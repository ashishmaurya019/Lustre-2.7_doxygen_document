<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: net</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>net<br/>
<small>
[<a class="el" href="group__PtlRPC.html">Portal RPC and networking module.</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for net:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__net.png" border="0" alt="" usemap="#group____net_map"/>
<map name="group____net_map" id="group____net">
<area shape="rect" id="node3" href="group__nrs.html" title="Service compatibility function; the policy is compatible with all services." alt="" coords="408,5,619,35"/><area shape="rect" id="node2" href="group__PtlRPC.html" title="PortalRPC is the layer used by rest of lustre code to achieve network communications:..." alt="" coords="5,5,264,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__replay__async__args.html">ptlrpc_replay_async_args</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__connection.html">ptlrpc_connection</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to single define portal connection.  <a href="structptlrpc__connection.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__client.html">ptlrpc_client</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Client definition for PortalRPC.  <a href="structptlrpc__client.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionptlrpc__async__args.html">ptlrpc_async_args</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of request set structure.  <a href="structptlrpc__request__set.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__set__cbdata.html">ptlrpc_set_cbdata</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Description of a single ptrlrpc_set callback.  <a href="structptlrpc__set__cbdata.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__cb__id.html">ptlrpc_cb_id</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ptlrpc callback &amp; work item stuff  <a href="structptlrpc__cb__id.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__reply__state.html">ptlrpc_reply_state</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to define reply state on the server Reply state holds various reply message information.  <a href="structptlrpc__reply__state.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of request pool structure.  <a href="structptlrpc__request__pool.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__hpreq__ops.html">ptlrpc_hpreq_ops</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic request prioritization operations structure.  <a href="structptlrpc__hpreq__ops.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__cli__req.html">ptlrpc_cli_req</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__srv__req.html">ptlrpc_srv_req</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__request.html">ptlrpc_request</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents remote procedure call.  <a href="structptlrpc__request.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__bulk__page.html">ptlrpc_bulk_page</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that defines a single page of a bulk transfer.  <a href="structptlrpc__bulk__page.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__thread.html">ptlrpc_thread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of server service thread structure.  <a href="structptlrpc__thread.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__request__buffer__desc.html">ptlrpc_request_buffer_desc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request buffer descriptor structure.  <a href="structptlrpc__request__buffer__desc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__service__ops.html">ptlrpc_service_ops</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__service.html">ptlrpc_service</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of PortalRPC service.  <a href="structptlrpc__service.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of PortalRPC service partition data.  <a href="structptlrpc__service__part.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpcd__ctl.html">ptlrpcd_ctl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declaration of ptlrpcd control structure.  <a href="structptlrpcd__ctl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__service__buf__conf.html">ptlrpc_service_buf_conf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__service__thr__conf.html">ptlrpc_service_thr_conf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__service__cpt__conf.html">ptlrpc_service_cpt_conf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__service__conf.html">ptlrpc_service_conf</a></td></tr>
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html">Network Request Scheduler</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Service compatibility function; the policy is compatible with all services. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga157c3f17a1c57b1a5f9bbe640e0b9c19"></a><!-- doxytag: member="net::PTLRPC_MD_OPTIONS" ref="ga157c3f17a1c57b1a5f9bbe640e0b9c19" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_MD_OPTIONS</b>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gabf4b4d7a3ddddab43ae78ddefc08af29">PTLRPC_BULK_OPS_BITS</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">log2 max # of bulk operations in one request: 2=4MB/RPC, 5=32MB/RPC, .  <a href="#gabf4b4d7a3ddddab43ae78ddefc08af29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga490cb13c3d4b02b157fd6a4629c872b4"></a><!-- doxytag: member="net::PTLRPC_BULK_OPS_COUNT" ref="ga490cb13c3d4b02b157fd6a4629c872b4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_BULK_OPS_COUNT</b>&nbsp;&nbsp;&nbsp;(1U &lt;&lt; PTLRPC_BULK_OPS_BITS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga8b841cf2fb3c1d1c92a9ddcf7068bb4c">PTLRPC_BULK_OPS_MASK</a>&nbsp;&nbsp;&nbsp;(~((__u64)PTLRPC_BULK_OPS_COUNT - 1))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PTLRPC_BULK_OPS_MASK is for the convenience of the client only, and should not be used on the server at all.  <a href="#ga8b841cf2fb3c1d1c92a9ddcf7068bb4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga507b0acc65154a8e8842879d5f4db30b">PTLRPC_MAX_BRW_BITS</a>&nbsp;&nbsp;&nbsp;(LNET_MTU_BITS + PTLRPC_BULK_OPS_BITS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define maxima for bulk I/O.  <a href="#ga507b0acc65154a8e8842879d5f4db30b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga395e088d87586ef8ceaca1aea618c60f"></a><!-- doxytag: member="net::PTLRPC_MAX_BRW_SIZE" ref="ga395e088d87586ef8ceaca1aea618c60f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_MAX_BRW_SIZE</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; PTLRPC_MAX_BRW_BITS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaced9eb537787b1e8c157fc7a3e1c167b"></a><!-- doxytag: member="net::PTLRPC_MAX_BRW_PAGES" ref="gaced9eb537787b1e8c157fc7a3e1c167b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_MAX_BRW_PAGES</b>&nbsp;&nbsp;&nbsp;(PTLRPC_MAX_BRW_SIZE &gt;&gt; PAGE_CACHE_SHIFT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81c21f2171d6912a36ca02da217084d4"></a><!-- doxytag: member="net::ONE_MB_BRW_SIZE" ref="ga81c21f2171d6912a36ca02da217084d4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ONE_MB_BRW_SIZE</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; LNET_MTU_BITS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54b813af48fd306d714dfe5d2dd9dcbe"></a><!-- doxytag: member="net::MD_MAX_BRW_SIZE" ref="ga54b813af48fd306d714dfe5d2dd9dcbe" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MD_MAX_BRW_SIZE</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; LNET_MTU_BITS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga61910e6afc32b8b9a825cafee843d10f"></a><!-- doxytag: member="net::MD_MAX_BRW_PAGES" ref="ga61910e6afc32b8b9a825cafee843d10f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MD_MAX_BRW_PAGES</b>&nbsp;&nbsp;&nbsp;(MD_MAX_BRW_SIZE &gt;&gt; PAGE_CACHE_SHIFT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga42b91fc3e95a0fbbd654180940faa261"></a><!-- doxytag: member="net::DT_MAX_BRW_SIZE" ref="ga42b91fc3e95a0fbbd654180940faa261" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DT_MAX_BRW_SIZE</b>&nbsp;&nbsp;&nbsp;PTLRPC_MAX_BRW_SIZE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a54fcc98e16a4f9a812a2fa76cd5b20"></a><!-- doxytag: member="net::DT_MAX_BRW_PAGES" ref="ga1a54fcc98e16a4f9a812a2fa76cd5b20" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DT_MAX_BRW_PAGES</b>&nbsp;&nbsp;&nbsp;(DT_MAX_BRW_SIZE &gt;&gt; PAGE_CACHE_SHIFT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3a380e2199f126c6bf7b690f8d50c886"></a><!-- doxytag: member="net::OFD_MAX_BRW_SIZE" ref="ga3a380e2199f126c6bf7b690f8d50c886" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OFD_MAX_BRW_SIZE</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; LNET_MTU_BITS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe956408171741e4f2fa929087b87a26"></a><!-- doxytag: member="net::PTLRPC_NTHRS_INIT" ref="gafe956408171741e4f2fa929087b87a26" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_NTHRS_INIT</b>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga3a944e6b359ce130537f3ab0efdd5a2a">LDLM_THR_FACTOR</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Buffer Constants.  <a href="#ga3a944e6b359ce130537f3ab0efdd5a2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga742311d34141ab6eaee328dfcc72b488"></a><!-- doxytag: member="net::LDLM_NTHRS_INIT" ref="ga742311d34141ab6eaee328dfcc72b488" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_NTHRS_INIT</b>&nbsp;&nbsp;&nbsp;PTLRPC_NTHRS_INIT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0a61d5a753e8c5c555e50e636722e399"></a><!-- doxytag: member="net::LDLM_NTHRS_BASE" ref="ga0a61d5a753e8c5c555e50e636722e399" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_NTHRS_BASE</b>&nbsp;&nbsp;&nbsp;24</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga46d108e558ab6d0e3198f65c876d1a81"></a><!-- doxytag: member="net::LDLM_NTHRS_MAX" ref="ga46d108e558ab6d0e3198f65c876d1a81" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_NTHRS_MAX</b>&nbsp;&nbsp;&nbsp;(num_online_cpus() == 1 ? 64 : 128)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7394435c900a8c54f6b95170c88935e6"></a><!-- doxytag: member="net::LDLM_BL_THREADS" ref="ga7394435c900a8c54f6b95170c88935e6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_BL_THREADS</b>&nbsp;&nbsp;&nbsp;LDLM_NTHRS_AUTO_INIT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6083e4e11e92c0e1899135e1ecb0d8e0"></a><!-- doxytag: member="net::LDLM_CLIENT_NBUFS" ref="ga6083e4e11e92c0e1899135e1ecb0d8e0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_CLIENT_NBUFS</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga799922177ad620208dc9b06071f692db"></a><!-- doxytag: member="net::LDLM_SERVER_NBUFS" ref="ga799922177ad620208dc9b06071f692db" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_SERVER_NBUFS</b>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga49bb95cb76972aaca8e816575cd02aca"></a><!-- doxytag: member="net::LDLM_BUFSIZE" ref="ga49bb95cb76972aaca8e816575cd02aca" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_BUFSIZE</b>&nbsp;&nbsp;&nbsp;(8 * 1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9e405949bcdca22d07e59f01c2a49472"></a><!-- doxytag: member="net::LDLM_MAXREQSIZE" ref="ga9e405949bcdca22d07e59f01c2a49472" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_MAXREQSIZE</b>&nbsp;&nbsp;&nbsp;(5 * 1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacff8051eb06c1171b24729b4bf074eda"></a><!-- doxytag: member="net::LDLM_MAXREPSIZE" ref="gacff8051eb06c1171b24729b4bf074eda" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_MAXREPSIZE</b>&nbsp;&nbsp;&nbsp;(1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39960ff74dd6e99afa9493eef0cfafc9"></a><!-- doxytag: member="net::MDS_MAX_THREADS" ref="ga39960ff74dd6e99afa9493eef0cfafc9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_MAX_THREADS</b>&nbsp;&nbsp;&nbsp;1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2803f1a066b1b5eb624606097c73ed86"></a><!-- doxytag: member="net::MDS_MAX_OTHR_THREADS" ref="ga2803f1a066b1b5eb624606097c73ed86" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_MAX_OTHR_THREADS</b>&nbsp;&nbsp;&nbsp;256</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70e59b7c463e86e27ccb8b5b22048a47"></a><!-- doxytag: member="net::MDS_THR_FACTOR" ref="ga70e59b7c463e86e27ccb8b5b22048a47" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_THR_FACTOR</b>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbbfd3d72987bb9721f9fb62007731d4"></a><!-- doxytag: member="net::MDS_NTHRS_INIT" ref="gabbbfd3d72987bb9721f9fb62007731d4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_NTHRS_INIT</b>&nbsp;&nbsp;&nbsp;PTLRPC_NTHRS_INIT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga244fa4230dc897399f3dff88dda960ad"></a><!-- doxytag: member="net::MDS_NTHRS_MAX" ref="ga244fa4230dc897399f3dff88dda960ad" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_NTHRS_MAX</b>&nbsp;&nbsp;&nbsp;MDS_MAX_THREADS</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2efb8ac49c003b862962fb21e081518d"></a><!-- doxytag: member="net::MDS_NTHRS_BASE" ref="ga2efb8ac49c003b862962fb21e081518d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_NTHRS_BASE</b>&nbsp;&nbsp;&nbsp;min(64, MDS_NTHRS_MAX)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa4116fa3846b0121ef81329010562804"></a><!-- doxytag: member="net::MDS_RDPG_THR_FACTOR" ref="gaa4116fa3846b0121ef81329010562804" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_RDPG_THR_FACTOR</b>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga414913daf8e5db5aca77861890f3f2e0"></a><!-- doxytag: member="net::MDS_RDPG_NTHRS_INIT" ref="ga414913daf8e5db5aca77861890f3f2e0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_RDPG_NTHRS_INIT</b>&nbsp;&nbsp;&nbsp;PTLRPC_NTHRS_INIT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga436352d1f9885c24a128201572e3e7d2"></a><!-- doxytag: member="net::MDS_RDPG_NTHRS_MAX" ref="ga436352d1f9885c24a128201572e3e7d2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_RDPG_NTHRS_MAX</b>&nbsp;&nbsp;&nbsp;MDS_MAX_OTHR_THREADS</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab69d130f17c0596b5a286a42dfe6d92a"></a><!-- doxytag: member="net::MDS_RDPG_NTHRS_BASE" ref="gab69d130f17c0596b5a286a42dfe6d92a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_RDPG_NTHRS_BASE</b>&nbsp;&nbsp;&nbsp;min(48, MDS_RDPG_NTHRS_MAX)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga28af3ce9f210352a4949b4fd36bf8335"></a><!-- doxytag: member="net::MDS_SETA_THR_FACTOR" ref="ga28af3ce9f210352a4949b4fd36bf8335" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_SETA_THR_FACTOR</b>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga37496fd9a199fae4bb9b2371ef7b6168"></a><!-- doxytag: member="net::MDS_SETA_NTHRS_INIT" ref="ga37496fd9a199fae4bb9b2371ef7b6168" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_SETA_NTHRS_INIT</b>&nbsp;&nbsp;&nbsp;PTLRPC_NTHRS_INIT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4e0c711cd3f8b3593ed725caa5319d4f"></a><!-- doxytag: member="net::MDS_SETA_NTHRS_MAX" ref="ga4e0c711cd3f8b3593ed725caa5319d4f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_SETA_NTHRS_MAX</b>&nbsp;&nbsp;&nbsp;MDS_MAX_OTHR_THREADS</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga12e70004dc735fd050b4fd3249bf0f5c"></a><!-- doxytag: member="net::MDS_SETA_NTHRS_BASE" ref="ga12e70004dc735fd050b4fd3249bf0f5c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_SETA_NTHRS_BASE</b>&nbsp;&nbsp;&nbsp;min(48, MDS_SETA_NTHRS_MAX)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga552f6644a8116b4b4cd9fd1e779f80a0"></a><!-- doxytag: member="net::MDS_OTHR_NTHRS_INIT" ref="ga552f6644a8116b4b4cd9fd1e779f80a0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_OTHR_NTHRS_INIT</b>&nbsp;&nbsp;&nbsp;PTLRPC_NTHRS_INIT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a07faf92c59ff2070faa8efaa057ffb"></a><!-- doxytag: member="net::MDS_OTHR_NTHRS_MAX" ref="ga4a07faf92c59ff2070faa8efaa057ffb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_OTHR_NTHRS_MAX</b>&nbsp;&nbsp;&nbsp;MDS_MAX_OTHR_THREADS</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a471dccc8fdd69639438f1ed9eadf71"></a><!-- doxytag: member="net::MDS_NBUFS" ref="ga9a471dccc8fdd69639438f1ed9eadf71" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_NBUFS</b>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga0925bdb5333dd708e0aa362a7b859f87">MDS_MAXREQSIZE</a>&nbsp;&nbsp;&nbsp;(5 * 1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assume file name length = FNAME_MAX = 256 (true for ext3).  <a href="#ga0925bdb5333dd708e0aa362a7b859f87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d5ce2bf1f1ae98e02bc257cd69fd129"></a><!-- doxytag: member="net::MDS_MAXREPSIZE" ref="ga0d5ce2bf1f1ae98e02bc257cd69fd129" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_MAXREPSIZE</b>&nbsp;&nbsp;&nbsp;(9 * 1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga30f21c5f8837df1463edffb20d62a4f2">MDS_LOV_MAXREQSIZE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MDS incoming request with LOV EA 24 = sizeof(struct lov_ost_data), i.e: replay of opencreate.  <a href="#ga30f21c5f8837df1463edffb20d62a4f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gacacc3457857ade161935c93720109685">MDS_LOV_MAXREPSIZE</a>&nbsp;&nbsp;&nbsp;MDS_LOV_MAXREQSIZE</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MDS outgoing reply with LOV EA.  <a href="#gacacc3457857ade161935c93720109685"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga11a8ca7b7077906bf6d328588ec4dec4">MDS_EA_MAXREQSIZE</a>&nbsp;&nbsp;&nbsp;66288</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the size of a maximum REINT_SETXATTR request:.  <a href="#ga11a8ca7b7077906bf6d328588ec4dec4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga55304816884c7b0a95e492ced0d476ff">MDS_REG_MAXREQSIZE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These are the maximum request and reply sizes (rounded up to 1 KB boundaries) for the "regular" MDS_REQUEST_PORTAL and MDS_REPLY_PORTAL.  <a href="#ga55304816884c7b0a95e492ced0d476ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafcd9831ec8cedfbf10a6796bea541b46"></a><!-- doxytag: member="net::MDS_REG_MAXREPSIZE" ref="gafcd9831ec8cedfbf10a6796bea541b46" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MDS_REG_MAXREPSIZE</b>&nbsp;&nbsp;&nbsp;MDS_REG_MAXREQSIZE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3061b67fa028fa7ea59239b69b10c911"></a><!-- doxytag: member="net::OUT_MAXREQSIZE" ref="ga3061b67fa028fa7ea59239b69b10c911" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga3061b67fa028fa7ea59239b69b10c911">OUT_MAXREQSIZE</a>&nbsp;&nbsp;&nbsp;(1000 * 1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The update request includes all of updates from the create, which might include linkea (4K maxim), together with other updates, we set it to 1000K: lustre_msg + ptlrpc_body + OUT_UPDATE_BUFFER_SIZE_MAX. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5ddee6a7625595767bc2e1e6e35cbcf"></a><!-- doxytag: member="net::OUT_MAXREPSIZE" ref="gad5ddee6a7625595767bc2e1e6e35cbcf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OUT_MAXREPSIZE</b>&nbsp;&nbsp;&nbsp;MDS_MAXREPSIZE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga89120bf4c91617f84fb648d3445c4d0d">MDS_BUFSIZE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MDS_BUFSIZE = max_reqsize (w/o LOV EA) + max sptlrpc payload size.  <a href="#ga89120bf4c91617f84fb648d3445c4d0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gace39c2a24b8ed087135caf8102925f80">MDS_REG_BUFSIZE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MDS_REG_BUFSIZE should at least be MDS_REG_MAXREQSIZE + SPTLRPC_MAX_PAYLOAD.  <a href="#gace39c2a24b8ed087135caf8102925f80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gae34be12e43c77807e8487670d8c4b119">OUT_BUFSIZE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OUT_BUFSIZE = max_out_reqsize + max sptlrpc payload (~1K) which is about 10K, for the same reason as MDS_REG_BUFSIZE, we also give some extra bytes to each request buffer to improve buffer utilization rate.  <a href="#gae34be12e43c77807e8487670d8c4b119"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc6001cafee4a86e6ce9e3c564300fba"></a><!-- doxytag: member="net::FLD_MAXREQSIZE" ref="gacc6001cafee4a86e6ce9e3c564300fba" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gacc6001cafee4a86e6ce9e3c564300fba">FLD_MAXREQSIZE</a>&nbsp;&nbsp;&nbsp;(160)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FLD_MAXREQSIZE == lustre_msg + __u32 padding + ptlrpc_body + opc. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79a13640cdfd7899d81028fd45849e20"></a><!-- doxytag: member="net::FLD_MAXREPSIZE" ref="ga79a13640cdfd7899d81028fd45849e20" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga79a13640cdfd7899d81028fd45849e20">FLD_MAXREPSIZE</a>&nbsp;&nbsp;&nbsp;(152)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FLD_MAXREPSIZE == lustre_msg + ptlrpc_body. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac06737cf90ac519d7b893a73c556e1d7"></a><!-- doxytag: member="net::FLD_BUFSIZE" ref="gac06737cf90ac519d7b893a73c556e1d7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>FLD_BUFSIZE</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 12)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab00780470dc1dda21d5107cb3439968b"></a><!-- doxytag: member="net::SEQ_MAXREQSIZE" ref="gab00780470dc1dda21d5107cb3439968b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gab00780470dc1dda21d5107cb3439968b">SEQ_MAXREQSIZE</a>&nbsp;&nbsp;&nbsp;(160)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SEQ_MAXREQSIZE == lustre_msg + __u32 padding + ptlrpc_body + opc + lu_range + __u32 padding. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad213a2a89d144bd859084578eb412571"></a><!-- doxytag: member="net::SEQ_MAXREPSIZE" ref="gad213a2a89d144bd859084578eb412571" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gad213a2a89d144bd859084578eb412571">SEQ_MAXREPSIZE</a>&nbsp;&nbsp;&nbsp;(152)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SEQ_MAXREPSIZE == lustre_msg + ptlrpc_body + lu_range. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd5b9f5ebcda42209dd76180511dfb16"></a><!-- doxytag: member="net::SEQ_BUFSIZE" ref="gadd5b9f5ebcda42209dd76180511dfb16" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>SEQ_BUFSIZE</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 12)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga12eb8c4f6e3d563a0e5896e9c2b220d5"></a><!-- doxytag: member="net::MGS_NTHRS_INIT" ref="ga12eb8c4f6e3d563a0e5896e9c2b220d5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga12eb8c4f6e3d563a0e5896e9c2b220d5">MGS_NTHRS_INIT</a>&nbsp;&nbsp;&nbsp;(PTLRPC_NTHRS_INIT + 1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MGS threads must be &gt;= 3, see bug 22458 comment #28. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5c93971749de996a29cf22f9897f91a5"></a><!-- doxytag: member="net::MGS_NTHRS_MAX" ref="ga5c93971749de996a29cf22f9897f91a5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGS_NTHRS_MAX</b>&nbsp;&nbsp;&nbsp;32</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70a22720391d9716047d981002f41e0f"></a><!-- doxytag: member="net::MGS_NBUFS" ref="ga70a22720391d9716047d981002f41e0f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGS_NBUFS</b>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05f77b5b40b7665ed4bad5e99cb3914b"></a><!-- doxytag: member="net::MGS_BUFSIZE" ref="ga05f77b5b40b7665ed4bad5e99cb3914b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGS_BUFSIZE</b>&nbsp;&nbsp;&nbsp;(8 * 1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga058f6c5763d4ec6ed56d27894c129c4d"></a><!-- doxytag: member="net::MGS_MAXREQSIZE" ref="ga058f6c5763d4ec6ed56d27894c129c4d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGS_MAXREQSIZE</b>&nbsp;&nbsp;&nbsp;(7 * 1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga09696fdc67a516b616641018d7f01a8b"></a><!-- doxytag: member="net::MGS_MAXREPSIZE" ref="ga09696fdc67a516b616641018d7f01a8b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGS_MAXREPSIZE</b>&nbsp;&nbsp;&nbsp;(9 * 1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSS_THR_FACTOR</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac1472096f107f464745434d858967198"></a><!-- doxytag: member="net::OSS_NTHRS_INIT" ref="gac1472096f107f464745434d858967198" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSS_NTHRS_INIT</b>&nbsp;&nbsp;&nbsp;(PTLRPC_NTHRS_INIT + 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6831cd1d9b4ce57e6228ccd81cc5644c"></a><!-- doxytag: member="net::OSS_NTHRS_BASE" ref="ga6831cd1d9b4ce57e6228ccd81cc5644c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSS_NTHRS_BASE</b>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74852f44edc643dfad53455c1a94e39d"></a><!-- doxytag: member="net::OSS_CR_THR_FACTOR" ref="ga74852f44edc643dfad53455c1a94e39d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSS_CR_THR_FACTOR</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8852ea575dae46f58a5e069b2530e9f3"></a><!-- doxytag: member="net::OSS_CR_NTHRS_INIT" ref="ga8852ea575dae46f58a5e069b2530e9f3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSS_CR_NTHRS_INIT</b>&nbsp;&nbsp;&nbsp;PTLRPC_NTHRS_INIT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaedf87039c07092efbe0505eb87154423"></a><!-- doxytag: member="net::OSS_CR_NTHRS_BASE" ref="gaedf87039c07092efbe0505eb87154423" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSS_CR_NTHRS_BASE</b>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec7ab227158f64ddb130f678bc4965fe"></a><!-- doxytag: member="net::OSS_CR_NTHRS_MAX" ref="gaec7ab227158f64ddb130f678bc4965fe" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSS_CR_NTHRS_MAX</b>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga7effbcacfc90f58c6e550e8441ee9b5d">_OST_MAXREQSIZE_SUM</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OST_IO_MAXREQSIZE ~= lustre_msg + ptlrpc_body + <a class="el" href="structobdo.html">obdo</a> + <a class="el" href="structobd__ioobj.html">obd_ioobj</a> + DT_MAX_BRW_PAGES * <a class="el" href="structniobuf__remote.html">niobuf_remote</a>.  <a href="#ga7effbcacfc90f58c6e550e8441ee9b5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga90591733c0c1eee622c2b8b512fd89e3"></a><!-- doxytag: member="net::OST_MAXREQSIZE" ref="ga90591733c0c1eee622c2b8b512fd89e3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga90591733c0c1eee622c2b8b512fd89e3">OST_MAXREQSIZE</a>&nbsp;&nbsp;&nbsp;(16 * 1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FIEMAP request can be 4K+ for now. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OST_IO_MAXREQSIZE</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d46c61bf1187782e6eb6867ac91f146"></a><!-- doxytag: member="net::OST_MAXREPSIZE" ref="ga0d46c61bf1187782e6eb6867ac91f146" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OST_MAXREPSIZE</b>&nbsp;&nbsp;&nbsp;(9 * 1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga315fc498b63260468a9e2be3229d5bbd"></a><!-- doxytag: member="net::OST_IO_MAXREPSIZE" ref="ga315fc498b63260468a9e2be3229d5bbd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OST_IO_MAXREPSIZE</b>&nbsp;&nbsp;&nbsp;OST_MAXREPSIZE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab72ba326b290df7189c8e5360ea6f8c1"></a><!-- doxytag: member="net::OST_NBUFS" ref="gab72ba326b290df7189c8e5360ea6f8c1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OST_NBUFS</b>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gade43b8059a7940089671f1c160b97e8b"></a><!-- doxytag: member="net::OST_BUFSIZE" ref="gade43b8059a7940089671f1c160b97e8b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gade43b8059a7940089671f1c160b97e8b">OST_BUFSIZE</a>&nbsp;&nbsp;&nbsp;max_t(int, OST_MAXREQSIZE + 1024, 16 * 1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OST_BUFSIZE = max_reqsize + max sptlrpc payload size. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga112461e50f5b4ce6d060c31e89002f4a"></a><!-- doxytag: member="net::OST_IO_BUFSIZE" ref="ga112461e50f5b4ce6d060c31e89002f4a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga112461e50f5b4ce6d060c31e89002f4a">OST_IO_BUFSIZE</a>&nbsp;&nbsp;&nbsp;max_t(int, OST_IO_MAXREQSIZE + 1024, 64 * 1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OST_IO_MAXREQSIZE is 18K, giving extra 46K can increase buffer utilization rate of request buffer, please check comment of MDS_LOV_BUFSIZE for details. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50f2542bf0ac863d6ef21de92a35c915"></a><!-- doxytag: member="net::ptlrpc_req_async_args" ref="ga50f2542bf0ac863d6ef21de92a35c915" args="(req)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_req_async_args</b>(req)&nbsp;&nbsp;&nbsp;((void *)&amp;req-&gt;rq_async_args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9360fd394863fc72262f905536407ea"></a><!-- doxytag: member="net::PTL_RPC_FL_INTR" ref="gab9360fd394863fc72262f905536407ea" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gab9360fd394863fc72262f905536407ea">PTL_RPC_FL_INTR</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">state flags of requests <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab36c9b4e63763d4ccd5dd8d83fc9e117"></a><!-- doxytag: member="net::PTL_RPC_FL_TIMEOUT" ref="gab36c9b4e63763d4ccd5dd8d83fc9e117" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTL_RPC_FL_TIMEOUT</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 7)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga193cc5955f0b02b74eda762a7fe7ab05"></a><!-- doxytag: member="net::REQ_MAX_ACK_LOCKS" ref="ga193cc5955f0b02b74eda762a7fe7ab05" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REQ_MAX_ACK_LOCKS</b>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2d55f86d607f2386cec08e37daa7ce67"></a><!-- doxytag: member="net::RS_MAX_LOCKS" ref="ga2d55f86d607f2386cec08e37daa7ce67" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga2d55f86d607f2386cec08e37daa7ce67">RS_MAX_LOCKS</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of locks to fit into reply state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga107a0dc89278a5fa763fa802d8943c51"></a><!-- doxytag: member="net::RS_DEBUG" ref="ga107a0dc89278a5fa763fa802d8943c51" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>RS_DEBUG</b>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a02f006a097fc5c4f7da0fe2ee8f763"></a><!-- doxytag: member="net::rq_bulk" ref="ga4a02f006a097fc5c4f7da0fe2ee8f763" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga4a02f006a097fc5c4f7da0fe2ee8f763">rq_bulk</a>&nbsp;&nbsp;&nbsp;rq_cli.cr_bulk</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">client request member alias <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9d9c34968982339330a987fed9d607c5"></a><!-- doxytag: member="net::rq_delay_limit" ref="ga9d9c34968982339330a987fed9d607c5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_delay_limit</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_delay_limit</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ba1a1449da0935a71803b0119aa5821"></a><!-- doxytag: member="net::rq_queued_time" ref="ga5ba1a1449da0935a71803b0119aa5821" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_queued_time</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_queued_time</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga444c0b4670f0bdb9bec6cf62c88bf815"></a><!-- doxytag: member="net::rq_sent_tv" ref="ga444c0b4670f0bdb9bec6cf62c88bf815" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_sent_tv</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_sent_tv</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa9fb935c2a6cfc5cc0633cbfa8e0059c"></a><!-- doxytag: member="net::rq_real_sent" ref="gaa9fb935c2a6cfc5cc0633cbfa8e0059c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_real_sent</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_sent_out</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad92d8fece9ae0bc064cffe9f29ebb58a"></a><!-- doxytag: member="net::rq_reply_deadline" ref="gad92d8fece9ae0bc064cffe9f29ebb58a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_reply_deadline</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_reply_deadline</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a3aced83b8099658d3fcd2575917545"></a><!-- doxytag: member="net::rq_bulk_deadline" ref="ga9a3aced83b8099658d3fcd2575917545" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_bulk_deadline</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_bulk_deadline</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae93bda6757ee4aa06739faf9ba481292"></a><!-- doxytag: member="net::rq_nr_resend" ref="gae93bda6757ee4aa06739faf9ba481292" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_nr_resend</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_resend_nr</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa29a817016207b9b9a73d5280dc98785"></a><!-- doxytag: member="net::rq_request_portal" ref="gaa29a817016207b9b9a73d5280dc98785" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_request_portal</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_req_ptl</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7b35b9e672d0815c98c90744a974e0fd"></a><!-- doxytag: member="net::rq_reply_portal" ref="ga7b35b9e672d0815c98c90744a974e0fd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_reply_portal</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_rep_ptl</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabd13173c467193f92437df63e96243a6"></a><!-- doxytag: member="net::rq_import_generation" ref="gabd13173c467193f92437df63e96243a6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_import_generation</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_imp_gen</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5196aa2a46336b5a6e9ca2f24574556"></a><!-- doxytag: member="net::rq_send_state" ref="gac5196aa2a46336b5a6e9ca2f24574556" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_send_state</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_send_state</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabfd771a992570154c4e73515249dcd07"></a><!-- doxytag: member="net::rq_set_chain" ref="gabfd771a992570154c4e73515249dcd07" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_set_chain</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_set_chain</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga260bae7d8e2e57b19fa5c10b3431fd3a"></a><!-- doxytag: member="net::rq_ctx_chain" ref="ga260bae7d8e2e57b19fa5c10b3431fd3a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_ctx_chain</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_ctx_chain</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6029c7d984fb697afe175a22a0db561a"></a><!-- doxytag: member="net::rq_set" ref="ga6029c7d984fb697afe175a22a0db561a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_set</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_set</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0ad4e49bf7a15d898a8adf3232a2296"></a><!-- doxytag: member="net::rq_set_waitq" ref="gab0ad4e49bf7a15d898a8adf3232a2296" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_set_waitq</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_set_waitq</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a6f69e4eaf87b4ca4325297c57003e0"></a><!-- doxytag: member="net::rq_cli_ctx" ref="ga7a6f69e4eaf87b4ca4325297c57003e0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_cli_ctx</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_cli_ctx</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2d5d03805a7f64b890c4908f134ae03"></a><!-- doxytag: member="net::rq_req_md_h" ref="gaa2d5d03805a7f64b890c4908f134ae03" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_req_md_h</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_req_md_h</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7393772a0fab787b31b47b88a6c46699"></a><!-- doxytag: member="net::rq_req_cbid" ref="ga7393772a0fab787b31b47b88a6c46699" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_req_cbid</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_req_cbid</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8ed9127b2ba7b8bad5e4a61f7b3b437d"></a><!-- doxytag: member="net::rq_reply_md_h" ref="ga8ed9127b2ba7b8bad5e4a61f7b3b437d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_reply_md_h</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_reply_md_h</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae124821a8b96d1bcb852adf7f3260749"></a><!-- doxytag: member="net::rq_reply_waitq" ref="gae124821a8b96d1bcb852adf7f3260749" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_reply_waitq</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_reply_waitq</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaebd30d82a1f9ba76415ccb0d8a0305af"></a><!-- doxytag: member="net::rq_reply_cbid" ref="gaebd30d82a1f9ba76415ccb0d8a0305af" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_reply_cbid</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_reply_cbid</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbdf7e18aa80cda2d76ec721eb5ee9de"></a><!-- doxytag: member="net::rq_interpret_reply" ref="gabbdf7e18aa80cda2d76ec721eb5ee9de" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_interpret_reply</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_reply_interp</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5780584dd0147f19146bfaafac2ab6c"></a><!-- doxytag: member="net::rq_resend_cb" ref="gac5780584dd0147f19146bfaafac2ab6c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_resend_cb</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_resend_cb</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga18f45126e72f2e66a52df266e2247cfd"></a><!-- doxytag: member="net::rq_async_args" ref="ga18f45126e72f2e66a52df266e2247cfd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_async_args</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_async_args</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b441d4d8961259f97a771fcb9cce42f"></a><!-- doxytag: member="net::rq_cb_data" ref="ga0b441d4d8961259f97a771fcb9cce42f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_cb_data</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_cb_data</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3015a78a5f6445df6147ecb92a5db36"></a><!-- doxytag: member="net::rq_unreplied_list" ref="gaf3015a78a5f6445df6147ecb92a5db36" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_unreplied_list</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_unreplied_list</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab31576d9718505a24cae616b37fbebdb"></a><!-- doxytag: member="net::rq_commit_cb" ref="gab31576d9718505a24cae616b37fbebdb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_commit_cb</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_commit_cb</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a5d664562476237852261beca3ad137"></a><!-- doxytag: member="net::rq_replay_cb" ref="ga6a5d664562476237852261beca3ad137" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_replay_cb</b>&nbsp;&nbsp;&nbsp;rq_cli.cr_replay_cb</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2add693a51a7d38acaced35e27bdc861"></a><!-- doxytag: member="net::rq_svc_thread" ref="ga2add693a51a7d38acaced35e27bdc861" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga2add693a51a7d38acaced35e27bdc861">rq_svc_thread</a>&nbsp;&nbsp;&nbsp;rq_srv.sr_svc_thread</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">server request member alias <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc0944ef09687a9201caa304a2fd3df7"></a><!-- doxytag: member="net::rq_timed_list" ref="gacc0944ef09687a9201caa304a2fd3df7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_timed_list</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_timed_list</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga065abc2354b8e9dbc0b029924d8097d8"></a><!-- doxytag: member="net::rq_exp_list" ref="ga065abc2354b8e9dbc0b029924d8097d8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_exp_list</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_exp_list</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a45b03f5ec0266755273e5df8c368e4"></a><!-- doxytag: member="net::rq_history_list" ref="ga2a45b03f5ec0266755273e5df8c368e4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_history_list</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_hist_list</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga689598ddfa8c58809fbcde6208a045cd"></a><!-- doxytag: member="net::rq_history_seq" ref="ga689598ddfa8c58809fbcde6208a045cd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_history_seq</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_hist_seq</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e73b5ff48a1bd26cc3728e59c7bc4d0"></a><!-- doxytag: member="net::rq_at_index" ref="ga8e73b5ff48a1bd26cc3728e59c7bc4d0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_at_index</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_at_index</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ed6c8bebdf3ff9e12e82ccb6ffd8773"></a><!-- doxytag: member="net::rq_auth_uid" ref="ga2ed6c8bebdf3ff9e12e82ccb6ffd8773" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_auth_uid</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_auth_uid</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga500b12cb611e13a6bc2490af0f864176"></a><!-- doxytag: member="net::rq_auth_mapped_uid" ref="ga500b12cb611e13a6bc2490af0f864176" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_auth_mapped_uid</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_auth_mapped_uid</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e62fe7162ef90540262c1f8bc43e909"></a><!-- doxytag: member="net::rq_sp_from" ref="ga1e62fe7162ef90540262c1f8bc43e909" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_sp_from</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_sp_from</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39b8ab55f7009414e7eda35c24322fed"></a><!-- doxytag: member="net::rq_session" ref="ga39b8ab55f7009414e7eda35c24322fed" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_session</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_ses</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga688ee7185a479edf36de5b9313563ad1"></a><!-- doxytag: member="net::rq_nrq" ref="ga688ee7185a479edf36de5b9313563ad1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_nrq</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_nrq</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa824576728341fb0354931d5897bc7f7"></a><!-- doxytag: member="net::rq_arrival_time" ref="gaa824576728341fb0354931d5897bc7f7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_arrival_time</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_arrival_time</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b70d095a2065c3544bdc6725ea690d8"></a><!-- doxytag: member="net::rq_reply_state" ref="ga0b70d095a2065c3544bdc6725ea690d8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_reply_state</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_reply_state</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga49196d810b2839d9156bfc7177339dbb"></a><!-- doxytag: member="net::rq_svc_ctx" ref="ga49196d810b2839d9156bfc7177339dbb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_svc_ctx</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_svc_ctx</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a258cad4a3ee6de482ca2d021d2fa8e"></a><!-- doxytag: member="net::rq_user_desc" ref="ga6a258cad4a3ee6de482ca2d021d2fa8e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_user_desc</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_user_desc</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga181db0d552d641a21c1664c6c17e1a78"></a><!-- doxytag: member="net::rq_ops" ref="ga181db0d552d641a21c1664c6c17e1a78" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_ops</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_ops</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0072c0a48cd4c776e94dac6eab282d2e"></a><!-- doxytag: member="net::rq_rqbd" ref="ga0072c0a48cd4c776e94dac6eab282d2e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rq_rqbd</b>&nbsp;&nbsp;&nbsp;rq_srv.sr_rqbd</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga276fb42e2ae30a776be3e2ca52e1c639"></a><!-- doxytag: member="net::GET_KIOV" ref="ga276fb42e2ae30a776be3e2ca52e1c639" args="(desc)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GET_KIOV</b>(desc)&nbsp;&nbsp;&nbsp;((desc)-&gt;bd_u.bd_kiov.bd_vec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab52fff79731198f0294f477ef3ccddcc"></a><!-- doxytag: member="net::BD_GET_KIOV" ref="gab52fff79731198f0294f477ef3ccddcc" args="(desc, i)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BD_GET_KIOV</b>(desc, i)&nbsp;&nbsp;&nbsp;((desc)-&gt;bd_u.bd_kiov.bd_vec[i])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a3c902c301b0b12cc40da5114a1a149"></a><!-- doxytag: member="net::GET_ENC_KIOV" ref="ga9a3c902c301b0b12cc40da5114a1a149" args="(desc)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GET_ENC_KIOV</b>(desc)&nbsp;&nbsp;&nbsp;((desc)-&gt;bd_u.bd_kiov.bd_enc_vec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5baa8a2e70b353ac8b84a4e4da0569a4"></a><!-- doxytag: member="net::BD_GET_ENC_KIOV" ref="ga5baa8a2e70b353ac8b84a4e4da0569a4" args="(desc, i)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BD_GET_ENC_KIOV</b>(desc, i)&nbsp;&nbsp;&nbsp;((desc)-&gt;bd_u.bd_kiov.bd_enc_vec[i])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga93c531cfacf63d7648b1b721a303ae18"></a><!-- doxytag: member="net::GET_KVEC" ref="ga93c531cfacf63d7648b1b721a303ae18" args="(desc)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GET_KVEC</b>(desc)&nbsp;&nbsp;&nbsp;((desc)-&gt;bd_u.bd_kvec.bd_kvec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e243fefd309d6957a22fb18abbc771f"></a><!-- doxytag: member="net::BD_GET_KVEC" ref="ga1e243fefd309d6957a22fb18abbc771f" args="(desc, i)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BD_GET_KVEC</b>(desc, i)&nbsp;&nbsp;&nbsp;((desc)-&gt;bd_u.bd_kvec.bd_kvec[i])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa0a201cc3605a702ee388ddacfced386"></a><!-- doxytag: member="net::GET_ENC_KVEC" ref="gaa0a201cc3605a702ee388ddacfced386" args="(desc)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GET_ENC_KVEC</b>(desc)&nbsp;&nbsp;&nbsp;((desc)-&gt;bd_u.bd_kvec.bd_enc_kvec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5746331f6d15148a4f3ed22ca6fe595d"></a><!-- doxytag: member="net::BD_GET_ENC_KVEC" ref="ga5746331f6d15148a4f3ed22ca6fe595d" args="(desc, i)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BD_GET_ENC_KVEC</b>(desc, i)&nbsp;&nbsp;&nbsp;((desc)-&gt;bd_u.bd_kvec.bd_enc_kvec[i])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc35cc21ab702063983586056094d6c3"></a><!-- doxytag: member="net::PTLRPC_THR_NAME_LEN" ref="gacc35cc21ab702063983586056094d6c3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_THR_NAME_LEN</b>&nbsp;&nbsp;&nbsp;32</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f4d7f4b592db13b248e9f0973608f71"></a><!-- doxytag: member="net::PTLRPC_SVC_HP_RATIO" ref="ga4f4d7f4b592db13b248e9f0973608f71" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga4f4d7f4b592db13b248e9f0973608f71">PTLRPC_SVC_HP_RATIO</a>&nbsp;&nbsp;&nbsp;10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">How many high priority requests to serve before serving one normal priority request. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_service_for_each_part</b>(part, i, svc)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8ba8258387b636ab4e5695917aa2847d"></a><!-- doxytag: member="net::set_interpreter_func" ref="ga8ba8258387b636ab4e5695917aa2847d" args=")(struct ptlrpc_request_set *, void *, int)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_interpreter_func</b> )(struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *, void *, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga17aa5caeef85aa78f71add31bf7afbe1"></a><!-- doxytag: member="net::set_producer_func" ref="ga17aa5caeef85aa78f71add31bf7afbe1" args=")(struct ptlrpc_request_set *, void *)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_producer_func</b> )(struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80bef25da5dad7e788b4427e8c5e7df6"></a><!-- doxytag: member="net::ptlrpc_interpterer_t" ref="ga80bef25da5dad7e788b4427e8c5e7df6" args=")(const struct lu_env *env, struct ptlrpc_request *req, void *arg, int rc)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga80bef25da5dad7e788b4427e8c5e7df6">ptlrpc_interpterer_t</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, void *arg, int rc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of request interpreter call-back. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacaae2164af2591db6b5e1d2b208cb6e7"></a><!-- doxytag: member="net::ptlrpc_resend_cb_t" ref="gacaae2164af2591db6b5e1d2b208cb6e7" args=")(struct ptlrpc_request *req, void *arg)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gacaae2164af2591db6b5e1d2b208cb6e7">ptlrpc_resend_cb_t</a> )(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of request resend call-back. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaafdde121d699c66fbef23b0a702d1cb0"></a><!-- doxytag: member="net::svc_handler_t" ref="gaafdde121d699c66fbef23b0a702d1cb0" args=")(struct ptlrpc_request *req)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>svc_handler_t</b> )(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga0e456f0c28b52cad4b543eec9efa656a">rq_phase</a> { <br/>
&nbsp;&nbsp;<b>RQ_PHASE_NEW</b> =  0xebc0de00, 
<b>RQ_PHASE_RPC</b> =  0xebc0de01, 
<b>RQ_PHASE_BULK</b> =  0xebc0de02, 
<b>RQ_PHASE_INTERPRET</b> =  0xebc0de03, 
<br/>
&nbsp;&nbsp;<b>RQ_PHASE_COMPLETE</b> =  0xebc0de04, 
<b>RQ_PHASE_UNREGISTERING</b> =  0xebc0de05, 
<b>RQ_PHASE_UNDEFINED</b> =  0xebc0de06
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>RPC stages. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_bulk_op_type</b> { <br/>
&nbsp;&nbsp;<b>PTLRPC_BULK_OP_ACTIVE</b> =  0x00000001, 
<b>PTLRPC_BULK_OP_PASSIVE</b> =  0x00000002, 
<b>PTLRPC_BULK_OP_PUT</b> =  0x00000004, 
<b>PTLRPC_BULK_OP_GET</b> =  0x00000008, 
<br/>
&nbsp;&nbsp;<b>PTLRPC_BULK_BUF_KVEC</b> =  0x00000010, 
<b>PTLRPC_BULK_BUF_KIOV</b> =  0x00000020, 
<b>PTLRPC_BULK_GET_SOURCE</b> =  PTLRPC_BULK_OP_PASSIVE | PTLRPC_BULK_OP_GET, 
<b>PTLRPC_BULK_PUT_SINK</b> =  PTLRPC_BULK_OP_PASSIVE | PTLRPC_BULK_OP_PUT, 
<br/>
&nbsp;&nbsp;<b>PTLRPC_BULK_GET_SINK</b> =  PTLRPC_BULK_OP_ACTIVE | PTLRPC_BULK_OP_GET, 
<b>PTLRPC_BULK_PUT_SOURCE</b> =  PTLRPC_BULK_OP_ACTIVE | PTLRPC_BULK_OP_PUT
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<b>SVC_STOPPED</b> =  1 &lt;&lt; 0, 
<b>SVC_STOPPING</b> =  1 &lt;&lt; 1, 
<b>SVC_STARTING</b> =  1 &lt;&lt; 2, 
<b>SVC_RUNNING</b> =  1 &lt;&lt; 3, 
<br/>
&nbsp;&nbsp;<b>SVC_EVENT</b> =  1 &lt;&lt; 4, 
<b>SVC_SIGNAL</b> =  1 &lt;&lt; 5
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaaa41ab709a4804427e6eb05360ebbed4">ptlrpcd_ctl_flags</a> { <a class="el" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c">LIOD_START</a> =  1 &lt;&lt; 0, 
<a class="el" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c">LIOD_STOP</a> =  1 &lt;&lt; 1, 
<a class="el" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4ad315ddb8cfd7bec02047607f28de70e2">LIOD_FORCE</a> =  1 &lt;&lt; 2, 
<a class="el" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a5a3062cb119fabc0613a8b5dc2e7b75b">LIOD_RECOVERY</a> =  1 &lt;&lt; 3
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1907465565bda3ff642311e407d9be83"></a><!-- doxytag: member="net::ptlrpc_uuid_to_peer" ref="ga1907465565bda3ff642311e407d9be83" args="(struct obd_uuid *uuid, lnet_process_id_t *peer, lnet_nid_t *self)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_uuid_to_peer</b> (struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid, <a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a> *peer, <a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> *self)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1cbaf87598b1c623226f8771cf7e82d6"></a><!-- doxytag: member="net::ptlrpc_connection_get" ref="ga1cbaf87598b1c623226f8771cf7e82d6" args="(lnet_process_id_t peer, lnet_nid_t self, struct obd_uuid *uuid)" -->
struct <a class="el" href="structptlrpc__connection.html">ptlrpc_connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_connection_get</b> (<a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a> peer, <a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> self, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa3b5c9b0468396b8667672dd0704bb8c"></a><!-- doxytag: member="net::ptlrpc_connection_put" ref="gaa3b5c9b0468396b8667672dd0704bb8c" args="(struct ptlrpc_connection *c)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_connection_put</b> (struct <a class="el" href="structptlrpc__connection.html">ptlrpc_connection</a> *c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa3230083ef959e91b7c71227975e373"></a><!-- doxytag: member="net::ptlrpc_connection_addref" ref="gaaa3230083ef959e91b7c71227975e373" args="(struct ptlrpc_connection *)" -->
struct <a class="el" href="structptlrpc__connection.html">ptlrpc_connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_connection_addref</b> (struct <a class="el" href="structptlrpc__connection.html">ptlrpc_connection</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06134970ba769bb2fd1f9bdb0c367b6f"></a><!-- doxytag: member="net::ptlrpc_connection_init" ref="ga06134970ba769bb2fd1f9bdb0c367b6f" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_connection_init</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga964f70e236fc46e71a001e138761c6a0"></a><!-- doxytag: member="net::ptlrpc_connection_fini" ref="ga964f70e236fc46e71a001e138761c6a0" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_connection_fini</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga823ffa6488c25750f836f7c5ccdac8f0"></a><!-- doxytag: member="net::ptl_get_pid" ref="ga823ffa6488c25750f836f7c5ccdac8f0" args="(void)" -->
<a class="el" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd">lnet_pid_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptl_get_pid</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaad7581ae130c00088e4d7c3f8df6d91"></a><!-- doxytag: member="net::ptlrpc_pinger_suppress_pings" ref="gaaad7581ae130c00088e4d7c3f8df6d91" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_pinger_suppress_pings</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf6c0a253a44e1a561d3650cafa0aeab"></a><!-- doxytag: member="net::ptlrpcd_stop" ref="gadf6c0a253a44e1a561d3650cafa0aeab" args="(struct ptlrpcd_ctl *pc, int force)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_stop</b> (struct <a class="el" href="structptlrpcd__ctl.html">ptlrpcd_ctl</a> *pc, int force)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8ef02e8c2a1c0621b003d24cd5975c4"></a><!-- doxytag: member="net::ptlrpcd_free" ref="gad8ef02e8c2a1c0621b003d24cd5975c4" args="(struct ptlrpcd_ctl *pc)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_free</b> (struct <a class="el" href="structptlrpcd__ctl.html">ptlrpcd_ctl</a> *pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2acfae9e6349420190608a611125bb78"></a><!-- doxytag: member="net::ptlrpcd_wake" ref="ga2acfae9e6349420190608a611125bb78" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_wake</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8a1fd19f62cb6e52ee2b145c63f5dd1"></a><!-- doxytag: member="net::ptlrpcd_add_req" ref="gad8a1fd19f62cb6e52ee2b145c63f5dd1" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1">ptlrpcd_add_req</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check-&gt;<a class="el" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies...">ptlrpc_check_set()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga8786798db7200aeedbfe4cd0a855232f">ptlrpcd_add_rqset</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move all request from an existing request set to the ptlrpcd queue.  <a href="#ga8786798db7200aeedbfe4cd0a855232f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2b4cdaf9bce76784e8efa1f9bda8c58b"></a><!-- doxytag: member="net::ptlrpcd_addref" ref="ga2b4cdaf9bce76784e8efa1f9bda8c58b" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_addref</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54a4bcf408e22400c741b530bbb8ec06"></a><!-- doxytag: member="net::ptlrpcd_decref" ref="ga54a4bcf408e22400c741b530bbb8ec06" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_decref</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga483f32cf35c540381bf42ad5d39996dd"></a><!-- doxytag: member="net::llog_origin_handle_open" ref="ga483f32cf35c540381bf42ad5d39996dd" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_origin_handle_open</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga355d1b7adee0199650bd610106fb01f1"></a><!-- doxytag: member="net::llog_origin_handle_destroy" ref="ga355d1b7adee0199650bd610106fb01f1" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_origin_handle_destroy</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8502b96b5f278d5bab2bfc3332c6d062"></a><!-- doxytag: member="net::llog_origin_handle_prev_block" ref="ga8502b96b5f278d5bab2bfc3332c6d062" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_origin_handle_prev_block</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga99484c789b25c3cb5c04ea01bd738704"></a><!-- doxytag: member="net::llog_origin_handle_next_block" ref="ga99484c789b25c3cb5c04ea01bd738704" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_origin_handle_next_block</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacb61cb1b7710780fff85d3f0279428c5"></a><!-- doxytag: member="net::llog_origin_handle_read_header" ref="gacb61cb1b7710780fff85d3f0279428c5" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_origin_handle_read_header</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga34e330a518ed1972949561b4df491aeb"></a><!-- doxytag: member="net::llog_origin_handle_close" ref="ga34e330a518ed1972949561b4df491aeb" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_origin_handle_close</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1194825a0870adce9de4d05b19500152"></a><!-- doxytag: member="net::ptlrpc_bulk_kiov_pin_ops" ref="ga1194825a0870adce9de4d05b19500152" args="" -->
struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_bulk_kiov_pin_ops</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga687589e95f98270c665ebde62a874d03"></a><!-- doxytag: member="net::ptlrpc_bulk_kiov_nopin_ops" ref="ga687589e95f98270c665ebde62a874d03" args="" -->
struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_bulk_kiov_nopin_ops</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72925c5dcb81674f2d733fc975dc4748"></a><!-- doxytag: member="net::ptlrpc_bulk_kvec_ops" ref="ga72925c5dcb81674f2d733fc975dc4748" args="" -->
struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_bulk_kvec_ops</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43d00a48fde2ab8cfdaf5417683e63c9"></a><!-- doxytag: member="net::ptlrpc_eq_h" ref="ga43d00a48fde2ab8cfdaf5417683e63c9" args="" -->
<a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_eq_h</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ec29710aa0674b084aad4f32e96d428"></a><!-- doxytag: member="net::llog_client_ops" ref="ga1ec29710aa0674b084aad4f32e96d428" args="" -->
struct <a class="el" href="structllog__operations.html">llog_operations</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_client_ops</b></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga83197c087490e096e36a4397091d0c3f">timeout_event</a> { <b>TIMEOUT_GRANT</b> =  1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Pinger API (client side only). </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad82b5875e63992cfb2e05f9b94fbc71"></a><!-- doxytag: member="net::timeout_cb_t" ref="gaad82b5875e63992cfb2e05f9b94fbc71" args=")(struct timeout_item *, void *)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>timeout_cb_t</b> )(struct <a class="el" href="structtimeout__item.html">timeout_item</a> *, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7acffec98d1468d2ef76654aaccade4"></a><!-- doxytag: member="net::_debug_req" ref="gaa7acffec98d1468d2ef76654aaccade4" args="(struct ptlrpc_request *req, struct libcfs_debug_msg_data *data, const char *fmt,...) __attribute__((format(printf" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>_debug_req</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structlibcfs__debug__msg__data.html">libcfs_debug_msg_data</a> *data, const char *fmt,...) __attribute__((format(printf</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga888caf60135e2eecdef05fce1b2de9b6"></a><!-- doxytag: member="net::request_out_callback" ref="ga888caf60135e2eecdef05fce1b2de9b6" args="(lnet_event_t *ev)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga888caf60135e2eecdef05fce1b2de9b6">request_out_callback</a> (<a class="el" href="structlnet__event__t.html">lnet_event_t</a> *ev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These callbacks are invoked by LNet when something happened to underlying buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga447473f788164a63797ffd70d471499a"></a><!-- doxytag: member="net::reply_in_callback" ref="ga447473f788164a63797ffd70d471499a" args="(lnet_event_t *ev)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>reply_in_callback</b> (<a class="el" href="structlnet__event__t.html">lnet_event_t</a> *ev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab3a1ba2f0cd4eab3b1a50cb7edbaf172"></a><!-- doxytag: member="net::client_bulk_callback" ref="gab3a1ba2f0cd4eab3b1a50cb7edbaf172" args="(lnet_event_t *ev)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>client_bulk_callback</b> (<a class="el" href="structlnet__event__t.html">lnet_event_t</a> *ev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc74b903a7097918d144a762599c02cb"></a><!-- doxytag: member="net::request_in_callback" ref="gabc74b903a7097918d144a762599c02cb" args="(lnet_event_t *ev)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>request_in_callback</b> (<a class="el" href="structlnet__event__t.html">lnet_event_t</a> *ev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac80d5dea22a333f5aa859f2b57e84a8f"></a><!-- doxytag: member="net::reply_out_callback" ref="gac80d5dea22a333f5aa859f2b57e84a8f" args="(lnet_event_t *ev)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>reply_out_callback</b> (<a class="el" href="structlnet__event__t.html">lnet_event_t</a> *ev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d">ptlrpc_register_bulk</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actual interfacing with LNet to put/get/register/unregister stuff.  <a href="#gaa1cf14602e33836d92101141c3a0d67d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7">ptlrpc_unregister_bulk</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int async)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect a bulk desc from the <a class="el" href="structnetwork.html">network</a>.  <a href="#gaea9a5e62d5d55ace491db905c9a474f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga563a5d436790759334ba2a51f0dce12e">ptlrpc_send_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send request reply from request <em>req</em> reply buffer.  <a href="#ga563a5d436790759334ba2a51f0dce12e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad40cbc28d0a901fa44135d66e595602d"></a><!-- doxytag: member="net::ptlrpc_reply" ref="gad40cbc28d0a901fa44135d66e595602d" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_reply</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac2a8de93c376592370228d10fd94761d">ptlrpc_send_error</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int difficult)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For request <em>req</em> send an error reply back.  <a href="#gac2a8de93c376592370228d10fd94761d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9ee87b413f0ce1ea5589d233011a30c"></a><!-- doxytag: member="net::ptlrpc_error" ref="gab9ee87b413f0ce1ea5589d233011a30c" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_error</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa4ddbc1d6aa868710ab5c137a2e029e2"></a><!-- doxytag: member="net::ptlrpc_at_get_net_latency" ref="gaa4ddbc1d6aa868710ab5c137a2e029e2" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_at_get_net_latency</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d">ptl_send_rpc</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request, int noreply)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send request <em>request</em>.  <a href="#ga52f0aef010b62759e4c2f9e6ef6aea3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf7557fc8aa34bbf889ee11612ece2315"></a><!-- doxytag: member="net::ptlrpc_register_rqbd" ref="gaf7557fc8aa34bbf889ee11612ece2315" args="(struct ptlrpc_request_buffer_desc *rqbd)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf7557fc8aa34bbf889ee11612ece2315">ptlrpc_register_rqbd</a> (struct <a class="el" href="structptlrpc__request__buffer__desc.html">ptlrpc_request_buffer_desc</a> *rqbd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register request buffer descriptor for request receiving. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gacab48d448ba12ade8093383e054814cc">ptlrpc_request_committed</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Client-side portals API.  <a href="#gacab48d448ba12ade8093383e054814cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8274d1c6229aa8679c30551cc4768778"></a><!-- doxytag: member="net::ptlrpc_init_client" ref="ga8274d1c6229aa8679c30551cc4768778" args="(int req_portal, int rep_portal, char *name, struct ptlrpc_client *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga8274d1c6229aa8679c30551cc4768778">ptlrpc_init_client</a> (int req_portal, int rep_portal, char *name, struct <a class="el" href="structptlrpc__client.html">ptlrpc_client</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize passed in client structure <em>cl</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b758fc8a90798b7f3f82ad51ed8b518"></a><!-- doxytag: member="net::ptlrpc_cleanup_client" ref="ga1b758fc8a90798b7f3f82ad51ed8b518" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_cleanup_client</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac16251a340153c3059c8727b8b39d400"></a><!-- doxytag: member="net::ptlrpc_uuid_to_connection" ref="gac16251a340153c3059c8727b8b39d400" args="(struct obd_uuid *uuid)" -->
struct <a class="el" href="structptlrpc__connection.html">ptlrpc_connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac16251a340153c3059c8727b8b39d400">ptlrpc_uuid_to_connection</a> (struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return PortalRPC connection for remore uud <em>uuid</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48">ptlrpc_queue_wait</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send request and wait until it completes.  <a href="#ga003cd2f0c09fd578821500e8084f8c48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gafd4a53f20e90893d5ae03f1996ecb2fc">ptlrpc_replay_req</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares and queues request for replay.  <a href="#gafd4a53f20e90893d5ae03f1996ecb2fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga469a6dc4c139ecc1ab2fd3562c693986"></a><!-- doxytag: member="net::ptlrpc_restart_req" ref="ga469a6dc4c139ecc1ab2fd3562c693986" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_restart_req</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaebf74d120543fbad3a68316dc1a5c97c"></a><!-- doxytag: member="net::ptlrpc_abort_inflight" ref="gaebf74d120543fbad3a68316dc1a5c97c" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaebf74d120543fbad3a68316dc1a5c97c">ptlrpc_abort_inflight</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Aborts all in-flight request on import <em>imp</em> sending and delayed lists. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01a4895dc2c01104ef9b4b6998d76729"></a><!-- doxytag: member="net::ptlrpc_cleanup_imp" ref="ga01a4895dc2c01104ef9b4b6998d76729" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_cleanup_imp</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf9a01538061117dbbb8787fb7b81b77"></a><!-- doxytag: member="net::ptlrpc_abort_set" ref="gacf9a01538061117dbbb8787fb7b81b77" args="(struct ptlrpc_request_set *set)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gacf9a01538061117dbbb8787fb7b81b77">ptlrpc_abort_set</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort all uncompleted requests in request set <em>set</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4">ptlrpc_prep_set</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize new request set structure on the current CPT.  <a href="#ga7e29af1c85aba7368cea369f091d09b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga2d9ff5fa185af154f37c364df7b5c4cc">ptlrpc_prep_fcset</a> (int max, set_producer_func func, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize new request set structure with flow control extension.  <a href="#ga2d9ff5fa185af154f37c364df7b5c4cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gad92b893a7fb440c2f0eed3ce0e79f6af">ptlrpc_set_add_cb</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set, set_interpreter_func fn, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a callback function <em>fn</em> to the set.  <a href="#gad92b893a7fb440c2f0eed3ce0e79f6af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga63613680c8953223c8efc4331656b11a">ptlrpc_check_set</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this sends any unsent RPCs in <em>set</em> and returns 1 if all are sent and no more replies are expected.  <a href="#ga63613680c8953223c8efc4331656b11a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac072432ff0e3366be99c8456895e28d1">ptlrpc_set_wait</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send all unset request from the set and then wait untill all requests in the set complete (either get a reply, timeout, get an error or otherwise be interrupted).  <a href="#gac072432ff0e3366be99c8456895e28d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf50ebcc46ea5f7316c23362915fd5ce7"></a><!-- doxytag: member="net::ptlrpc_mark_interrupted" ref="gaf50ebcc46ea5f7316c23362915fd5ce7" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf50ebcc46ea5f7316c23362915fd5ce7">ptlrpc_mark_interrupted</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets rq_intr flag in <em>req</em> under spinlock. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8">ptlrpc_set_destroy</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wind down and free request set structure previously allocated with ptlrpc_prep_set.  <a href="#ga862d0349489e1b216f7b1be96ac3baf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8">ptlrpc_set_add_req</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new request to the general purpose request set.  <a href="#ga5da56461932d974b4c2487f179d8e6d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga1b3e3fff15de45e0042c071e5bb806f4">ptlrpc_free_rq_pool</a> (struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *pool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wind down request pool <em>pool</em>.  <a href="#ga1b3e3fff15de45e0042c071e5bb806f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07d19311543ebd57e6514926b08ddd08"></a><!-- doxytag: member="net::ptlrpc_add_rqs_to_pool" ref="ga07d19311543ebd57e6514926b08ddd08" args="(struct ptlrpc_request_pool *pool, int num_rq)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga07d19311543ebd57e6514926b08ddd08">ptlrpc_add_rqs_to_pool</a> (struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *pool, int num_rq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates, initializes and adds <em>num_rq</em> requests to the pool <em>pool</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga297dfeefaa23e0c6265ca8c0ad81e818"></a><!-- doxytag: member="net::ptlrpc_init_rq_pool" ref="ga297dfeefaa23e0c6265ca8c0ad81e818" args="(int, int, int(*populate_pool)(struct ptlrpc_request_pool *, int))" -->
struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga297dfeefaa23e0c6265ca8c0ad81e818">ptlrpc_init_rq_pool</a> (int, int, int(*populate_pool)(struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *, int))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialize new request pool with given attributes: <em>num_rq</em> - initial number of requests to create for the pool <em>msgsize</em> - maximum message size possible for requests in thid pool <em>populate_pool</em> - function to be called when more requests need to be added to the pool Returns pointer to newly created pool or NULL on error. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7">ptlrpc_at_set_req_timeout</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set server timelimit for this req, i.e.  <a href="#ga476170376a6f1bb9bb7f85ade4c774f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2bf080a905f488f676248838514e264a"></a><!-- doxytag: member="net::ptlrpc_request_alloc" ref="ga2bf080a905f488f676248838514e264a" args="(struct obd_import *imp, const struct req_format *format)" -->
struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga2bf080a905f488f676248838514e264a">ptlrpc_request_alloc</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, const struct req_format *format)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate new request structure for import <em>imp</em> and initialize its buffer structure according to capsule template <em>format</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0aa209ecf9cb734df89fec89a61d00a1"></a><!-- doxytag: member="net::ptlrpc_request_alloc_pool" ref="ga0aa209ecf9cb734df89fec89a61d00a1" args="(struct obd_import *imp, struct ptlrpc_request_pool *, const struct req_format *format)" -->
struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga0aa209ecf9cb734df89fec89a61d00a1">ptlrpc_request_alloc_pool</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *, const struct req_format *format)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate new request structure for import <em>imp</em> from pool <em>pool</em> and initialize its buffer structure according to capsule template <em>format</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f">ptlrpc_request_free</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For requests not from pool, free memory of the request structure.  <a href="#ga35e91945e5dfe7314c1b31519907929f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1d6f5834629cf755c8f1f0b1a4349de"></a><!-- doxytag: member="net::ptlrpc_request_pack" ref="gaa1d6f5834629cf755c8f1f0b1a4349de" args="(struct ptlrpc_request *request, __u32 version, int opcode)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de">ptlrpc_request_pack</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request, __u32 version, int opcode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack request buffers for <a class="el" href="structnetwork.html">network</a> transfer, performing necessary encryption steps if necessary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac578ffdc47c9c2141c34c4798a55cce4">ptlrpc_request_alloc_pack</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, const struct req_format *format, __u32 version, int opcode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate new request for operatione <em>opcode</em> and immediatelly pack it for <a class="el" href="structnetwork.html">network</a> transfer.  <a href="#gac578ffdc47c9c2141c34c4798a55cce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae057f78231e03c194800fb70734b7ad2"></a><!-- doxytag: member="net::ptlrpc_request_bufs_pack" ref="gae057f78231e03c194800fb70734b7ad2" args="(struct ptlrpc_request *request, __u32 version, int opcode, char **bufs, struct ptlrpc_cli_ctx *ctx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_request_bufs_pack</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request, __u32 version, int opcode, char **bufs, struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf16bb640b9f0c667d79b7254ac965288"></a><!-- doxytag: member="net::ptlrpc_req_finished" ref="gaf16bb640b9f0c667d79b7254ac965288" args="(struct ptlrpc_request *request)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288">ptlrpc_req_finished</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops one reference count for a request. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac030d75f1b39211b69e4974fc328669d">ptlrpc_req_finished_with_imp_lock</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop one request reference.  <a href="#gac030d75f1b39211b69e4974fc328669d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga60499b3efd5caf2e7bc59c308332aff3"></a><!-- doxytag: member="net::ptlrpc_request_addref" ref="ga60499b3efd5caf2e7bc59c308332aff3" args="(struct ptlrpc_request *req)" -->
struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3">ptlrpc_request_addref</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grab additional reference on a request <em>req</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga42ea756e2d84491e4b6ea2e53616d7cb">ptlrpc_prep_bulk_imp</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, unsigned nfrags, unsigned max_brw, unsigned int type, unsigned portal, const struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> *ops)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare bulk descriptor for specified outgoing request <em>req</em> that can fit <em>nfrags</em> * pages.  <a href="#ga42ea756e2d84491e4b6ea2e53616d7cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ce5ef3b8b47e511c659611f9535f1f7"></a><!-- doxytag: member="net::ptlrpc_prep_bulk_frag" ref="ga2ce5ef3b8b47e511c659611f9535f1f7" args="(struct ptlrpc_bulk_desc *desc, void *frag, int len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_prep_bulk_frag</b> (struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc, void *frag, int len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf3d6df55675560574b76a41836bdb2e"></a><!-- doxytag: member="net::__ptlrpc_prep_bulk_page" ref="gaaf3d6df55675560574b76a41836bdb2e" args="(struct ptlrpc_bulk_desc *desc, struct page *page, int pageoffset, int len, int pin)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>__ptlrpc_prep_bulk_page</b> (struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc, struct page *page, int pageoffset, int len, int pin)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga157357acf9f2b447ca5e49b108986e6c"></a><!-- doxytag: member="net::ptlrpc_free_bulk" ref="ga157357acf9f2b447ca5e49b108986e6c" args="(struct ptlrpc_bulk_desc *bulk)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_free_bulk</b> (struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *bulk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga74e4777d34c1f5305c03de9d365a6268">ptlrpc_retain_replayable_request</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a request to import replay_list.  <a href="#ga74e4777d34c1f5305c03de9d365a6268"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__u64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf2442fe17f822101d45881701da27f40">ptlrpc_next_xid</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase xid and returns resulting new value to the caller.  <a href="#gaf2442fe17f822101d45881701da27f40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__u64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac08edd7ffd185c9f01d010fa5da16fd3">ptlrpc_sample_next_xid</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a glimpse at what next xid value might have been.  <a href="#gac08edd7ffd185c9f01d010fa5da16fd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga283d8a396288df3e34efd571d9d30018"></a><!-- doxytag: member="net::ptlrpc_req_xid" ref="ga283d8a396288df3e34efd571d9d30018" args="(struct ptlrpc_request *request)" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga283d8a396288df3e34efd571d9d30018">ptlrpc_req_xid</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns xid of a <em>request</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56ad09ae5c5df58c7555e7299dc02108"></a><!-- doxytag: member="net::ptlrpcd_alloc_work" ref="ga56ad09ae5c5df58c7555e7299dc02108" args="(struct obd_import *imp, int(*cb)(const struct lu_env *, void *), void *data)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga56ad09ae5c5df58c7555e7299dc02108">ptlrpcd_alloc_work</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, int(*cb)(const struct <a class="el" href="structlu__env.html">lu_env</a> *, void *), void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a work for ptlrpc. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f31480e3a6bf61fb70da03169ffef2c"></a><!-- doxytag: member="net::ptlrpcd_destroy_work" ref="ga4f31480e3a6bf61fb70da03169ffef2c" args="(void *handler)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_destroy_work</b> (void *handler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga796a1313cf9a7e633831e831a6f217da"></a><!-- doxytag: member="net::ptlrpcd_queue_work" ref="ga796a1313cf9a7e633831e831a6f217da" args="(void *handler)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_queue_work</b> (void *handler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga686ce1d3f4b5ce9b59e59136cb6b265c">ptlrpc_save_lock</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lock, int mode, int no_ack)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Server-side services API.  <a href="#ga686ce1d3f4b5ce9b59e59136cb6b265c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c4d3548ace7c49c820adf3d6610f7a8"></a><!-- doxytag: member="net::ptlrpc_commit_replies" ref="ga1c4d3548ace7c49c820adf3d6610f7a8" args="(struct obd_export *exp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_commit_replies</b> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac133162c229195f6e9479dd79aac6473"></a><!-- doxytag: member="net::ptlrpc_dispatch_difficult_reply" ref="gac133162c229195f6e9479dd79aac6473" args="(struct ptlrpc_reply_state *rs)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac133162c229195f6e9479dd79aac6473">ptlrpc_dispatch_difficult_reply</a> (struct <a class="el" href="structptlrpc__reply__state.html">ptlrpc_reply_state</a> *rs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put reply state into a queue for processing because we received ACK from the client. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9ab523a4b395599275d00e72079b51f9"></a><!-- doxytag: member="net::ptlrpc_schedule_difficult_reply" ref="ga9ab523a4b395599275d00e72079b51f9" args="(struct ptlrpc_reply_state *rs)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_schedule_difficult_reply</b> (struct <a class="el" href="structptlrpc__reply__state.html">ptlrpc_reply_state</a> *rs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6539e422ce487ae5c6cdeb3855ffdc96"></a><!-- doxytag: member="net::ptlrpc_hpreq_handler" ref="ga6539e422ce487ae5c6cdeb3855ffdc96" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_hpreq_handler</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga13835bf69545de9744051ff7ef02a4c3">ptlrpc_register_service</a> (struct <a class="el" href="structptlrpc__service__conf.html">ptlrpc_service_conf</a> *conf, struct proc_dir_entry *proc_entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize service on a given portal.  <a href="#ga13835bf69545de9744051ff7ef02a4c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59db7fb30a02fd79e28791330f99fb3c"></a><!-- doxytag: member="net::ptlrpc_stop_all_threads" ref="ga59db7fb30a02fd79e28791330f99fb3c" args="(struct ptlrpc_service *svc)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga59db7fb30a02fd79e28791330f99fb3c">ptlrpc_stop_all_threads</a> (struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops all threads of a particular service <em>svc</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae98dcdbb3ab34d8e067f6caf336c9d31"></a><!-- doxytag: member="net::ptlrpc_start_threads" ref="gae98dcdbb3ab34d8e067f6caf336c9d31" args="(struct ptlrpc_service *svc)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_start_threads</b> (struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f7edc9d9d00fa395262051c0f9fc855"></a><!-- doxytag: member="net::ptlrpc_unregister_service" ref="ga2f7edc9d9d00fa395262051c0f9fc855" args="(struct ptlrpc_service *service)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_unregister_service</b> (struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *service)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga90dec4ae9fc60a0730d7675e6618229b"></a><!-- doxytag: member="net::liblustre_check_services" ref="ga90dec4ae9fc60a0730d7675e6618229b" args="(void *arg)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>liblustre_check_services</b> (void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04c970ca262e5df3786559bd7927b319"></a><!-- doxytag: member="net::ptlrpc_daemonize" ref="ga04c970ca262e5df3786559bd7927b319" args="(char *name)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_daemonize</b> (char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7bc966179d16fa5e27e45a95523b0386"></a><!-- doxytag: member="net::ptlrpc_service_health_check" ref="ga7bc966179d16fa5e27e45a95523b0386" args="(struct ptlrpc_service *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_service_health_check</b> (struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga45bbc99a8cb3940b830d5ac581cd2f10">ptlrpc_server_drop_request</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop a reference count of the request.  <a href="#ga45bbc99a8cb3940b830d5ac581cd2f10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaedae07eef44eef7ce7d1b0cfe437804f"></a><!-- doxytag: member="net::ptlrpc_request_change_export" ref="gaedae07eef44eef7ce7d1b0cfe437804f" args="(struct ptlrpc_request *req, struct obd_export *export)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaedae07eef44eef7ce7d1b0cfe437804f">ptlrpc_request_change_export</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structobd__export.html">obd_export</a> *export)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change request export and move hp request from old export to new. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga3b962a1b6e534a49a4848336555d1d89">ptlrpc_update_export_timer</a> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp, long extra_delay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function makes sure dead exports are evicted in a timely manner.  <a href="#ga3b962a1b6e534a49a4848336555d1d89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga47eab7558ff3a05ad0bd51901e737849"></a><!-- doxytag: member="net::ptlrpc_hr_init" ref="ga47eab7558ff3a05ad0bd51901e737849" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_hr_init</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga48bcd41298dc75aed55d30b850d28c26"></a><!-- doxytag: member="net::ptlrpc_hr_fini" ref="ga48bcd41298dc75aed55d30b850d28c26" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_hr_fini</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gae524031a54066bf23dda2ad572bbcfdf">ptlrpc_connect_import</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Import API.  <a href="#gae524031a54066bf23dda2ad572bbcfdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4197d19954bc0ced2fd5063ce62b9373"></a><!-- doxytag: member="net::ptlrpc_init_import" ref="ga4197d19954bc0ced2fd5063ce62b9373" args="(struct obd_import *imp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_init_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab498b6deeff2988de567a762bcb6e9ad"></a><!-- doxytag: member="net::ptlrpc_disconnect_import" ref="gab498b6deeff2988de567a762bcb6e9ad" args="(struct obd_import *imp, int noclose)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_disconnect_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, int noclose)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gae24ff0ea3f19794b41cb4da94ffa9ce2">ptlrpc_import_recovery_state_machine</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the state machine for client-side recovery on import.  <a href="#gae24ff0ea3f19794b41cb4da94ffa9ce2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7c5dee1feb43474335f9a79fa06e173f"></a><!-- doxytag: member="net::deuuidify" ref="ga7c5dee1feb43474335f9a79fa06e173f" args="(char *uuid, const char *prefix, char **uuid_start, int *uuid_len)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>deuuidify</b> (char *uuid, const char *prefix, char **uuid_start, int *uuid_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ad1e58ff4d334ea76093692cc976932"></a><!-- doxytag: member="net::ptlrpc_import_enter_resend" ref="ga6ad1e58ff4d334ea76093692cc976932" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_import_enter_resend</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8143184eaf22d5624ea42473dd4e8acc"></a><!-- doxytag: member="net::ptlrpc_reconnect_import" ref="ga8143184eaf22d5624ea42473dd4e8acc" args="(struct obd_import *imp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_reconnect_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa22239843a54a1577998de2a44fd8af7"></a><!-- doxytag: member="net::ptlrpc_buf_need_swab" ref="gaa22239843a54a1577998de2a44fd8af7" args="(struct ptlrpc_request *req, const int inout, __u32 index)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaa22239843a54a1577998de2a44fd8af7">ptlrpc_buf_need_swab</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, const int inout, __u32 index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ptlrpc msg buffer and swab interface <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6920d79557ab62c16abd7c03d5f27ed7"></a><!-- doxytag: member="net::ptlrpc_buf_set_swabbed" ref="ga6920d79557ab62c16abd7c03d5f27ed7" args="(struct ptlrpc_request *req, const int inout, __u32 index)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_buf_set_swabbed</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, const int inout, __u32 index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39ce8a4b0728469e0174c3aa68fd381e"></a><!-- doxytag: member="net::ptlrpc_unpack_rep_msg" ref="ga39ce8a4b0728469e0174c3aa68fd381e" args="(struct ptlrpc_request *req, int len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_unpack_rep_msg</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga880aa3ea008857e45135398b11077193"></a><!-- doxytag: member="net::ptlrpc_unpack_req_msg" ref="ga880aa3ea008857e45135398b11077193" args="(struct ptlrpc_request *req, int len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_unpack_req_msg</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac7a9b2c131fb724a634b28295311e90d"></a><!-- doxytag: member="net::lustre_msg_check_version" ref="gac7a9b2c131fb724a634b28295311e90d" args="(struct lustre_msg *msg, __u32 version)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_check_version</b> (struct lustre_msg *msg, __u32 version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga675f94ce12272868d6f12b98ee1def0d"></a><!-- doxytag: member="net::lustre_init_msg_v2" ref="ga675f94ce12272868d6f12b98ee1def0d" args="(struct lustre_msg_v2 *msg, int count, __u32 *lens, char **bufs)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_init_msg_v2</b> (struct <a class="el" href="structlustre__msg__v2.html">lustre_msg_v2</a> *msg, int count, __u32 *lens, char **bufs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf9e68de9b741fc678c0427fd15a9763"></a><!-- doxytag: member="net::lustre_pack_request" ref="gaaf9e68de9b741fc678c0427fd15a9763" args="(struct ptlrpc_request *, __u32 magic, int count, __u32 *lens, char **bufs)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_pack_request</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *, __u32 magic, int count, __u32 *lens, char **bufs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga931e9c4b5f584f4101c94dfcd3462c5f"></a><!-- doxytag: member="net::lustre_pack_reply" ref="ga931e9c4b5f584f4101c94dfcd3462c5f" args="(struct ptlrpc_request *, int count, __u32 *lens, char **bufs)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_pack_reply</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *, int count, __u32 *lens, char **bufs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga33e4ff610e2b182cd78c74131c847cb0"></a><!-- doxytag: member="net::lustre_pack_reply_v2" ref="ga33e4ff610e2b182cd78c74131c847cb0" args="(struct ptlrpc_request *req, int count, __u32 *lens, char **bufs, int flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_pack_reply_v2</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int count, __u32 *lens, char **bufs, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59c89b28811f4f38f28b2b7d339797f6"></a><!-- doxytag: member="net::lustre_pack_reply_flags" ref="ga59c89b28811f4f38f28b2b7d339797f6" args="(struct ptlrpc_request *, int count, __u32 *lens, char **bufs, int flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_pack_reply_flags</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *, int count, __u32 *lens, char **bufs, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2e757694495c0c01d68d49b78c586125"></a><!-- doxytag: member="net::lustre_shrink_msg" ref="ga2e757694495c0c01d68d49b78c586125" args="(struct lustre_msg *msg, int segment, unsigned int newlen, int move_data)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_shrink_msg</b> (struct lustre_msg *msg, int segment, unsigned int newlen, int move_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f4bc7c975ca5f3f346d7869bb3f4091"></a><!-- doxytag: member="net::lustre_free_reply_state" ref="ga3f4bc7c975ca5f3f346d7869bb3f4091" args="(struct ptlrpc_reply_state *rs)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_free_reply_state</b> (struct <a class="el" href="structptlrpc__reply__state.html">ptlrpc_reply_state</a> *rs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0868ef692f15726090390fd3a1ae258d"></a><!-- doxytag: member="net::__lustre_unpack_msg" ref="ga0868ef692f15726090390fd3a1ae258d" args="(struct lustre_msg *m, int len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>__lustre_unpack_msg</b> (struct lustre_msg *m, int len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaff9112552bf89bd375921061a1dd2b85"></a><!-- doxytag: member="net::lustre_msg_hdr_size" ref="gaff9112552bf89bd375921061a1dd2b85" args="(__u32 magic, __u32 count)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_hdr_size</b> (__u32 magic, __u32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga32c4986e896273a264d87bbc5d28bc70"></a><!-- doxytag: member="net::lustre_msg_size" ref="ga32c4986e896273a264d87bbc5d28bc70" args="(__u32 magic, int count, __u32 *lengths)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_size</b> (__u32 magic, int count, __u32 *lengths)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a6268b0e3e950415cc3d4900b744f5d"></a><!-- doxytag: member="net::lustre_msg_size_v2" ref="ga4a6268b0e3e950415cc3d4900b744f5d" args="(int count, __u32 *lengths)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_size_v2</b> (int count, __u32 *lengths)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39c3c778d0a57ae7fa1d99ca0b9650f1"></a><!-- doxytag: member="net::lustre_packed_msg_size" ref="ga39c3c778d0a57ae7fa1d99ca0b9650f1" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_packed_msg_size</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ec5cd43001c5914c7921da08598ba0c"></a><!-- doxytag: member="net::lustre_msg_early_size" ref="ga0ec5cd43001c5914c7921da08598ba0c" args="(void)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_early_size</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac7dfe0f3f8a3973f5b2c2853454dcde6"></a><!-- doxytag: member="net::lustre_msg_buf_v2" ref="gac7dfe0f3f8a3973f5b2c2853454dcde6" args="(struct lustre_msg_v2 *m, __u32 n, __u32 min_size)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_buf_v2</b> (struct <a class="el" href="structlustre__msg__v2.html">lustre_msg_v2</a> *m, __u32 n, __u32 min_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf86387935cc1ebf32b6befd3c486f9d1"></a><!-- doxytag: member="net::lustre_msg_buf" ref="gaf86387935cc1ebf32b6befd3c486f9d1" args="(struct lustre_msg *m, __u32 n, __u32 minlen)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_buf</b> (struct lustre_msg *m, __u32 n, __u32 minlen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga8ddfe4bfdb34b2159b8281fb3c6e09a4">lustre_msg_buflen</a> (struct lustre_msg *m, __u32 n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lustre_msg_buflen - return the length of buffer <em>n</em> in message <em>m</em>  <a href="#ga8ddfe4bfdb34b2159b8281fb3c6e09a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa079849f1357fc2699237871d0531258"></a><!-- doxytag: member="net::lustre_msg_set_buflen" ref="gaa079849f1357fc2699237871d0531258" args="(struct lustre_msg *m, __u32 n, __u32 len)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_buflen</b> (struct lustre_msg *m, __u32 n, __u32 len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f44a8677c4acf578c772774ba0cf93e"></a><!-- doxytag: member="net::lustre_msg_bufcount" ref="ga6f44a8677c4acf578c772774ba0cf93e" args="(struct lustre_msg *m)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_bufcount</b> (struct lustre_msg *m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga330ed85a023a0002340a4ba73a1e808d"></a><!-- doxytag: member="net::lustre_msg_string" ref="ga330ed85a023a0002340a4ba73a1e808d" args="(struct lustre_msg *m, __u32 n, __u32 max_len)" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_string</b> (struct lustre_msg *m, __u32 n, __u32 max_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa52f54de41c43cabe289cdaa7fedc1b"></a><!-- doxytag: member="net::lustre_msghdr_get_flags" ref="gafa52f54de41c43cabe289cdaa7fedc1b" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msghdr_get_flags</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga641c3578b5bba1f589b31f8b05a635bf"></a><!-- doxytag: member="net::lustre_msghdr_set_flags" ref="ga641c3578b5bba1f589b31f8b05a635bf" args="(struct lustre_msg *msg, __u32 flags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msghdr_set_flags</b> (struct lustre_msg *msg, __u32 flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7039633508af55679f204cff967f1879"></a><!-- doxytag: member="net::lustre_msg_get_flags" ref="ga7039633508af55679f204cff967f1879" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_flags</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga680b03200ebe0b9e31464e5d5999091a"></a><!-- doxytag: member="net::lustre_msg_add_flags" ref="ga680b03200ebe0b9e31464e5d5999091a" args="(struct lustre_msg *msg, __u32 flags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_add_flags</b> (struct lustre_msg *msg, __u32 flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gada3542d777501a1faceed38b584aacf0"></a><!-- doxytag: member="net::lustre_msg_set_flags" ref="gada3542d777501a1faceed38b584aacf0" args="(struct lustre_msg *msg, __u32 flags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_flags</b> (struct lustre_msg *msg, __u32 flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4407c10c8d31d9a5c3e6bedee6e1bde0"></a><!-- doxytag: member="net::lustre_msg_clear_flags" ref="ga4407c10c8d31d9a5c3e6bedee6e1bde0" args="(struct lustre_msg *msg, __u32 flags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_clear_flags</b> (struct lustre_msg *msg, __u32 flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b9caf652e934e32217574de70f0ee18"></a><!-- doxytag: member="net::lustre_msg_get_op_flags" ref="ga6b9caf652e934e32217574de70f0ee18" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_op_flags</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga936d750268a27c353fdd2ac940ab20c8"></a><!-- doxytag: member="net::lustre_msg_add_op_flags" ref="ga936d750268a27c353fdd2ac940ab20c8" args="(struct lustre_msg *msg, __u32 flags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_add_op_flags</b> (struct lustre_msg *msg, __u32 flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad75d2dc265242a98676033489842e8c1"></a><!-- doxytag: member="net::lustre_msg_get_handle" ref="gad75d2dc265242a98676033489842e8c1" args="(struct lustre_msg *msg)" -->
struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_handle</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01d33f66f8a27c313cd4db66ea0bdbc6"></a><!-- doxytag: member="net::lustre_msg_get_type" ref="ga01d33f66f8a27c313cd4db66ea0bdbc6" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_type</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89d53cb5a8d4f00ed4c92a25969c444d"></a><!-- doxytag: member="net::lustre_msg_get_version" ref="ga89d53cb5a8d4f00ed4c92a25969c444d" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_version</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga066a801c595cf650dd7538bf3e8f773a"></a><!-- doxytag: member="net::lustre_msg_add_version" ref="ga066a801c595cf650dd7538bf3e8f773a" args="(struct lustre_msg *msg, __u32 version)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_add_version</b> (struct lustre_msg *msg, __u32 version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5889b19f527897c102df244998c9de02"></a><!-- doxytag: member="net::lustre_msg_get_opc" ref="ga5889b19f527897c102df244998c9de02" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_opc</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae1e0c34642d37fbb79ad0decc534a802"></a><!-- doxytag: member="net::lustre_msg_get_last_xid" ref="gae1e0c34642d37fbb79ad0decc534a802" args="(struct lustre_msg *msg)" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_last_xid</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad697a66b5792cd2cd75bcf95f87d012b"></a><!-- doxytag: member="net::lustre_msg_get_tag" ref="gad697a66b5792cd2cd75bcf95f87d012b" args="(struct lustre_msg *msg)" -->
__u16&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_tag</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ac5547cd6b69a63dd6232cf44428f11"></a><!-- doxytag: member="net::lustre_msg_get_last_committed" ref="ga4ac5547cd6b69a63dd6232cf44428f11" args="(struct lustre_msg *msg)" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_last_committed</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4f241bad6b8f2477c2d1176835fa44f"></a><!-- doxytag: member="net::lustre_msg_get_versions" ref="gaf4f241bad6b8f2477c2d1176835fa44f" args="(struct lustre_msg *msg)" -->
__u64 *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_versions</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9bedef213e170e969899bfab36bb8fb0"></a><!-- doxytag: member="net::lustre_msg_get_transno" ref="ga9bedef213e170e969899bfab36bb8fb0" args="(struct lustre_msg *msg)" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_transno</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga75b1983d0a0620bce67698d9c74606ce"></a><!-- doxytag: member="net::lustre_msg_get_slv" ref="ga75b1983d0a0620bce67698d9c74606ce" args="(struct lustre_msg *msg)" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_slv</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee4ba63f57ed3b69dfa3d34d31c56fcb"></a><!-- doxytag: member="net::lustre_msg_get_limit" ref="gaee4ba63f57ed3b69dfa3d34d31c56fcb" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_limit</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab04cac335854c3ed32f2d61d7ea8f20d"></a><!-- doxytag: member="net::lustre_msg_set_slv" ref="gab04cac335854c3ed32f2d61d7ea8f20d" args="(struct lustre_msg *msg, __u64 slv)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_slv</b> (struct lustre_msg *msg, __u64 slv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac6d72b5cde5803459955f9b39480b73"></a><!-- doxytag: member="net::lustre_msg_set_limit" ref="gaac6d72b5cde5803459955f9b39480b73" args="(struct lustre_msg *msg, __u64 limit)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_limit</b> (struct lustre_msg *msg, __u64 limit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa6ef42a52d75cf87cb0b7834606093b"></a><!-- doxytag: member="net::lustre_msg_get_status" ref="gaaa6ef42a52d75cf87cb0b7834606093b" args="(struct lustre_msg *msg)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_status</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a5b544ffbfafa4fb89c592e719ac9e5"></a><!-- doxytag: member="net::lustre_msg_get_conn_cnt" ref="ga8a5b544ffbfafa4fb89c592e719ac9e5" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_conn_cnt</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01eb6e83d9ebdde883ab568eb3f8dc27"></a><!-- doxytag: member="net::lustre_msg_get_magic" ref="ga01eb6e83d9ebdde883ab568eb3f8dc27" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_magic</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac8ece5ff148e7b332a8408646971193c"></a><!-- doxytag: member="net::lustre_msg_get_timeout" ref="gac8ece5ff148e7b332a8408646971193c" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_timeout</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace5ea0242057ff28a144714e38029efe"></a><!-- doxytag: member="net::lustre_msg_get_service_time" ref="gace5ea0242057ff28a144714e38029efe" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_service_time</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga31246dd9883e11558349659fa4d34162"></a><!-- doxytag: member="net::lustre_msg_get_jobid" ref="ga31246dd9883e11558349659fa4d34162" args="(struct lustre_msg *msg)" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_jobid</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1fab96e53cfbe27a7634cde2fd6146e"></a><!-- doxytag: member="net::lustre_msg_get_cksum" ref="gab1fab96e53cfbe27a7634cde2fd6146e" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_cksum</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga88b6efce1585cbc6a60b84006e486678"></a><!-- doxytag: member="net::lustre_msg_get_mbits" ref="ga88b6efce1585cbc6a60b84006e486678" args="(struct lustre_msg *msg)" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_get_mbits</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f3e7b2437b921cd4173cc356084583b"></a><!-- doxytag: member="net::lustre_msg_calc_cksum" ref="ga1f3e7b2437b921cd4173cc356084583b" args="(struct lustre_msg *msg)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_calc_cksum</b> (struct lustre_msg *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9661a4e2ee3f8bb75a5512d9070903cd"></a><!-- doxytag: member="net::lustre_msg_set_handle" ref="ga9661a4e2ee3f8bb75a5512d9070903cd" args="(struct lustre_msg *msg, struct lustre_handle *handle)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_handle</b> (struct lustre_msg *msg, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69bbda1293ed3ddb76113eda09cd7e05"></a><!-- doxytag: member="net::lustre_msg_set_type" ref="ga69bbda1293ed3ddb76113eda09cd7e05" args="(struct lustre_msg *msg, __u32 type)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_type</b> (struct lustre_msg *msg, __u32 type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga340f5c94b8d8274c155dd269283a3bb5"></a><!-- doxytag: member="net::lustre_msg_set_opc" ref="ga340f5c94b8d8274c155dd269283a3bb5" args="(struct lustre_msg *msg, __u32 opc)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_opc</b> (struct lustre_msg *msg, __u32 opc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad22d60ce1da1272ccbdb640de0c4ab38"></a><!-- doxytag: member="net::lustre_msg_set_last_xid" ref="gad22d60ce1da1272ccbdb640de0c4ab38" args="(struct lustre_msg *msg, __u64 last_xid)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_last_xid</b> (struct lustre_msg *msg, __u64 last_xid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga49511c8ab44ce45f0cb42052399a6a00"></a><!-- doxytag: member="net::lustre_msg_set_tag" ref="ga49511c8ab44ce45f0cb42052399a6a00" args="(struct lustre_msg *msg, __u16 tag)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_tag</b> (struct lustre_msg *msg, __u16 tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3c3a3ba4abbddaf007796fa6532a91ee"></a><!-- doxytag: member="net::lustre_msg_set_last_committed" ref="ga3c3a3ba4abbddaf007796fa6532a91ee" args="(struct lustre_msg *msg, __u64 last_committed)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_last_committed</b> (struct lustre_msg *msg, __u64 last_committed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3ae7fb0ee2a942e263d0b35929530d79"></a><!-- doxytag: member="net::lustre_msg_set_versions" ref="ga3ae7fb0ee2a942e263d0b35929530d79" args="(struct lustre_msg *msg, __u64 *versions)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_versions</b> (struct lustre_msg *msg, __u64 *versions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3866ca9b0ab811a58b005c6459519b3a"></a><!-- doxytag: member="net::lustre_msg_set_transno" ref="ga3866ca9b0ab811a58b005c6459519b3a" args="(struct lustre_msg *msg, __u64 transno)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_transno</b> (struct lustre_msg *msg, __u64 transno)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f9de05092069e96b6ec4932bcd138d1"></a><!-- doxytag: member="net::lustre_msg_set_status" ref="ga7f9de05092069e96b6ec4932bcd138d1" args="(struct lustre_msg *msg, __u32 status)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_status</b> (struct lustre_msg *msg, __u32 status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga53b3384718936bcef0bce14187a7c379"></a><!-- doxytag: member="net::lustre_msg_set_conn_cnt" ref="ga53b3384718936bcef0bce14187a7c379" args="(struct lustre_msg *msg, __u32 conn_cnt)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_conn_cnt</b> (struct lustre_msg *msg, __u32 conn_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9ce11af085c01fdcf0a2f251b955eb47"></a><!-- doxytag: member="net::ptlrpc_req_set_repsize" ref="ga9ce11af085c01fdcf0a2f251b955eb47" args="(struct ptlrpc_request *req, int count, __u32 *sizes)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_req_set_repsize</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int count, __u32 *sizes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6590c2ad5fda846f88583c0b8b3db24"></a><!-- doxytag: member="net::ptlrpc_request_set_replen" ref="gad6590c2ad5fda846f88583c0b8b3db24" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_request_set_replen</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeaac365936d81c960708510421690066"></a><!-- doxytag: member="net::lustre_msg_set_timeout" ref="gaeaac365936d81c960708510421690066" args="(struct lustre_msg *msg, __u32 timeout)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_timeout</b> (struct lustre_msg *msg, __u32 timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4e3c3687a2b470bfea8a0093067e26f5"></a><!-- doxytag: member="net::lustre_msg_set_service_time" ref="ga4e3c3687a2b470bfea8a0093067e26f5" args="(struct lustre_msg *msg, __u32 service_time)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_service_time</b> (struct lustre_msg *msg, __u32 service_time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c7457d1600c44342f8be69cb25a2646"></a><!-- doxytag: member="net::lustre_msg_set_jobid" ref="ga1c7457d1600c44342f8be69cb25a2646" args="(struct lustre_msg *msg, char *jobid)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_jobid</b> (struct lustre_msg *msg, char *jobid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2da3c742415b9c88d9b8ad49211a0bfd"></a><!-- doxytag: member="net::lustre_msg_set_cksum" ref="ga2da3c742415b9c88d9b8ad49211a0bfd" args="(struct lustre_msg *msg, __u32 cksum)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_cksum</b> (struct lustre_msg *msg, __u32 cksum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga682a6cac8b98c3a8ad2122b3c887ca15"></a><!-- doxytag: member="net::lustre_msg_set_mbits" ref="ga682a6cac8b98c3a8ad2122b3c887ca15" args="(struct lustre_msg *msg, __u64 mbits)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_msg_set_mbits</b> (struct lustre_msg *msg, __u64 mbits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabcdaa31fdbdb87a69a06d19c43bbcda0"></a><!-- doxytag: member="net::client_obd_setup" ref="gabcdaa31fdbdb87a69a06d19c43bbcda0" args="(struct obd_device *obddev, struct lustre_cfg *lcfg)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gabcdaa31fdbdb87a69a06d19c43bbcda0">client_obd_setup</a> (struct <a class="el" href="structobd__device.html">obd_device</a> *obddev, struct <a class="el" href="structlustre__cfg.html">lustre_cfg</a> *lcfg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Target client logic. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41252167a852a9399752defcf029083a"></a><!-- doxytag: member="net::client_obd_cleanup" ref="ga41252167a852a9399752defcf029083a" args="(struct obd_device *obddev)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>client_obd_cleanup</b> (struct <a class="el" href="structobd__device.html">obd_device</a> *obddev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab66008e96b57e399aaf8e48a351478f8"></a><!-- doxytag: member="net::client_connect_import" ref="gab66008e96b57e399aaf8e48a351478f8" args="(const struct lu_env *env, struct obd_export **exp, struct obd_device *obd, struct obd_uuid *cluuid, struct obd_connect_data *, void *localdata)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>client_connect_import</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structobd__export.html">obd_export</a> **exp, struct <a class="el" href="structobd__device.html">obd_device</a> *obd, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *cluuid, struct <a class="el" href="structobd__connect__data.html">obd_connect_data</a> *, void *localdata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab8ecd3b16250a80c377e9c9f7bfebfb8"></a><!-- doxytag: member="net::client_disconnect_export" ref="gab8ecd3b16250a80c377e9c9f7bfebfb8" args="(struct obd_export *exp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>client_disconnect_export</b> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace2253d15c74ffe28cf60ed3518258b2"></a><!-- doxytag: member="net::client_import_add_conn" ref="gace2253d15c74ffe28cf60ed3518258b2" args="(struct obd_import *imp, struct obd_uuid *uuid, int priority)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>client_import_add_conn</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid, int priority)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga770f58b91f82d4b373b35f2b11cdf5d0"></a><!-- doxytag: member="net::client_import_del_conn" ref="ga770f58b91f82d4b373b35f2b11cdf5d0" args="(struct obd_import *imp, struct obd_uuid *uuid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>client_import_del_conn</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga0d66e2da6f0da4bb948be01b9719af5c">client_import_find_conn</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, <a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> peer, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find conn UUID by peer NID.  <a href="#ga0d66e2da6f0da4bb948be01b9719af5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f7cd84c38bd70963730d1338076a21d"></a><!-- doxytag: member="net::import_set_conn_priority" ref="ga7f7cd84c38bd70963730d1338076a21d" args="(struct obd_import *imp, struct obd_uuid *uuid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>import_set_conn_priority</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0e64772578519b8f2ed8c0bd50b0a3a1"></a><!-- doxytag: member="net::client_destroy_import" ref="ga0e64772578519b8f2ed8c0bd50b0a3a1" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>client_destroy_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4e44a48c2d9f37024987ae16f570ecc"></a><!-- doxytag: member="net::ptlrpc_pinger_add_import" ref="gaf4e44a48c2d9f37024987ae16f570ecc" args="(struct obd_import *imp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_pinger_add_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga156e93f4ea3bc9fe2e6388558583b755"></a><!-- doxytag: member="net::ptlrpc_pinger_del_import" ref="ga156e93f4ea3bc9fe2e6388558583b755" args="(struct obd_import *imp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_pinger_del_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaafd0e5c4122b455302d4c8a8a67467bb"></a><!-- doxytag: member="net::ptlrpc_add_timeout_client" ref="gaafd0e5c4122b455302d4c8a8a67467bb" args="(int time, enum timeout_event event, timeout_cb_t cb, void *data, struct list_head *obd_list)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_add_timeout_client</b> (int time, enum <a class="el" href="group__net.html#ga83197c087490e096e36a4397091d0c3f">timeout_event</a> event, timeout_cb_t cb, void *data, struct <a class="el" href="structlist__head.html">list_head</a> *obd_list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga43e79605481156aa499fd539a3e1265c">ptlrpc_del_timeout_client</a> (struct <a class="el" href="structlist__head.html">list_head</a> *obd_list, enum <a class="el" href="group__net.html#ga83197c087490e096e36a4397091d0c3f">timeout_event</a> event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa72b6cce8215496489a8e7e1a88b6c70"></a><!-- doxytag: member="net::ptlrpc_prep_ping" ref="gaa72b6cce8215496489a8e7e1a88b6c70" args="(struct obd_import *imp)" -->
struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_prep_ping</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace9ff93f7cc36086c18cea009c16fc25"></a><!-- doxytag: member="net::ptlrpc_obd_ping" ref="gace9ff93f7cc36086c18cea009c16fc25" args="(struct obd_device *obd)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_obd_ping</b> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d288501654fddca2fd757799fffd4cb"></a><!-- doxytag: member="net::ping_evictor_start" ref="ga0d288501654fddca2fd757799fffd4cb" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ping_evictor_start</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga599f2b96469b266065b3fd2fbe423ee1"></a><!-- doxytag: member="net::ping_evictor_stop" ref="ga599f2b96469b266065b3fd2fbe423ee1" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ping_evictor_stop</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga62624c86802cf22df46e02590dd55951"></a><!-- doxytag: member="net::ptlrpc_pinger_ir_up" ref="ga62624c86802cf22df46e02590dd55951" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_pinger_ir_up</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b518fe4579064b2464f4bb8c4c59f33"></a><!-- doxytag: member="net::ptlrpc_pinger_ir_down" ref="ga4b518fe4579064b2464f4bb8c4c59f33" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_pinger_ir_down</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac9b02b599f8ac342b03f25da53bcb168"></a><!-- doxytag: member="net::ll_opcode2str" ref="gac9b02b599f8ac342b03f25da53bcb168" args="(__u32 opcode)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac9b02b599f8ac342b03f25da53bcb168">ll_opcode2str</a> (__u32 opcode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">procfs output related functions <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd94724172cd311f5ce62102d91b8583"></a><!-- doxytag: member="net::FLAG" ref="gafd94724172cd311f5ce62102d91b8583" args="(field, str)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gafd94724172cd311f5ce62102d91b8583">FLAG</a>(field, str)&nbsp;&nbsp;&nbsp;(field ? str : &quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debugging functions and helpers to print request structure into debug log. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf155302427c8b1196ede7e7cd7e7d133">DEBUG_REQ_FLAGS</a>(req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bit flags into a string.  <a href="#gaf155302427c8b1196ede7e7cd7e7d133"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga032f24555e4e11c57c079292ce89699a"></a><!-- doxytag: member="net::REQ_FLAGS_FMT" ref="ga032f24555e4e11c57c079292ce89699a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REQ_FLAGS_FMT</b>&nbsp;&nbsp;&nbsp;&quot;%s:%s%s%s%s%s%s%s%s%s%s%s%s&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaa7f4f5cd9c831160823af2e141bca1c2">debug_req</a>(msgdata, mask, cdls, req, fmt, a...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper that decides if we need to print request accordig to current debug level settings.  <a href="#gaa7f4f5cd9c831160823af2e141bca1c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf">DEBUG_REQ</a>(level, req, fmt, args...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the debug print function you need to use to print request sturucture content into lustre debug log.  <a href="#ga2d5d1c7075b9387118d9356833e9abdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga478f052147cbdc94dbfba08da7f945fa"></a><!-- doxytag: member="net::PTLRPC_REPLY_MAYBE_DIFFICULT" ref="ga478f052147cbdc94dbfba08da7f945fa" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_REPLY_MAYBE_DIFFICULT</b>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4223d4b654456d504d272bebd9ebba23"></a><!-- doxytag: member="net::PTLRPC_REPLY_EARLY" ref="ga4223d4b654456d504d272bebd9ebba23" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_REPLY_EARLY</b>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga199fecbfb969a5e469f5f84fcffa12a4"></a><!-- doxytag: member="net::LPRFL_EARLY_REPLY" ref="ga199fecbfb969a5e469f5f84fcffa12a4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LPRFL_EARLY_REPLY</b>&nbsp;&nbsp;&nbsp;1</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga7effbcacfc90f58c6e550e8441ee9b5d"></a><!-- doxytag: member="lustre_net.h::_OST_MAXREQSIZE_SUM" ref="ga7effbcacfc90f58c6e550e8441ee9b5d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _OST_MAXREQSIZE_SUM</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<span class="keyword">sizeof</span>(<span class="keyword">struct </span>lustre_msg) + \
                             sizeof(struct ptlrpc_body) + \
                             sizeof(struct <a class="code" href="structobdo.html">obdo</a>) + \
                             sizeof(struct <a class="code" href="structobd__ioobj.html">obd_ioobj</a>) + \
                             sizeof(struct <a class="code" href="structniobuf__remote.html">niobuf_remote</a>) * DT_MAX_BRW_PAGES)
</pre></div>
<p>OST_IO_MAXREQSIZE ~= lustre_msg + ptlrpc_body + <a class="el" href="structobdo.html">obdo</a> + <a class="el" href="structobd__ioobj.html">obd_ioobj</a> + DT_MAX_BRW_PAGES * <a class="el" href="structniobuf__remote.html">niobuf_remote</a>. </p>
<ul>
<li>single object with 16 pages is 512 bytes</li>
<li>OST_IO_MAXREQSIZE must be at least 1 page of cookies plus some spillover</li>
<li>Must be a multiple of 1024</li>
<li>actual size is about 18K </li>
</ul>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00480">480</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d5d1c7075b9387118d9356833e9abdf"></a><!-- doxytag: member="lustre_net.h::DEBUG_REQ" ref="ga2d5d1c7075b9387118d9356833e9abdf" args="(level, req, fmt, args...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_REQ</td>
          <td>(</td>
          <td class="paramtype">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">req, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args...&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                          \
        <span class="keywordflow">if</span> ((level) &amp; (D_ERROR | D_WARNING)) {                                \
                <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcfs__debug__limit__state.html">cfs_debug_limit_state</a> cdls;                     \
                LIBCFS_DEBUG_MSG_DATA_DECL(msgdata, level, &amp;cdls);            \
                <a class="code" href="group__net.html#gaa7f4f5cd9c831160823af2e141bca1c2" title="Helper that decides if we need to print request accordig to current debug level settings...">debug_req</a>(&amp;msgdata, level, &amp;cdls, req, <span class="stringliteral">&quot;@@@ &quot;</span>fmt<span class="stringliteral">&quot; &quot;</span>, ## args);\
        } <span class="keywordflow">else</span> {                                                              \
                LIBCFS_DEBUG_MSG_DATA_DECL(msgdata, level, NULL);             \
                <a class="code" href="group__net.html#gaa7f4f5cd9c831160823af2e141bca1c2" title="Helper that decides if we need to print request accordig to current debug level settings...">debug_req</a>(&amp;msgdata, level, NULL, req, <span class="stringliteral">&quot;@@@ &quot;</span>fmt<span class="stringliteral">&quot; &quot;</span>, ## args); \
        }                                                                     \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>This is the debug print function you need to use to print request sturucture content into lustre debug log. </p>
<p>for most callers (level is a constant) this is resolved at compile time </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l01302">1302</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01294">ldlm_cli_update_pool()</a>, <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, <a class="el" href="client_8c_source.html#l03045">ptlrpc_abort_inflight()</a>, <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, <a class="el" href="import_8c_source.html#l00648">ptlrpc_connect_import()</a>, <a class="el" href="client_8c_source.html#l02626">ptlrpc_free_committed()</a>, <a class="el" href="import_8c_source.html#l00286">ptlrpc_invalidate_import()</a>, <a class="el" href="client_8c_source.html#l03006">ptlrpc_replay_req()</a>, <a class="el" href="client_8c_source.html#l02769">ptlrpc_retain_replayable_request()</a>, <a class="el" href="niobuf_8c_source.html#l00420">ptlrpc_unregister_bulk()</a>, <a class="el" href="recover_8c_source.html#l00234">ptlrpc_wake_delayed()</a>, <a class="el" href="ptlrpcd_8c_source.html#l00268">ptlrpcd_add_req()</a>, <a class="el" href="layout_8c_source.html#l01868">req_capsule_server_pack()</a>, <a class="el" href="events_8c_source.html#l00051">request_out_callback()</a>, and <a class="el" href="sec_8c_source.html#l01130">sptlrpc_cli_unwrap_early_reply()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa7f4f5cd9c831160823af2e141bca1c2"></a><!-- doxytag: member="lustre_net.h::debug_req" ref="gaa7f4f5cd9c831160823af2e141bca1c2" args="(msgdata, mask, cdls, req, fmt, a...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define debug_req</td>
          <td>(</td>
          <td class="paramtype">msgdata, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cdls, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">req, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a...&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                          \
        CFS_CHECK_STACK(msgdata, mask, cdls);                                 \
                                                                              \
        <span class="keywordflow">if</span> (((mask) &amp; D_CANTMASK) != 0 ||                                     \
            ((libcfs_debug &amp; (mask)) != 0 &amp;&amp;                                  \
             (libcfs_subsystem_debug &amp; DEBUG_SUBSYSTEM) != 0))                \
                _debug_req((req), msgdata, fmt, ##a);                         \
} <span class="keywordflow">while</span>(0)
</pre></div>
<p>Helper that decides if we need to print request accordig to current debug level settings. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l01288">1288</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf155302427c8b1196ede7e7cd7e7d133"></a><!-- doxytag: member="lustre_net.h::DEBUG_REQ_FLAGS" ref="gaf155302427c8b1196ede7e7cd7e7d133" args="(req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_REQ_FLAGS</td>
          <td>(</td>
          <td class="paramtype">req&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">ptlrpc_rqphase2str(req),                                                \
        <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_intr, <span class="stringliteral">&quot;I&quot;</span>), <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_replied, <span class="stringliteral">&quot;R&quot;</span>),                    \
        <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_err, <span class="stringliteral">&quot;E&quot;</span>),                                                 \
        <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_timedout, <span class="stringliteral">&quot;X&quot;</span>) <span class="comment">/* eXpired */</span>, <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_resend, <span class="stringliteral">&quot;S&quot;</span>),   \
        <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_restart, <span class="stringliteral">&quot;T&quot;</span>), <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_replay, <span class="stringliteral">&quot;P&quot;</span>),                  \
        <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_no_resend, <span class="stringliteral">&quot;N&quot;</span>),                                           \
        <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_waiting, <span class="stringliteral">&quot;W&quot;</span>),                                             \
        <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_wait_ctx, <span class="stringliteral">&quot;C&quot;</span>), <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_hp, <span class="stringliteral">&quot;H&quot;</span>),                     \
        <a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583" title="Debugging functions and helpers to print request structure into debug log.">FLAG</a>(req-&gt;rq_committed, <span class="stringliteral">&quot;M&quot;</span>)
</pre></div>
<p>Convert bit flags into a string. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l01267">1267</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a944e6b359ce130537f3ab0efdd5a2a"></a><!-- doxytag: member="lustre_net.h::LDLM_THR_FACTOR" ref="ga3a944e6b359ce130537f3ab0efdd5a2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_THR_FACTOR&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Buffer Constants. </p>
<p>Constants determine how memory is used to buffer incoming service requests.</p>
<p>?_NBUFS # buffers to allocate when growing the pool ?_BUFSIZE # bytes in a single request buffer ?_MAXREQSIZE # maximum request service will receive</p>
<p>When fewer than ?_NBUFS/2 buffers are posted for receive, another chunk of ?_NBUFS is added to the pool.</p>
<p>Messages larger than ?_MAXREQSIZE are dropped. Request buffers are considered full when less than ?_MAXREQSIZE is left in them. Thread Constants Constants determine how threads are created for ptlrpc service.</p>
<p>?_NTHRS_INIT # threads to create for each service partition on initializing. If it's non-affinity service and there is only one partition, it's the overall # threads for the service while initializing. ?_NTHRS_BASE # threads should be created at least for each ptlrpc partition to keep the service healthy. It's the low-water mark of threads upper-limit for each partition. ?_THR_FACTOR # threads can be added on threads upper-limit for each CPU core. This factor is only for reference, we might decrease value of factor if number of cores per CPT is above a limit. ?_NTHRS_MAX # overall threads can be created for a service, it's a soft limit because if service is running on machine with hundreds of cores and tens of CPU partitions, we need to guarantee each partition has ?_NTHRS_BASE threads, which means total threads will be ?_NTHRS_BASE * number_of_cpts which can exceed ?_NTHRS_MAX.</p>
<p>Examples</p>
<p>define MDS_NTHRS_INIT 2 define MDS_NTHRS_BASE 64 define MDS_NTHRS_FACTOR 8 define MDS_NTHRS_MAX 1024</p>
<p>Example 1): --------------------------------------------------------------------- Server(A) has 16 cores, user configured it to 4 partitions so each partition has 4 cores, then actual number of service threads on each partition is: MDS_NTHRS_BASE(64) + cores(4) * MDS_NTHRS_FACTOR(8) = 96</p>
<p>Total number of threads for the service is: 96 * partitions(4) = 384</p>
<p>Example 2): --------------------------------------------------------------------- Server(B) has 32 cores, user configured it to 4 partitions so each partition has 8 cores, then actual number of service threads on each partition is: MDS_NTHRS_BASE(64) + cores(8) * MDS_NTHRS_FACTOR(8) = 128</p>
<p>Total number of threads for the service is: 128 * partitions(4) = 512</p>
<p>Example 3): --------------------------------------------------------------------- Server(B) has 96 cores, user configured it to 8 partitions so each partition has 12 cores, then actual number of service threads on each partition is: MDS_NTHRS_BASE(64) + cores(12) * MDS_NTHRS_FACTOR(8) = 160</p>
<p>Total number of threads for the service is: 160 * partitions(8) = 1280</p>
<p>However, it's above the soft limit MDS_NTHRS_MAX, so we choose this number as upper limit of threads number for each partition: MDS_NTHRS_MAX(1024) / partitions(8) = 128</p>
<p>Example 4): --------------------------------------------------------------------- Server(C) have a thousand of cores and user configured it to 32 partitions MDS_NTHRS_BASE(64) * 32 = 2048</p>
<p>which is already above soft limit MDS_NTHRS_MAX(1024), but we still need to guarantee that each partition has at least MDS_NTHRS_BASE(64) threads to keep service healthy, so total number of threads will just be 2048.</p>
<p>NB: we don't suggest to choose server with that many cores because backend filesystem itself, buffer cache, or underlying <a class="el" href="structnetwork.html">network</a> stack might have some SMP scalability issues at that large scale.</p>
<p>If user already has a fat machine with hundreds or thousands of cores, there are two choices for configuration: a) create CPU table from subset of all CPUs and run Lustre on top of this subset b) bind service threads on a few partitions, see modparameters of MDS and OSS for details</p>
<p>NB: these calculations (and examples below) are simplified to help understanding, the real implementation is a little more complex, please see ptlrpc_server_nthreads_check() for details. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00257">257</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga89120bf4c91617f84fb648d3445c4d0d"></a><!-- doxytag: member="lustre_net.h::MDS_BUFSIZE" ref="ga89120bf4c91617f84fb648d3445c4d0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MDS_BUFSIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">max(<a class="code" href="group__net.html#ga0925bdb5333dd708e0aa362a7b859f87" title="Assume file name length = FNAME_MAX = 256 (true for ext3).">MDS_MAXREQSIZE</a> + SPTLRPC_MAX_PAYLOAD, \
                                    8 * 1024)
</pre></div>
<p>MDS_BUFSIZE = max_reqsize (w/o LOV EA) + max sptlrpc payload size. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00379">379</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga11a8ca7b7077906bf6d328588ec4dec4"></a><!-- doxytag: member="lustre_net.h::MDS_EA_MAXREQSIZE" ref="ga11a8ca7b7077906bf6d328588ec4dec4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MDS_EA_MAXREQSIZE&nbsp;&nbsp;&nbsp;66288</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the size of a maximum REINT_SETXATTR request:. </p>
<p>lustre_msg 56 (32 + 4 x 5 + 4) ptlrpc_body 184 <a class="el" href="structmdt__rec__setxattr.html">mdt_rec_setxattr</a> 136 <a class="el" href="structlustre__capa.html">lustre_capa</a> 120 name 256 (XATTR_NAME_MAX) value 65536 (XATTR_SIZE_MAX) </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00360">360</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="gacacc3457857ade161935c93720109685"></a><!-- doxytag: member="lustre_net.h::MDS_LOV_MAXREPSIZE" ref="gacacc3457857ade161935c93720109685" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MDS_LOV_MAXREPSIZE&nbsp;&nbsp;&nbsp;MDS_LOV_MAXREQSIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MDS outgoing reply with LOV EA. </p>
<p>NB: max reply size Lustre 2.4+ client can get from old MDS is: LOV_MAX_STRIPE_COUNT * (<a class="el" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> + lov_ost_data) + extra bytes</p>
<p>but 2.4 or later MDS will never send reply with <a class="el" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> to any version client. This macro is defined for server side reply buffer size. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00348">348</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga30f21c5f8837df1463edffb20d62a4f2"></a><!-- doxytag: member="lustre_net.h::MDS_LOV_MAXREQSIZE" ref="ga30f21c5f8837df1463edffb20d62a4f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MDS_LOV_MAXREQSIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">max(<a class="code" href="group__net.html#ga0925bdb5333dd708e0aa362a7b859f87" title="Assume file name length = FNAME_MAX = 256 (true for ext3).">MDS_MAXREQSIZE</a>, \
                                    362 + LOV_MAX_STRIPE_COUNT * 24)
</pre></div>
<p>MDS incoming request with LOV EA 24 = sizeof(struct lov_ost_data), i.e: replay of opencreate. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00337">337</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0925bdb5333dd708e0aa362a7b859f87"></a><!-- doxytag: member="lustre_net.h::MDS_MAXREQSIZE" ref="ga0925bdb5333dd708e0aa362a7b859f87" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MDS_MAXREQSIZE&nbsp;&nbsp;&nbsp;(5 * 1024)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assume file name length = FNAME_MAX = 256 (true for ext3). </p>
<p>path name length = PATH_MAX = 4096 LOV MD size max = EA_MAX = 24 * 2000 (NB: 24 is size of lov_ost_data) LOV LOGCOOKIE size max = 32 * 2000 (NB: 32 is size of <a class="el" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a>) symlink: FNAME_MAX + PATH_MAX &lt;- largest link: FNAME_MAX + PATH_MAX (mds_rec_link &lt; mds_rec_create) rename: FNAME_MAX + FNAME_MAX open: FNAME_MAX + EA_MAX</p>
<p>MDS_MAXREQSIZE ~= 4736 bytes = lustre_msg + <a class="el" href="structldlm__request.html">ldlm_request</a> + <a class="el" href="structmdt__body.html">mdt_body</a> + mds_rec_create + FNAME_MAX + PATH_MAX MDS_MAXREPSIZE ~= 8300 bytes = lustre_msg + llog_header</p>
<p>Realistic size is about 512 bytes (20 character name + 128 char symlink), except in the open case where there are a large number of OSTs in a LOV. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00330">330</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="gace39c2a24b8ed087135caf8102925f80"></a><!-- doxytag: member="lustre_net.h::MDS_REG_BUFSIZE" ref="gace39c2a24b8ed087135caf8102925f80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MDS_REG_BUFSIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">max(<a class="code" href="group__net.html#ga55304816884c7b0a95e492ced0d476ff" title="These are the maximum request and reply sizes (rounded up to 1 KB boundaries) for...">MDS_REG_MAXREQSIZE</a> + SPTLRPC_MAX_PAYLOAD, \
                                    160 * 1024)
</pre></div>
<p>MDS_REG_BUFSIZE should at least be MDS_REG_MAXREQSIZE + SPTLRPC_MAX_PAYLOAD. </p>
<p>However, we need to allocate a much larger buffer for it because LNet requires each MD(rqbd) has at least MDS_REQ_MAXREQSIZE bytes left to avoid dropping of maximum-sized incoming request. So if MDS_REG_BUFSIZE is only a little larger than MDS_REG_MAXREQSIZE, then it can only fit in one request even there are about MDS_REG_MAX_REQSIZE bytes left in a rqbd, and memory utilization is very low.</p>
<p>In the meanwhile, size of rqbd can't be too large, because rqbd can't be reused until all requests fit in it have been processed and released, which means one long blocked request can prevent the rqbd be reused. Now we set request buffer size to 160 KB, so even each rqbd is unlinked from LNet with unused 65 KB, buffer utilization will be about 59%. Please check LU-2432 for details. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00398">398</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga55304816884c7b0a95e492ced0d476ff"></a><!-- doxytag: member="lustre_net.h::MDS_REG_MAXREQSIZE" ref="ga55304816884c7b0a95e492ced0d476ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MDS_REG_MAXREQSIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(((max(<a class="code" href="group__net.html#ga11a8ca7b7077906bf6d328588ec4dec4" title="This is the size of a maximum REINT_SETXATTR request:.">MDS_EA_MAXREQSIZE</a>, \
                                       <a class="code" href="group__net.html#ga30f21c5f8837df1463edffb20d62a4f2" title="MDS incoming request with LOV EA 24 = sizeof(struct lov_ost_data), i.e: replay of...">MDS_LOV_MAXREQSIZE</a>) + 1023) &gt;&gt; 10) &lt;&lt; 10)
</pre></div>
<p>These are the maximum request and reply sizes (rounded up to 1 KB boundaries) for the "regular" MDS_REQUEST_PORTAL and MDS_REPLY_PORTAL. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00366">366</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1278d9299d9ff6ef534065ab23eba663"></a><!-- doxytag: member="lustre_net.h::OSS_THR_FACTOR" ref="ga1278d9299d9ff6ef534065ab23eba663" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSS_THR_FACTOR</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">min_t(<span class="keywordtype">int</span>, 8, \
                                NUM_CACHEPAGES &gt;&gt; (28 - PAGE_CACHE_SHIFT))
</pre></div>
<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00459">459</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga910924170a8059c49ec72de9a3afebb3"></a><!-- doxytag: member="lustre_net.h::OST_IO_MAXREQSIZE" ref="ga910924170a8059c49ec72de9a3afebb3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OST_IO_MAXREQSIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">max_t(<span class="keywordtype">int</span>, <a class="code" href="group__net.html#ga90591733c0c1eee622c2b8b512fd89e3" title="FIEMAP request can be 4K+ for now.">OST_MAXREQSIZE</a>, \
                                (((<a class="code" href="group__net.html#ga7effbcacfc90f58c6e550e8441ee9b5d" title="OST_IO_MAXREQSIZE ~= lustre_msg + ptlrpc_body + obdo + obd_ioobj + DT_MAX_BRW_PAGES...">_OST_MAXREQSIZE_SUM</a> - 1) | (1024 - 1)) + 1))
</pre></div>
<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00489">489</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae34be12e43c77807e8487670d8c4b119"></a><!-- doxytag: member="lustre_net.h::OUT_BUFSIZE" ref="gae34be12e43c77807e8487670d8c4b119" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OUT_BUFSIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">max(<a class="code" href="group__net.html#ga3061b67fa028fa7ea59239b69b10c911" title="The update request includes all of updates from the create, which might include linkea...">OUT_MAXREQSIZE</a> + SPTLRPC_MAX_PAYLOAD, \
                                    24 * 1024)
</pre></div>
<p>OUT_BUFSIZE = max_out_reqsize + max sptlrpc payload (~1K) which is about 10K, for the same reason as MDS_REG_BUFSIZE, we also give some extra bytes to each request buffer to improve buffer utilization rate. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00406">406</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabf4b4d7a3ddddab43ae78ddefc08af29"></a><!-- doxytag: member="lustre_net.h::PTLRPC_BULK_OPS_BITS" ref="gabf4b4d7a3ddddab43ae78ddefc08af29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTLRPC_BULK_OPS_BITS&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>log2 max # of bulk operations in one request: 2=4MB/RPC, 5=32MB/RPC, . </p>
<p>.. In order for the client and server to properly negotiate the maximum possible transfer size, PTLRPC_BULK_OPS_COUNT must be a power-of-two value. The client is free to limit the actual RPC size for any bulk transfer via cl_max_pages_per_rpc to some non-power-of-two value. NOTE: This is limited to 16 (=64GB RPCs) by IOOBJ_MAX_BRW_BITS. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00082">82</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8b841cf2fb3c1d1c92a9ddcf7068bb4c"></a><!-- doxytag: member="lustre_net.h::PTLRPC_BULK_OPS_MASK" ref="ga8b841cf2fb3c1d1c92a9ddcf7068bb4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTLRPC_BULK_OPS_MASK&nbsp;&nbsp;&nbsp;(~((__u64)PTLRPC_BULK_OPS_COUNT - 1))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PTLRPC_BULK_OPS_MASK is for the convenience of the client only, and should not be used on the server at all. </p>
<p>Otherwise, it imposes a protocol limitation on the maximum RPC size that can be used by any RPC sent to that server in the future. Instead, the server should use the negotiated per-client ocd_brw_size to determine the bulk RPC count. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00094">94</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00301">ptlrpc_register_bulk()</a>.</p>

</div>
</div>
<a class="anchor" id="ga507b0acc65154a8e8842879d5f4db30b"></a><!-- doxytag: member="lustre_net.h::PTLRPC_MAX_BRW_BITS" ref="ga507b0acc65154a8e8842879d5f4db30b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTLRPC_MAX_BRW_BITS&nbsp;&nbsp;&nbsp;(LNET_MTU_BITS + PTLRPC_BULK_OPS_BITS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define maxima for bulk I/O. </p>
<p>A single PTLRPC BRW request is sent via up to PTLRPC_BULK_OPS_COUNT of LNET_MTU sized RDMA transfers. Clients and servers negotiate the currently supported maximum between peers at connect via ocd_brw_size. </p>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l00103">103</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadfc88ea5f31c558c5e23cd0a999bd36d"></a><!-- doxytag: member="lustre_net.h::ptlrpc_service_for_each_part" ref="gadfc88ea5f31c558c5e23cd0a999bd36d" args="(part, i, svc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ptlrpc_service_for_each_part</td>
          <td>(</td>
          <td class="paramtype">part, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">svc&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (i = 0;                                                     \
             i &lt; (svc)-&gt;srv_ncpts &amp;&amp;                                    \
             (svc)-&gt;srv_parts != NULL &amp;&amp;                                \
             ((part) = (svc)-&gt;srv_parts[i]) != NULL; i++)
</pre></div>
<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l01857">1857</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaaa41ab709a4804427e6eb05360ebbed4"></a><!-- doxytag: member="lustre_net.h::ptlrpcd_ctl_flags" ref="gaaa41ab709a4804427e6eb05360ebbed4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__net.html#gaaa41ab709a4804427e6eb05360ebbed4">ptlrpcd_ctl_flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c"></a><!-- doxytag: member="LIOD_START" ref="ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c" args="" -->LIOD_START</em>&nbsp;</td><td>
<p>Ptlrpc thread start flag. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c"></a><!-- doxytag: member="LIOD_STOP" ref="ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c" args="" -->LIOD_STOP</em>&nbsp;</td><td>
<p>Ptlrpc thread stop flag. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa41ab709a4804427e6eb05360ebbed4ad315ddb8cfd7bec02047607f28de70e2"></a><!-- doxytag: member="LIOD_FORCE" ref="ggaaa41ab709a4804427e6eb05360ebbed4ad315ddb8cfd7bec02047607f28de70e2" args="" -->LIOD_FORCE</em>&nbsp;</td><td>
<p>Ptlrpc thread force flag (only stop force so far). </p>
<p>This will cause aborting any inflight rpcs handled by thread if LIOD_STOP is specified. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa41ab709a4804427e6eb05360ebbed4a5a3062cb119fabc0613a8b5dc2e7b75b"></a><!-- doxytag: member="LIOD_RECOVERY" ref="ggaaa41ab709a4804427e6eb05360ebbed4a5a3062cb119fabc0613a8b5dc2e7b75b" args="" -->LIOD_RECOVERY</em>&nbsp;</td><td>
<p>This is a recovery ptlrpc thread. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lustre__net_8h_source.html#l01922">1922</a> of file <a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01922"></a>01922                        {
<a name="l01926"></a>01926         <a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c" title="Ptlrpc thread start flag.">LIOD_START</a>       = 1 &lt;&lt; 0,
<a name="l01930"></a>01930         <a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c" title="Ptlrpc thread stop flag.">LIOD_STOP</a>        = 1 &lt;&lt; 1,
<a name="l01936"></a>01936         <a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4ad315ddb8cfd7bec02047607f28de70e2" title="Ptlrpc thread force flag (only stop force so far).">LIOD_FORCE</a>       = 1 &lt;&lt; 2,
<a name="l01940"></a>01940         <a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a5a3062cb119fabc0613a8b5dc2e7b75b" title="This is a recovery ptlrpc thread.">LIOD_RECOVERY</a>    = 1 &lt;&lt; 3,
<a name="l01941"></a>01941 };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0d66e2da6f0da4bb948be01b9719af5c"></a><!-- doxytag: member="lustre_net.h::client_import_find_conn" ref="ga0d66e2da6f0da4bb948be01b9719af5c" args="(struct obd_import *imp, lnet_nid_t peer, struct obd_uuid *uuid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int client_import_find_conn </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a>&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *&nbsp;</td>
          <td class="paramname"> <em>uuid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find conn UUID by peer NID. </p>
<p><em>peer</em> is a server NID. This function is used to find a conn uuid of <em>imp</em> which can reach <em>peer</em>. </p>

<p>Definition at line <a class="el" href="ldlm__lib_8c_source.html#l00199">199</a> of file <a class="el" href="ldlm__lib_8c_source.html">ldlm_lib.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00267">obd_import::imp_conn_list</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00141">obd_import_conn::oic_item</a>, and <a class="el" href="lustre__import_8h_source.html#l00145">obd_import_conn::oic_uuid</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00201"></a>00201 {
<a name="l00202"></a>00202         <span class="keyword">struct </span><a class="code" href="structobd__import__conn.html" title="Definition of import connection structure.">obd_import_conn</a> *conn;
<a name="l00203"></a>00203         <span class="keywordtype">int</span> rc = -ENOENT;
<a name="l00204"></a>00204         ENTRY;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00207"></a>00207         list_for_each_entry(conn, &amp;imp-&gt;<a class="code" href="structobd__import.html#a6a268202c5cd1a1e69b92f10355c81e5" title="List of all possible connection for import.">imp_conn_list</a>, <a class="code" href="structobd__import__conn.html#af3d6c3ee5b8330992011e80166139852" title="Item for linking connections together.">oic_item</a>) {
<a name="l00208"></a>00208                 <span class="comment">/* Check if conn UUID does have this peer NID. */</span>
<a name="l00209"></a>00209                 <span class="keywordflow">if</span> (class_check_uuid(&amp;conn-&gt;<a class="code" href="structobd__import__conn.html#ab1781dad90184103cfefe6aa82221d63" title="uuid of remote side">oic_uuid</a>, peer)) {
<a name="l00210"></a>00210                         *uuid = conn-&gt;<a class="code" href="structobd__import__conn.html#ab1781dad90184103cfefe6aa82221d63" title="uuid of remote side">oic_uuid</a>;
<a name="l00211"></a>00211                         rc = 0;
<a name="l00212"></a>00212                         <span class="keywordflow">break</span>;
<a name="l00213"></a>00213                 }
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00216"></a>00216         RETURN(rc);
<a name="l00217"></a>00217 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8ddfe4bfdb34b2159b8281fb3c6e09a4"></a><!-- doxytag: member="lustre_net.h::lustre_msg_buflen" ref="ga8ddfe4bfdb34b2159b8281fb3c6e09a4" args="(struct lustre_msg *m, __u32 n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__u32 lustre_msg_buflen </td>
          <td>(</td>
          <td class="paramtype">struct lustre_msg *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lustre_msg_buflen - return the length of buffer <em>n</em> in message <em>m</em> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>lustre_msg (request or reply) to look at </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>message index (base 0)</td></tr>
  </table>
  </dd>
</dl>
<p>returns zero for non-existent message indices </p>

<p>Definition at line <a class="el" href="pack__generic_8c_source.html#l00688">688</a> of file <a class="el" href="pack__generic_8c_source.html">pack_generic.c</a>.</p>

<p>Referenced by <a class="el" href="layout_8c_source.html#l02263">req_capsule_get_size()</a>, and <a class="el" href="layout_8c_source.html#l02416">req_capsule_shrink()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00689"></a>00689 {
<a name="l00690"></a>00690         <span class="keywordflow">switch</span> (m-&gt;lm_magic) {
<a name="l00691"></a>00691         <span class="keywordflow">case</span> LUSTRE_MSG_MAGIC_V2:
<a name="l00692"></a>00692                 <span class="keywordflow">return</span> lustre_msg_buflen_v2(m, n);
<a name="l00693"></a>00693         <span class="keywordflow">default</span>:
<a name="l00694"></a>00694                 CERROR(<span class="stringliteral">&quot;incorrect message magic: %08x\n&quot;</span>, m-&gt;lm_magic);
<a name="l00695"></a>00695                 <span class="keywordflow">return</span> 0;
<a name="l00696"></a>00696         }
<a name="l00697"></a>00697 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga8ddfe4bfdb34b2159b8281fb3c6e09a4_icgraph.png" border="0" usemap="#group__net_ga8ddfe4bfdb34b2159b8281fb3c6e09a4_icgraph_map" alt=""></div>
<map name="group__net_ga8ddfe4bfdb34b2159b8281fb3c6e09a4_icgraph_map" id="group__net_ga8ddfe4bfdb34b2159b8281fb3c6e09a4_icgraph">
<area shape="rect" id="node3" href="group__req__layout.html#ga102a4e6bb0a627ead289f4684971fc28" title="Return the actual PTLRPC buffer length of a request or reply (loc) for the given..." alt="" coords="396,24,561,54"/><area shape="rect" id="node10" href="group__req__layout.html#gaf42efe506903884592711902e9276e99" title="This function shrinks the size of the _buffer_ of the pill&#39;s PTLRPC request or..." alt="" coords="200,104,347,134"/><area shape="rect" id="node5" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="863,24,999,54"/><area shape="rect" id="node7" href="group__ldlm__cli__api.html#gac421005283912bb5186b035013aa58c0" title="Finishing portion of client lock enqueue code." alt="" coords="628,24,791,54"/><area shape="rect" id="node12" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps..." alt="" coords="400,131,557,160"/><area shape="rect" id="node14" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="637,78,781,107"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="635,184,784,214"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1076,236,1217,266"/><area shape="rect" id="node39" href="group__net.html#gac578ffdc47c9c2141c34c4798a55cce4" title="Allocate new request for operatione opcode and immediatelly pack it for network transfer..." alt="" coords="612,131,807,160"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="857,184,1004,214"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1087,79,1207,108"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1055,132,1239,162"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1539,158,1781,187"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1289,79,1489,108"/><area shape="rect" id="node24" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1591,79,1729,108"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1288,132,1491,162"/><area shape="rect" id="node33" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1829,158,2005,187"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga52f0aef010b62759e4c2f9e6ef6aea3d"></a><!-- doxytag: member="lustre_net.h::ptl_send_rpc" ref="ga52f0aef010b62759e4c2f9e6ef6aea3d" args="(struct ptlrpc_request *request, int noreply)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptl_send_rpc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>noreply</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send request <em>request</em>. </p>
<p>if <em>noreply</em> is set, don't expect any reply back and don't set up reply buffers. Returns 0 on success or error code. </p>

<p><p>For enabled AT all request should have AT_SUPPORT in the FULL import state when OBD_CONNECT_AT is set </p>
</p>

<p>Definition at line <a class="el" href="niobuf_8c_source.html#l00660">660</a> of file <a class="el" href="niobuf_8c_source.html">niobuf.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l00521">ptlrpc_connection::c_peer</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00440">lnet_md_t::eq_handle</a>, <a class="el" href="lustre__import_8h_source.html#l00239">obd_import::imp_conn_cnt</a>, <a class="el" href="lustre__import_8h_source.html#l00170">obd_import::imp_connection</a>, <a class="el" href="lustre__import_8h_source.html#l00220">obd_import::imp_inflight</a>, <a class="el" href="lustre__import_8h_source.html#l00202">obd_import::imp_known_replied_xid</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__import_8h_source.html#l00260">obd_import::imp_remote_handle</a>, <a class="el" href="lustre__import_8h_source.html#l00230">obd_import::imp_state</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00333">LNET_INS_AFTER</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00459">LNET_MD_MANAGE_REMOTE</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00455">LNET_MD_OP_PUT</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00476">LNET_MD_THRESH_INF</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00462">LNET_MD_TRUNCATE</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00647">LNET_NOACK_REQ</a>, <a class="el" href="lib-md_8c_source.html#l00263">LNetMDAttach()</a>, <a class="el" href="lib-me_8c_source.html#l00076">LNetMEAttach()</a>, <a class="el" href="lib-me_8c_source.html#l00227">LNetMEUnlink()</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00426">lnet_md_t::options</a>, <a class="el" href="niobuf_8c_source.html#l00301">ptlrpc_register_bulk()</a>, <a class="el" href="client_8c_source.html#l02490">ptlrpc_req_finished()</a>, <a class="el" href="client_8c_source.html#l02757">ptlrpc_request_addref()</a>, <a class="el" href="niobuf_8c_source.html#l00420">ptlrpc_unregister_bulk()</a>, <a class="el" href="lustre__net_8h_source.html#l01119">ptlrpc_request::rq_deadline</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01038">ptlrpc_request::rq_mbits</a>, <a class="el" href="lustre__net_8h_source.html#l01080">ptlrpc_request::rq_repbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01081">ptlrpc_request::rq_repdata</a>, <a class="el" href="lustre__net_8h_source.html#l01026">ptlrpc_request::rq_replen</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01079">ptlrpc_request::rq_reqbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01117">ptlrpc_request::rq_sent</a>, <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>, <a class="el" href="lustre__net_8h_source.html#l01113">ptlrpc_request::rq_timeout</a>, <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>, <a class="el" href="sec_8c_source.html#l01707">sptlrpc_cli_alloc_repbuf()</a>, <a class="el" href="sec_8c_source.html#l00978">sptlrpc_cli_wrap_request()</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00369">lnet_md_t::start</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00381">lnet_md_t::threshold</a>, and <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00433">lnet_md_t::user_ptr</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00661"></a>00661 {
<a name="l00662"></a>00662         <span class="keywordtype">int</span> rc;
<a name="l00663"></a>00663         <span class="keywordtype">int</span> rc2;
<a name="l00664"></a>00664         <span class="keywordtype">int</span> mpflag = 0;
<a name="l00665"></a>00665         <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> *connection;
<a name="l00666"></a>00666         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_me_t</a>  reply_me_h;
<a name="l00667"></a>00667         <a class="code" href="structlnet__md__t.html" title="Defines the visible parts of a memory descriptor.">lnet_md_t</a>         reply_md;
<a name="l00668"></a>00668         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l00669"></a>00669         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd = imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>;
<a name="l00670"></a>00670         ENTRY;
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_DROP_RPC))
<a name="l00673"></a>00673                 RETURN(0);
<a name="l00674"></a>00674 
<a name="l00675"></a>00675         LASSERT(request-&gt;rq_type == PTL_RPC_MSG_REQUEST);
<a name="l00676"></a>00676         LASSERT(request-&gt;rq_wait_ctx == 0);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678         <span class="comment">/* If this is a re-transmit, we&apos;re required to have disengaged</span>
<a name="l00679"></a>00679 <span class="comment">         * cleanly from the previous attempt */</span>
<a name="l00680"></a>00680         LASSERT(!request-&gt;rq_receiving_reply);
<a name="l00681"></a>00681         LASSERT(!((lustre_msg_get_flags(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; MSG_REPLAY) &amp;&amp;
<a name="l00682"></a>00682                 (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_FULL)));
<a name="l00683"></a>00683 
<a name="l00684"></a>00684         <span class="keywordflow">if</span> (unlikely(obd != NULL &amp;&amp; obd-&gt;obd_fail)) {
<a name="l00685"></a>00685                 CDEBUG(D_HA, <span class="stringliteral">&quot;muting rpc for failed imp obd %s\n&quot;</span>,
<a name="l00686"></a>00686                         obd-&gt;obd_name);
<a name="l00687"></a>00687                 <span class="comment">/* this prevents us from waiting in ptlrpc_queue_wait */</span>
<a name="l00688"></a>00688                 spin_lock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00689"></a>00689                 request-&gt;rq_err = 1;
<a name="l00690"></a>00690                 spin_unlock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00691"></a>00691                 request-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -ENODEV;
<a name="l00692"></a>00692                 RETURN(-ENODEV);
<a name="l00693"></a>00693         }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695         connection = imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>;
<a name="l00696"></a>00696 
<a name="l00697"></a>00697         lustre_msg_set_handle(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>,
<a name="l00698"></a>00698                               &amp;imp-&gt;<a class="code" href="structobd__import.html#a0b8bb1da93c9c21f85044d87a7104a4e" title="Remote export handle.">imp_remote_handle</a>);
<a name="l00699"></a>00699         lustre_msg_set_type(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, PTL_RPC_MSG_REQUEST);
<a name="l00700"></a>00700         lustre_msg_set_conn_cnt(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>,
<a name="l00701"></a>00701                                 imp-&gt;<a class="code" href="structobd__import.html#ac3b8409237b9f6fc17e80bdfed39a1d5" title="Incremented every time we send reconnection request.">imp_conn_cnt</a>);
<a name="l00702"></a>00702         lustre_msghdr_set_flags(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>,
<a name="l00703"></a>00703                                 imp-&gt;imp_msghdr_flags);
<a name="l00704"></a>00704 
<a name="l00705"></a>00705         <span class="comment">/* If it&apos;s the first time to resend the request for EINPROGRESS,</span>
<a name="l00706"></a>00706 <span class="comment">         * we need to allocate a new XID (see after_reply()), it&apos;s different</span>
<a name="l00707"></a>00707 <span class="comment">         * from the resend for reply timeout. */</span>
<a name="l00708"></a>00708         <span class="keywordflow">if</span> (request-&gt;rq_nr_resend != 0 &amp;&amp;
<a name="l00709"></a>00709             list_empty(&amp;request-&gt;rq_unreplied_list)) {
<a name="l00710"></a>00710                 __u64 min_xid = 0;
<a name="l00711"></a>00711                 <span class="comment">/* resend for EINPROGRESS, allocate new xid to avoid reply</span>
<a name="l00712"></a>00712 <span class="comment">                 * reconstruction */</span>
<a name="l00713"></a>00713                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00714"></a>00714                 ptlrpc_assign_next_xid_nolock(request);
<a name="l00715"></a>00715                 request-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a> = request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>;
<a name="l00716"></a>00716                 min_xid = ptlrpc_known_replied_xid(imp);
<a name="l00717"></a>00717                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00718"></a>00718 
<a name="l00719"></a>00719                 lustre_msg_set_last_xid(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, min_xid);
<a name="l00720"></a>00720                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, request, <span class="stringliteral">&quot;Allocating new xid for &quot;</span>
<a name="l00721"></a>00721                           <span class="stringliteral">&quot;resend on EINPROGRESS&quot;</span>);
<a name="l00722"></a>00722         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (request-&gt;rq_bulk != NULL) {
<a name="l00723"></a>00723                 ptlrpc_set_bulk_mbits(request);
<a name="l00724"></a>00724                 lustre_msg_set_mbits(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, request-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a>);
<a name="l00725"></a>00725         }
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         <span class="keywordflow">if</span> (list_empty(&amp;request-&gt;rq_unreplied_list) ||
<a name="l00728"></a>00728             request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> &lt;= imp-&gt;<a class="code" href="structobd__import.html#a3581a8b4f15a6d9ba6daad54873cd0eb" title="Known maximal replied XID.">imp_known_replied_xid</a>) {
<a name="l00729"></a>00729                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, request, <span class="stringliteral">&quot;xid: &quot;</span>LPU64<span class="stringliteral">&quot;, replied: &quot;</span>LPU64<span class="stringliteral">&quot;, &quot;</span>
<a name="l00730"></a>00730                           <span class="stringliteral">&quot;list_empty:%d\n&quot;</span>, request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>,
<a name="l00731"></a>00731                           imp-&gt;<a class="code" href="structobd__import.html#a3581a8b4f15a6d9ba6daad54873cd0eb" title="Known maximal replied XID.">imp_known_replied_xid</a>,
<a name="l00732"></a>00732                           list_empty(&amp;request-&gt;rq_unreplied_list));
<a name="l00733"></a>00733                 LBUG();
<a name="l00734"></a>00734         }
<a name="l00735"></a>00735 
<a name="l00738"></a>00738         LASSERT(AT_OFF || imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> != LUSTRE_IMP_FULL ||
<a name="l00739"></a>00739                 (imp-&gt;imp_msghdr_flags &amp; MSGHDR_AT_SUPPORT) ||
<a name="l00740"></a>00740                 !(imp-&gt;imp_connect_data.ocd_connect_flags &amp;
<a name="l00741"></a>00741                 OBD_CONNECT_AT));
<a name="l00742"></a>00742 
<a name="l00743"></a>00743         <span class="keywordflow">if</span> (request-&gt;rq_resend) {
<a name="l00744"></a>00744                 lustre_msg_add_flags(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, MSG_RESENT);
<a name="l00745"></a>00745                 <span class="keywordflow">if</span> (request-&gt;rq_resend_cb != NULL)
<a name="l00746"></a>00746                         request-&gt;rq_resend_cb(request, &amp;request-&gt;rq_async_args);
<a name="l00747"></a>00747         }
<a name="l00748"></a>00748         <span class="keywordflow">if</span> (request-&gt;rq_memalloc)
<a name="l00749"></a>00749                 mpflag = cfs_memory_pressure_get_and_set();
<a name="l00750"></a>00750 
<a name="l00751"></a>00751         rc = <a class="code" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre-defined security transformation upon the...">sptlrpc_cli_wrap_request</a>(request);
<a name="l00752"></a>00752         <span class="keywordflow">if</span> (rc == -ENOMEM)
<a name="l00753"></a>00753                 <span class="comment">/* set rq_sent so that this request is treated</span>
<a name="l00754"></a>00754 <span class="comment">                 * as a delayed send in the upper layers */</span>
<a name="l00755"></a>00755                 request-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> = cfs_time_current_sec();
<a name="l00756"></a>00756         <span class="keywordflow">if</span> (rc)
<a name="l00757"></a>00757                 GOTO(out, rc);
<a name="l00758"></a>00758 
<a name="l00759"></a>00759         <span class="comment">/* bulk register should be done after wrap_request() */</span>
<a name="l00760"></a>00760         <span class="keywordflow">if</span> (request-&gt;rq_bulk != NULL) {
<a name="l00761"></a>00761                 rc = <a class="code" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Actual interfacing with LNet to put/get/register/unregister stuff.">ptlrpc_register_bulk</a> (request);
<a name="l00762"></a>00762                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00763"></a>00763                         GOTO(out, rc);
<a name="l00764"></a>00764         }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="keywordflow">if</span> (!noreply) {
<a name="l00767"></a>00767                 LASSERT (request-&gt;<a class="code" href="structptlrpc__request.html#aaa9ba7e7b71ad2057d1650469ab15076" title="Reply length.">rq_replen</a> != 0);
<a name="l00768"></a>00768                 <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a> == NULL) {
<a name="l00769"></a>00769                         LASSERT(request-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> == NULL);
<a name="l00770"></a>00770                         LASSERT(request-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> == NULL);
<a name="l00771"></a>00771                         rc = <a class="code" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req.">sptlrpc_cli_alloc_repbuf</a>(request,
<a name="l00772"></a>00772                                                       request-&gt;<a class="code" href="structptlrpc__request.html#aaa9ba7e7b71ad2057d1650469ab15076" title="Reply length.">rq_replen</a>);
<a name="l00773"></a>00773                         <span class="keywordflow">if</span> (rc) {
<a name="l00774"></a>00774                                 <span class="comment">/* this prevents us from looping in</span>
<a name="l00775"></a>00775 <span class="comment">                                 * ptlrpc_queue_wait */</span>
<a name="l00776"></a>00776                                 spin_lock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00777"></a>00777                                 request-&gt;rq_err = 1;
<a name="l00778"></a>00778                                 spin_unlock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00779"></a>00779                                 request-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = rc;
<a name="l00780"></a>00780                                 GOTO(cleanup_bulk, rc);
<a name="l00781"></a>00781                         }
<a name="l00782"></a>00782                 } <span class="keywordflow">else</span> {
<a name="l00783"></a>00783                         request-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> = NULL;
<a name="l00784"></a>00784                         request-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> = NULL;
<a name="l00785"></a>00785                 }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787                 rc = <a class="code" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal.">LNetMEAttach</a>(request-&gt;rq_reply_portal,<span class="comment">/*XXX FIXME bug 249*/</span>
<a name="l00788"></a>00788                                   connection-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>, request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>, 0,
<a name="l00789"></a>00789                                   LNET_UNLINK, <a class="code" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a9c92e271885b81271fa1467f486dcd07" title="insert ME after current position or tail of the list">LNET_INS_AFTER</a>, &amp;reply_me_h);
<a name="l00790"></a>00790                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l00791"></a>00791                         CERROR(<span class="stringliteral">&quot;LNetMEAttach failed: %d\n&quot;</span>, rc);
<a name="l00792"></a>00792                         LASSERT (rc == -ENOMEM);
<a name="l00793"></a>00793                         GOTO(cleanup_bulk, rc = -ENOMEM);
<a name="l00794"></a>00794                 }
<a name="l00795"></a>00795         }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797         spin_lock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00798"></a>00798         <span class="comment">/* We are responsible for unlinking the reply buffer */</span>
<a name="l00799"></a>00799         request-&gt;rq_reply_unlinked = noreply;
<a name="l00800"></a>00800         request-&gt;rq_receiving_reply = !noreply;
<a name="l00801"></a>00801         <span class="comment">/* Clear any flags that may be present from previous sends. */</span>
<a name="l00802"></a>00802         request-&gt;rq_req_unlinked = 0;
<a name="l00803"></a>00803         request-&gt;rq_replied = 0;
<a name="l00804"></a>00804         request-&gt;rq_err = 0;
<a name="l00805"></a>00805         request-&gt;rq_timedout = 0;
<a name="l00806"></a>00806         request-&gt;rq_net_err = 0;
<a name="l00807"></a>00807         request-&gt;rq_resend = 0;
<a name="l00808"></a>00808         request-&gt;rq_restart = 0;
<a name="l00809"></a>00809         request-&gt;rq_reply_truncated = 0;
<a name="l00810"></a>00810         spin_unlock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812         <span class="keywordflow">if</span> (!noreply) {
<a name="l00813"></a>00813                 reply_md.<a class="code" href="structlnet__md__t.html#a11130deb533aae021364cdec65dd1935" title="Specify the memory region associated with the memory descriptor.">start</a>     = request-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>;
<a name="l00814"></a>00814                 reply_md.length    = request-&gt;rq_repbuf_len;
<a name="l00815"></a>00815                 <span class="comment">/* Allow multiple early replies */</span>
<a name="l00816"></a>00816                 reply_md.<a class="code" href="structlnet__md__t.html#a60130fbc7253f41b3b6cd8da947ff023" title="Specifies the maximum number of operations that can be performed on the memory descriptor...">threshold</a> = <a class="code" href="group__lnet__md.html#gab5ce273fe5d92ed9f27f71519592e0d2" title="Infinite threshold on MD operations.">LNET_MD_THRESH_INF</a>;
<a name="l00817"></a>00817                 <span class="comment">/* Manage remote for early replies */</span>
<a name="l00818"></a>00818                 reply_md.<a class="code" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">options</a>   = PTLRPC_MD_OPTIONS | <a class="code" href="group__lnet__md.html#ga653ba41bd3978635e420cfa4601193e1" title="Options for the MD structure.">LNET_MD_OP_PUT</a> |
<a name="l00819"></a>00819                         <a class="code" href="group__lnet__md.html#ga972b76d71cbb0e446c273d2edf83cad6" title="See lnet_md_t::options.">LNET_MD_MANAGE_REMOTE</a> |
<a name="l00820"></a>00820                         <a class="code" href="group__lnet__md.html#gab42e05f052fae51874fb3b60471d7c30" title="See lnet_md_t::options.">LNET_MD_TRUNCATE</a>; <span class="comment">/* allow to make EOVERFLOW error */</span>;
<a name="l00821"></a>00821                 reply_md.<a class="code" href="structlnet__md__t.html#a57f16fe0f86a1e86553eb0a1eee4bd58" title="A user-specified value that is associated with the memory descriptor.">user_ptr</a>  = &amp;request-&gt;rq_reply_cbid;
<a name="l00822"></a>00822                 reply_md.<a class="code" href="structlnet__md__t.html#a568b34498bd37af0973c749f5e856a3b" title="A handle for the event queue used to log the operations performed on the memory region...">eq_handle</a> = ptlrpc_eq_h;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824                 <span class="comment">/* We must see the unlink callback to set rq_reply_unlinked,</span>
<a name="l00825"></a>00825 <span class="comment">                 * so we can&apos;t auto-unlink */</span>
<a name="l00826"></a>00826                 rc = <a class="code" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME.">LNetMDAttach</a>(reply_me_h, reply_md, LNET_RETAIN,
<a name="l00827"></a>00827                                   &amp;request-&gt;rq_reply_md_h);
<a name="l00828"></a>00828                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l00829"></a>00829                         CERROR(<span class="stringliteral">&quot;LNetMDAttach failed: %d\n&quot;</span>, rc);
<a name="l00830"></a>00830                         LASSERT (rc == -ENOMEM);
<a name="l00831"></a>00831                         spin_lock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00832"></a>00832                         <span class="comment">/* ...but the MD attach didn&apos;t succeed... */</span>
<a name="l00833"></a>00833                         request-&gt;rq_receiving_reply = 0;
<a name="l00834"></a>00834                         spin_unlock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00835"></a>00835                         GOTO(cleanup_me, rc = -ENOMEM);
<a name="l00836"></a>00836                 }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838                 CDEBUG(D_NET, <span class="stringliteral">&quot;Setup reply buffer: %u bytes, xid &quot;</span>LPU64
<a name="l00839"></a>00839                        <span class="stringliteral">&quot;, portal %u\n&quot;</span>,
<a name="l00840"></a>00840                        request-&gt;rq_repbuf_len, request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>,
<a name="l00841"></a>00841                        request-&gt;rq_reply_portal);
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843 
<a name="l00844"></a>00844         <span class="comment">/* add references on request for request_out_callback */</span>
<a name="l00845"></a>00845         <a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>(request);
<a name="l00846"></a>00846         <span class="keywordflow">if</span> (obd != NULL &amp;&amp; obd-&gt;obd_svc_stats != NULL)
<a name="l00847"></a>00847                 lprocfs_counter_add(obd-&gt;obd_svc_stats, PTLRPC_REQACTIVE_CNTR,
<a name="l00848"></a>00848                         atomic_read(&amp;imp-&gt;<a class="code" href="structobd__import.html#aece380c78562b6b0ddbfb1b5460fcbb2" title="Number of requests currently in-flight.">imp_inflight</a>));
<a name="l00849"></a>00849 
<a name="l00850"></a>00850         OBD_FAIL_TIMEOUT(OBD_FAIL_PTLRPC_DELAY_SEND, request-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a> + 5);
<a name="l00851"></a>00851 
<a name="l00852"></a>00852         do_gettimeofday(&amp;request-&gt;rq_sent_tv);
<a name="l00853"></a>00853         request-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> = cfs_time_current_sec();
<a name="l00854"></a>00854         <span class="comment">/* We give the server rq_timeout secs to process the req, and</span>
<a name="l00855"></a>00855 <span class="comment">           add the network latency for our local timeout. */</span>
<a name="l00856"></a>00856         request-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> = request-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> + request-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a> +
<a name="l00857"></a>00857                 ptlrpc_at_get_net_latency(request);
<a name="l00858"></a>00858 
<a name="l00859"></a>00859         ptlrpc_pinger_sending_on_import(imp);
<a name="l00860"></a>00860 
<a name="l00861"></a>00861         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_INFO, request, <span class="stringliteral">&quot;send flg=%x&quot;</span>,
<a name="l00862"></a>00862                   lustre_msg_get_flags(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l00863"></a>00863         rc = ptl_send_buf(&amp;request-&gt;rq_req_md_h,
<a name="l00864"></a>00864                           request-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>, request-&gt;rq_reqdata_len,
<a name="l00865"></a>00865                           <a class="code" href="group__lnet__data.html#gga7a9fb861289ab6d6f5a555de5a16222daf7554f6ed5ff24f4ab2058283eeffc97" title="Request that no acknowledgment should be generated.">LNET_NOACK_REQ</a>, &amp;request-&gt;rq_req_cbid,
<a name="l00866"></a>00866                           connection,
<a name="l00867"></a>00867                           request-&gt;rq_request_portal,
<a name="l00868"></a>00868                           request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>, 0);
<a name="l00869"></a>00869         <span class="keywordflow">if</span> (likely(rc == 0))
<a name="l00870"></a>00870                 GOTO(out, rc);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872         request-&gt;rq_req_unlinked = 1;
<a name="l00873"></a>00873         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(request);
<a name="l00874"></a>00874         <span class="keywordflow">if</span> (noreply)
<a name="l00875"></a>00875                 GOTO(out, rc);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877  cleanup_me:
<a name="l00878"></a>00878         <span class="comment">/* MEUnlink is safe; the PUT didn&apos;t even get off the ground, and</span>
<a name="l00879"></a>00879 <span class="comment">         * nobody apart from the PUT&apos;s target has the right nid+XID to</span>
<a name="l00880"></a>00880 <span class="comment">         * access the reply buffer. */</span>
<a name="l00881"></a>00881         rc2 = <a class="code" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list.">LNetMEUnlink</a>(reply_me_h);
<a name="l00882"></a>00882         LASSERT (rc2 == 0);
<a name="l00883"></a>00883         <span class="comment">/* UNLINKED callback called synchronously */</span>
<a name="l00884"></a>00884         LASSERT(!request-&gt;rq_receiving_reply);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886  cleanup_bulk:
<a name="l00887"></a>00887         <span class="comment">/* We do sync unlink here as there was no real transfer here so</span>
<a name="l00888"></a>00888 <span class="comment">         * the chance to have long unlink to sluggish net is smaller here. */</span>
<a name="l00889"></a>00889         <a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(request, 0);
<a name="l00890"></a>00890  out:
<a name="l00891"></a>00891         <span class="keywordflow">if</span> (request-&gt;rq_memalloc)
<a name="l00892"></a>00892                 cfs_memory_pressure_restore(mpflag);
<a name="l00893"></a>00893         <span class="keywordflow">return</span> rc;
<a name="l00894"></a>00894 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga52f0aef010b62759e4c2f9e6ef6aea3d_cgraph.png" border="0" usemap="#group__net_ga52f0aef010b62759e4c2f9e6ef6aea3d_cgraph_map" alt=""></div>
<map name="group__net_ga52f0aef010b62759e4c2f9e6ef6aea3d_cgraph_map" id="group__net_ga52f0aef010b62759e4c2f9e6ef6aea3d_cgraph">
<area shape="rect" id="node3" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME." alt="" coords="416,5,541,35"/><area shape="rect" id="node5" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal." alt="" coords="417,71,540,100"/><area shape="rect" id="node7" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list." alt="" coords="421,148,536,177"/><area shape="rect" id="node9" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Actual interfacing with LNet to put/get/register/unregister stuff." alt="" coords="177,101,332,131"/><area shape="rect" id="node14" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request." alt="" coords="181,205,328,235"/><area shape="rect" id="node16" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req." alt="" coords="169,259,340,288"/><area shape="rect" id="node18" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network." alt="" coords="169,312,340,341"/><area shape="rect" id="node20" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req." alt="" coords="167,365,343,395"/><area shape="rect" id="node22" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre&#45;defined security transformation upon the..." alt="" coords="161,419,348,448"/><area shape="rect" id="node24" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc." alt="" coords="399,419,559,448"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga52f0aef010b62759e4c2f9e6ef6aea3d_icgraph.png" border="0" usemap="#group__net_ga52f0aef010b62759e4c2f9e6ef6aea3d_icgraph_map" alt=""></div>
<map name="group__net_ga52f0aef010b62759e4c2f9e6ef6aea3d_icgraph_map" id="group__net_ga52f0aef010b62759e4c2f9e6ef6aea3d_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="160,84,299,113"/><area shape="rect" id="node5" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="721,56,865,85"/><area shape="rect" id="node7" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="348,109,473,139"/><area shape="rect" id="node9" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="523,109,669,139"/><area shape="rect" id="node12" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="719,109,868,139"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="725,163,861,192"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="919,109,1065,139"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1148,29,1268,59"/><area shape="rect" id="node23" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1116,83,1300,112"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1600,108,1843,137"/><area shape="rect" id="node32" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1137,187,1279,216"/><area shape="rect" id="node18" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1351,29,1551,59"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1652,29,1791,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1349,83,1552,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1891,108,2067,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga476170376a6f1bb9bb7f85ade4c774f7"></a><!-- doxytag: member="lustre_net.h::ptlrpc_at_set_req_timeout" ref="ga476170376a6f1bb9bb7f85ade4c774f7" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_at_set_req_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set server timelimit for this req, i.e. </p>
<p>how long are we willing to wait for reply before timing out this request. </p>

<p><p><em>imp_server_timeout</em> means this is reverse import and we send (currently only) ASTs to the client and cannot afford to wait too long for the reply, otherwise the other client (because of which we are sending this request) would timeout waiting for us</p>
</p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00293">293</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, and <a class="el" href="lustre__net_8h_source.html#l01113">ptlrpc_request::rq_timeout</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01185">ldlm_cli_cancel_req()</a>, and <a class="el" href="client_8c_source.html#l03006">ptlrpc_replay_req()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00294"></a>00294 {
<a name="l00295"></a>00295         __u32 serv_est;
<a name="l00296"></a>00296         <span class="keywordtype">int</span> idx;
<a name="l00297"></a>00297         <span class="keyword">struct </span><a class="code" href="structimp__at.html">imp_at</a> *at;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301         <span class="keywordflow">if</span> (AT_OFF) {
<a name="l00302"></a>00302                 <span class="comment">/* non-AT settings */</span>
<a name="l00310"></a>00310                 req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a> = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;imp_server_timeout ?
<a name="l00311"></a>00311                                   obd_timeout / 2 : obd_timeout;
<a name="l00312"></a>00312         } <span class="keywordflow">else</span> {
<a name="l00313"></a>00313                 at = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;imp_at;
<a name="l00314"></a>00314                 idx = import_at_get_index(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>,
<a name="l00315"></a>00315                                           req-&gt;rq_request_portal);
<a name="l00316"></a>00316                 serv_est = at_get(&amp;at-&gt;iat_service_estimate[idx]);
<a name="l00317"></a>00317                 req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a> = at_est2timeout(serv_est);
<a name="l00318"></a>00318         }
<a name="l00319"></a>00319         <span class="comment">/* We could get even fancier here, using history to predict increased</span>
<a name="l00320"></a>00320 <span class="comment">           loading... */</span>
<a name="l00321"></a>00321 
<a name="l00322"></a>00322         <span class="comment">/* Let the server know what this RPC timeout is by putting it in the</span>
<a name="l00323"></a>00323 <span class="comment">           reqmsg*/</span>
<a name="l00324"></a>00324         lustre_msg_set_timeout(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>);
<a name="l00325"></a>00325 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga476170376a6f1bb9bb7f85ade4c774f7_icgraph.png" border="0" usemap="#group__net_ga476170376a6f1bb9bb7f85ade4c774f7_icgraph_map" alt=""></div>
<map name="group__net_ga476170376a6f1bb9bb7f85ade4c774f7_icgraph_map" id="group__net_ga476170376a6f1bb9bb7f85ade4c774f7_icgraph">
<area shape="rect" id="node3" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="260,109,409,139"/><area shape="rect" id="node25" href="group__net.html#gafd4a53f20e90893d5ae03f1996ecb2fc" title="Prepares and queues request for replay." alt="" coords="265,163,404,192"/><area shape="rect" id="node5" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="460,109,607,139"/><area shape="rect" id="node7" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="689,29,809,59"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="657,83,841,112"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1141,108,1384,137"/><area shape="rect" id="node23" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="679,187,820,216"/><area shape="rect" id="node9" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="892,29,1092,59"/><area shape="rect" id="node11" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1193,29,1332,59"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="891,83,1093,112"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1432,108,1608,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga63613680c8953223c8efc4331656b11a"></a><!-- doxytag: member="lustre_net.h::ptlrpc_check_set" ref="ga63613680c8953223c8efc4331656b11a" args="(const struct lu_env *env, struct ptlrpc_request_set *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_check_set </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this sends any unsent RPCs in <em>set</em> and returns 1 if all are sent and no more replies are expected. </p>
<p>(it is possible to get less replies than requests sent e.g. due to timed out requests or requests that we had trouble to send out)</p>
<p>NOTE: This function contains a potential schedule point (cond_resched()). </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l01644">1644</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l00521">ptlrpc_connection::c_peer</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="lustre__import_8h_source.html#l00170">obd_import::imp_connection</a>, <a class="el" href="lustre__import_8h_source.html#l00220">obd_import::imp_inflight</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__import_8h_source.html#l00217">obd_import::imp_recovery_waitq</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00304">lnet_process_id_t::nid</a>, <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, <a class="el" href="client_8c_source.html#l02490">ptlrpc_req_finished()</a>, <a class="el" href="niobuf_8c_source.html#l00420">ptlrpc_unregister_bulk()</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_intr</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_invalid_rqset</a>, <a class="el" href="lustre__net_8h_source.html#l00962">ptlrpc_request::rq_list</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01011">ptlrpc_request::rq_next_phase</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01117">ptlrpc_request::rq_sent</a>, <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>, <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>, and <a class="el" href="sec_8c_source.html#l00675">sptlrpc_req_refresh_ctx()</a>.</p>

<p>Referenced by <a class="el" href="pack__generic_8c_source.html#l01574">do_set_info_async()</a>, and <a class="el" href="client_8c_source.html#l02260">ptlrpc_set_wait()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01645"></a>01645 {
<a name="l01646"></a>01646         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp, *next;
<a name="l01647"></a>01647         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>  comp_reqs;
<a name="l01648"></a>01648         <span class="keywordtype">int</span> force_timer_recalc = 0;
<a name="l01649"></a>01649         ENTRY;
<a name="l01650"></a>01650 
<a name="l01651"></a>01651         <span class="keywordflow">if</span> (atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>) == 0)
<a name="l01652"></a>01652                 RETURN(1);
<a name="l01653"></a>01653 
<a name="l01654"></a>01654         INIT_LIST_HEAD(&amp;comp_reqs);
<a name="l01655"></a>01655         list_for_each_safe(tmp, next, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>) {
<a name="l01656"></a>01656                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l01657"></a>01657                         list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l01658"></a>01658                                    rq_set_chain);
<a name="l01659"></a>01659                 <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l01660"></a>01660                 <span class="keywordtype">int</span> unregistered = 0;
<a name="l01661"></a>01661                 <span class="keywordtype">int</span> async = 1;
<a name="l01662"></a>01662                 <span class="keywordtype">int</span> rc = 0;
<a name="l01663"></a>01663 
<a name="l01664"></a>01664                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_COMPLETE) {
<a name="l01665"></a>01665                         list_move_tail(&amp;req-&gt;rq_set_chain, &amp;comp_reqs);
<a name="l01666"></a>01666                         <span class="keywordflow">continue</span>;
<a name="l01667"></a>01667                 }
<a name="l01668"></a>01668 
<a name="l01669"></a>01669                 <span class="comment">/* This schedule point is mainly for the ptlrpcd caller of this</span>
<a name="l01670"></a>01670 <span class="comment">                 * function.  Most ptlrpc sets are not long-lived and unbounded</span>
<a name="l01671"></a>01671 <span class="comment">                 * in length, but at the least the set used by the ptlrpcd is.</span>
<a name="l01672"></a>01672 <span class="comment">                 * Since the processing time is unbounded, we need to insert an</span>
<a name="l01673"></a>01673 <span class="comment">                 * explicit schedule point to make the thread well-behaved.</span>
<a name="l01674"></a>01674 <span class="comment">                 */</span>
<a name="l01675"></a>01675                 cond_resched();
<a name="l01676"></a>01676 
<a name="l01677"></a>01677                 <span class="comment">/* If the caller requires to allow to be interpreted by force</span>
<a name="l01678"></a>01678 <span class="comment">                 * and it has really been interpreted, then move the request</span>
<a name="l01679"></a>01679 <span class="comment">                 * to RQ_PHASE_INTERPRET phase in spite of what the current</span>
<a name="l01680"></a>01680 <span class="comment">                 * phase is. */</span>
<a name="l01681"></a>01681                 <span class="keywordflow">if</span> (unlikely(req-&gt;rq_allow_intr &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#a6d4f6fc90fdcc8e2492f4ab902147970" title="client-side flags are serialized by rq_lock">rq_intr</a>)) {
<a name="l01682"></a>01682                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EINTR;
<a name="l01683"></a>01683                         ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01684"></a>01684 
<a name="l01685"></a>01685                         <span class="comment">/* Since it is interpreted and we have to wait for</span>
<a name="l01686"></a>01686 <span class="comment">                         * the reply to be unlinked, then use sync mode. */</span>
<a name="l01687"></a>01687                         async = 0;
<a name="l01688"></a>01688 
<a name="l01689"></a>01689                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01690"></a>01690                 }
<a name="l01691"></a>01691 
<a name="l01692"></a>01692                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW &amp;&amp; ptlrpc_send_new_req(req))
<a name="l01693"></a>01693                         force_timer_recalc = 1;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695                 <span class="comment">/* delayed send - skip */</span>
<a name="l01696"></a>01696                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a>)
<a name="l01697"></a>01697                         <span class="keywordflow">continue</span>;
<a name="l01698"></a>01698 
<a name="l01699"></a>01699                 <span class="comment">/* delayed resend - skip */</span>
<a name="l01700"></a>01700                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_RPC &amp;&amp; req-&gt;rq_resend &amp;&amp;
<a name="l01701"></a>01701                     req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> &gt; cfs_time_current_sec())
<a name="l01702"></a>01702                         <span class="keywordflow">continue</span>;
<a name="l01703"></a>01703 
<a name="l01704"></a>01704                 <span class="keywordflow">if</span> (!(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_RPC ||
<a name="l01705"></a>01705                       req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_BULK ||
<a name="l01706"></a>01706                       req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_INTERPRET ||
<a name="l01707"></a>01707                       req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_UNREGISTERING)) {
<a name="l01708"></a>01708                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;bad phase %x&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a>);
<a name="l01709"></a>01709                         LBUG();
<a name="l01710"></a>01710                 }
<a name="l01711"></a>01711 
<a name="l01712"></a>01712                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_UNREGISTERING) {
<a name="l01713"></a>01713                         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a> != req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a>);
<a name="l01714"></a>01714                         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a> != RQ_PHASE_UNDEFINED);
<a name="l01715"></a>01715 
<a name="l01716"></a>01716                         <span class="comment">/*</span>
<a name="l01717"></a>01717 <span class="comment">                         * Skip processing until reply is unlinked. We</span>
<a name="l01718"></a>01718 <span class="comment">                         * can&apos;t return to pool before that and we can&apos;t</span>
<a name="l01719"></a>01719 <span class="comment">                         * call interpret before that. We need to make</span>
<a name="l01720"></a>01720 <span class="comment">                         * sure that all rdma transfers finished and will</span>
<a name="l01721"></a>01721 <span class="comment">                         * not corrupt any data.</span>
<a name="l01722"></a>01722 <span class="comment">                         */</span>
<a name="l01723"></a>01723                         <span class="keywordflow">if</span> (ptlrpc_client_recv_or_unlink(req) ||
<a name="l01724"></a>01724                             ptlrpc_client_bulk_active(req))
<a name="l01725"></a>01725                                 <span class="keywordflow">continue</span>;
<a name="l01726"></a>01726 
<a name="l01727"></a>01727                         <span class="comment">/*</span>
<a name="l01728"></a>01728 <span class="comment">                         * Turn fail_loc off to prevent it from looping</span>
<a name="l01729"></a>01729 <span class="comment">                         * forever.</span>
<a name="l01730"></a>01730 <span class="comment">                         */</span>
<a name="l01731"></a>01731                         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK)) {
<a name="l01732"></a>01732                                 OBD_FAIL_CHECK_ORSET(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK,
<a name="l01733"></a>01733                                                      OBD_FAIL_ONCE);
<a name="l01734"></a>01734                         }
<a name="l01735"></a>01735                         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_BULK_UNLINK)) {
<a name="l01736"></a>01736                                 OBD_FAIL_CHECK_ORSET(OBD_FAIL_PTLRPC_LONG_BULK_UNLINK,
<a name="l01737"></a>01737                                                      OBD_FAIL_ONCE);
<a name="l01738"></a>01738                         }
<a name="l01739"></a>01739 
<a name="l01740"></a>01740                         <span class="comment">/*</span>
<a name="l01741"></a>01741 <span class="comment">                         * Move to next phase if reply was successfully</span>
<a name="l01742"></a>01742 <span class="comment">                         * unlinked.</span>
<a name="l01743"></a>01743 <span class="comment">                         */</span>
<a name="l01744"></a>01744                         ptlrpc_rqphase_move(req, req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a>);
<a name="l01745"></a>01745                 }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_INTERPRET)
<a name="l01748"></a>01748                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01749"></a>01749 
<a name="l01750"></a>01750                 <span class="comment">/*</span>
<a name="l01751"></a>01751 <span class="comment">                 * Note that this also will start async reply unlink.</span>
<a name="l01752"></a>01752 <span class="comment">                 */</span>
<a name="l01753"></a>01753                 <span class="keywordflow">if</span> (req-&gt;rq_net_err &amp;&amp; !req-&gt;rq_timedout) {
<a name="l01754"></a>01754                         ptlrpc_expire_one_request(req, 1);
<a name="l01755"></a>01755 
<a name="l01756"></a>01756                         <span class="comment">/*</span>
<a name="l01757"></a>01757 <span class="comment">                         * Check if we still need to wait for unlink.</span>
<a name="l01758"></a>01758 <span class="comment">                         */</span>
<a name="l01759"></a>01759                         <span class="keywordflow">if</span> (ptlrpc_client_recv_or_unlink(req) ||
<a name="l01760"></a>01760                             ptlrpc_client_bulk_active(req))
<a name="l01761"></a>01761                                 <span class="keywordflow">continue</span>;
<a name="l01762"></a>01762                         <span class="comment">/* If there is no need to resend, fail it now. */</span>
<a name="l01763"></a>01763                         <span class="keywordflow">if</span> (req-&gt;rq_no_resend) {
<a name="l01764"></a>01764                                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> == 0)
<a name="l01765"></a>01765                                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l01766"></a>01766                                 ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01767"></a>01767                                 GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01768"></a>01768                         } <span class="keywordflow">else</span> {
<a name="l01769"></a>01769                                 <span class="keywordflow">continue</span>;
<a name="l01770"></a>01770                         }
<a name="l01771"></a>01771                 }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773                 <span class="keywordflow">if</span> (req-&gt;rq_err) {
<a name="l01774"></a>01774                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01775"></a>01775                         req-&gt;rq_replied = 0;
<a name="l01776"></a>01776                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01777"></a>01777                         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> == 0)
<a name="l01778"></a>01778                                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l01779"></a>01779                         ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01780"></a>01780                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01781"></a>01781                 }
<a name="l01782"></a>01782 
<a name="l01783"></a>01783                 <span class="comment">/* ptlrpc_set_wait-&gt;l_wait_event sets lwi_allow_intr</span>
<a name="l01784"></a>01784 <span class="comment">                 * so it sets rq_intr regardless of individual rpc</span>
<a name="l01785"></a>01785 <span class="comment">                 * timeouts. The synchronous IO waiting path sets</span>
<a name="l01786"></a>01786 <span class="comment">                 * rq_intr irrespective of whether ptlrpcd</span>
<a name="l01787"></a>01787 <span class="comment">                 * has seen a timeout.  Our policy is to only interpret</span>
<a name="l01788"></a>01788 <span class="comment">                 * interrupted rpcs after they have timed out, so we</span>
<a name="l01789"></a>01789 <span class="comment">                 * need to enforce that here.</span>
<a name="l01790"></a>01790 <span class="comment">                 */</span>
<a name="l01791"></a>01791 
<a name="l01792"></a>01792                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a6d4f6fc90fdcc8e2492f4ab902147970" title="client-side flags are serialized by rq_lock">rq_intr</a> &amp;&amp; (req-&gt;rq_timedout || req-&gt;rq_waiting ||
<a name="l01793"></a>01793                                      req-&gt;rq_wait_ctx)) {
<a name="l01794"></a>01794                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EINTR;
<a name="l01795"></a>01795                         ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01796"></a>01796                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01797"></a>01797                 }
<a name="l01798"></a>01798 
<a name="l01799"></a>01799                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_RPC) {
<a name="l01800"></a>01800                         <span class="keywordflow">if</span> (req-&gt;rq_timedout || req-&gt;rq_resend ||
<a name="l01801"></a>01801                             req-&gt;rq_waiting || req-&gt;rq_wait_ctx) {
<a name="l01802"></a>01802                                 <span class="keywordtype">int</span> status;
<a name="l01803"></a>01803 
<a name="l01804"></a>01804                                 <span class="keywordflow">if</span> (!ptlrpc_unregister_reply(req, 1)) {
<a name="l01805"></a>01805                                         <a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(req, 1);
<a name="l01806"></a>01806                                         <span class="keywordflow">continue</span>;
<a name="l01807"></a>01807                                 }
<a name="l01808"></a>01808 
<a name="l01809"></a>01809                                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01810"></a>01810                                 <span class="keywordflow">if</span> (ptlrpc_import_delay_req(imp, req, &amp;status)){
<a name="l01811"></a>01811                                         <span class="comment">/* put on delay list - only if we wait</span>
<a name="l01812"></a>01812 <span class="comment">                                         * recovery finished - before send */</span>
<a name="l01813"></a>01813                                         list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l01814"></a>01814                                         list_add_tail(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>,
<a name="l01815"></a>01815                                                           &amp;imp-&gt;
<a name="l01816"></a>01816                                                           imp_delayed_list);
<a name="l01817"></a>01817                                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01818"></a>01818                                         <span class="keywordflow">continue</span>;
<a name="l01819"></a>01819                                 }
<a name="l01820"></a>01820 
<a name="l01821"></a>01821                                 <span class="keywordflow">if</span> (status != 0)  {
<a name="l01822"></a>01822                                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = status;
<a name="l01823"></a>01823                                         ptlrpc_rqphase_move(req,
<a name="l01824"></a>01824                                                 RQ_PHASE_INTERPRET);
<a name="l01825"></a>01825                                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01826"></a>01826                                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01827"></a>01827                                 }
<a name="l01828"></a>01828                                 <span class="keywordflow">if</span> (ptlrpc_no_resend(req) &amp;&amp;
<a name="l01829"></a>01829                                     !req-&gt;rq_wait_ctx) {
<a name="l01830"></a>01830                                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -ENOTCONN;
<a name="l01831"></a>01831                                         ptlrpc_rqphase_move(req,
<a name="l01832"></a>01832                                                             RQ_PHASE_INTERPRET);
<a name="l01833"></a>01833                                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01834"></a>01834                                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01835"></a>01835                                 }
<a name="l01836"></a>01836 
<a name="l01837"></a>01837                                 list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l01838"></a>01838                                 list_add_tail(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>,
<a name="l01839"></a>01839                                                   &amp;imp-&gt;imp_sending_list);
<a name="l01840"></a>01840 
<a name="l01841"></a>01841                                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01842"></a>01842 
<a name="l01843"></a>01843                                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01844"></a>01844                                 req-&gt;rq_waiting = 0;
<a name="l01845"></a>01845                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01846"></a>01846 
<a name="l01847"></a>01847                                 <span class="keywordflow">if</span> (req-&gt;rq_timedout || req-&gt;rq_resend) {
<a name="l01848"></a>01848                                         <span class="comment">/* This is re-sending anyways,</span>
<a name="l01849"></a>01849 <span class="comment">                                         * let&apos;s mark req as resend. */</span>
<a name="l01850"></a>01850                                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01851"></a>01851                                         req-&gt;rq_resend = 1;
<a name="l01852"></a>01852                                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01853"></a>01853 
<a name="l01854"></a>01854                                         <span class="keywordflow">if</span> (req-&gt;rq_bulk != NULL &amp;&amp;
<a name="l01855"></a>01855                                             !<a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(req, 1))
<a name="l01856"></a>01856                                                 <span class="keywordflow">continue</span>;
<a name="l01857"></a>01857                                 }
<a name="l01858"></a>01858                                 <span class="comment">/*</span>
<a name="l01859"></a>01859 <span class="comment">                                 * rq_wait_ctx is only touched by ptlrpcd,</span>
<a name="l01860"></a>01860 <span class="comment">                                 * so no lock is needed here.</span>
<a name="l01861"></a>01861 <span class="comment">                                 */</span>
<a name="l01862"></a>01862                                 status = <a class="code" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&amp;#39;s not up-to-date.">sptlrpc_req_refresh_ctx</a>(req, -1);
<a name="l01863"></a>01863                                 <span class="keywordflow">if</span> (status) {
<a name="l01864"></a>01864                                         <span class="keywordflow">if</span> (req-&gt;rq_err) {
<a name="l01865"></a>01865                                                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = status;
<a name="l01866"></a>01866                                                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01867"></a>01867                                                 req-&gt;rq_wait_ctx = 0;
<a name="l01868"></a>01868                                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01869"></a>01869                                                 force_timer_recalc = 1;
<a name="l01870"></a>01870                                         } <span class="keywordflow">else</span> {
<a name="l01871"></a>01871                                                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01872"></a>01872                                                 req-&gt;rq_wait_ctx = 1;
<a name="l01873"></a>01873                                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01874"></a>01874                                         }
<a name="l01875"></a>01875 
<a name="l01876"></a>01876                                         <span class="keywordflow">continue</span>;
<a name="l01877"></a>01877                                 } <span class="keywordflow">else</span> {
<a name="l01878"></a>01878                                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01879"></a>01879                                         req-&gt;rq_wait_ctx = 0;
<a name="l01880"></a>01880                                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01881"></a>01881                                 }
<a name="l01882"></a>01882 
<a name="l01883"></a>01883                                 rc = <a class="code" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request.">ptl_send_rpc</a>(req, 0);
<a name="l01884"></a>01884                                 <span class="keywordflow">if</span> (rc == -ENOMEM) {
<a name="l01885"></a>01885                                         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01886"></a>01886                                         <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>))
<a name="l01887"></a>01887                                                 list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l01888"></a>01888                                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01889"></a>01889                                         ptlrpc_rqphase_move(req, RQ_PHASE_NEW);
<a name="l01890"></a>01890                                         <span class="keywordflow">continue</span>;
<a name="l01891"></a>01891                                 }
<a name="l01892"></a>01892                                 <span class="keywordflow">if</span> (rc) {
<a name="l01893"></a>01893                                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req,
<a name="l01894"></a>01894                                                   <span class="stringliteral">&quot;send failed: rc = %d&quot;</span>, rc);
<a name="l01895"></a>01895                                         force_timer_recalc = 1;
<a name="l01896"></a>01896                                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01897"></a>01897                                         req-&gt;rq_net_err = 1;
<a name="l01898"></a>01898                                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01899"></a>01899                                         <span class="keywordflow">continue</span>;
<a name="l01900"></a>01900                                 }
<a name="l01901"></a>01901                                 <span class="comment">/* need to reset the timeout */</span>
<a name="l01902"></a>01902                                 force_timer_recalc = 1;
<a name="l01903"></a>01903                         }
<a name="l01904"></a>01904 
<a name="l01905"></a>01905                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01906"></a>01906 
<a name="l01907"></a>01907                         <span class="keywordflow">if</span> (ptlrpc_client_early(req)) {
<a name="l01908"></a>01908                                 ptlrpc_at_recv_early_reply(req);
<a name="l01909"></a>01909                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01910"></a>01910                                 <span class="keywordflow">continue</span>;
<a name="l01911"></a>01911                         }
<a name="l01912"></a>01912 
<a name="l01913"></a>01913                         <span class="comment">/* Still waiting for a reply? */</span>
<a name="l01914"></a>01914                         <span class="keywordflow">if</span> (ptlrpc_client_recv(req)) {
<a name="l01915"></a>01915                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01916"></a>01916                                 <span class="keywordflow">continue</span>;
<a name="l01917"></a>01917                         }
<a name="l01918"></a>01918 
<a name="l01919"></a>01919                         <span class="comment">/* Did we actually receive a reply? */</span>
<a name="l01920"></a>01920                         <span class="keywordflow">if</span> (!ptlrpc_client_replied(req)) {
<a name="l01921"></a>01921                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01922"></a>01922                                 <span class="keywordflow">continue</span>;
<a name="l01923"></a>01923                         }
<a name="l01924"></a>01924 
<a name="l01925"></a>01925                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01926"></a>01926 
<a name="l01927"></a>01927                         <span class="comment">/* unlink from net because we are going to</span>
<a name="l01928"></a>01928 <span class="comment">                         * swab in-place of reply buffer */</span>
<a name="l01929"></a>01929                         unregistered = ptlrpc_unregister_reply(req, 1);
<a name="l01930"></a>01930                         <span class="keywordflow">if</span> (!unregistered)
<a name="l01931"></a>01931                                 <span class="keywordflow">continue</span>;
<a name="l01932"></a>01932 
<a name="l01933"></a>01933                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = after_reply(req);
<a name="l01934"></a>01934                         <span class="keywordflow">if</span> (req-&gt;rq_resend)
<a name="l01935"></a>01935                                 <span class="keywordflow">continue</span>;
<a name="l01936"></a>01936 
<a name="l01937"></a>01937                         <span class="comment">/* If there is no bulk associated with this request,</span>
<a name="l01938"></a>01938 <span class="comment">                         * then we&apos;re done and should let the interpreter</span>
<a name="l01939"></a>01939 <span class="comment">                         * process the reply. Similarly if the RPC returned</span>
<a name="l01940"></a>01940 <span class="comment">                         * an error, and therefore the bulk will never arrive.</span>
<a name="l01941"></a>01941 <span class="comment">                         */</span>
<a name="l01942"></a>01942                         <span class="keywordflow">if</span> (req-&gt;rq_bulk == NULL || req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> &lt; 0) {
<a name="l01943"></a>01943                                 ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01944"></a>01944                                 GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01945"></a>01945                         }
<a name="l01946"></a>01946 
<a name="l01947"></a>01947                         ptlrpc_rqphase_move(req, RQ_PHASE_BULK);
<a name="l01948"></a>01948                 }
<a name="l01949"></a>01949 
<a name="l01950"></a>01950                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_BULK);
<a name="l01951"></a>01951                 <span class="keywordflow">if</span> (ptlrpc_client_bulk_active(req))
<a name="l01952"></a>01952                         <span class="keywordflow">continue</span>;
<a name="l01953"></a>01953 
<a name="l01954"></a>01954                 <span class="keywordflow">if</span> (req-&gt;rq_bulk-&gt;bd_failure) {
<a name="l01955"></a>01955                         <span class="comment">/* The RPC reply arrived OK, but the bulk screwed</span>
<a name="l01956"></a>01956 <span class="comment">                         * up!  Dead weird since the server told us the RPC</span>
<a name="l01957"></a>01957 <span class="comment">                         * was good after getting the REPLY for her GET or</span>
<a name="l01958"></a>01958 <span class="comment">                         * the ACK for her PUT. */</span>
<a name="l01959"></a>01959                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;bulk transfer failed&quot;</span>);
<a name="l01960"></a>01960                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l01961"></a>01961                 }
<a name="l01962"></a>01962 
<a name="l01963"></a>01963                 ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01964"></a>01964 
<a name="l01965"></a>01965         interpret:
<a name="l01966"></a>01966                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_INTERPRET);
<a name="l01967"></a>01967 
<a name="l01968"></a>01968                 <span class="comment">/* This moves to &quot;unregistering&quot; phase we need to wait for</span>
<a name="l01969"></a>01969 <span class="comment">                 * reply unlink. */</span>
<a name="l01970"></a>01970                 <span class="keywordflow">if</span> (!unregistered &amp;&amp; !ptlrpc_unregister_reply(req, async)) {
<a name="l01971"></a>01971                         <span class="comment">/* start async bulk unlink too */</span>
<a name="l01972"></a>01972                         <a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(req, 1);
<a name="l01973"></a>01973                         <span class="keywordflow">continue</span>;
<a name="l01974"></a>01974                 }
<a name="l01975"></a>01975 
<a name="l01976"></a>01976                 <span class="keywordflow">if</span> (!<a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(req, async))
<a name="l01977"></a>01977                         <span class="keywordflow">continue</span>;
<a name="l01978"></a>01978 
<a name="l01979"></a>01979                 <span class="comment">/* When calling interpret receiving already should be</span>
<a name="l01980"></a>01980 <span class="comment">                 * finished. */</span>
<a name="l01981"></a>01981                 LASSERT(!req-&gt;rq_receiving_reply);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983                 ptlrpc_req_interpret(env, req, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01984"></a>01984 
<a name="l01985"></a>01985                 <span class="keywordflow">if</span> (ptlrpcd_check_work(req)) {
<a name="l01986"></a>01986                         atomic_dec(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>);
<a name="l01987"></a>01987                         <span class="keywordflow">continue</span>;
<a name="l01988"></a>01988                 }
<a name="l01989"></a>01989                 ptlrpc_rqphase_move(req, RQ_PHASE_COMPLETE);
<a name="l01990"></a>01990 
<a name="l01991"></a>01991                 CDEBUG(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> != NULL ? D_RPCTRACE : 0,
<a name="l01992"></a>01992                         <span class="stringliteral">&quot;Completed RPC pname:cluuid:pid:xid:nid:&quot;</span>
<a name="l01993"></a>01993                         <span class="stringliteral">&quot;opc %s:%s:%d:&quot;</span>LPU64<span class="stringliteral">&quot;:%s:%d\n&quot;</span>,
<a name="l01994"></a>01994                         current_comm(), imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_uuid.uuid,
<a name="l01995"></a>01995                         lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>), req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>,
<a name="l01996"></a>01996                         libcfs_nid2str(imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>),
<a name="l01997"></a>01997                         lustre_msg_get_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l01998"></a>01998 
<a name="l01999"></a>01999                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02000"></a>02000                 <span class="comment">/* Request already may be not on sending or delaying list. This</span>
<a name="l02001"></a>02001 <span class="comment">                 * may happen in the case of marking it erroneous for the case</span>
<a name="l02002"></a>02002 <span class="comment">                 * ptlrpc_import_delay_req(req, status) find it impossible to</span>
<a name="l02003"></a>02003 <span class="comment">                 * allow sending this rpc and returns *status != 0. */</span>
<a name="l02004"></a>02004                 <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>)) {
<a name="l02005"></a>02005                         list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l02006"></a>02006                         atomic_dec(&amp;imp-&gt;<a class="code" href="structobd__import.html#aece380c78562b6b0ddbfb1b5460fcbb2" title="Number of requests currently in-flight.">imp_inflight</a>);
<a name="l02007"></a>02007                 }
<a name="l02008"></a>02008                 list_del_init(&amp;req-&gt;rq_unreplied_list);
<a name="l02009"></a>02009                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02010"></a>02010 
<a name="l02011"></a>02011                 atomic_dec(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>);
<a name="l02012"></a>02012                 wake_up_all(&amp;imp-&gt;<a class="code" href="structobd__import.html#a43b896a006360181311cd5c246bd7c8b" title="Wait queue for those who need to wait for recovery completion.">imp_recovery_waitq</a>);
<a name="l02013"></a>02013 
<a name="l02014"></a>02014                 <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structptlrpc__request__set.html#a9be81c226e91f43d9a2b64328b0831a0" title="Callback function used to generate RPCs.">set_producer</a>) {
<a name="l02015"></a>02015                         <span class="comment">/* produce a new request if possible */</span>
<a name="l02016"></a>02016                         <span class="keywordflow">if</span> (ptlrpc_set_producer(<span class="keyword">set</span>) &gt; 0)
<a name="l02017"></a>02017                                 force_timer_recalc = 1;
<a name="l02018"></a>02018 
<a name="l02019"></a>02019                         <span class="comment">/* free the request that has just been completed</span>
<a name="l02020"></a>02020 <span class="comment">                         * in order not to pollute set-&gt;set_requests */</span>
<a name="l02021"></a>02021                         list_del_init(&amp;req-&gt;rq_set_chain);
<a name="l02022"></a>02022                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02023"></a>02023                         req-&gt;rq_set = NULL;
<a name="l02024"></a>02024                         req-&gt;<a class="code" href="structptlrpc__request.html#a3c7a9c4f0292826fffa36e3ab1cedf47" title="whether the &amp;quot;rq_set&amp;quot; is a valid one">rq_invalid_rqset</a> = 0;
<a name="l02025"></a>02025                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02026"></a>02026 
<a name="l02027"></a>02027                         <span class="comment">/* record rq_status to compute the final status later */</span>
<a name="l02028"></a>02028                         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != 0)
<a name="l02029"></a>02029                                 <span class="keyword">set</span>-&gt;set_rc = req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>;
<a name="l02030"></a>02030                         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l02031"></a>02031                 } <span class="keywordflow">else</span> {
<a name="l02032"></a>02032                         list_move_tail(&amp;req-&gt;rq_set_chain, &amp;comp_reqs);
<a name="l02033"></a>02033                 }
<a name="l02034"></a>02034         }
<a name="l02035"></a>02035 
<a name="l02036"></a>02036         <span class="comment">/* move completed request at the head of list so it&apos;s easier for</span>
<a name="l02037"></a>02037 <span class="comment">         * caller to find them */</span>
<a name="l02038"></a>02038         list_splice(&amp;comp_reqs, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>);
<a name="l02039"></a>02039 
<a name="l02040"></a>02040         <span class="comment">/* If we hit an error, we want to recover promptly. */</span>
<a name="l02041"></a>02041         RETURN(atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>) == 0 || force_timer_recalc);
<a name="l02042"></a>02042 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga63613680c8953223c8efc4331656b11a_cgraph.png" border="0" usemap="#group__net_ga63613680c8953223c8efc4331656b11a_cgraph_map" alt=""></div>
<map name="group__net_ga63613680c8953223c8efc4331656b11a_cgraph_map" id="group__net_ga63613680c8953223c8efc4331656b11a_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="231,240,337,269"/><area shape="rect" id="node16" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request." alt="" coords="463,371,609,400"/><area shape="rect" id="node20" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network." alt="" coords="451,424,621,453"/><area shape="rect" id="node30" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="193,476,375,505"/><area shape="rect" id="node5" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME." alt="" coords="715,124,840,153"/><area shape="rect" id="node7" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal." alt="" coords="716,200,839,229"/><area shape="rect" id="node9" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list." alt="" coords="720,260,835,289"/><area shape="rect" id="node11" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Actual interfacing with LNet to put/get/register/unregister stuff." alt="" coords="459,213,613,243"/><area shape="rect" id="node18" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req." alt="" coords="451,317,621,347"/><area shape="rect" id="node22" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req." alt="" coords="448,5,624,35"/><area shape="rect" id="node24" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre&#45;defined security transformation upon the..." alt="" coords="443,59,629,88"/><area shape="rect" id="node26" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc." alt="" coords="697,59,857,88"/><area shape="rect" id="node32" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="424,477,648,507"/><area shape="rect" id="node34" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="699,451,856,480"/><area shape="rect" id="node36" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="699,504,856,533"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga63613680c8953223c8efc4331656b11a_icgraph.png" border="0" usemap="#group__net_ga63613680c8953223c8efc4331656b11a_icgraph_map" alt=""></div>
<map name="group__net_ga63613680c8953223c8efc4331656b11a_icgraph_map" id="group__net_ga63613680c8953223c8efc4331656b11a_icgraph">
<area shape="rect" id="node3" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="567,56,711,85"/><area shape="rect" id="node5" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="193,109,319,139"/><area shape="rect" id="node7" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="368,109,515,139"/><area shape="rect" id="node10" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="564,109,713,139"/><area shape="rect" id="node32" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="571,163,707,192"/><area shape="rect" id="node12" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="764,109,911,139"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="993,29,1113,59"/><area shape="rect" id="node21" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="961,83,1145,112"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1445,108,1688,137"/><area shape="rect" id="node30" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="983,187,1124,216"/><area shape="rect" id="node16" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1196,29,1396,59"/><area shape="rect" id="node18" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1497,29,1636,59"/><area shape="rect" id="node23" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1195,83,1397,112"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1736,108,1912,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gae524031a54066bf23dda2ad572bbcfdf"></a><!-- doxytag: member="lustre_net.h::ptlrpc_connect_import" ref="gae524031a54066bf23dda2ad572bbcfdf" args="(struct obd_import *imp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_connect_import </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Import API. </p>
<p>Import API.</p>
<p>This includes all preparations, initializing CONNECT RPC request and passing it to ptlrpcd for actual sending. Returns 0 on success or error code. </p>

<p>Definition at line <a class="el" href="import_8c_source.html#l00648">648</a> of file <a class="el" href="import_8c_source.html">import.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="lustre__import_8h_source.html#l00239">obd_import::imp_conn_cnt</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__import_8h_source.html#l00248">obd_import::imp_peer_committed_transno</a>, <a class="el" href="lustre__import_8h_source.html#l00260">obd_import::imp_remote_handle</a>, <a class="el" href="lustre__import_8h_source.html#l00230">obd_import::imp_state</a>, <a class="el" href="client_8c_source.html#l00852">ptlrpc_request_alloc()</a>, <a class="el" href="client_8c_source.html#l00875">ptlrpc_request_free()</a>, <a class="el" href="ptlrpcd_8c_source.html#l00268">ptlrpcd_add_req()</a>, <a class="el" href="layout_8c_source.html#l02226">req_capsule_set_size()</a>, <a class="el" href="lustre__net_8h_source.html#l01121">ptlrpc_request::rq_pill</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01113">ptlrpc_request::rq_timeout</a>, and <a class="el" href="sec_8c_source.html#l01438">sptlrpc_import_sec_adapt()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00649"></a>00649 {
<a name="l00650"></a>00650         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd = imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>;
<a name="l00651"></a>00651         <span class="keywordtype">int</span> initial_connect = 0;
<a name="l00652"></a>00652         <span class="keywordtype">int</span> set_transno = 0;
<a name="l00653"></a>00653         __u64 committed_before_reconnect = 0;
<a name="l00654"></a>00654         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request;
<a name="l00655"></a>00655         <span class="keywordtype">char</span> *bufs[] = { NULL,
<a name="l00656"></a>00656                          obd2cli_tgt(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>),
<a name="l00657"></a>00657                          obd-&gt;obd_uuid.uuid,
<a name="l00658"></a>00658                          (<span class="keywordtype">char</span> *)&amp;imp-&gt;imp_dlm_handle,
<a name="l00659"></a>00659                          (<span class="keywordtype">char</span> *)&amp;imp-&gt;imp_connect_data };
<a name="l00660"></a>00660         <span class="keyword">struct </span>ptlrpc_connect_async_args *aa;
<a name="l00661"></a>00661         <span class="keywordtype">int</span> rc;
<a name="l00662"></a>00662         ENTRY;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00665"></a>00665         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_CLOSED) {
<a name="l00666"></a>00666                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00667"></a>00667                 CERROR(<span class="stringliteral">&quot;can&apos;t connect to a closed import\n&quot;</span>);
<a name="l00668"></a>00668                 RETURN(-EINVAL);
<a name="l00669"></a>00669         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_FULL) {
<a name="l00670"></a>00670                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00671"></a>00671                 CERROR(<span class="stringliteral">&quot;already connected\n&quot;</span>);
<a name="l00672"></a>00672                 RETURN(0);
<a name="l00673"></a>00673         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_CONNECTING ||
<a name="l00674"></a>00674                    imp-&gt;imp_connected) {
<a name="l00675"></a>00675                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00676"></a>00676                 CERROR(<span class="stringliteral">&quot;already connecting\n&quot;</span>);
<a name="l00677"></a>00677                 RETURN(-EALREADY);
<a name="l00678"></a>00678         }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680         IMPORT_SET_STATE_NOLOCK(imp, LUSTRE_IMP_CONNECTING);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682         imp-&gt;<a class="code" href="structobd__import.html#ac3b8409237b9f6fc17e80bdfed39a1d5" title="Incremented every time we send reconnection request.">imp_conn_cnt</a>++;
<a name="l00683"></a>00683         imp-&gt;imp_resend_replay = 0;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="keywordflow">if</span> (!lustre_handle_is_used(&amp;imp-&gt;<a class="code" href="structobd__import.html#a0b8bb1da93c9c21f85044d87a7104a4e" title="Remote export handle.">imp_remote_handle</a>))
<a name="l00686"></a>00686                 initial_connect = 1;
<a name="l00687"></a>00687         <span class="keywordflow">else</span>
<a name="l00688"></a>00688                 committed_before_reconnect = imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>;
<a name="l00689"></a>00689 
<a name="l00690"></a>00690         set_transno = ptlrpc_first_transno(imp,
<a name="l00691"></a>00691                                            &amp;imp-&gt;imp_connect_data.ocd_transno);
<a name="l00692"></a>00692         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00693"></a>00693 
<a name="l00694"></a>00694         rc = import_select_connection(imp);
<a name="l00695"></a>00695         <span class="keywordflow">if</span> (rc)
<a name="l00696"></a>00696                 GOTO(out, rc);
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         rc = <a class="code" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration...">sptlrpc_import_sec_adapt</a>(imp, NULL, NULL);
<a name="l00699"></a>00699         <span class="keywordflow">if</span> (rc)
<a name="l00700"></a>00700                 GOTO(out, rc);
<a name="l00701"></a>00701 
<a name="l00702"></a>00702         <span class="comment">/* Reset connect flags to the originally requested flags, in case</span>
<a name="l00703"></a>00703 <span class="comment">         * the server is updated on-the-fly we will get the new features. */</span>
<a name="l00704"></a>00704         imp-&gt;imp_connect_data.ocd_connect_flags = imp-&gt;imp_connect_flags_orig;
<a name="l00705"></a>00705         <span class="comment">/* Reset ocd_version each time so the server knows the exact versions */</span>
<a name="l00706"></a>00706         imp-&gt;imp_connect_data.ocd_version = LUSTRE_VERSION_CODE;
<a name="l00707"></a>00707         imp-&gt;imp_msghdr_flags &amp;= ~MSGHDR_AT_SUPPORT;
<a name="l00708"></a>00708         imp-&gt;imp_msghdr_flags &amp;= ~MSGHDR_CKSUM_INCOMPAT18;
<a name="l00709"></a>00709 
<a name="l00710"></a>00710         rc = obd_reconnect(NULL, imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_self_export, obd,
<a name="l00711"></a>00711                            &amp;obd-&gt;obd_uuid, &amp;imp-&gt;imp_connect_data, NULL);
<a name="l00712"></a>00712         <span class="keywordflow">if</span> (rc)
<a name="l00713"></a>00713                 GOTO(out, rc);
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         request = <a class="code" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure...">ptlrpc_request_alloc</a>(imp, &amp;RQF_MDS_CONNECT);
<a name="l00716"></a>00716         <span class="keywordflow">if</span> (request == NULL)
<a name="l00717"></a>00717                 GOTO(out, rc = -ENOMEM);
<a name="l00718"></a>00718 
<a name="l00719"></a>00719         rc = ptlrpc_request_bufs_pack(request, LUSTRE_OBD_VERSION,
<a name="l00720"></a>00720                                       imp-&gt;imp_connect_op, bufs, NULL);
<a name="l00721"></a>00721         <span class="keywordflow">if</span> (rc) {
<a name="l00722"></a>00722                 <a class="code" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure.">ptlrpc_request_free</a>(request);
<a name="l00723"></a>00723                 GOTO(out, rc);
<a name="l00724"></a>00724         }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         <span class="comment">/* Report the rpc service time to the server so that it knows how long</span>
<a name="l00727"></a>00727 <span class="comment">         * to wait for clients to join recovery */</span>
<a name="l00728"></a>00728         lustre_msg_set_service_time(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>,
<a name="l00729"></a>00729                                     at_timeout2est(request-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>));
<a name="l00730"></a>00730 
<a name="l00731"></a>00731         <span class="comment">/* The amount of time we give the server to process the connect req.</span>
<a name="l00732"></a>00732 <span class="comment">         * import_select_connection will increase the net latency on</span>
<a name="l00733"></a>00733 <span class="comment">         * repeated reconnect attempts to cover slow networks.</span>
<a name="l00734"></a>00734 <span class="comment">         * We override/ignore the server rpc completion estimate here,</span>
<a name="l00735"></a>00735 <span class="comment">         * which may be large if this is a reconnect attempt */</span>
<a name="l00736"></a>00736         request-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a> = INITIAL_CONNECT_TIMEOUT;
<a name="l00737"></a>00737         lustre_msg_set_timeout(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, request-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>);
<a name="l00738"></a>00738 
<a name="l00739"></a>00739         request-&gt;rq_no_resend = request-&gt;rq_no_delay = 1;
<a name="l00740"></a>00740         request-&gt;rq_send_state = LUSTRE_IMP_CONNECTING;
<a name="l00741"></a>00741         <span class="comment">/* Allow a slightly larger reply for future growth compatibility */</span>
<a name="l00742"></a>00742         <a class="code" href="group__req__layout.html#ga6d0a3a11367bcd9fe40dc723243e7b0d" title="Set the size of the PTLRPC request/reply (loc) buffer for the given field of the...">req_capsule_set_size</a>(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_CONNECT_DATA, RCL_SERVER,
<a name="l00743"></a>00743                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structobd__connect__data.html">obd_connect_data</a>)+16*<span class="keyword">sizeof</span>(__u64));
<a name="l00744"></a>00744         ptlrpc_request_set_replen(request);
<a name="l00745"></a>00745         request-&gt;rq_interpret_reply = ptlrpc_connect_interpret;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         CLASSERT(<span class="keyword">sizeof</span> (*aa) &lt;= <span class="keyword">sizeof</span> (request-&gt;rq_async_args));
<a name="l00748"></a>00748         aa = ptlrpc_req_async_args(request);
<a name="l00749"></a>00749         memset(aa, 0, <span class="keyword">sizeof</span> *aa);
<a name="l00750"></a>00750 
<a name="l00751"></a>00751         aa-&gt;pcaa_peer_committed = committed_before_reconnect;
<a name="l00752"></a>00752         aa-&gt;pcaa_initial_connect = initial_connect;
<a name="l00753"></a>00753 
<a name="l00754"></a>00754         <span class="keywordflow">if</span> (aa-&gt;pcaa_initial_connect) {
<a name="l00755"></a>00755                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00756"></a>00756                 imp-&gt;imp_replayable = 1;
<a name="l00757"></a>00757                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00758"></a>00758                 lustre_msg_add_op_flags(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>,
<a name="l00759"></a>00759                                         MSG_CONNECT_INITIAL);
<a name="l00760"></a>00760         }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762         <span class="keywordflow">if</span> (set_transno)
<a name="l00763"></a>00763                 lustre_msg_add_op_flags(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>,
<a name="l00764"></a>00764                                         MSG_CONNECT_TRANSNO);
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, request, <span class="stringliteral">&quot;(re)connect request (timeout %d)&quot;</span>,
<a name="l00767"></a>00767                   request-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>);
<a name="l00768"></a>00768         <a class="code" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check-&amp;gt;ptlrpc_check_set()...">ptlrpcd_add_req</a>(request);
<a name="l00769"></a>00769         rc = 0;
<a name="l00770"></a>00770 out:
<a name="l00771"></a>00771         <span class="keywordflow">if</span> (rc != 0)
<a name="l00772"></a>00772                 IMPORT_SET_STATE(imp, LUSTRE_IMP_DISCON);
<a name="l00773"></a>00773 
<a name="l00774"></a>00774         RETURN(rc);
<a name="l00775"></a>00775 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gae524031a54066bf23dda2ad572bbcfdf_cgraph.png" border="0" usemap="#group__net_gae524031a54066bf23dda2ad572bbcfdf_cgraph_map" alt=""></div>
<map name="group__net_gae524031a54066bf23dda2ad572bbcfdf_cgraph_map" id="group__net_gae524031a54066bf23dda2ad572bbcfdf_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure..." alt="" coords="249,5,407,35"/><area shape="rect" id="node5" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure." alt="" coords="251,59,405,88"/><area shape="rect" id="node7" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check&#45;&gt;ptlrpc_check_set()..." alt="" coords="264,112,392,141"/><area shape="rect" id="node9" href="group__req__layout.html#ga6d0a3a11367bcd9fe40dc723243e7b0d" title="Set the size of the PTLRPC request/reply (loc) buffer for the given field of the..." alt="" coords="245,165,411,195"/><area shape="rect" id="node11" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration..." alt="" coords="231,219,425,248"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga43e79605481156aa499fd539a3e1265c"></a><!-- doxytag: member="lustre_net.h::ptlrpc_del_timeout_client" ref="ga43e79605481156aa499fd539a3e1265c" args="(struct list_head *obd_list, enum timeout_event event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_del_timeout_client </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>obd_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__net.html#ga83197c087490e096e36a4397091d0c3f">timeout_event</a>&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>If there are no obd attached to the timeout event list, remove this timeout event from the pinger</p>
</p>

<p>Definition at line <a class="el" href="pinger_8c_source.html#l00522">522</a> of file <a class="el" href="pinger_8c_source.html">pinger.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00524"></a>00524 {
<a name="l00525"></a>00525         <span class="keyword">struct </span><a class="code" href="structtimeout__item.html">timeout_item</a> *ti = NULL, *item;
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         <span class="keywordflow">if</span> (list_empty(obd_list))
<a name="l00528"></a>00528                 <span class="keywordflow">return</span> 0;
<a name="l00529"></a>00529         mutex_lock(&amp;pinger_mutex);
<a name="l00530"></a>00530         list_del_init(obd_list);
<a name="l00535"></a>00535         list_for_each_entry(item, &amp;timeout_list, ti_chain) {
<a name="l00536"></a>00536                 <span class="keywordflow">if</span> (item-&gt;ti_event == event) {
<a name="l00537"></a>00537                         ti = item;
<a name="l00538"></a>00538                         <span class="keywordflow">break</span>;
<a name="l00539"></a>00539                 }
<a name="l00540"></a>00540         }
<a name="l00541"></a>00541         LASSERTF(ti != NULL, <span class="stringliteral">&quot;ti is NULL !\n&quot;</span>);
<a name="l00542"></a>00542         <span class="keywordflow">if</span> (list_empty(&amp;ti-&gt;ti_obd_list)) {
<a name="l00543"></a>00543                 list_del(&amp;ti-&gt;ti_chain);
<a name="l00544"></a>00544                 OBD_FREE_PTR(ti);
<a name="l00545"></a>00545         }
<a name="l00546"></a>00546         mutex_unlock(&amp;pinger_mutex);
<a name="l00547"></a>00547         <span class="keywordflow">return</span> 0;
<a name="l00548"></a>00548 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga1b3e3fff15de45e0042c071e5bb806f4"></a><!-- doxytag: member="lustre_net.h::ptlrpc_free_rq_pool" ref="ga1b3e3fff15de45e0042c071e5bb806f4" args="(struct ptlrpc_request_pool *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_free_rq_pool </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__pool.html">ptlrpc_request_pool</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wind down request pool <em>pool</em>. </p>
<p>Frees all requests from the pool too </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00509">509</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l00742">ptlrpc_request_pool::prp_lock</a>, <a class="el" href="lustre__net_8h_source.html#l00744">ptlrpc_request_pool::prp_req_list</a>, <a class="el" href="lustre__net_8h_source.html#l00746">ptlrpc_request_pool::prp_rq_size</a>, <a class="el" href="lustre__net_8h_source.html#l00962">ptlrpc_request::rq_list</a>, and <a class="el" href="lustre__net_8h_source.html#l01079">ptlrpc_request::rq_reqbuf</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00510"></a>00510 {
<a name="l00511"></a>00511         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *l, *tmp;
<a name="l00512"></a>00512         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         LASSERT(pool != NULL);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516         spin_lock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00517"></a>00517         list_for_each_safe(l, tmp, &amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66" title="list of ptlrpc_request structs">prp_req_list</a>) {
<a name="l00518"></a>00518                 req = list_entry(l, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, <a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l00519"></a>00519                 list_del(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l00520"></a>00520                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>);
<a name="l00521"></a>00521                 LASSERT(req-&gt;rq_reqbuf_len == pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a>);
<a name="l00522"></a>00522                 OBD_FREE_LARGE(req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>, pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a>);
<a name="l00523"></a>00523                 ptlrpc_request_cache_free(req);
<a name="l00524"></a>00524         }
<a name="l00525"></a>00525         spin_unlock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00526"></a>00526         OBD_FREE(pool, <span class="keyword">sizeof</span>(*pool));
<a name="l00527"></a>00527 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae24ff0ea3f19794b41cb4da94ffa9ce2"></a><!-- doxytag: member="lustre_net.h::ptlrpc_import_recovery_state_machine" ref="gae24ff0ea3f19794b41cb4da94ffa9ce2" args="(struct obd_import *imp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_import_recovery_state_machine </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the state machine for client-side recovery on import. </p>
<p>Typicaly we have two possibly paths. If we came to server and it is not in recovery, we just enter IMP_EVICTED state, invalidate our import state and reconnect from scratch. If we came to server that is in recovery, we enter IMP_REPLAY import state. We go through our list of requests to replay and send them to server one by one. After sending all request from the list we change import state to IMP_REPLAY_LOCKS and re-request all the locks we believe we have from server and also all the locks we don't yet have and wait for server to grant us. After that we send a special "replay completed" request and change import state to IMP_REPLAY_WAIT. Upon receiving reply to that "replay completed" RPC we enter IMP_RECOVER state and resend all requests from sending list. After that we promote import to FULL state and send all delayed requests and import is fully operational after that. </p>

<p>Definition at line <a class="el" href="import_8c_source.html#l01449">1449</a> of file <a class="el" href="import_8c_source.html">import.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l00521">ptlrpc_connection::c_peer</a>, <a class="el" href="lustre__net_8h_source.html#l00523">ptlrpc_connection::c_remote_uuid</a>, <a class="el" href="lustre__import_8h_source.html#l00170">obd_import::imp_connection</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__import_8h_source.html#l00217">obd_import::imp_recovery_waitq</a>, <a class="el" href="lustre__import_8h_source.html#l00224">obd_import::imp_replay_inflight</a>, <a class="el" href="lustre__import_8h_source.html#l00230">obd_import::imp_state</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00304">lnet_process_id_t::nid</a>, <a class="el" href="recover_8c_source.html#l00196">ptlrpc_resend()</a>, and <a class="el" href="recover_8c_source.html#l00234">ptlrpc_wake_delayed()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01450"></a>01450 {
<a name="l01451"></a>01451         <span class="keywordtype">int</span> rc = 0;
<a name="l01452"></a>01452         <span class="keywordtype">int</span> inflight;
<a name="l01453"></a>01453         <span class="keywordtype">char</span> *target_start;
<a name="l01454"></a>01454         <span class="keywordtype">int</span> target_len;
<a name="l01455"></a>01455 
<a name="l01456"></a>01456         ENTRY;
<a name="l01457"></a>01457         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_EVICTED) {
<a name="l01458"></a>01458                 deuuidify(obd2cli_tgt(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>), NULL,
<a name="l01459"></a>01459                           &amp;target_start, &amp;target_len);
<a name="l01460"></a>01460                 <span class="comment">/* Don&apos;t care about MGC eviction */</span>
<a name="l01461"></a>01461                 <span class="keywordflow">if</span> (strcmp(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_type-&gt;typ_name,
<a name="l01462"></a>01462                            LUSTRE_MGC_NAME) != 0) {
<a name="l01463"></a>01463                         LCONSOLE_ERROR_MSG(0x167, <span class="stringliteral">&quot;%s: This client was evicted &quot;</span>
<a name="l01464"></a>01464                                            <span class="stringliteral">&quot;by %.*s; in progress operations &quot;</span>
<a name="l01465"></a>01465                                            <span class="stringliteral">&quot;using this service will fail.\n&quot;</span>,
<a name="l01466"></a>01466                                            imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name, target_len,
<a name="l01467"></a>01467                                            target_start);
<a name="l01468"></a>01468                 }
<a name="l01469"></a>01469                 CDEBUG(D_HA, <span class="stringliteral">&quot;evicted from %s@%s; invalidating\n&quot;</span>,
<a name="l01470"></a>01470                        obd2cli_tgt(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>),
<a name="l01471"></a>01471                        imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>.uuid);
<a name="l01472"></a>01472                 <span class="comment">/* reset vbr_failed flag upon eviction */</span>
<a name="l01473"></a>01473                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01474"></a>01474                 imp-&gt;imp_vbr_failed = 0;
<a name="l01475"></a>01475                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01476"></a>01476 
<a name="l01477"></a>01477                 {
<a name="l01478"></a>01478                 <span class="keyword">struct </span>task_struct *task;
<a name="l01479"></a>01479                 <span class="comment">/* bug 17802:  XXX client_disconnect_export vs connect request</span>
<a name="l01480"></a>01480 <span class="comment">                 * race. if client is evicted at this time then we start</span>
<a name="l01481"></a>01481 <span class="comment">                 * invalidate thread without reference to import and import can</span>
<a name="l01482"></a>01482 <span class="comment">                 * be freed at same time. */</span>
<a name="l01483"></a>01483                 class_import_get(imp);
<a name="l01484"></a>01484                 task = kthread_run(ptlrpc_invalidate_import_thread, imp,
<a name="l01485"></a>01485                                      <span class="stringliteral">&quot;ll_imp_inval&quot;</span>);
<a name="l01486"></a>01486                 <span class="keywordflow">if</span> (IS_ERR(task)) {
<a name="l01487"></a>01487                         class_import_put(imp);
<a name="l01488"></a>01488                         CERROR(<span class="stringliteral">&quot;error starting invalidate thread: %d\n&quot;</span>, rc);
<a name="l01489"></a>01489                         rc = PTR_ERR(task);
<a name="l01490"></a>01490                 } <span class="keywordflow">else</span> {
<a name="l01491"></a>01491                         rc = 0;
<a name="l01492"></a>01492                 }
<a name="l01493"></a>01493                 RETURN(rc);
<a name="l01494"></a>01494                 }
<a name="l01495"></a>01495         }
<a name="l01496"></a>01496 
<a name="l01497"></a>01497         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_REPLAY) {
<a name="l01498"></a>01498                 CDEBUG(D_HA, <span class="stringliteral">&quot;replay requested by %s\n&quot;</span>,
<a name="l01499"></a>01499                        obd2cli_tgt(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>));
<a name="l01500"></a>01500                 rc = ptlrpc_replay_next(imp, &amp;inflight);
<a name="l01501"></a>01501                 <span class="keywordflow">if</span> (inflight == 0 &amp;&amp;
<a name="l01502"></a>01502                     atomic_read(&amp;imp-&gt;<a class="code" href="structobd__import.html#a128f8537a5590b089f0b0155f80674ab" title="Number of replay requests inflight.">imp_replay_inflight</a>) == 0) {
<a name="l01503"></a>01503                         IMPORT_SET_STATE(imp, LUSTRE_IMP_REPLAY_LOCKS);
<a name="l01504"></a>01504                         rc = ldlm_replay_locks(imp);
<a name="l01505"></a>01505                         <span class="keywordflow">if</span> (rc)
<a name="l01506"></a>01506                                 GOTO(out, rc);
<a name="l01507"></a>01507                 }
<a name="l01508"></a>01508                 rc = 0;
<a name="l01509"></a>01509         }
<a name="l01510"></a>01510 
<a name="l01511"></a>01511         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_REPLAY_LOCKS) {
<a name="l01512"></a>01512                 <span class="keywordflow">if</span> (atomic_read(&amp;imp-&gt;<a class="code" href="structobd__import.html#a128f8537a5590b089f0b0155f80674ab" title="Number of replay requests inflight.">imp_replay_inflight</a>) == 0) {
<a name="l01513"></a>01513                         IMPORT_SET_STATE(imp, LUSTRE_IMP_REPLAY_WAIT);
<a name="l01514"></a>01514                         rc = signal_completed_replay(imp);
<a name="l01515"></a>01515                         <span class="keywordflow">if</span> (rc)
<a name="l01516"></a>01516                                 GOTO(out, rc);
<a name="l01517"></a>01517                 }
<a name="l01518"></a>01518         }
<a name="l01519"></a>01519 
<a name="l01520"></a>01520         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_REPLAY_WAIT) {
<a name="l01521"></a>01521                 <span class="keywordflow">if</span> (atomic_read(&amp;imp-&gt;<a class="code" href="structobd__import.html#a128f8537a5590b089f0b0155f80674ab" title="Number of replay requests inflight.">imp_replay_inflight</a>) == 0) {
<a name="l01522"></a>01522                         IMPORT_SET_STATE(imp, LUSTRE_IMP_RECOVER);
<a name="l01523"></a>01523                 }
<a name="l01524"></a>01524         }
<a name="l01525"></a>01525 
<a name="l01526"></a>01526         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_RECOVER) {
<a name="l01527"></a>01527                 <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> *conn = imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>;
<a name="l01528"></a>01528 
<a name="l01529"></a>01529                 rc = <a class="code" href="group__ha.html#gaf20ae4ef40ab6633e816a6b842697203" title="Schedule resending of request on sending_list.">ptlrpc_resend</a>(imp);
<a name="l01530"></a>01530                 <span class="keywordflow">if</span> (rc)
<a name="l01531"></a>01531                         GOTO(out, rc);
<a name="l01532"></a>01532                 IMPORT_SET_STATE(imp, LUSTRE_IMP_FULL);
<a name="l01533"></a>01533                 ptlrpc_activate_import(imp);
<a name="l01534"></a>01534 
<a name="l01535"></a>01535                 LCONSOLE_INFO(<span class="stringliteral">&quot;%s: Connection restored to %s (at %s)\n&quot;</span>,
<a name="l01536"></a>01536                               imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01537"></a>01537                               obd_uuid2str(&amp;conn-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>),
<a name="l01538"></a>01538                               libcfs_nid2str(imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>));
<a name="l01539"></a>01539         }
<a name="l01540"></a>01540 
<a name="l01541"></a>01541         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_FULL) {
<a name="l01542"></a>01542                 wake_up_all(&amp;imp-&gt;<a class="code" href="structobd__import.html#a43b896a006360181311cd5c246bd7c8b" title="Wait queue for those who need to wait for recovery completion.">imp_recovery_waitq</a>);
<a name="l01543"></a>01543                 <a class="code" href="group__ha.html#ga903dde67851aeb4d8fa5869641a95c34" title="Go through all requests in delayed list and wake their threads for resending.">ptlrpc_wake_delayed</a>(imp);
<a name="l01544"></a>01544         }
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 out:
<a name="l01547"></a>01547         RETURN(rc);
<a name="l01548"></a>01548 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gae24ff0ea3f19794b41cb4da94ffa9ce2_cgraph.png" border="0" usemap="#group__net_gae24ff0ea3f19794b41cb4da94ffa9ce2_cgraph_map" alt=""></div>
<map name="group__net_gae24ff0ea3f19794b41cb4da94ffa9ce2_cgraph_map" id="group__net_gae24ff0ea3f19794b41cb4da94ffa9ce2_cgraph">
<area shape="rect" id="node3" href="group__ha.html#gaf20ae4ef40ab6633e816a6b842697203" title="Schedule resending of request on sending_list." alt="" coords="365,5,480,35"/><area shape="rect" id="node5" href="group__ha.html#ga903dde67851aeb4d8fa5869641a95c34" title="Go through all requests in delayed list and wake their threads for resending." alt="" coords="341,59,504,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf2442fe17f822101d45881701da27f40"></a><!-- doxytag: member="lustre_net.h::ptlrpc_next_xid" ref="gaf2442fe17f822101d45881701da27f40" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__u64 ptlrpc_next_xid </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase xid and returns resulting new value to the caller. </p>
<p>Multi-bulk BRW RPCs consume multiple XIDs for each bulk transfer, starting at the returned xid, up to xid + PTLRPC_BULK_OPS_COUNT - 1. The BRW RPC itself uses the last bulk xid needed, so the server can determine the the number of bulk transfers from the RPC XID and a bitmask. The starting xid must align to a power-of-two value.</p>
<p>This is assumed to be true due to the initial ptlrpc_last_xid value also being initialized to a power-of-two value. LU-1431 </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l03177">3177</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l03178"></a>03178 {
<a name="l03179"></a>03179         __u64 next;
<a name="l03180"></a>03180 
<a name="l03181"></a>03181         spin_lock(&amp;ptlrpc_last_xid_lock);
<a name="l03182"></a>03182         next = ptlrpc_last_xid + PTLRPC_BULK_OPS_COUNT;
<a name="l03183"></a>03183         ptlrpc_last_xid = next;
<a name="l03184"></a>03184         spin_unlock(&amp;ptlrpc_last_xid_lock);
<a name="l03185"></a>03185 
<a name="l03186"></a>03186         <span class="keywordflow">return</span> next;
<a name="l03187"></a>03187 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga42ea756e2d84491e4b6ea2e53616d7cb"></a><!-- doxytag: member="lustre_net.h::ptlrpc_prep_bulk_imp" ref="ga42ea756e2d84491e4b6ea2e53616d7cb" args="(struct ptlrpc_request *req, unsigned nfrags, unsigned max_brw, unsigned int type, unsigned portal, const struct ptlrpc_bulk_frag_ops *ops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a>* ptlrpc_prep_bulk_imp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>nfrags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>max_brw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> *&nbsp;</td>
          <td class="paramname"> <em>ops</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare bulk descriptor for specified outgoing request <em>req</em> that can fit <em>nfrags</em> * pages. </p>
<p><em>type</em> is bulk type. <em>portal</em> is where the bulk to be sent. Used on client-side. Returns pointer to newly allocatrd initialized bulk descriptor or NULL on error. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00174">174</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01448">ptlrpc_bulk_desc::bd_import</a>, <a class="el" href="lustre__net_8h_source.html#l01440">ptlrpc_bulk_desc::bd_import_generation</a>, <a class="el" href="lustre__net_8h_source.html#l01450">ptlrpc_bulk_desc::bd_req</a>, and <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00180"></a>00180 {
<a name="l00181"></a>00181         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l00182"></a>00182         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         ENTRY;
<a name="l00185"></a>00185         LASSERT(ptlrpc_is_bulk_op_passive(type));
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         desc = ptlrpc_new_bulk(nfrags, max_brw, type, portal, ops);
<a name="l00188"></a>00188         <span class="keywordflow">if</span> (desc == NULL)
<a name="l00189"></a>00189                 RETURN(NULL);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a939c59e8ca2ab48321d206fb7ac148b5" title="Import generation when request for this bulk was sent.">bd_import_generation</a> = req-&gt;rq_import_generation;
<a name="l00192"></a>00192         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a> = class_import_get(imp);
<a name="l00193"></a>00193         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a4d18b5020a6fbf0bb1c7f7e1af278707" title="Back pointer to the request.">bd_req</a> = req;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         desc-&gt;bd_cbid.cbid_fn  = client_bulk_callback;
<a name="l00196"></a>00196         desc-&gt;bd_cbid.cbid_arg = desc;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198         <span class="comment">/* This makes req own desc, and free it when she frees herself */</span>
<a name="l00199"></a>00199         req-&gt;rq_bulk = desc;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201         <span class="keywordflow">return</span> desc;
<a name="l00202"></a>00202 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2d9ff5fa185af154f37c364df7b5c4cc"></a><!-- doxytag: member="lustre_net.h::ptlrpc_prep_fcset" ref="ga2d9ff5fa185af154f37c364df7b5c4cc" args="(int max, set_producer_func func, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a>* ptlrpc_prep_fcset </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set_producer_func&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and initialize new request set structure with flow control extension. </p>
<p>This extension allows to control the number of requests in-flight for the whole set. A callback function to generate requests must be provided and the request set will keep the number of requests sent over the wire to . Returns a pointer to the newly allocated set structure or NULL on error. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00948">948</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l00913">ptlrpc_prep_set()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00951"></a>00951 {
<a name="l00952"></a>00952         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         <span class="keyword">set</span> = <a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT.">ptlrpc_prep_set</a>();
<a name="l00955"></a>00955         <span class="keywordflow">if</span> (!<span class="keyword">set</span>)
<a name="l00956"></a>00956                 RETURN(NULL);
<a name="l00957"></a>00957 
<a name="l00958"></a>00958         <span class="keyword">set</span>-&gt;set_max_inflight  = max;
<a name="l00959"></a>00959         <span class="keyword">set</span>-&gt;set_producer      = func;
<a name="l00960"></a>00960         <span class="keyword">set</span>-&gt;set_producer_arg  = arg;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962         RETURN(<span class="keyword">set</span>);
<a name="l00963"></a>00963 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga2d9ff5fa185af154f37c364df7b5c4cc_cgraph.png" border="0" usemap="#group__net_ga2d9ff5fa185af154f37c364df7b5c4cc_cgraph_map" alt=""></div>
<map name="group__net_ga2d9ff5fa185af154f37c364df7b5c4cc_cgraph_map" id="group__net_ga2d9ff5fa185af154f37c364df7b5c4cc_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT." alt="" coords="195,5,323,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7e29af1c85aba7368cea369f091d09b4"></a><!-- doxytag: member="lustre_net.h::ptlrpc_prep_set" ref="ga7e29af1c85aba7368cea369f091d09b4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a>* ptlrpc_prep_set </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and initialize new request set structure on the current CPT. </p>
<p>Returns a pointer to the newly allocated set structure or NULL on error. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00913">913</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l00948">ptlrpc_prep_fcset()</a>, and <a class="el" href="client_8c_source.html#l02829">ptlrpc_queue_wait()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00914"></a>00914 {
<a name="l00915"></a>00915         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a>       *<span class="keyword">set</span>;
<a name="l00916"></a>00916         <span class="keywordtype">int</span>                             cpt;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918         ENTRY;
<a name="l00919"></a>00919         cpt = cfs_cpt_current(<a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>, 0);
<a name="l00920"></a>00920         OBD_CPT_ALLOC(<span class="keyword">set</span>, <a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>, cpt, <span class="keyword">sizeof</span> *<span class="keyword">set</span>);
<a name="l00921"></a>00921         <span class="keywordflow">if</span> (!<span class="keyword">set</span>)
<a name="l00922"></a>00922                 RETURN(NULL);
<a name="l00923"></a>00923         atomic_set(&amp;set-&gt;set_refcount, 1);
<a name="l00924"></a>00924         INIT_LIST_HEAD(&amp;set-&gt;set_requests);
<a name="l00925"></a>00925         init_waitqueue_head(&amp;set-&gt;set_waitq);
<a name="l00926"></a>00926         atomic_set(&amp;set-&gt;set_new_count, 0);
<a name="l00927"></a>00927         atomic_set(&amp;set-&gt;set_remaining, 0);
<a name="l00928"></a>00928         spin_lock_init(&amp;set-&gt;set_new_req_lock);
<a name="l00929"></a>00929         INIT_LIST_HEAD(&amp;set-&gt;set_new_requests);
<a name="l00930"></a>00930         INIT_LIST_HEAD(&amp;set-&gt;set_cblist);
<a name="l00931"></a>00931         <span class="keyword">set</span>-&gt;set_max_inflight = UINT_MAX;
<a name="l00932"></a>00932         <span class="keyword">set</span>-&gt;set_producer     = NULL;
<a name="l00933"></a>00933         <span class="keyword">set</span>-&gt;set_producer_arg = NULL;
<a name="l00934"></a>00934         <span class="keyword">set</span>-&gt;set_rc           = 0;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936         RETURN(<span class="keyword">set</span>);
<a name="l00937"></a>00937 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga7e29af1c85aba7368cea369f091d09b4_icgraph.png" border="0" usemap="#group__net_ga7e29af1c85aba7368cea369f091d09b4_icgraph_map" alt=""></div>
<map name="group__net_ga7e29af1c85aba7368cea369f091d09b4_icgraph_map" id="group__net_ga7e29af1c85aba7368cea369f091d09b4_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga2d9ff5fa185af154f37c364df7b5c4cc" title="Allocate and initialize new request set structure with flow control extension." alt="" coords="184,56,325,85"/><area shape="rect" id="node5" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="181,109,328,139"/><area shape="rect" id="node7" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="380,56,524,85"/><area shape="rect" id="node9" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="377,109,527,139"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="384,163,520,192"/><area shape="rect" id="node11" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="577,109,724,139"/><area shape="rect" id="node13" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="807,29,927,59"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="775,83,959,112"/><area shape="rect" id="node24" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1259,108,1501,137"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="796,187,937,216"/><area shape="rect" id="node15" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1009,29,1209,59"/><area shape="rect" id="node17" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1311,29,1449,59"/><area shape="rect" id="node22" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1008,83,1211,112"/><area shape="rect" id="node26" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1549,108,1725,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga003cd2f0c09fd578821500e8084f8c48"></a><!-- doxytag: member="lustre_net.h::ptlrpc_queue_wait" ref="ga003cd2f0c09fd578821500e8084f8c48" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_queue_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send request and wait until it completes. </p>
<p>Returns request processing status. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02829">2829</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l00913">ptlrpc_prep_set()</a>, <a class="el" href="client_8c_source.html#l02757">ptlrpc_request_addref()</a>, <a class="el" href="client_8c_source.html#l01050">ptlrpc_set_add_req()</a>, <a class="el" href="client_8c_source.html#l00973">ptlrpc_set_destroy()</a>, <a class="el" href="client_8c_source.html#l02260">ptlrpc_set_wait()</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p>Referenced by <a class="el" href="pack__generic_8c_source.html#l01574">do_set_info_async()</a>, <a class="el" href="ldlm__request_8c_source.html#l01185">ldlm_cli_cancel_req()</a>, and <a class="el" href="ldlm__request_8c_source.html#l00869">ldlm_cli_enqueue()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02830"></a>02830 {
<a name="l02831"></a>02831         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>;
<a name="l02832"></a>02832         <span class="keywordtype">int</span> rc;
<a name="l02833"></a>02833         ENTRY;
<a name="l02834"></a>02834 
<a name="l02835"></a>02835         LASSERT(req-&gt;rq_set == NULL);
<a name="l02836"></a>02836         LASSERT(!req-&gt;rq_receiving_reply);
<a name="l02837"></a>02837 
<a name="l02838"></a>02838         <span class="keyword">set</span> = <a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT.">ptlrpc_prep_set</a>();
<a name="l02839"></a>02839         <span class="keywordflow">if</span> (<span class="keyword">set</span> == NULL) {
<a name="l02840"></a>02840                 CERROR(<span class="stringliteral">&quot;cannot allocate ptlrpc set: rc = %d\n&quot;</span>, -ENOMEM);
<a name="l02841"></a>02841                 RETURN(-ENOMEM);
<a name="l02842"></a>02842         }
<a name="l02843"></a>02843 
<a name="l02844"></a>02844         <span class="comment">/* for distributed debugging */</span>
<a name="l02845"></a>02845         lustre_msg_set_status(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, current_pid());
<a name="l02846"></a>02846 
<a name="l02847"></a>02847         <span class="comment">/* add a ref for the set (see comment in ptlrpc_set_add_req) */</span>
<a name="l02848"></a>02848         <a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>(req);
<a name="l02849"></a>02849         <a class="code" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set.">ptlrpc_set_add_req</a>(<span class="keyword">set</span>, req);
<a name="l02850"></a>02850         rc = <a class="code" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set...">ptlrpc_set_wait</a>(<span class="keyword">set</span>);
<a name="l02851"></a>02851         <a class="code" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set...">ptlrpc_set_destroy</a>(<span class="keyword">set</span>);
<a name="l02852"></a>02852 
<a name="l02853"></a>02853         RETURN(rc);
<a name="l02854"></a>02854 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga003cd2f0c09fd578821500e8084f8c48_cgraph.png" border="0" usemap="#group__net_ga003cd2f0c09fd578821500e8084f8c48_cgraph_map" alt=""></div>
<map name="group__net_ga003cd2f0c09fd578821500e8084f8c48_cgraph_map" id="group__net_ga003cd2f0c09fd578821500e8084f8c48_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT." alt="" coords="212,5,340,35"/><area shape="rect" id="node5" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req." alt="" coords="859,57,1029,87"/><area shape="rect" id="node7" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set." alt="" coords="201,109,351,139"/><area shape="rect" id="node9" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set..." alt="" coords="401,148,551,177"/><area shape="rect" id="node13" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="213,240,339,269"/><area shape="rect" id="node11" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request." alt="" coords="871,111,1017,140"/><area shape="rect" id="node15" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="407,267,545,296"/><area shape="rect" id="node17" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="639,267,745,296"/><area shape="rect" id="node32" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network." alt="" coords="859,476,1029,505"/><area shape="rect" id="node42" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="601,489,783,519"/><area shape="rect" id="node19" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME." alt="" coords="1123,332,1248,361"/><area shape="rect" id="node21" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal." alt="" coords="1124,176,1247,205"/><area shape="rect" id="node23" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list." alt="" coords="1128,255,1243,284"/><area shape="rect" id="node25" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Actual interfacing with LNet to put/get/register/unregister stuff." alt="" coords="867,215,1021,244"/><area shape="rect" id="node34" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req." alt="" coords="856,319,1032,348"/><area shape="rect" id="node36" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre&#45;defined security transformation upon the..." alt="" coords="851,423,1037,452"/><area shape="rect" id="node38" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc." alt="" coords="1105,423,1265,452"/><area shape="rect" id="node44" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="832,529,1056,559"/><area shape="rect" id="node46" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="1107,503,1264,532"/><area shape="rect" id="node48" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="1107,556,1264,585"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga003cd2f0c09fd578821500e8084f8c48_icgraph.png" border="0" usemap="#group__net_ga003cd2f0c09fd578821500e8084f8c48_icgraph_map" alt=""></div>
<map name="group__net_ga003cd2f0c09fd578821500e8084f8c48_icgraph_map" id="group__net_ga003cd2f0c09fd578821500e8084f8c48_icgraph">
<area shape="rect" id="node3" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="204,56,348,85"/><area shape="rect" id="node5" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="201,109,351,139"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="208,163,344,192"/><area shape="rect" id="node7" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="401,109,548,139"/><area shape="rect" id="node9" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="631,29,751,59"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="599,83,783,112"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1083,108,1325,137"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="620,187,761,216"/><area shape="rect" id="node11" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="833,29,1033,59"/><area shape="rect" id="node13" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1135,29,1273,59"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="832,83,1035,112"/><area shape="rect" id="node22" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1373,108,1549,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa1cf14602e33836d92101141c3a0d67d"></a><!-- doxytag: member="lustre_net.h::ptlrpc_register_bulk" ref="gaa1cf14602e33836d92101141c3a0d67d" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_register_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Actual interfacing with LNet to put/get/register/unregister stuff. </p>
<p>Actual interfacing with LNet to put/get/register/unregister stuff.</p>
<p>Returns 0 on success or error code. </p>

<p>Definition at line <a class="el" href="niobuf_8c_source.html#l00301">301</a> of file <a class="el" href="niobuf_8c_source.html">niobuf.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01434">ptlrpc_bulk_desc::bd_failure</a>, <a class="el" href="lustre__net_8h_source.html#l01448">ptlrpc_bulk_desc::bd_import</a>, <a class="el" href="lustre__net_8h_source.html#l01438">ptlrpc_bulk_desc::bd_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01465">ptlrpc_bulk_desc::bd_mds</a>, <a class="el" href="lustre__net_8h_source.html#l01444">ptlrpc_bulk_desc::bd_portal</a>, <a class="el" href="lustre__net_8h_source.html#l01436">ptlrpc_bulk_desc::bd_registered</a>, <a class="el" href="lustre__net_8h_source.html#l01450">ptlrpc_bulk_desc::bd_req</a>, <a class="el" href="lustre__net_8h_source.html#l01442">ptlrpc_bulk_desc::bd_type</a>, <a class="el" href="lustre__net_8h_source.html#l00521">ptlrpc_connection::c_peer</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00440">lnet_md_t::eq_handle</a>, <a class="el" href="lustre__import_8h_source.html#l00170">obd_import::imp_connection</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00333">LNET_INS_AFTER</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00450">LNET_MAX_IOV</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00457">LNET_MD_OP_GET</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00455">LNET_MD_OP_PUT</a>, <a class="el" href="lib-md_8c_source.html#l00263">LNetMDAttach()</a>, <a class="el" href="lib-me_8c_source.html#l00076">LNetMEAttach()</a>, <a class="el" href="lib-me_8c_source.html#l00227">LNetMEUnlink()</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00426">lnet_md_t::options</a>, <a class="el" href="lustre__net_8h_source.html#l00094">PTLRPC_BULK_OPS_MASK</a>, <a class="el" href="lustre__net_8h_source.html#l01038">ptlrpc_request::rq_mbits</a>, <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00381">lnet_md_t::threshold</a>, and <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00433">lnet_md_t::user_ptr</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00302"></a>00302 {
<a name="l00303"></a>00303         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc = req-&gt;rq_bulk;
<a name="l00304"></a>00304         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> peer;
<a name="l00305"></a>00305         <span class="keywordtype">int</span> rc = 0;
<a name="l00306"></a>00306         <span class="keywordtype">int</span> rc2;
<a name="l00307"></a>00307         <span class="keywordtype">int</span> posted_md;
<a name="l00308"></a>00308         <span class="keywordtype">int</span> total_md;
<a name="l00309"></a>00309         __u64 mbits;
<a name="l00310"></a>00310         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_me_t</a>  me_h;
<a name="l00311"></a>00311         <a class="code" href="structlnet__md__t.html" title="Defines the visible parts of a memory descriptor.">lnet_md_t</a>         md;
<a name="l00312"></a>00312         ENTRY;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_BULK_GET_NET))
<a name="l00315"></a>00315                 RETURN(0);
<a name="l00316"></a>00316 
<a name="l00317"></a>00317         <span class="comment">/* NB no locking required until desc is on the network */</span>
<a name="l00318"></a>00318         LASSERT(desc-&gt;bd_nob &gt; 0);
<a name="l00319"></a>00319         LASSERT(desc-&gt;bd_md_count == 0);
<a name="l00320"></a>00320         LASSERT(desc-&gt;bd_md_max_brw &lt;= PTLRPC_BULK_OPS_COUNT);
<a name="l00321"></a>00321         LASSERT(desc-&gt;bd_iov_count &lt;= PTLRPC_MAX_BRW_PAGES);
<a name="l00322"></a>00322         LASSERT(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a4d18b5020a6fbf0bb1c7f7e1af278707" title="Back pointer to the request.">bd_req</a> != NULL);
<a name="l00323"></a>00323         LASSERT(ptlrpc_is_bulk_op_passive(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a>));
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         <span class="comment">/* cleanup the state of the bulk for it will be reused */</span>
<a name="l00326"></a>00326         <span class="keywordflow">if</span> (req-&gt;rq_resend || req-&gt;rq_send_state == LUSTRE_IMP_REPLAY)
<a name="l00327"></a>00327                 desc-&gt;bd_nob_transferred = 0;
<a name="l00328"></a>00328         <span class="keywordflow">else</span>
<a name="l00329"></a>00329                 LASSERT(desc-&gt;bd_nob_transferred == 0);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#ad2c8f2d528e849f5032676b40f040f0c" title="completed with failure">bd_failure</a> = 0;
<a name="l00332"></a>00332 
<a name="l00333"></a>00333         peer = desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a>-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335         LASSERT(desc-&gt;bd_cbid.cbid_fn == client_bulk_callback);
<a name="l00336"></a>00336         LASSERT(desc-&gt;bd_cbid.cbid_arg == desc);
<a name="l00337"></a>00337 
<a name="l00338"></a>00338         total_md = (desc-&gt;bd_iov_count + <a class="code" href="group__lnet__md.html#gae5c5481fe02371e7bf253b2b1cf0d030" title="limit on the number of fragments in discontiguous MDs">LNET_MAX_IOV</a> - 1) / <a class="code" href="group__lnet__md.html#gae5c5481fe02371e7bf253b2b1cf0d030" title="limit on the number of fragments in discontiguous MDs">LNET_MAX_IOV</a>;
<a name="l00339"></a>00339         <span class="comment">/* rq_mbits is matchbits of the final bulk */</span>
<a name="l00340"></a>00340         mbits = req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a> - total_md + 1;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342         LASSERTF(mbits == (req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a> &amp; <a class="code" href="group__net.html#ga8b841cf2fb3c1d1c92a9ddcf7068bb4c" title="PTLRPC_BULK_OPS_MASK is for the convenience of the client only, and should not be...">PTLRPC_BULK_OPS_MASK</a>),
<a name="l00343"></a>00343                  <span class="stringliteral">&quot;first mbits = x&quot;</span>LPU64<span class="stringliteral">&quot;, last mbits = x&quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00344"></a>00344                  mbits, req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a>);
<a name="l00345"></a>00345         LASSERTF(!(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a29bfcbd3cf54cdbc36b530bd00362ea4" title="client side">bd_registered</a> &amp;&amp;
<a name="l00346"></a>00346                    req-&gt;rq_send_state != LUSTRE_IMP_REPLAY) ||
<a name="l00347"></a>00347                  mbits != desc-&gt;bd_last_mbits,
<a name="l00348"></a>00348                  <span class="stringliteral">&quot;registered: %d  rq_mbits: &quot;</span>LPU64<span class="stringliteral">&quot; bd_last_mbits: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00349"></a>00349                  desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a29bfcbd3cf54cdbc36b530bd00362ea4" title="client side">bd_registered</a>, mbits, desc-&gt;bd_last_mbits);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a29bfcbd3cf54cdbc36b530bd00362ea4" title="client side">bd_registered</a> = 1;
<a name="l00352"></a>00352         desc-&gt;bd_last_mbits = mbits;
<a name="l00353"></a>00353         desc-&gt;bd_md_count = total_md;
<a name="l00354"></a>00354         md.<a class="code" href="structlnet__md__t.html#a57f16fe0f86a1e86553eb0a1eee4bd58" title="A user-specified value that is associated with the memory descriptor.">user_ptr</a> = &amp;desc-&gt;bd_cbid;
<a name="l00355"></a>00355         md.<a class="code" href="structlnet__md__t.html#a568b34498bd37af0973c749f5e856a3b" title="A handle for the event queue used to log the operations performed on the memory region...">eq_handle</a> = ptlrpc_eq_h;
<a name="l00356"></a>00356         md.<a class="code" href="structlnet__md__t.html#a60130fbc7253f41b3b6cd8da947ff023" title="Specifies the maximum number of operations that can be performed on the memory descriptor...">threshold</a> = 1;                       <span class="comment">/* PUT or GET */</span>
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         <span class="keywordflow">for</span> (posted_md = 0; posted_md &lt; total_md; posted_md++, mbits++) {
<a name="l00359"></a>00359                 md.<a class="code" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">options</a> = PTLRPC_MD_OPTIONS |
<a name="l00360"></a>00360                              (ptlrpc_is_bulk_op_get(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a>) ?
<a name="l00361"></a>00361                               <a class="code" href="group__lnet__md.html#ga2f9879433bdc5c8f77f13359f74e5df5" title="See lnet_md_t::options.">LNET_MD_OP_GET</a> : <a class="code" href="group__lnet__md.html#ga653ba41bd3978635e420cfa4601193e1" title="Options for the MD structure.">LNET_MD_OP_PUT</a>);
<a name="l00362"></a>00362                 ptlrpc_fill_bulk_md(&amp;md, desc, posted_md);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364                 rc = <a class="code" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal.">LNetMEAttach</a>(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a18b9d9682e655499c82b9e785343d0df" title="LNet portal for this bulk.">bd_portal</a>, peer, mbits, 0,
<a name="l00365"></a>00365                                   LNET_UNLINK, <a class="code" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a9c92e271885b81271fa1467f486dcd07" title="insert ME after current position or tail of the list">LNET_INS_AFTER</a>, &amp;me_h);
<a name="l00366"></a>00366                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l00367"></a>00367                         CERROR(<span class="stringliteral">&quot;%s: LNetMEAttach failed x&quot;</span>LPU64<span class="stringliteral">&quot;/%d: rc = %d\n&quot;</span>,
<a name="l00368"></a>00368                                desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name, mbits,
<a name="l00369"></a>00369                                posted_md, rc);
<a name="l00370"></a>00370                         <span class="keywordflow">break</span>;
<a name="l00371"></a>00371                 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373                 <span class="comment">/* About to let the network at it... */</span>
<a name="l00374"></a>00374                 rc = <a class="code" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME.">LNetMDAttach</a>(me_h, md, LNET_UNLINK,
<a name="l00375"></a>00375                                   &amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a39514074e69f6f37f43699541282c288" title="array of associated MDs">bd_mds</a>[posted_md]);
<a name="l00376"></a>00376                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l00377"></a>00377                         CERROR(<span class="stringliteral">&quot;%s: LNetMDAttach failed x&quot;</span>LPU64<span class="stringliteral">&quot;/%d: rc = %d\n&quot;</span>,
<a name="l00378"></a>00378                                desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name, mbits,
<a name="l00379"></a>00379                                posted_md, rc);
<a name="l00380"></a>00380                         rc2 = <a class="code" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list.">LNetMEUnlink</a>(me_h);
<a name="l00381"></a>00381                         LASSERT(rc2 == 0);
<a name="l00382"></a>00382                         <span class="keywordflow">break</span>;
<a name="l00383"></a>00383                 }
<a name="l00384"></a>00384         }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00387"></a>00387                 LASSERT(rc == -ENOMEM);
<a name="l00388"></a>00388                 spin_lock(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>);
<a name="l00389"></a>00389                 desc-&gt;bd_md_count -= total_md - posted_md;
<a name="l00390"></a>00390                 spin_unlock(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>);
<a name="l00391"></a>00391                 LASSERT(desc-&gt;bd_md_count &gt;= 0);
<a name="l00392"></a>00392                 mdunlink_iterate_helper(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a39514074e69f6f37f43699541282c288" title="array of associated MDs">bd_mds</a>, desc-&gt;bd_md_max_brw);
<a name="l00393"></a>00393                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -ENOMEM;
<a name="l00394"></a>00394                 RETURN(-ENOMEM);
<a name="l00395"></a>00395         }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397         spin_lock(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>);
<a name="l00398"></a>00398         <span class="comment">/* Holler if peer manages to touch buffers before he knows the mbits */</span>
<a name="l00399"></a>00399         <span class="keywordflow">if</span> (desc-&gt;bd_md_count != total_md)
<a name="l00400"></a>00400                 CWARN(<span class="stringliteral">&quot;%s: Peer %s touched %d buffers while I registered\n&quot;</span>,
<a name="l00401"></a>00401                       desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name, libcfs_id2str(peer),
<a name="l00402"></a>00402                       total_md - desc-&gt;bd_md_count);
<a name="l00403"></a>00403         spin_unlock(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         CDEBUG(D_NET, <span class="stringliteral">&quot;Setup %u bulk %s buffers: %u pages %u bytes, &quot;</span>
<a name="l00406"></a>00406                <span class="stringliteral">&quot;mbits x&quot;</span>LPX64<span class="stringliteral">&quot;-&quot;</span>LPX64<span class="stringliteral">&quot;, portal %u\n&quot;</span>, desc-&gt;bd_md_count,
<a name="l00407"></a>00407                ptlrpc_is_bulk_op_get(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a>) ? <span class="stringliteral">&quot;get-source&quot;</span> : <span class="stringliteral">&quot;put-sink&quot;</span>,
<a name="l00408"></a>00408                desc-&gt;bd_iov_count, desc-&gt;bd_nob,
<a name="l00409"></a>00409                desc-&gt;bd_last_mbits, req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a>, desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a18b9d9682e655499c82b9e785343d0df" title="LNet portal for this bulk.">bd_portal</a>);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411         RETURN(0);
<a name="l00412"></a>00412 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gaa1cf14602e33836d92101141c3a0d67d_cgraph.png" border="0" usemap="#group__net_gaa1cf14602e33836d92101141c3a0d67d_cgraph_map" alt=""></div>
<map name="group__net_gaa1cf14602e33836d92101141c3a0d67d_cgraph_map" id="group__net_gaa1cf14602e33836d92101141c3a0d67d_cgraph">
<area shape="rect" id="node3" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME." alt="" coords="209,5,335,35"/><area shape="rect" id="node5" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal." alt="" coords="211,59,333,88"/><area shape="rect" id="node7" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list." alt="" coords="215,112,329,141"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gaa1cf14602e33836d92101141c3a0d67d_icgraph.png" border="0" usemap="#group__net_gaa1cf14602e33836d92101141c3a0d67d_icgraph_map" alt=""></div>
<map name="group__net_gaa1cf14602e33836d92101141c3a0d67d_icgraph_map" id="group__net_gaa1cf14602e33836d92101141c3a0d67d_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="208,84,315,113"/><area shape="rect" id="node5" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="363,84,501,113"/><area shape="rect" id="node7" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="924,56,1068,85"/><area shape="rect" id="node9" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="551,109,676,139"/><area shape="rect" id="node11" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="725,109,872,139"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="921,109,1071,139"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="928,163,1064,192"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1121,109,1268,139"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1351,29,1471,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1319,83,1503,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1803,108,2045,137"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1340,187,1481,216"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1553,29,1753,59"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1855,29,1993,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1552,83,1755,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2093,108,2269,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga13835bf69545de9744051ff7ef02a4c3"></a><!-- doxytag: member="lustre_net.h::ptlrpc_register_service" ref="ga13835bf69545de9744051ff7ef02a4c3" args="(struct ptlrpc_service_conf *conf, struct proc_dir_entry *proc_entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a>* ptlrpc_register_service </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service__conf.html">ptlrpc_service_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct proc_dir_entry *&nbsp;</td>
          <td class="paramname"> <em>proc_entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize service on a given portal. </p>
<p>This includes starting serving threads , allocating and posting rqbds and so on. </p>

<p>Definition at line <a class="el" href="service_8c_source.html#l00690">690</a> of file <a class="el" href="service_8c_source.html">service.c</a>.</p>

<p>References <a class="el" href="lib-ptl_8c_source.html#l00896">LNetSetLazyPortal()</a>, <a class="el" href="lustre__net_8h_source.html#l01661">PTLRPC_SVC_HP_RATIO</a>, <a class="el" href="lustre__net_8h_source.html#l01698">ptlrpc_service::srv_buf_size</a>, <a class="el" href="lustre__net_8h_source.html#l01722">ptlrpc_service::srv_cpt_bits</a>, <a class="el" href="lustre__net_8h_source.html#l01724">ptlrpc_service::srv_cptable</a>, <a class="el" href="lustre__net_8h_source.html#l01720">ptlrpc_service::srv_cpts</a>, <a class="el" href="lustre__net_8h_source.html#l01709">ptlrpc_service::srv_ctx_tags</a>, <a class="el" href="lustre__net_8h_source.html#l01692">ptlrpc_service::srv_hpreq_ratio</a>, <a class="el" href="lustre__net_8h_source.html#l01674">ptlrpc_service::srv_list</a>, <a class="el" href="lustre__net_8h_source.html#l01671">ptlrpc_service::srv_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01696">ptlrpc_service::srv_max_reply_size</a>, <a class="el" href="lustre__net_8h_source.html#l01694">ptlrpc_service::srv_max_req_size</a>, <a class="el" href="lustre__net_8h_source.html#l01678">ptlrpc_service::srv_name</a>, <a class="el" href="lustre__net_8h_source.html#l01700">ptlrpc_service::srv_nbuf_per_group</a>, <a class="el" href="lustre__net_8h_source.html#l01718">ptlrpc_service::srv_ncpts</a>, <a class="el" href="lustre__net_8h_source.html#l01676">ptlrpc_service::srv_ops</a>, <a class="el" href="lustre__net_8h_source.html#l01728">ptlrpc_service::srv_parts</a>, <a class="el" href="lustre__net_8h_source.html#l01704">ptlrpc_service::srv_rep_portal</a>, <a class="el" href="lustre__net_8h_source.html#l01702">ptlrpc_service::srv_req_portal</a>, <a class="el" href="lustre__net_8h_source.html#l01680">ptlrpc_service::srv_thread_name</a>, and <a class="el" href="lustre__net_8h_source.html#l01711">ptlrpc_service::srv_watchdog_factor</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00692"></a>00692 {
<a name="l00693"></a>00693         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__cpt__conf.html">ptlrpc_service_cpt_conf</a>  *cconf = &amp;conf-&gt;psc_cpt;
<a name="l00694"></a>00694         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>           *service;
<a name="l00695"></a>00695         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *svcpt;
<a name="l00696"></a>00696         <span class="keyword">struct </span><a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>            *cptable;
<a name="l00697"></a>00697         __u32                           *cpts = NULL;
<a name="l00698"></a>00698         <span class="keywordtype">int</span>                             ncpts;
<a name="l00699"></a>00699         <span class="keywordtype">int</span>                             cpt;
<a name="l00700"></a>00700         <span class="keywordtype">int</span>                             rc;
<a name="l00701"></a>00701         <span class="keywordtype">int</span>                             i;
<a name="l00702"></a>00702         ENTRY;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         LASSERT(conf-&gt;psc_buf.bc_nbufs &gt; 0);
<a name="l00705"></a>00705         LASSERT(conf-&gt;psc_buf.bc_buf_size &gt;=
<a name="l00706"></a>00706                 conf-&gt;psc_buf.bc_req_max_size + SPTLRPC_MAX_PAYLOAD);
<a name="l00707"></a>00707         LASSERT(conf-&gt;psc_thr.tc_ctx_tags != 0);
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         cptable = cconf-&gt;cc_cptable;
<a name="l00710"></a>00710         <span class="keywordflow">if</span> (cptable == NULL)
<a name="l00711"></a>00711                 cptable = <a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713         <span class="keywordflow">if</span> (!conf-&gt;psc_thr.tc_cpu_affinity) {
<a name="l00714"></a>00714                 ncpts = 1;
<a name="l00715"></a>00715         } <span class="keywordflow">else</span> {
<a name="l00716"></a>00716                 ncpts = cfs_cpt_number(cptable);
<a name="l00717"></a>00717                 <span class="keywordflow">if</span> (cconf-&gt;cc_pattern != NULL) {
<a name="l00718"></a>00718                         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a>    *el;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720                         rc = cfs_expr_list_parse(cconf-&gt;cc_pattern,
<a name="l00721"></a>00721                                                  strlen(cconf-&gt;cc_pattern),
<a name="l00722"></a>00722                                                  0, ncpts - 1, &amp;el);
<a name="l00723"></a>00723                         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00724"></a>00724                                 CERROR(<span class="stringliteral">&quot;%s: invalid CPT pattern string: %s&quot;</span>,
<a name="l00725"></a>00725                                        conf-&gt;psc_name, cconf-&gt;cc_pattern);
<a name="l00726"></a>00726                                 RETURN(ERR_PTR(-EINVAL));
<a name="l00727"></a>00727                         }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729                         rc = cfs_expr_list_values(el, ncpts, &amp;cpts);
<a name="l00730"></a>00730                         cfs_expr_list_free(el);
<a name="l00731"></a>00731                         <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l00732"></a>00732                                 CERROR(<span class="stringliteral">&quot;%s: failed to parse CPT array %s: %d\n&quot;</span>,
<a name="l00733"></a>00733                                        conf-&gt;psc_name, cconf-&gt;cc_pattern, rc);
<a name="l00734"></a>00734                                 <span class="keywordflow">if</span> (cpts != NULL)
<a name="l00735"></a>00735                                         OBD_FREE(cpts, <span class="keyword">sizeof</span>(*cpts) * ncpts);
<a name="l00736"></a>00736                                 RETURN(ERR_PTR(rc &lt; 0 ? rc : -EINVAL));
<a name="l00737"></a>00737                         }
<a name="l00738"></a>00738                         ncpts = rc;
<a name="l00739"></a>00739                 }
<a name="l00740"></a>00740         }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         OBD_ALLOC(service, offsetof(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>, srv_parts[ncpts]));
<a name="l00743"></a>00743         <span class="keywordflow">if</span> (service == NULL) {
<a name="l00744"></a>00744                 <span class="keywordflow">if</span> (cpts != NULL)
<a name="l00745"></a>00745                         OBD_FREE(cpts, <span class="keyword">sizeof</span>(*cpts) * ncpts);
<a name="l00746"></a>00746                 RETURN(ERR_PTR(-ENOMEM));
<a name="l00747"></a>00747         }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749         service-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>            = cptable;
<a name="l00750"></a>00750         service-&gt;<a class="code" href="structptlrpc__service.html#a2c32ba2dab0f289ff0ebbd2f093fe7ba" title="CPTs array this service bound on.">srv_cpts</a>               = cpts;
<a name="l00751"></a>00751         service-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>              = ncpts;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753         service-&gt;<a class="code" href="structptlrpc__service.html#a073426a7d8cdc28ce5ebe9849cc49695" title="2^srv_cptab_bits &amp;gt;= cfs_cpt_numbert(srv_cptable)">srv_cpt_bits</a> = 0; <span class="comment">/* it&apos;s zero already, easy to read... */</span>
<a name="l00754"></a>00754         <span class="keywordflow">while</span> ((1 &lt;&lt; service-&gt;<a class="code" href="structptlrpc__service.html#a073426a7d8cdc28ce5ebe9849cc49695" title="2^srv_cptab_bits &amp;gt;= cfs_cpt_numbert(srv_cptable)">srv_cpt_bits</a>) &lt; cfs_cpt_number(cptable))
<a name="l00755"></a>00755                 service-&gt;<a class="code" href="structptlrpc__service.html#a073426a7d8cdc28ce5ebe9849cc49695" title="2^srv_cptab_bits &amp;gt;= cfs_cpt_numbert(srv_cptable)">srv_cpt_bits</a>++;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         <span class="comment">/* public members */</span>
<a name="l00758"></a>00758         spin_lock_init(&amp;service-&gt;<a class="code" href="structptlrpc__service.html#a2a1688cbca333e023932a1d01da3adf2" title="serialize /proc operations">srv_lock</a>);
<a name="l00759"></a>00759         service-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>               = conf-&gt;psc_name;
<a name="l00760"></a>00760         service-&gt;<a class="code" href="structptlrpc__service.html#a1117d58e40a577dce38f8985a491c895" title="soft watchdog timeout multiplier">srv_watchdog_factor</a>    = conf-&gt;psc_watchdog_factor;
<a name="l00761"></a>00761         INIT_LIST_HEAD(&amp;service-&gt;<a class="code" href="structptlrpc__service.html#a7b76c93b05ae8b75256861ab53f5db59" title="most often accessed fields">srv_list</a>); <span class="comment">/* for safty of cleanup */</span>
<a name="l00762"></a>00762 
<a name="l00763"></a>00763         <span class="comment">/* buffer configuration */</span>
<a name="l00764"></a>00764         service-&gt;<a class="code" href="structptlrpc__service.html#a54dfbef346d31cd165d5815410fe7b25" title="# buffers to allocate in 1 group">srv_nbuf_per_group</a>     = test_req_buffer_pressure ?
<a name="l00765"></a>00765                                           1 : conf-&gt;psc_buf.bc_nbufs;
<a name="l00766"></a>00766         service-&gt;<a class="code" href="structptlrpc__service.html#a4e6fb169a6bd2375b8f724ec9c5c57bc" title="biggest request to receive">srv_max_req_size</a>       = conf-&gt;psc_buf.bc_req_max_size +
<a name="l00767"></a>00767                                           SPTLRPC_MAX_PAYLOAD;
<a name="l00768"></a>00768         service-&gt;<a class="code" href="structptlrpc__service.html#ad777e605aff6b7a216384cec5917575b" title="size of individual buffers">srv_buf_size</a>           = conf-&gt;psc_buf.bc_buf_size;
<a name="l00769"></a>00769         service-&gt;<a class="code" href="structptlrpc__service.html#a80ea8b17769802197d27c45a7a485958" title="Portal on the client to send replies to.">srv_rep_portal</a>         = conf-&gt;psc_buf.bc_rep_portal;
<a name="l00770"></a>00770         service-&gt;<a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>         = conf-&gt;psc_buf.bc_req_portal;
<a name="l00771"></a>00771 
<a name="l00772"></a>00772         <span class="comment">/* Increase max reply size to next power of two */</span>
<a name="l00773"></a>00773         service-&gt;<a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51" title="biggest reply to send">srv_max_reply_size</a> = 1;
<a name="l00774"></a>00774         <span class="keywordflow">while</span> (service-&gt;<a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51" title="biggest reply to send">srv_max_reply_size</a> &lt;
<a name="l00775"></a>00775                conf-&gt;psc_buf.bc_rep_max_size + SPTLRPC_MAX_PAYLOAD)
<a name="l00776"></a>00776                 service-&gt;<a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51" title="biggest reply to send">srv_max_reply_size</a> &lt;&lt;= 1;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778         service-&gt;<a class="code" href="structptlrpc__service.html#a3618e53f527140ea9c7861f64565b321" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_thread_name</a>        = conf-&gt;psc_thr.tc_thr_name;
<a name="l00779"></a>00779         service-&gt;<a class="code" href="structptlrpc__service.html#af76e91c99923a872836d738214efad63" title="Tags for lu_context associated with this thread, see struct lu_context.">srv_ctx_tags</a>           = conf-&gt;psc_thr.tc_ctx_tags;
<a name="l00780"></a>00780         service-&gt;<a class="code" href="structptlrpc__service.html#a73de1e37738df30184d39314262bebbb" title="# hp per lp reqs to handle">srv_hpreq_ratio</a>        = <a class="code" href="group__net.html#ga4f4d7f4b592db13b248e9f0973608f71" title="How many high priority requests to serve before serving one normal priority request...">PTLRPC_SVC_HP_RATIO</a>;
<a name="l00781"></a>00781         service-&gt;<a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90" title="service operations table">srv_ops</a>                = conf-&gt;psc_ops;
<a name="l00782"></a>00782 
<a name="l00783"></a>00783         <span class="keywordflow">for</span> (i = 0; i &lt; ncpts; i++) {
<a name="l00784"></a>00784                 <span class="keywordflow">if</span> (!conf-&gt;psc_thr.tc_cpu_affinity)
<a name="l00785"></a>00785                         cpt = CFS_CPT_ANY;
<a name="l00786"></a>00786                 <span class="keywordflow">else</span>
<a name="l00787"></a>00787                         cpt = cpts != NULL ? cpts[i] : i;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789                 OBD_CPT_ALLOC(svcpt, cptable, cpt, <span class="keyword">sizeof</span>(*svcpt));
<a name="l00790"></a>00790                 <span class="keywordflow">if</span> (svcpt == NULL)
<a name="l00791"></a>00791                         GOTO(failed, rc = -ENOMEM);
<a name="l00792"></a>00792 
<a name="l00793"></a>00793                 service-&gt;<a class="code" href="structptlrpc__service.html#a7e35faf6ba1087f8f57b57fd8ef98bb8" title="partition data for ptlrpc service">srv_parts</a>[i] = svcpt;
<a name="l00794"></a>00794                 rc = ptlrpc_service_part_init(service, svcpt, cpt);
<a name="l00795"></a>00795                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00796"></a>00796                         GOTO(failed, rc);
<a name="l00797"></a>00797         }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799         ptlrpc_server_nthreads_check(service, conf);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         rc = <a class="code" href="group__lnet__misc.html#ga1986737ae4fa6d8756708df641f024e3" title="Turn on the lazy portal attribute.">LNetSetLazyPortal</a>(service-&gt;<a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>);
<a name="l00802"></a>00802         LASSERT(rc == 0);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         mutex_lock(&amp;ptlrpc_all_services_mutex);
<a name="l00805"></a>00805         list_add(&amp;service-&gt;<a class="code" href="structptlrpc__service.html#a7b76c93b05ae8b75256861ab53f5db59" title="most often accessed fields">srv_list</a>, &amp;ptlrpc_all_services);
<a name="l00806"></a>00806         mutex_unlock(&amp;ptlrpc_all_services_mutex);
<a name="l00807"></a>00807 
<a name="l00808"></a>00808         <span class="keywordflow">if</span> (proc_entry != NULL)
<a name="l00809"></a>00809                 ptlrpc_lprocfs_register_service(proc_entry, service);
<a name="l00810"></a>00810 
<a name="l00811"></a>00811         rc = ptlrpc_service_nrs_setup(service);
<a name="l00812"></a>00812         <span class="keywordflow">if</span> (rc != 0)
<a name="l00813"></a>00813                 GOTO(failed, rc);
<a name="l00814"></a>00814 
<a name="l00815"></a>00815         CDEBUG(D_NET, <span class="stringliteral">&quot;%s: Started, listening on portal %d\n&quot;</span>,
<a name="l00816"></a>00816                service-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, service-&gt;<a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>);
<a name="l00817"></a>00817 
<a name="l00818"></a>00818         rc = ptlrpc_start_threads(service);
<a name="l00819"></a>00819         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00820"></a>00820                 CERROR(<span class="stringliteral">&quot;Failed to start threads for service %s: %d\n&quot;</span>,
<a name="l00821"></a>00821                        service-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, rc);
<a name="l00822"></a>00822                 GOTO(failed, rc);
<a name="l00823"></a>00823         }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         RETURN(service);
<a name="l00826"></a>00826 failed:
<a name="l00827"></a>00827         ptlrpc_unregister_service(service);
<a name="l00828"></a>00828         RETURN(ERR_PTR(rc));
<a name="l00829"></a>00829 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga13835bf69545de9744051ff7ef02a4c3_cgraph.png" border="0" usemap="#group__net_ga13835bf69545de9744051ff7ef02a4c3_cgraph_map" alt=""></div>
<map name="group__net_ga13835bf69545de9744051ff7ef02a4c3_cgraph_map" id="group__net_ga13835bf69545de9744051ff7ef02a4c3_cgraph">
<area shape="rect" id="node3" href="group__lnet__misc.html#ga1986737ae4fa6d8756708df641f024e3" title="Turn on the lazy portal attribute." alt="" coords="232,5,384,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gafd4a53f20e90893d5ae03f1996ecb2fc"></a><!-- doxytag: member="lustre_net.h::ptlrpc_replay_req" ref="gafd4a53f20e90893d5ae03f1996ecb2fc" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_replay_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares and queues request for replay. </p>
<p>Adds it to ptlrpcd queue for actual sending. Returns 0 on success. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l03006">3006</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="lustre__import_8h_source.html#l00224">obd_import::imp_replay_inflight</a>, <a class="el" href="lustre__import_8h_source.html#l00230">obd_import::imp_state</a>, <a class="el" href="client_8c_source.html#l00293">ptlrpc_at_set_req_timeout()</a>, <a class="el" href="client_8c_source.html#l02757">ptlrpc_request_addref()</a>, <a class="el" href="ptlrpcd_8c_source.html#l00268">ptlrpcd_add_req()</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01011">ptlrpc_request::rq_next_phase</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, and <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l03007"></a>03007 {
<a name="l03008"></a>03008         <span class="keyword">struct </span><a class="code" href="structptlrpc__replay__async__args.html">ptlrpc_replay_async_args</a> *aa;
<a name="l03009"></a>03009         ENTRY;
<a name="l03010"></a>03010 
<a name="l03011"></a>03011         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_REPLAY);
<a name="l03012"></a>03012 
<a name="l03013"></a>03013         LASSERT (<span class="keyword">sizeof</span> (*aa) &lt;= <span class="keyword">sizeof</span> (req-&gt;rq_async_args));
<a name="l03014"></a>03014         aa = ptlrpc_req_async_args(req);
<a name="l03015"></a>03015         memset(aa, 0, <span class="keyword">sizeof</span> *aa);
<a name="l03016"></a>03016 
<a name="l03017"></a>03017         <span class="comment">/* Prepare request to be resent with ptlrpcd */</span>
<a name="l03018"></a>03018         aa-&gt;praa_old_state = req-&gt;rq_send_state;
<a name="l03019"></a>03019         req-&gt;rq_send_state = LUSTRE_IMP_REPLAY;
<a name="l03020"></a>03020         req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> = RQ_PHASE_NEW;
<a name="l03021"></a>03021         req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a> = RQ_PHASE_UNDEFINED;
<a name="l03022"></a>03022         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>)
<a name="l03023"></a>03023                 aa-&gt;praa_old_status = lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l03024"></a>03024         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = 0;
<a name="l03025"></a>03025         req-&gt;rq_interpret_reply = ptlrpc_replay_interpret;
<a name="l03026"></a>03026         <span class="comment">/* Readjust the timeout for current conditions */</span>
<a name="l03027"></a>03027         <a class="code" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e.">ptlrpc_at_set_req_timeout</a>(req);
<a name="l03028"></a>03028 
<a name="l03029"></a>03029         <span class="comment">/* Tell server the net_latency, so the server can calculate how long</span>
<a name="l03030"></a>03030 <span class="comment">         * it should wait for next replay */</span>
<a name="l03031"></a>03031         lustre_msg_set_service_time(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>,
<a name="l03032"></a>03032                                     ptlrpc_at_get_net_latency(req));
<a name="l03033"></a>03033         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;REPLAY&quot;</span>);
<a name="l03034"></a>03034 
<a name="l03035"></a>03035         atomic_inc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a128f8537a5590b089f0b0155f80674ab" title="Number of replay requests inflight.">imp_replay_inflight</a>);
<a name="l03036"></a>03036         <a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>(req);     <span class="comment">/* ptlrpcd needs a ref */</span>
<a name="l03037"></a>03037 
<a name="l03038"></a>03038         <a class="code" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check-&amp;gt;ptlrpc_check_set()...">ptlrpcd_add_req</a>(req);
<a name="l03039"></a>03039         RETURN(0);
<a name="l03040"></a>03040 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gafd4a53f20e90893d5ae03f1996ecb2fc_cgraph.png" border="0" usemap="#group__net_gafd4a53f20e90893d5ae03f1996ecb2fc_cgraph_map" alt=""></div>
<map name="group__net_gafd4a53f20e90893d5ae03f1996ecb2fc_cgraph_map" id="group__net_gafd4a53f20e90893d5ae03f1996ecb2fc_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e." alt="" coords="193,5,396,35"/><area shape="rect" id="node5" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req." alt="" coords="209,59,380,88"/><area shape="rect" id="node7" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check&#45;&gt;ptlrpc_check_set()..." alt="" coords="231,112,359,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gac030d75f1b39211b69e4974fc328669d"></a><!-- doxytag: member="lustre_net.h::ptlrpc_req_finished_with_imp_lock" ref="gac030d75f1b39211b69e4974fc328669d" args="(struct ptlrpc_request *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_req_finished_with_imp_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>request</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drop one request reference. </p>
<p>Must be called with import imp_lock held. When reference count drops to zero, request is freed. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02451">2451</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, and <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02452"></a>02452 {
<a name="l02453"></a>02453         assert_spin_locked(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02454"></a>02454         (void)__ptlrpc_req_finished(request, 1);
<a name="l02455"></a>02455 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac578ffdc47c9c2141c34c4798a55cce4"></a><!-- doxytag: member="lustre_net.h::ptlrpc_request_alloc_pack" ref="gac578ffdc47c9c2141c34c4798a55cce4" args="(struct obd_import *imp, const struct req_format *format, __u32 version, int opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a>* ptlrpc_request_alloc_pack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct req_format *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate new request for operatione <em>opcode</em> and immediatelly pack it for <a class="el" href="structnetwork.html">network</a> transfer. </p>
<p>Only used for simple requests like OBD_PING where the only important part of the request is operation itself. Returns allocated request or NULL on error. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00891">891</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l00852">ptlrpc_request_alloc()</a>, <a class="el" href="client_8c_source.html#l00875">ptlrpc_request_free()</a>, and <a class="el" href="client_8c_source.html#l00762">ptlrpc_request_pack()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00869">ldlm_cli_enqueue()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00894"></a>00894 {
<a name="l00895"></a>00895         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = <a class="code" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure...">ptlrpc_request_alloc</a>(imp, format);
<a name="l00896"></a>00896         <span class="keywordtype">int</span>                    rc;
<a name="l00897"></a>00897 
<a name="l00898"></a>00898         <span class="keywordflow">if</span> (req) {
<a name="l00899"></a>00899                 rc = <a class="code" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps...">ptlrpc_request_pack</a>(req, version, opcode);
<a name="l00900"></a>00900                 <span class="keywordflow">if</span> (rc) {
<a name="l00901"></a>00901                         <a class="code" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure.">ptlrpc_request_free</a>(req);
<a name="l00902"></a>00902                         req = NULL;
<a name="l00903"></a>00903                 }
<a name="l00904"></a>00904         }
<a name="l00905"></a>00905         <span class="keywordflow">return</span> req;
<a name="l00906"></a>00906 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gac578ffdc47c9c2141c34c4798a55cce4_cgraph.png" border="0" usemap="#group__net_gac578ffdc47c9c2141c34c4798a55cce4_cgraph_map" alt=""></div>
<map name="group__net_gac578ffdc47c9c2141c34c4798a55cce4_cgraph_map" id="group__net_gac578ffdc47c9c2141c34c4798a55cce4_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure..." alt="" coords="252,5,409,35"/><area shape="rect" id="node5" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure." alt="" coords="253,59,408,88"/><area shape="rect" id="node7" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps..." alt="" coords="252,112,409,141"/><area shape="rect" id="node9" href="group__req__layout.html#gaf42efe506903884592711902e9276e99" title="This function shrinks the size of the _buffer_ of the pill&#39;s PTLRPC request or..." alt="" coords="459,112,605,141"/><area shape="rect" id="node11" href="group__net.html#ga8ddfe4bfdb34b2159b8281fb3c6e09a4" title="lustre_msg_buflen &#45; return the length of buffer n in message m " alt="" coords="680,59,824,88"/><area shape="rect" id="node13" href="group__req__layout.html#gad281812fde0bdb0aaaed8a022e0008f2" title="Returns a non&#45;zero value if the given field is present in the given pill&#39;s PTLRPC..." alt="" coords="653,112,851,141"/><area shape="rect" id="node15" href="group__req__layout.html#ga35302dbfc2517d692579948a9742d3ba" title="This function returns a non&#45;zero value if the given field is present in the format..." alt="" coords="900,139,1065,168"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gac578ffdc47c9c2141c34c4798a55cce4_icgraph.png" border="0" usemap="#group__net_gac578ffdc47c9c2141c34c4798a55cce4_icgraph_map" alt=""></div>
<map name="group__net_gac578ffdc47c9c2141c34c4798a55cce4_icgraph_map" id="group__net_gac578ffdc47c9c2141c34c4798a55cce4_icgraph">
<area shape="rect" id="node3" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="251,5,387,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gacab48d448ba12ade8093383e054814cc"></a><!-- doxytag: member="lustre_net.h::ptlrpc_request_committed" ref="gacab48d448ba12ade8093383e054814cc" args="(struct ptlrpc_request *req, int force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_request_committed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>force</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Client-side portals API. </p>
<p>Everything to send requests, receive replies, request queues, request management, etc. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02601">2601</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00248">obd_import::imp_peer_committed_transno</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01045">ptlrpc_request::rq_replay_list</a>, and <a class="el" href="lustre__net_8h_source.html#l01034">ptlrpc_request::rq_transno</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02602"></a>02602 {
<a name="l02603"></a>02603         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a>       *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l02604"></a>02604 
<a name="l02605"></a>02605         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02606"></a>02606         <span class="keywordflow">if</span> (list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>)) {
<a name="l02607"></a>02607                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02608"></a>02608                 <span class="keywordflow">return</span>;
<a name="l02609"></a>02609         }
<a name="l02610"></a>02610 
<a name="l02611"></a>02611         <span class="keywordflow">if</span> (force || req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> &lt;= imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>)
<a name="l02612"></a>02612                 ptlrpc_free_request(req);
<a name="l02613"></a>02613 
<a name="l02614"></a>02614         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02615"></a>02615 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga35e91945e5dfe7314c1b31519907929f"></a><!-- doxytag: member="lustre_net.h::ptlrpc_request_free" ref="ga35e91945e5dfe7314c1b31519907929f" args="(struct ptlrpc_request *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_request_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>request</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For requests not from pool, free memory of the request structure. </p>
<p>For requests obtained from a pool earlier, return request back to pool. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00875">875</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01028">ptlrpc_request::rq_pool</a>.</p>

<p>Referenced by <a class="el" href="pack__generic_8c_source.html#l01574">do_set_info_async()</a>, <a class="el" href="ldlm__request_8c_source.html#l01185">ldlm_cli_cancel_req()</a>, <a class="el" href="import_8c_source.html#l00648">ptlrpc_connect_import()</a>, and <a class="el" href="client_8c_source.html#l00891">ptlrpc_request_alloc_pack()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00876"></a>00876 {
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a>)
<a name="l00878"></a>00878                 __ptlrpc_free_req_to_pool(request);
<a name="l00879"></a>00879         <span class="keywordflow">else</span>
<a name="l00880"></a>00880                 ptlrpc_request_cache_free(request);
<a name="l00881"></a>00881 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga35e91945e5dfe7314c1b31519907929f_icgraph.png" border="0" usemap="#group__net_ga35e91945e5dfe7314c1b31519907929f_icgraph_map" alt=""></div>
<map name="group__net_ga35e91945e5dfe7314c1b31519907929f_icgraph_map" id="group__net_ga35e91945e5dfe7314c1b31519907929f_icgraph">
<area shape="rect" id="node3" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="237,56,381,85"/><area shape="rect" id="node5" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="235,109,384,139"/><area shape="rect" id="node27" href="group__net.html#gae524031a54066bf23dda2ad572bbcfdf" title="Attempt to (re)connect import imp." alt="" coords="223,163,396,192"/><area shape="rect" id="node29" href="group__net.html#gac578ffdc47c9c2141c34c4798a55cce4" title="Allocate new request for operatione opcode and immediatelly pack it for network transfer..." alt="" coords="212,216,407,245"/><area shape="rect" id="node7" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="457,109,604,139"/><area shape="rect" id="node9" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="687,29,807,59"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="655,83,839,112"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1139,108,1381,137"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="676,187,817,216"/><area shape="rect" id="node11" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="889,29,1089,59"/><area shape="rect" id="node13" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1191,29,1329,59"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="888,83,1091,112"/><area shape="rect" id="node22" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1429,108,1605,137"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="463,216,599,245"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga74e4777d34c1f5305c03de9d365a6268"></a><!-- doxytag: member="lustre_net.h::ptlrpc_retain_replayable_request" ref="ga74e4777d34c1f5305c03de9d365a6268" args="(struct ptlrpc_request *req, struct obd_import *imp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_retain_replayable_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a request to import replay_list. </p>
<p>Must be called under imp_lock </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02769">2769</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00183">obd_import::imp_replay_list</a>, <a class="el" href="client_8c_source.html#l02757">ptlrpc_request_addref()</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01045">ptlrpc_request::rq_replay_list</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01034">ptlrpc_request::rq_transno</a>, and <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02771"></a>02771 {
<a name="l02772"></a>02772         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp;
<a name="l02773"></a>02773 
<a name="l02774"></a>02774         assert_spin_locked(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02775"></a>02775 
<a name="l02776"></a>02776         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> == 0) {
<a name="l02777"></a>02777                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_EMERG, req, <span class="stringliteral">&quot;saving request with zero transno&quot;</span>);
<a name="l02778"></a>02778                 LBUG();
<a name="l02779"></a>02779         }
<a name="l02780"></a>02780 
<a name="l02781"></a>02781         <span class="comment">/* clear this for new requests that were resent as well</span>
<a name="l02782"></a>02782 <span class="comment">           as resent replayed requests. */</span>
<a name="l02783"></a>02783         lustre_msg_clear_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, MSG_RESENT);
<a name="l02784"></a>02784 
<a name="l02785"></a>02785         <span class="comment">/* don&apos;t re-add requests that have been replayed */</span>
<a name="l02786"></a>02786         <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>))
<a name="l02787"></a>02787                 <span class="keywordflow">return</span>;
<a name="l02788"></a>02788 
<a name="l02789"></a>02789         lustre_msg_add_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, MSG_REPLAY);
<a name="l02790"></a>02790 
<a name="l02791"></a>02791         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02792"></a>02792         req-&gt;rq_resend = 0;
<a name="l02793"></a>02793         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02794"></a>02794 
<a name="l02795"></a>02795         LASSERT(imp-&gt;imp_replayable);
<a name="l02796"></a>02796         <span class="comment">/* Balanced in ptlrpc_free_committed, usually. */</span>
<a name="l02797"></a>02797         <a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>(req);
<a name="l02798"></a>02798         list_for_each_prev(tmp, &amp;imp-&gt;<a class="code" href="structobd__import.html#ae3f32574c5a9b068001d451c8506ef7b" title="Lists of requests that are retained for replay, waiting for a reply, or waiting for...">imp_replay_list</a>) {
<a name="l02799"></a>02799                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *iter = list_entry(tmp,
<a name="l02800"></a>02800                                                          <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l02801"></a>02801                                                          <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>);
<a name="l02802"></a>02802 
<a name="l02803"></a>02803                 <span class="comment">/* We may have duplicate transnos if we create and then</span>
<a name="l02804"></a>02804 <span class="comment">                 * open a file, or for closes retained if to match creating</span>
<a name="l02805"></a>02805 <span class="comment">                 * opens, so use req-&gt;rq_xid as a secondary key.</span>
<a name="l02806"></a>02806 <span class="comment">                 * (See bugs 684, 685, and 428.)</span>
<a name="l02807"></a>02807 <span class="comment">                 * XXX no longer needed, but all opens need transnos!</span>
<a name="l02808"></a>02808 <span class="comment">                 */</span>
<a name="l02809"></a>02809                 <span class="keywordflow">if</span> (iter-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> &gt; req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a>)
<a name="l02810"></a>02810                         <span class="keywordflow">continue</span>;
<a name="l02811"></a>02811 
<a name="l02812"></a>02812                 <span class="keywordflow">if</span> (iter-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> == req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a>) {
<a name="l02813"></a>02813                         LASSERT(iter-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> != req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l02814"></a>02814                         <span class="keywordflow">if</span> (iter-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> &gt; req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>)
<a name="l02815"></a>02815                                 <span class="keywordflow">continue</span>;
<a name="l02816"></a>02816                 }
<a name="l02817"></a>02817 
<a name="l02818"></a>02818                 list_add(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>, &amp;iter-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>);
<a name="l02819"></a>02819                 <span class="keywordflow">return</span>;
<a name="l02820"></a>02820         }
<a name="l02821"></a>02821 
<a name="l02822"></a>02822         list_add(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>, &amp;imp-&gt;<a class="code" href="structobd__import.html#ae3f32574c5a9b068001d451c8506ef7b" title="Lists of requests that are retained for replay, waiting for a reply, or waiting for...">imp_replay_list</a>);
<a name="l02823"></a>02823 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga74e4777d34c1f5305c03de9d365a6268_cgraph.png" border="0" usemap="#group__net_ga74e4777d34c1f5305c03de9d365a6268_cgraph_map" alt=""></div>
<map name="group__net_ga74e4777d34c1f5305c03de9d365a6268_cgraph_map" id="group__net_ga74e4777d34c1f5305c03de9d365a6268_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req." alt="" coords="299,5,469,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gac08edd7ffd185c9f01d010fa5da16fd3"></a><!-- doxytag: member="lustre_net.h::ptlrpc_sample_next_xid" ref="gac08edd7ffd185c9f01d010fa5da16fd3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__u64 ptlrpc_sample_next_xid </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a glimpse at what next xid value might have been. </p>
<p>Returns possible next xid. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l03230">3230</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l03231"></a>03231 {
<a name="l03232"></a>03232 <span class="preprocessor">#if BITS_PER_LONG == 32</span>
<a name="l03233"></a>03233 <span class="preprocessor"></span>        <span class="comment">/* need to avoid possible word tearing on 32-bit systems */</span>
<a name="l03234"></a>03234         __u64 next;
<a name="l03235"></a>03235 
<a name="l03236"></a>03236         spin_lock(&amp;ptlrpc_last_xid_lock);
<a name="l03237"></a>03237         next = ptlrpc_last_xid + PTLRPC_BULK_OPS_COUNT;
<a name="l03238"></a>03238         spin_unlock(&amp;ptlrpc_last_xid_lock);
<a name="l03239"></a>03239 
<a name="l03240"></a>03240         <span class="keywordflow">return</span> next;
<a name="l03241"></a>03241 <span class="preprocessor">#else</span>
<a name="l03242"></a>03242 <span class="preprocessor"></span>        <span class="comment">/* No need to lock, since returned value is racy anyways */</span>
<a name="l03243"></a>03243         <span class="keywordflow">return</span> ptlrpc_last_xid + PTLRPC_BULK_OPS_COUNT;
<a name="l03244"></a>03244 <span class="preprocessor">#endif</span>
<a name="l03245"></a>03245 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga686ce1d3f4b5ce9b59e59136cb6b265c"></a><!-- doxytag: member="lustre_net.h::ptlrpc_save_lock" ref="ga686ce1d3f4b5ce9b59e59136cb6b265c" args="(struct ptlrpc_request *req, struct lustre_handle *lock, int mode, int no_ack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_save_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>no_ack</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Server-side services API. </p>
<p>Register/unregister service, request state management, service thread management</p>
<p>Server-side services API.</p>
<p>Puts a lock and its mode into reply state assotiated to request reply. </p>

<p>Definition at line <a class="el" href="service_8c_source.html#l00183">183</a> of file <a class="el" href="service_8c_source.html">service.c</a>.</p>

<p>References <a class="el" href="ldlm__lock_8c_source.html#l00903">ldlm_lock_decref()</a>, <a class="el" href="lustre__net_8h_source.html#l01102">ptlrpc_request::rq_export</a>, <a class="el" href="lustre__net_8h_source.html#l00664">ptlrpc_reply_state::rs_difficult</a>, <a class="el" href="lustre__net_8h_source.html#l00708">ptlrpc_reply_state::rs_locks</a>, <a class="el" href="lustre__net_8h_source.html#l00639">RS_MAX_LOCKS</a>, <a class="el" href="lustre__net_8h_source.html#l00710">ptlrpc_reply_state::rs_modes</a>, and <a class="el" href="lustre__net_8h_source.html#l00677">ptlrpc_reply_state::rs_nlocks</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00185"></a>00185 {
<a name="l00186"></a>00186         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs = req-&gt;rq_reply_state;
<a name="l00187"></a>00187         <span class="keywordtype">int</span>                        idx;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         LASSERT(rs != NULL);
<a name="l00190"></a>00190         LASSERT(rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a971c2d968f9044adfbb3361f6d938e51" title="Number of locks awaiting client ACK.">rs_nlocks</a> &lt; <a class="code" href="group__net.html#ga2d55f86d607f2386cec08e37daa7ce67" title="Maximum number of locks to fit into reply state.">RS_MAX_LOCKS</a>);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;exp_disconnected) {
<a name="l00193"></a>00193                 <a class="code" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref</a>(lock, mode);
<a name="l00194"></a>00194         } <span class="keywordflow">else</span> {
<a name="l00195"></a>00195                 idx = rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a971c2d968f9044adfbb3361f6d938e51" title="Number of locks awaiting client ACK.">rs_nlocks</a>++;
<a name="l00196"></a>00196                 rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a610b2cfcd3f4e63424d0d21e3faadb63" title="Handles of locks awaiting client reply ACK.">rs_locks</a>[idx] = *lock;
<a name="l00197"></a>00197                 rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ad8efd2c38ee66e40822759cd3d7255fe" title="Lock modes of locks in rs_locks.">rs_modes</a>[idx] = mode;
<a name="l00198"></a>00198                 rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a053119600f608d97cd028b4e145772f2" title="Reply state flags.">rs_difficult</a> = 1;
<a name="l00199"></a>00199                 rs-&gt;rs_no_ack = !!no_ack;
<a name="l00200"></a>00200         }
<a name="l00201"></a>00201 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga686ce1d3f4b5ce9b59e59136cb6b265c_cgraph.png" border="0" usemap="#group__net_ga686ce1d3f4b5ce9b59e59136cb6b265c_cgraph_map" alt=""></div>
<map name="group__net_ga686ce1d3f4b5ce9b59e59136cb6b265c_cgraph_map" id="group__net_ga686ce1d3f4b5ce9b59e59136cb6b265c_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh." alt="" coords="187,32,320,61"/><area shape="rect" id="node5" href="group__LDLM.html#gabac2ce09f8215c4f05a3a8113fa72545" title="Obtain a lock reference by handle." alt="" coords="369,32,516,61"/><area shape="rect" id="node7" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="575,5,713,35"/><area shape="rect" id="node9" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="567,59,721,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gac2a8de93c376592370228d10fd94761d"></a><!-- doxytag: member="lustre_net.h::ptlrpc_send_error" ref="gac2a8de93c376592370228d10fd94761d" args="(struct ptlrpc_request *req, int difficult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_send_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>may_be_difficult</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For request <em>req</em> send an error reply back. </p>
<p>Create empty reply buffers if necessary. </p>

<p>Definition at line <a class="el" href="niobuf_8c_source.html#l00626">626</a> of file <a class="el" href="niobuf_8c_source.html">niobuf.c</a>.</p>

<p>References <a class="el" href="niobuf_8c_source.html#l00528">ptlrpc_send_reply()</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, and <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00627"></a>00627 {
<a name="l00628"></a>00628         <span class="keywordtype">int</span> rc;
<a name="l00629"></a>00629         ENTRY;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631         <span class="keywordflow">if</span> (req-&gt;rq_no_reply)
<a name="l00632"></a>00632                 RETURN(0);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634         <span class="keywordflow">if</span> (!req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) {
<a name="l00635"></a>00635                 rc = lustre_pack_reply(req, 1, NULL, NULL);
<a name="l00636"></a>00636                 <span class="keywordflow">if</span> (rc)
<a name="l00637"></a>00637                         RETURN(rc);
<a name="l00638"></a>00638         }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != -ENOSPC &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != -EACCES &amp;&amp;
<a name="l00641"></a>00641             req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != -EPERM &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != -ENOENT &amp;&amp;
<a name="l00642"></a>00642             req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != -EINPROGRESS &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != -EDQUOT)
<a name="l00643"></a>00643                 req-&gt;rq_type = PTL_RPC_MSG_ERR;
<a name="l00644"></a>00644 
<a name="l00645"></a>00645         rc = <a class="code" href="group__net.html#ga563a5d436790759334ba2a51f0dce12e" title="Send request reply from request req reply buffer.">ptlrpc_send_reply</a>(req, may_be_difficult);
<a name="l00646"></a>00646         RETURN(rc);
<a name="l00647"></a>00647 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gac2a8de93c376592370228d10fd94761d_cgraph.png" border="0" usemap="#group__net_gac2a8de93c376592370228d10fd94761d_cgraph_map" alt=""></div>
<map name="group__net_gac2a8de93c376592370228d10fd94761d_cgraph_map" id="group__net_gac2a8de93c376592370228d10fd94761d_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga563a5d436790759334ba2a51f0dce12e" title="Send request reply from request req reply buffer." alt="" coords="193,32,332,61"/><area shape="rect" id="node5" href="group__sptlrpc.html#gaa36445bb3135100651ecb584e151f3cb" title="Used by ptlrpc server, to perform transformation upon reply message." alt="" coords="383,5,559,35"/><area shape="rect" id="node7" href="group__lib.html#gafdb6e70a2f301ef0c9e594f8871d9b40" title="Packs current SLV and Limit into req." alt="" coords="381,59,560,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga563a5d436790759334ba2a51f0dce12e"></a><!-- doxytag: member="lustre_net.h::ptlrpc_send_reply" ref="ga563a5d436790759334ba2a51f0dce12e" args="(struct ptlrpc_request *req, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_send_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send request reply from request <em>req</em> reply buffer. </p>
<p><em>flags</em> defines reply types Returns 0 on success or error code </p>

<p>Definition at line <a class="el" href="niobuf_8c_source.html#l00528">528</a> of file <a class="el" href="niobuf_8c_source.html">niobuf.c</a>.</p>

<p>References <a class="el" href="lustre__export_8h_source.html#l00217">obd_export::exp_connection</a>, <a class="el" href="lustre__export_8h_source.html#l00209">obd_export::exp_obd</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00645">LNET_ACK_REQ</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00647">LNET_NOACK_REQ</a>, <a class="el" href="lustre__net_8h_source.html#l01102">ptlrpc_request::rq_export</a>, <a class="el" href="lustre__net_8h_source.html#l01108">ptlrpc_request::rq_peer</a>, <a class="el" href="lustre__net_8h_source.html#l01026">ptlrpc_request::rq_replen</a>, <a class="el" href="lustre__net_8h_source.html#l01092">ptlrpc_request::rq_reply_off</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01079">ptlrpc_request::rq_reqbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01106">ptlrpc_request::rq_self</a>, <a class="el" href="lustre__net_8h_source.html#l01117">ptlrpc_request::rq_sent</a>, <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>, <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>, <a class="el" href="lustre__net_8h_source.html#l00651">ptlrpc_reply_state::rs_cb_id</a>, <a class="el" href="lustre__net_8h_source.html#l00664">ptlrpc_reply_state::rs_difficult</a>, <a class="el" href="lustre__net_8h_source.html#l00690">ptlrpc_reply_state::rs_md_h</a>, <a class="el" href="lustre__net_8h_source.html#l00705">ptlrpc_reply_state::rs_msg</a>, <a class="el" href="lustre__net_8h_source.html#l00695">ptlrpc_reply_state::rs_repbuf</a>, <a class="el" href="lustre__net_8h_source.html#l00699">ptlrpc_reply_state::rs_repdata_len</a>, <a class="el" href="sec_8c_source.html#l02180">sptlrpc_svc_wrap_reply()</a>, and <a class="el" href="ldlm__lib_8c_source.html#l02810">target_pack_pool_reply()</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00626">ptlrpc_send_error()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00529"></a>00529 {
<a name="l00530"></a>00530         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs = req-&gt;rq_reply_state;
<a name="l00531"></a>00531         <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a>  *conn;
<a name="l00532"></a>00532         <span class="keywordtype">int</span>                        rc;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         <span class="comment">/* We must already have a reply buffer (only ptlrpc_error() may be</span>
<a name="l00535"></a>00535 <span class="comment">         * called without one). The reply generated by sptlrpc layer (e.g.</span>
<a name="l00536"></a>00536 <span class="comment">         * error notify, etc.) might have NULL rq-&gt;reqmsg; Otherwise we must</span>
<a name="l00537"></a>00537 <span class="comment">         * have a request buffer which is either the actual (swabbed) incoming</span>
<a name="l00538"></a>00538 <span class="comment">         * request, or a saved copy if this is a req saved in</span>
<a name="l00539"></a>00539 <span class="comment">         * target_queue_final_reply().</span>
<a name="l00540"></a>00540 <span class="comment">         */</span>
<a name="l00541"></a>00541         LASSERT (req-&gt;rq_no_reply == 0);
<a name="l00542"></a>00542         LASSERT (req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> != NULL);
<a name="l00543"></a>00543         LASSERT (rs != NULL);
<a name="l00544"></a>00544         LASSERT ((flags &amp; PTLRPC_REPLY_MAYBE_DIFFICULT) || !rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a053119600f608d97cd028b4e145772f2" title="Reply state flags.">rs_difficult</a>);
<a name="l00545"></a>00545         LASSERT (req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> != NULL);
<a name="l00546"></a>00546         LASSERT (req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> == rs-&gt;<a class="code" href="structptlrpc__reply__state.html#af08fd77ced5fd2bf1db68fb9191f3701" title="Actual reply message.">rs_msg</a>);
<a name="l00547"></a>00547         LASSERT (rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a822cfc83a489857d3511fc0bb49de345" title="Callback description.">rs_cb_id</a>.cbid_fn == reply_out_callback);
<a name="l00548"></a>00548         LASSERT (rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a822cfc83a489857d3511fc0bb49de345" title="Callback description.">rs_cb_id</a>.cbid_arg == rs);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550         <span class="comment">/* There may be no rq_export during failover */</span>
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         <span class="keywordflow">if</span> (unlikely(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a> &amp;&amp;
<a name="l00553"></a>00553                      req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_fail)) {
<a name="l00554"></a>00554                 <span class="comment">/* Failed obd&apos;s only send ENODEV */</span>
<a name="l00555"></a>00555                 req-&gt;rq_type = PTL_RPC_MSG_ERR;
<a name="l00556"></a>00556                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -ENODEV;
<a name="l00557"></a>00557                 CDEBUG(D_HA, <span class="stringliteral">&quot;sending ENODEV from failed obd %d\n&quot;</span>,
<a name="l00558"></a>00558                        req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_minor);
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         <span class="comment">/* In order to keep interoprability with the client (&lt; 2.3) which</span>
<a name="l00562"></a>00562 <span class="comment">         * doesn&apos;t have pb_jobid in ptlrpc_body, We have to shrink the</span>
<a name="l00563"></a>00563 <span class="comment">         * ptlrpc_body in reply buffer to ptlrpc_body_v2, otherwise, the</span>
<a name="l00564"></a>00564 <span class="comment">         * reply buffer on client will be overflow.</span>
<a name="l00565"></a>00565 <span class="comment">         *</span>
<a name="l00566"></a>00566 <span class="comment">         * XXX Remove this whenver we drop the interoprability with such client.</span>
<a name="l00567"></a>00567 <span class="comment">         */</span>
<a name="l00568"></a>00568         req-&gt;<a class="code" href="structptlrpc__request.html#aaa9ba7e7b71ad2057d1650469ab15076" title="Reply length.">rq_replen</a> = lustre_shrink_msg(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>, 0,
<a name="l00569"></a>00569                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__body__v2.html">ptlrpc_body_v2</a>), 1);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571         <span class="keywordflow">if</span> (req-&gt;rq_type != PTL_RPC_MSG_ERR)
<a name="l00572"></a>00572                 req-&gt;rq_type = PTL_RPC_MSG_REPLY;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574         lustre_msg_set_type(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>, req-&gt;rq_type);
<a name="l00575"></a>00575         lustre_msg_set_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>,
<a name="l00576"></a>00576                               ptlrpc_status_hton(req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>));
<a name="l00577"></a>00577         lustre_msg_set_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>,
<a name="l00578"></a>00578                 req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> ? lustre_msg_get_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) : 0);
<a name="l00579"></a>00579 
<a name="l00580"></a>00580         <a class="code" href="group__lib.html#gafdb6e70a2f301ef0c9e594f8871d9b40" title="Packs current SLV and Limit into req.">target_pack_pool_reply</a>(req);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582         ptlrpc_at_set_reply(req, flags);
<a name="l00583"></a>00583 
<a name="l00584"></a>00584         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> == NULL || req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ae0ed47ab09f5904f1b740d33bd2f27ef" title="Active connetion.">exp_connection</a> == NULL)
<a name="l00585"></a>00585                 conn = ptlrpc_connection_get(req-&gt;<a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>, req-&gt;<a class="code" href="structptlrpc__request.html#a23e7140c61b1569e060509edc7e2727b" title="our LNet NID">rq_self</a>, NULL);
<a name="l00586"></a>00586         <span class="keywordflow">else</span>
<a name="l00587"></a>00587                 conn = ptlrpc_connection_addref(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ae0ed47ab09f5904f1b740d33bd2f27ef" title="Active connetion.">exp_connection</a>);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589         <span class="keywordflow">if</span> (unlikely(conn == NULL)) {
<a name="l00590"></a>00590                 CERROR(<span class="stringliteral">&quot;not replying on NULL connection\n&quot;</span>); <span class="comment">/* bug 9635 */</span>
<a name="l00591"></a>00591                 <span class="keywordflow">return</span> -ENOTCONN;
<a name="l00592"></a>00592         }
<a name="l00593"></a>00593         ptlrpc_rs_addref(rs);                   <span class="comment">/* +1 ref for the network */</span>
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         rc = <a class="code" href="group__sptlrpc.html#gaa36445bb3135100651ecb584e151f3cb" title="Used by ptlrpc server, to perform transformation upon reply message.">sptlrpc_svc_wrap_reply</a>(req);
<a name="l00596"></a>00596         <span class="keywordflow">if</span> (unlikely(rc))
<a name="l00597"></a>00597                 <span class="keywordflow">goto</span> out;
<a name="l00598"></a>00598 
<a name="l00599"></a>00599         req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> = cfs_time_current_sec();
<a name="l00600"></a>00600 
<a name="l00601"></a>00601         rc = ptl_send_buf (&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a48dd3dc9a45264d8875c1508d61a25e8" title="Lnet metadata handle for the reply.">rs_md_h</a>, rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a6c58a6733cf86b062ad1c152fb2a3d53" title="Reply buffer (actually sent to the client), encoded if needed.">rs_repbuf</a>, rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ad8f79dd53c66b683ac2f1906324bf7e3" title="Size of the reply message.">rs_repdata_len</a>,
<a name="l00602"></a>00602                            (rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a053119600f608d97cd028b4e145772f2" title="Reply state flags.">rs_difficult</a> &amp;&amp; !rs-&gt;rs_no_ack) ?
<a name="l00603"></a>00603                            <a class="code" href="group__lnet__data.html#gga7a9fb861289ab6d6f5a555de5a16222dab6ed367929aa2ddaaee1e6027eb0bba6" title="Request an acknowledgment.">LNET_ACK_REQ</a> : <a class="code" href="group__lnet__data.html#gga7a9fb861289ab6d6f5a555de5a16222daf7554f6ed5ff24f4ab2058283eeffc97" title="Request that no acknowledgment should be generated.">LNET_NOACK_REQ</a>,
<a name="l00604"></a>00604                            &amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a822cfc83a489857d3511fc0bb49de345" title="Callback description.">rs_cb_id</a>, conn,
<a name="l00605"></a>00605                            ptlrpc_req2svc(req)-&gt;srv_rep_portal,
<a name="l00606"></a>00606                            req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>, req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a>);
<a name="l00607"></a>00607 out:
<a name="l00608"></a>00608         <span class="keywordflow">if</span> (unlikely(rc != 0))
<a name="l00609"></a>00609                 ptlrpc_req_drop_rs(req);
<a name="l00610"></a>00610         ptlrpc_connection_put(conn);
<a name="l00611"></a>00611         <span class="keywordflow">return</span> rc;
<a name="l00612"></a>00612 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga563a5d436790759334ba2a51f0dce12e_cgraph.png" border="0" usemap="#group__net_ga563a5d436790759334ba2a51f0dce12e_cgraph_map" alt=""></div>
<map name="group__net_ga563a5d436790759334ba2a51f0dce12e_cgraph_map" id="group__net_ga563a5d436790759334ba2a51f0dce12e_cgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#gaa36445bb3135100651ecb584e151f3cb" title="Used by ptlrpc server, to perform transformation upon reply message." alt="" coords="196,5,372,35"/><area shape="rect" id="node5" href="group__lib.html#gafdb6e70a2f301ef0c9e594f8871d9b40" title="Packs current SLV and Limit into req." alt="" coords="195,59,373,88"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga563a5d436790759334ba2a51f0dce12e_icgraph.png" border="0" usemap="#group__net_ga563a5d436790759334ba2a51f0dce12e_icgraph_map" alt=""></div>
<map name="group__net_ga563a5d436790759334ba2a51f0dce12e_icgraph_map" id="group__net_ga563a5d436790759334ba2a51f0dce12e_icgraph">
<area shape="rect" id="node3" href="group__net.html#gac2a8de93c376592370228d10fd94761d" title="For request req send an error reply back." alt="" coords="195,5,333,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga45bbc99a8cb3940b830d5ac581cd2f10"></a><!-- doxytag: member="lustre_net.h::ptlrpc_server_drop_request" ref="ga45bbc99a8cb3940b830d5ac581cd2f10" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_server_drop_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>drop a reference count of the request. </p>
<p>if it reaches 0, we either put it into history list, or free it immediately. </p>

<p>Definition at line <a class="el" href="service_8c_source.html#l00859">859</a> of file <a class="el" href="service_8c_source.html">service.c</a>.</p>

<p>References <a class="el" href="lu__object_8c_source.html#l01786">lu_context_exit()</a>, <a class="el" href="lu__object_8c_source.html#l01755">lu_context_fini()</a>, <a class="el" href="lustre__net_8h_source.html#l01003">ptlrpc_request::rq_at_linked</a>, <a class="el" href="lustre__net_8h_source.html#l01102">ptlrpc_request::rq_export</a>, <a class="el" href="lustre__net_8h_source.html#l00962">ptlrpc_request::rq_list</a>, <a class="el" href="lustre__net_8h_source.html#l01016">ptlrpc_request::rq_refcount</a>, <a class="el" href="lustre__net_8h_source.html#l01606">ptlrpc_request_buffer_desc::rqbd_list</a>, <a class="el" href="lustre__net_8h_source.html#l01621">ptlrpc_request_buffer_desc::rqbd_req</a>, <a class="el" href="lustre__net_8h_source.html#l01608">ptlrpc_request_buffer_desc::rqbd_reqs</a>, <a class="el" href="lustre__net_8h_source.html#l01610">ptlrpc_request_buffer_desc::rqbd_svcpt</a>, <a class="el" href="lustre__net_8h_source.html#l01798">ptlrpc_service_part::scp_hist_nrqbds</a>, <a class="el" href="lustre__net_8h_source.html#l01796">ptlrpc_service_part::scp_hist_rqbds</a>, <a class="el" href="lustre__net_8h_source.html#l01802">ptlrpc_service_part::scp_hist_seq_culled</a>, <a class="el" href="lustre__net_8h_source.html#l01780">ptlrpc_service_part::scp_rqbd_idle</a>, and <a class="el" href="lustre__net_8h_source.html#l01716">ptlrpc_service::srv_hist_nrqbds_cpt_max</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00860"></a>00860 {
<a name="l00861"></a>00861         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *rqbd = req-&gt;rq_rqbd;
<a name="l00862"></a>00862         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>        *svcpt = rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a1e7bb4edc15fbecb9ef0800039fe255e" title="Back pointer to service for which this buffer is registered.">rqbd_svcpt</a>;
<a name="l00863"></a>00863         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>             *svc = svcpt-&gt;scp_service;
<a name="l00864"></a>00864         <span class="keywordtype">int</span>                                refcount;
<a name="l00865"></a>00865         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                          *tmp;
<a name="l00866"></a>00866         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                          *nxt;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868         <span class="keywordflow">if</span> (!atomic_dec_and_test(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>))
<a name="l00869"></a>00869                 <span class="keywordflow">return</span>;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871         <span class="keywordflow">if</span> (req-&gt;rq_session.lc_state == LCS_ENTERED) {
<a name="l00872"></a>00872                 <a class="code" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit</a>(&amp;req-&gt;rq_session);
<a name="l00873"></a>00873                 <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(&amp;req-&gt;rq_session);
<a name="l00874"></a>00874         }
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a9e26278917dfc99ef8c03ce46770d9bf" title="link into service&amp;#39;s srv_at_array">rq_at_linked</a>) {
<a name="l00877"></a>00877                 spin_lock(&amp;svcpt-&gt;scp_at_lock);
<a name="l00878"></a>00878                 <span class="comment">/* recheck with lock, in case it&apos;s unlinked by</span>
<a name="l00879"></a>00879 <span class="comment">                 * ptlrpc_at_check_timed() */</span>
<a name="l00880"></a>00880                 <span class="keywordflow">if</span> (likely(req-&gt;<a class="code" href="structptlrpc__request.html#a9e26278917dfc99ef8c03ce46770d9bf" title="link into service&amp;#39;s srv_at_array">rq_at_linked</a>))
<a name="l00881"></a>00881                         ptlrpc_at_remove_timed(req);
<a name="l00882"></a>00882                 spin_unlock(&amp;svcpt-&gt;scp_at_lock);
<a name="l00883"></a>00883         }
<a name="l00884"></a>00884 
<a name="l00885"></a>00885         LASSERT(list_empty(&amp;req-&gt;rq_timed_list));
<a name="l00886"></a>00886 
<a name="l00887"></a>00887         <span class="comment">/* finalize request */</span>
<a name="l00888"></a>00888         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>) {
<a name="l00889"></a>00889                 class_export_put(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l00890"></a>00890                 req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> = NULL;
<a name="l00891"></a>00891         }
<a name="l00892"></a>00892 
<a name="l00893"></a>00893         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895         list_add(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>, &amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>);
<a name="l00896"></a>00896 
<a name="l00897"></a>00897         refcount = --(rqbd-&gt;rqbd_refcount);
<a name="l00898"></a>00898         <span class="keywordflow">if</span> (refcount == 0) {
<a name="l00899"></a>00899                 <span class="comment">/* request buffer is now idle: add to history */</span>
<a name="l00900"></a>00900                 list_del(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>);
<a name="l00901"></a>00901 
<a name="l00902"></a>00902                 list_add_tail(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aa72950e08d334ab8f1964a2640971efd" title="request buffer history">scp_hist_rqbds</a>);
<a name="l00903"></a>00903                 svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a46f749b9c04d8a939db8e29cbadadb0f" title="# request buffers in history">scp_hist_nrqbds</a>++;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905                 <span class="comment">/* cull some history?</span>
<a name="l00906"></a>00906 <span class="comment">                 * I expect only about 1 or 2 rqbds need to be recycled here */</span>
<a name="l00907"></a>00907                 <span class="keywordflow">while</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a46f749b9c04d8a939db8e29cbadadb0f" title="# request buffers in history">scp_hist_nrqbds</a> &gt; svc-&gt;<a class="code" href="structptlrpc__service.html#ab8c2b2b1eaca9032c565e830244fdfdb" title="max # request buffers in history per partition">srv_hist_nrqbds_cpt_max</a>) {
<a name="l00908"></a>00908                         rqbd = list_entry(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aa72950e08d334ab8f1964a2640971efd" title="request buffer history">scp_hist_rqbds</a>.next,
<a name="l00909"></a>00909                                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a>,
<a name="l00910"></a>00910                                           rqbd_list);
<a name="l00911"></a>00911 
<a name="l00912"></a>00912                         list_del(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>);
<a name="l00913"></a>00913                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a46f749b9c04d8a939db8e29cbadadb0f" title="# request buffers in history">scp_hist_nrqbds</a>--;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915                         <span class="comment">/* remove rqbd&apos;s reqs from svc&apos;s req history while</span>
<a name="l00916"></a>00916 <span class="comment">                         * I&apos;ve got the service lock */</span>
<a name="l00917"></a>00917                         list_for_each(tmp, &amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>) {
<a name="l00918"></a>00918                                 req = list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00919"></a>00919                                                  rq_list);
<a name="l00920"></a>00920                                 <span class="comment">/* Track the highest culled req seq */</span>
<a name="l00921"></a>00921                                 <span class="keywordflow">if</span> (req-&gt;rq_history_seq &gt;
<a name="l00922"></a>00922                                     svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a" title="highest seq culled from history">scp_hist_seq_culled</a>) {
<a name="l00923"></a>00923                                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a" title="highest seq culled from history">scp_hist_seq_culled</a> =
<a name="l00924"></a>00924                                                 req-&gt;rq_history_seq;
<a name="l00925"></a>00925                                 }
<a name="l00926"></a>00926                                 list_del(&amp;req-&gt;rq_history_list);
<a name="l00927"></a>00927                         }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929                         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00930"></a>00930 
<a name="l00931"></a>00931                         list_for_each_safe(tmp, nxt, &amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>) {
<a name="l00932"></a>00932                                 req = list_entry(rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>.next,
<a name="l00933"></a>00933                                                  <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00934"></a>00934                                                  rq_list);
<a name="l00935"></a>00935                                 list_del(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l00936"></a>00936                                 ptlrpc_server_free_request(req);
<a name="l00937"></a>00937                         }
<a name="l00938"></a>00938 
<a name="l00939"></a>00939                         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00940"></a>00940                         <span class="comment">/*</span>
<a name="l00941"></a>00941 <span class="comment">                         * now all reqs including the embedded req has been</span>
<a name="l00942"></a>00942 <span class="comment">                         * disposed, schedule request buffer for re-use.</span>
<a name="l00943"></a>00943 <span class="comment">                         */</span>
<a name="l00944"></a>00944                         LASSERT(atomic_read(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a039d2591d32389c3b0e9c739c33cf263" title="This &amp;quot;embedded&amp;quot; request structure is only used for the last request to...">rqbd_req</a>.<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>) == 0);
<a name="l00945"></a>00945                         list_add_tail(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>);
<a name="l00946"></a>00946                 }
<a name="l00947"></a>00947 
<a name="l00948"></a>00948                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00949"></a>00949         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;rq_reply_state &amp;&amp; req-&gt;rq_reply_state-&gt;rs_prealloc) {
<a name="l00950"></a>00950                 <span class="comment">/* If we are low on memory, we are not interested in history */</span>
<a name="l00951"></a>00951                 list_del(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l00952"></a>00952                 list_del_init(&amp;req-&gt;rq_history_list);
<a name="l00953"></a>00953 
<a name="l00954"></a>00954                 <span class="comment">/* Track the highest culled req seq */</span>
<a name="l00955"></a>00955                 <span class="keywordflow">if</span> (req-&gt;rq_history_seq &gt; svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a" title="highest seq culled from history">scp_hist_seq_culled</a>)
<a name="l00956"></a>00956                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a" title="highest seq culled from history">scp_hist_seq_culled</a> = req-&gt;rq_history_seq;
<a name="l00957"></a>00957 
<a name="l00958"></a>00958                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960                 ptlrpc_server_free_request(req);
<a name="l00961"></a>00961         } <span class="keywordflow">else</span> {
<a name="l00962"></a>00962                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00963"></a>00963         }
<a name="l00964"></a>00964 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga45bbc99a8cb3940b830d5ac581cd2f10_cgraph.png" border="0" usemap="#group__net_ga45bbc99a8cb3940b830d5ac581cd2f10_cgraph_map" alt=""></div>
<map name="group__net_ga45bbc99a8cb3940b830d5ac581cd2f10_cgraph_map" id="group__net_ga45bbc99a8cb3940b830d5ac581cd2f10_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx." alt="" coords="263,5,391,35"/><area shape="rect" id="node5" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data&#45;structure." alt="" coords="267,59,387,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad92b893a7fb440c2f0eed3ce0e79f6af"></a><!-- doxytag: member="lustre_net.h::ptlrpc_set_add_cb" ref="gad92b893a7fb440c2f0eed3ce0e79f6af" args="(struct ptlrpc_request_set *set, set_interpreter_func fn, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_set_add_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set_interpreter_func&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a callback function <em>fn</em> to the set. </p>
<p>This function would be called when all requests on this set are completed. The function will be passed <em>data</em> argument. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l01030">1030</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l00623">ptlrpc_set_cbdata::psc_data</a>, <a class="el" href="lustre__net_8h_source.html#l00621">ptlrpc_set_cbdata::psc_interpret</a>, and <a class="el" href="lustre__net_8h_source.html#l00619">ptlrpc_set_cbdata::psc_item</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01032"></a>01032 {
<a name="l01033"></a>01033         <span class="keyword">struct </span><a class="code" href="structptlrpc__set__cbdata.html" title="Description of a single ptrlrpc_set callback.">ptlrpc_set_cbdata</a> *cbdata;
<a name="l01034"></a>01034 
<a name="l01035"></a>01035         OBD_ALLOC_PTR(cbdata);
<a name="l01036"></a>01036         <span class="keywordflow">if</span> (cbdata == NULL)
<a name="l01037"></a>01037                 RETURN(-ENOMEM);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039         cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#a7122f5f29318e70ed85129a2195bc247" title="Pointer to interpreting function.">psc_interpret</a> = fn;
<a name="l01040"></a>01040         cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#acf9721671bfcc548e1e5fe4276ba9b5c" title="Opaq argument to pass to the callback.">psc_data</a> = data;
<a name="l01041"></a>01041         list_add_tail(&amp;cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#a72f1ec9f7c8e7a2f8ea2e123bf4c0444" title="List linkage item.">psc_item</a>, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#afd915cdca4eee2fd8b0abdbecd520ce3" title="List of completion callbacks to be called when the set is completed This is only...">set_cblist</a>);
<a name="l01042"></a>01042 
<a name="l01043"></a>01043         RETURN(0);
<a name="l01044"></a>01044 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga5da56461932d974b4c2487f179d8e6d8"></a><!-- doxytag: member="lustre_net.h::ptlrpc_set_add_req" ref="ga5da56461932d974b4c2487f179d8e6d8" args="(struct ptlrpc_request_set *, struct ptlrpc_request *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_set_add_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new request to the general purpose request set. </p>
<p>Assumes request reference from the caller. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l01050">1050</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p>Referenced by <a class="el" href="pack__generic_8c_source.html#l01574">do_set_info_async()</a>, and <a class="el" href="client_8c_source.html#l02829">ptlrpc_queue_wait()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01052"></a>01052 {
<a name="l01053"></a>01053         LASSERT(list_empty(&amp;req-&gt;rq_set_chain));
<a name="l01054"></a>01054 
<a name="l01055"></a>01055         <span class="keywordflow">if</span> (req-&gt;rq_allow_intr)
<a name="l01056"></a>01056                 <span class="keyword">set</span>-&gt;set_allow_intr = 1;
<a name="l01057"></a>01057 
<a name="l01058"></a>01058         <span class="comment">/* The set takes over the caller&apos;s request reference */</span>
<a name="l01059"></a>01059         list_add_tail(&amp;req-&gt;rq_set_chain, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>);
<a name="l01060"></a>01060         req-&gt;rq_set = <span class="keyword">set</span>;
<a name="l01061"></a>01061         atomic_inc(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>);
<a name="l01062"></a>01062         req-&gt;rq_queued_time = cfs_time_current();
<a name="l01063"></a>01063 
<a name="l01064"></a>01064         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> != NULL)
<a name="l01065"></a>01065                 lustre_msg_set_jobid(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, NULL);
<a name="l01066"></a>01066 
<a name="l01067"></a>01067         <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structptlrpc__request__set.html#a9be81c226e91f43d9a2b64328b0831a0" title="Callback function used to generate RPCs.">set_producer</a> != NULL)
<a name="l01068"></a>01068                 <span class="comment">/* If the request set has a producer callback, the RPC must be</span>
<a name="l01069"></a>01069 <span class="comment">                 * sent straight away */</span>
<a name="l01070"></a>01070                 ptlrpc_send_new_req(req);
<a name="l01071"></a>01071 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga5da56461932d974b4c2487f179d8e6d8_icgraph.png" border="0" usemap="#group__net_ga5da56461932d974b4c2487f179d8e6d8_icgraph_map" alt=""></div>
<map name="group__net_ga5da56461932d974b4c2487f179d8e6d8_icgraph_map" id="group__net_ga5da56461932d974b4c2487f179d8e6d8_icgraph">
<area shape="rect" id="node3" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="404,56,548,85"/><area shape="rect" id="node5" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="205,109,352,139"/><area shape="rect" id="node8" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="401,109,551,139"/><area shape="rect" id="node30" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="408,163,544,192"/><area shape="rect" id="node10" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="601,109,748,139"/><area shape="rect" id="node12" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="831,29,951,59"/><area shape="rect" id="node19" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="799,83,983,112"/><area shape="rect" id="node23" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1283,108,1525,137"/><area shape="rect" id="node28" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="820,187,961,216"/><area shape="rect" id="node14" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1033,29,1233,59"/><area shape="rect" id="node16" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1335,29,1473,59"/><area shape="rect" id="node21" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1032,83,1235,112"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1573,108,1749,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga862d0349489e1b216f7b1be96ac3baf8"></a><!-- doxytag: member="lustre_net.h::ptlrpc_set_destroy" ref="ga862d0349489e1b216f7b1be96ac3baf8" args="(struct ptlrpc_request_set *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_set_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wind down and free request set structure previously allocated with ptlrpc_prep_set. </p>
<p>Ensures that all requests on the set have completed and removes all requests from the request list in a set. If any unsent request happen to be on the list, pretends that they got an error in flight and calls their completion handler. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l00973">973</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l02490">ptlrpc_req_finished()</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_invalid_rqset</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, and <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02829">ptlrpc_queue_wait()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00974"></a>00974 {
<a name="l00975"></a>00975         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *tmp;
<a name="l00976"></a>00976         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *next;
<a name="l00977"></a>00977         <span class="keywordtype">int</span>                      expected_phase;
<a name="l00978"></a>00978         <span class="keywordtype">int</span>                      n = 0;
<a name="l00979"></a>00979         ENTRY;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981         <span class="comment">/* Requests on the set should either all be completed, or all be new */</span>
<a name="l00982"></a>00982         expected_phase = (atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>) == 0) ?
<a name="l00983"></a>00983                          RQ_PHASE_COMPLETE : RQ_PHASE_NEW;
<a name="l00984"></a>00984         list_for_each(tmp, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>) {
<a name="l00985"></a>00985                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l00986"></a>00986                         list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00987"></a>00987                                    rq_set_chain);
<a name="l00988"></a>00988 
<a name="l00989"></a>00989                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == expected_phase);
<a name="l00990"></a>00990                 n++;
<a name="l00991"></a>00991         }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993         LASSERTF(atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>) == 0 ||
<a name="l00994"></a>00994                  atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>) == n, <span class="stringliteral">&quot;%d / %d\n&quot;</span>,
<a name="l00995"></a>00995                  atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>), n);
<a name="l00996"></a>00996 
<a name="l00997"></a>00997         list_for_each_safe(tmp, next, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>) {
<a name="l00998"></a>00998                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l00999"></a>00999                         list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l01000"></a>01000                                    rq_set_chain);
<a name="l01001"></a>01001                 list_del_init(&amp;req-&gt;rq_set_chain);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == expected_phase);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW) {
<a name="l01006"></a>01006                         ptlrpc_req_interpret(NULL, req, -EBADR);
<a name="l01007"></a>01007                         atomic_dec(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>);
<a name="l01008"></a>01008                 }
<a name="l01009"></a>01009 
<a name="l01010"></a>01010                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01011"></a>01011                 req-&gt;rq_set = NULL;
<a name="l01012"></a>01012                 req-&gt;<a class="code" href="structptlrpc__request.html#a3c7a9c4f0292826fffa36e3ab1cedf47" title="whether the &amp;quot;rq_set&amp;quot; is a valid one">rq_invalid_rqset</a> = 0;
<a name="l01013"></a>01013                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01014"></a>01014 
<a name="l01015"></a>01015                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a> (req);
<a name="l01016"></a>01016         }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018         LASSERT(atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>) == 0);
<a name="l01019"></a>01019 
<a name="l01020"></a>01020         ptlrpc_reqset_put(<span class="keyword">set</span>);
<a name="l01021"></a>01021         EXIT;
<a name="l01022"></a>01022 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga862d0349489e1b216f7b1be96ac3baf8_cgraph.png" border="0" usemap="#group__net_ga862d0349489e1b216f7b1be96ac3baf8_cgraph_map" alt=""></div>
<map name="group__net_ga862d0349489e1b216f7b1be96ac3baf8_cgraph_map" id="group__net_ga862d0349489e1b216f7b1be96ac3baf8_cgraph">
<area shape="rect" id="node3" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request." alt="" coords="207,5,353,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_ga862d0349489e1b216f7b1be96ac3baf8_icgraph.png" border="0" usemap="#group__net_ga862d0349489e1b216f7b1be96ac3baf8_icgraph_map" alt=""></div>
<map name="group__net_ga862d0349489e1b216f7b1be96ac3baf8_icgraph_map" id="group__net_ga862d0349489e1b216f7b1be96ac3baf8_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="205,109,352,139"/><area shape="rect" id="node5" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="404,56,548,85"/><area shape="rect" id="node7" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="401,109,551,139"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="408,163,544,192"/><area shape="rect" id="node9" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="601,109,748,139"/><area shape="rect" id="node11" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="831,29,951,59"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="799,83,983,112"/><area shape="rect" id="node22" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1283,108,1525,137"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="820,187,961,216"/><area shape="rect" id="node13" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1033,29,1233,59"/><area shape="rect" id="node15" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1335,29,1473,59"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1032,83,1235,112"/><area shape="rect" id="node24" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1573,108,1749,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gac072432ff0e3366be99c8456895e28d1"></a><!-- doxytag: member="lustre_net.h::ptlrpc_set_wait" ref="gac072432ff0e3366be99c8456895e28d1" args="(struct ptlrpc_request_set *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_set_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send all unset request from the set and then wait untill all requests in the set complete (either get a reply, timeout, get an error or otherwise be interrupted). </p>
<p>Returns 0 on success or error code otherwise. </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02260">2260</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l00623">ptlrpc_set_cbdata::psc_data</a>, <a class="el" href="lustre__net_8h_source.html#l00621">ptlrpc_set_cbdata::psc_interpret</a>, <a class="el" href="lustre__net_8h_source.html#l00619">ptlrpc_set_cbdata::psc_item</a>, <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_invalid_rqset</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, and <a class="el" href="lustre__net_8h_source.html#l00957">ptlrpc_request::rq_status</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l02829">ptlrpc_queue_wait()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02261"></a>02261 {
<a name="l02262"></a>02262         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>            *tmp;
<a name="l02263"></a>02263         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l02264"></a>02264         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>     lwi;
<a name="l02265"></a>02265         <span class="keywordtype">int</span>                    rc, timeout;
<a name="l02266"></a>02266         ENTRY;
<a name="l02267"></a>02267 
<a name="l02268"></a>02268         <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structptlrpc__request__set.html#a9be81c226e91f43d9a2b64328b0831a0" title="Callback function used to generate RPCs.">set_producer</a>)
<a name="l02269"></a>02269                 (void)ptlrpc_set_producer(<span class="keyword">set</span>);
<a name="l02270"></a>02270         <span class="keywordflow">else</span>
<a name="l02271"></a>02271                 list_for_each(tmp, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>) {
<a name="l02272"></a>02272                         req = list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l02273"></a>02273                                          rq_set_chain);
<a name="l02274"></a>02274                         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW)
<a name="l02275"></a>02275                                 (void)ptlrpc_send_new_req(req);
<a name="l02276"></a>02276                 }
<a name="l02277"></a>02277 
<a name="l02278"></a>02278         <span class="keywordflow">if</span> (list_empty(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>))
<a name="l02279"></a>02279                 RETURN(0);
<a name="l02280"></a>02280 
<a name="l02281"></a>02281         <span class="keywordflow">do</span> {
<a name="l02282"></a>02282                 timeout = ptlrpc_set_next_timeout(<span class="keyword">set</span>);
<a name="l02283"></a>02283 
<a name="l02284"></a>02284                 <span class="comment">/* wait until all complete, interrupted, or an in-flight</span>
<a name="l02285"></a>02285 <span class="comment">                 * req times out */</span>
<a name="l02286"></a>02286                 CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;set %p going to sleep for %d seconds\n&quot;</span>,
<a name="l02287"></a>02287                        <span class="keyword">set</span>, timeout);
<a name="l02288"></a>02288 
<a name="l02289"></a>02289                 <span class="keywordflow">if</span> ((timeout == 0 &amp;&amp; !signal_pending(current)) ||
<a name="l02290"></a>02290                     set-&gt;set_allow_intr)
<a name="l02291"></a>02291                         <span class="comment">/* No requests are in-flight (ether timed out</span>
<a name="l02292"></a>02292 <span class="comment">                         * or delayed), so we can allow interrupts.</span>
<a name="l02293"></a>02293 <span class="comment">                         * We still want to block for a limited time,</span>
<a name="l02294"></a>02294 <span class="comment">                         * so we allow interrupts during the timeout. */</span>
<a name="l02295"></a>02295                         lwi = LWI_TIMEOUT_INTR_ALL(
<a name="l02296"></a>02296                                         cfs_time_seconds(timeout ? timeout : 1),
<a name="l02297"></a>02297                                         ptlrpc_expired_set,
<a name="l02298"></a>02298                                         ptlrpc_interrupted_set, <span class="keyword">set</span>);
<a name="l02299"></a>02299                 <span class="keywordflow">else</span>
<a name="l02300"></a>02300                         <span class="comment">/*</span>
<a name="l02301"></a>02301 <span class="comment">                         * At least one request is in flight, so no</span>
<a name="l02302"></a>02302 <span class="comment">                         * interrupts are allowed. Wait until all</span>
<a name="l02303"></a>02303 <span class="comment">                         * complete, or an in-flight req times out.</span>
<a name="l02304"></a>02304 <span class="comment">                         */</span>
<a name="l02305"></a>02305                         lwi = LWI_TIMEOUT(cfs_time_seconds(timeout? timeout : 1),
<a name="l02306"></a>02306                                           ptlrpc_expired_set, <span class="keyword">set</span>);
<a name="l02307"></a>02307 
<a name="l02308"></a>02308                 rc = l_wait_event(set-&gt;<a class="code" href="structptlrpc__request__set.html#afa37e9803cad75f212925a762a9f6d7b" title="wait queue to wait on for request events">set_waitq</a>, <a class="code" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies...">ptlrpc_check_set</a>(NULL, <span class="keyword">set</span>), &amp;lwi);
<a name="l02309"></a>02309 
<a name="l02310"></a>02310                 <span class="comment">/* LU-769 - if we ignored the signal because it was already</span>
<a name="l02311"></a>02311 <span class="comment">                 * pending when we started, we need to handle it now or we risk</span>
<a name="l02312"></a>02312 <span class="comment">                 * it being ignored forever */</span>
<a name="l02313"></a>02313                 <span class="keywordflow">if</span> (rc == -ETIMEDOUT &amp;&amp;
<a name="l02314"></a>02314                     (!lwi.lwi_allow_intr || set-&gt;set_allow_intr) &amp;&amp;
<a name="l02315"></a>02315                     signal_pending(current)) {
<a name="l02316"></a>02316                         sigset_t blocked_sigs =
<a name="l02317"></a>02317                                            cfs_block_sigsinv(LUSTRE_FATAL_SIGS);
<a name="l02318"></a>02318 
<a name="l02319"></a>02319                         <span class="comment">/* In fact we only interrupt for the &quot;fatal&quot; signals</span>
<a name="l02320"></a>02320 <span class="comment">                         * like SIGINT or SIGKILL. We still ignore less</span>
<a name="l02321"></a>02321 <span class="comment">                         * important signals since ptlrpc set is not easily</span>
<a name="l02322"></a>02322 <span class="comment">                         * reentrant from userspace again */</span>
<a name="l02323"></a>02323                         <span class="keywordflow">if</span> (signal_pending(current))
<a name="l02324"></a>02324                                 ptlrpc_interrupted_set(<span class="keyword">set</span>);
<a name="l02325"></a>02325                         cfs_restore_sigs(blocked_sigs);
<a name="l02326"></a>02326                 }
<a name="l02327"></a>02327 
<a name="l02328"></a>02328                 LASSERT(rc == 0 || rc == -EINTR || rc == -ETIMEDOUT);
<a name="l02329"></a>02329 
<a name="l02330"></a>02330                 <span class="comment">/* -EINTR =&gt; all requests have been flagged rq_intr so next</span>
<a name="l02331"></a>02331 <span class="comment">                 * check completes.</span>
<a name="l02332"></a>02332 <span class="comment">                 * -ETIMEDOUT =&gt; someone timed out.  When all reqs have</span>
<a name="l02333"></a>02333 <span class="comment">                 * timed out, signals are enabled allowing completion with</span>
<a name="l02334"></a>02334 <span class="comment">                 * EINTR.</span>
<a name="l02335"></a>02335 <span class="comment">                 * I don&apos;t really care if we go once more round the loop in</span>
<a name="l02336"></a>02336 <span class="comment">                 * the error cases -eeb. */</span>
<a name="l02337"></a>02337                 <span class="keywordflow">if</span> (rc == 0 &amp;&amp; atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>) == 0) {
<a name="l02338"></a>02338                         list_for_each(tmp, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>) {
<a name="l02339"></a>02339                                 req = list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l02340"></a>02340                                                  rq_set_chain);
<a name="l02341"></a>02341                                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02342"></a>02342                                 req-&gt;<a class="code" href="structptlrpc__request.html#a3c7a9c4f0292826fffa36e3ab1cedf47" title="whether the &amp;quot;rq_set&amp;quot; is a valid one">rq_invalid_rqset</a> = 1;
<a name="l02343"></a>02343                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02344"></a>02344                         }
<a name="l02345"></a>02345                 }
<a name="l02346"></a>02346         } <span class="keywordflow">while</span> (rc != 0 || atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>) != 0);
<a name="l02347"></a>02347 
<a name="l02348"></a>02348         LASSERT(atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>) == 0);
<a name="l02349"></a>02349 
<a name="l02350"></a>02350         rc = <span class="keyword">set</span>-&gt;set_rc; <span class="comment">/* rq_status of already freed requests if any */</span>
<a name="l02351"></a>02351         list_for_each(tmp, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>) {
<a name="l02352"></a>02352                 req = list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, rq_set_chain);
<a name="l02353"></a>02353 
<a name="l02354"></a>02354                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_COMPLETE);
<a name="l02355"></a>02355                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != 0)
<a name="l02356"></a>02356                         rc = req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>;
<a name="l02357"></a>02357         }
<a name="l02358"></a>02358 
<a name="l02359"></a>02359         <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structptlrpc__request__set.html#a3fc57c89c29f05a8fe2dccc5fa321baa" title="Completion callback, if only one.">set_interpret</a> != NULL) {
<a name="l02360"></a>02360                 int (*interpreter)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>,<span class="keywordtype">void</span> *,int) =
<a name="l02361"></a>02361                         set-&gt;<a class="code" href="structptlrpc__request__set.html#a3fc57c89c29f05a8fe2dccc5fa321baa" title="Completion callback, if only one.">set_interpret</a>;
<a name="l02362"></a>02362                 rc = interpreter (<span class="keyword">set</span>, set-&gt;<a class="code" href="structptlrpc__request__set.html#a6731b8dc93db539e727857043de0a9ad" title="opaq argument passed to completion set_interpret callback.">set_arg</a>, rc);
<a name="l02363"></a>02363         } <span class="keywordflow">else</span> {
<a name="l02364"></a>02364                 <span class="keyword">struct </span><a class="code" href="structptlrpc__set__cbdata.html" title="Description of a single ptrlrpc_set callback.">ptlrpc_set_cbdata</a> *cbdata, *n;
<a name="l02365"></a>02365                 <span class="keywordtype">int</span> err;
<a name="l02366"></a>02366 
<a name="l02367"></a>02367                 list_for_each_entry_safe(cbdata, n,
<a name="l02368"></a>02368                                          &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#afd915cdca4eee2fd8b0abdbecd520ce3" title="List of completion callbacks to be called when the set is completed This is only...">set_cblist</a>, <a class="code" href="structptlrpc__set__cbdata.html#a72f1ec9f7c8e7a2f8ea2e123bf4c0444" title="List linkage item.">psc_item</a>) {
<a name="l02369"></a>02369                         list_del_init(&amp;cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#a72f1ec9f7c8e7a2f8ea2e123bf4c0444" title="List linkage item.">psc_item</a>);
<a name="l02370"></a>02370                         err = cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#a7122f5f29318e70ed85129a2195bc247" title="Pointer to interpreting function.">psc_interpret</a>(<span class="keyword">set</span>, cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#acf9721671bfcc548e1e5fe4276ba9b5c" title="Opaq argument to pass to the callback.">psc_data</a>, rc);
<a name="l02371"></a>02371                         <span class="keywordflow">if</span> (err &amp;&amp; !rc)
<a name="l02372"></a>02372                                 rc = err;
<a name="l02373"></a>02373                         OBD_FREE_PTR(cbdata);
<a name="l02374"></a>02374                 }
<a name="l02375"></a>02375         }
<a name="l02376"></a>02376 
<a name="l02377"></a>02377         RETURN(rc);
<a name="l02378"></a>02378 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gac072432ff0e3366be99c8456895e28d1_cgraph.png" border="0" usemap="#group__net_gac072432ff0e3366be99c8456895e28d1_cgraph_map" alt=""></div>
<map name="group__net_gac072432ff0e3366be99c8456895e28d1_cgraph_map" id="group__net_gac072432ff0e3366be99c8456895e28d1_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="181,399,320,428"/><area shape="rect" id="node5" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="407,240,513,269"/><area shape="rect" id="node18" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request." alt="" coords="639,371,785,400"/><area shape="rect" id="node22" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network." alt="" coords="627,424,797,453"/><area shape="rect" id="node32" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="369,476,551,505"/><area shape="rect" id="node7" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME." alt="" coords="891,124,1016,153"/><area shape="rect" id="node9" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal." alt="" coords="892,200,1015,229"/><area shape="rect" id="node11" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list." alt="" coords="896,260,1011,289"/><area shape="rect" id="node13" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Actual interfacing with LNet to put/get/register/unregister stuff." alt="" coords="635,213,789,243"/><area shape="rect" id="node20" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req." alt="" coords="627,317,797,347"/><area shape="rect" id="node24" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req." alt="" coords="624,5,800,35"/><area shape="rect" id="node26" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre&#45;defined security transformation upon the..." alt="" coords="619,59,805,88"/><area shape="rect" id="node28" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc." alt="" coords="873,59,1033,88"/><area shape="rect" id="node34" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="600,477,824,507"/><area shape="rect" id="node36" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="875,451,1032,480"/><area shape="rect" id="node38" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="875,504,1032,533"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gac072432ff0e3366be99c8456895e28d1_icgraph.png" border="0" usemap="#group__net_gac072432ff0e3366be99c8456895e28d1_icgraph_map" alt=""></div>
<map name="group__net_gac072432ff0e3366be99c8456895e28d1_icgraph_map" id="group__net_gac072432ff0e3366be99c8456895e28d1_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="181,109,328,139"/><area shape="rect" id="node5" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="380,56,524,85"/><area shape="rect" id="node7" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="377,109,527,139"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="384,163,520,192"/><area shape="rect" id="node9" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="577,109,724,139"/><area shape="rect" id="node11" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="807,29,927,59"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="775,83,959,112"/><area shape="rect" id="node22" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1259,108,1501,137"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="796,187,937,216"/><area shape="rect" id="node13" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1009,29,1209,59"/><area shape="rect" id="node15" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1311,29,1449,59"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1008,83,1211,112"/><area shape="rect" id="node24" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1549,108,1725,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaea9a5e62d5d55ace491db905c9a474f7"></a><!-- doxytag: member="lustre_net.h::ptlrpc_unregister_bulk" ref="gaea9a5e62d5d55ace491db905c9a474f7" args="(struct ptlrpc_request *req, int async)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_unregister_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>async</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect a bulk desc from the <a class="el" href="structnetwork.html">network</a>. </p>
<p>Idempotent. Not thread-safe (i.e. only interlocks with completion callback). Returns 1 on success or 0 if <a class="el" href="structnetwork.html">network</a> unregistration failed for whatever reason. </p>

<p>Definition at line <a class="el" href="niobuf_8c_source.html#l00420">420</a> of file <a class="el" href="niobuf_8c_source.html">niobuf.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01465">ptlrpc_bulk_desc::bd_mds</a>, <a class="el" href="lustre__net_8h_source.html#l01450">ptlrpc_bulk_desc::bd_req</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, and <a class="el" href="lustre__net_8h_source.html#l01011">ptlrpc_request::rq_next_phase</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, and <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00421"></a>00421 {
<a name="l00422"></a>00422         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc = req-&gt;rq_bulk;
<a name="l00423"></a>00423         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>       lwi;
<a name="l00424"></a>00424         <span class="keywordtype">int</span>                      rc;
<a name="l00425"></a>00425         ENTRY;
<a name="l00426"></a>00426 
<a name="l00427"></a>00427         LASSERT(!in_interrupt());     <span class="comment">/* might sleep */</span>
<a name="l00428"></a>00428 
<a name="l00429"></a>00429         <span class="comment">/* Let&apos;s setup deadline for reply unlink. */</span>
<a name="l00430"></a>00430         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_BULK_UNLINK) &amp;&amp;
<a name="l00431"></a>00431             async &amp;&amp; req-&gt;rq_bulk_deadline == 0)
<a name="l00432"></a>00432                 req-&gt;rq_bulk_deadline = cfs_time_current_sec() + LONG_UNLINK;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434         <span class="keywordflow">if</span> (ptlrpc_client_bulk_active(req) == 0)        <span class="comment">/* completed or */</span>
<a name="l00435"></a>00435                 RETURN(1);                              <span class="comment">/* never registered */</span>
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         LASSERT(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a4d18b5020a6fbf0bb1c7f7e1af278707" title="Back pointer to the request.">bd_req</a> == req);  <span class="comment">/* bd_req NULL until registered */</span>
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         <span class="comment">/* the unlink ensures the callback happens ASAP and is the last</span>
<a name="l00440"></a>00440 <span class="comment">         * one.  If it fails, it must be because completion just happened,</span>
<a name="l00441"></a>00441 <span class="comment">         * but we must still l_wait_event() in this case to give liblustre</span>
<a name="l00442"></a>00442 <span class="comment">         * a chance to run client_bulk_callback() */</span>
<a name="l00443"></a>00443         mdunlink_iterate_helper(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a39514074e69f6f37f43699541282c288" title="array of associated MDs">bd_mds</a>, desc-&gt;bd_md_max_brw);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445         <span class="keywordflow">if</span> (ptlrpc_client_bulk_active(req) == 0)        <span class="comment">/* completed or */</span>
<a name="l00446"></a>00446                 RETURN(1);                              <span class="comment">/* never registered */</span>
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         <span class="comment">/* Move to &quot;Unregistering&quot; phase as bulk was not unlinked yet. */</span>
<a name="l00449"></a>00449         ptlrpc_rqphase_move(req, RQ_PHASE_UNREGISTERING);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451         <span class="comment">/* Do not wait for unlink to finish. */</span>
<a name="l00452"></a>00452         <span class="keywordflow">if</span> (async)
<a name="l00453"></a>00453                 RETURN(0);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         <span class="keywordflow">for</span> (;;) {
<a name="l00456"></a>00456                 <span class="comment">/* The wq argument is ignored by user-space wait_event macros */</span>
<a name="l00457"></a>00457                 wait_queue_head_t *wq = (req-&gt;rq_set != NULL) ?
<a name="l00458"></a>00458                                         &amp;req-&gt;rq_set-&gt;set_waitq :
<a name="l00459"></a>00459                                         &amp;req-&gt;rq_reply_waitq;
<a name="l00460"></a>00460                 <span class="comment">/* Network access will complete in finite time but the HUGE</span>
<a name="l00461"></a>00461 <span class="comment">                 * timeout lets us CWARN for visibility of sluggish NALs */</span>
<a name="l00462"></a>00462                 lwi = LWI_TIMEOUT_INTERVAL(cfs_time_seconds(LONG_UNLINK),
<a name="l00463"></a>00463                                            cfs_time_seconds(1), NULL, NULL);
<a name="l00464"></a>00464                 rc = l_wait_event(*wq, !ptlrpc_client_bulk_active(req), &amp;lwi);
<a name="l00465"></a>00465                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l00466"></a>00466                         ptlrpc_rqphase_move(req, req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a>);
<a name="l00467"></a>00467                         RETURN(1);
<a name="l00468"></a>00468                 }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470                 LASSERT(rc == -ETIMEDOUT);
<a name="l00471"></a>00471                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_WARNING, req, <span class="stringliteral">&quot;Unexpectedly long timeout: desc %p&quot;</span>,
<a name="l00472"></a>00472                           desc);
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474         RETURN(0);
<a name="l00475"></a>00475 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__net_gaea9a5e62d5d55ace491db905c9a474f7_icgraph.png" border="0" usemap="#group__net_gaea9a5e62d5d55ace491db905c9a474f7_icgraph_map" alt=""></div>
<map name="group__net_gaea9a5e62d5d55ace491db905c9a474f7_icgraph_map" id="group__net_gaea9a5e62d5d55ace491db905c9a474f7_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="224,57,331,87"/><area shape="rect" id="node5" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="379,84,517,113"/><area shape="rect" id="node7" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="940,56,1084,85"/><area shape="rect" id="node9" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="567,109,692,139"/><area shape="rect" id="node11" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="741,109,888,139"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="937,109,1087,139"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="944,163,1080,192"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1137,109,1284,139"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1367,29,1487,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1335,83,1519,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1819,108,2061,137"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1356,187,1497,216"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1569,29,1769,59"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1871,29,2009,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1568,83,1771,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2109,108,2285,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga3b962a1b6e534a49a4848336555d1d89"></a><!-- doxytag: member="lustre_net.h::ptlrpc_update_export_timer" ref="ga3b962a1b6e534a49a4848336555d1d89" args="(struct obd_export *exp, long extra_delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_update_export_timer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__export.html">obd_export</a> *&nbsp;</td>
          <td class="paramname"> <em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>extra_delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function makes sure dead exports are evicted in a timely manner. </p>
<p>This function is only called when some export receives a message (i.e., the <a class="el" href="structnetwork.html">network</a> is up.) </p>

<p>Definition at line <a class="el" href="service_8c_source.html#l01037">1037</a> of file <a class="el" href="service_8c_source.html">service.c</a>.</p>

<p>References <a class="el" href="lustre__export_8h_source.html#l00233">obd_export::exp_last_request_time</a>, <a class="el" href="lustre__export_8h_source.html#l00209">obd_export::exp_obd</a>, and <a class="el" href="lustre__export_8h_source.html#l00207">obd_export::exp_obd_chain_timed</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01038"></a>01038 {
<a name="l01039"></a>01039         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *oldest_exp;
<a name="l01040"></a>01040         time_t oldest_time, new_time;
<a name="l01041"></a>01041 
<a name="l01042"></a>01042         ENTRY;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044         LASSERT(exp);
<a name="l01045"></a>01045 
<a name="l01046"></a>01046         <span class="comment">/* Compensate for slow machines, etc, by faking our request time</span>
<a name="l01047"></a>01047 <span class="comment">           into the future.  Although this can break the strict time-ordering</span>
<a name="l01048"></a>01048 <span class="comment">           of the list, we can be really lazy here - we don&apos;t have to evict</span>
<a name="l01049"></a>01049 <span class="comment">           at the exact right moment.  Eventually, all silent exports</span>
<a name="l01050"></a>01050 <span class="comment">           will make it to the top of the list. */</span>
<a name="l01051"></a>01051 
<a name="l01052"></a>01052         <span class="comment">/* Do not pay attention on 1sec or smaller renewals. */</span>
<a name="l01053"></a>01053         new_time = cfs_time_current_sec() + extra_delay;
<a name="l01054"></a>01054         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structobd__export.html#a84db689e39028117188c5177e0b21dd0" title="When was last request received.">exp_last_request_time</a> + 1 <span class="comment">/*second */</span> &gt;= new_time)
<a name="l01055"></a>01055                 RETURN_EXIT;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057         exp-&gt;<a class="code" href="structobd__export.html#a84db689e39028117188c5177e0b21dd0" title="When was last request received.">exp_last_request_time</a> = new_time;
<a name="l01058"></a>01058 
<a name="l01059"></a>01059         <span class="comment">/* exports may get disconnected from the chain even though the</span>
<a name="l01060"></a>01060 <span class="comment">           export has references, so we must keep the spin lock while</span>
<a name="l01061"></a>01061 <span class="comment">           manipulating the lists */</span>
<a name="l01062"></a>01062         spin_lock(&amp;exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_dev_lock);
<a name="l01063"></a>01063 
<a name="l01064"></a>01064         <span class="keywordflow">if</span> (list_empty(&amp;exp-&gt;<a class="code" href="structobd__export.html#a6bb9ba26dcffde196c0e80178558ced2" title="last_rcvd clt gen hash">exp_obd_chain_timed</a>)) {
<a name="l01065"></a>01065                 <span class="comment">/* this one is not timed */</span>
<a name="l01066"></a>01066                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_dev_lock);
<a name="l01067"></a>01067                 RETURN_EXIT;
<a name="l01068"></a>01068         }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070         list_move_tail(&amp;exp-&gt;<a class="code" href="structobd__export.html#a6bb9ba26dcffde196c0e80178558ced2" title="last_rcvd clt gen hash">exp_obd_chain_timed</a>,
<a name="l01071"></a>01071                        &amp;exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_exports_timed);
<a name="l01072"></a>01072 
<a name="l01073"></a>01073         oldest_exp = list_entry(exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_exports_timed.next,
<a name="l01074"></a>01074                                 <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>, <a class="code" href="structobd__export.html#a6bb9ba26dcffde196c0e80178558ced2" title="last_rcvd clt gen hash">exp_obd_chain_timed</a>);
<a name="l01075"></a>01075         oldest_time = oldest_exp-&gt;<a class="code" href="structobd__export.html#a84db689e39028117188c5177e0b21dd0" title="When was last request received.">exp_last_request_time</a>;
<a name="l01076"></a>01076         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_dev_lock);
<a name="l01077"></a>01077 
<a name="l01078"></a>01078         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_recovering) {
<a name="l01079"></a>01079                 <span class="comment">/* be nice to everyone during recovery */</span>
<a name="l01080"></a>01080                 EXIT;
<a name="l01081"></a>01081                 <span class="keywordflow">return</span>;
<a name="l01082"></a>01082         }
<a name="l01083"></a>01083 
<a name="l01084"></a>01084         <span class="comment">/* Note - racing to start/reset the obd_eviction timer is safe */</span>
<a name="l01085"></a>01085         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_eviction_timer == 0) {
<a name="l01086"></a>01086                 <span class="comment">/* Check if the oldest entry is expired. */</span>
<a name="l01087"></a>01087                 <span class="keywordflow">if</span> (cfs_time_current_sec() &gt; (oldest_time + PING_EVICT_TIMEOUT +
<a name="l01088"></a>01088                                               extra_delay)) {
<a name="l01089"></a>01089                         <span class="comment">/* We need a second timer, in case the net was down and</span>
<a name="l01090"></a>01090 <span class="comment">                         * it just came back. Since the pinger may skip every</span>
<a name="l01091"></a>01091 <span class="comment">                         * other PING_INTERVAL (see note in ptlrpc_pinger_main),</span>
<a name="l01092"></a>01092 <span class="comment">                         * we better wait for 3. */</span>
<a name="l01093"></a>01093                         exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_eviction_timer =
<a name="l01094"></a>01094                                 cfs_time_current_sec() + 3 * PING_INTERVAL;
<a name="l01095"></a>01095                         CDEBUG(D_HA, <span class="stringliteral">&quot;%s: Think about evicting %s from &quot;</span>CFS_TIME_T<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01096"></a>01096                                exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_name,
<a name="l01097"></a>01097                                obd_export_nid2str(oldest_exp), oldest_time);
<a name="l01098"></a>01098                 }
<a name="l01099"></a>01099         } <span class="keywordflow">else</span> {
<a name="l01100"></a>01100                 <span class="keywordflow">if</span> (cfs_time_current_sec() &gt;
<a name="l01101"></a>01101                     (exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_eviction_timer + extra_delay)) {
<a name="l01102"></a>01102                         <span class="comment">/* The evictor won&apos;t evict anyone who we&apos;ve heard from</span>
<a name="l01103"></a>01103 <span class="comment">                         * recently, so we don&apos;t have to check before we start</span>
<a name="l01104"></a>01104 <span class="comment">                         * it. */</span>
<a name="l01105"></a>01105                         <span class="keywordflow">if</span> (!ping_evictor_wake(exp))
<a name="l01106"></a>01106                                 exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_eviction_timer = 0;
<a name="l01107"></a>01107                 }
<a name="l01108"></a>01108         }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110         EXIT;
<a name="l01111"></a>01111 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8786798db7200aeedbfe4cd0a855232f"></a><!-- doxytag: member="lustre_net.h::ptlrpcd_add_rqset" ref="ga8786798db7200aeedbfe4cd0a855232f" args="(struct ptlrpc_request_set *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpcd_add_rqset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move all request from an existing request set to the ptlrpcd queue. </p>
<p>All requests from the set must be in phase RQ_PHASE_NEW. </p>

<p>Definition at line <a class="el" href="ptlrpcd_8c_source.html#l00200">200</a> of file <a class="el" href="ptlrpcd_8c_source.html">ptlrpcd.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01910">ptlrpcd_ctl::pc_npartners</a>, <a class="el" href="lustre__net_8h_source.html#l01906">ptlrpcd_ctl::pc_partners</a>, <a class="el" href="lustre__net_8h_source.html#l01886">ptlrpcd_ctl::pc_set</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, and <a class="el" href="lustre__net_8h_source.html#l00579">ptlrpc_request_set::set_waitq</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00201"></a>00201 {
<a name="l00202"></a>00202         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp, *pos;
<a name="l00203"></a>00203         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc;
<a name="l00204"></a>00204         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">new</span>;
<a name="l00205"></a>00205         <span class="keywordtype">int</span> count, i;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207         pc = ptlrpcd_select_pc(NULL);
<a name="l00208"></a>00208         <span class="keyword">new</span> = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         list_for_each_safe(pos, tmp, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>) {
<a name="l00211"></a>00211                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l00212"></a>00212                         list_entry(pos, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00213"></a>00213                                    rq_set_chain);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW);
<a name="l00216"></a>00216                 req-&gt;rq_set = <span class="keyword">new</span>;
<a name="l00217"></a>00217                 req-&gt;rq_queued_time = cfs_time_current();
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         spin_lock(&amp;new-&gt;set_new_req_lock);
<a name="l00221"></a>00221         list_splice_init(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>, &amp;new-&gt;set_new_requests);
<a name="l00222"></a>00222         i = atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>);
<a name="l00223"></a>00223         count = atomic_add_return(i, &amp;new-&gt;set_new_count);
<a name="l00224"></a>00224         atomic_set(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>, 0);
<a name="l00225"></a>00225         spin_unlock(&amp;new-&gt;set_new_req_lock);
<a name="l00226"></a>00226         <span class="keywordflow">if</span> (count == i) {
<a name="l00227"></a>00227                 wake_up(&amp;new-&gt;set_waitq);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229                 <span class="comment">/* XXX: It maybe unnecessary to wakeup all the partners. But to</span>
<a name="l00230"></a>00230 <span class="comment">                 *      guarantee the async RPC can be processed ASAP, we have</span>
<a name="l00231"></a>00231 <span class="comment">                 *      no other better choice. It maybe fixed in future. */</span>
<a name="l00232"></a>00232                 <span class="keywordflow">for</span> (i = 0; i &lt; pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a>; i++)
<a name="l00233"></a>00233                         wake_up(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a>[i]-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>-&gt;<a class="code" href="structptlrpc__request__set.html#afa37e9803cad75f212925a762a9f6d7b" title="wait queue to wait on for request events">set_waitq</a>);
<a name="l00234"></a>00234         }
<a name="l00235"></a>00235 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:45 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
