<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: sptlrpc</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sptlrpc</h1>
<p><div class="dynheader">
Collaboration diagram for sptlrpc:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__sptlrpc.png" border="0" alt="" usemap="#group____sptlrpc_map"/>
<map name="group____sptlrpc_map" id="group____sptlrpc">
<area shape="rect" id="node1" href="group__flavor.html" title="RPC flavor is represented by a 32 bits integer." alt="" coords="124,5,183,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbulk__spec__hash.html">bulk_spec_hash</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Full description of flavors being used on a ptlrpc connection, include both regular RPC and bulk transfer parts.  <a href="structsptlrpc__flavor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsptlrpc__rule.html">sptlrpc_rule</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A rule specifies a flavor to be used by a ptlrpc connection between two Lustre parts.  <a href="structsptlrpc__rule.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A set of rules in memory.  <a href="structsptlrpc__rule__set.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvfs__cred.html">vfs_cred</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html">ptlrpc_ctx_ops</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__cops.html">ptlrpc_sec_cops</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">client side policy operation vector.  <a href="structptlrpc__sec__cops.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html">ptlrpc_sec_sops</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">server side policy operation vector.  <a href="structptlrpc__sec__sops.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> represents the client side ptlrpc security facilities, each <a class="el" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> (both regular and reverse import) must associate with a <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>.  <a href="structptlrpc__sec.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__user__desc.html">ptlrpc_user_desc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__bulk__sec__desc.html">ptlrpc_bulk_sec_desc</a></td></tr>
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flavor.html">flavor</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>RPC flavor is represented by a 32 bits integer. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3958409bc75b758e9e09796d7ca3925e"></a><!-- doxytag: member="sptlrpc::SPTLRPC_MAX_PAYLOAD" ref="ga3958409bc75b758e9e09796d7ca3925e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>SPTLRPC_MAX_PAYLOAD</b>&nbsp;&nbsp;&nbsp;(1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3102fdbe49a0dfef9ecb47f58d1c5935"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_NEW_BIT" ref="ga3102fdbe49a0dfef9ecb47f58d1c5935" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_NEW_BIT</b>&nbsp;&nbsp;&nbsp;(0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5aae0155a0ccdf50d4b64cb9e8965a47"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_UPTODATE_BIT" ref="ga5aae0155a0ccdf50d4b64cb9e8965a47" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_UPTODATE_BIT</b>&nbsp;&nbsp;&nbsp;(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa3716b7ebd501da999e12c921ceb0acb"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_DEAD_BIT" ref="gaa3716b7ebd501da999e12c921ceb0acb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_DEAD_BIT</b>&nbsp;&nbsp;&nbsp;(2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b7bd0230dc3d10ba50a6e32afc81a8d"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_ERROR_BIT" ref="ga0b7bd0230dc3d10ba50a6e32afc81a8d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_ERROR_BIT</b>&nbsp;&nbsp;&nbsp;(3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69a211d66569cde070d2b8c9db0eb822"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_CACHED_BIT" ref="ga69a211d66569cde070d2b8c9db0eb822" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_CACHED_BIT</b>&nbsp;&nbsp;&nbsp;(8)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga08b8df932cfb8e6e7d49034e5189e832"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_ETERNAL_BIT" ref="ga08b8df932cfb8e6e7d49034e5189e832" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_ETERNAL_BIT</b>&nbsp;&nbsp;&nbsp;(9)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac238dab7ed875b43558d58d8116760a7"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_NEW" ref="gac238dab7ed875b43558d58d8116760a7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_NEW</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; PTLRPC_CTX_NEW_BIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5d4408fc132bb7fcdb8196ecc6e44271"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_UPTODATE" ref="ga5d4408fc132bb7fcdb8196ecc6e44271" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_UPTODATE</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; PTLRPC_CTX_UPTODATE_BIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga18454dbb72c5daa80ad31f82652d2d6a"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_DEAD" ref="ga18454dbb72c5daa80ad31f82652d2d6a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_DEAD</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; PTLRPC_CTX_DEAD_BIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb5bfc157af765aeb2642330b7fc3536"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_ERROR" ref="gabb5bfc157af765aeb2642330b7fc3536" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_ERROR</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; PTLRPC_CTX_ERROR_BIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e170f5ce575f05515cfa842268b4b74"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_CACHED" ref="ga6e170f5ce575f05515cfa842268b4b74" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_CACHED</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; PTLRPC_CTX_CACHED_BIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga350852cbca12fbf31f6d368af93baeb1"></a><!-- doxytag: member="sptlrpc::PTLRPC_CTX_ETERNAL" ref="ga350852cbca12fbf31f6d368af93baeb1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_ETERNAL</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; PTLRPC_CTX_ETERNAL_BIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_CTX_STATUS_MASK</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8249a00d1231bc0bff8b14bb11bf4c1"></a><!-- doxytag: member="sptlrpc::PTLRPC_SEC_FL_REVERSE" ref="gad8249a00d1231bc0bff8b14bb11bf4c1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_SEC_FL_REVERSE</b>&nbsp;&nbsp;&nbsp;0x0001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6644a9cecb39572b0b8d0850594c4e80"></a><!-- doxytag: member="sptlrpc::PTLRPC_SEC_FL_ROOTONLY" ref="ga6644a9cecb39572b0b8d0850594c4e80" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_SEC_FL_ROOTONLY</b>&nbsp;&nbsp;&nbsp;0x0002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7ba0786836764f27532ac7b91d4b81e"></a><!-- doxytag: member="sptlrpc::PTLRPC_SEC_FL_UDESC" ref="gaa7ba0786836764f27532ac7b91d4b81e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_SEC_FL_UDESC</b>&nbsp;&nbsp;&nbsp;0x0004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae74cca9772faedbadc086c9645ba97b8"></a><!-- doxytag: member="sptlrpc::PTLRPC_SEC_FL_BULK" ref="gae74cca9772faedbadc086c9645ba97b8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_SEC_FL_BULK</b>&nbsp;&nbsp;&nbsp;0x0008</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5b9c7dc666ad443976790ffa78e98ea"></a><!-- doxytag: member="sptlrpc::PTLRPC_SEC_FL_PAG" ref="gaa5b9c7dc666ad443976790ffa78e98ea" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PTLRPC_SEC_FL_PAG</b>&nbsp;&nbsp;&nbsp;0x0010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1df5a3dd21c2fdac7afa32716a85ae06"></a><!-- doxytag: member="sptlrpc::LUSTRE_MAX_GROUPS" ref="ga1df5a3dd21c2fdac7afa32716a85ae06" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LUSTRE_MAX_GROUPS</b>&nbsp;&nbsp;&nbsp;(128)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f4321c051636a3be86bce589cdd8b22"></a><!-- doxytag: member="sptlrpc::CFS_CAP_CHOWN_MASK" ref="ga4f4321c051636a3be86bce589cdd8b22" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CFS_CAP_CHOWN_MASK</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; CFS_CAP_CHOWN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga816dad091bd44f66008aa6e363d7e694"></a><!-- doxytag: member="sptlrpc::CFS_CAP_SYS_RESOURCE_MASK" ref="ga816dad091bd44f66008aa6e363d7e694" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CFS_CAP_SYS_RESOURCE_MASK</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; CFS_CAP_SYS_RESOURCE)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">lustre_sec_part</a> { <br/>
&nbsp;&nbsp;<b>LUSTRE_SP_CLI</b> =  0, 
<b>LUSTRE_SP_MDT</b>, 
<b>LUSTRE_SP_OST</b>, 
<b>LUSTRE_SP_MGC</b>, 
<br/>
&nbsp;&nbsp;<b>LUSTRE_SP_MGS</b>, 
<b>LUSTRE_SP_ANY</b> =  0xFF
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>identify the RPC is generated from what part of Lustre. </p>
 <a href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_bulk_hash_alg</b> { <br/>
&nbsp;&nbsp;<b>BULK_HASH_ALG_NULL</b> =  0, 
<b>BULK_HASH_ALG_ADLER32</b>, 
<b>BULK_HASH_ALG_CRC32</b>, 
<b>BULK_HASH_ALG_MD5</b>, 
<br/>
&nbsp;&nbsp;<b>BULK_HASH_ALG_SHA1</b>, 
<b>BULK_HASH_ALG_SHA256</b>, 
<b>BULK_HASH_ALG_SHA384</b>, 
<b>BULK_HASH_ALG_SHA512</b>, 
<br/>
&nbsp;&nbsp;<b>BULK_HASH_ALG_MAX</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>BSD_FL_ERR</b> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>secsvc_accept_res</b> { <b>SECSVC_OK</b> =  0, 
<b>SECSVC_COMPLETE</b>, 
<b>SECSVC_DROP</b>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>LUSTRE_SEC_NONE</b> =  0, 
<b>LUSTRE_SEC_REMOTE</b> =  1, 
<b>LUSTRE_SEC_SPECIFY</b> =  2, 
<b>LUSTRE_SEC_ALL</b> =  3
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae3ba857eeba0c2ef1f39398fbec5d20b"></a><!-- doxytag: member="sptlrpc::sptlrpc_part2name" ref="gae3ba857eeba0c2ef1f39398fbec5d20b" args="(enum lustre_sec_part sp)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_part2name</b> (enum <a class="el" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">lustre_sec_part</a> sp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab694657bf342c17497d3a93d365ca0fb"></a><!-- doxytag: member="sptlrpc::sptlrpc_target_sec_part" ref="gab694657bf342c17497d3a93d365ca0fb" args="(struct obd_device *obd)" -->
enum <a class="el" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">lustre_sec_part</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_target_sec_part</b> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga980342127c4dc3a5b3ddf602bb7b4006"></a><!-- doxytag: member="sptlrpc::sptlrpc_parse_flavor" ref="ga980342127c4dc3a5b3ddf602bb7b4006" args="(const char *str, struct sptlrpc_flavor *flvr)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_parse_flavor</b> (const char *str, struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *flvr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa80ab1abf7cfff17fd225a9cc473ea33"></a><!-- doxytag: member="sptlrpc::sptlrpc_flavor_has_bulk" ref="gaa80ab1abf7cfff17fd225a9cc473ea33" args="(struct sptlrpc_flavor *flvr)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_flavor_has_bulk</b> (struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *flvr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70cd74bc850b26e1f7b64f005e7b65ba"></a><!-- doxytag: member="sptlrpc::sptlrpc_rule_set_free" ref="ga70cd74bc850b26e1f7b64f005e7b65ba" args="(struct sptlrpc_rule_set *set)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_rule_set_free</b> (struct <a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a> *set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad97bd682c62430332e66ea25e26404fb"></a><!-- doxytag: member="sptlrpc::sptlrpc_rule_set_expand" ref="gad97bd682c62430332e66ea25e26404fb" args="(struct sptlrpc_rule_set *set)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_rule_set_expand</b> (struct <a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a> *set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac98f179353155454bcb03aa77718a914"></a><!-- doxytag: member="sptlrpc::sptlrpc_rule_set_merge" ref="gac98f179353155454bcb03aa77718a914" args="(struct sptlrpc_rule_set *set, struct sptlrpc_rule *rule)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_rule_set_merge</b> (struct <a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a> *set, struct <a class="el" href="structsptlrpc__rule.html">sptlrpc_rule</a> *rule)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gaa86a438c13250916b84e0d12810d5786">sptlrpc_rule_set_choose</a> (struct <a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a> *rset, enum <a class="el" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">lustre_sec_part</a> from, enum <a class="el" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">lustre_sec_part</a> to, <a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> nid, struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *sf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">given from/to/nid, determine a matching flavor in ruleset.  <a href="#gaa86a438c13250916b84e0d12810d5786"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e24aa2e05415973026abbbba8e920d6"></a><!-- doxytag: member="sptlrpc::sptlrpc_rule_set_dump" ref="ga8e24aa2e05415973026abbbba8e920d6" args="(struct sptlrpc_rule_set *set)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_rule_set_dump</b> (struct <a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a> *set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c47d43e343809a1953d50ab7f669843"></a><!-- doxytag: member="sptlrpc::sptlrpc_process_config" ref="ga1c47d43e343809a1953d50ab7f669843" args="(struct lustre_cfg *lcfg)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_process_config</b> (struct <a class="el" href="structlustre__cfg.html">lustre_cfg</a> *lcfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2496cbe40b256079ab21ef772f5fb6f2"></a><!-- doxytag: member="sptlrpc::sptlrpc_conf_log_start" ref="ga2496cbe40b256079ab21ef772f5fb6f2" args="(const char *logname)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_conf_log_start</b> (const char *logname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaacb6f9cb18a825fe739d903c6c3f7fff"></a><!-- doxytag: member="sptlrpc::sptlrpc_conf_log_stop" ref="gaacb6f9cb18a825fe739d903c6c3f7fff" args="(const char *logname)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_conf_log_stop</b> (const char *logname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7585b0181e15b0a90dc648c8be5c733"></a><!-- doxytag: member="sptlrpc::sptlrpc_conf_log_update_begin" ref="gaa7585b0181e15b0a90dc648c8be5c733" args="(const char *logname)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_conf_log_update_begin</b> (const char *logname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf01cd5684aea35fb175f6c9606735fa0"></a><!-- doxytag: member="sptlrpc::sptlrpc_conf_log_update_end" ref="gaf01cd5684aea35fb175f6c9606735fa0" args="(const char *logname)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gaf01cd5684aea35fb175f6c9606735fa0">sptlrpc_conf_log_update_end</a> (const char *logname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">mark a config log has been updated <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5e58c9331d8eafe4108b46943df678d4"></a><!-- doxytag: member="sptlrpc::sptlrpc_conf_client_adapt" ref="ga5e58c9331d8eafe4108b46943df678d4" args="(struct obd_device *obd)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga5e58c9331d8eafe4108b46943df678d4">sptlrpc_conf_client_adapt</a> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">called by client devices, notify the sptlrpc config has changed and do import_sec_adapt later. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7d95f365760c1a00381d8e0b116c4cb"></a><!-- doxytag: member="sptlrpc::sptlrpc_conf_target_get_rules" ref="gaa7d95f365760c1a00381d8e0b116c4cb" args="(struct obd_device *obd, struct sptlrpc_rule_set *rset, int initial)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gaa7d95f365760c1a00381d8e0b116c4cb">sptlrpc_conf_target_get_rules</a> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd, struct <a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a> *rset, int initial)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">called by target devices, extract sptlrpc rules which applies to this target, to be used for future rpc flavor checking. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2dcbcaee70d89f9e5f250d5e095ab4e"></a><!-- doxytag: member="sptlrpc::sptlrpc_target_choose_flavor" ref="gac2dcbcaee70d89f9e5f250d5e095ab4e" args="(struct sptlrpc_rule_set *rset, enum lustre_sec_part from, lnet_nid_t nid, struct sptlrpc_flavor *flavor)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gac2dcbcaee70d89f9e5f250d5e095ab4e">sptlrpc_target_choose_flavor</a> (struct <a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a> *rset, enum <a class="el" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">lustre_sec_part</a> from, <a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> nid, struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *flavor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">called by target devices, determine the expected flavor from certain peer (from, nid). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc8594b4a7fd11ab03c1b2eb0073d496"></a><!-- doxytag: member="sptlrpc::sptlrpc_get_hash_name" ref="gafc8594b4a7fd11ab03c1b2eb0073d496" args="(__u8 hash_alg)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_get_hash_name</b> (__u8 hash_alg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga385e9b182391ffe3960e4229f5ba7f5e"></a><!-- doxytag: member="sptlrpc::sptlrpc_get_hash_alg" ref="ga385e9b182391ffe3960e4229f5ba7f5e" args="(const char *algname)" -->
__u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_get_hash_alg</b> (const char *algname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd69575358901d3eef6fab761a1eeea2"></a><!-- doxytag: member="sptlrpc::_sptlrpc_enlarge_msg_inplace" ref="gafd69575358901d3eef6fab761a1eeea2" args="(struct lustre_msg *msg, int segment, int newsize)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>_sptlrpc_enlarge_msg_inplace</b> (struct lustre_msg *msg, int segment, int newsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a05c039cd87056cf638e2051cf3fe83"></a><!-- doxytag: member="sptlrpc::sptlrpc_register_policy" ref="ga1a05c039cd87056cf638e2051cf3fe83" args="(struct ptlrpc_sec_policy *policy)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_register_policy</b> (struct <a class="el" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed742582f21f7873e14c565bbbf25ff2"></a><!-- doxytag: member="sptlrpc::sptlrpc_unregister_policy" ref="gaed742582f21f7873e14c565bbbf25ff2" args="(struct ptlrpc_sec_policy *policy)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_unregister_policy</b> (struct <a class="el" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga912a600308193abc2eec4daee744cfca"></a><!-- doxytag: member="sptlrpc::sptlrpc_name2flavor_base" ref="ga912a600308193abc2eec4daee744cfca" args="(const char *name)" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_name2flavor_base</b> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3132dfbf193fbf12fff8c2b03a9f8b45"></a><!-- doxytag: member="sptlrpc::sptlrpc_flavor2name_base" ref="ga3132dfbf193fbf12fff8c2b03a9f8b45" args="(__u32 flvr)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_flavor2name_base</b> (__u32 flvr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1315e2959982e95e86a8627d34bd408"></a><!-- doxytag: member="sptlrpc::sptlrpc_flavor2name_bulk" ref="gaa1315e2959982e95e86a8627d34bd408" args="(struct sptlrpc_flavor *sf, char *buf, int bufsize)" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_flavor2name_bulk</b> (struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *sf, char *buf, int bufsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06e6b1fc8fbc7addf5900923b0469d6a"></a><!-- doxytag: member="sptlrpc::sptlrpc_flavor2name" ref="ga06e6b1fc8fbc7addf5900923b0469d6a" args="(struct sptlrpc_flavor *sf, char *buf, int bufsize)" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_flavor2name</b> (struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *sf, char *buf, int bufsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga325dd2fed56fea11600d8cc135b19b41"></a><!-- doxytag: member="sptlrpc::sptlrpc_secflags2str" ref="ga325dd2fed56fea11600d8cc135b19b41" args="(__u32 flags, char *buf, int bufsize)" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_secflags2str</b> (__u32 flags, char *buf, int bufsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga46b62f214acc7091ec6a686b6b7e7467"></a><!-- doxytag: member="sptlrpc::sptlrpc_sec_get" ref="ga46b62f214acc7091ec6a686b6b7e7467" args="(struct ptlrpc_sec *sec)" -->
struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_sec_get</b> (struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7614fad9d6201ee956c2b8c591b63e27"></a><!-- doxytag: member="sptlrpc::sptlrpc_sec_put" ref="ga7614fad9d6201ee956c2b8c591b63e27" args="(struct ptlrpc_sec *sec)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_sec_put</b> (struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b64d60127ec57a387ff0477a9ae64f5"></a><!-- doxytag: member="sptlrpc::sptlrpc_get_next_secid" ref="ga4b64d60127ec57a387ff0477a9ae64f5" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_get_next_secid</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5c544de8ca3702af15a342280e984797"></a><!-- doxytag: member="sptlrpc::sptlrpc_sec_destroy" ref="ga5c544de8ca3702af15a342280e984797" args="(struct ptlrpc_sec *sec)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_sec_destroy</b> (struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9129ba640c50c1a8b7d3e50bfec54f4"></a><!-- doxytag: member="sptlrpc::sptlrpc_cli_ctx_get" ref="gab9129ba640c50c1a8b7d3e50bfec54f4" args="(struct ptlrpc_cli_ctx *ctx)" -->
struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_cli_ctx_get</b> (struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69f6e7f870c1215e81c9e939d790ae3b"></a><!-- doxytag: member="sptlrpc::sptlrpc_cli_ctx_put" ref="ga69f6e7f870c1215e81c9e939d790ae3b" args="(struct ptlrpc_cli_ctx *ctx, int sync)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_cli_ctx_put</b> (struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, int sync)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga6c05663895d669f077f0369232b46dad">sptlrpc_cli_ctx_expire</a> (struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expire the client context immediately.  <a href="#ga6c05663895d669f077f0369232b46dad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gae8509673f10f3ba05986d960f5b4a20d">sptlrpc_cli_ctx_wakeup</a> (struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To wake up the threads who are waiting for this client context.  <a href="#gae8509673f10f3ba05986d960f5b4a20d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga606c9a5cf4f1a5a6668ff8d1ea65bb5e"></a><!-- doxytag: member="sptlrpc::sptlrpc_cli_ctx_display" ref="ga606c9a5cf4f1a5a6668ff8d1ea65bb5e" args="(struct ptlrpc_cli_ctx *ctx, char *buf, int bufsize)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_cli_ctx_display</b> (struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, char *buf, int bufsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2">sptlrpc_cli_wrap_request</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc client, to perform the pre-defined security transformation upon the request message of <em>req</em>.  <a href="#ga2b508842c18d6c0a32c9678445565ce2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga4e652d7f03a8727b8eb9c290936aec23">sptlrpc_cli_unwrap_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc client, to perform security transformation upon the reply message of <em>req</em>.  <a href="#ga4e652d7f03a8727b8eb9c290936aec23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gaafb426af1f450b0f25952ba1b38f640d">sptlrpc_cli_alloc_reqbuf</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int msgsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc client to allocate request buffer of <em>req</em>.  <a href="#gaafb426af1f450b0f25952ba1b38f640d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga2f36863ed408b2fc13f7a04eb6280dd4">sptlrpc_cli_free_reqbuf</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc client to free request buffer of <em>req</em>.  <a href="#ga2f36863ed408b2fc13f7a04eb6280dd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f">sptlrpc_cli_alloc_repbuf</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int msgsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc client to allocate reply buffer of <em>req</em>.  <a href="#ga2059ff503d15d0b06699e153845bc66f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga6cd89bd371e4a81930e260bb1b8c79f8">sptlrpc_cli_free_repbuf</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc client to free reply buffer of <em>req</em>.  <a href="#ga6cd89bd371e4a81930e260bb1b8c79f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gae060941c4c97b1cb7ba03904a24b53c3">sptlrpc_cli_enlarge_reqbuf</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int segment, int newsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc client to enlarge the <em>segment</em> of request message pointed by req-&gt;rq_reqmsg to size <em>newsize</em>, all previously filled-in data will be preserved after the enlargement.  <a href="#gae060941c4c97b1cb7ba03904a24b53c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga555969de6cd1c126c5a8887b740e1354">sptlrpc_cli_unwrap_early_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> **req_ret)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc client, to perform security transformation upon the early reply message of <em>req</em>.  <a href="#ga555969de6cd1c126c5a8887b740e1354"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga9e900c41f0c033d65d6a108d1a1a553c">sptlrpc_cli_finish_early_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *early_req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc client, to release a processed early reply <em>early_req</em>.  <a href="#ga9e900c41f0c033d65d6a108d1a1a553c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga61d2d3a2133c043d3998bd7a473f3937"></a><!-- doxytag: member="sptlrpc::sptlrpc_request_out_callback" ref="ga61d2d3a2133c043d3998bd7a473f3937" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_request_out_callback</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b">sptlrpc_import_sec_adapt</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx, struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *flvr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To get an appropriate <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> for the <em>imp</em>, according to the current configuration.  <a href="#ga01235b3d6bd59ff6adee314742be930b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaaacc60ce00e1c012d6a657e285853f6"></a><!-- doxytag: member="sptlrpc::sptlrpc_import_sec_ref" ref="gaaaacc60ce00e1c012d6a657e285853f6" args="(struct obd_import *imp)" -->
struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_import_sec_ref</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1abd65eeaa270acbef838fcbccaaeac5"></a><!-- doxytag: member="sptlrpc::sptlrpc_import_sec_put" ref="ga1abd65eeaa270acbef838fcbccaaeac5" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_import_sec_put</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5">sptlrpc_import_check_ctx</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an import <em>imp</em>, check whether current user has a valid context or not.  <a href="#gaa43ec50fcb7c93e96d80c8b544da92a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4617ddc0fa8e067bbc8737e446c22d4"></a><!-- doxytag: member="sptlrpc::sptlrpc_import_flush_root_ctx" ref="gad4617ddc0fa8e067bbc8737e446c22d4" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_import_flush_root_ctx</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga84bad1e7778dc00a63e61ecd39032ef9"></a><!-- doxytag: member="sptlrpc::sptlrpc_import_flush_my_ctx" ref="ga84bad1e7778dc00a63e61ecd39032ef9" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_import_flush_my_ctx</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92154e132fba9ee6e8452e2694efcedd"></a><!-- doxytag: member="sptlrpc::sptlrpc_import_flush_all_ctx" ref="ga92154e132fba9ee6e8452e2694efcedd" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_import_flush_all_ctx</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847">sptlrpc_req_get_ctx</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a <em>req</em>, find or allocate an appropriate context for it.  <a href="#ga5aafb085a9167ed0295a28d4bddb5847"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c">sptlrpc_req_put_ctx</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int sync)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop the context for <em>req</em>.  <a href="#ga9c506dfa976b8fa42f6d351f1a67098c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0">sptlrpc_req_refresh_ctx</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To refresh the context of , if it's not up-to-date.  <a href="#ga94cbed545313e8c7bc6a682a438c89b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd">sptlrpc_req_replace_dead_ctx</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If current context of <em>req</em> is dead somehow, e.g.  <a href="#ga7254cf32b0cefed6242f298d3326e8dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga701bf20eebf0fd9d03c94918418f3b31">sptlrpc_req_set_flavor</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int opcode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize flavor settings for <em>req</em>, according to <em>opcode</em>.  <a href="#ga701bf20eebf0fd9d03c94918418f3b31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa6c9dde64f9943554b399bddd35b9ec"></a><!-- doxytag: member="sptlrpc::sptlrpc_parse_rule" ref="gafa6c9dde64f9943554b399bddd35b9ec" args="(char *param, struct sptlrpc_rule *rule)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_parse_rule</b> (char *param, struct <a class="el" href="structsptlrpc__rule.html">sptlrpc_rule</a> *rule)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01c41546e7400b5b265dcd8000628d1e"></a><!-- doxytag: member="sptlrpc::sptlrpc_gc_add_sec" ref="ga01c41546e7400b5b265dcd8000628d1e" args="(struct ptlrpc_sec *sec)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_gc_add_sec</b> (struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga87571fcfb3f0bd71da0ff18fd1b541a2"></a><!-- doxytag: member="sptlrpc::sptlrpc_gc_del_sec" ref="ga87571fcfb3f0bd71da0ff18fd1b541a2" args="(struct ptlrpc_sec *sec)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_gc_del_sec</b> (struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6c2b6adaa51bed62ebd4a5bef32eb8e"></a><!-- doxytag: member="sptlrpc::sptlrpc_gc_add_ctx" ref="gad6c2b6adaa51bed62ebd4a5bef32eb8e" args="(struct ptlrpc_cli_ctx *ctx)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_gc_add_ctx</b> (struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafca48f8057fe571c4bfb390c91959ed4"></a><!-- doxytag: member="sptlrpc::sec2target_str" ref="gafca48f8057fe571c4bfb390c91959ed4" args="(struct ptlrpc_sec *sec)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sec2target_str</b> (struct <a class="el" href="structptlrpc__sec.html">ptlrpc_sec</a> *sec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac7ab4ffd47c810edfecc4c529a9e51ee"></a><!-- doxytag: member="sptlrpc::sptlrpc_lprocfs_cliobd_attach" ref="gac7ab4ffd47c810edfecc4c529a9e51ee" args="(struct obd_device *dev)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_lprocfs_cliobd_attach</b> (struct <a class="el" href="structobd__device.html">obd_device</a> *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga6fdd12db4bcfd925fed91da8a4ecf857">sptlrpc_svc_unwrap_request</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc server, to perform transformation upon request message of incoming <em>req</em>.  <a href="#ga6fdd12db4bcfd925fed91da8a4ecf857"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga1bcf6cf901c5c461f6f273a9b764430a">sptlrpc_svc_alloc_rs</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int msglen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc server, to allocate reply buffer for <em>req</em>.  <a href="#ga1bcf6cf901c5c461f6f273a9b764430a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gaa36445bb3135100651ecb584e151f3cb">sptlrpc_svc_wrap_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc server, to perform transformation upon reply message.  <a href="#gaa36445bb3135100651ecb584e151f3cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga993608bc2cfa31615e26f5f368801d30"></a><!-- doxytag: member="sptlrpc::sptlrpc_svc_free_rs" ref="ga993608bc2cfa31615e26f5f368801d30" args="(struct ptlrpc_reply_state *rs)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga993608bc2cfa31615e26f5f368801d30">sptlrpc_svc_free_rs</a> (struct <a class="el" href="structptlrpc__reply__state.html">ptlrpc_reply_state</a> *rs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by ptlrpc server, to free reply_state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac66b97b1dc648126eca05d226eb472d4"></a><!-- doxytag: member="sptlrpc::sptlrpc_svc_ctx_addref" ref="gac66b97b1dc648126eca05d226eb472d4" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_svc_ctx_addref</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb77528ba2594382bae01ea165279b33"></a><!-- doxytag: member="sptlrpc::sptlrpc_svc_ctx_decref" ref="gabb77528ba2594382bae01ea165279b33" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_svc_ctx_decref</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga190589b71fa07942382f910717c24698"></a><!-- doxytag: member="sptlrpc::sptlrpc_svc_ctx_invalidate" ref="ga190589b71fa07942382f910717c24698" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_svc_ctx_invalidate</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gaf12efdd6553013c0e886d356541dd86b">sptlrpc_target_export_check</a> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an export <em>exp</em>, check whether the flavor of incoming <em>req</em> is allowed by the export <em>exp</em>.  <a href="#gaf12efdd6553013c0e886d356541dd86b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga722b78e23977e8a40890e54e043fb743"></a><!-- doxytag: member="sptlrpc::sptlrpc_target_update_exp_flavor" ref="ga722b78e23977e8a40890e54e043fb743" args="(struct obd_device *obd, struct sptlrpc_rule_set *rset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_target_update_exp_flavor</b> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd, struct <a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a> *rset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa6cf2336242cfbca59edb26b9444508a"></a><!-- doxytag: member="sptlrpc::sptlrpc_svc_install_rvs_ctx" ref="gaa6cf2336242cfbca59edb26b9444508a" args="(struct obd_import *imp, struct ptlrpc_svc_ctx *ctx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_svc_install_rvs_ctx</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78e7e46d42204a9fc6366341ca7825a6"></a><!-- doxytag: member="sptlrpc::sptlrpc_cli_install_rvs_ctx" ref="ga78e7e46d42204a9fc6366341ca7825a6" args="(struct obd_import *imp, struct ptlrpc_cli_ctx *ctx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_cli_install_rvs_ctx</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82064312c04e9133154ce8bb6d2daacf"></a><!-- doxytag: member="sptlrpc::sptlrpc_enc_pool_add_user" ref="ga82064312c04e9133154ce8bb6d2daacf" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_enc_pool_add_user</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga68dbf6ae7e8805edf17e14742ea3c8f1"></a><!-- doxytag: member="sptlrpc::sptlrpc_enc_pool_del_user" ref="ga68dbf6ae7e8805edf17e14742ea3c8f1" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_enc_pool_del_user</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ced763490cbc558e995cd56979ec1dd"></a><!-- doxytag: member="sptlrpc::sptlrpc_enc_pool_get_pages" ref="ga5ced763490cbc558e995cd56979ec1dd" args="(struct ptlrpc_bulk_desc *desc)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_enc_pool_get_pages</b> (struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad0f938109566cd8150a11035de54d84"></a><!-- doxytag: member="sptlrpc::sptlrpc_enc_pool_put_pages" ref="gaad0f938109566cd8150a11035de54d84" args="(struct ptlrpc_bulk_desc *desc)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_enc_pool_put_pages</b> (struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ed62eee15ce0e042433a188a1caa805"></a><!-- doxytag: member="sptlrpc::get_free_pages_in_pool" ref="ga1ed62eee15ce0e042433a188a1caa805" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_free_pages_in_pool</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga37e790b753a395f182df4dd8b0051121"></a><!-- doxytag: member="sptlrpc::pool_is_at_full_capacity" ref="ga37e790b753a395f182df4dd8b0051121" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>pool_is_at_full_capacity</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512">sptlrpc_cli_wrap_bulk</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform transformation upon bulk data pointed by <em>desc</em>.  <a href="#gae9ac9239c38fc5eb10c0951976a38512"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga40f686bb862f149e189cf81f3a51a7c3">sptlrpc_cli_unwrap_bulk_read</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc, int nob)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called after unwrap the reply message.  <a href="#ga40f686bb862f149e189cf81f3a51a7c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sptlrpc.html#ga4a0448bc155a2dd383e108188f99beec">sptlrpc_cli_unwrap_bulk_write</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called after unwrap the reply message.  <a href="#ga4a0448bc155a2dd383e108188f99beec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d1e537bd99b8f771179b04a2949f1d4"></a><!-- doxytag: member="sptlrpc::sptlrpc_get_bulk_checksum" ref="ga1d1e537bd99b8f771179b04a2949f1d4" args="(struct ptlrpc_bulk_desc *desc, __u8 alg, void *buf, int buflen)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_get_bulk_checksum</b> (struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc, __u8 alg, void *buf, int buflen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6035532fa5f42950c0bc7ae26a5cd6b1"></a><!-- doxytag: member="sptlrpc::bulk_sec_desc_unpack" ref="ga6035532fa5f42950c0bc7ae26a5cd6b1" args="(struct lustre_msg *msg, int offset, int swabbed)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>bulk_sec_desc_unpack</b> (struct lustre_msg *msg, int offset, int swabbed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf61d7452ef3a6935b30b6dba4ba8039"></a><!-- doxytag: member="sptlrpc::sptlrpc_current_user_desc_size" ref="gacf61d7452ef3a6935b30b6dba4ba8039" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_current_user_desc_size</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab78c9aec11cc11bf54cec647da66230f"></a><!-- doxytag: member="sptlrpc::sptlrpc_pack_user_desc" ref="gab78c9aec11cc11bf54cec647da66230f" args="(struct lustre_msg *msg, int offset)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_pack_user_desc</b> (struct lustre_msg *msg, int offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e53853e63a860a62a3b72b4f13f5632"></a><!-- doxytag: member="sptlrpc::sptlrpc_unpack_user_desc" ref="ga3e53853e63a860a62a3b72b4f13f5632" args="(struct lustre_msg *req, int offset, int swabbed)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_unpack_user_desc</b> (struct lustre_msg *req, int offset, int swabbed)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa93552557afcf1b6764abfef741123bf"></a><!-- doxytag: member="sptlrpc::sptlrpc_proc_root" ref="gaa93552557afcf1b6764abfef741123bf" args="" -->
struct proc_dir_entry *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sptlrpc_proc_root</b></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga147ef1e0ce843903ef7f3921c413d4ed"></a><!-- doxytag: member="lustre_sec.h::PTLRPC_CTX_STATUS_MASK" ref="ga147ef1e0ce843903ef7f3921c413d4ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTLRPC_CTX_STATUS_MASK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(PTLRPC_CTX_NEW_BIT    |       \
                                        PTLRPC_CTX_UPTODATE   |       \
                                        PTLRPC_CTX_DEAD       |       \
                                        PTLRPC_CTX_ERROR)
</pre></div>
<p>Definition at line <a class="el" href="lustre__sec_8h_source.html#l00529">529</a> of file <a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaceeb8c40afd0179b5b42fc19aa58d177"></a><!-- doxytag: member="lustre_sec.h::lustre_sec_part" ref="gaceeb8c40afd0179b5b42fc19aa58d177" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">lustre_sec_part</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>identify the RPC is generated from what part of Lustre. </p>
<p>It's encoded into RPC requests and to be checked by ptlrpc service. </p>

<p>Definition at line <a class="el" href="lustre__sec_8h_source.html#l00315">315</a> of file <a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00315"></a>00315                      {
<a name="l00316"></a>00316         LUSTRE_SP_CLI           = 0,
<a name="l00317"></a>00317         LUSTRE_SP_MDT,
<a name="l00318"></a>00318         LUSTRE_SP_OST,
<a name="l00319"></a>00319         LUSTRE_SP_MGC,
<a name="l00320"></a>00320         LUSTRE_SP_MGS,
<a name="l00321"></a>00321         LUSTRE_SP_ANY           = 0xFF
<a name="l00322"></a>00322 };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2059ff503d15d0b06699e153845bc66f"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_alloc_repbuf" ref="ga2059ff503d15d0b06699e153845bc66f" args="(struct ptlrpc_request *req, int msgsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_cli_alloc_repbuf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msgsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc client to allocate reply buffer of <em>req</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>After this, req-&gt;rq_repmsg is still not accessible. </dd></dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01707">1707</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__sec__cops.html#a6b48ac1eaef3ac1159a8d8cac74d5eef">ptlrpc_sec_cops::alloc_repbuf</a>, and <a class="el" href="lustre__net_8h_source.html#l01080">ptlrpc_request::rq_repbuf</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01708"></a>01708 {
<a name="l01709"></a>01709         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l01710"></a>01710         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l01711"></a>01711         ENTRY;
<a name="l01712"></a>01712 
<a name="l01713"></a>01713         LASSERT(ctx);
<a name="l01714"></a>01714         LASSERT(ctx-&gt;cc_sec);
<a name="l01715"></a>01715         LASSERT(ctx-&gt;cc_sec-&gt;ps_policy);
<a name="l01716"></a>01716 
<a name="l01717"></a>01717         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>)
<a name="l01718"></a>01718                 RETURN(0);
<a name="l01719"></a>01719 
<a name="l01720"></a>01720         policy = ctx-&gt;cc_sec-&gt;ps_policy;
<a name="l01721"></a>01721         RETURN(policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a6b48ac1eaef3ac1159a8d8cac74d5eef" title="To allocate reply buffer for req.">alloc_repbuf</a>(ctx-&gt;cc_sec, req, msgsize));
<a name="l01722"></a>01722 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga2059ff503d15d0b06699e153845bc66f_icgraph.png" border="0" usemap="#group__sptlrpc_ga2059ff503d15d0b06699e153845bc66f_icgraph_map" alt=""></div>
<map name="group__sptlrpc_ga2059ff503d15d0b06699e153845bc66f_icgraph_map" id="group__sptlrpc_ga2059ff503d15d0b06699e153845bc66f_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="229,84,336,113"/><area shape="rect" id="node5" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="384,84,523,113"/><area shape="rect" id="node7" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="945,56,1089,85"/><area shape="rect" id="node9" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="572,109,697,139"/><area shape="rect" id="node11" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="747,109,893,139"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="943,109,1092,139"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="949,163,1085,192"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1143,109,1289,139"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1372,29,1492,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1340,83,1524,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1824,108,2067,137"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1361,187,1503,216"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1575,29,1775,59"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1876,29,2015,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1573,83,1776,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2115,108,2291,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaafb426af1f450b0f25952ba1b38f640d"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_alloc_reqbuf" ref="gaafb426af1f450b0f25952ba1b38f640d" args="(struct ptlrpc_request *req, int msgsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_cli_alloc_reqbuf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msgsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc client to allocate request buffer of <em>req</em>. </p>
<p>Upon return successfully, req-&gt;rq_reqmsg points to a buffer with size <em>msgsize</em>. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01580">1580</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__sec__cops.html#aa41ab203ee2687014b25d0876b7427e5">ptlrpc_sec_cops::alloc_reqbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01083">ptlrpc_request::rq_clrbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01028">ptlrpc_request::rq_pool</a>, <a class="el" href="lustre__net_8h_source.html#l01079">ptlrpc_request::rq_reqbuf</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01581"></a>01581 {
<a name="l01582"></a>01582         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l01583"></a>01583         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l01584"></a>01584         <span class="keywordtype">int</span> rc;
<a name="l01585"></a>01585 
<a name="l01586"></a>01586         LASSERT(ctx);
<a name="l01587"></a>01587         LASSERT(ctx-&gt;cc_sec);
<a name="l01588"></a>01588         LASSERT(ctx-&gt;cc_sec-&gt;ps_policy);
<a name="l01589"></a>01589         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> == NULL);
<a name="l01590"></a>01590         LASSERT_ATOMIC_POS(&amp;ctx-&gt;cc_refcount);
<a name="l01591"></a>01591 
<a name="l01592"></a>01592         policy = ctx-&gt;cc_sec-&gt;ps_policy;
<a name="l01593"></a>01593         rc = policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#aa41ab203ee2687014b25d0876b7427e5" title="To allocate request buffer for req.">alloc_reqbuf</a>(ctx-&gt;cc_sec, req, msgsize);
<a name="l01594"></a>01594         <span class="keywordflow">if</span> (!rc) {
<a name="l01595"></a>01595                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l01596"></a>01596                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> || req-&gt;<a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d" title="only in priv mode">rq_clrbuf</a>);
<a name="l01597"></a>01597 
<a name="l01598"></a>01598                 <span class="comment">/* zeroing preallocated buffer */</span>
<a name="l01599"></a>01599                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a>)
<a name="l01600"></a>01600                         memset(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, 0, msgsize);
<a name="l01601"></a>01601         }
<a name="l01602"></a>01602 
<a name="l01603"></a>01603         <span class="keywordflow">return</span> rc;
<a name="l01604"></a>01604 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6c05663895d669f077f0369232b46dad"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_ctx_expire" ref="ga6c05663895d669f077f0369232b46dad" args="(struct ptlrpc_cli_ctx *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptlrpc_cli_ctx_expire </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expire the client context immediately. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Caller must hold at least 1 reference on the <em>ctx</em>. </dd></dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l00322">322</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__ctx__ops.html#a87347673c61d50fb34d358829bcff5ae">ptlrpc_ctx_ops::die</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00323"></a>00323 {
<a name="l00324"></a>00324         LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a87347673c61d50fb34d358829bcff5ae" title="Force the ctx to die.">die</a>);
<a name="l00325"></a>00325         ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a87347673c61d50fb34d358829bcff5ae" title="Force the ctx to die.">die</a>(ctx, 0);
<a name="l00326"></a>00326 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae8509673f10f3ba05986d960f5b4a20d"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_ctx_wakeup" ref="gae8509673f10f3ba05986d960f5b4a20d" args="(struct ptlrpc_cli_ctx *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptlrpc_cli_ctx_wakeup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To wake up the threads who are waiting for this client context. </p>
<p>Called after some status change happened on <em>ctx</em>. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l00333">333</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00334"></a>00334 {
<a name="l00335"></a>00335         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, *next;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337         spin_lock(&amp;ctx-&gt;cc_lock);
<a name="l00338"></a>00338         list_for_each_entry_safe(req, next, &amp;ctx-&gt;cc_req_list,
<a name="l00339"></a>00339                                      rq_ctx_chain) {
<a name="l00340"></a>00340                 list_del_init(&amp;req-&gt;rq_ctx_chain);
<a name="l00341"></a>00341                 ptlrpc_client_wake_req(req);
<a name="l00342"></a>00342         }
<a name="l00343"></a>00343         spin_unlock(&amp;ctx-&gt;cc_lock);
<a name="l00344"></a>00344 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae060941c4c97b1cb7ba03904a24b53c3"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_enlarge_reqbuf" ref="gae060941c4c97b1cb7ba03904a24b53c3" args="(struct ptlrpc_request *req, int segment, int newsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_cli_enlarge_reqbuf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>newsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc client to enlarge the <em>segment</em> of request message pointed by req-&gt;rq_reqmsg to size <em>newsize</em>, all previously filled-in data will be preserved after the enlargement. </p>
<p>this must be called after original request buffer being allocated.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>after this be called, rq_reqmsg and rq_reqlen might have been changed, so caller should refresh its local pointers if needed. </dd></dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01681">1681</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__sec__cops.html#a67af7eed6f87fb433e01dc500814723f">ptlrpc_sec_cops::enlarge_reqbuf</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01683"></a>01683 {
<a name="l01684"></a>01684         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>    *ctx = req-&gt;rq_cli_ctx;
<a name="l01685"></a>01685         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__cops.html" title="client side policy operation vector.">ptlrpc_sec_cops</a>   *cops;
<a name="l01686"></a>01686         <span class="keyword">struct </span>lustre_msg        *msg = req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>;
<a name="l01687"></a>01687 
<a name="l01688"></a>01688         LASSERT(ctx);
<a name="l01689"></a>01689         LASSERT(msg);
<a name="l01690"></a>01690         LASSERT(msg-&gt;lm_bufcount &gt; segment);
<a name="l01691"></a>01691         LASSERT(msg-&gt;lm_buflens[segment] &lt;= newsize);
<a name="l01692"></a>01692 
<a name="l01693"></a>01693         <span class="keywordflow">if</span> (msg-&gt;lm_buflens[segment] == newsize)
<a name="l01694"></a>01694                 <span class="keywordflow">return</span> 0;
<a name="l01695"></a>01695 
<a name="l01696"></a>01696         cops = ctx-&gt;cc_sec-&gt;ps_policy-&gt;sp_cops;
<a name="l01697"></a>01697         LASSERT(cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a67af7eed6f87fb433e01dc500814723f" title="To expand the request buffer of req, thus the segment in the request message pointed...">enlarge_reqbuf</a>);
<a name="l01698"></a>01698         <span class="keywordflow">return</span> cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a67af7eed6f87fb433e01dc500814723f" title="To expand the request buffer of req, thus the segment in the request message pointed...">enlarge_reqbuf</a>(ctx-&gt;cc_sec, req, segment, newsize);
<a name="l01699"></a>01699 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9e900c41f0c033d65d6a108d1a1a553c"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_finish_early_reply" ref="ga9e900c41f0c033d65d6a108d1a1a553c" args="(struct ptlrpc_request *early_req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptlrpc_cli_finish_early_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>early_req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc client, to release a processed early reply <em>early_req</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>early_req</em> was obtained from calling <a class="el" href="group__sptlrpc.html#ga555969de6cd1c126c5a8887b740e1354" title="Used by ptlrpc client, to perform security transformation upon the early reply message...">sptlrpc_cli_unwrap_early_reply()</a>. </dd></dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01221">1221</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01080">ptlrpc_request::rq_repbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01081">ptlrpc_request::rq_repdata</a>, and <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01222"></a>01222 {
<a name="l01223"></a>01223         LASSERT(early_req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>);
<a name="l01224"></a>01224         LASSERT(early_req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a>);
<a name="l01225"></a>01225         LASSERT(early_req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l01226"></a>01226 
<a name="l01227"></a>01227         sptlrpc_cli_ctx_put(early_req-&gt;rq_cli_ctx, 1);
<a name="l01228"></a>01228         OBD_FREE_LARGE(early_req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>, early_req-&gt;rq_repbuf_len);
<a name="l01229"></a>01229         ptlrpc_request_cache_free(early_req);
<a name="l01230"></a>01230 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6cd89bd371e4a81930e260bb1b8c79f8"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_free_repbuf" ref="ga6cd89bd371e4a81930e260bb1b8c79f8" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptlrpc_cli_free_repbuf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc client to free reply buffer of <em>req</em>. </p>
<p>After this req-&gt;rq_repmsg is set to NULL and should not be accessed anymore. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01728">1728</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__sec__cops.html#ae72ed3fbdbb93a9fb7d08931fd536082">ptlrpc_sec_cops::free_repbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01080">ptlrpc_request::rq_repbuf</a>, and <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01729"></a>01729 {
<a name="l01730"></a>01730         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l01731"></a>01731         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l01732"></a>01732         ENTRY;
<a name="l01733"></a>01733 
<a name="l01734"></a>01734         LASSERT(ctx);
<a name="l01735"></a>01735         LASSERT(ctx-&gt;cc_sec);
<a name="l01736"></a>01736         LASSERT(ctx-&gt;cc_sec-&gt;ps_policy);
<a name="l01737"></a>01737         LASSERT_ATOMIC_POS(&amp;ctx-&gt;cc_refcount);
<a name="l01738"></a>01738 
<a name="l01739"></a>01739         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a> == NULL)
<a name="l01740"></a>01740                 <span class="keywordflow">return</span>;
<a name="l01741"></a>01741         LASSERT(req-&gt;rq_repbuf_len);
<a name="l01742"></a>01742 
<a name="l01743"></a>01743         policy = ctx-&gt;cc_sec-&gt;ps_policy;
<a name="l01744"></a>01744         policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#ae72ed3fbdbb93a9fb7d08931fd536082" title="To free reply buffer for req.">free_repbuf</a>(ctx-&gt;cc_sec, req);
<a name="l01745"></a>01745         req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> = NULL;
<a name="l01746"></a>01746         EXIT;
<a name="l01747"></a>01747 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2f36863ed408b2fc13f7a04eb6280dd4"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_free_reqbuf" ref="ga2f36863ed408b2fc13f7a04eb6280dd4" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptlrpc_cli_free_reqbuf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc client to free request buffer of <em>req</em>. </p>
<p>After this req-&gt;rq_reqmsg is set to NULL and should not be accessed anymore. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01610">1610</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__sec__cops.html#a1ccde999a88cf1028d6e9f7106c3fdf3">ptlrpc_sec_cops::free_reqbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01083">ptlrpc_request::rq_clrbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01079">ptlrpc_request::rq_reqbuf</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01611"></a>01611 {
<a name="l01612"></a>01612         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l01613"></a>01613         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l01614"></a>01614 
<a name="l01615"></a>01615         LASSERT(ctx);
<a name="l01616"></a>01616         LASSERT(ctx-&gt;cc_sec);
<a name="l01617"></a>01617         LASSERT(ctx-&gt;cc_sec-&gt;ps_policy);
<a name="l01618"></a>01618         LASSERT_ATOMIC_POS(&amp;ctx-&gt;cc_refcount);
<a name="l01619"></a>01619 
<a name="l01620"></a>01620         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> == NULL &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d" title="only in priv mode">rq_clrbuf</a> == NULL)
<a name="l01621"></a>01621                 <span class="keywordflow">return</span>;
<a name="l01622"></a>01622 
<a name="l01623"></a>01623         policy = ctx-&gt;cc_sec-&gt;ps_policy;
<a name="l01624"></a>01624         policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a1ccde999a88cf1028d6e9f7106c3fdf3" title="To free request buffer for req.">free_reqbuf</a>(ctx-&gt;cc_sec, req);
<a name="l01625"></a>01625         req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> = NULL;
<a name="l01626"></a>01626 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga40f686bb862f149e189cf81f3a51a7c3"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_unwrap_bulk_read" ref="ga40f686bb862f149e189cf81f3a51a7c3" args="(struct ptlrpc_request *req, struct ptlrpc_bulk_desc *desc, int nob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_cli_unwrap_bulk_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nob</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is called after unwrap the reply message. </p>
<p>return nob of actual plain text size received, or error code. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l02286">2286</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e">ptlrpc_ctx_ops::unwrap_bulk</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02289"></a>02289 {
<a name="l02290"></a>02290         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>  *ctx;
<a name="l02291"></a>02291         <span class="keywordtype">int</span>                     rc;
<a name="l02292"></a>02292 
<a name="l02293"></a>02293         LASSERT(req-&gt;rq_bulk_read &amp;&amp; !req-&gt;rq_bulk_write);
<a name="l02294"></a>02294 
<a name="l02295"></a>02295         <span class="keywordflow">if</span> (!req-&gt;rq_pack_bulk)
<a name="l02296"></a>02296                 <span class="keywordflow">return</span> desc-&gt;bd_nob_transferred;
<a name="l02297"></a>02297 
<a name="l02298"></a>02298         ctx = req-&gt;rq_cli_ctx;
<a name="l02299"></a>02299         <span class="keywordflow">if</span> (ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e" title="Unwrap bulk reply data.">unwrap_bulk</a>) {
<a name="l02300"></a>02300                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e" title="Unwrap bulk reply data.">unwrap_bulk</a>(ctx, req, desc);
<a name="l02301"></a>02301                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02302"></a>02302                         <span class="keywordflow">return</span> rc;
<a name="l02303"></a>02303         }
<a name="l02304"></a>02304         <span class="keywordflow">return</span> desc-&gt;bd_nob_transferred;
<a name="l02305"></a>02305 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4a0448bc155a2dd383e108188f99beec"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_unwrap_bulk_write" ref="ga4a0448bc155a2dd383e108188f99beec" args="(struct ptlrpc_request *req, struct ptlrpc_bulk_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_cli_unwrap_bulk_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is called after unwrap the reply message. </p>
<p>return 0 for success or error code. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l02312">2312</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e">ptlrpc_ctx_ops::unwrap_bulk</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02314"></a>02314 {
<a name="l02315"></a>02315         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>  *ctx;
<a name="l02316"></a>02316         <span class="keywordtype">int</span>                     rc;
<a name="l02317"></a>02317 
<a name="l02318"></a>02318         LASSERT(!req-&gt;rq_bulk_read &amp;&amp; req-&gt;rq_bulk_write);
<a name="l02319"></a>02319 
<a name="l02320"></a>02320         <span class="keywordflow">if</span> (!req-&gt;rq_pack_bulk)
<a name="l02321"></a>02321                 <span class="keywordflow">return</span> 0;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323         ctx = req-&gt;rq_cli_ctx;
<a name="l02324"></a>02324         <span class="keywordflow">if</span> (ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e" title="Unwrap bulk reply data.">unwrap_bulk</a>) {
<a name="l02325"></a>02325                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e" title="Unwrap bulk reply data.">unwrap_bulk</a>(ctx, req, desc);
<a name="l02326"></a>02326                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02327"></a>02327                         <span class="keywordflow">return</span> rc;
<a name="l02328"></a>02328         }
<a name="l02329"></a>02329 
<a name="l02330"></a>02330         <span class="comment">/*</span>
<a name="l02331"></a>02331 <span class="comment">         * if everything is going right, nob should equals to nob_transferred.</span>
<a name="l02332"></a>02332 <span class="comment">         * in case of privacy mode, nob_transferred needs to be adjusted.</span>
<a name="l02333"></a>02333 <span class="comment">         */</span>
<a name="l02334"></a>02334         <span class="keywordflow">if</span> (desc-&gt;bd_nob != desc-&gt;bd_nob_transferred) {
<a name="l02335"></a>02335                 CERROR(<span class="stringliteral">&quot;nob %d doesn&apos;t match transferred nob %d\n&quot;</span>,
<a name="l02336"></a>02336                        desc-&gt;bd_nob, desc-&gt;bd_nob_transferred);
<a name="l02337"></a>02337                 <span class="keywordflow">return</span> -EPROTO;
<a name="l02338"></a>02338         }
<a name="l02339"></a>02339 
<a name="l02340"></a>02340         <span class="keywordflow">return</span> 0;
<a name="l02341"></a>02341 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga555969de6cd1c126c5a8887b740e1354"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_unwrap_early_reply" ref="ga555969de6cd1c126c5a8887b740e1354" args="(struct ptlrpc_request *req, struct ptlrpc_request **req_ret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_cli_unwrap_early_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> **&nbsp;</td>
          <td class="paramname"> <em>req_ret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc client, to perform security transformation upon the early reply message of <em>req</em>. </p>
<p>We expect the rq_reply_off is 0, and rq_nob_received is the early reply size.</p>
<p>Because the receive buffer might be still posted, the reply data might be changed at any time, no matter we're holding rq_lock or not. For this reason we allocate a separate <a class="el" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> and reply buffer for early reply processing.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success, <em>req_ret</em> is filled with a duplicated <a class="el" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>. Later the caller must call <a class="el" href="group__sptlrpc.html#ga9e900c41f0c033d65d6a108d1a1a553c" title="Used by ptlrpc client, to release a processed early reply early_req.">sptlrpc_cli_finish_early_reply()</a> on the returned <em>*req_ret</em> to release it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ev</em>&nbsp;</td><td>error number, and <em>req_ret</em> will not be set. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01130">1130</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00059">D_ADAPTTO</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="lustre__net_8h_source.html#l01055">ptlrpc_request::rq_flvr</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01022">ptlrpc_request::rq_nob_received</a>, <a class="el" href="lustre__net_8h_source.html#l01080">ptlrpc_request::rq_repbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01081">ptlrpc_request::rq_repdata</a>, <a class="el" href="lustre__net_8h_source.html#l01092">ptlrpc_request::rq_reply_off</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01132"></a>01132 {
<a name="l01133"></a>01133         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>  *early_req;
<a name="l01134"></a>01134         <span class="keywordtype">char</span>                   *early_buf;
<a name="l01135"></a>01135         <span class="keywordtype">int</span>                     early_bufsz, early_size;
<a name="l01136"></a>01136         <span class="keywordtype">int</span>                     rc;
<a name="l01137"></a>01137         ENTRY;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         early_req = ptlrpc_request_cache_alloc(GFP_NOFS);
<a name="l01140"></a>01140         <span class="keywordflow">if</span> (early_req == NULL)
<a name="l01141"></a>01141                 RETURN(-ENOMEM);
<a name="l01142"></a>01142 
<a name="l01143"></a>01143         ptlrpc_cli_req_init(early_req);
<a name="l01144"></a>01144 
<a name="l01145"></a>01145         early_size = req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>;
<a name="l01146"></a>01146         early_bufsz = size_roundup_power2(early_size);
<a name="l01147"></a>01147         OBD_ALLOC_LARGE(early_buf, early_bufsz);
<a name="l01148"></a>01148         <span class="keywordflow">if</span> (early_buf == NULL)
<a name="l01149"></a>01149                 GOTO(err_req, rc = -ENOMEM);
<a name="l01150"></a>01150 
<a name="l01151"></a>01151         <span class="comment">/* sanity checkings and copy data out, do it inside spinlock */</span>
<a name="l01152"></a>01152         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01153"></a>01153 
<a name="l01154"></a>01154         <span class="keywordflow">if</span> (req-&gt;rq_replied) {
<a name="l01155"></a>01155                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01156"></a>01156                 GOTO(err_buf, rc = -EALREADY);
<a name="l01157"></a>01157         }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>);
<a name="l01160"></a>01160         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> == NULL);
<a name="l01161"></a>01161         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> == NULL);
<a name="l01162"></a>01162 
<a name="l01163"></a>01163         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a> != 0) {
<a name="l01164"></a>01164                 CERROR(<span class="stringliteral">&quot;early reply with offset %u\n&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a>);
<a name="l01165"></a>01165                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01166"></a>01166                 GOTO(err_buf, rc = -EPROTO);
<a name="l01167"></a>01167         }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a> != early_size) {
<a name="l01170"></a>01170                 <span class="comment">/* even another early arrived the size should be the same */</span>
<a name="l01171"></a>01171                 CERROR(<span class="stringliteral">&quot;data size has changed from %u to %u\n&quot;</span>,
<a name="l01172"></a>01172                        early_size, req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>);
<a name="l01173"></a>01173                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01174"></a>01174                 GOTO(err_buf, rc = -EINVAL);
<a name="l01175"></a>01175         }
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a> &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> lustre_msg)) {
<a name="l01178"></a>01178                 CERROR(<span class="stringliteral">&quot;early reply length %d too small\n&quot;</span>,
<a name="l01179"></a>01179                        req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>);
<a name="l01180"></a>01180                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01181"></a>01181                 GOTO(err_buf, rc = -EALREADY);
<a name="l01182"></a>01182         }
<a name="l01183"></a>01183 
<a name="l01184"></a>01184         memcpy(early_buf, req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>, early_size);
<a name="l01185"></a>01185         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01186"></a>01186 
<a name="l01187"></a>01187         early_req-&gt;rq_cli_ctx = sptlrpc_cli_ctx_get(req-&gt;rq_cli_ctx);
<a name="l01188"></a>01188         early_req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a> = req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>;
<a name="l01189"></a>01189         early_req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a> = early_buf;
<a name="l01190"></a>01190         early_req-&gt;rq_repbuf_len = early_bufsz;
<a name="l01191"></a>01191         early_req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> = (<span class="keyword">struct </span>lustre_msg *) early_buf;
<a name="l01192"></a>01192         early_req-&gt;rq_repdata_len = early_size;
<a name="l01193"></a>01193         early_req-&gt;rq_early = 1;
<a name="l01194"></a>01194         early_req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> = req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>;
<a name="l01195"></a>01195 
<a name="l01196"></a>01196         rc = do_cli_unwrap_reply(early_req);
<a name="l01197"></a>01197         <span class="keywordflow">if</span> (rc) {
<a name="l01198"></a>01198                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a>, early_req,
<a name="l01199"></a>01199                           <span class="stringliteral">&quot;error %d unwrap early reply&quot;</span>, rc);
<a name="l01200"></a>01200                 GOTO(err_ctx, rc);
<a name="l01201"></a>01201         }
<a name="l01202"></a>01202 
<a name="l01203"></a>01203         LASSERT(early_req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l01204"></a>01204         *req_ret = early_req;
<a name="l01205"></a>01205         RETURN(0);
<a name="l01206"></a>01206 
<a name="l01207"></a>01207 err_ctx:
<a name="l01208"></a>01208         sptlrpc_cli_ctx_put(early_req-&gt;rq_cli_ctx, 1);
<a name="l01209"></a>01209 err_buf:
<a name="l01210"></a>01210         OBD_FREE_LARGE(early_buf, early_bufsz);
<a name="l01211"></a>01211 err_req:
<a name="l01212"></a>01212         ptlrpc_request_cache_free(early_req);
<a name="l01213"></a>01213         RETURN(rc);
<a name="l01214"></a>01214 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4e652d7f03a8727b8eb9c290936aec23"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_unwrap_reply" ref="ga4e652d7f03a8727b8eb9c290936aec23" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_cli_unwrap_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc client, to perform security transformation upon the reply message of <em>req</em>. </p>
<p>After return successfully, req-&gt;rq_repmsg points to the reply message in clear text.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>the reply buffer should have been un-posted from LNet, so nothing is going to change. </dd></dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01090">1090</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01022">ptlrpc_request::rq_nob_received</a>, <a class="el" href="lustre__net_8h_source.html#l01080">ptlrpc_request::rq_repbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01081">ptlrpc_request::rq_repdata</a>, <a class="el" href="lustre__net_8h_source.html#l01092">ptlrpc_request::rq_reply_off</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01091"></a>01091 {
<a name="l01092"></a>01092         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>);
<a name="l01093"></a>01093         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> == NULL);
<a name="l01094"></a>01094         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> == NULL);
<a name="l01095"></a>01095         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a> + req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a> &lt;= req-&gt;rq_repbuf_len);
<a name="l01096"></a>01096 
<a name="l01097"></a>01097         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a> == 0 &amp;&amp;
<a name="l01098"></a>01098             (lustre_msghdr_get_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; MSGHDR_AT_SUPPORT)) {
<a name="l01099"></a>01099                 CERROR(<span class="stringliteral">&quot;real reply with offset 0\n&quot;</span>);
<a name="l01100"></a>01100                 <span class="keywordflow">return</span> -EPROTO;
<a name="l01101"></a>01101         }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a> % 8 != 0) {
<a name="l01104"></a>01104                 CERROR(<span class="stringliteral">&quot;reply at odd offset %u\n&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a>);
<a name="l01105"></a>01105                 <span class="keywordflow">return</span> -EPROTO;
<a name="l01106"></a>01106         }
<a name="l01107"></a>01107 
<a name="l01108"></a>01108         req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> = (<span class="keyword">struct </span>lustre_msg *)
<a name="l01109"></a>01109                                 (req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a> + req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a>);
<a name="l01110"></a>01110         req-&gt;rq_repdata_len = req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>;
<a name="l01111"></a>01111 
<a name="l01112"></a>01112         <span class="keywordflow">return</span> do_cli_unwrap_reply(req);
<a name="l01113"></a>01113 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae9ac9239c38fc5eb10c0951976a38512"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_wrap_bulk" ref="gae9ac9239c38fc5eb10c0951976a38512" args="(struct ptlrpc_request *req, struct ptlrpc_bulk_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_cli_wrap_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform transformation upon bulk data pointed by <em>desc</em>. </p>
<p>This is called before transforming the request message. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l02265">2265</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__ctx__ops.html#a1440abe65b4eac150d2f52c160582631">ptlrpc_ctx_ops::wrap_bulk</a>.</p>

<p>Referenced by <a class="el" href="sec_8c_source.html#l00978">sptlrpc_cli_wrap_request()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02267"></a>02267 {
<a name="l02268"></a>02268         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx;
<a name="l02269"></a>02269 
<a name="l02270"></a>02270         LASSERT(req-&gt;rq_bulk_read || req-&gt;rq_bulk_write);
<a name="l02271"></a>02271 
<a name="l02272"></a>02272         <span class="keywordflow">if</span> (!req-&gt;rq_pack_bulk)
<a name="l02273"></a>02273                 <span class="keywordflow">return</span> 0;
<a name="l02274"></a>02274 
<a name="l02275"></a>02275         ctx = req-&gt;rq_cli_ctx;
<a name="l02276"></a>02276         <span class="keywordflow">if</span> (ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a1440abe65b4eac150d2f52c160582631" title="Wrap bulk request data.">wrap_bulk</a>)
<a name="l02277"></a>02277                 <span class="keywordflow">return</span> ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a1440abe65b4eac150d2f52c160582631" title="Wrap bulk request data.">wrap_bulk</a>(ctx, req, desc);
<a name="l02278"></a>02278         <span class="keywordflow">return</span> 0;
<a name="l02279"></a>02279 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_gae9ac9239c38fc5eb10c0951976a38512_icgraph.png" border="0" usemap="#group__sptlrpc_gae9ac9239c38fc5eb10c0951976a38512_icgraph_map" alt=""></div>
<map name="group__sptlrpc_gae9ac9239c38fc5eb10c0951976a38512_icgraph_map" id="group__sptlrpc_gae9ac9239c38fc5eb10c0951976a38512_icgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre&#45;defined security transformation upon the..." alt="" coords="217,84,404,113"/><area shape="rect" id="node5" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="453,84,560,113"/><area shape="rect" id="node7" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="608,84,747,113"/><area shape="rect" id="node9" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="1169,56,1313,85"/><area shape="rect" id="node11" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="796,109,921,139"/><area shape="rect" id="node13" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="971,109,1117,139"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="1167,109,1316,139"/><area shape="rect" id="node38" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="1173,163,1309,192"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1367,109,1513,139"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1596,29,1716,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1564,83,1748,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="2048,108,2291,137"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1585,187,1727,216"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1799,29,1999,59"/><area shape="rect" id="node24" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="2100,29,2239,59"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1797,83,2000,112"/><area shape="rect" id="node33" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2339,108,2515,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga2b508842c18d6c0a32c9678445565ce2"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_cli_wrap_request" ref="ga2b508842c18d6c0a32c9678445565ce2" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_cli_wrap_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc client, to perform the pre-defined security transformation upon the request message of <em>req</em>. </p>
<p>After this function called, req-&gt;rq_reqmsg is still accessible as clear text. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l00978">978</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01083">ptlrpc_request::rq_clrbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01055">ptlrpc_request::rq_flvr</a>, <a class="el" href="lustre__net_8h_source.html#l01079">ptlrpc_request::rq_reqbuf</a>, <a class="el" href="structptlrpc__ctx__ops.html#a21b8b702790d8794111c70b0d81529dc">ptlrpc_ctx_ops::seal</a>, <a class="el" href="lustre__sec_8h_source.html#l00292">sptlrpc_flavor::sf_rpc</a>, <a class="el" href="structptlrpc__ctx__ops.html#a56a7044b0eb1b542f387d61fb0f2c2c9">ptlrpc_ctx_ops::sign</a>, <a class="el" href="sec_8c_source.html#l02265">sptlrpc_cli_wrap_bulk()</a>, <a class="el" href="lustre__sec_8h_source.html#l00113">SPTLRPC_SVC_AUTH</a>, <a class="el" href="lustre__sec_8h_source.html#l00114">SPTLRPC_SVC_INTG</a>, <a class="el" href="lustre__sec_8h_source.html#l00112">SPTLRPC_SVC_NULL</a>, and <a class="el" href="lustre__sec_8h_source.html#l00115">SPTLRPC_SVC_PRIV</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00979"></a>00979 {
<a name="l00980"></a>00980         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l00981"></a>00981         <span class="keywordtype">int</span> rc = 0;
<a name="l00982"></a>00982         ENTRY;
<a name="l00983"></a>00983 
<a name="l00984"></a>00984         LASSERT(ctx);
<a name="l00985"></a>00985         LASSERT(ctx-&gt;cc_sec);
<a name="l00986"></a>00986         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> || req-&gt;<a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d" title="only in priv mode">rq_clrbuf</a>);
<a name="l00987"></a>00987 
<a name="l00988"></a>00988         <span class="comment">/* we wrap bulk request here because now we can be sure</span>
<a name="l00989"></a>00989 <span class="comment">         * the context is uptodate.</span>
<a name="l00990"></a>00990 <span class="comment">         */</span>
<a name="l00991"></a>00991         <span class="keywordflow">if</span> (req-&gt;rq_bulk) {
<a name="l00992"></a>00992                 rc = <a class="code" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc.">sptlrpc_cli_wrap_bulk</a>(req, req-&gt;rq_bulk);
<a name="l00993"></a>00993                 <span class="keywordflow">if</span> (rc)
<a name="l00994"></a>00994                         RETURN(rc);
<a name="l00995"></a>00995         }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997         <span class="keywordflow">switch</span> (SPTLRPC_FLVR_SVC(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>)) {
<a name="l00998"></a>00998         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa9962cb9ccc8b90b4c67ada0e7b00210b" title="no security">SPTLRPC_SVC_NULL</a>:
<a name="l00999"></a>00999         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa691acc99dba7191db4f6c2e177331e30" title="authentication only">SPTLRPC_SVC_AUTH</a>:
<a name="l01000"></a>01000         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa74b1cc494dcf8dbf001b3a19e8790fd9" title="integrity">SPTLRPC_SVC_INTG</a>:
<a name="l01001"></a>01001                 LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a56a7044b0eb1b542f387d61fb0f2c2c9" title="Sign the request message using ctx.">sign</a>);
<a name="l01002"></a>01002                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a56a7044b0eb1b542f387d61fb0f2c2c9" title="Sign the request message using ctx.">sign</a>(ctx, req);
<a name="l01003"></a>01003                 <span class="keywordflow">break</span>;
<a name="l01004"></a>01004         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa1baf868991ad935c71ceb65c53389564" title="privacy">SPTLRPC_SVC_PRIV</a>:
<a name="l01005"></a>01005                 LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a21b8b702790d8794111c70b0d81529dc" title="Encrypt the request message using ctx.">seal</a>);
<a name="l01006"></a>01006                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a21b8b702790d8794111c70b0d81529dc" title="Encrypt the request message using ctx.">seal</a>(ctx, req);
<a name="l01007"></a>01007                 <span class="keywordflow">break</span>;
<a name="l01008"></a>01008         <span class="keywordflow">default</span>:
<a name="l01009"></a>01009                 LBUG();
<a name="l01010"></a>01010         }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01013"></a>01013                 LASSERT(req-&gt;rq_reqdata_len);
<a name="l01014"></a>01014                 LASSERT(req-&gt;rq_reqdata_len % 8 == 0);
<a name="l01015"></a>01015                 LASSERT(req-&gt;rq_reqdata_len &lt;= req-&gt;rq_reqbuf_len);
<a name="l01016"></a>01016         }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018         RETURN(rc);
<a name="l01019"></a>01019 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga2b508842c18d6c0a32c9678445565ce2_cgraph.png" border="0" usemap="#group__sptlrpc_ga2b508842c18d6c0a32c9678445565ce2_cgraph_map" alt=""></div>
<map name="group__sptlrpc_ga2b508842c18d6c0a32c9678445565ce2_cgraph_map" id="group__sptlrpc_ga2b508842c18d6c0a32c9678445565ce2_cgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc." alt="" coords="244,5,404,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga2b508842c18d6c0a32c9678445565ce2_icgraph.png" border="0" usemap="#group__sptlrpc_ga2b508842c18d6c0a32c9678445565ce2_icgraph_map" alt=""></div>
<map name="group__sptlrpc_ga2b508842c18d6c0a32c9678445565ce2_icgraph_map" id="group__sptlrpc_ga2b508842c18d6c0a32c9678445565ce2_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="243,84,349,113"/><area shape="rect" id="node5" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="397,84,536,113"/><area shape="rect" id="node7" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="959,56,1103,85"/><area shape="rect" id="node9" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="585,109,711,139"/><area shape="rect" id="node11" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="760,109,907,139"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="956,109,1105,139"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="963,163,1099,192"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1156,109,1303,139"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1385,29,1505,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1353,83,1537,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1837,108,2080,137"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1375,187,1516,216"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1588,29,1788,59"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1889,29,2028,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1587,83,1789,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2128,108,2304,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa43ec50fcb7c93e96d80c8b544da92a5"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_import_check_ctx" ref="gaa43ec50fcb7c93e96d80c8b544da92a5" args="(struct obd_import *imp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_import_check_ctx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an import <em>imp</em>, check whether current user has a valid context or not. </p>
<p>We may create a new context and try to refresh it, and try repeatedly try in case of non-fatal errors. Return 0 means success. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l00926">926</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01055">ptlrpc_request::rq_flvr</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01016">ptlrpc_request::rq_refcount</a>, <a class="el" href="sec_8c_source.html#l00675">sptlrpc_req_refresh_ctx()</a>, and <a class="el" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255">ptlrpc_ctx_ops::validate</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l01370">ldlm_lock_match()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00927"></a>00927 {
<a name="l00928"></a>00928         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>     *sec;
<a name="l00929"></a>00929         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx;
<a name="l00930"></a>00930         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = NULL;
<a name="l00931"></a>00931         <span class="keywordtype">int</span> rc;
<a name="l00932"></a>00932         ENTRY;
<a name="l00933"></a>00933 
<a name="l00934"></a>00934         might_sleep();
<a name="l00935"></a>00935 
<a name="l00936"></a>00936         sec = sptlrpc_import_sec_ref(imp);
<a name="l00937"></a>00937         ctx = get_my_ctx(sec);
<a name="l00938"></a>00938         sptlrpc_sec_put(sec);
<a name="l00939"></a>00939 
<a name="l00940"></a>00940         <span class="keywordflow">if</span> (!ctx)
<a name="l00941"></a>00941                 RETURN(-ENOMEM);
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <span class="keywordflow">if</span> (cli_ctx_is_eternal(ctx) ||
<a name="l00944"></a>00944             ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255" title="Validate the ctx.">validate</a>(ctx) == 0) {
<a name="l00945"></a>00945                 sptlrpc_cli_ctx_put(ctx, 1);
<a name="l00946"></a>00946                 RETURN(0);
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         <span class="keywordflow">if</span> (cli_ctx_is_error(ctx)) {
<a name="l00950"></a>00950                 sptlrpc_cli_ctx_put(ctx, 1);
<a name="l00951"></a>00951                 RETURN(-EACCES);
<a name="l00952"></a>00952         }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         req = ptlrpc_request_cache_alloc(GFP_NOFS);
<a name="l00955"></a>00955         <span class="keywordflow">if</span> (!req)
<a name="l00956"></a>00956                 RETURN(-ENOMEM);
<a name="l00957"></a>00957 
<a name="l00958"></a>00958         ptlrpc_cli_req_init(req);
<a name="l00959"></a>00959         atomic_set(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>, 10000);
<a name="l00960"></a>00960 
<a name="l00961"></a>00961         req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a> = imp;
<a name="l00962"></a>00962         req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a> = sec-&gt;ps_flvr;
<a name="l00963"></a>00963         req-&gt;rq_cli_ctx = ctx;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965         rc = <a class="code" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&amp;#39;s not up-to-date.">sptlrpc_req_refresh_ctx</a>(req, 0);
<a name="l00966"></a>00966         LASSERT(list_empty(&amp;req-&gt;rq_ctx_chain));
<a name="l00967"></a>00967         sptlrpc_cli_ctx_put(req-&gt;rq_cli_ctx, 1);
<a name="l00968"></a>00968         ptlrpc_request_cache_free(req);
<a name="l00969"></a>00969 
<a name="l00970"></a>00970         RETURN(rc);
<a name="l00971"></a>00971 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_gaa43ec50fcb7c93e96d80c8b544da92a5_cgraph.png" border="0" usemap="#group__sptlrpc_gaa43ec50fcb7c93e96d80c8b544da92a5_cgraph_map" alt=""></div>
<map name="group__sptlrpc_gaa43ec50fcb7c93e96d80c8b544da92a5_cgraph_map" id="group__sptlrpc_gaa43ec50fcb7c93e96d80c8b544da92a5_cgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="252,32,433,61"/><area shape="rect" id="node5" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="483,32,707,61"/><area shape="rect" id="node7" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="756,5,913,35"/><area shape="rect" id="node9" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="756,59,913,88"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_gaa43ec50fcb7c93e96d80c8b544da92a5_icgraph.png" border="0" usemap="#group__sptlrpc_gaa43ec50fcb7c93e96d80c8b544da92a5_icgraph_map" alt=""></div>
<map name="group__sptlrpc_gaa43ec50fcb7c93e96d80c8b544da92a5_icgraph_map" id="group__sptlrpc_gaa43ec50fcb7c93e96d80c8b544da92a5_icgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga1373811e4c4edbb039f1da1ca7947b03" title="Attempt to find a lock with specified properties." alt="" coords="251,5,384,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga01235b3d6bd59ff6adee314742be930b"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_import_sec_adapt" ref="ga01235b3d6bd59ff6adee314742be930b" args="(struct obd_import *imp, struct ptlrpc_svc_ctx *ctx, struct sptlrpc_flavor *flvr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_import_sec_adapt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *&nbsp;</td>
          <td class="paramname"> <em>svc_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *&nbsp;</td>
          <td class="paramname"> <em>flvr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To get an appropriate <a class="el" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> for the <em>imp</em>, according to the current configuration. </p>
<p>Upon called, imp-&gt;imp_sec may or may not be NULL.</p>
<ul>
<li>regular import: <em>svc_ctx</em> should be NULL and <em>flvr</em> is ignored;</li>
<li>reverse import: <em>svc_ctx</em> and <em>flvr</em> are obtained from incoming request. </li>
</ul>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01438">1438</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l00523">ptlrpc_connection::c_remote_uuid</a>, <a class="el" href="lustre__net_8h_source.html#l00519">ptlrpc_connection::c_self</a>, <a class="el" href="lustre__import_8h_source.html#l00170">obd_import::imp_connection</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__sec_8h_source.html#l00296">sptlrpc_flavor::sf_flags</a>, and <a class="el" href="lustre__sec_8h_source.html#l00292">sptlrpc_flavor::sf_rpc</a>.</p>

<p>Referenced by <a class="el" href="import_8c_source.html#l00648">ptlrpc_connect_import()</a>, and <a class="el" href="sec_8c_source.html#l01797">sptlrpc_target_export_check()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01441"></a>01441 {
<a name="l01442"></a>01442         <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a>   *conn;
<a name="l01443"></a>01443         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a>       sf;
<a name="l01444"></a>01444         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>          *sec, *newsec;
<a name="l01445"></a>01445         <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a>        sp;
<a name="l01446"></a>01446         <span class="keywordtype">char</span>                        str[24];
<a name="l01447"></a>01447         <span class="keywordtype">int</span>                         rc = 0;
<a name="l01448"></a>01448         ENTRY;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450         might_sleep();
<a name="l01451"></a>01451 
<a name="l01452"></a>01452         <span class="keywordflow">if</span> (imp == NULL)
<a name="l01453"></a>01453                 RETURN(0);
<a name="l01454"></a>01454 
<a name="l01455"></a>01455         conn = imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>;
<a name="l01456"></a>01456 
<a name="l01457"></a>01457         <span class="keywordflow">if</span> (svc_ctx == NULL) {
<a name="l01458"></a>01458                 <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *cliobd = &amp;imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;u.cli;
<a name="l01459"></a>01459                 <span class="comment">/*</span>
<a name="l01460"></a>01460 <span class="comment">                 * normal import, determine flavor from rule set, except</span>
<a name="l01461"></a>01461 <span class="comment">                 * for mgc the flavor is predetermined.</span>
<a name="l01462"></a>01462 <span class="comment">                 */</span>
<a name="l01463"></a>01463                 <span class="keywordflow">if</span> (cliobd-&gt;cl_sp_me == LUSTRE_SP_MGC)
<a name="l01464"></a>01464                         sf = cliobd-&gt;cl_flvr_mgc;
<a name="l01465"></a>01465                 <span class="keywordflow">else</span> 
<a name="l01466"></a>01466                         sptlrpc_conf_choose_flavor(cliobd-&gt;cl_sp_me,
<a name="l01467"></a>01467                                                    cliobd-&gt;cl_sp_to,
<a name="l01468"></a>01468                                                    &amp;cliobd-&gt;cl_target_uuid,
<a name="l01469"></a>01469                                                    conn-&gt;<a class="code" href="structptlrpc__connection.html#a002bdb401d67315c931ff672970178b8" title="Our own lnet nid for this connection.">c_self</a>, &amp;sf);
<a name="l01470"></a>01470 
<a name="l01471"></a>01471                 sp = imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;u.cli.cl_sp_me;
<a name="l01472"></a>01472         } <span class="keywordflow">else</span> {
<a name="l01473"></a>01473                 <span class="comment">/* reverse import, determine flavor from incoming reqeust */</span>
<a name="l01474"></a>01474                 sf = *flvr;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476                 <span class="keywordflow">if</span> (sf.sf_rpc != SPTLRPC_FLVR_NULL)
<a name="l01477"></a>01477                         sf.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> = PTLRPC_SEC_FL_REVERSE |
<a name="l01478"></a>01478                                       PTLRPC_SEC_FL_ROOTONLY;
<a name="l01479"></a>01479 
<a name="l01480"></a>01480                 sp = sptlrpc_target_sec_part(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>);
<a name="l01481"></a>01481         }
<a name="l01482"></a>01482 
<a name="l01483"></a>01483         sec = sptlrpc_import_sec_ref(imp);
<a name="l01484"></a>01484         <span class="keywordflow">if</span> (sec) {
<a name="l01485"></a>01485                 <span class="keywordtype">char</span>    str2[24];
<a name="l01486"></a>01486 
<a name="l01487"></a>01487                 <span class="keywordflow">if</span> (flavor_equal(&amp;sf, &amp;sec-&gt;ps_flvr))
<a name="l01488"></a>01488                         GOTO(out, rc);
<a name="l01489"></a>01489 
<a name="l01490"></a>01490                 CDEBUG(D_SEC, <span class="stringliteral">&quot;import %s-&gt;%s: changing flavor %s -&gt; %s\n&quot;</span>,
<a name="l01491"></a>01491                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01492"></a>01492                        obd_uuid2str(&amp;conn-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>),
<a name="l01493"></a>01493                        sptlrpc_flavor2name(&amp;sec-&gt;ps_flvr, str, <span class="keyword">sizeof</span>(str)),
<a name="l01494"></a>01494                        sptlrpc_flavor2name(&amp;sf, str2, <span class="keyword">sizeof</span>(str2)));
<a name="l01495"></a>01495 
<a name="l01496"></a>01496                 <span class="keywordflow">if</span> (SPTLRPC_FLVR_POLICY(sf.sf_rpc) ==
<a name="l01497"></a>01497                     SPTLRPC_FLVR_POLICY(sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) &amp;&amp;
<a name="l01498"></a>01498                     SPTLRPC_FLVR_MECH(sf.sf_rpc) ==
<a name="l01499"></a>01499                     SPTLRPC_FLVR_MECH(sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>)) {
<a name="l01500"></a>01500                         sptlrpc_import_sec_adapt_inplace(imp, sec, &amp;sf);
<a name="l01501"></a>01501                         GOTO(out, rc);
<a name="l01502"></a>01502                 }
<a name="l01503"></a>01503         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SPTLRPC_FLVR_BASE(sf.sf_rpc) !=
<a name="l01504"></a>01504                    SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_NULL)) {
<a name="l01505"></a>01505                 CDEBUG(D_SEC, <span class="stringliteral">&quot;import %s-&gt;%s netid %x: select flavor %s\n&quot;</span>,
<a name="l01506"></a>01506                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01507"></a>01507                        obd_uuid2str(&amp;conn-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>),
<a name="l01508"></a>01508                        LNET_NIDNET(conn-&gt;<a class="code" href="structptlrpc__connection.html#a002bdb401d67315c931ff672970178b8" title="Our own lnet nid for this connection.">c_self</a>),
<a name="l01509"></a>01509                        sptlrpc_flavor2name(&amp;sf, str, <span class="keyword">sizeof</span>(str)));
<a name="l01510"></a>01510         }
<a name="l01511"></a>01511 
<a name="l01512"></a>01512         mutex_lock(&amp;imp-&gt;imp_sec_mutex);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514         newsec = sptlrpc_sec_create(imp, svc_ctx, &amp;sf, sp);
<a name="l01515"></a>01515         <span class="keywordflow">if</span> (newsec) {
<a name="l01516"></a>01516                 sptlrpc_import_sec_install(imp, newsec);
<a name="l01517"></a>01517         } <span class="keywordflow">else</span> {
<a name="l01518"></a>01518                 CERROR(<span class="stringliteral">&quot;import %s-&gt;%s: failed to create new sec\n&quot;</span>,
<a name="l01519"></a>01519                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01520"></a>01520                        obd_uuid2str(&amp;conn-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>));
<a name="l01521"></a>01521                 rc = -EPERM;
<a name="l01522"></a>01522         }
<a name="l01523"></a>01523 
<a name="l01524"></a>01524         mutex_unlock(&amp;imp-&gt;imp_sec_mutex);
<a name="l01525"></a>01525 out:
<a name="l01526"></a>01526         sptlrpc_sec_put(sec);
<a name="l01527"></a>01527         RETURN(rc);
<a name="l01528"></a>01528 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga01235b3d6bd59ff6adee314742be930b_icgraph.png" border="0" usemap="#group__sptlrpc_ga01235b3d6bd59ff6adee314742be930b_icgraph_map" alt=""></div>
<map name="group__sptlrpc_ga01235b3d6bd59ff6adee314742be930b_icgraph_map" id="group__sptlrpc_ga01235b3d6bd59ff6adee314742be930b_icgraph">
<area shape="rect" id="node3" href="group__net.html#gae524031a54066bf23dda2ad572bbcfdf" title="Attempt to (re)connect import imp." alt="" coords="273,5,447,35"/><area shape="rect" id="node5" href="group__sptlrpc.html#gaf12efdd6553013c0e886d356541dd86b" title="Given an export exp, check whether the flavor of incoming req is allowed by the export..." alt="" coords="251,59,469,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga5aafb085a9167ed0295a28d4bddb5847"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_req_get_ctx" ref="ga5aafb085a9167ed0295a28d4bddb5847" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_req_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a <em>req</em>, find or allocate an appropriate context for it. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_cli_ctx == NULL.</dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>succeed, and req-&gt;rq_cli_ctx is set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ev</em>&nbsp;</td><td>error number, and req-&gt;rq_cli_ctx == NULL. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l00425">425</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>.</p>

<p>Referenced by <a class="el" href="sec_8c_source.html#l00549">sptlrpc_req_replace_dead_ctx()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00426"></a>00426 {
<a name="l00427"></a>00427         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l00428"></a>00428         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec;
<a name="l00429"></a>00429         <span class="keywordtype">int</span>                rc;
<a name="l00430"></a>00430         ENTRY;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432         LASSERT(!req-&gt;rq_cli_ctx);
<a name="l00433"></a>00433         LASSERT(imp);
<a name="l00434"></a>00434 
<a name="l00435"></a>00435         rc = import_sec_validate_get(imp, &amp;sec);
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (rc)
<a name="l00437"></a>00437                 RETURN(rc);
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         req-&gt;rq_cli_ctx = get_my_ctx(sec);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         sptlrpc_sec_put(sec);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443         <span class="keywordflow">if</span> (!req-&gt;rq_cli_ctx) {
<a name="l00444"></a>00444                 CERROR(<span class="stringliteral">&quot;req %p: fail to get context\n&quot;</span>, req);
<a name="l00445"></a>00445                 RETURN(-ECONNREFUSED);
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         RETURN(0);
<a name="l00449"></a>00449 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga5aafb085a9167ed0295a28d4bddb5847_icgraph.png" border="0" usemap="#group__sptlrpc_ga5aafb085a9167ed0295a28d4bddb5847_icgraph_map" alt=""></div>
<map name="group__sptlrpc_ga5aafb085a9167ed0295a28d4bddb5847_icgraph_map" id="group__sptlrpc_ga5aafb085a9167ed0295a28d4bddb5847_icgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="213,136,437,165"/><area shape="rect" id="node5" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="487,136,668,165"/><area shape="rect" id="node7" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="747,109,885,139"/><area shape="rect" id="node40" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5" title="Given an import imp, check whether current user has a valid context or not." alt="" coords="719,163,913,192"/><area shape="rect" id="node9" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="1343,56,1487,85"/><area shape="rect" id="node11" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="967,109,1092,139"/><area shape="rect" id="node13" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="1144,109,1291,139"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="1340,109,1489,139"/><area shape="rect" id="node38" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="1347,163,1483,192"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1540,109,1687,139"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1769,29,1889,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1737,83,1921,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="2221,108,2464,137"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1759,187,1900,216"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1972,29,2172,59"/><area shape="rect" id="node24" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="2273,29,2412,59"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1971,83,2173,112"/><area shape="rect" id="node33" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2512,108,2688,137"/><area shape="rect" id="node42" href="group__LDLM.html#ga1373811e4c4edbb039f1da1ca7947b03" title="Attempt to find a lock with specified properties." alt="" coords="963,163,1096,192"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9c506dfa976b8fa42f6d351f1a67098c"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_req_put_ctx" ref="ga9c506dfa976b8fa42f6d351f1a67098c" args="(struct ptlrpc_request *req, int sync)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptlrpc_req_put_ctx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sync</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drop the context for <em>req</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_cli_ctx != NULL. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>req-&gt;rq_cli_ctx == NULL.</dd></dl>
<p>If <em>sync</em> == 0, this function should return quickly without sleep; otherwise it might trigger and wait for the whole process of sending an context-destroying rpc to server. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l00460">460</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>Referenced by <a class="el" href="sec_8c_source.html#l00549">sptlrpc_req_replace_dead_ctx()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00461"></a>00461 {
<a name="l00462"></a>00462         ENTRY;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464         LASSERT(req);
<a name="l00465"></a>00465         LASSERT(req-&gt;rq_cli_ctx);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         <span class="comment">/* request might be asked to release earlier while still</span>
<a name="l00468"></a>00468 <span class="comment">         * in the context waiting list.</span>
<a name="l00469"></a>00469 <span class="comment">         */</span>
<a name="l00470"></a>00470         <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;rq_ctx_chain)) {
<a name="l00471"></a>00471                 spin_lock(&amp;req-&gt;rq_cli_ctx-&gt;cc_lock);
<a name="l00472"></a>00472                 list_del_init(&amp;req-&gt;rq_ctx_chain);
<a name="l00473"></a>00473                 spin_unlock(&amp;req-&gt;rq_cli_ctx-&gt;cc_lock);
<a name="l00474"></a>00474         }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476         sptlrpc_cli_ctx_put(req-&gt;rq_cli_ctx, sync);
<a name="l00477"></a>00477         req-&gt;rq_cli_ctx = NULL;
<a name="l00478"></a>00478         EXIT;
<a name="l00479"></a>00479 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga9c506dfa976b8fa42f6d351f1a67098c_icgraph.png" border="0" usemap="#group__sptlrpc_ga9c506dfa976b8fa42f6d351f1a67098c_icgraph_map" alt=""></div>
<map name="group__sptlrpc_ga9c506dfa976b8fa42f6d351f1a67098c_icgraph_map" id="group__sptlrpc_ga9c506dfa976b8fa42f6d351f1a67098c_icgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="211,136,435,165"/><area shape="rect" id="node5" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="484,136,665,165"/><area shape="rect" id="node7" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="744,109,883,139"/><area shape="rect" id="node40" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5" title="Given an import imp, check whether current user has a valid context or not." alt="" coords="716,163,911,192"/><area shape="rect" id="node9" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="1340,56,1484,85"/><area shape="rect" id="node11" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="964,109,1089,139"/><area shape="rect" id="node13" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="1141,109,1288,139"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="1337,109,1487,139"/><area shape="rect" id="node38" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="1344,163,1480,192"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1537,109,1684,139"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1767,29,1887,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1735,83,1919,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="2219,108,2461,137"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1756,187,1897,216"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1969,29,2169,59"/><area shape="rect" id="node24" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="2271,29,2409,59"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1968,83,2171,112"/><area shape="rect" id="node33" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2509,108,2685,137"/><area shape="rect" id="node42" href="group__LDLM.html#ga1373811e4c4edbb039f1da1ca7947b03" title="Attempt to find a lock with specified properties." alt="" coords="960,163,1093,192"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga94cbed545313e8c7bc6a682a438c89b0"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_req_refresh_ctx" ref="ga94cbed545313e8c7bc6a682a438c89b0" args="(struct ptlrpc_request *req, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_req_refresh_ctx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To refresh the context of , if it's not up-to-date. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td><ul>
<li>&lt; 0: don't wait</li>
<li>= 0: wait until success or fatal error occur</li>
<li>&gt; 0: timeout value (in seconds)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The status of the context could be subject to be changed by other threads at any time. We allow this race, but once we return with 0, the caller will suppose it's uptodated and keep using it until the owning rpc is done.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>only if the context is uptodated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ev</em>&nbsp;</td><td>error number. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l00675">675</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__ctx__ops.html#ad2d600893d9bf038f602916ca9419eb8">ptlrpc_ctx_ops::refresh</a>, <a class="el" href="lustre__net_8h_source.html#l01055">ptlrpc_request::rq_flvr</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__sec_8h_source.html#l00292">sptlrpc_flavor::sf_rpc</a>, <a class="el" href="sec_8c_source.html#l00549">sptlrpc_req_replace_dead_ctx()</a>, and <a class="el" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255">ptlrpc_ctx_ops::validate</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, and <a class="el" href="sec_8c_source.html#l00926">sptlrpc_import_check_ctx()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00676"></a>00676 {
<a name="l00677"></a>00677         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>  *ctx = req-&gt;rq_cli_ctx;
<a name="l00678"></a>00678         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>      *sec;
<a name="l00679"></a>00679         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>      lwi;
<a name="l00680"></a>00680         <span class="keywordtype">int</span>                     rc;
<a name="l00681"></a>00681         ENTRY;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         LASSERT(ctx);
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="keywordflow">if</span> (req-&gt;rq_ctx_init || req-&gt;rq_ctx_fini)
<a name="l00686"></a>00686                 RETURN(0);
<a name="l00687"></a>00687 
<a name="l00688"></a>00688         <span class="comment">/*</span>
<a name="l00689"></a>00689 <span class="comment">         * during the process a request&apos;s context might change type even</span>
<a name="l00690"></a>00690 <span class="comment">         * (e.g. from gss ctx to null ctx), so each loop we need to re-check</span>
<a name="l00691"></a>00691 <span class="comment">         * everything</span>
<a name="l00692"></a>00692 <span class="comment">         */</span>
<a name="l00693"></a>00693 again:
<a name="l00694"></a>00694         rc = import_sec_validate_get(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>, &amp;sec);
<a name="l00695"></a>00695         <span class="keywordflow">if</span> (rc)
<a name="l00696"></a>00696                 RETURN(rc);
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         <span class="keywordflow">if</span> (sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a> != req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) {
<a name="l00699"></a>00699                 CDEBUG(D_SEC, <span class="stringliteral">&quot;req %p: flavor has changed %x -&gt; %x\n&quot;</span>,
<a name="l00700"></a>00700                       req, req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l00701"></a>00701                 req_off_ctx_list(req, ctx);
<a name="l00702"></a>00702                 <a class="code" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g.">sptlrpc_req_replace_dead_ctx</a>(req);
<a name="l00703"></a>00703                 ctx = req-&gt;rq_cli_ctx;
<a name="l00704"></a>00704         }
<a name="l00705"></a>00705         sptlrpc_sec_put(sec);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707         <span class="keywordflow">if</span> (cli_ctx_is_eternal(ctx))
<a name="l00708"></a>00708                 RETURN(0);
<a name="l00709"></a>00709 
<a name="l00710"></a>00710         <span class="keywordflow">if</span> (unlikely(test_bit(PTLRPC_CTX_NEW_BIT, &amp;ctx-&gt;cc_flags))) {
<a name="l00711"></a>00711                 LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#ad2d600893d9bf038f602916ca9419eb8" title="To bring the ctx uptodate.">refresh</a>);
<a name="l00712"></a>00712                 ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#ad2d600893d9bf038f602916ca9419eb8" title="To bring the ctx uptodate.">refresh</a>(ctx);
<a name="l00713"></a>00713         }
<a name="l00714"></a>00714         LASSERT(test_bit(PTLRPC_CTX_NEW_BIT, &amp;ctx-&gt;cc_flags) == 0);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716         LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255" title="Validate the ctx.">validate</a>);
<a name="l00717"></a>00717         <span class="keywordflow">if</span> (ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255" title="Validate the ctx.">validate</a>(ctx) == 0) {
<a name="l00718"></a>00718                 req_off_ctx_list(req, ctx);
<a name="l00719"></a>00719                 RETURN(0);
<a name="l00720"></a>00720         }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722         <span class="keywordflow">if</span> (unlikely(test_bit(PTLRPC_CTX_ERROR_BIT, &amp;ctx-&gt;cc_flags))) {
<a name="l00723"></a>00723                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00724"></a>00724                 req-&gt;rq_err = 1;
<a name="l00725"></a>00725                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00726"></a>00726                 req_off_ctx_list(req, ctx);
<a name="l00727"></a>00727                 RETURN(-EPERM);
<a name="l00728"></a>00728         }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="comment">/*</span>
<a name="l00731"></a>00731 <span class="comment">         * There&apos;s a subtle issue for resending RPCs, suppose following</span>
<a name="l00732"></a>00732 <span class="comment">         * situation:</span>
<a name="l00733"></a>00733 <span class="comment">         *  1. the request was sent to server.</span>
<a name="l00734"></a>00734 <span class="comment">         *  2. recovery was kicked start, after finished the request was</span>
<a name="l00735"></a>00735 <span class="comment">         *     marked as resent.</span>
<a name="l00736"></a>00736 <span class="comment">         *  3. resend the request.</span>
<a name="l00737"></a>00737 <span class="comment">         *  4. old reply from server received, we accept and verify the reply.</span>
<a name="l00738"></a>00738 <span class="comment">         *     this has to be success, otherwise the error will be aware</span>
<a name="l00739"></a>00739 <span class="comment">         *     by application.</span>
<a name="l00740"></a>00740 <span class="comment">         *  5. new reply from server received, dropped by LNet.</span>
<a name="l00741"></a>00741 <span class="comment">         *</span>
<a name="l00742"></a>00742 <span class="comment">         * Note the xid of old &amp; new request is the same. We can&apos;t simply</span>
<a name="l00743"></a>00743 <span class="comment">         * change xid for the resent request because the server replies on</span>
<a name="l00744"></a>00744 <span class="comment">         * it for reply reconstruction.</span>
<a name="l00745"></a>00745 <span class="comment">         *</span>
<a name="l00746"></a>00746 <span class="comment">         * Commonly the original context should be uptodate because we</span>
<a name="l00747"></a>00747 <span class="comment">         * have an expiry nice time; server will keep its context because</span>
<a name="l00748"></a>00748 <span class="comment">         * we at least hold a ref of old context which prevent context</span>
<a name="l00749"></a>00749 <span class="comment">         * from destroying RPC being sent. So server still can accept the</span>
<a name="l00750"></a>00750 <span class="comment">         * request and finish the RPC. But if that&apos;s not the case:</span>
<a name="l00751"></a>00751 <span class="comment">         *  1. If server side context has been trimmed, a NO_CONTEXT will</span>
<a name="l00752"></a>00752 <span class="comment">         *     be returned, gss_cli_ctx_verify/unseal will switch to new</span>
<a name="l00753"></a>00753 <span class="comment">         *     context by force.</span>
<a name="l00754"></a>00754 <span class="comment">         *  2. Current context never be refreshed, then we are fine: we</span>
<a name="l00755"></a>00755 <span class="comment">         *     never really send request with old context before.</span>
<a name="l00756"></a>00756 <span class="comment">         */</span>
<a name="l00757"></a>00757         <span class="keywordflow">if</span> (test_bit(PTLRPC_CTX_UPTODATE_BIT, &amp;ctx-&gt;cc_flags) &amp;&amp;
<a name="l00758"></a>00758             unlikely(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp;&amp;
<a name="l00759"></a>00759             lustre_msg_get_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; MSG_RESENT) {
<a name="l00760"></a>00760                 req_off_ctx_list(req, ctx);
<a name="l00761"></a>00761                 RETURN(0);
<a name="l00762"></a>00762         }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764         <span class="keywordflow">if</span> (unlikely(test_bit(PTLRPC_CTX_DEAD_BIT, &amp;ctx-&gt;cc_flags))) {
<a name="l00765"></a>00765                 req_off_ctx_list(req, ctx);
<a name="l00766"></a>00766                 <span class="comment">/*</span>
<a name="l00767"></a>00767 <span class="comment">                 * don&apos;t switch ctx if import was deactivated</span>
<a name="l00768"></a>00768 <span class="comment">                 */</span>
<a name="l00769"></a>00769                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;imp_deactive) {
<a name="l00770"></a>00770                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00771"></a>00771                         req-&gt;rq_err = 1;
<a name="l00772"></a>00772                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00773"></a>00773                         RETURN(-EINTR);
<a name="l00774"></a>00774                 }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776                 rc = <a class="code" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g.">sptlrpc_req_replace_dead_ctx</a>(req);
<a name="l00777"></a>00777                 <span class="keywordflow">if</span> (rc) {
<a name="l00778"></a>00778                         LASSERT(ctx == req-&gt;rq_cli_ctx);
<a name="l00779"></a>00779                         CERROR(<span class="stringliteral">&quot;req %p: failed to replace dead ctx %p: %d\n&quot;</span>,
<a name="l00780"></a>00780                                req, ctx, rc);
<a name="l00781"></a>00781                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00782"></a>00782                         req-&gt;rq_err = 1;
<a name="l00783"></a>00783                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00784"></a>00784                         RETURN(rc);
<a name="l00785"></a>00785                 }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787                 ctx = req-&gt;rq_cli_ctx;
<a name="l00788"></a>00788                 <span class="keywordflow">goto</span> again;
<a name="l00789"></a>00789         }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791         <span class="comment">/*</span>
<a name="l00792"></a>00792 <span class="comment">         * Now we&apos;re sure this context is during upcall, add myself into</span>
<a name="l00793"></a>00793 <span class="comment">         * waiting list</span>
<a name="l00794"></a>00794 <span class="comment">         */</span>
<a name="l00795"></a>00795         spin_lock(&amp;ctx-&gt;cc_lock);
<a name="l00796"></a>00796         <span class="keywordflow">if</span> (list_empty(&amp;req-&gt;rq_ctx_chain))
<a name="l00797"></a>00797                 list_add(&amp;req-&gt;rq_ctx_chain, &amp;ctx-&gt;cc_req_list);
<a name="l00798"></a>00798         spin_unlock(&amp;ctx-&gt;cc_lock);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800         <span class="keywordflow">if</span> (timeout &lt; 0)
<a name="l00801"></a>00801                 RETURN(-EWOULDBLOCK);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         <span class="comment">/* Clear any flags that may be present from previous sends */</span>
<a name="l00804"></a>00804         LASSERT(req-&gt;rq_receiving_reply == 0);
<a name="l00805"></a>00805         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00806"></a>00806         req-&gt;rq_err = 0;
<a name="l00807"></a>00807         req-&gt;rq_timedout = 0;
<a name="l00808"></a>00808         req-&gt;rq_resend = 0;
<a name="l00809"></a>00809         req-&gt;rq_restart = 0;
<a name="l00810"></a>00810         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812         lwi = LWI_TIMEOUT_INTR(msecs_to_jiffies(timeout * MSEC_PER_SEC),
<a name="l00813"></a>00813                                ctx_refresh_timeout,
<a name="l00814"></a>00814                                ctx_refresh_interrupt, req);
<a name="l00815"></a>00815         rc = l_wait_event(req-&gt;rq_reply_waitq, ctx_check_refresh(ctx), &amp;lwi);
<a name="l00816"></a>00816 
<a name="l00817"></a>00817         <span class="comment">/*</span>
<a name="l00818"></a>00818 <span class="comment">         * following cases could lead us here:</span>
<a name="l00819"></a>00819 <span class="comment">         * - successfully refreshed;</span>
<a name="l00820"></a>00820 <span class="comment">         * - interrupted;</span>
<a name="l00821"></a>00821 <span class="comment">         * - timedout, and we don&apos;t want recover from the failure;</span>
<a name="l00822"></a>00822 <span class="comment">         * - timedout, and waked up upon recovery finished;</span>
<a name="l00823"></a>00823 <span class="comment">         * - someone else mark this ctx dead by force;</span>
<a name="l00824"></a>00824 <span class="comment">         * - someone invalidate the req and call ptlrpc_client_wake_req(),</span>
<a name="l00825"></a>00825 <span class="comment">         *   e.g. ptlrpc_abort_inflight();</span>
<a name="l00826"></a>00826 <span class="comment">         */</span>
<a name="l00827"></a>00827         <span class="keywordflow">if</span> (!cli_ctx_is_refreshed(ctx)) {
<a name="l00828"></a>00828                 <span class="comment">/* timed out or interruptted */</span>
<a name="l00829"></a>00829                 req_off_ctx_list(req, ctx);
<a name="l00830"></a>00830 
<a name="l00831"></a>00831                 LASSERT(rc != 0);
<a name="l00832"></a>00832                 RETURN(rc);
<a name="l00833"></a>00833         }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835         <span class="keywordflow">goto</span> again;
<a name="l00836"></a>00836 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga94cbed545313e8c7bc6a682a438c89b0_cgraph.png" border="0" usemap="#group__sptlrpc_ga94cbed545313e8c7bc6a682a438c89b0_cgraph_map" alt=""></div>
<map name="group__sptlrpc_ga94cbed545313e8c7bc6a682a438c89b0_cgraph_map" id="group__sptlrpc_ga94cbed545313e8c7bc6a682a438c89b0_cgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="237,32,461,61"/><area shape="rect" id="node5" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="511,5,668,35"/><area shape="rect" id="node7" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="511,59,668,88"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga94cbed545313e8c7bc6a682a438c89b0_icgraph.png" border="0" usemap="#group__sptlrpc_ga94cbed545313e8c7bc6a682a438c89b0_icgraph_map" alt=""></div>
<map name="group__sptlrpc_ga94cbed545313e8c7bc6a682a438c89b0_icgraph_map" id="group__sptlrpc_ga94cbed545313e8c7bc6a682a438c89b0_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="267,109,405,139"/><area shape="rect" id="node36" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5" title="Given an import imp, check whether current user has a valid context or not." alt="" coords="239,163,433,192"/><area shape="rect" id="node5" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="863,56,1007,85"/><area shape="rect" id="node7" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="487,109,612,139"/><area shape="rect" id="node9" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="664,109,811,139"/><area shape="rect" id="node12" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="860,109,1009,139"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="867,163,1003,192"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1060,109,1207,139"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1289,29,1409,59"/><area shape="rect" id="node23" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1257,83,1441,112"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1741,108,1984,137"/><area shape="rect" id="node32" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1279,187,1420,216"/><area shape="rect" id="node18" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1492,29,1692,59"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="1793,29,1932,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1491,83,1693,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2032,108,2208,137"/><area shape="rect" id="node38" href="group__LDLM.html#ga1373811e4c4edbb039f1da1ca7947b03" title="Attempt to find a lock with specified properties." alt="" coords="483,163,616,192"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7254cf32b0cefed6242f298d3326e8dd"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_req_replace_dead_ctx" ref="ga7254cf32b0cefed6242f298d3326e8dd" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_req_replace_dead_ctx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If current context of <em>req</em> is dead somehow, e.g. </p>
<p>we just switched flavor thus marked original contexts dead, we'll find a new context for it. if no switch is needed, <em>req</em> will end up with the same context.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>a request must have a context, to keep other parts of code happy. In any case of failure during the switching, we must restore the old one. </dd></dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l00549">549</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="sec_8c_source.html#l00425">sptlrpc_req_get_ctx()</a>, and <a class="el" href="sec_8c_source.html#l00460">sptlrpc_req_put_ctx()</a>.</p>

<p>Referenced by <a class="el" href="sec_8c_source.html#l00675">sptlrpc_req_refresh_ctx()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00550"></a>00550 {
<a name="l00551"></a>00551         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *oldctx = req-&gt;rq_cli_ctx;
<a name="l00552"></a>00552         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *newctx;
<a name="l00553"></a>00553         <span class="keywordtype">int</span>                    rc;
<a name="l00554"></a>00554         ENTRY;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556         LASSERT(oldctx);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         sptlrpc_cli_ctx_get(oldctx);
<a name="l00559"></a>00559         <a class="code" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req.">sptlrpc_req_put_ctx</a>(req, 0);
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         rc = <a class="code" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it.">sptlrpc_req_get_ctx</a>(req);
<a name="l00562"></a>00562         <span class="keywordflow">if</span> (unlikely(rc)) {
<a name="l00563"></a>00563                 LASSERT(!req-&gt;rq_cli_ctx);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565                 <span class="comment">/* restore old ctx */</span>
<a name="l00566"></a>00566                 req-&gt;rq_cli_ctx = oldctx;
<a name="l00567"></a>00567                 RETURN(rc);
<a name="l00568"></a>00568         }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         newctx = req-&gt;rq_cli_ctx;
<a name="l00571"></a>00571         LASSERT(newctx);
<a name="l00572"></a>00572 
<a name="l00573"></a>00573         <span class="keywordflow">if</span> (unlikely(newctx == oldctx &amp;&amp;
<a name="l00574"></a>00574                      test_bit(PTLRPC_CTX_DEAD_BIT, &amp;oldctx-&gt;cc_flags))) {
<a name="l00575"></a>00575                 <span class="comment">/*</span>
<a name="l00576"></a>00576 <span class="comment">                 * still get the old dead ctx, usually means system too busy</span>
<a name="l00577"></a>00577 <span class="comment">                 */</span>
<a name="l00578"></a>00578                 CDEBUG(D_SEC,
<a name="l00579"></a>00579                        <span class="stringliteral">&quot;ctx (%p, fl %lx) doesn&apos;t switch, relax a little bit\n&quot;</span>,
<a name="l00580"></a>00580                        newctx, newctx-&gt;cc_flags);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582                 set_current_state(TASK_INTERRUPTIBLE);
<a name="l00583"></a>00583                 schedule_timeout(msecs_to_jiffies(MSEC_PER_SEC));
<a name="l00584"></a>00584         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (unlikely(test_bit(PTLRPC_CTX_UPTODATE_BIT, &amp;newctx-&gt;cc_flags)
<a name="l00585"></a>00585                             == 0)) {
<a name="l00586"></a>00586                 <span class="comment">/*</span>
<a name="l00587"></a>00587 <span class="comment">                 * new ctx not up to date yet</span>
<a name="l00588"></a>00588 <span class="comment">                 */</span>
<a name="l00589"></a>00589                 CDEBUG(D_SEC,
<a name="l00590"></a>00590                        <span class="stringliteral">&quot;ctx (%p, fl %lx) doesn&apos;t switch, not up to date yet\n&quot;</span>,
<a name="l00591"></a>00591                        newctx, newctx-&gt;cc_flags);
<a name="l00592"></a>00592         } <span class="keywordflow">else</span> {
<a name="l00593"></a>00593                 <span class="comment">/*</span>
<a name="l00594"></a>00594 <span class="comment">                 * it&apos;s possible newctx == oldctx if we&apos;re switching</span>
<a name="l00595"></a>00595 <span class="comment">                 * subflavor with the same sec.</span>
<a name="l00596"></a>00596 <span class="comment">                 */</span>
<a name="l00597"></a>00597                 rc = sptlrpc_req_ctx_switch(req, oldctx, newctx);
<a name="l00598"></a>00598                 <span class="keywordflow">if</span> (rc) {
<a name="l00599"></a>00599                         <span class="comment">/* restore old ctx */</span>
<a name="l00600"></a>00600                         <a class="code" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req.">sptlrpc_req_put_ctx</a>(req, 0);
<a name="l00601"></a>00601                         req-&gt;rq_cli_ctx = oldctx;
<a name="l00602"></a>00602                         RETURN(rc);
<a name="l00603"></a>00603                 }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605                 LASSERT(req-&gt;rq_cli_ctx == newctx);
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         sptlrpc_cli_ctx_put(oldctx, 1);
<a name="l00609"></a>00609         RETURN(0);
<a name="l00610"></a>00610 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga7254cf32b0cefed6242f298d3326e8dd_cgraph.png" border="0" usemap="#group__sptlrpc_ga7254cf32b0cefed6242f298d3326e8dd_cgraph_map" alt=""></div>
<map name="group__sptlrpc_ga7254cf32b0cefed6242f298d3326e8dd_cgraph_map" id="group__sptlrpc_ga7254cf32b0cefed6242f298d3326e8dd_cgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="279,5,436,35"/><area shape="rect" id="node5" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="279,59,436,88"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_ga7254cf32b0cefed6242f298d3326e8dd_icgraph.png" border="0" usemap="#group__sptlrpc_ga7254cf32b0cefed6242f298d3326e8dd_icgraph_map" alt=""></div>
<map name="group__sptlrpc_ga7254cf32b0cefed6242f298d3326e8dd_icgraph_map" id="group__sptlrpc_ga7254cf32b0cefed6242f298d3326e8dd_icgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="279,136,460,165"/><area shape="rect" id="node5" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="539,109,677,139"/><area shape="rect" id="node38" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5" title="Given an import imp, check whether current user has a valid context or not." alt="" coords="511,163,705,192"/><area shape="rect" id="node7" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="1135,56,1279,85"/><area shape="rect" id="node9" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="759,109,884,139"/><area shape="rect" id="node11" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="936,109,1083,139"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="1132,109,1281,139"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="1139,163,1275,192"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1332,109,1479,139"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1561,29,1681,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1529,83,1713,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="2013,108,2256,137"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1551,187,1692,216"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1764,29,1964,59"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="2065,29,2204,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1763,83,1965,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2304,108,2480,137"/><area shape="rect" id="node40" href="group__LDLM.html#ga1373811e4c4edbb039f1da1ca7947b03" title="Attempt to find a lock with specified properties." alt="" coords="755,163,888,192"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga701bf20eebf0fd9d03c94918418f3b31"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_req_set_flavor" ref="ga701bf20eebf0fd9d03c94918418f3b31" args="(struct ptlrpc_request *req, int opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptlrpc_req_set_flavor </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize flavor settings for <em>req</em>, according to <em>opcode</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>this could be called in two situations:<ul>
<li>new request from ptlrpc_pre_req(), with proper </li>
<li>old request which changed ctx in the middle, with  == 0 </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l00845">845</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01055">ptlrpc_request::rq_flvr</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__sec_8h_source.html#l00296">sptlrpc_flavor::sf_flags</a>, <a class="el" href="lustre__sec_8h_source.html#l00292">sptlrpc_flavor::sf_rpc</a>, <a class="el" href="lustre__sec_8h_source.html#l00114">SPTLRPC_SVC_INTG</a>, and <a class="el" href="lustre__sec_8h_source.html#l00112">SPTLRPC_SVC_NULL</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00846"></a>00846 {
<a name="l00847"></a>00847         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec;
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>);
<a name="l00850"></a>00850         LASSERT(req-&gt;rq_cli_ctx);
<a name="l00851"></a>00851         LASSERT(req-&gt;rq_cli_ctx-&gt;cc_sec);
<a name="l00852"></a>00852         LASSERT(req-&gt;rq_bulk_read == 0 || req-&gt;rq_bulk_write == 0);
<a name="l00853"></a>00853 
<a name="l00854"></a>00854         <span class="comment">/* special security flags accoding to opcode */</span>
<a name="l00855"></a>00855         <span class="keywordflow">switch</span> (opcode) {
<a name="l00856"></a>00856         <span class="keywordflow">case</span> OST_READ:
<a name="l00857"></a>00857         <span class="keywordflow">case</span> MDS_READPAGE:
<a name="l00858"></a>00858         <span class="keywordflow">case</span> MGS_CONFIG_READ:
<a name="l00859"></a>00859         <span class="keywordflow">case</span> OBD_IDX_READ:
<a name="l00860"></a>00860                 req-&gt;rq_bulk_read = 1;
<a name="l00861"></a>00861                 <span class="keywordflow">break</span>;
<a name="l00862"></a>00862         <span class="keywordflow">case</span> OST_WRITE:
<a name="l00863"></a>00863         <span class="keywordflow">case</span> MDS_WRITEPAGE:
<a name="l00864"></a>00864                 req-&gt;rq_bulk_write = 1;
<a name="l00865"></a>00865                 <span class="keywordflow">break</span>;
<a name="l00866"></a>00866         <span class="keywordflow">case</span> SEC_CTX_INIT:
<a name="l00867"></a>00867                 req-&gt;rq_ctx_init = 1;
<a name="l00868"></a>00868                 <span class="keywordflow">break</span>;
<a name="l00869"></a>00869         <span class="keywordflow">case</span> SEC_CTX_FINI:
<a name="l00870"></a>00870                 req-&gt;rq_ctx_fini = 1;
<a name="l00871"></a>00871                 <span class="keywordflow">break</span>;
<a name="l00872"></a>00872         <span class="keywordflow">case</span> 0:
<a name="l00873"></a>00873                 <span class="comment">/* init/fini rpc won&apos;t be resend, so can&apos;t be here */</span>
<a name="l00874"></a>00874                 LASSERT(req-&gt;rq_ctx_init == 0);
<a name="l00875"></a>00875                 LASSERT(req-&gt;rq_ctx_fini == 0);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877                 <span class="comment">/* cleanup flags, which should be recalculated */</span>
<a name="l00878"></a>00878                 req-&gt;rq_pack_udesc = 0;
<a name="l00879"></a>00879                 req-&gt;rq_pack_bulk = 0;
<a name="l00880"></a>00880                 <span class="keywordflow">break</span>;
<a name="l00881"></a>00881         }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883         sec = req-&gt;rq_cli_ctx-&gt;cc_sec;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885         spin_lock(&amp;sec-&gt;ps_lock);
<a name="l00886"></a>00886         req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a> = sec-&gt;ps_flvr;
<a name="l00887"></a>00887         spin_unlock(&amp;sec-&gt;ps_lock);
<a name="l00888"></a>00888 
<a name="l00889"></a>00889         <span class="comment">/* force SVC_NULL for context initiation rpc, SVC_INTG for context</span>
<a name="l00890"></a>00890 <span class="comment">         * destruction rpc */</span>
<a name="l00891"></a>00891         <span class="keywordflow">if</span> (unlikely(req-&gt;rq_ctx_init))
<a name="l00892"></a>00892                 flvr_set_svc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa9962cb9ccc8b90b4c67ada0e7b00210b" title="no security">SPTLRPC_SVC_NULL</a>);
<a name="l00893"></a>00893         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (unlikely(req-&gt;rq_ctx_fini))
<a name="l00894"></a>00894                 flvr_set_svc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa74b1cc494dcf8dbf001b3a19e8790fd9" title="integrity">SPTLRPC_SVC_INTG</a>);
<a name="l00895"></a>00895 
<a name="l00896"></a>00896         <span class="comment">/* user descriptor flag, null security can&apos;t do it anyway */</span>
<a name="l00897"></a>00897         <span class="keywordflow">if</span> ((sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> &amp; PTLRPC_SEC_FL_UDESC) &amp;&amp;
<a name="l00898"></a>00898             (req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a> != SPTLRPC_FLVR_NULL))
<a name="l00899"></a>00899                 req-&gt;rq_pack_udesc = 1;
<a name="l00900"></a>00900 
<a name="l00901"></a>00901         <span class="comment">/* bulk security flag */</span>
<a name="l00902"></a>00902         <span class="keywordflow">if</span> ((req-&gt;rq_bulk_read || req-&gt;rq_bulk_write) &amp;&amp;
<a name="l00903"></a>00903             sptlrpc_flavor_has_bulk(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>))
<a name="l00904"></a>00904                 req-&gt;rq_pack_bulk = 1;
<a name="l00905"></a>00905 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa86a438c13250916b84e0d12810d5786"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_rule_set_choose" ref="gaa86a438c13250916b84e0d12810d5786" args="(struct sptlrpc_rule_set *rset, enum lustre_sec_part from, enum lustre_sec_part to, lnet_nid_t nid, struct sptlrpc_flavor *sf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_rule_set_choose </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsptlrpc__rule__set.html">sptlrpc_rule_set</a> *&nbsp;</td>
          <td class="paramname"> <em>rset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">lustre_sec_part</a>&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">lustre_sec_part</a>&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a>&nbsp;</td>
          <td class="paramname"> <em>nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsptlrpc__flavor.html">sptlrpc_flavor</a> *&nbsp;</td>
          <td class="paramname"> <em>sf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>given from/to/nid, determine a matching flavor in ruleset. </p>
<p>return 1 if a match found, otherwise return 0. </p>

<p>Definition at line <a class="el" href="sec__config_8c_source.html#l00404">404</a> of file <a class="el" href="sec__config_8c_source.html">sec_config.c</a>.</p>

<p>References <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00072">LNET_NID_ANY</a>.</p>

<p>Referenced by <a class="el" href="sec__config_8c_source.html#l00890">sptlrpc_target_choose_flavor()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00409"></a>00409 {
<a name="l00410"></a>00410         <span class="keyword">struct </span><a class="code" href="structsptlrpc__rule.html" title="A rule specifies a flavor to be used by a ptlrpc connection between two Lustre parts...">sptlrpc_rule</a>    *r;
<a name="l00411"></a>00411         <span class="keywordtype">int</span>                     n;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413         <span class="keywordflow">for</span> (n = 0; n &lt; rset-&gt;srs_nrule; n++) {
<a name="l00414"></a>00414                 r = &amp;rset-&gt;srs_rules[n];
<a name="l00415"></a>00415 
<a name="l00416"></a>00416                 <span class="keywordflow">if</span> (LNET_NIDNET(nid) != LNET_NIDNET(<a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) &amp;&amp;
<a name="l00417"></a>00417                     r-&gt;sr_netid != LNET_NIDNET(<a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) &amp;&amp;
<a name="l00418"></a>00418                     LNET_NIDNET(nid) != r-&gt;sr_netid)
<a name="l00419"></a>00419                         <span class="keywordflow">continue</span>;
<a name="l00420"></a>00420 
<a name="l00421"></a>00421                 <span class="keywordflow">if</span> (from != LUSTRE_SP_ANY &amp;&amp; r-&gt;sr_from != LUSTRE_SP_ANY &amp;&amp;
<a name="l00422"></a>00422                     from != r-&gt;sr_from)
<a name="l00423"></a>00423                         <span class="keywordflow">continue</span>;
<a name="l00424"></a>00424 
<a name="l00425"></a>00425                 <span class="keywordflow">if</span> (to != LUSTRE_SP_ANY &amp;&amp; r-&gt;sr_to != LUSTRE_SP_ANY &amp;&amp;
<a name="l00426"></a>00426                     to != r-&gt;sr_to)
<a name="l00427"></a>00427                         <span class="keywordflow">continue</span>;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429                 *sf = r-&gt;sr_flvr;
<a name="l00430"></a>00430                 <span class="keywordflow">return</span> 1;
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433         <span class="keywordflow">return</span> 0;
<a name="l00434"></a>00434 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_gaa86a438c13250916b84e0d12810d5786_icgraph.png" border="0" usemap="#group__sptlrpc_gaa86a438c13250916b84e0d12810d5786_icgraph_map" alt=""></div>
<map name="group__sptlrpc_gaa86a438c13250916b84e0d12810d5786_icgraph_map" id="group__sptlrpc_gaa86a438c13250916b84e0d12810d5786_icgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#gac2dcbcaee70d89f9e5f250d5e095ab4e" title="called by target devices, determine the expected flavor from certain peer (from,..." alt="" coords="240,5,459,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga1bcf6cf901c5c461f6f273a9b764430a"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_svc_alloc_rs" ref="ga1bcf6cf901c5c461f6f273a9b764430a" args="(struct ptlrpc_request *req, int msglen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_svc_alloc_rs </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msglen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc server, to allocate reply buffer for <em>req</em>. </p>
<p>If succeed, req-&gt;rq_reply_state is set, and req-&gt;rq_reply_state-&gt;rs_msg point to a buffer of <em>msglen</em> size. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l02130">2130</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412">ptlrpc_sec_sops::alloc_rs</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02131"></a>02131 {
<a name="l02132"></a>02132         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l02133"></a>02133         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs;
<a name="l02134"></a>02134         <span class="keywordtype">int</span> rc;
<a name="l02135"></a>02135         ENTRY;
<a name="l02136"></a>02136 
<a name="l02137"></a>02137         LASSERT(req-&gt;rq_svc_ctx);
<a name="l02138"></a>02138         LASSERT(req-&gt;rq_svc_ctx-&gt;sc_policy);
<a name="l02139"></a>02139 
<a name="l02140"></a>02140         policy = req-&gt;rq_svc_ctx-&gt;sc_policy;
<a name="l02141"></a>02141         LASSERT(policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412" title="Allocate a ptlrpc_reply_state.">alloc_rs</a>);
<a name="l02142"></a>02142 
<a name="l02143"></a>02143         rc = policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412" title="Allocate a ptlrpc_reply_state.">alloc_rs</a>(req, msglen);
<a name="l02144"></a>02144         <span class="keywordflow">if</span> (unlikely(rc == -ENOMEM)) {
<a name="l02145"></a>02145                 <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt = req-&gt;rq_rqbd-&gt;rqbd_svcpt;
<a name="l02146"></a>02146                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service-&gt;srv_max_reply_size &lt;
<a name="l02147"></a>02147                    msglen + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>)) {
<a name="l02148"></a>02148                         <span class="comment">/* Just return failure if the size is too big */</span>
<a name="l02149"></a>02149                         CERROR(<span class="stringliteral">&quot;size of message is too big (%zd), %d allowed\n&quot;</span>,
<a name="l02150"></a>02150                                 msglen + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>),
<a name="l02151"></a>02151                                 svcpt-&gt;scp_service-&gt;srv_max_reply_size);
<a name="l02152"></a>02152                         RETURN(-ENOMEM);
<a name="l02153"></a>02153                 }
<a name="l02154"></a>02154 
<a name="l02155"></a>02155                 <span class="comment">/* failed alloc, try emergency pool */</span>
<a name="l02156"></a>02156                 rs = lustre_get_emerg_rs(svcpt);
<a name="l02157"></a>02157                 <span class="keywordflow">if</span> (rs == NULL)
<a name="l02158"></a>02158                         RETURN(-ENOMEM);
<a name="l02159"></a>02159 
<a name="l02160"></a>02160                 req-&gt;rq_reply_state = rs;
<a name="l02161"></a>02161                 rc = policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412" title="Allocate a ptlrpc_reply_state.">alloc_rs</a>(req, msglen);
<a name="l02162"></a>02162                 <span class="keywordflow">if</span> (rc) {
<a name="l02163"></a>02163                         lustre_put_emerg_rs(rs);
<a name="l02164"></a>02164                         req-&gt;rq_reply_state = NULL;
<a name="l02165"></a>02165                 }
<a name="l02166"></a>02166         }
<a name="l02167"></a>02167 
<a name="l02168"></a>02168         LASSERT(rc != 0 ||
<a name="l02169"></a>02169                 (req-&gt;rq_reply_state &amp;&amp; req-&gt;rq_reply_state-&gt;rs_msg));
<a name="l02170"></a>02170 
<a name="l02171"></a>02171         RETURN(rc);
<a name="l02172"></a>02172 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6fdd12db4bcfd925fed91da8a4ecf857"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_svc_unwrap_request" ref="ga6fdd12db4bcfd925fed91da8a4ecf857" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_svc_unwrap_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc server, to perform transformation upon request message of incoming <em>req</em>. </p>
<p>This must be the first thing to do with an incoming request in ptlrpc layer.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SECSVC_OK</em>&nbsp;</td><td>success, and req-&gt;rq_reqmsg point to request message in clear text, size is req-&gt;rq_reqlen; also req-&gt;rq_svc_ctx is set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SECSVC_COMPLETE</em>&nbsp;</td><td>success, the request has been fully processed, and reply message has been prepared. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SECSVC_DROP</em>&nbsp;</td><td>failed, this request should be dropped. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l02070">2070</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__sec__sops.html#a2a593984c53aea5425bc29f6ede99144">ptlrpc_sec_sops::accept</a>, <a class="el" href="lustre__idl_8h_source.html#l01144">MSG_PTLRPC_HEADER_OFF</a>, <a class="el" href="lustre__net_8h_source.html#l01055">ptlrpc_request::rq_flvr</a>, <a class="el" href="lustre__net_8h_source.html#l01108">ptlrpc_request::rq_peer</a>, <a class="el" href="lustre__net_8h_source.html#l01032">ptlrpc_request::rq_repmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01096">ptlrpc_request::rq_req_swab_mask</a>, <a class="el" href="lustre__net_8h_source.html#l01079">ptlrpc_request::rq_reqbuf</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="lustre__net_8h_source.html#l01036">ptlrpc_request::rq_xid</a>, <a class="el" href="lustre__sec_8h_source.html#l00292">sptlrpc_flavor::sf_rpc</a>, and <a class="el" href="lustre__sec_8h_source.html#l00256">WIRE_FLVR</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02071"></a>02071 {
<a name="l02072"></a>02072         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l02073"></a>02073         <span class="keyword">struct </span>lustre_msg        *msg = req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>;
<a name="l02074"></a>02074         <span class="keywordtype">int</span>                       rc;
<a name="l02075"></a>02075         ENTRY;
<a name="l02076"></a>02076 
<a name="l02077"></a>02077         LASSERT(msg);
<a name="l02078"></a>02078         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> == NULL);
<a name="l02079"></a>02079         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> == NULL);
<a name="l02080"></a>02080         LASSERT(req-&gt;rq_svc_ctx == NULL);
<a name="l02081"></a>02081 
<a name="l02082"></a>02082         req-&gt;<a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a> = 0;
<a name="l02083"></a>02083 
<a name="l02084"></a>02084         rc = __lustre_unpack_msg(msg, req-&gt;rq_reqdata_len);
<a name="l02085"></a>02085         <span class="keywordflow">switch</span> (rc) {
<a name="l02086"></a>02086         <span class="keywordflow">case</span> 1:
<a name="l02087"></a>02087                 lustre_set_req_swabbed(req, <a class="code" href="group__lustreidl.html#gafa5c71e7497acfe5dea4f5efd14ef8ec" title="only use in req-&amp;gt;rq_{req,rep}_swab_mask">MSG_PTLRPC_HEADER_OFF</a>);
<a name="l02088"></a>02088         <span class="keywordflow">case</span> 0:
<a name="l02089"></a>02089                 <span class="keywordflow">break</span>;
<a name="l02090"></a>02090         <span class="keywordflow">default</span>:
<a name="l02091"></a>02091                 CERROR(<span class="stringliteral">&quot;error unpacking request from %s x&quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l02092"></a>02092                        libcfs_id2str(req-&gt;<a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>), req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l02093"></a>02093                 RETURN(SECSVC_DROP);
<a name="l02094"></a>02094         }
<a name="l02095"></a>02095 
<a name="l02096"></a>02096         req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a> = <a class="code" href="group__flavor.html#ga7746f840ac0ba4799482883ea5719881" title="extract the useful part from wire flavor">WIRE_FLVR</a>(msg-&gt;lm_secflvr);
<a name="l02097"></a>02097         req-&gt;rq_sp_from = LUSTRE_SP_ANY;
<a name="l02098"></a>02098         req-&gt;rq_auth_uid = -1;          <span class="comment">/* set to INVALID_UID */</span>
<a name="l02099"></a>02099         req-&gt;rq_auth_mapped_uid = -1;
<a name="l02100"></a>02100 
<a name="l02101"></a>02101         policy = sptlrpc_wireflavor2policy(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l02102"></a>02102         <span class="keywordflow">if</span> (!policy) {
<a name="l02103"></a>02103                 CERROR(<span class="stringliteral">&quot;unsupported rpc flavor %x\n&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l02104"></a>02104                 RETURN(SECSVC_DROP);
<a name="l02105"></a>02105         }
<a name="l02106"></a>02106 
<a name="l02107"></a>02107         LASSERT(policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a2a593984c53aea5425bc29f6ede99144" title="verify an incoming request.">accept</a>);
<a name="l02108"></a>02108         rc = policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a2a593984c53aea5425bc29f6ede99144" title="verify an incoming request.">accept</a>(req);
<a name="l02109"></a>02109         sptlrpc_policy_put(policy);
<a name="l02110"></a>02110         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> || rc != SECSVC_OK);
<a name="l02111"></a>02111         LASSERT(req-&gt;rq_svc_ctx || rc == SECSVC_DROP);
<a name="l02112"></a>02112 
<a name="l02113"></a>02113         <span class="comment">/*</span>
<a name="l02114"></a>02114 <span class="comment">         * if it&apos;s not null flavor (which means embedded packing msg),</span>
<a name="l02115"></a>02115 <span class="comment">         * reset the swab mask for the comming inner msg unpacking.</span>
<a name="l02116"></a>02116 <span class="comment">         */</span>
<a name="l02117"></a>02117         <span class="keywordflow">if</span> (SPTLRPC_FLVR_POLICY(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) != SPTLRPC_POLICY_NULL)
<a name="l02118"></a>02118                 req-&gt;<a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a> = 0;
<a name="l02119"></a>02119 
<a name="l02120"></a>02120         <span class="comment">/* sanity check for the request source */</span>
<a name="l02121"></a>02121         rc = sptlrpc_svc_check_from(req, rc);
<a name="l02122"></a>02122         RETURN(rc);
<a name="l02123"></a>02123 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa36445bb3135100651ecb584e151f3cb"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_svc_wrap_reply" ref="gaa36445bb3135100651ecb584e151f3cb" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_svc_wrap_reply </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by ptlrpc server, to perform transformation upon reply message. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>req-&gt;rq_reply_off is set to approriate server-controlled reply offset. </dd>
<dd>
req-&gt;rq_repmsg and req-&gt;rq_reply_state-&gt;rs_msg becomes inaccessible. </dd></dl>

<p>Definition at line <a class="el" href="sec_8c_source.html#l02180">2180</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="structptlrpc__sec__sops.html#a876a2e82cdca22048ce6521778690e83">ptlrpc_sec_sops::authorize</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00528">ptlrpc_send_reply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02181"></a>02181 {
<a name="l02182"></a>02182         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l02183"></a>02183         <span class="keywordtype">int</span> rc;
<a name="l02184"></a>02184         ENTRY;
<a name="l02185"></a>02185 
<a name="l02186"></a>02186         LASSERT(req-&gt;rq_svc_ctx);
<a name="l02187"></a>02187         LASSERT(req-&gt;rq_svc_ctx-&gt;sc_policy);
<a name="l02188"></a>02188 
<a name="l02189"></a>02189         policy = req-&gt;rq_svc_ctx-&gt;sc_policy;
<a name="l02190"></a>02190         LASSERT(policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a876a2e82cdca22048ce6521778690e83" title="Perform security transformation upon reply message.">authorize</a>);
<a name="l02191"></a>02191 
<a name="l02192"></a>02192         rc = policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a876a2e82cdca22048ce6521778690e83" title="Perform security transformation upon reply message.">authorize</a>(req);
<a name="l02193"></a>02193         LASSERT(rc || req-&gt;rq_reply_state-&gt;rs_repdata_len);
<a name="l02194"></a>02194 
<a name="l02195"></a>02195         RETURN(rc);
<a name="l02196"></a>02196 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_gaa36445bb3135100651ecb584e151f3cb_icgraph.png" border="0" usemap="#group__sptlrpc_gaa36445bb3135100651ecb584e151f3cb_icgraph_map" alt=""></div>
<map name="group__sptlrpc_gaa36445bb3135100651ecb584e151f3cb_icgraph_map" id="group__sptlrpc_gaa36445bb3135100651ecb584e151f3cb_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga563a5d436790759334ba2a51f0dce12e" title="Send request reply from request req reply buffer." alt="" coords="233,5,372,35"/><area shape="rect" id="node5" href="group__net.html#gac2a8de93c376592370228d10fd94761d" title="For request req send an error reply back." alt="" coords="421,5,560,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf12efdd6553013c0e886d356541dd86b"></a><!-- doxytag: member="lustre_sec.h::sptlrpc_target_export_check" ref="gaf12efdd6553013c0e886d356541dd86b" args="(struct obd_export *exp, struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sptlrpc_target_export_check </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__export.html">obd_export</a> *&nbsp;</td>
          <td class="paramname"> <em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an export <em>exp</em>, check whether the flavor of incoming <em>req</em> is allowed by the export <em>exp</em>. </p>
<p>Main logic is about taking care of changing configurations. Return 0 means success. </p>

<p>Definition at line <a class="el" href="sec_8c_source.html#l01797">1797</a> of file <a class="el" href="sec_8c_source.html">sec.c</a>.</p>

<p>References <a class="el" href="lustre__export_8h_source.html#l00214">obd_export::exp_imp_reverse</a>, <a class="el" href="lustre__export_8h_source.html#l00240">obd_export::exp_lock</a>, <a class="el" href="lustre__export_8h_source.html#l00209">obd_export::exp_obd</a>, <a class="el" href="lustre__net_8h_source.html#l01055">ptlrpc_request::rq_flvr</a>, <a class="el" href="lustre__sec_8h_source.html#l00292">sptlrpc_flavor::sf_rpc</a>, and <a class="el" href="sec_8c_source.html#l01438">sptlrpc_import_sec_adapt()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01799"></a>01799 {
<a name="l01800"></a>01800         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a>   flavor;
<a name="l01801"></a>01801 
<a name="l01802"></a>01802         <span class="keywordflow">if</span> (exp == NULL)
<a name="l01803"></a>01803                 <span class="keywordflow">return</span> 0;
<a name="l01804"></a>01804 
<a name="l01805"></a>01805         <span class="comment">/* client side export has no imp_reverse, skip</span>
<a name="l01806"></a>01806 <span class="comment">         * FIXME maybe we should check flavor this as well??? */</span>
<a name="l01807"></a>01807         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structobd__export.html#a2dce74f596d31fe639a35fae13a75214" title="&amp;quot;reverse&amp;quot; import to send requests (e.g.">exp_imp_reverse</a> == NULL)
<a name="l01808"></a>01808                 <span class="keywordflow">return</span> 0;
<a name="l01809"></a>01809 
<a name="l01810"></a>01810         <span class="comment">/* don&apos;t care about ctx fini rpc */</span>
<a name="l01811"></a>01811         <span class="keywordflow">if</span> (req-&gt;rq_ctx_fini)
<a name="l01812"></a>01812                 <span class="keywordflow">return</span> 0;
<a name="l01813"></a>01813 
<a name="l01814"></a>01814         spin_lock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01815"></a>01815 
<a name="l01816"></a>01816         <span class="comment">/* if flavor just changed (exp-&gt;exp_flvr_changed != 0), we wait for</span>
<a name="l01817"></a>01817 <span class="comment">         * the first req with the new flavor, then treat it as current flavor,</span>
<a name="l01818"></a>01818 <span class="comment">         * adapt reverse sec according to it.</span>
<a name="l01819"></a>01819 <span class="comment">         * note the first rpc with new flavor might not be with root ctx, in</span>
<a name="l01820"></a>01820 <span class="comment">         * which case delay the sec_adapt by leaving exp_flvr_adapt == 1. */</span>
<a name="l01821"></a>01821         <span class="keywordflow">if</span> (unlikely(exp-&gt;exp_flvr_changed) &amp;&amp;
<a name="l01822"></a>01822             flavor_allowed(&amp;exp-&gt;exp_flvr_old[1], req)) {
<a name="l01823"></a>01823                 <span class="comment">/* make the new flavor as &quot;current&quot;, and old ones as</span>
<a name="l01824"></a>01824 <span class="comment">                 * about-to-expire */</span>
<a name="l01825"></a>01825                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p: just changed: %x-&gt;%x\n&quot;</span>, exp,
<a name="l01826"></a>01826                        exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01827"></a>01827                 flavor = exp-&gt;exp_flvr_old[1];
<a name="l01828"></a>01828                 exp-&gt;exp_flvr_old[1] = exp-&gt;exp_flvr_old[0];
<a name="l01829"></a>01829                 exp-&gt;exp_flvr_expire[1] = exp-&gt;exp_flvr_expire[0];
<a name="l01830"></a>01830                 exp-&gt;exp_flvr_old[0] = exp-&gt;exp_flvr;
<a name="l01831"></a>01831                 exp-&gt;exp_flvr_expire[0] = cfs_time_current_sec() +
<a name="l01832"></a>01832                                           EXP_FLVR_UPDATE_EXPIRE;
<a name="l01833"></a>01833                 exp-&gt;exp_flvr = flavor;
<a name="l01834"></a>01834 
<a name="l01835"></a>01835                 <span class="comment">/* flavor change finished */</span>
<a name="l01836"></a>01836                 exp-&gt;exp_flvr_changed = 0;
<a name="l01837"></a>01837                 LASSERT(exp-&gt;exp_flvr_adapt == 1);
<a name="l01838"></a>01838 
<a name="l01839"></a>01839                 <span class="comment">/* if it&apos;s gss, we only interested in root ctx init */</span>
<a name="l01840"></a>01840                 <span class="keywordflow">if</span> (req-&gt;rq_auth_gss &amp;&amp;
<a name="l01841"></a>01841                     !(req-&gt;rq_ctx_init &amp;&amp;
<a name="l01842"></a>01842                       (req-&gt;rq_auth_usr_root || req-&gt;rq_auth_usr_mdt ||
<a name="l01843"></a>01843                        req-&gt;rq_auth_usr_ost))) {
<a name="l01844"></a>01844                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01845"></a>01845                         CDEBUG(D_SEC, <span class="stringliteral">&quot;is good but not root(%d:%d:%d:%d:%d)\n&quot;</span>,
<a name="l01846"></a>01846                                req-&gt;rq_auth_gss, req-&gt;rq_ctx_init,
<a name="l01847"></a>01847                                req-&gt;rq_auth_usr_root, req-&gt;rq_auth_usr_mdt,
<a name="l01848"></a>01848                                req-&gt;rq_auth_usr_ost);
<a name="l01849"></a>01849                         <span class="keywordflow">return</span> 0;
<a name="l01850"></a>01850                 }
<a name="l01851"></a>01851 
<a name="l01852"></a>01852                 exp-&gt;exp_flvr_adapt = 0;
<a name="l01853"></a>01853                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01854"></a>01854 
<a name="l01855"></a>01855                 <span class="keywordflow">return</span> <a class="code" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration...">sptlrpc_import_sec_adapt</a>(exp-&gt;<a class="code" href="structobd__export.html#a2dce74f596d31fe639a35fae13a75214" title="&amp;quot;reverse&amp;quot; import to send requests (e.g.">exp_imp_reverse</a>,
<a name="l01856"></a>01856                                                 req-&gt;rq_svc_ctx, &amp;flavor);
<a name="l01857"></a>01857         }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859         <span class="comment">/* if it equals to the current flavor, we accept it, but need to</span>
<a name="l01860"></a>01860 <span class="comment">         * dealing with reverse sec/ctx */</span>
<a name="l01861"></a>01861         <span class="keywordflow">if</span> (likely(flavor_allowed(&amp;exp-&gt;exp_flvr, req))) {
<a name="l01862"></a>01862                 <span class="comment">/* most cases should return here, we only interested in</span>
<a name="l01863"></a>01863 <span class="comment">                 * gss root ctx init */</span>
<a name="l01864"></a>01864                 <span class="keywordflow">if</span> (!req-&gt;rq_auth_gss || !req-&gt;rq_ctx_init ||
<a name="l01865"></a>01865                     (!req-&gt;rq_auth_usr_root &amp;&amp; !req-&gt;rq_auth_usr_mdt &amp;&amp;
<a name="l01866"></a>01866                      !req-&gt;rq_auth_usr_ost)) {
<a name="l01867"></a>01867                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01868"></a>01868                         <span class="keywordflow">return</span> 0;
<a name="l01869"></a>01869                 }
<a name="l01870"></a>01870 
<a name="l01871"></a>01871                 <span class="comment">/* if flavor just changed, we should not proceed, just leave</span>
<a name="l01872"></a>01872 <span class="comment">                 * it and current flavor will be discovered and replaced</span>
<a name="l01873"></a>01873 <span class="comment">                 * shortly, and let _this_ rpc pass through */</span>
<a name="l01874"></a>01874                 <span class="keywordflow">if</span> (exp-&gt;exp_flvr_changed) {
<a name="l01875"></a>01875                         LASSERT(exp-&gt;exp_flvr_adapt);
<a name="l01876"></a>01876                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01877"></a>01877                         <span class="keywordflow">return</span> 0;
<a name="l01878"></a>01878                 }
<a name="l01879"></a>01879 
<a name="l01880"></a>01880                 <span class="keywordflow">if</span> (exp-&gt;exp_flvr_adapt) {
<a name="l01881"></a>01881                         exp-&gt;exp_flvr_adapt = 0;
<a name="l01882"></a>01882                         CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): do delayed adapt\n&quot;</span>,
<a name="l01883"></a>01883                                exp, exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01884"></a>01884                                exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01885"></a>01885                                exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01886"></a>01886                         flavor = exp-&gt;exp_flvr;
<a name="l01887"></a>01887                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01888"></a>01888 
<a name="l01889"></a>01889                         <span class="keywordflow">return</span> <a class="code" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration...">sptlrpc_import_sec_adapt</a>(exp-&gt;<a class="code" href="structobd__export.html#a2dce74f596d31fe639a35fae13a75214" title="&amp;quot;reverse&amp;quot; import to send requests (e.g.">exp_imp_reverse</a>,
<a name="l01890"></a>01890                                                         req-&gt;rq_svc_ctx,
<a name="l01891"></a>01891                                                         &amp;flavor);
<a name="l01892"></a>01892                 } <span class="keywordflow">else</span> {
<a name="l01893"></a>01893                         CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): is current flavor, &quot;</span>
<a name="l01894"></a>01894                                <span class="stringliteral">&quot;install rvs ctx\n&quot;</span>, exp, exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01895"></a>01895                                exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01896"></a>01896                                exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01897"></a>01897                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01898"></a>01898 
<a name="l01899"></a>01899                         <span class="keywordflow">return</span> sptlrpc_svc_install_rvs_ctx(exp-&gt;<a class="code" href="structobd__export.html#a2dce74f596d31fe639a35fae13a75214" title="&amp;quot;reverse&amp;quot; import to send requests (e.g.">exp_imp_reverse</a>,
<a name="l01900"></a>01900                                                            req-&gt;rq_svc_ctx);
<a name="l01901"></a>01901                 }
<a name="l01902"></a>01902         }
<a name="l01903"></a>01903 
<a name="l01904"></a>01904         <span class="keywordflow">if</span> (exp-&gt;exp_flvr_expire[0]) {
<a name="l01905"></a>01905                 <span class="keywordflow">if</span> (exp-&gt;exp_flvr_expire[0] &gt;= cfs_time_current_sec()) {
<a name="l01906"></a>01906                         <span class="keywordflow">if</span> (flavor_allowed(&amp;exp-&gt;exp_flvr_old[0], req)) {
<a name="l01907"></a>01907                                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): match the &quot;</span>
<a name="l01908"></a>01908                                        <span class="stringliteral">&quot;middle one (&quot;</span>CFS_DURATION_T<span class="stringliteral">&quot;)\n&quot;</span>, exp,
<a name="l01909"></a>01909                                        exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01910"></a>01910                                        exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01911"></a>01911                                        exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01912"></a>01912                                        exp-&gt;exp_flvr_expire[0] -
<a name="l01913"></a>01913                                                 cfs_time_current_sec());
<a name="l01914"></a>01914                                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01915"></a>01915                                 <span class="keywordflow">return</span> 0;
<a name="l01916"></a>01916                         }
<a name="l01917"></a>01917                 } <span class="keywordflow">else</span> {
<a name="l01918"></a>01918                         CDEBUG(D_SEC, <span class="stringliteral">&quot;mark middle expired\n&quot;</span>);
<a name="l01919"></a>01919                         exp-&gt;exp_flvr_expire[0] = 0;
<a name="l01920"></a>01920                 }
<a name="l01921"></a>01921                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): %x not match middle\n&quot;</span>, exp,
<a name="l01922"></a>01922                        exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01923"></a>01923                        exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01924"></a>01924                        req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01925"></a>01925         }
<a name="l01926"></a>01926 
<a name="l01927"></a>01927         <span class="comment">/* now it doesn&apos;t match the current flavor, the only chance we can</span>
<a name="l01928"></a>01928 <span class="comment">         * accept it is match the old flavors which is not expired. */</span>
<a name="l01929"></a>01929         <span class="keywordflow">if</span> (exp-&gt;exp_flvr_changed == 0 &amp;&amp; exp-&gt;exp_flvr_expire[1]) {
<a name="l01930"></a>01930                 <span class="keywordflow">if</span> (exp-&gt;exp_flvr_expire[1] &gt;= cfs_time_current_sec()) {
<a name="l01931"></a>01931                         <span class="keywordflow">if</span> (flavor_allowed(&amp;exp-&gt;exp_flvr_old[1], req)) {
<a name="l01932"></a>01932                                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): match the &quot;</span>
<a name="l01933"></a>01933                                        <span class="stringliteral">&quot;oldest one (&quot;</span>CFS_DURATION_T<span class="stringliteral">&quot;)\n&quot;</span>, exp,
<a name="l01934"></a>01934                                        exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01935"></a>01935                                        exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01936"></a>01936                                        exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01937"></a>01937                                        exp-&gt;exp_flvr_expire[1] -
<a name="l01938"></a>01938                                                 cfs_time_current_sec());
<a name="l01939"></a>01939                                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01940"></a>01940                                 <span class="keywordflow">return</span> 0;
<a name="l01941"></a>01941                         }
<a name="l01942"></a>01942                 } <span class="keywordflow">else</span> {
<a name="l01943"></a>01943                         CDEBUG(D_SEC, <span class="stringliteral">&quot;mark oldest expired\n&quot;</span>);
<a name="l01944"></a>01944                         exp-&gt;exp_flvr_expire[1] = 0;
<a name="l01945"></a>01945                 }
<a name="l01946"></a>01946                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): %x not match found\n&quot;</span>,
<a name="l01947"></a>01947                        exp, exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01948"></a>01948                        exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01949"></a>01949                        req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01950"></a>01950         } <span class="keywordflow">else</span> {
<a name="l01951"></a>01951                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): skip the last one\n&quot;</span>,
<a name="l01952"></a>01952                        exp, exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01953"></a>01953                        exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01954"></a>01954         }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01957"></a>01957 
<a name="l01958"></a>01958         CWARN(<span class="stringliteral">&quot;exp %p(%s): req %p (%u|%u|%u|%u|%u|%u) with &quot;</span>
<a name="l01959"></a>01959               <span class="stringliteral">&quot;unauthorized flavor %x, expect %x|%x(%+ld)|%x(%+ld)\n&quot;</span>,
<a name="l01960"></a>01960               exp, exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_name,
<a name="l01961"></a>01961               req, req-&gt;rq_auth_gss, req-&gt;rq_ctx_init, req-&gt;rq_ctx_fini,
<a name="l01962"></a>01962               req-&gt;rq_auth_usr_root, req-&gt;rq_auth_usr_mdt, req-&gt;rq_auth_usr_ost,
<a name="l01963"></a>01963               req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01964"></a>01964               exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01965"></a>01965               exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01966"></a>01966               exp-&gt;exp_flvr_expire[0] ?
<a name="l01967"></a>01967               (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (exp-&gt;exp_flvr_expire[0] -
<a name="l01968"></a>01968                                cfs_time_current_sec()) : 0,
<a name="l01969"></a>01969               exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01970"></a>01970               exp-&gt;exp_flvr_expire[1] ?
<a name="l01971"></a>01971               (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (exp-&gt;exp_flvr_expire[1] -
<a name="l01972"></a>01972                                cfs_time_current_sec()) : 0);
<a name="l01973"></a>01973         <span class="keywordflow">return</span> -EACCES;
<a name="l01974"></a>01974 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__sptlrpc_gaf12efdd6553013c0e886d356541dd86b_cgraph.png" border="0" usemap="#group__sptlrpc_gaf12efdd6553013c0e886d356541dd86b_cgraph_map" alt=""></div>
<map name="group__sptlrpc_gaf12efdd6553013c0e886d356541dd86b_cgraph_map" id="group__sptlrpc_gaf12efdd6553013c0e886d356541dd86b_cgraph">
<area shape="rect" id="node3" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration..." alt="" coords="273,5,468,35"/></map>
</div>
</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:46 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
