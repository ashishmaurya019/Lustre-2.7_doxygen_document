<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: cl_page Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cl_page Struct Reference<br/>
<small>
[<a class="el" href="group__cl__page.html">cl_page</a>]</small>
</h1><!-- doxytag: class="cl_page" -->
<p>Fields are protected by the lock on struct page, except for atomics and immutables.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl__object_8h_source.html">cl_object.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for cl_page:</div>
<div class="dynsection">
<div class="center"><img src="structcl__page__coll__graph.png" border="0" usemap="#cl__page_coll__map" alt="Collaboration graph"/></div>
<map name="cl__page_coll__map" id="cl__page_coll__map">
<area shape="rect" id="node133" href="structcl__io.html" title="State for io." alt="" coords="1471,1870,1634,2874"/><area shape="rect" id="node2" href="structlist__head.html" title="{list_head\n|+ next\l+ prev\l|}" alt="" coords="1351,14,1434,117"/><area shape="rect" id="node9" href="structlu__object.html" title="Layer in the layered object." alt="" coords="2374,688,2478,843"/><area shape="rect" id="node16" href="structlu__object__header.html" title="&quot;Compound&quot; object, consisting of multiple layers." alt="" coords="2638,209,2777,415"/><area shape="rect" id="node26" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking." alt="" coords="2493,1414,2618,1621"/><area shape="rect" id="node29" href="structobd__device.html" title="{obd_device\n|+ obd_type\l+ obd_magic\l+ obd_minor\l+ obd_lu_dev\l+ obd_uuid\l+ obd_name\l+ obd_attached\l+ obd_set_up\l+ obd_recovering\l+ obd_abort_recovery\l+ obd_version_recov\l+ obd_replayable\l+ obd_no_transno\l+ obd_no_recov\l+ obd_stopping\l+ obd_starting\l+ obd_force\l+ obd_fail\l+ obd_no_conn\l+ obd_inactive\l+ obd_no_ir\l+ obd_process_conf\l+ obd_uses_nid_stats\l+ obd_recovery_expired\l+ obd_uuid_hash\l+ obd_nid_hash\l+ obd_nid_stats_hash\l+ obd_gen_hash\l+ obd_nid_stats\l+ obd_exports\l+ obd_unlinked_exports\l+ obd_delayed_exports\l+ obd_lwp_list\l+ obd_refcount\l+ obd_num_exports\l+ obd_nid_lock\l+ obd_namespace\l+ obd_ldlm_client\l+ obd_dev_lock\l+ obd_osfs_lock\l+ obd_osfs\l+ obd_osfs_age\l+ obd_last_committed\l+ obd_dev_mutex\l+ obd_lvfs_ctxt\l+ obd_olg\l+ obd_observer\l+ obd_observer_link_sem\l+ obd_upcall\l+ obd_self_export\l+ obd_lwp_export\l+ obd_exports_timed\l+ obd_eviction_timer\l+ obd_max_recoverable_clients\l+ obd_connected_clients\l+ obd_stale_clients\l+ obd_recovery_task_lock\l+ obd_next_recovery_transno\l+ obd_replayed_requests\l+ obd_requests_queued_for_recovery\l+ obd_next_transno_waitq\l+ obd_recovery_timer\l+ obd_recovery_start\l+ obd_recovery_end\l+ obd_recovery_time_hard\l+ obd_recovery_timeout\l+ obd_recovery_ir_factor\l+ obd_replayed_locks\l+ obd_req_replay_clients\l+ obd_lock_replay_clients\l+ obd_recovery_data\l+ obd_req_replay_queue\l+ obd_lock_replay_queue\l+ obd_final_req_queue\l+ cli\l+ echo_client\l+ lov\l+ lmv\l+ u\l+ obd_stats\l+ obd_cntr_base\l+ obd_md_cntr_base\l+ obd_md_stats\l+ obd_proc_entry\l+ obd_proc_exports_entry\l+ obd_svc_procroot\l+ obd_svc_stats\l+ obd_vars\l+ obd_evict_inprogress\l+ obd_evict_inprogress_waitq\l+ obd_evict_list\l+ obd_pool_lock\l+ obd_pool_slv\l+ obd_pool_limit\l+ obd_conn_inprogress\l+ obd_reference\l|}" alt="" coords="1338,4131,1613,5863"/><area shape="rect" id="node31" href="structecho__client__obd.html" title="{echo_client_obd\n|+ ec_exp\l+ ec_lock\l+ ec_objects\l+ ec_locks\l+ ec_unique\l|}" alt="" coords="714,7720,845,7875"/><area shape="rect" id="node34" href="structobd__export.html" title="Export structure." alt="" coords="506,5947,749,7037"/><area shape="rect" id="node40" href="structcfs__workitem.html" title="{cfs_workitem\n|+ wi_list\l+ wi_action\l+ wi_data\l+ wi_running\l+ wi_scheduled\l|}" alt="" coords="934,440,1059,595"/><area shape="rect" id="node59" href="structobd__type.html" title="{obd_type\n|+ typ_chain\l+ typ_dt_ops\l+ typ_md_ops\l+ typ_procroot\l+ typ_procsym\l+ typ_sym_filter\l+ typ_name\l+ typ_refcnt\l+ typ_lu\l+ obd_type_lock\l|}" alt="" coords="2190,3701,2323,3942"/><area shape="rect" id="node64" href="structlu__device__type.html" title="Type of device." alt="" coords="2249,3157,2374,3347"/><area shape="rect" id="node82" href="structclient__obd.html" title="{client_obd\n|+ cl_sem\l+ cl_target_uuid\l+ cl_import\l+ cl_conn_count\l+ cl_default_mds_easize\l+ cl_max_mds_easize\l+ cl_sp_me\l+ cl_sp_to\l+ cl_flvr_mgc\l+ cl_dirty_pages\l+ cl_dirty_max_pages\l+ cl_dirty_transit\l+ cl_avail_grant\l+ cl_lost_grant\l+ cl_dirty_grant\l+ cl_reserved_grant\l+ cl_cache_waiters\l+ cl_next_shrink_grant\l+ cl_grant_shrink_list\l+ cl_grant_shrink_interval\l+ cl_chunkbits\l+ cl_grant_extent_tax\l+ cl_max_extent_pages\l+ cl_loi_list_lock\l+ cl_loi_ready_list\l+ cl_loi_hp_ready_list\l+ cl_loi_write_list\l+ cl_loi_read_list\l+ cl_r_in_flight\l+ cl_w_in_flight\l+ cl_pending_w_pages\l+ cl_pending_r_pages\l+ cl_max_pages_per_rpc\l+ cl_max_rpcs_in_flight\l+ cl_read_rpc_hist\l+ cl_write_rpc_hist\l+ cl_read_page_hist\l+ cl_write_page_hist\l+ cl_read_offset_hist\l+ cl_write_offset_hist\l+ cl_cache\l+ cl_lru_osc\l+ cl_lru_left\l+ cl_lru_busy\l+ cl_lru_in_list\l+ cl_lru_shrinkers\l+ cl_lru_last_used\l+ cl_lru_reclaim\l+ cl_lru_list\l+ cl_lru_list_lock\l+ cl_unstable_count\l+ cl_shrink_list\l+ cl_destroy_in_flight\l+ cl_destroy_waitq\l+ cl_rpc_lock\l+ cl_mod_rpcs_lock\l+ cl_max_mod_rpcs_in_flight\l+ cl_mod_rpcs_in_flight\l+ cl_close_rpcs_in_flight\l+ cl_mod_rpcs_waitq\l+ cl_mod_tag_bitmap\l+ cl_mod_rpcs_hist\l+ cl_mgc_mutex\l+ cl_mgc_los\l+ cl_mgc_configs_dir\l+ cl_mgc_refcount\l+ cl_mgc_mgsexp\l+ cl_checksum\l+ cl_supp_cksum_types\l+ cl_cksum_type\l+ cl_ar\l+ cl_seq\l+ cl_resends\l+ cl_writeback_work\l+ cl_lru_work\l+ cl_quota_hash\l|}" alt="" coords="133,7105,346,8490"/><area shape="rect" id="node93" href="structldlm__namespace.html" title="LDLM Namespace." alt="" coords="2269,6198,2453,6786"/><area shape="rect" id="node99" href="structlov__obd.html" title="{lov_obd\n|+ desc\l+ lov_tgts\l+ lov_packed\l+ lov_lock\l+ lov_ocd\l+ targets_proc_entry\l+ lov_refcount\l+ lov_death_row\l+ lov_tgt_size\l+ lov_connects\l+ lov_pool_count\l+ lov_pools_hash_body\l+ lov_pool_list\l+ lov_pool_proc_entry\l+ lov_sp_me\l+ lov_cache\l+ lov_notify_lock\l|}" alt="" coords="1813,3640,1986,4003"/><area shape="rect" id="node117" href="structlu__site.html" title="lu_site is a &quot;compartment&quot; within which objects are unique, and LRU discipline..." alt="" coords="2703,7668,2845,7927"/><area shape="rect" id="node139" href="structcl__page__list.html" title="{cl_page_list\n|+ pl_nr\l+ pl_pages\l+ pl_owner\l|}" alt="" coords="1343,252,1442,372"/><area shape="rect" id="node147" href="structcl__lockset.html" title="Lock&#45;set represents a collection of locks, that io needs at a time." alt="" coords="1178,1243,1271,1346"/><area shape="rect" id="node5" href="structcl__object.html" title="Sub&#45;class of lu_object with methods common for objects on the client stacks." alt="" coords="1846,1081,1961,1201"/><area shape="rect" id="node7" href="structcl__object__operations.html" title="Operations implemented for each cl object layer." alt="" coords="1817,619,1979,912"/><area shape="rect" id="node113" href="structlu__device__operations.html" title="Operations common for data and meta&#45;data devices." alt="" coords="2319,1073,2514,1210"/><area shape="rect" id="node12" href="structlu__object__operations.html" title="Operations specific for particular lu_object." alt="" coords="2443,217,2614,407"/><area shape="rect" id="node14" href="structlu__ref__link.html" title="{lu_ref_link\n||}" alt="" coords="2170,269,2255,355"/><area shape="rect" id="node19" href="structhlist__node.html" title="{hlist_node\n|+ next\l+ pprev\l|}" alt="" coords="570,14,661,117"/><area shape="rect" id="node22" href="structlu__fid.html" title="File IDentifier." alt="" coords="2893,5,2965,125"/><area shape="rect" id="node24" href="structlu__ref.html" title="{lu_ref\n||}" alt="" coords="2414,23,2473,108"/><area shape="rect" id="node68" href="structlu__device__type__operations.html" title="Operations on a device type." alt="" coords="2213,2269,2415,2475"/><area shape="rect" id="node119" href="structlu__target.html" title="{lu_target\n|+ lut_obd\l+ lut_bottom\l+ lut_tdtd\l+ lut_tdtd_commit_thread\l+ lut_slice\l+ lut_reply_fail_id\l+ lut_request_fail_id\l+ lut_sptlrpc_lock\l+ lut_sptlrpc_rset\l+ lut_flags_lock\l+ lut_sec_level\l+ lut_syncjournal\l+ lut_sync_lock_cancel\l+ lut_no_reconstruct\l+ lut_last_rcvd\l+ lut_txn_cb\l+ lut_lsd\l+ lut_last_transno\l+ lut_translock\l+ lut_client_bitmap_lock\l+ lut_client_bitmap\l+ lut_num_clients\l+ lut_client_generation\l+ lut_reply_data\l+ lut_reply_bitmap\l+ lut_sync_count\l|}" alt="" coords="1759,6233,1962,6751"/><area shape="rect" id="node108" href="structlmv__obd.html" title="{lmv_obd\n|+ refcount\l+ lmv_fld\l+ lmv_lock\l+ lmv_placement\l+ desc\l+ cluuid\l+ exp\l+ targets_proc_entry\l+ lmv_init_mutex\l+ connected\l+ max_easize\l+ max_def_easize\l+ tgts_size\l+ tgts\l+ conn_data\l|}" alt="" coords="869,7633,1034,7961"/><area shape="rect" id="node126" href="structseq__server__site.html" title="{seq_server_site\n|+ ss_lu\l+ ss_node_id\l+ ss_server_fld\l+ ss_client_fld\l+ ss_server_seq\l+ ss_control_seq\l+ ss_control_exp\l+ ss_client_seq\l|}" alt="" coords="2599,8558,2735,8765"/><area shape="rect" id="node36" href="structcfs__hash.html" title="cfs_hash is a hash&#45;table implementation for general purpose, it can support: ." alt="" coords="1205,3019,1367,3485"/><area shape="rect" id="node38" href="unioncfs__hash__lock.html" title="{cfs_hash_lock\n|+ rw\l+ spin\l|}" alt="" coords="1065,1466,1177,1569"/><area shape="rect" id="node43" href="structcfs__hash__bucket.html" title="cfs_hash_bucket is a container of:lock, counter ." alt="" coords="1314,2286,1447,2458"/><area shape="rect" id="node46" href="structcfs__hash__hlist__ops.html" title="{cfs_hash_hlist_ops\n|+ hop_hhead\l+ hop_hhead_size\l+ hop_hnode_add\l+ hop_hnode_del\l|}" alt="" coords="1746,2303,1890,2441"/><area shape="rect" id="node48" href="structcfs__hash__lock__ops.html" title="{cfs_hash_lock_ops\n|+ hs_lock\l+ hs_unlock\l+ hs_bkt_lock\l+ hs_bkt_unlock\l|}" alt="" coords="897,2303,1038,2441"/><area shape="rect" id="node50" href="structcfs__hash__ops.html" title="{cfs_hash_ops\n|+ hs_hash\l+ hs_key\l+ hs_keycpy\l+ hs_keycmp\l+ hs_object\l+ hs_get\l+ hs_put\l+ hs_put_locked\l+ hs_exit\l|}" alt="" coords="1062,2260,1193,2484"/><area shape="rect" id="node55" href="structobd__uuid.html" title="{obd_uuid\n|+ uuid\l|}" alt="" coords="450,3779,530,3864"/><area shape="rect" id="node62" href="structmd__ops.html" title="{md_ops\n|+ m_close\l+ m_create\l+ m_enqueue\l+ m_getattr\l+ m_intent_lock\l+ m_link\l+ m_rename\l+ m_setattr\l+ m_fsync\l+ m_read_page\l+ m_unlink\l+ m_setxattr\l+ m_getxattr\l+ m_intent_getattr_async\l+ m_revalidate_lock\l+ m_get_root\l+ m_null_inode\l+ m_getattr_name\l+ m_init_ea_size\l+ m_get_lustre_md\l+ m_free_lustre_md\l+ m_merge_attr\l+ m_set_open_replay_data\l+ m_clear_open_replay_data\l+ m_set_lock_data\l+ m_lock_match\l+ m_cancel_unused\l+ m_get_remote_perm\l+ m_get_fid_from_lsm\l+ m_unpackmd\l|}" alt="" coords="2011,2958,2225,3546"/><area shape="rect" id="node71" href="structlprocfs__stats.html" title="{lprocfs_stats\n|+ ls_num\l+ ls_biggest_alloc_num\l+ ls_flags\l+ ls_lock\l+ ls_cnt_header\l+ ls_percpu\l|}" alt="" coords="2550,3735,2726,3907"/><area shape="rect" id="node73" href="structobd__notify__upcall.html" title="{obd_notify_upcall\n|+ onu_upcall\l+ onu_owner\l|}" alt="" coords="655,3770,791,3873"/><area shape="rect" id="node76" href="structptlrpc__client.html" title="Client definition for PortalRPC." alt="" coords="815,3761,970,3881"/><area shape="rect" id="node78" href="structobd__llog__group.html" title="{obd_llog_group\n|+ olg_ctxts\l+ olg_waitq\l+ olg_lock\l+ olg_cat_processing\l|}" alt="" coords="994,3753,1157,3890"/><area shape="rect" id="node80" href="structlprocfs__vars.html" title="{lprocfs_vars\n|+ name\l+ fops\l+ data\l+ proc_mode\l|}" alt="" coords="1181,3753,1290,3890"/><area shape="rect" id="node88" href="structobd__statfs.html" title="{obd_statfs\n|+ os_type\l+ os_blocks\l+ os_bfree\l+ os_bavail\l+ os_files\l+ os_ffree\l+ os_fsid\l+ os_bsize\l+ os_namelen\l+ os_maxbytes\l+ os_state\l+ os_fprecreated\l+ os_spare2\l+ os_spare3\l+ os_spare4\l+ os_spare5\l+ os_spare6\l+ os_spare7\l+ os_spare8\l+ os_spare9\l|}" alt="" coords="1314,3614,1453,4029"/><area shape="rect" id="node103" href="structtarget__recovery__data.html" title="{target_recovery_data\n|+ trd_recovery_handler\l+ trd_processing_task\l+ trd_starting\l+ trd_finishing\l|}" alt="" coords="1477,3753,1655,3890"/><area shape="rect" id="node105" href="structlvfs__run__ctxt.html" title="{lvfs_run_ctxt\n|+ pwdmnt\l+ pwd\l+ fs\l+ umask\l+ dt\l+ magic\l|}" alt="" coords="1679,3735,1789,3907"/><area shape="rect" id="node131" href="structcl__sync__io.html" title="Anchor for synchronous transfer." alt="" coords="1502,1064,1614,1219"/><area shape="rect" id="node137" href="structcl__2queue.html" title="A 2&#45;queue of pages." alt="" coords="1369,937,1459,1039"/><area shape="rect" id="node145" href="structost__lvb.html" title="{ost_lvb\n|+ lvb_size\l+ lvb_mtime\l+ lvb_atime\l+ lvb_ctime\l+ lvb_blocks\l+ lvb_mtime_ns\l+ lvb_atime_ns\l+ lvb_ctime_ns\l+ lvb_padding\l|}" alt="" coords="1567,1405,1695,1629"/><area shape="rect" id="node150" href="structcl__io__rw__common.html" title="{cl_io_rw_common\n|+ crw_pos\l+ crw_count\l+ crw_nonblock\l|}" alt="" coords="1719,1457,1858,1577"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">atomic_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#a1dc94f624c3d567c7e870e75d0bd2954">cp_ref</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference counter.  <a href="#a1dc94f624c3d567c7e870e75d0bd2954"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#aaf3ea4b65234c8ef58960233b82172b1">cp_error</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer error.  <a href="#aaf3ea4b65234c8ef58960233b82172b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#aa26f7281959921dababe7892b869abb2">cp_obj</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An object this page is a part of.  <a href="#aa26f7281959921dababe7892b869abb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a4e391a7b741652812a451580176c9a"></a><!-- doxytag: member="cl_page::cp_vmpage" ref="a9a4e391a7b741652812a451580176c9a" args="" -->
struct page *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#a9a4e391a7b741652812a451580176c9a">cp_vmpage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vmpage <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#a728db31646edabc4ff8c8cfc3f30f10f">cp_batch</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linkage of pages within group.  <a href="#a728db31646edabc4ff8c8cfc3f30f10f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#a96b574e5021d9b6464adac298980e594">cp_layers</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of slices.  <a href="#a96b574e5021d9b6464adac298980e594"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">cl_page_state</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#a96e9addda3754eb5551faaa00f94e903">cp_state</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Page state.  <a href="#a96e9addda3754eb5551faaa00f94e903"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#a5b1df421c69f4dd003decae6bfa71467">cp_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Page type.  <a href="#a5b1df421c69f4dd003decae6bfa71467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a">cp_owner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Owning IO in <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">cl_page_state::CPS_OWNED</a> state.  <a href="#aa9fa7162c90de9f32abb3aa306c2112a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__ref.html">lu_ref</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#a6df94d2c121a8372ded94e0bf00d8c45">cp_reference</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of references to this page, for debugging.  <a href="#a6df94d2c121a8372ded94e0bf00d8c45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__ref__link.html">lu_ref_link</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#a35d94ccfb7dfb16b315370024fea00cf">cp_obj_ref</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Link to an object, for debugging.  <a href="#a35d94ccfb7dfb16b315370024fea00cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__ref__link.html">lu_ref_link</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#abfe411a851a9881cc9aca12ac6fcaf94">cp_queue_ref</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Link to a queue, for debugging.  <a href="#abfe411a851a9881cc9aca12ac6fcaf94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fee0561b08bf01258f9824f0c2b62d2"></a><!-- doxytag: member="cl_page::cp_sync_io" ref="a9fee0561b08bf01258f9824f0c2b62d2" args="" -->
struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html#a9fee0561b08bf01258f9824f0c2b62d2">cp_sync_io</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigned if doing a sync_io. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Fields are protected by the lock on struct page, except for atomics and immutables. </p>
<p>Layered client page.</p>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>Data type invariants are in cl_page_invariant(). Basically: cl_page::cp_parent and cl_page::cp_child are a well-formed double-linked list, consistent with the parent/child pointers in the <a class="el" href="structcl__page.html#aa26f7281959921dababe7892b869abb2" title="An object this page is a part of.">cl_page::cp_obj</a> and <a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> (when set).</dd></dl>
<p><a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>: represents a portion of a file, cached in the memory. All pages of the given file are of the same size, and are kept in the radix tree hanging off the <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>. <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> doesn't fan out, but as sub-objects of the top-level file object are first class cl_objects, they have their own radix trees of pages and hence page is implemented as a sequence of struct cl_pages's, linked into double-linked list through cl_page::cp_parent and cl_page::cp_child pointers, each residing in the corresponding radix tree at the corresponding logical offset.</p>
<p><a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is associated with VM page of the hosting environment (struct page in Linux kernel, for example), struct page. It is assumed, that this association is implemented by one of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> layers (top layer in the current design) that</p>
<ul>
<li>intercepts per-VM-page call-backs made by the environment (e.g., memory pressure),</li>
</ul>
<ul>
<li>translates state (page flag bits) and locking between lustre and environment.</li>
</ul>
<p>The association between <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> and struct page is immutable and established when <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is created.</p>
<p><a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> can be "owned" by a particular <a class="el" href="structcl__io.html" title="State for io.">cl_io</a> (see below), guaranteeing this io an exclusive access to this page w.r.t. other io attempts and various events changing page state (such as transfer completion, or eviction of the page from the memory). Note, that in general <a class="el" href="structcl__io.html" title="State for io.">cl_io</a> cannot be identified with a particular thread, and page ownership is not exactly equal to the current thread holding a lock on the page. Layer implementing association between <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> and struct page has to implement ownership on top of available synchronization mechanisms.</p>
<p>While lustre client maintains the notion of an page ownership by io, hosting MM/VM usually has its own page concurrency control mechanisms. For example, in Linux, page access is synchronized by the per-page PG_locked bit-lock, and generic kernel code (generic_file_*()) takes care to acquire and release such locks as necessary around the calls to the file system methods (-&gt;readpage(), -&gt;prepare_write(), -&gt;commit_write(), etc.). This leads to the situation when there are two different ways to own a page in the client:</p>
<ul>
<li>client code explicitly and voluntary owns the page (<a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own()</a>);</li>
</ul>
<ul>
<li>VM locks a page and then calls the client, that has "to assume" the ownership from the VM (<a class="el" href="group__cl__page.html#ga77a2e8592e58cc9c514cb4ac38a9d2f4" title="Assume page ownership.">cl_page_assume()</a>).</li>
</ul>
<p>Dual methods to release ownership are <a class="el" href="group__cl__page.html#gae41a4c98faae723b2566a721b6e4b7fb" title="Releases page ownership.">cl_page_disown()</a> and <a class="el" href="group__cl__page.html#ga4e7db1845b76bea8277b4e3d2a482f61" title="Releases page ownership without unlocking the page.">cl_page_unassume()</a>.</p>
<p><a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is reference counted (<a class="el" href="structcl__page.html#a1dc94f624c3d567c7e870e75d0bd2954" title="Reference counter.">cl_page::cp_ref</a>). When reference counter drops to 0, the page is returned to the cache, unless it is in <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a> state, in which case it is immediately destroyed.</p>
<p>The general logic guaranteeing the absence of "existential races" for pages is the following:</p>
<ul>
<li>there are fixed known ways for a thread to obtain a new reference to a page:</li>
</ul>
<ul>
<li>by doing a lookup in the <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> radix tree, protected by the spin-lock;</li>
</ul>
<ul>
<li>by starting from VM-locked struct page and following some hosting environment method (e.g., following -&gt;private pointer in the case of Linux kernel), see <a class="el" href="group__cl__page.html#gac3255abeeef8f9d9f3a4c80f553a75ed" title="Returns a cl_page associated with a VM page, and given cl_object.">cl_vmpage_page()</a>;</li>
</ul>
<ul>
<li>when the page enters <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a> state, all these ways are severed with the proper synchronization (<a class="el" href="group__cl__page.html#ga55a51f6efaa6effc3b5b3d045d4ee432" title="Called when a decision is made to throw page out of memory.">cl_page_delete()</a>);</li>
</ul>
<ul>
<li>entry into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a> is serialized by the VM page lock;</li>
</ul>
<ul>
<li>no new references to the page in <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a> state are allowed (checked in <a class="el" href="group__cl__page.html#gafc2fc785c3daf1db46bb250244dfde13" title="Acquires an additional reference to a page.">cl_page_get()</a>).</li>
</ul>
<p>Together this guarantees that when last reference to a <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a> page is released, it is safe to destroy the page, as neither references to it can be acquired at that point, nor ones exist.</p>
<p><a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is a state machine. States are enumerated in enum cl_page_state. Possible state transitions are enumerated in cl_page_state_set(). State transition process (i.e., actual changing of <a class="el" href="structcl__page.html#a96e9addda3754eb5551faaa00f94e903" title="Page state.">cl_page::cp_state</a> field) is protected by the lock on the underlying VM page.</p>
<p>Linux Kernel implementation.</p>
<p>Binding between <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> and struct page (which is a typedef for struct page) is implemented in the vvp layer. <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is attached to the -&gt;private pointer of the struct page, together with the setting of PG_private bit in page-&gt;flags, and acquiring additional reference on the struct page (much like struct buffer_head, or any similar file system private data structures).</p>
<p>PG_locked lock is used to implement both ownership and transfer synchronization, that is, page is VM-locked in CPS_{OWNED,PAGE{IN,OUT}} states. No additional references are acquired for the duration of the transfer.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>*THIS IS NOT* the behavior expected by the Linux kernel, where write-out is "protected" by the special PG_writeback bit. </dd></dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00714">714</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a728db31646edabc4ff8c8cfc3f30f10f"></a><!-- doxytag: member="cl_page::cp_batch" ref="a728db31646edabc4ff8c8cfc3f30f10f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__head.html">list_head</a> <a class="el" href="structcl__page.html#a728db31646edabc4ff8c8cfc3f30f10f">cl_page::cp_batch</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linkage of pages within group. </p>
<p>Pages must be owned </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00724">724</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00866">cl_page_list_add()</a>, <a class="el" href="cl__io_8c_source.html#l00886">cl_page_list_del()</a>, <a class="el" href="cl__io_8c_source.html#l00963">cl_page_list_disown()</a>, <a class="el" href="cl__io_8c_source.html#l00905">cl_page_list_move()</a>, <a class="el" href="cl__io_8c_source.html#l00925">cl_page_list_move_head()</a>, and <a class="el" href="cl__page_8c_source.html#l00372">cl_page_put()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf3ea4b65234c8ef58960233b82172b1"></a><!-- doxytag: member="cl_page::cp_error" ref="aaf3ea4b65234c8ef58960233b82172b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structcl__page.html#aaf3ea4b65234c8ef58960233b82172b1">cl_page::cp_error</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer error. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00718">718</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l01015">cl_page_list_own()</a>.</p>

</div>
</div>
<a class="anchor" id="a96b574e5021d9b6464adac298980e594"></a><!-- doxytag: member="cl_page::cp_layers" ref="a96b574e5021d9b6464adac298980e594" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__head.html">list_head</a> <a class="el" href="structcl__page.html#a96b574e5021d9b6464adac298980e594">cl_page::cp_layers</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of slices. </p>
<p>Immutable after creation. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00726">726</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00821">cl_page_is_vmlocked()</a>, and <a class="el" href="cl__page_8c_source.html#l01080">cl_page_slice_add()</a>.</p>

</div>
</div>
<a class="anchor" id="aa26f7281959921dababe7892b869abb2"></a><!-- doxytag: member="cl_page::cp_obj" ref="aa26f7281959921dababe7892b869abb2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__object.html">cl_object</a>* <a class="el" href="structcl__page.html#aa26f7281959921dababe7892b869abb2">cl_page::cp_obj</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An object this page is a part of. </p>
<p>Immutable after creation. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00720">720</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00652">cl_page_assume()</a>, <a class="el" href="cl__page_8c_source.html#l01011">cl_page_header_print()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, and <a class="el" href="osc__page_8c_source.html#l00667">osc_lru_shrink()</a>.</p>

</div>
</div>
<a class="anchor" id="a35d94ccfb7dfb16b315370024fea00cf"></a><!-- doxytag: member="cl_page::cp_obj_ref" ref="a35d94ccfb7dfb16b315370024fea00cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__ref__link.html">lu_ref_link</a> <a class="el" href="structcl__page.html#a35d94ccfb7dfb16b315370024fea00cf">cl_page::cp_obj_ref</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Link to an object, for debugging. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00746">746</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9fa7162c90de9f32abb3aa306c2112a"></a><!-- doxytag: member="cl_page::cp_owner" ref="aa9fa7162c90de9f32abb3aa306c2112a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__io.html">cl_io</a>* <a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a">cl_page::cp_owner</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Owning IO in <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">cl_page_state::CPS_OWNED</a> state. </p>
<p>Sub-page can be owned by sub-io. Protected by a VM lock. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00742">742</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00652">cl_page_assume()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, <a class="el" href="cl__io_8c_source.html#l00866">cl_page_list_add()</a>, and <a class="el" href="cl__page_8c_source.html#l00372">cl_page_put()</a>.</p>

</div>
</div>
<a class="anchor" id="abfe411a851a9881cc9aca12ac6fcaf94"></a><!-- doxytag: member="cl_page::cp_queue_ref" ref="abfe411a851a9881cc9aca12ac6fcaf94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__ref__link.html">lu_ref_link</a> <a class="el" href="structcl__page.html#abfe411a851a9881cc9aca12ac6fcaf94">cl_page::cp_queue_ref</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Link to a queue, for debugging. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00748">748</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00866">cl_page_list_add()</a>, <a class="el" href="cl__io_8c_source.html#l00886">cl_page_list_del()</a>, <a class="el" href="cl__io_8c_source.html#l00963">cl_page_list_disown()</a>, <a class="el" href="cl__io_8c_source.html#l00905">cl_page_list_move()</a>, and <a class="el" href="cl__io_8c_source.html#l00925">cl_page_list_move_head()</a>.</p>

</div>
</div>
<a class="anchor" id="a1dc94f624c3d567c7e870e75d0bd2954"></a><!-- doxytag: member="cl_page::cp_ref" ref="a1dc94f624c3d567c7e870e75d0bd2954" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atomic_t <a class="el" href="structcl__page.html#a1dc94f624c3d567c7e870e75d0bd2954">cl_page::cp_ref</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reference counter. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00716">716</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00372">cl_page_put()</a>.</p>

</div>
</div>
<a class="anchor" id="a6df94d2c121a8372ded94e0bf00d8c45"></a><!-- doxytag: member="cl_page::cp_reference" ref="a6df94d2c121a8372ded94e0bf00d8c45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__ref.html">lu_ref</a> <a class="el" href="structcl__page.html#a6df94d2c121a8372ded94e0bf00d8c45">cl_page::cp_reference</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of references to this page, for debugging. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00744">744</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00866">cl_page_list_add()</a>, <a class="el" href="cl__io_8c_source.html#l00886">cl_page_list_del()</a>, <a class="el" href="cl__io_8c_source.html#l00963">cl_page_list_disown()</a>, <a class="el" href="cl__io_8c_source.html#l00905">cl_page_list_move()</a>, and <a class="el" href="cl__io_8c_source.html#l00925">cl_page_list_move_head()</a>.</p>

</div>
</div>
<a class="anchor" id="a96e9addda3754eb5551faaa00f94e903"></a><!-- doxytag: member="cl_page::cp_state" ref="a96e9addda3754eb5551faaa00f94e903" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">cl_page_state</a> <a class="el" href="structcl__page.html#a96e9addda3754eb5551faaa00f94e903">cl_page::cp_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Page state. </p>
<p>This field is const to avoid accidental update, it is modified only internally within <a class="el" href="cl__page_8c_source.html">cl_page.c</a>. Protected by a VM lock. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00731">731</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00909">cl_page_completion()</a>, <a class="el" href="cl__page_8c_source.html#l00709">cl_page_disown()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, <a class="el" href="cl__page_8c_source.html#l00943">cl_page_make_ready()</a>, and <a class="el" href="cl__page_8c_source.html#l00372">cl_page_put()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b1df421c69f4dd003decae6bfa71467"></a><!-- doxytag: member="cl_page::cp_type" ref="a5b1df421c69f4dd003decae6bfa71467" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> <a class="el" href="structcl__page.html#a5b1df421c69f4dd003decae6bfa71467">cl_page::cp_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Page type. </p>
<p>Only CPT_TRANSIENT is used so far. Immutable after creation. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00736">736</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00866">cl_page_prep()</a>, and <a class="el" href="cl__page_8c_source.html#l00398">cl_vmpage_page()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="cl__object_8h_source.html">cl_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:56:19 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
