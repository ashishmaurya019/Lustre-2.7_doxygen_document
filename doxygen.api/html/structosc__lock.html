<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: osc_lock Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>osc_lock Struct Reference<br/>
<small>
[<a class="el" href="group__osc.html">osc</a>]</small>
</h1><!-- doxytag: class="osc_lock" -->
<p>osc-private state of <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for osc_lock:</div>
<div class="dynsection">
<div class="center"><img src="structosc__lock__coll__graph.png" border="0" usemap="#osc__lock_coll__map" alt="Collaboration graph"/></div>
<map name="osc__lock_coll__map" id="osc__lock_coll__map">
<area shape="rect" id="node2" href="structlist__head.html" title="{list_head\n|+ next\l+ prev\l|}" alt="" coords="1987,237,2069,339"/><area shape="rect" id="node9" href="structcl__lock__slice.html" title="Per&#45;layer part of cl_lock." alt="" coords="483,5993,589,6130"/><area shape="rect" id="node16" href="structlu__object.html" title="Layer in the layered object." alt="" coords="636,1963,740,2117"/><area shape="rect" id="node23" href="structlu__object__header.html" title="&quot;Compound&quot; object, consisting of multiple layers." alt="" coords="675,631,813,838"/><area shape="rect" id="node31" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking." alt="" coords="1103,631,1228,838"/><area shape="rect" id="node34" href="structobd__device.html" title="{obd_device\n|+ obd_type\l+ obd_magic\l+ obd_minor\l+ obd_lu_dev\l+ obd_uuid\l+ obd_name\l+ obd_attached\l+ obd_set_up\l+ obd_recovering\l+ obd_abort_recovery\l+ obd_version_recov\l+ obd_replayable\l+ obd_no_transno\l+ obd_no_recov\l+ obd_stopping\l+ obd_starting\l+ obd_force\l+ obd_fail\l+ obd_no_conn\l+ obd_inactive\l+ obd_no_ir\l+ obd_process_conf\l+ obd_uses_nid_stats\l+ obd_recovery_expired\l+ obd_uuid_hash\l+ obd_nid_hash\l+ obd_nid_stats_hash\l+ obd_gen_hash\l+ obd_nid_stats\l+ obd_exports\l+ obd_unlinked_exports\l+ obd_delayed_exports\l+ obd_lwp_list\l+ obd_refcount\l+ obd_num_exports\l+ obd_nid_lock\l+ obd_namespace\l+ obd_ldlm_client\l+ obd_dev_lock\l+ obd_osfs_lock\l+ obd_osfs\l+ obd_osfs_age\l+ obd_last_committed\l+ obd_dev_mutex\l+ obd_lvfs_ctxt\l+ obd_olg\l+ obd_observer\l+ obd_observer_link_sem\l+ obd_upcall\l+ obd_self_export\l+ obd_lwp_export\l+ obd_exports_timed\l+ obd_eviction_timer\l+ obd_max_recoverable_clients\l+ obd_connected_clients\l+ obd_stale_clients\l+ obd_recovery_task_lock\l+ obd_next_recovery_transno\l+ obd_replayed_requests\l+ obd_requests_queued_for_recovery\l+ obd_next_transno_waitq\l+ obd_recovery_timer\l+ obd_recovery_start\l+ obd_recovery_end\l+ obd_recovery_time_hard\l+ obd_recovery_timeout\l+ obd_recovery_ir_factor\l+ obd_replayed_locks\l+ obd_req_replay_clients\l+ obd_lock_replay_clients\l+ obd_recovery_data\l+ obd_req_replay_queue\l+ obd_lock_replay_queue\l+ obd_final_req_queue\l+ cli\l+ echo_client\l+ lov\l+ lmv\l+ u\l+ obd_stats\l+ obd_cntr_base\l+ obd_md_cntr_base\l+ obd_md_stats\l+ obd_proc_entry\l+ obd_proc_exports_entry\l+ obd_svc_procroot\l+ obd_svc_stats\l+ obd_vars\l+ obd_evict_inprogress\l+ obd_evict_inprogress_waitq\l+ obd_evict_list\l+ obd_pool_lock\l+ obd_pool_slv\l+ obd_pool_limit\l+ obd_conn_inprogress\l+ obd_reference\l|}" alt="" coords="1052,1174,1327,2906"/><area shape="rect" id="node42" href="structobd__export.html" title="Export structure." alt="" coords="2079,4563,2321,5653"/><area shape="rect" id="node44" href="structtg__export__data.html" title="Target&#45;specific export data." alt="" coords="2551,1902,2743,2178"/><area shape="rect" id="node47" href="structtg__reply__data.html" title="Target reply data." alt="" coords="2245,657,2392,812"/><area shape="rect" id="node50" href="structlu__nodemap.html" title="The nodemap id 0 will be the default nodemap." alt="" coords="2621,545,2819,925"/><area shape="rect" id="node55" href="structportals__handle.html" title="{portals_handle\n|+ h_link\l+ h_cookie\l+ h_owner\l+ h_ops\l+ h_rcu\l+ h_lock\l+ h_size\l+ h_in\l|}" alt="" coords="3096,1937,3213,2143"/><area shape="rect" id="node60" href="structfilter__export__data.html" title="Filter (oss&#45;side) specific import data." alt="" coords="2691,3569,2867,3828"/><area shape="rect" id="node72" href="structobd__import.html" title="Defintion of PortalRPC import structure." alt="" coords="1361,3041,1599,4357"/><area shape="rect" id="node83" href="structmdt__export__data.html" title="MDT&#45;specific export data." alt="" coords="2347,3621,2512,3776"/><area shape="rect" id="node89" href="structnid__stat.html" title="per&#45;NID statistics structure." alt="" coords="3027,3595,3184,3802"/><area shape="rect" id="node95" href="structmgs__export__data.html" title="{mgs_export_data\n|+ med_clients\l+ med_lock\l|}" alt="" coords="2127,1019,2265,1122"/><area shape="rect" id="node99" href="structec__export__data.html" title="{ec_export_data\n|+ eced_locks\l|}" alt="" coords="2131,2931,2259,3016"/><area shape="rect" id="node105" href="structcl__lock.html" title="Layered client lock." alt="" coords="488,5763,584,5866"/><area shape="rect" id="node116" href="structldlm__lock.html" title="LDLM lock structure." alt="" coords="1375,6198,1535,6994"/><area shape="rect" id="node128" href="structldlm__interval.html" title="Interval node data for each LDLM_EXTENT lock." alt="" coords="3435,683,3541,786"/><area shape="rect" id="node141" href="structldlm__resource.html" title="LDLM resource description." alt="" coords="3767,1833,3929,2247"/><area shape="rect" id="node5" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters." alt="" coords="1680,6475,1827,6717"/><area shape="rect" id="node7" href="structcl__sync__io.html" title="Anchor for synchronous transfer." alt="" coords="1851,6519,1963,6673"/><area shape="rect" id="node12" href="structcl__object.html" title="Sub&#45;class of lu_object with methods common for objects on the client stacks." alt="" coords="509,3639,624,3759"/><area shape="rect" id="node108" href="structcl__lock__descr.html" title="Lock description." alt="" coords="461,5022,587,5194"/><area shape="rect" id="node14" href="structcl__object__operations.html" title="Operations implemented for each cl object layer." alt="" coords="399,1893,561,2187"/><area shape="rect" id="node19" href="structlu__object__operations.html" title="Operations specific for particular lu_object." alt="" coords="224,640,395,829"/><area shape="rect" id="node21" href="structlu__ref__link.html" title="{lu_ref_link\n||}" alt="" coords="419,692,504,777"/><area shape="rect" id="node26" href="structhlist__node.html" title="{hlist_node\n|+ next\l+ pprev\l|}" alt="" coords="3212,237,3303,339"/><area shape="rect" id="node67" href="structptlrpc__connection.html" title="Structure to single define portal connection." alt="" coords="1761,1963,1903,2117"/><area shape="rect" id="node29" href="structlu__ref.html" title="{lu_ref\n||}" alt="" coords="596,245,655,331"/><area shape="rect" id="node36" href="structcfs__hash.html" title="cfs_hash is a hash&#45;table implementation for general purpose, it can support: ." alt="" coords="1689,501,1852,968"/><area shape="rect" id="node121" href="structldlm__flock.html" title="{ldlm_flock\n|+ start\l+ end\l+ owner\l+ blocking_owner\l+ blocking_export\l+ blocking_refs\l+ pid\l|}" alt="" coords="1676,5720,1817,5909"/><area shape="rect" id="node58" href="structportals__handle__ops.html" title="{portals_handle_ops\n|+ hop_addref\l+ hop_free\l|}" alt="" coords="3080,683,3229,786"/><area shape="rect" id="node65" href="structobd__connect__data.html" title="{obd_connect_data\n|+ ocd_connect_flags\l+ ocd_version\l+ ocd_grant\l+ ocd_index\l+ ocd_brw_size\l+ ocd_ibits_known\l+ ocd_grant_blkbits\l+ ocd_grant_inobits\l+ ocd_grant_tax_kb\l+ ocd_grant_max_blks\l+ ocd_transno\l+ ocd_group\l+ ocd_cksum_types\l+ ocd_max_easize\l+ ocd_instance\l+ ocd_maxbytes\l+ ocd_maxmodrpcs\l+ padding0\l+ padding1\l+ ocd_connect_flags2\l+ padding3\l+ padding4\l+ padding5\l+ padding6\l+ padding7\l+ padding8\l+ padding9\l+ paddingA\l+ paddingB\l+ paddingC\l+ paddingD\l+ paddingE\l+ paddingF\l|}" alt="" coords="1516,1720,1687,2360"/><area shape="rect" id="node70" href="structobd__uuid.html" title="{obd_uuid\n|+ uuid\l|}" alt="" coords="1585,692,1665,777"/><area shape="rect" id="node79" href="structlustre__handle.html" title="{lustre_handle\n|+ cookie\l|}" alt="" coords="916,1997,1028,2083"/><area shape="rect" id="node81" href="structadaptive__timeout.html" title="{adaptive_timeout\n|+ at_binstart\l+ at_hist\l+ at_flags\l+ at_current\l+ at_worst_ever\l+ at_worst_time\l+ at_lock\l|}" alt="" coords="4185,193,4327,383"/><area shape="rect" id="node146" href="structldlm__ns__bucket.html" title="{ldlm_ns_bucket\n|+ nsb_namespace\l+ nsb_at_estimate\l+ nsb_reclaim_start\l|}" alt="" coords="4132,675,4287,795"/><area shape="rect" id="node87" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular..." alt="" coords="2891,3621,3003,3776"/><area shape="rect" id="node111" href="structcl__lock__operations.html" title="{cl_lock_operations\n|+ clo_fini\l+ clo_print\l+ clo_enqueue\l+ clo_cancel\l|* clo_enqueue\l* clo_cancel\l}" alt="" coords="5,5737,149,5892"/><area shape="rect" id="node113" href="structost__lvb.html" title="{ost_lvb\n|+ lvb_size\l+ lvb_mtime\l+ lvb_atime\l+ lvb_ctime\l+ lvb_blocks\l+ lvb_mtime_ns\l+ lvb_atime_ns\l+ lvb_ctime_ns\l+ lvb_padding\l|}" alt="" coords="1987,6484,2115,6708"/><area shape="rect" id="node119" href="unionldlm__policy__data.html" title="{ldlm_policy_data\n|+ l_extent\l+ l_flock\l+ l_inodebits\l|}" alt="" coords="1681,6001,1812,6121"/><area shape="rect" id="node124" href="structldlm__extent.html" title="{ldlm_extent\n|+ start\l+ end\l+ gid\l|}" alt="" coords="1533,5755,1637,5875"/><area shape="rect" id="node126" href="structldlm__inodebits.html" title="{ldlm_inodebits\n|+ bits\l|}" alt="" coords="1841,5772,1959,5857"/><area shape="rect" id="node131" href="structinterval__node.html" title="{interval_node\n|+ in_left\l+ in_right\l+ in_parent\l+ in_color\l+ in_intree\l+ in_res1\l+ in_res2\l+ in_max_high\l+ in_extent\l|}" alt="" coords="3811,176,3928,400"/><area shape="rect" id="node149" href="structldlm__interval__tree.html" title="Interval tree for extent locks." alt="" coords="3847,675,3991,795"/><area shape="rect" id="node134" href="structinterval__node_1_1interval__node__extent.html" title="{interval_node::interval_node_extent\n|+ start\l+ end\l|}" alt="" coords="3735,6,4004,109"/><area shape="rect" id="node152" href="structldlm__res__id.html" title="{ldlm_res_id\n|+ name\l|}" alt="" coords="4015,692,4108,777"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaea6569665985de217dd5948d806db01"></a><!-- doxytag: member="osc_lock::ols_cl" ref="aaea6569665985de217dd5948d806db01" args="" -->
struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ols_cl</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">spinlock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641">ols_lock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal lock to protect states, etc.  <a href="#ac103709b1b39897da03bf305179e4641"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca301e8e6fd1eda2ae94eb28c4defae7"></a><!-- doxytag: member="osc_lock::ols_owner" ref="aca301e8e6fd1eda2ae94eb28c4defae7" args="" -->
struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7">ols_owner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Owner sleeps on this channel for state change. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59dd81488c9fbd6733740cfaeed61b56"></a><!-- doxytag: member="osc_lock::ols_waiting_list" ref="a59dd81488c9fbd6733740cfaeed61b56" args="" -->
struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a59dd81488c9fbd6733740cfaeed61b56">ols_waiting_list</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">waiting list for this lock to be cancelled <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf07ba3202fb5cd4074a6b98bc41f9e3"></a><!-- doxytag: member="osc_lock::ols_wait_entry" ref="aaf07ba3202fb5cd4074a6b98bc41f9e3" args="" -->
struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#aaf07ba3202fb5cd4074a6b98bc41f9e3">ols_wait_entry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">wait entry of ols_waiting_list <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61ed1b1236e5970e472888bb62c81193"></a><!-- doxytag: member="osc_lock::ols_nextlock_oscobj" ref="a61ed1b1236e5970e472888bb62c81193" args="" -->
struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a61ed1b1236e5970e472888bb62c81193">ols_nextlock_oscobj</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list entry for osc_object::oo_ol_list <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa628fd5a29fe670d23088616c9c6182f"></a><!-- doxytag: member="osc_lock::ols_dlmlock" ref="aa628fd5a29fe670d23088616c9c6182f" args="" -->
struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f">ols_dlmlock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">underlying DLM lock <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aab2a482c5aa5d06deb2d5a8df7b275"></a><!-- doxytag: member="osc_lock::ols_flags" ref="a6aab2a482c5aa5d06deb2d5a8df7b275" args="" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275">ols_flags</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLM flags with which <a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a> was enqueued. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a638af9b318fdd4b2d94f549ff165a732"></a><!-- doxytag: member="osc_lock::ols_handle" ref="a638af9b318fdd4b2d94f549ff165a732" args="" -->
struct <a class="el" href="structlustre__handle.html">lustre_handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732">ols_handle</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a> handle <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d1369425e04be04518a52972a05bf89"></a><!-- doxytag: member="osc_lock::ols_einfo" ref="a4d1369425e04be04518a52972a05bf89" args="" -->
struct <a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ols_einfo</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7c08a350800344211d420d88f66bc7c"></a><!-- doxytag: member="osc_lock::ols_state" ref="ae7c08a350800344211d420d88f66bc7c" args="" -->
enum osc_lock_state&nbsp;</td><td class="memItemRight" valign="bottom"><b>ols_state</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a942265d5ad56c6b1260aa06ae9df6960"></a><!-- doxytag: member="osc_lock::ols_lvb" ref="a942265d5ad56c6b1260aa06ae9df6960" args="" -->
struct <a class="el" href="structost__lvb.html">ost_lvb</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a942265d5ad56c6b1260aa06ae9df6960">ols_lvb</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock value block <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2">ols_hold</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true, if <a class="el" href="group__LDLM.html#ga2d77135057c3b9123a3ae5704752c946" title="Add specified reader/writer reference to LDLM lock with handle lockh.">ldlm_lock_addref()</a> was called against <a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a>.  <a href="#a40ce4d599eee71b32fa4cf9a5df7cca2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152">ols_has_ref</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is much like <a class="el" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">osc_lock::ols_hold</a>, except that this bit is cleared _after_ reference in released in osc_lock_unuse().  <a href="#ab4a4bb0e1ed33561bda35534caa67152"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed">ols_locklessable</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inherit the lockless attribute from top level <a class="el" href="structcl__io.html" title="State for io.">cl_io</a>.  <a href="#a1bea66d8dcb337d683b314e349d996ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416">ols_glimpse</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">if set, the <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> is a glimpse lock.  <a href="#a5b89f022e42397b2beb321f01ef5d416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1cb6efc7400d813edcfd0a4e6fe3001"></a><!-- doxytag: member="osc_lock::ols_agl" ref="ab1cb6efc7400d813edcfd0a4e6fe3001" args="" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001">ols_agl</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For async glimpse lock. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>osc-private state of <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>. </p>
<p>Interaction with DLM.</p>
<p>Once receive upcall is invoked, <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> remembers a handle of DLM lock in <a class="el" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">osc_lock::ols_handle</a> and a pointer to that lock in <a class="el" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">osc_lock::ols_dlmlock</a>.</p>
<p>This pointer is protected through a reference, acquired by osc_lock_upcall0(). Also, an additional reference is acquired by <a class="el" href="group__LDLM.html#ga2d77135057c3b9123a3ae5704752c946" title="Add specified reader/writer reference to LDLM lock with handle lockh.">ldlm_lock_addref()</a> call protecting the lock from cancellation, until osc_lock_unuse() releases it.</p>
<p>Below is a description of how lock references are acquired and released inside of DLM.</p>
<ul>
<li>When new lock is created and enqueued to the server (<a class="el" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client-side lock enqueue.">ldlm_cli_enqueue()</a>)<ul>
<li>ldlm_lock_create()<ul>
<li>ldlm_lock_new(): initializes a lock with 2 references. One for the caller (released when reply from the server is received, or on error), and another for the hash table.</li>
</ul>
</li>
<li>ldlm_lock_addref_internal(): protects the lock from cancellation.</li>
</ul>
</li>
</ul>
<ul>
<li>When reply is received from the server (osc_enqueue_interpret())<ul>
<li><a class="el" href="group__ldlm__cli__api.html#gac421005283912bb5186b035013aa58c0" title="Finishing portion of client lock enqueue code.">ldlm_cli_enqueue_fini()</a><ul>
<li><a class="el" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT()</a>: releases caller reference acquired by ldlm_lock_new().</li>
<li>if (rc != 0) <a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a>: error case: matches <a class="el" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client-side lock enqueue.">ldlm_cli_enqueue()</a>.</li>
</ul>
</li>
<li><a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a>: for async locks, matches <a class="el" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client-side lock enqueue.">ldlm_cli_enqueue()</a>.</li>
</ul>
</li>
</ul>
<ul>
<li>When lock is being cancelled (<a class="el" href="group__LDLM.html#gadec8a773eb3b13c995cf35a4d013393b" title="Attempts to cancel LDLM lock lock that has no reader/writer references.">ldlm_lock_cancel()</a>)<ul>
<li><a class="el" href="group__LDLM.html#ga833125f7d72f8e77cb16c031c56dd2a0" title="Destroys a LDLM lock lock.">ldlm_lock_destroy()</a><ul>
<li><a class="el" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT()</a>: releases hash-table reference acquired by ldlm_lock_new().</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> is detached from <a class="el" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> by osc_lock_detach() that is called either when lock is cancelled (osc_lock_blocking()), or when locks is deleted without cancellation (e.g., from cl_locks_prune()). In the latter case ldlm lock remains in memory, and can be re-attached to <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> in the future. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00260">260</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a5b89f022e42397b2beb321f01ef5d416"></a><!-- doxytag: member="osc_lock::ols_glimpse" ref="a5b89f022e42397b2beb321f01ef5d416" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416">osc_lock::ols_glimpse</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>if set, the <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> is a glimpse lock. </p>
<p>For glimpse locks, we treat the EVAVAIL error as torerable, this will make upper logic happy to wait all glimpse locks to each OSTs to be completed. Glimpse lock converts to normal lock if the server lock is granted. Glimpse lock should be destroyed immediately after use. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00290">290</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4a4bb0e1ed33561bda35534caa67152"></a><!-- doxytag: member="osc_lock::ols_has_ref" ref="ab4a4bb0e1ed33561bda35534caa67152" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152">osc_lock::ols_has_ref</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this is much like <a class="el" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">osc_lock::ols_hold</a>, except that this bit is cleared _after_ reference in released in osc_lock_unuse(). </p>
<p>This fine distinction is needed because:</p>
<ul>
<li>if ldlm lock still has a reference, osc_ast_data_get() needs to return associated <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> (so that a flag is needed that is cleared after <a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a> returned), and</li>
</ul>
<ul>
<li><a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a> can invoke blocking ast (for a LDLM_FL_CBPENDING lock), and <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> functions like osc_lock_cancel() called from there need to know whether to release lock reference (so that a flag is needed that is cleared before <a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a> is called). </li>
</ul>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00290">290</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

</div>
</div>
<a class="anchor" id="a40ce4d599eee71b32fa4cf9a5df7cca2"></a><!-- doxytag: member="osc_lock::ols_hold" ref="a40ce4d599eee71b32fa4cf9a5df7cca2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2">osc_lock::ols_hold</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>true, if <a class="el" href="group__LDLM.html#ga2d77135057c3b9123a3ae5704752c946" title="Add specified reader/writer reference to LDLM lock with handle lockh.">ldlm_lock_addref()</a> was called against <a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a>. </p>
<p>This is used for sanity checking.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152" title="this is much like osc_lock::ols_hold, except that this bit is cleared _after_ reference...">osc_lock::ols_has_ref</a> </dd></dl>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00290">290</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac103709b1b39897da03bf305179e4641"></a><!-- doxytag: member="osc_lock::ols_lock" ref="ac103709b1b39897da03bf305179e4641" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spinlock_t <a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641">osc_lock::ols_lock</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal lock to protect states, etc. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00263">263</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1bea66d8dcb337d683b314e349d996ed"></a><!-- doxytag: member="osc_lock::ols_locklessable" ref="a1bea66d8dcb337d683b314e349d996ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed">osc_lock::ols_locklessable</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>inherit the lockless attribute from top level <a class="el" href="structcl__io.html" title="State for io.">cl_io</a>. </p>
<p>If true, osc_lock_enqueue is able to tolerate the -EUSERS error. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00290">290</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/osc/<a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 21:04:51 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
