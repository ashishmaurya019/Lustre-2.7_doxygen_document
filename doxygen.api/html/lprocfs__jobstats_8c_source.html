<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/obdclass/lprocfs_jobstats.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/obdclass/lprocfs_jobstats.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* GPL HEADER START</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00006"></a>00006 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00007"></a>00007 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00010"></a>00010 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00012"></a>00012 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00013"></a>00013 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00016"></a>00016 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00017"></a>00017 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * GPL HEADER END</span>
<a name="l00020"></a>00020 <span class="comment"> */</span>
<a name="l00021"></a>00021 <span class="comment">/*</span>
<a name="l00022"></a>00022 <span class="comment"> * Copyright (c) 2012, 2015, Intel Corporation.</span>
<a name="l00023"></a>00023 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00024"></a>00024 <span class="comment"> *</span>
<a name="l00025"></a>00025 <span class="comment"> * Author: Niu Yawei &lt;niu@whamcloud.com&gt;</span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 <span class="comment">/*</span>
<a name="l00028"></a>00028 <span class="comment"> * lustre/obdclass/lprocfs_jobstats.c</span>
<a name="l00029"></a>00029 <span class="comment"> */</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_CLASS</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;lprocfs_status.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;lustre/lustre_idl.h&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#ifdef CONFIG_PROC_FS</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="comment">/*</span>
<a name="l00041"></a>00041 <span class="comment"> * JobID formats &amp; JobID environment variable names for supported</span>
<a name="l00042"></a>00042 <span class="comment"> * job schedulers:</span>
<a name="l00043"></a>00043 <span class="comment"> *</span>
<a name="l00044"></a>00044 <span class="comment"> * SLURM:</span>
<a name="l00045"></a>00045 <span class="comment"> *   JobID format:  32 bit integer.</span>
<a name="l00046"></a>00046 <span class="comment"> *   JobID env var: SLURM_JOB_ID.</span>
<a name="l00047"></a>00047 <span class="comment"> * SGE:</span>
<a name="l00048"></a>00048 <span class="comment"> *   JobID format:  Decimal integer range to 99999.</span>
<a name="l00049"></a>00049 <span class="comment"> *   JobID env var: JOB_ID.</span>
<a name="l00050"></a>00050 <span class="comment"> * LSF:</span>
<a name="l00051"></a>00051 <span class="comment"> *   JobID format:  6 digit integer by default (up to 999999), can be</span>
<a name="l00052"></a>00052 <span class="comment"> *                increased to 10 digit (up to 2147483646).</span>
<a name="l00053"></a>00053 <span class="comment"> *   JobID env var: LSB_JOBID.</span>
<a name="l00054"></a>00054 <span class="comment"> * Loadleveler:</span>
<a name="l00055"></a>00055 <span class="comment"> *   JobID format:  String of machine_name.cluster_id.process_id, for</span>
<a name="l00056"></a>00056 <span class="comment"> *                example: fr2n02.32.0</span>
<a name="l00057"></a>00057 <span class="comment"> *   JobID env var: LOADL_STEP_ID.</span>
<a name="l00058"></a>00058 <span class="comment"> * PBS:</span>
<a name="l00059"></a>00059 <span class="comment"> *   JobID format:  String of sequence_number[.server_name][@server].</span>
<a name="l00060"></a>00060 <span class="comment"> *   JobID env var: PBS_JOBID.</span>
<a name="l00061"></a>00061 <span class="comment"> * Maui/MOAB:</span>
<a name="l00062"></a>00062 <span class="comment"> *   JobID format:  Same as PBS.</span>
<a name="l00063"></a>00063 <span class="comment"> *   JobID env var: Same as PBS.</span>
<a name="l00064"></a>00064 <span class="comment"> */</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keyword">struct </span>job_stat {
<a name="l00067"></a>00067         <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>       js_hash;        <span class="comment">/* hash struct for this jobid */</span>
<a name="l00068"></a>00068         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        js_list;        <span class="comment">/* on ojs_list, with ojs_lock */</span>
<a name="l00069"></a>00069         atomic_t                js_refcount;    <span class="comment">/* num users of this struct */</span>
<a name="l00070"></a>00070         <span class="keywordtype">char</span>                    js_jobid[LUSTRE_JOBID_SIZE]; <span class="comment">/* job name */</span>
<a name="l00071"></a>00071         time_t                  js_timestamp;   <span class="comment">/* seconds of most recent stat*/</span>
<a name="l00072"></a>00072         <span class="keyword">struct </span><a class="code" href="structlprocfs__stats.html">lprocfs_stats</a>    *js_stats;      <span class="comment">/* per-job statistics */</span>
<a name="l00073"></a>00073         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a>    *js_jobstats;   <span class="comment">/* for accessing ojs_lock */</span>
<a name="l00074"></a>00074 };
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="keyword">static</span> <span class="keywordtype">unsigned</span>
<a name="l00077"></a>00077 job_stat_hash(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs, <span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> mask)
<a name="l00078"></a>00078 {
<a name="l00079"></a>00079         <span class="keywordflow">return</span> cfs_hash_djb2_hash(key, strlen(key), mask);
<a name="l00080"></a>00080 }
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="keyword">static</span> <span class="keywordtype">void</span> *job_stat_key(<span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00083"></a>00083 {
<a name="l00084"></a>00084         <span class="keyword">struct </span>job_stat *job;
<a name="l00085"></a>00085         job = hlist_entry(hnode, <span class="keyword">struct</span> job_stat, js_hash);
<a name="l00086"></a>00086         <span class="keywordflow">return</span> job-&gt;js_jobid;
<a name="l00087"></a>00087 }
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="keyword">static</span> <span class="keywordtype">int</span> job_stat_keycmp(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00090"></a>00090 {
<a name="l00091"></a>00091         <span class="keyword">struct </span>job_stat *job;
<a name="l00092"></a>00092         job = hlist_entry(hnode, <span class="keyword">struct</span> job_stat, js_hash);
<a name="l00093"></a>00093         <span class="keywordflow">return</span> (strlen(job-&gt;js_jobid) == strlen(key)) &amp;&amp;
<a name="l00094"></a>00094                !strncmp(job-&gt;js_jobid, key, strlen(key));
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="keyword">static</span> <span class="keywordtype">void</span> *job_stat_object(<span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099         <span class="keywordflow">return</span> hlist_entry(hnode, <span class="keyword">struct</span> job_stat, js_hash);
<a name="l00100"></a>00100 }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="keyword">static</span> <span class="keywordtype">void</span> job_stat_get(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00103"></a>00103 {
<a name="l00104"></a>00104         <span class="keyword">struct </span>job_stat *job;
<a name="l00105"></a>00105         job = hlist_entry(hnode, <span class="keyword">struct</span> job_stat, js_hash);
<a name="l00106"></a>00106         atomic_inc(&amp;job-&gt;js_refcount);
<a name="l00107"></a>00107 }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="keyword">static</span> <span class="keywordtype">void</span> job_free(<span class="keyword">struct</span> job_stat *job)
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111         LASSERT(atomic_read(&amp;job-&gt;js_refcount) == 0);
<a name="l00112"></a>00112         LASSERT(job-&gt;js_jobstats != NULL);
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         write_lock(&amp;job-&gt;js_jobstats-&gt;ojs_lock);
<a name="l00115"></a>00115         list_del_init(&amp;job-&gt;js_list);
<a name="l00116"></a>00116         write_unlock(&amp;job-&gt;js_jobstats-&gt;ojs_lock);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         lprocfs_free_stats(&amp;job-&gt;js_stats);
<a name="l00119"></a>00119         OBD_FREE_PTR(job);
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keywordtype">void</span> job_putref(<span class="keyword">struct</span> job_stat *job)
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124         LASSERT(atomic_read(&amp;job-&gt;js_refcount) &gt; 0);
<a name="l00125"></a>00125         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;job-&gt;js_refcount))
<a name="l00126"></a>00126                 job_free(job);
<a name="l00127"></a>00127 }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="keyword">static</span> <span class="keywordtype">void</span> job_stat_put_locked(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00130"></a>00130 {
<a name="l00131"></a>00131         <span class="keyword">struct </span>job_stat *job;
<a name="l00132"></a>00132         job = hlist_entry(hnode, <span class="keyword">struct</span> job_stat, js_hash);
<a name="l00133"></a>00133         job_putref(job);
<a name="l00134"></a>00134 }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="keyword">static</span> <span class="keywordtype">void</span> job_stat_exit(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00137"></a>00137 {
<a name="l00138"></a>00138         CERROR(<span class="stringliteral">&quot;should not have any items\n&quot;</span>);
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcfs__hash__ops.html">cfs_hash_ops</a> job_stats_hash_ops = {
<a name="l00142"></a>00142         .hs_hash       = job_stat_hash,
<a name="l00143"></a>00143         .hs_key        = job_stat_key,
<a name="l00144"></a>00144         .hs_keycmp     = job_stat_keycmp,
<a name="l00145"></a>00145         .hs_object     = job_stat_object,
<a name="l00146"></a>00146         .hs_get        = job_stat_get,
<a name="l00147"></a>00147         .hs_put_locked = job_stat_put_locked,
<a name="l00148"></a>00148         .hs_exit       = job_stat_exit,
<a name="l00149"></a>00149 };
<a name="l00150"></a>00150 
<a name="l00163"></a>00163 <span class="keyword">static</span> <span class="keywordtype">int</span> job_cleanup_iter_callback(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs,
<a name="l00164"></a>00164                                      <span class="keyword">struct</span> <a class="code" href="structcfs__hash__bd.html" title="cfs_hash bucket descriptor, it&amp;#39;s normally in stack of caller">cfs_hash_bd</a> *bd,
<a name="l00165"></a>00165                                      <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode, <span class="keywordtype">void</span> *data)
<a name="l00166"></a>00166 {
<a name="l00167"></a>00167         time_t oldest_time = *((time_t *)data);
<a name="l00168"></a>00168         <span class="keyword">struct </span>job_stat *job;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         job = hlist_entry(hnode, <span class="keyword">struct</span> job_stat, js_hash);
<a name="l00171"></a>00171         <span class="keywordflow">if</span> (job-&gt;js_timestamp &lt; oldest_time)
<a name="l00172"></a>00172                 cfs_hash_bd_del_locked(hs, bd, hnode);
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         <span class="keywordflow">return</span> 0;
<a name="l00175"></a>00175 }
<a name="l00176"></a>00176 
<a name="l00194"></a>00194 <span class="keyword">static</span> <span class="keywordtype">void</span> lprocfs_job_cleanup(<span class="keyword">struct</span> <a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats, <span class="keywordtype">int</span> before)
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196         time_t now = cfs_time_current_sec();
<a name="l00197"></a>00197         time_t oldest;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         <span class="keywordflow">if</span> (likely(before &gt;= 0)) {
<a name="l00200"></a>00200                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cleanup_interval = stats-&gt;ojs_cleanup_interval;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202                 <span class="keywordflow">if</span> (cleanup_interval == 0 || before == 0)
<a name="l00203"></a>00203                         <span class="keywordflow">return</span>;
<a name="l00204"></a>00204 
<a name="l00205"></a>00205                 <span class="keywordflow">if</span> (now &lt; stats-&gt;ojs_last_cleanup + cleanup_interval / 2)
<a name="l00206"></a>00206                         <span class="keywordflow">return</span>;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208                 <span class="keywordflow">if</span> (stats-&gt;ojs_cleaning)
<a name="l00209"></a>00209                         <span class="keywordflow">return</span>;
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         write_lock(&amp;stats-&gt;ojs_lock);
<a name="l00213"></a>00213         <span class="keywordflow">if</span> (before &gt;= 0 &amp;&amp; stats-&gt;ojs_cleaning) {
<a name="l00214"></a>00214                 write_unlock(&amp;stats-&gt;ojs_lock);
<a name="l00215"></a>00215                 <span class="keywordflow">return</span>;
<a name="l00216"></a>00216         }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218         stats-&gt;ojs_cleaning = <span class="keyword">true</span>;
<a name="l00219"></a>00219         write_unlock(&amp;stats-&gt;ojs_lock);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         <span class="comment">/* Can&apos;t hold ojs_lock over hash iteration, since it is grabbed by</span>
<a name="l00222"></a>00222 <span class="comment">         * job_cleanup_iter_callback()</span>
<a name="l00223"></a>00223 <span class="comment">         *   -&gt;cfs_hash_bd_del_locked()</span>
<a name="l00224"></a>00224 <span class="comment">         *     -&gt;job_putref()</span>
<a name="l00225"></a>00225 <span class="comment">         *       -&gt;job_free()</span>
<a name="l00226"></a>00226 <span class="comment">         *</span>
<a name="l00227"></a>00227 <span class="comment">         * Holding ojs_lock isn&apos;t necessary for safety of the hash iteration,</span>
<a name="l00228"></a>00228 <span class="comment">         * since locking of the hash is handled internally, but there isn&apos;t</span>
<a name="l00229"></a>00229 <span class="comment">         * any benefit to having multiple threads doing cleanup at one time.</span>
<a name="l00230"></a>00230 <span class="comment">         */</span>
<a name="l00231"></a>00231         oldest = now - before;
<a name="l00232"></a>00232         cfs_hash_for_each_safe(stats-&gt;ojs_hash, job_cleanup_iter_callback,
<a name="l00233"></a>00233                                &amp;oldest);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235         write_lock(&amp;stats-&gt;ojs_lock);
<a name="l00236"></a>00236         stats-&gt;ojs_cleaning = <span class="keyword">false</span>;
<a name="l00237"></a>00237         stats-&gt;ojs_last_cleanup = cfs_time_current_sec();
<a name="l00238"></a>00238         write_unlock(&amp;stats-&gt;ojs_lock);
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="keyword">static</span> <span class="keyword">struct </span>job_stat *job_alloc(<span class="keywordtype">char</span> *jobid, <span class="keyword">struct</span> <a class="code" href="structobd__job__stats.html">obd_job_stats</a> *jobs)
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243         <span class="keyword">struct </span>job_stat *job;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245         OBD_ALLOC_PTR(job);
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (job == NULL)
<a name="l00247"></a>00247                 <span class="keywordflow">return</span> NULL;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249         job-&gt;js_stats = lprocfs_alloc_stats(jobs-&gt;ojs_cntr_num, 0);
<a name="l00250"></a>00250         <span class="keywordflow">if</span> (job-&gt;js_stats == NULL) {
<a name="l00251"></a>00251                 OBD_FREE_PTR(job);
<a name="l00252"></a>00252                 <span class="keywordflow">return</span> NULL;
<a name="l00253"></a>00253         }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255         jobs-&gt;ojs_cntr_init_fn(job-&gt;js_stats);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257         memcpy(job-&gt;js_jobid, jobid, LUSTRE_JOBID_SIZE);
<a name="l00258"></a>00258         job-&gt;js_timestamp = cfs_time_current_sec();
<a name="l00259"></a>00259         job-&gt;js_jobstats = jobs;
<a name="l00260"></a>00260         INIT_HLIST_NODE(&amp;job-&gt;js_hash);
<a name="l00261"></a>00261         INIT_LIST_HEAD(&amp;job-&gt;js_list);
<a name="l00262"></a>00262         atomic_set(&amp;job-&gt;js_refcount, 1);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264         <span class="keywordflow">return</span> job;
<a name="l00265"></a>00265 }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="keywordtype">int</span> lprocfs_job_stats_log(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd, <span class="keywordtype">char</span> *jobid,
<a name="l00268"></a>00268                           <span class="keywordtype">int</span> event, <span class="keywordtype">long</span> amount)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats = &amp;obd-&gt;u.obt.obt_jobstats;
<a name="l00271"></a>00271         <span class="keyword">struct </span>job_stat *job, *job2;
<a name="l00272"></a>00272         ENTRY;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274         LASSERT(stats != NULL);
<a name="l00275"></a>00275         LASSERT(stats-&gt;ojs_hash != NULL);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         <span class="keywordflow">if</span> (event &gt;= stats-&gt;ojs_cntr_num)
<a name="l00278"></a>00278                 RETURN(-EINVAL);
<a name="l00279"></a>00279 
<a name="l00280"></a>00280         <span class="keywordflow">if</span> (jobid == NULL || strlen(jobid) == 0)
<a name="l00281"></a>00281                 RETURN(-EINVAL);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283         <span class="keywordflow">if</span> (strlen(jobid) &gt;= LUSTRE_JOBID_SIZE) {
<a name="l00284"></a>00284                 CERROR(<span class="stringliteral">&quot;Invalid jobid size (%lu), expect(%d)\n&quot;</span>,
<a name="l00285"></a>00285                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)strlen(jobid) + 1, LUSTRE_JOBID_SIZE);
<a name="l00286"></a>00286                 RETURN(-EINVAL);
<a name="l00287"></a>00287         }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         job = cfs_hash_lookup(stats-&gt;ojs_hash, jobid);
<a name="l00290"></a>00290         <span class="keywordflow">if</span> (job)
<a name="l00291"></a>00291                 <span class="keywordflow">goto</span> found;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         lprocfs_job_cleanup(stats, stats-&gt;ojs_cleanup_interval);
<a name="l00294"></a>00294 
<a name="l00295"></a>00295         job = job_alloc(jobid, stats);
<a name="l00296"></a>00296         <span class="keywordflow">if</span> (job == NULL)
<a name="l00297"></a>00297                 RETURN(-ENOMEM);
<a name="l00298"></a>00298 
<a name="l00299"></a>00299         job2 = cfs_hash_findadd_unique(stats-&gt;ojs_hash, job-&gt;js_jobid,
<a name="l00300"></a>00300                                        &amp;job-&gt;js_hash);
<a name="l00301"></a>00301         <span class="keywordflow">if</span> (job2 != job) {
<a name="l00302"></a>00302                 job_putref(job);
<a name="l00303"></a>00303                 job = job2;
<a name="l00304"></a>00304                 <span class="comment">/* We cannot LASSERT(!list_empty(&amp;job-&gt;js_list)) here,</span>
<a name="l00305"></a>00305 <span class="comment">                 * since we just lost the race for inserting &quot;job&quot; into the</span>
<a name="l00306"></a>00306 <span class="comment">                 * ojs_list, and some other thread is doing it _right_now_.</span>
<a name="l00307"></a>00307 <span class="comment">                 * Instead, be content the other thread is doing this, since</span>
<a name="l00308"></a>00308 <span class="comment">                 * &quot;job2&quot; was initialized in job_alloc() already. LU-2163 */</span>
<a name="l00309"></a>00309         } <span class="keywordflow">else</span> {
<a name="l00310"></a>00310                 LASSERT(list_empty(&amp;job-&gt;js_list));
<a name="l00311"></a>00311                 write_lock(&amp;stats-&gt;ojs_lock);
<a name="l00312"></a>00312                 list_add_tail(&amp;job-&gt;js_list, &amp;stats-&gt;ojs_list);
<a name="l00313"></a>00313                 write_unlock(&amp;stats-&gt;ojs_lock);
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 found:
<a name="l00317"></a>00317         LASSERT(stats == job-&gt;js_jobstats);
<a name="l00318"></a>00318         job-&gt;js_timestamp = cfs_time_current_sec();
<a name="l00319"></a>00319         lprocfs_counter_add(job-&gt;js_stats, event, amount);
<a name="l00320"></a>00320 
<a name="l00321"></a>00321         job_putref(job);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323         RETURN(0);
<a name="l00324"></a>00324 }
<a name="l00325"></a>00325 EXPORT_SYMBOL(lprocfs_job_stats_log);
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="keywordtype">void</span> lprocfs_job_stats_fini(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd)
<a name="l00328"></a>00328 {
<a name="l00329"></a>00329         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats = &amp;obd-&gt;u.obt.obt_jobstats;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331         <span class="keywordflow">if</span> (stats-&gt;ojs_hash == NULL)
<a name="l00332"></a>00332                 <span class="keywordflow">return</span>;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334         lprocfs_job_cleanup(stats, -99);
<a name="l00335"></a>00335         cfs_hash_putref(stats-&gt;ojs_hash);
<a name="l00336"></a>00336         stats-&gt;ojs_hash = NULL;
<a name="l00337"></a>00337         LASSERT(list_empty(&amp;stats-&gt;ojs_list));
<a name="l00338"></a>00338 }
<a name="l00339"></a>00339 EXPORT_SYMBOL(lprocfs_job_stats_fini);
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 <span class="keyword">static</span> <span class="keywordtype">void</span> *lprocfs_jobstats_seq_start(<span class="keyword">struct</span> seq_file *p, loff_t *pos)
<a name="l00342"></a>00342 {
<a name="l00343"></a>00343         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats = p-&gt;private;
<a name="l00344"></a>00344         loff_t off = *pos;
<a name="l00345"></a>00345         <span class="keyword">struct </span>job_stat *job;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         read_lock(&amp;stats-&gt;ojs_lock);
<a name="l00348"></a>00348         <span class="keywordflow">if</span> (off == 0)
<a name="l00349"></a>00349                 <span class="keywordflow">return</span> SEQ_START_TOKEN;
<a name="l00350"></a>00350         off--;
<a name="l00351"></a>00351         list_for_each_entry(job, &amp;stats-&gt;ojs_list, js_list) {
<a name="l00352"></a>00352                 <span class="keywordflow">if</span> (!off--)
<a name="l00353"></a>00353                         <span class="keywordflow">return</span> job;
<a name="l00354"></a>00354         }
<a name="l00355"></a>00355         <span class="keywordflow">return</span> NULL;
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="keyword">static</span> <span class="keywordtype">void</span> lprocfs_jobstats_seq_stop(<span class="keyword">struct</span> seq_file *p, <span class="keywordtype">void</span> *v)
<a name="l00359"></a>00359 {
<a name="l00360"></a>00360         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats = p-&gt;private;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362         read_unlock(&amp;stats-&gt;ojs_lock);
<a name="l00363"></a>00363 }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="keyword">static</span> <span class="keywordtype">void</span> *lprocfs_jobstats_seq_next(<span class="keyword">struct</span> seq_file *p, <span class="keywordtype">void</span> *v, loff_t *pos)
<a name="l00366"></a>00366 {
<a name="l00367"></a>00367         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats = p-&gt;private;
<a name="l00368"></a>00368         <span class="keyword">struct </span>job_stat *job;
<a name="l00369"></a>00369         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *next;
<a name="l00370"></a>00370 
<a name="l00371"></a>00371         ++*pos;
<a name="l00372"></a>00372         <span class="keywordflow">if</span> (v == SEQ_START_TOKEN) {
<a name="l00373"></a>00373                 next = stats-&gt;ojs_list.next;
<a name="l00374"></a>00374         } <span class="keywordflow">else</span> {
<a name="l00375"></a>00375                 job = (<span class="keyword">struct </span>job_stat *)v;
<a name="l00376"></a>00376                 next = job-&gt;js_list.next;
<a name="l00377"></a>00377         }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379         <span class="keywordflow">return</span> next == &amp;stats-&gt;ojs_list ? NULL :
<a name="l00380"></a>00380                 list_entry(next, <span class="keyword">struct</span> job_stat, js_list);
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 <span class="comment">/*</span>
<a name="l00384"></a>00384 <span class="comment"> * Example of output on MDT:</span>
<a name="l00385"></a>00385 <span class="comment"> *</span>
<a name="l00386"></a>00386 <span class="comment"> * job_stats:</span>
<a name="l00387"></a>00387 <span class="comment"> * - job_id:        dd.4854</span>
<a name="l00388"></a>00388 <span class="comment"> *   snapshot_time: 1322494486</span>
<a name="l00389"></a>00389 <span class="comment"> *   open:          { samples:         1, unit: reqs }</span>
<a name="l00390"></a>00390 <span class="comment"> *   close:         { samples:         1, unit: reqs }</span>
<a name="l00391"></a>00391 <span class="comment"> *   mknod:         { samples:         0, unit: reqs }</span>
<a name="l00392"></a>00392 <span class="comment"> *   link:          { samples:         0, unit: reqs }</span>
<a name="l00393"></a>00393 <span class="comment"> *   unlink:        { samples:         0, unit: reqs }</span>
<a name="l00394"></a>00394 <span class="comment"> *   mkdir:         { samples:         0, unit: reqs }</span>
<a name="l00395"></a>00395 <span class="comment"> *   rmdir:         { samples:         0, unit: reqs }</span>
<a name="l00396"></a>00396 <span class="comment"> *   rename:        { samples:         0, unit: reqs }</span>
<a name="l00397"></a>00397 <span class="comment"> *   getattr:       { samples:         1, unit: reqs }</span>
<a name="l00398"></a>00398 <span class="comment"> *   setattr:       { samples:         0, unit: reqs }</span>
<a name="l00399"></a>00399 <span class="comment"> *   getxattr:      { samples:         0, unit: reqs }</span>
<a name="l00400"></a>00400 <span class="comment"> *   setxattr:      { samples:         0, unit: reqs }</span>
<a name="l00401"></a>00401 <span class="comment"> *   statfs:        { samples:         0, unit: reqs }</span>
<a name="l00402"></a>00402 <span class="comment"> *   sync:          { samples:         0, unit: reqs }</span>
<a name="l00403"></a>00403 <span class="comment"> *</span>
<a name="l00404"></a>00404 <span class="comment"> * Example of output on OST:</span>
<a name="l00405"></a>00405 <span class="comment"> *</span>
<a name="l00406"></a>00406 <span class="comment"> * job_stats:</span>
<a name="l00407"></a>00407 <span class="comment"> * - job_id         dd.4854</span>
<a name="l00408"></a>00408 <span class="comment"> *   snapshot_time: 1322494602</span>
<a name="l00409"></a>00409 <span class="comment"> *   read:          { samples: 0, unit: bytes, min:  0, max:  0, sum:  0 }</span>
<a name="l00410"></a>00410 <span class="comment"> *   write:         { samples: 1, unit: bytes, min: 4096, max: 4096, sum: 4096 }</span>
<a name="l00411"></a>00411 <span class="comment"> *   setattr:       { samples: 0, unit: reqs }</span>
<a name="l00412"></a>00412 <span class="comment"> *   punch:         { samples: 0, unit: reqs }</span>
<a name="l00413"></a>00413 <span class="comment"> *   sync:          { samples: 0, unit: reqs }</span>
<a name="l00414"></a>00414 <span class="comment"> */</span>
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> spaces[] = <span class="stringliteral">&quot;                    &quot;</span>;
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">inline</span> width(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> len)
<a name="l00419"></a>00419 {
<a name="l00420"></a>00420         <span class="keywordflow">return</span> len - min((<span class="keywordtype">int</span>)strlen(str), 15);
<a name="l00421"></a>00421 }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 <span class="keyword">static</span> <span class="keywordtype">int</span> lprocfs_jobstats_seq_show(<span class="keyword">struct</span> seq_file *p, <span class="keywordtype">void</span> *v)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425         <span class="keyword">struct </span>job_stat                 *job = v;
<a name="l00426"></a>00426         <span class="keyword">struct </span><a class="code" href="structlprocfs__stats.html">lprocfs_stats</a>            *s;
<a name="l00427"></a>00427         <span class="keyword">struct </span><a class="code" href="structlprocfs__counter.html">lprocfs_counter</a>          ret;
<a name="l00428"></a>00428         <span class="keyword">struct </span><a class="code" href="structlprocfs__counter__header.html">lprocfs_counter_header</a>   *cntr_header;
<a name="l00429"></a>00429         <span class="keywordtype">int</span>                             i;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431         <span class="keywordflow">if</span> (v == SEQ_START_TOKEN) {
<a name="l00432"></a>00432                 seq_printf(p, <span class="stringliteral">&quot;job_stats:\n&quot;</span>);
<a name="l00433"></a>00433                 <span class="keywordflow">return</span> 0;
<a name="l00434"></a>00434         }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436         <span class="comment">/* Replace the non-printable character in jobid with &apos;?&apos;, so</span>
<a name="l00437"></a>00437 <span class="comment">         * that the output of jobid will be confined in single line. */</span>
<a name="l00438"></a>00438         seq_printf(p, <span class="stringliteral">&quot;- %-16s &quot;</span>, <span class="stringliteral">&quot;job_id:&quot;</span>);
<a name="l00439"></a>00439         <span class="keywordflow">for</span> (i = 0; i &lt; strlen(job-&gt;js_jobid); i++) {
<a name="l00440"></a>00440                 <span class="keywordflow">if</span> (isprint(job-&gt;js_jobid[i]) != 0)
<a name="l00441"></a>00441                         seq_putc(p, job-&gt;js_jobid[i]);
<a name="l00442"></a>00442                 <span class="keywordflow">else</span>
<a name="l00443"></a>00443                         seq_putc(p, <span class="charliteral">&apos;?&apos;</span>);
<a name="l00444"></a>00444         }
<a name="l00445"></a>00445         seq_putc(p, <span class="charliteral">&apos;\n&apos;</span>);
<a name="l00446"></a>00446 
<a name="l00447"></a>00447         seq_printf(p, <span class="stringliteral">&quot;  %-16s %ld\n&quot;</span>, <span class="stringliteral">&quot;snapshot_time:&quot;</span>, job-&gt;js_timestamp);
<a name="l00448"></a>00448 
<a name="l00449"></a>00449         s = job-&gt;js_stats;
<a name="l00450"></a>00450         <span class="keywordflow">for</span> (i = 0; i &lt; s-&gt;ls_num; i++) {
<a name="l00451"></a>00451                 cntr_header = &amp;s-&gt;ls_cnt_header[i];
<a name="l00452"></a>00452                 lprocfs_stats_collect(s, i, &amp;ret);
<a name="l00453"></a>00453 
<a name="l00454"></a>00454                 seq_printf(p, <span class="stringliteral">&quot;  %s:%.*s { samples: %11&quot;</span>LPF64<span class="stringliteral">&quot;u&quot;</span>,
<a name="l00455"></a>00455                            cntr_header-&gt;lc_name,
<a name="l00456"></a>00456                            width(cntr_header-&gt;lc_name, 15), spaces,
<a name="l00457"></a>00457                            ret.lc_count);
<a name="l00458"></a>00458                 <span class="keywordflow">if</span> (cntr_header-&gt;lc_units[0] != <span class="charliteral">&apos;\0&apos;</span>)
<a name="l00459"></a>00459                         seq_printf(p, <span class="stringliteral">&quot;, unit: %5s&quot;</span>, cntr_header-&gt;lc_units);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461                 <span class="keywordflow">if</span> (cntr_header-&gt;lc_config &amp; LPROCFS_CNTR_AVGMINMAX) {
<a name="l00462"></a>00462                         seq_printf(p, <span class="stringliteral">&quot;, min:%8&quot;</span>LPF64<span class="stringliteral">&quot;u, max:%8&quot;</span>LPF64<span class="stringliteral">&quot;u,&quot;</span>
<a name="l00463"></a>00463                                    <span class="stringliteral">&quot; sum:%16&quot;</span>LPF64<span class="stringliteral">&quot;u&quot;</span>,
<a name="l00464"></a>00464                                    ret.lc_count ? ret.lc_min : 0,
<a name="l00465"></a>00465                                    ret.lc_count ? ret.lc_max : 0,
<a name="l00466"></a>00466                                    ret.lc_count ? ret.lc_sum : 0);
<a name="l00467"></a>00467                 }
<a name="l00468"></a>00468                 <span class="keywordflow">if</span> (cntr_header-&gt;lc_config &amp; LPROCFS_CNTR_STDDEV) {
<a name="l00469"></a>00469                         seq_printf(p, <span class="stringliteral">&quot;, sumsq: %18&quot;</span>LPF64<span class="stringliteral">&quot;u&quot;</span>,
<a name="l00470"></a>00470                                    ret.lc_count ? ret.lc_sumsquare : 0);
<a name="l00471"></a>00471                 }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473                 seq_printf(p, <span class="stringliteral">&quot; }\n&quot;</span>);
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         }
<a name="l00476"></a>00476         <span class="keywordflow">return</span> 0;
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>seq_operations lprocfs_jobstats_seq_sops = {
<a name="l00480"></a>00480         start: lprocfs_jobstats_seq_start,
<a name="l00481"></a>00481         stop:  lprocfs_jobstats_seq_stop,
<a name="l00482"></a>00482         next:  lprocfs_jobstats_seq_next,
<a name="l00483"></a>00483         show:  lprocfs_jobstats_seq_show,
<a name="l00484"></a>00484 };
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="keyword">static</span> <span class="keywordtype">int</span> lprocfs_jobstats_seq_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)
<a name="l00487"></a>00487 {
<a name="l00488"></a>00488         <span class="keyword">struct </span>seq_file *seq;
<a name="l00489"></a>00489         <span class="keywordtype">int</span> rc;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491         rc = LPROCFS_ENTRY_CHECK(inode);
<a name="l00492"></a>00492         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00493"></a>00493                 <span class="keywordflow">return</span> rc;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         rc = seq_open(file, &amp;lprocfs_jobstats_seq_sops);
<a name="l00496"></a>00496         <span class="keywordflow">if</span> (rc)
<a name="l00497"></a>00497                 <span class="keywordflow">return</span> rc;
<a name="l00498"></a>00498         seq = file-&gt;private_data;
<a name="l00499"></a>00499         seq-&gt;private = PDE_DATA(inode);
<a name="l00500"></a>00500         <span class="keywordflow">return</span> 0;
<a name="l00501"></a>00501 }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 <span class="keyword">static</span> ssize_t lprocfs_jobstats_seq_write(<span class="keyword">struct</span> file *file,
<a name="l00504"></a>00504                                           <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buf,
<a name="l00505"></a>00505                                           <span class="keywordtype">size_t</span> len, loff_t *off)
<a name="l00506"></a>00506 {
<a name="l00507"></a>00507         <span class="keyword">struct </span>seq_file *seq = file-&gt;private_data;
<a name="l00508"></a>00508         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats = seq-&gt;private;
<a name="l00509"></a>00509         <span class="keywordtype">char</span> jobid[LUSTRE_JOBID_SIZE];
<a name="l00510"></a>00510         <span class="keyword">struct </span>job_stat *job;
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         <span class="keywordflow">if</span> (len == 0 || len &gt;= LUSTRE_JOBID_SIZE)
<a name="l00513"></a>00513                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <span class="keywordflow">if</span> (stats-&gt;ojs_hash == NULL)
<a name="l00516"></a>00516                 <span class="keywordflow">return</span> -ENODEV;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518         <span class="keywordflow">if</span> (copy_from_user(jobid, buf, len))
<a name="l00519"></a>00519                 <span class="keywordflow">return</span> -EFAULT;
<a name="l00520"></a>00520         jobid[len] = 0;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522         <span class="comment">/* Trim &apos;\n&apos; if any */</span>
<a name="l00523"></a>00523         <span class="keywordflow">if</span> (jobid[len - 1] == <span class="charliteral">&apos;\n&apos;</span>)
<a name="l00524"></a>00524                 jobid[len - 1] = 0;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <span class="keywordflow">if</span> (strcmp(jobid, <span class="stringliteral">&quot;clear&quot;</span>) == 0) {
<a name="l00527"></a>00527                 lprocfs_job_cleanup(stats, -99);
<a name="l00528"></a>00528 
<a name="l00529"></a>00529                 <span class="keywordflow">return</span> len;
<a name="l00530"></a>00530         }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         <span class="keywordflow">if</span> (strlen(jobid) == 0)
<a name="l00533"></a>00533                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         job = cfs_hash_lookup(stats-&gt;ojs_hash, jobid);
<a name="l00536"></a>00536         <span class="keywordflow">if</span> (!job)
<a name="l00537"></a>00537                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         cfs_hash_del_key(stats-&gt;ojs_hash, jobid);
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         job_putref(job);
<a name="l00542"></a>00542         <span class="keywordflow">return</span> len;
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 
<a name="l00557"></a>00557 <span class="keyword">static</span> <span class="keywordtype">int</span> lprocfs_jobstats_seq_release(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)
<a name="l00558"></a>00558 {
<a name="l00559"></a>00559         <span class="keyword">struct </span>seq_file *seq = file-&gt;private_data;
<a name="l00560"></a>00560         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats = seq-&gt;private;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562         lprocfs_job_cleanup(stats, stats-&gt;ojs_cleanup_interval);
<a name="l00563"></a>00563 
<a name="l00564"></a>00564         <span class="keywordflow">return</span> lprocfs_seq_release(inode, file);
<a name="l00565"></a>00565 }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>file_operations lprocfs_jobstats_seq_fops = {
<a name="l00568"></a>00568         .owner   = THIS_MODULE,
<a name="l00569"></a>00569         .open    = lprocfs_jobstats_seq_open,
<a name="l00570"></a>00570         .read    = seq_read,
<a name="l00571"></a>00571         .write   = lprocfs_jobstats_seq_write,
<a name="l00572"></a>00572         .llseek  = seq_lseek,
<a name="l00573"></a>00573         .release = lprocfs_jobstats_seq_release,
<a name="l00574"></a>00574 };
<a name="l00575"></a>00575 
<a name="l00576"></a>00576 <span class="keywordtype">int</span> lprocfs_job_stats_init(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd, <span class="keywordtype">int</span> cntr_num,
<a name="l00577"></a>00577                            cntr_init_callback init_fn)
<a name="l00578"></a>00578 {
<a name="l00579"></a>00579         <span class="keyword">struct </span>proc_dir_entry *entry;
<a name="l00580"></a>00580         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats;
<a name="l00581"></a>00581         ENTRY;
<a name="l00582"></a>00582 
<a name="l00583"></a>00583         LASSERT(obd-&gt;obd_proc_entry != NULL);
<a name="l00584"></a>00584         LASSERT(obd-&gt;obd_type-&gt;typ_name);
<a name="l00585"></a>00585 
<a name="l00586"></a>00586         <span class="keywordflow">if</span> (cntr_num &lt;= 0)
<a name="l00587"></a>00587                 RETURN(-EINVAL);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589         <span class="keywordflow">if</span> (init_fn == NULL)
<a name="l00590"></a>00590                 RETURN(-EINVAL);
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         <span class="comment">/* Currently needs to be a target due to the use of obt_jobstats. */</span>
<a name="l00593"></a>00593         <span class="keywordflow">if</span> (strcmp(obd-&gt;obd_type-&gt;typ_name, LUSTRE_MDT_NAME) != 0 &amp;&amp;
<a name="l00594"></a>00594             strcmp(obd-&gt;obd_type-&gt;typ_name, LUSTRE_OST_NAME) != 0) {
<a name="l00595"></a>00595                 CERROR(<span class="stringliteral">&quot;%s: invalid device type %s for job stats: rc = %d\n&quot;</span>,
<a name="l00596"></a>00596                        obd-&gt;obd_name, obd-&gt;obd_type-&gt;typ_name, -EINVAL);
<a name="l00597"></a>00597                 RETURN(-EINVAL);
<a name="l00598"></a>00598         }
<a name="l00599"></a>00599         stats = &amp;obd-&gt;u.obt.obt_jobstats;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601         LASSERT(stats-&gt;ojs_hash == NULL);
<a name="l00602"></a>00602         stats-&gt;ojs_hash = cfs_hash_create(<span class="stringliteral">&quot;JOB_STATS&quot;</span>,
<a name="l00603"></a>00603                                           HASH_JOB_STATS_CUR_BITS,
<a name="l00604"></a>00604                                           HASH_JOB_STATS_MAX_BITS,
<a name="l00605"></a>00605                                           HASH_JOB_STATS_BKT_BITS, 0,
<a name="l00606"></a>00606                                           CFS_HASH_MIN_THETA,
<a name="l00607"></a>00607                                           CFS_HASH_MAX_THETA,
<a name="l00608"></a>00608                                           &amp;job_stats_hash_ops,
<a name="l00609"></a>00609                                           CFS_HASH_DEFAULT);
<a name="l00610"></a>00610         <span class="keywordflow">if</span> (stats-&gt;ojs_hash == NULL)
<a name="l00611"></a>00611                 RETURN(-ENOMEM);
<a name="l00612"></a>00612 
<a name="l00613"></a>00613         INIT_LIST_HEAD(&amp;stats-&gt;ojs_list);
<a name="l00614"></a>00614         rwlock_init(&amp;stats-&gt;ojs_lock);
<a name="l00615"></a>00615         stats-&gt;ojs_cntr_num = cntr_num;
<a name="l00616"></a>00616         stats-&gt;ojs_cntr_init_fn = init_fn;
<a name="l00617"></a>00617         stats-&gt;ojs_cleanup_interval = 600; <span class="comment">/* 10 mins by default */</span>
<a name="l00618"></a>00618         stats-&gt;ojs_last_cleanup = cfs_time_current_sec();
<a name="l00619"></a>00619 
<a name="l00620"></a>00620         entry = lprocfs_add_simple(obd-&gt;obd_proc_entry, <span class="stringliteral">&quot;job_stats&quot;</span>, stats,
<a name="l00621"></a>00621                                    &amp;lprocfs_jobstats_seq_fops);
<a name="l00622"></a>00622         <span class="keywordflow">if</span> (IS_ERR(entry)) {
<a name="l00623"></a>00623                 lprocfs_job_stats_fini(obd);
<a name="l00624"></a>00624                 RETURN(-ENOMEM);
<a name="l00625"></a>00625         }
<a name="l00626"></a>00626         RETURN(0);
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 EXPORT_SYMBOL(lprocfs_job_stats_init);
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="keywordtype">int</span> lprocfs_job_interval_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00631"></a>00631 {
<a name="l00632"></a>00632         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd = m-&gt;private;
<a name="l00633"></a>00633         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats;
<a name="l00634"></a>00634 
<a name="l00635"></a>00635         <span class="keywordflow">if</span> (obd == NULL)
<a name="l00636"></a>00636                 <span class="keywordflow">return</span> -ENODEV;
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         stats = &amp;obd-&gt;u.obt.obt_jobstats;
<a name="l00639"></a>00639         seq_printf(m, <span class="stringliteral">&quot;%d\n&quot;</span>, stats-&gt;ojs_cleanup_interval);
<a name="l00640"></a>00640         <span class="keywordflow">return</span> 0;
<a name="l00641"></a>00641 }
<a name="l00642"></a>00642 EXPORT_SYMBOL(lprocfs_job_interval_seq_show);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 ssize_t
<a name="l00645"></a>00645 lprocfs_job_interval_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00646"></a>00646                                 <span class="keywordtype">size_t</span> count, loff_t *off)
<a name="l00647"></a>00647 {
<a name="l00648"></a>00648         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd;
<a name="l00649"></a>00649         <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> *stats;
<a name="l00650"></a>00650         <span class="keywordtype">int</span> rc;
<a name="l00651"></a>00651         __s64 val;
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         obd = ((<span class="keyword">struct </span>seq_file *)file-&gt;private_data)-&gt;private;
<a name="l00654"></a>00654         <span class="keywordflow">if</span> (obd == NULL)
<a name="l00655"></a>00655                 <span class="keywordflow">return</span> -ENODEV;
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         stats = &amp;obd-&gt;u.obt.obt_jobstats;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         rc = lprocfs_str_to_s64(buffer, count, &amp;val);
<a name="l00660"></a>00660         <span class="keywordflow">if</span> (rc)
<a name="l00661"></a>00661                 <span class="keywordflow">return</span> rc;
<a name="l00662"></a>00662         <span class="keywordflow">if</span> (val &lt; 0 || val &gt; UINT_MAX)
<a name="l00663"></a>00663                 <span class="keywordflow">return</span> -ERANGE;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665         stats-&gt;ojs_cleanup_interval = val;
<a name="l00666"></a>00666         lprocfs_job_cleanup(stats, stats-&gt;ojs_cleanup_interval);
<a name="l00667"></a>00667         <span class="keywordflow">return</span> count;
<a name="l00668"></a>00668 }
<a name="l00669"></a>00669 EXPORT_SYMBOL(lprocfs_job_interval_seq_write);
<a name="l00670"></a>00670 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PROC_FS*/</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:18 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
