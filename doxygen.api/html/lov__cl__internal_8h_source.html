<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/lov/lov_cl_internal.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/lov/lov_cl_internal.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2012, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> */</span>
<a name="l00036"></a>00036 <span class="comment">/*</span>
<a name="l00037"></a>00037 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00038"></a>00038 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * Internal interfaces of LOV layer.</span>
<a name="l00041"></a>00041 <span class="comment"> *</span>
<a name="l00042"></a>00042 <span class="comment"> *   Author: Nikita Danilov &lt;nikita.danilov@sun.com&gt;</span>
<a name="l00043"></a>00043 <span class="comment"> *   Author: Jinshan Xiong &lt;jinshan.xiong@intel.com&gt;</span>
<a name="l00044"></a>00044 <span class="comment"> */</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#ifndef LOV_CL_INTERNAL_H</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#define LOV_CL_INTERNAL_H</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;libcfs/libcfs.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;obd.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;cl_object.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;lov_internal.h&quot;</span>
<a name="l00053"></a>00053 
<a name="l00086"></a>00086 <span class="keyword">struct </span><a class="code" href="structlovsub__device.html">lovsub_device</a>;
<a name="l00087"></a>00087 <span class="keyword">struct </span><a class="code" href="structlovsub__object.html">lovsub_object</a>;
<a name="l00088"></a>00088 <span class="keyword">struct </span><a class="code" href="structlovsub__lock.html" title="Lock state at lovsub layer.">lovsub_lock</a>;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="keyword">enum</span> lov_device_flags {
<a name="l00091"></a>00091         LOV_DEV_INITIALIZED = 1 &lt;&lt; 0
<a name="l00092"></a>00092 };
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">/*</span>
<a name="l00095"></a>00095 <span class="comment"> * Upper half.</span>
<a name="l00096"></a>00096 <span class="comment"> */</span>
<a name="l00097"></a>00097 
<a name="l00104"></a><a class="code" href="structlov__device__emerg.html">00104</a> <span class="keyword">struct </span><a class="code" href="structlov__device__emerg.html" title="Resources that are used in memory-cleaning path, and whose allocation cannot fail...">lov_device_emerg</a> {
<a name="l00108"></a><a class="code" href="structlov__device__emerg.html#ab580c11ad9ebe8e1c6e7df104688b172">00108</a>         <span class="keyword">struct </span><a class="code" href="structcl__page__list.html">cl_page_list</a> <a class="code" href="structlov__device__emerg.html#ab580c11ad9ebe8e1c6e7df104688b172" title="Page list used to submit IO when memory is in pressure.">emrg_page_list</a>;
<a name="l00113"></a><a class="code" href="structlov__device__emerg.html#a2d443d8c5db44bde24613f5a2921d0a9">00113</a>         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>        <a class="code" href="structlov__device__emerg.html#a2d443d8c5db44bde24613f5a2921d0a9" title="sub-io&amp;#39;s shared by all threads accessing this device when memory is too low to...">emrg_subio</a>;
<a name="l00118"></a><a class="code" href="structlov__device__emerg.html#a30ec2998c907817681103c64888d59fc">00118</a>         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>      *<a class="code" href="structlov__device__emerg.html#a30ec2998c907817681103c64888d59fc" title="Environments used by sub-io&amp;#39;s in lov_device_emerg::emrg_subio.">emrg_env</a>;
<a name="l00124"></a><a class="code" href="structlov__device__emerg.html#a38664c62ade1da34373ec8bf09609ae1">00124</a>         __u16               <a class="code" href="structlov__device__emerg.html#a38664c62ade1da34373ec8bf09609ae1" title="Refchecks for lov_device_emerg::emrg_env.">emrg_refcheck</a>;
<a name="l00125"></a>00125 };
<a name="l00126"></a>00126 
<a name="l00127"></a><a class="code" href="structlov__device.html">00127</a> <span class="keyword">struct </span><a class="code" href="structlov__device.html">lov_device</a> {
<a name="l00128"></a>00128         <span class="comment">/*</span>
<a name="l00129"></a>00129 <span class="comment">         * XXX Locking of lov-private data is missing.</span>
<a name="l00130"></a>00130 <span class="comment">         */</span>
<a name="l00131"></a>00131         <span class="keyword">struct </span><a class="code" href="structcl__device.html" title="Device in the client stack.">cl_device</a>          ld_cl;
<a name="l00132"></a>00132         <span class="keyword">struct </span><a class="code" href="structlov__obd.html">lov_obd</a>           *ld_lov;
<a name="l00134"></a><a class="code" href="structlov__device.html#ae4fa8ce0d2cde44938876f1eb53b1be2">00134</a>         __u32                     <a class="code" href="structlov__device.html#ae4fa8ce0d2cde44938876f1eb53b1be2" title="size of lov_device::ld_target[] array">ld_target_nr</a>;
<a name="l00135"></a>00135         <span class="keyword">struct </span><a class="code" href="structlovsub__device.html">lovsub_device</a>    **ld_target;
<a name="l00136"></a>00136         __u32                     ld_flags;
<a name="l00137"></a>00137 
<a name="l00139"></a><a class="code" href="structlov__device.html#af1be06dcf4a1884475fc3a098de98bca">00139</a>         <span class="keyword">struct </span><a class="code" href="structlov__device__emerg.html" title="Resources that are used in memory-cleaning path, and whose allocation cannot fail...">lov_device_emerg</a> **<a class="code" href="structlov__device.html#af1be06dcf4a1884475fc3a098de98bca" title="Emergency resources used in memory-cleansing paths.">ld_emrg</a>;
<a name="l00144"></a><a class="code" href="structlov__device.html#afe17377ec5f45235fcf37beefb069379">00144</a>         <span class="keyword">struct </span>mutex              <a class="code" href="structlov__device.html#afe17377ec5f45235fcf37beefb069379" title="Serializes access to lov_device::ld_emrg in low-memory conditions.">ld_mutex</a>;
<a name="l00145"></a>00145 };
<a name="l00146"></a>00146 
<a name="l00150"></a><a class="code" href="group__lov.html#ga28761ebc7af42a0c032a063f295c5ffb">00150</a> <span class="keyword">enum</span> <a class="code" href="group__lov.html#ga28761ebc7af42a0c032a063f295c5ffb" title="Layout type.">lov_layout_type</a> {
<a name="l00151"></a>00151         LLT_EMPTY,      
<a name="l00152"></a><a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffba81e332607fcc27ee9397e5239a8fb3ef">00152</a>         <a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffba81e332607fcc27ee9397e5239a8fb3ef" title="empty file without body (mknod + truncate)">LLT_RAID0</a>,      
<a name="l00153"></a><a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffbaa1e8f8d86df2f446390bfbf0768be16b">00153</a>         <a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffbaa1e8f8d86df2f446390bfbf0768be16b" title="striped file">LLT_RELEASED</a>,   
<a name="l00154"></a><a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffbaf3f741ce77c6819f58ac2c4f5b7be0b6">00154</a>         <a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffbaf3f741ce77c6819f58ac2c4f5b7be0b6" title="file with no objects (data in HSM)">LLT_NR</a>
<a name="l00155"></a>00155 };
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span> *llt2str(<span class="keyword">enum</span> <a class="code" href="group__lov.html#ga28761ebc7af42a0c032a063f295c5ffb" title="Layout type.">lov_layout_type</a> llt)
<a name="l00158"></a>00158 {
<a name="l00159"></a>00159         <span class="keywordflow">switch</span> (llt) {
<a name="l00160"></a>00160         <span class="keywordflow">case</span> LLT_EMPTY:
<a name="l00161"></a>00161                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;EMPTY&quot;</span>;
<a name="l00162"></a>00162         <span class="keywordflow">case</span> <a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffba81e332607fcc27ee9397e5239a8fb3ef" title="empty file without body (mknod + truncate)">LLT_RAID0</a>:
<a name="l00163"></a>00163                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;RAID0&quot;</span>;
<a name="l00164"></a>00164         <span class="keywordflow">case</span> <a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffbaa1e8f8d86df2f446390bfbf0768be16b" title="striped file">LLT_RELEASED</a>:
<a name="l00165"></a>00165                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;RELEASED&quot;</span>;
<a name="l00166"></a>00166         <span class="keywordflow">case</span> <a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffbaf3f741ce77c6819f58ac2c4f5b7be0b6" title="file with no objects (data in HSM)">LLT_NR</a>:
<a name="l00167"></a>00167                 LBUG();
<a name="l00168"></a>00168         }
<a name="l00169"></a>00169         LBUG();
<a name="l00170"></a>00170         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00171"></a>00171 }
<a name="l00172"></a>00172 
<a name="l00187"></a><a class="code" href="structlov__object.html">00187</a> <span class="keyword">struct </span><a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a> {
<a name="l00188"></a>00188         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>       lo_cl;
<a name="l00197"></a><a class="code" href="structlov__object.html#aab2ef978c79c508d47197c8078abf098">00197</a>         <span class="keyword">struct </span>rw_semaphore     <a class="code" href="structlov__object.html#aab2ef978c79c508d47197c8078abf098" title="Serializes object operations with transitions between layout types.">lo_type_guard</a>;
<a name="l00201"></a><a class="code" href="structlov__object.html#ab8b1070ca6fafc078bf5aa26c105382b">00201</a>         <span class="keyword">enum</span> <a class="code" href="group__lov.html#ga28761ebc7af42a0c032a063f295c5ffb" title="Layout type.">lov_layout_type</a>    <a class="code" href="structlov__object.html#ab8b1070ca6fafc078bf5aa26c105382b" title="Type of an object.">lo_type</a>;
<a name="l00206"></a><a class="code" href="structlov__object.html#a727ffe65ad9258f29f0b9849013dea55">00206</a>         <span class="keywordtype">bool</span>                    <a class="code" href="structlov__object.html#a727ffe65ad9258f29f0b9849013dea55" title="True if layout is invalid.">lo_layout_invalid</a>;
<a name="l00211"></a><a class="code" href="structlov__object.html#ad226b54b1209770b9ed33a6c6a36f62c">00211</a>         atomic_t               <a class="code" href="structlov__object.html#ad226b54b1209770b9ed33a6c6a36f62c" title="How many IOs are on going on this object.">lo_active_ios</a>;
<a name="l00215"></a><a class="code" href="structlov__object.html#a134c9f082f0e90422d7a2a84e3289ecd">00215</a>         wait_queue_head_t       <a class="code" href="structlov__object.html#a134c9f082f0e90422d7a2a84e3289ecd" title="Waitq - wait for no one else is using lo_lsm.">lo_waitq</a>;
<a name="l00219"></a><a class="code" href="structlov__object.html#a3c923cc1d7a5577213df50f1940c2be9">00219</a>         <span class="keyword">struct </span><a class="code" href="structlov__stripe__md.html">lov_stripe_md</a>  *<a class="code" href="structlov__object.html#a3c923cc1d7a5577213df50f1940c2be9" title="Layout metadata.">lo_lsm</a>;
<a name="l00220"></a>00220 
<a name="l00221"></a><a class="code" href="unionlov__object_1_1lov__layout__state.html">00221</a>         <span class="keyword">union </span><a class="code" href="unionlov__object_1_1lov__layout__state.html">lov_layout_state</a> {
<a name="l00222"></a><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html">00222</a>                 <span class="keyword">struct </span><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html">lov_layout_raid0</a> {
<a name="l00223"></a>00223                         <span class="keywordtype">unsigned</span>               lo_nr;
<a name="l00230"></a><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html#a9f007c05f804b56ba82476961121437e">00230</a>                         <span class="keywordtype">int</span>                    <a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html#a9f007c05f804b56ba82476961121437e" title="When this is true, lov_object::lo_attr contains valid up to date attributes for a...">lo_attr_valid</a>;
<a name="l00248"></a><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html#a2e5c4dc84cb2b59d7d94381bfe11782c">00248</a>                         <span class="keyword">struct </span><a class="code" href="structlovsub__object.html">lovsub_object</a> **<a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html#a2e5c4dc84cb2b59d7d94381bfe11782c" title="Array of sub-objects.">lo_sub</a>;
<a name="l00252"></a><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html#aad94c86c358254ee1d75712e1ac8b1a3">00252</a>                         spinlock_t              <a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html#aad94c86c358254ee1d75712e1ac8b1a3" title="protect lo_sub">lo_sub_lock</a>;
<a name="l00257"></a><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html#a6f91876fd2fcd8110e1cc91469fc6547">00257</a>                         <span class="keyword">struct </span><a class="code" href="structcl__attr.html" title="&amp;quot;Data attributes&amp;quot; of cl_object.">cl_attr</a>         <a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__raid0.html#a6f91876fd2fcd8110e1cc91469fc6547" title="Cached object attribute, built from sub-object attributes.">lo_attr</a>;
<a name="l00258"></a>00258                 } raid0;
<a name="l00259"></a><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__state__empty.html">00259</a>                 <span class="keyword">struct </span><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__state__empty.html">lov_layout_state_empty</a> {
<a name="l00260"></a>00260                 } empty;
<a name="l00261"></a><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__state__released.html">00261</a>                 <span class="keyword">struct </span><a class="code" href="structlov__object_1_1lov__layout__state_1_1lov__layout__state__released.html">lov_layout_state_released</a> {
<a name="l00262"></a>00262                 } released;
<a name="l00263"></a>00263         } u;
<a name="l00268"></a><a class="code" href="structlov__object.html#a3814521c58719ed71173f785659532ac">00268</a>         <span class="keyword">struct </span>task_struct            *<a class="code" href="structlov__object.html#a3814521c58719ed71173f785659532ac" title="Thread that acquired lov_object::lo_type_guard in an exclusive mode.">lo_owner</a>;
<a name="l00269"></a>00269 };
<a name="l00270"></a>00270 
<a name="l00274"></a><a class="code" href="structlov__lock__sub.html">00274</a> <span class="keyword">struct </span><a class="code" href="structlov__lock__sub.html" title="State lov_lock keeps for each sub-lock.">lov_lock_sub</a> {
<a name="l00276"></a><a class="code" href="structlov__lock__sub.html#a5a3014853bdd15361f5e02e32a92c50a">00276</a>         <span class="keyword">struct </span><a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>          <a class="code" href="structlov__lock__sub.html#a5a3014853bdd15361f5e02e32a92c50a" title="sub-lock itself">sub_lock</a>;
<a name="l00279"></a><a class="code" href="structlov__lock__sub.html#a617a0afe18937160926aa415684e11d8">00279</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlov__lock__sub.html#a617a0afe18937160926aa415684e11d8" title="Set if the sublock has ever been enqueued, meaning it may hold resources of underlying...">sub_is_enqueued</a>:1,
<a name="l00280"></a>00280                                 sub_initialized:1;
<a name="l00281"></a>00281         <span class="keywordtype">int</span>                     sub_stripe;
<a name="l00282"></a>00282 };
<a name="l00283"></a>00283 
<a name="l00287"></a><a class="code" href="structlov__lock.html">00287</a> <span class="keyword">struct </span><a class="code" href="structlov__lock.html" title="lov-specific lock state.">lov_lock</a> {
<a name="l00288"></a>00288         <span class="keyword">struct </span><a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a>    lls_cl;
<a name="l00290"></a><a class="code" href="structlov__lock.html#a87d809ad12c11d9a5cfafbc64c4b9177">00290</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlov__lock.html#a87d809ad12c11d9a5cfafbc64c4b9177" title="Number of sub-locks in this lock.">lls_nr</a>;
<a name="l00292"></a><a class="code" href="structlov__lock.html#ab0a8bc3e3852e9886ce9a6d7418e1fc8">00292</a>         <span class="keyword">struct </span><a class="code" href="structlov__lock__sub.html" title="State lov_lock keeps for each sub-lock.">lov_lock_sub</a>     <a class="code" href="structlov__lock.html#ab0a8bc3e3852e9886ce9a6d7418e1fc8" title="sublock array">lls_sub</a>[0];
<a name="l00293"></a>00293 };
<a name="l00294"></a>00294 
<a name="l00295"></a><a class="code" href="structlov__page.html">00295</a> <span class="keyword">struct </span><a class="code" href="structlov__page.html">lov_page</a> {
<a name="l00296"></a>00296         <span class="keyword">struct </span><a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a>    lps_cl;
<a name="l00297"></a>00297         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lps_stripe; <span class="comment">/* stripe index */</span>
<a name="l00298"></a>00298 };
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="comment">/*</span>
<a name="l00301"></a>00301 <span class="comment"> * Bottom half.</span>
<a name="l00302"></a>00302 <span class="comment"> */</span>
<a name="l00303"></a>00303 
<a name="l00304"></a><a class="code" href="structlovsub__device.html">00304</a> <span class="keyword">struct </span><a class="code" href="structlovsub__device.html">lovsub_device</a> {
<a name="l00305"></a>00305         <span class="keyword">struct </span><a class="code" href="structcl__device.html" title="Device in the client stack.">cl_device</a>   acid_cl;
<a name="l00306"></a>00306         <span class="keyword">struct </span><a class="code" href="structlov__device.html">lov_device</a> *acid_super;
<a name="l00307"></a>00307         <span class="keywordtype">int</span>                acid_idx;
<a name="l00308"></a>00308         <span class="keyword">struct </span><a class="code" href="structcl__device.html" title="Device in the client stack.">cl_device</a>  *acid_next;
<a name="l00309"></a>00309 };
<a name="l00310"></a>00310 
<a name="l00311"></a><a class="code" href="structlovsub__object.html">00311</a> <span class="keyword">struct </span><a class="code" href="structlovsub__object.html">lovsub_object</a> {
<a name="l00312"></a>00312         <span class="keyword">struct </span><a class="code" href="structcl__object__header.html" title="Extended header for client object.">cl_object_header</a> lso_header;
<a name="l00313"></a>00313         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>        lso_cl;
<a name="l00314"></a>00314         <span class="keyword">struct </span><a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a>      *lso_super;
<a name="l00315"></a>00315         <span class="keywordtype">int</span>                     lso_index;
<a name="l00316"></a>00316 };
<a name="l00317"></a>00317 
<a name="l00325"></a><a class="code" href="structlov__lock__link.html">00325</a> <span class="keyword">struct </span><a class="code" href="structlov__lock__link.html" title="A link between a top-lock and a sub-lock.">lov_lock_link</a> {
<a name="l00326"></a>00326         <span class="keyword">struct </span><a class="code" href="structlov__lock.html" title="lov-specific lock state.">lov_lock</a> *lll_super;
<a name="l00328"></a><a class="code" href="structlov__lock__link.html#a8d77910f7f6628311dd92b26af591db3">00328</a>         <span class="keywordtype">int</span>              <a class="code" href="structlov__lock__link.html#a8d77910f7f6628311dd92b26af591db3" title="An index within parent lock.">lll_idx</a>;
<a name="l00333"></a><a class="code" href="structlov__lock__link.html#acbe6aa6bd13e2125da93bce5248648c4">00333</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> <a class="code" href="structlov__lock__link.html#acbe6aa6bd13e2125da93bce5248648c4" title="A linkage into per sub-lock list of all corresponding top-locks, hanging off lovsub_lock::lss_parent...">lll_list</a>;
<a name="l00334"></a>00334 };
<a name="l00335"></a>00335 
<a name="l00339"></a><a class="code" href="structlovsub__lock.html">00339</a> <span class="keyword">struct </span><a class="code" href="structlovsub__lock.html" title="Lock state at lovsub layer.">lovsub_lock</a> {
<a name="l00340"></a>00340         <span class="keyword">struct </span><a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a>  lss_cl;
<a name="l00345"></a><a class="code" href="structlovsub__lock.html#a32cc2364b7428169f17769301f53bc7d">00345</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlovsub__lock.html#a32cc2364b7428169f17769301f53bc7d" title="List of top-locks that have given sub-lock as their part.">lss_parents</a>;
<a name="l00354"></a><a class="code" href="structlovsub__lock.html#a413361854bf37872d1c556d1d1fe594b">00354</a>         <span class="keyword">struct </span><a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>       *<a class="code" href="structlovsub__lock.html#a413361854bf37872d1c556d1d1fe594b" title="Top-lock that initiated current operation on this sub-lock.">lss_active</a>;
<a name="l00355"></a>00355 };
<a name="l00356"></a>00356 
<a name="l00360"></a><a class="code" href="structlov__sublock__env.html">00360</a> <span class="keyword">struct </span><a class="code" href="structlov__sublock__env.html" title="Describe the environment settings for sublocks.">lov_sublock_env</a> {
<a name="l00361"></a>00361         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *lse_env;
<a name="l00362"></a>00362         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>        *lse_io;
<a name="l00363"></a>00363         <span class="keyword">struct </span><a class="code" href="structlov__io__sub.html" title="State that lov_io maintains for every sub-io.">lov_io_sub</a>   *lse_sub;
<a name="l00364"></a>00364 };
<a name="l00365"></a>00365 
<a name="l00366"></a><a class="code" href="structlovsub__page.html">00366</a> <span class="keyword">struct </span><a class="code" href="structlovsub__page.html">lovsub_page</a> {
<a name="l00367"></a>00367         <span class="keyword">struct </span><a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> lsb_cl;
<a name="l00368"></a>00368 };
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 
<a name="l00371"></a><a class="code" href="structlov__thread__info.html">00371</a> <span class="keyword">struct </span><a class="code" href="structlov__thread__info.html">lov_thread_info</a> {
<a name="l00372"></a>00372         <span class="keyword">struct </span><a class="code" href="structcl__object__conf.html" title="Description of the client object configuration.">cl_object_conf</a>   lti_stripe_conf;
<a name="l00373"></a>00373         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           lti_fid;
<a name="l00374"></a>00374         <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a>    lti_ldescr;
<a name="l00375"></a>00375         <span class="keyword">struct </span><a class="code" href="structost__lvb.html">ost_lvb</a>          lti_lvb;
<a name="l00376"></a>00376         <span class="keyword">struct </span><a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a>        lti_cl2q;
<a name="l00377"></a>00377         <span class="keyword">struct </span><a class="code" href="structcl__page__list.html">cl_page_list</a>     lti_plist;
<a name="l00378"></a>00378         wait_queue_t            lti_waiter;
<a name="l00379"></a>00379         <span class="keyword">struct </span><a class="code" href="structcl__attr.html" title="&amp;quot;Data attributes&amp;quot; of cl_object.">cl_attr</a>          lti_attr;
<a name="l00380"></a>00380 };
<a name="l00381"></a>00381 
<a name="l00385"></a><a class="code" href="structlov__io__sub.html">00385</a> <span class="keyword">struct </span><a class="code" href="structlov__io__sub.html" title="State that lov_io maintains for every sub-io.">lov_io_sub</a> {
<a name="l00386"></a>00386         __u16                   sub_stripe;
<a name="l00392"></a><a class="code" href="structlov__io__sub.html#a6cff30515a4feb9cdd8a9934cb264352">00392</a>         __u16                   <a class="code" href="structlov__io__sub.html#a6cff30515a4feb9cdd8a9934cb264352" title="environment&amp;#39;s refcheck.">sub_refcheck</a>;
<a name="l00393"></a>00393         __u16                   sub_reenter;
<a name="l00398"></a><a class="code" href="structlov__io__sub.html#ae896419a893976693a8329533aedcec8">00398</a>         __u16                   <a class="code" href="structlov__io__sub.html#ae896419a893976693a8329533aedcec8" title="true, iff cl_io_init() was successfully executed against lov_io_sub::sub_io.">sub_io_initialized</a>:1,
<a name="l00403"></a>00403                                 <a class="code" href="structlov__io__sub.html#ad5949b093a640d6f4a72c71411a8095f" title="True, iff lov_io_sub::sub_io and lov_io_sub::sub_env weren&amp;#39;t allocated, but borrowed...">sub_borrowed</a>:1;
<a name="l00408"></a><a class="code" href="structlov__io__sub.html#aa95a5c38ceed4db24e2ade0ad2e972aa">00408</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlov__io__sub.html#aa95a5c38ceed4db24e2ade0ad2e972aa" title="Linkage into a list (hanging off lov_io::lis_active) of all sub-io&amp;#39;s active for...">sub_linkage</a>;
<a name="l00414"></a><a class="code" href="structlov__io__sub.html#a697cdbff9d6db2457e7be05cf25a8a86">00414</a>         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>            *<a class="code" href="structlov__io__sub.html#a697cdbff9d6db2457e7be05cf25a8a86" title="sub-io for a stripe.">sub_io</a>;
<a name="l00418"></a><a class="code" href="structlov__io__sub.html#af7f564ec1fe8808d1ea88d4086f5eb55">00418</a>         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>           *<a class="code" href="structlov__io__sub.html#af7f564ec1fe8808d1ea88d4086f5eb55" title="environment, in which sub-io executes.">sub_env</a>;
<a name="l00419"></a>00419 };
<a name="l00420"></a>00420 
<a name="l00424"></a><a class="code" href="structlov__io.html">00424</a> <span class="keyword">struct </span><a class="code" href="structlov__io.html" title="IO state private for LOV.">lov_io</a> {
<a name="l00426"></a><a class="code" href="structlov__io.html#a5f938199823edc9591ca5a6e10352781">00426</a>         <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> <a class="code" href="structlov__io.html#a5f938199823edc9591ca5a6e10352781" title="super-class">lis_cl</a>;
<a name="l00431"></a><a class="code" href="structlov__io.html#aaa89242164bd4c47c0cc912ee74c715a">00431</a>         <span class="keyword">struct </span><a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a> *<a class="code" href="structlov__io.html#aaa89242164bd4c47c0cc912ee74c715a" title="Pointer to the object slice.">lis_object</a>;
<a name="l00440"></a><a class="code" href="structlov__io.html#a778b0655e6dbf5fcd8d85c5d4ed9985d">00440</a>         loff_t             <a class="code" href="structlov__io.html#a778b0655e6dbf5fcd8d85c5d4ed9985d" title="Original end-of-io position for this IO, set by the upper layer as cl_io::u::ci_rw::pos...">lis_io_endpos</a>;
<a name="l00441"></a>00441 
<a name="l00446"></a><a class="code" href="structlov__io.html#abf417e70f1ed288fd51e00156a0cbe3c">00446</a>         loff_t                   <a class="code" href="structlov__io.html#abf417e70f1ed288fd51e00156a0cbe3c" title="starting position within a file, for the current io loop iteration (stripe), used...">lis_pos</a>;
<a name="l00451"></a><a class="code" href="structlov__io.html#a604e795f99fb9db731807c29c90fa4a7">00451</a>         loff_t                   <a class="code" href="structlov__io.html#a604e795f99fb9db731807c29c90fa4a7" title="end position with in a file, for the current stripe io.">lis_endpos</a>;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         <span class="keywordtype">int</span>                     lis_mem_frozen;
<a name="l00454"></a>00454         <span class="keywordtype">int</span>                     lis_stripe_count;
<a name="l00455"></a>00455         <span class="keywordtype">int</span>                     lis_active_subios;
<a name="l00456"></a>00456 
<a name="l00460"></a><a class="code" href="structlov__io.html#ab54e322284acffc02595f1c9db9c6e53">00460</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlov__io.html#ab54e322284acffc02595f1c9db9c6e53" title="the index of ls_single_subio in ls_subios array">lis_single_subio_index</a>;
<a name="l00461"></a>00461         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>            lis_single_subio;
<a name="l00462"></a>00462 
<a name="l00467"></a><a class="code" href="structlov__io.html#a272185c839140914ebf40b3ac97f18d6">00467</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlov__io.html#a272185c839140914ebf40b3ac97f18d6" title="size of ls_subios array, actually the highest stripe # May be vmalloc&amp;#39;d, must...">lis_nr_subios</a>;
<a name="l00468"></a>00468         <span class="keyword">struct </span><a class="code" href="structlov__io__sub.html" title="State that lov_io maintains for every sub-io.">lov_io_sub</a>       *lis_subs;
<a name="l00472"></a><a class="code" href="structlov__io.html#a532ccbdb32654eb433c3f9c288c04af7">00472</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlov__io.html#a532ccbdb32654eb433c3f9c288c04af7" title="List of active sub-io&amp;#39;s.">lis_active</a>;
<a name="l00473"></a>00473 };
<a name="l00474"></a>00474 
<a name="l00475"></a><a class="code" href="structlov__session.html">00475</a> <span class="keyword">struct </span><a class="code" href="structlov__session.html">lov_session</a> {
<a name="l00476"></a>00476         <span class="keyword">struct </span><a class="code" href="structlov__io.html" title="IO state private for LOV.">lov_io</a>          ls_io;
<a name="l00477"></a>00477         <span class="keyword">struct </span><a class="code" href="structlov__sublock__env.html" title="Describe the environment settings for sublocks.">lov_sublock_env</a> ls_subenv;
<a name="l00478"></a>00478 };
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> lov_device_type;
<a name="l00481"></a>00481 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> lovsub_device_type;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> lov_key;
<a name="l00484"></a>00484 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> lov_session_key;
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *lov_lock_kmem;
<a name="l00487"></a>00487 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *lov_object_kmem;
<a name="l00488"></a>00488 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *lov_thread_kmem;
<a name="l00489"></a>00489 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *lov_session_kmem;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *lovsub_lock_kmem;
<a name="l00492"></a>00492 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *lovsub_object_kmem;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *lov_lock_link_kmem;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 <span class="keywordtype">int</span>   lov_object_init     (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj,
<a name="l00497"></a>00497                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object__conf.html" title="Object configuration, describing particulars of object being created.">lu_object_conf</a> *conf);
<a name="l00498"></a>00498 <span class="keywordtype">int</span>   lovsub_object_init  (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj,
<a name="l00499"></a>00499                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object__conf.html" title="Object configuration, describing particulars of object being created.">lu_object_conf</a> *conf);
<a name="l00500"></a>00500 <span class="keywordtype">int</span>   lov_lock_init       (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00501"></a>00501                            <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00502"></a>00502 <span class="keywordtype">int</span>   <a class="code" href="group__lov.html#gac574558c668ecbfd3bb659c6d4707665" title="Implements cl_object_operations::clo_io_init() method for lov layer.">lov_io_init</a>         (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00503"></a>00503                            <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00504"></a>00504 <span class="keywordtype">int</span>   lovsub_lock_init    (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00505"></a>00505                            <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 <span class="keywordtype">int</span>   lov_lock_init_raid0 (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00508"></a>00508                            <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00509"></a>00509 <span class="keywordtype">int</span>   lov_lock_init_empty (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00510"></a>00510                            <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00511"></a>00511 <span class="keywordtype">int</span>   lov_io_init_raid0   (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00512"></a>00512                            <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00513"></a>00513 <span class="keywordtype">int</span>   lov_io_init_empty   (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00514"></a>00514                            <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00515"></a>00515 <span class="keywordtype">int</span>   lov_io_init_released(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00516"></a>00516                            <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00517"></a>00517 <span class="keywordtype">void</span>  lov_lock_unlink     (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlov__lock__link.html" title="A link between a top-lock and a sub-lock.">lov_lock_link</a> *link,
<a name="l00518"></a>00518                            <span class="keyword">struct</span> <a class="code" href="structlovsub__lock.html" title="Lock state at lovsub layer.">lovsub_lock</a> *sub);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="keyword">struct </span><a class="code" href="structlov__io__sub.html" title="State that lov_io maintains for every sub-io.">lov_io_sub</a> *lov_sub_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlov__io.html" title="IO state private for LOV.">lov_io</a> *lio,
<a name="l00521"></a>00521                                <span class="keywordtype">int</span> stripe);
<a name="l00522"></a>00522 <span class="keywordtype">void</span>  lov_sub_put             (<span class="keyword">struct</span> <a class="code" href="structlov__io__sub.html" title="State that lov_io maintains for every sub-io.">lov_io_sub</a> *sub);
<a name="l00523"></a>00523 <span class="keywordtype">int</span>   lov_sublock_modify  (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlov__lock.html" title="lov-specific lock state.">lov_lock</a> *lov,
<a name="l00524"></a>00524                            <span class="keyword">struct</span> <a class="code" href="structlovsub__lock.html" title="Lock state at lovsub layer.">lovsub_lock</a> *sublock,
<a name="l00525"></a>00525                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *d, <span class="keywordtype">int</span> idx);
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="keywordtype">int</span>   lov_page_init       (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *ob,
<a name="l00529"></a>00529                            <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page, pgoff_t index);
<a name="l00530"></a>00530 <span class="keywordtype">int</span>   lovsub_page_init    (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *ob,
<a name="l00531"></a>00531                            <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page, pgoff_t index);
<a name="l00532"></a>00532 <span class="keywordtype">int</span>   lov_page_init_empty (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00533"></a>00533                            <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page, pgoff_t index);
<a name="l00534"></a>00534 <span class="keywordtype">int</span>   lov_page_init_raid0 (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00535"></a>00535                            <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page, pgoff_t index);
<a name="l00536"></a>00536 <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *lov_object_alloc   (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00537"></a>00537                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object__header.html" title="&amp;quot;Compound&amp;quot; object, consisting of multiple layers.">lu_object_header</a> *hdr,
<a name="l00538"></a>00538                                       <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *dev);
<a name="l00539"></a>00539 <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *lovsub_object_alloc(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00540"></a>00540                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object__header.html" title="&amp;quot;Compound&amp;quot; object, consisting of multiple layers.">lu_object_header</a> *hdr,
<a name="l00541"></a>00541                                       <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *dev);
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="keyword">struct </span><a class="code" href="structlov__lock__link.html" title="A link between a top-lock and a sub-lock.">lov_lock_link</a> *lov_lock_link_find(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00544"></a>00544                                          <span class="keyword">struct</span> <a class="code" href="structlov__lock.html" title="lov-specific lock state.">lov_lock</a> *lck,
<a name="l00545"></a>00545                                          <span class="keyword">struct</span> <a class="code" href="structlovsub__lock.html" title="Lock state at lovsub layer.">lovsub_lock</a> *sub);
<a name="l00546"></a>00546 <span class="keyword">struct </span><a class="code" href="structlov__io__sub.html" title="State that lov_io maintains for every sub-io.">lov_io_sub</a>    *lov_page_subio    (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00547"></a>00547                                          <span class="keyword">struct</span> <a class="code" href="structlov__io.html" title="IO state private for LOV.">lov_io</a> *lio,
<a name="l00548"></a>00548                                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="keyword">struct </span><a class="code" href="structlov__stripe__md.html">lov_stripe_md</a> *lov_lsm_addref(<span class="keyword">struct</span> <a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a> *lov);
<a name="l00551"></a>00551 <span class="keywordtype">int</span> lov_page_stripe(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page);
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 <span class="preprocessor">#define lov_foreach_target(lov, var)                    \</span>
<a name="l00554"></a>00554 <span class="preprocessor">        for (var = 0; var &lt; lov_targets_nr(lov); ++var)</span>
<a name="l00555"></a>00555 <span class="preprocessor"></span>
<a name="l00556"></a>00556 <span class="comment">/*****************************************************************************</span>
<a name="l00557"></a>00557 <span class="comment"> *</span>
<a name="l00558"></a>00558 <span class="comment"> * Type conversions.</span>
<a name="l00559"></a>00559 <span class="comment"> *</span>
<a name="l00560"></a>00560 <span class="comment"> * Accessors.</span>
<a name="l00561"></a>00561 <span class="comment"> *</span>
<a name="l00562"></a>00562 <span class="comment"> */</span>
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlov__session.html">lov_session</a> *lov_env_session(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l00565"></a>00565 {
<a name="l00566"></a>00566         <span class="keyword">struct </span><a class="code" href="structlov__session.html">lov_session</a> *ses;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568         ses = <a class="code" href="group__lu.html#ga8fcebe57d8fb288a73a39144693074af" title="Return value associated with key key in context ctx.">lu_context_key_get</a>(env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>, &amp;lov_session_key);
<a name="l00569"></a>00569         LASSERT(ses != NULL);
<a name="l00570"></a>00570         <span class="keywordflow">return</span> ses;
<a name="l00571"></a>00571 }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlov__io.html" title="IO state private for LOV.">lov_io</a> *lov_env_io(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l00574"></a>00574 {
<a name="l00575"></a>00575         <span class="keywordflow">return</span> &amp;lov_env_session(env)-&gt;ls_io;
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lov_is_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj)
<a name="l00579"></a>00579 {
<a name="l00580"></a>00580         <span class="keywordflow">return</span> obj-&gt;<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a> == &amp;lov_device_type;
<a name="l00581"></a>00581 }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lovsub_is_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj)
<a name="l00584"></a>00584 {
<a name="l00585"></a>00585         <span class="keywordflow">return</span> obj-&gt;<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a> == &amp;lovsub_device_type;
<a name="l00586"></a>00586 }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *lov2lu_dev(<span class="keyword">struct</span> <a class="code" href="structlov__device.html">lov_device</a> *lov)
<a name="l00589"></a>00589 {
<a name="l00590"></a>00590         <span class="keywordflow">return</span> &amp;lov-&gt;ld_cl.<a class="code" href="structcl__device.html#a881ea223a07828242f8c3b02f65792db" title="Super-class.">cd_lu_dev</a>;
<a name="l00591"></a>00591 }
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlov__device.html">lov_device</a> *lu2lov_dev(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *d)
<a name="l00594"></a>00594 {
<a name="l00595"></a>00595         LINVRNT(d-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a> == &amp;lov_device_type);
<a name="l00596"></a>00596         <span class="keywordflow">return</span> container_of0(d, <span class="keyword">struct</span> <a class="code" href="structlov__device.html">lov_device</a>, ld_cl.cd_lu_dev);
<a name="l00597"></a>00597 }
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structcl__device.html" title="Device in the client stack.">cl_device</a> *lovsub2cl_dev(<span class="keyword">struct</span> <a class="code" href="structlovsub__device.html">lovsub_device</a> *lovsub)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601         <span class="keywordflow">return</span> &amp;lovsub-&gt;acid_cl;
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *lovsub2lu_dev(<span class="keyword">struct</span> <a class="code" href="structlovsub__device.html">lovsub_device</a> *lovsub)
<a name="l00605"></a>00605 {
<a name="l00606"></a>00606         <span class="keywordflow">return</span> &amp;lovsub2cl_dev(lovsub)-&gt;<a class="code" href="structcl__device.html#a881ea223a07828242f8c3b02f65792db" title="Super-class.">cd_lu_dev</a>;
<a name="l00607"></a>00607 }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlovsub__device.html">lovsub_device</a> *lu2lovsub_dev(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *d)
<a name="l00610"></a>00610 {
<a name="l00611"></a>00611         LINVRNT(d-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a> == &amp;lovsub_device_type);
<a name="l00612"></a>00612         <span class="keywordflow">return</span> container_of0(d, <span class="keyword">struct</span> <a class="code" href="structlovsub__device.html">lovsub_device</a>, acid_cl.cd_lu_dev);
<a name="l00613"></a>00613 }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlovsub__device.html">lovsub_device</a> *cl2lovsub_dev(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__device.html" title="Device in the client stack.">cl_device</a> *d)
<a name="l00616"></a>00616 {
<a name="l00617"></a>00617         LINVRNT(d-&gt;<a class="code" href="structcl__device.html#a881ea223a07828242f8c3b02f65792db" title="Super-class.">cd_lu_dev</a>.<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a> == &amp;lovsub_device_type);
<a name="l00618"></a>00618         <span class="keywordflow">return</span> container_of0(d, <span class="keyword">struct</span> <a class="code" href="structlovsub__device.html">lovsub_device</a>, acid_cl);
<a name="l00619"></a>00619 }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *lov2lu(<span class="keyword">struct</span> <a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a> *lov)
<a name="l00622"></a>00622 {
<a name="l00623"></a>00623         <span class="keywordflow">return</span> &amp;lov-&gt;lo_cl.<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>;
<a name="l00624"></a>00624 }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *lov2cl(<span class="keyword">struct</span> <a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a> *lov)
<a name="l00627"></a>00627 {
<a name="l00628"></a>00628         <span class="keywordflow">return</span> &amp;lov-&gt;lo_cl;
<a name="l00629"></a>00629 }
<a name="l00630"></a>00630 
<a name="l00631"></a>00631 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a> *lu2lov(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj)
<a name="l00632"></a>00632 {
<a name="l00633"></a>00633         LINVRNT(lov_is_object(obj));
<a name="l00634"></a>00634         <span class="keywordflow">return</span> container_of0(obj, <span class="keyword">struct</span> <a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a>, lo_cl.co_lu);
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a> *cl2lov(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj)
<a name="l00638"></a>00638 {
<a name="l00639"></a>00639         LINVRNT(lov_is_object(&amp;obj-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00640"></a>00640         <span class="keywordflow">return</span> container_of0(obj, <span class="keyword">struct</span> <a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a>, lo_cl);
<a name="l00641"></a>00641 }
<a name="l00642"></a>00642 
<a name="l00643"></a>00643 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *lovsub2lu(<span class="keyword">struct</span> <a class="code" href="structlovsub__object.html">lovsub_object</a> *los)
<a name="l00644"></a>00644 {
<a name="l00645"></a>00645         <span class="keywordflow">return</span> &amp;los-&gt;lso_cl.<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>;
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 
<a name="l00648"></a>00648 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *lovsub2cl(<span class="keyword">struct</span> <a class="code" href="structlovsub__object.html">lovsub_object</a> *los)
<a name="l00649"></a>00649 {
<a name="l00650"></a>00650         <span class="keywordflow">return</span> &amp;los-&gt;lso_cl;
<a name="l00651"></a>00651 }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlovsub__object.html">lovsub_object</a> *cl2lovsub(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj)
<a name="l00654"></a>00654 {
<a name="l00655"></a>00655         LINVRNT(lovsub_is_object(&amp;obj-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00656"></a>00656         <span class="keywordflow">return</span> container_of0(obj, <span class="keyword">struct</span> <a class="code" href="structlovsub__object.html">lovsub_object</a>, lso_cl);
<a name="l00657"></a>00657 }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlovsub__object.html">lovsub_object</a> *lu2lovsub(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj)
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661         LINVRNT(lovsub_is_object(obj));
<a name="l00662"></a>00662         <span class="keywordflow">return</span> container_of0(obj, <span class="keyword">struct</span> <a class="code" href="structlovsub__object.html">lovsub_object</a>, lso_cl.co_lu);
<a name="l00663"></a>00663 }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlovsub__lock.html" title="Lock state at lovsub layer.">lovsub_lock</a> *
<a name="l00666"></a>00666 cl2lovsub_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice)
<a name="l00667"></a>00667 {
<a name="l00668"></a>00668         LINVRNT(lovsub_is_object(&amp;slice-&gt;<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00669"></a>00669         <span class="keywordflow">return</span> container_of(slice, <span class="keyword">struct</span> <a class="code" href="structlovsub__lock.html" title="Lock state at lovsub layer.">lovsub_lock</a>, lss_cl);
<a name="l00670"></a>00670 }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlovsub__lock.html" title="Lock state at lovsub layer.">lovsub_lock</a> *cl2sub_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock)
<a name="l00673"></a>00673 {
<a name="l00674"></a>00674         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676         slice = <a class="code" href="group__cl__lock.html#ga9b59ad7624c11fcecf6eadb1a58f6f8b" title="Returns a slice with a lock, corresponding to the given layer in the device stack...">cl_lock_at</a>(lock, &amp;lovsub_device_type);
<a name="l00677"></a>00677         LASSERT(slice != NULL);
<a name="l00678"></a>00678         <span class="keywordflow">return</span> cl2lovsub_lock(slice);
<a name="l00679"></a>00679 }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlov__lock.html" title="lov-specific lock state.">lov_lock</a> *cl2lov_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice)
<a name="l00682"></a>00682 {
<a name="l00683"></a>00683         LINVRNT(lov_is_object(&amp;slice-&gt;<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00684"></a>00684         <span class="keywordflow">return</span> container_of(slice, <span class="keyword">struct</span> <a class="code" href="structlov__lock.html" title="lov-specific lock state.">lov_lock</a>, lls_cl);
<a name="l00685"></a>00685 }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlov__page.html">lov_page</a> *cl2lov_page(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice)
<a name="l00688"></a>00688 {
<a name="l00689"></a>00689         LINVRNT(lov_is_object(&amp;slice-&gt;<a class="code" href="structcl__page__slice.html#a71c54d2bf9c69b3a66df261412d0ba78" title="Object slice corresponding to this page slice.">cpl_obj</a>-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00690"></a>00690         <span class="keywordflow">return</span> container_of0(slice, <span class="keyword">struct</span> <a class="code" href="structlov__page.html">lov_page</a>, lps_cl);
<a name="l00691"></a>00691 }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlovsub__page.html">lovsub_page</a> *
<a name="l00694"></a>00694 cl2lovsub_page(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice)
<a name="l00695"></a>00695 {
<a name="l00696"></a>00696         LINVRNT(lovsub_is_object(&amp;slice-&gt;<a class="code" href="structcl__page__slice.html#a71c54d2bf9c69b3a66df261412d0ba78" title="Object slice corresponding to this page slice.">cpl_obj</a>-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00697"></a>00697         <span class="keywordflow">return</span> container_of0(slice, <span class="keyword">struct</span> <a class="code" href="structlovsub__page.html">lovsub_page</a>, lsb_cl);
<a name="l00698"></a>00698 }
<a name="l00699"></a>00699 
<a name="l00700"></a>00700 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlov__io.html" title="IO state private for LOV.">lov_io</a> *cl2lov_io(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00701"></a>00701                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *ios)
<a name="l00702"></a>00702 {
<a name="l00703"></a>00703         <span class="keyword">struct </span><a class="code" href="structlov__io.html" title="IO state private for LOV.">lov_io</a> *lio;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705         lio = container_of(ios, <span class="keyword">struct</span> <a class="code" href="structlov__io.html" title="IO state private for LOV.">lov_io</a>, <a class="code" href="structlov__io.html#a5f938199823edc9591ca5a6e10352781" title="super-class">lis_cl</a>);
<a name="l00706"></a>00706         LASSERT(lio == lov_env_io(env));
<a name="l00707"></a>00707         <span class="keywordflow">return</span> lio;
<a name="l00708"></a>00708 }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lov_targets_nr(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlov__device.html">lov_device</a> *lov)
<a name="l00711"></a>00711 {
<a name="l00712"></a>00712         <span class="keywordflow">return</span> lov-&gt;ld_lov-&gt;desc.ld_tgt_count;
<a name="l00713"></a>00713 }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlov__thread__info.html">lov_thread_info</a> *lov_env_info(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l00716"></a>00716 {
<a name="l00717"></a>00717         <span class="keyword">struct </span><a class="code" href="structlov__thread__info.html">lov_thread_info</a> *info;
<a name="l00718"></a>00718 
<a name="l00719"></a>00719         info = <a class="code" href="group__lu.html#ga8fcebe57d8fb288a73a39144693074af" title="Return value associated with key key in context ctx.">lu_context_key_get</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>, &amp;lov_key);
<a name="l00720"></a>00720         LASSERT(info != NULL);
<a name="l00721"></a>00721         <span class="keywordflow">return</span> info;
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>lov_layout_raid0 *lov_r0(<span class="keyword">struct</span> <a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a> *lov)
<a name="l00725"></a>00725 {
<a name="l00726"></a>00726         LASSERT(lov-&gt;<a class="code" href="structlov__object.html#ab8b1070ca6fafc078bf5aa26c105382b" title="Type of an object.">lo_type</a> == <a class="code" href="group__lov.html#gga28761ebc7af42a0c032a063f295c5ffba81e332607fcc27ee9397e5239a8fb3ef" title="empty file without body (mknod + truncate)">LLT_RAID0</a>);
<a name="l00727"></a>00727         LASSERT(lov-&gt;<a class="code" href="structlov__object.html#a3c923cc1d7a5577213df50f1940c2be9" title="Layout metadata.">lo_lsm</a>-&gt;lsm_magic == LOV_MAGIC ||
<a name="l00728"></a>00728                 lov-&gt;<a class="code" href="structlov__object.html#a3c923cc1d7a5577213df50f1940c2be9" title="Layout metadata.">lo_lsm</a>-&gt;lsm_magic == LOV_MAGIC_V3);
<a name="l00729"></a>00729         <span class="keywordflow">return</span> &amp;lov-&gt;u.raid0;
<a name="l00730"></a>00730 }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732 <span class="comment">/* lov_pack.c */</span>
<a name="l00733"></a>00733 <span class="keywordtype">int</span> lov_getstripe(<span class="keyword">struct</span> <a class="code" href="structlov__object.html" title="lov-specific file state.">lov_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structlov__stripe__md.html">lov_stripe_md</a> *lsm,
<a name="l00734"></a>00734                   <span class="keyword">struct</span> lov_user_md __user *lump);
<a name="l00735"></a>00735 
<a name="l00738"></a>00738 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:16 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
