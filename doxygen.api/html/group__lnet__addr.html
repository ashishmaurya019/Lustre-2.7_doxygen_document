<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: LNet addressing and basic types</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>LNet addressing and basic types<br/>
<small>
[<a class="el" href="group__lnet.html">LNet</a>]</small>
</h1>
<p>Addressing scheme and basic data types of LNet.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for LNet addressing and basic types:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__lnet__addr.png" border="0" alt="" usemap="#group____lnet____addr_map"/>
<map name="group____lnet____addr_map" id="group____lnet____addr">
<area shape="rect" id="node1" href="group__lnet.html" title="The Lustre Networking subsystem." alt="" coords="5,5,61,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWIRE__ATTR.html">WIRE_ATTR</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__ack.html">lnet_ack</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__put.html">lnet_put</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__get.html">lnet_get</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__reply.html">lnet_reply</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__hello.html">lnet_hello</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__counters.html">lnet_counters</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_any_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Objects maintained by the LNet are accessed through handles.  <a href="structlnet__handle__any__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global process ID.  <a href="structlnet__process__id__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1cf7949e1ca9aaf8726ddfed5a400169"></a><!-- doxytag: member="lnet_addr::LNET_VERSION" ref="ga1cf7949e1ca9aaf8726ddfed5a400169" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_VERSION</b>&nbsp;&nbsp;&nbsp;&quot;0.7.0&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__addr.html#ga9b82f6f47b45c5a95f7475c3f79ca218">LNET_RESERVED_PORTAL</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Portal reserved for LNet's own use.  <a href="#ga9b82f6f47b45c5a95f7475c3f79ca218"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf07699e7475f5357f581c00afeaaa1d7"></a><!-- doxytag: member="lnet_addr::LNET_NID_ANY" ref="gaf07699e7475f5357f581c00afeaaa1d7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7">LNET_NID_ANY</a>&nbsp;&nbsp;&nbsp;((<a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a>) -1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">wildcard NID that matches any end-point address <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga048843ee9085f3c7dab16554a040f791"></a><!-- doxytag: member="lnet_addr::LNET_PID_ANY" ref="ga048843ee9085f3c7dab16554a040f791" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__addr.html#ga048843ee9085f3c7dab16554a040f791">LNET_PID_ANY</a>&nbsp;&nbsp;&nbsp;((<a class="el" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd">lnet_pid_t</a>) -1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">wildcard PID that matches any lnet_pid_t <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga12d70f84773e980424d3361c6a2b2946"></a><!-- doxytag: member="lnet_addr::LNET_PID_RESERVED" ref="ga12d70f84773e980424d3361c6a2b2946" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PID_RESERVED</b>&nbsp;&nbsp;&nbsp;0xf0000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga419649526d652fb587ed39e554045384"></a><!-- doxytag: member="lnet_addr::LNET_PID_USERFLAG" ref="ga419649526d652fb587ed39e554045384" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PID_USERFLAG</b>&nbsp;&nbsp;&nbsp;0x80000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0186a9d5ab3efaf690ef00167353726b"></a><!-- doxytag: member="lnet_addr::LNET_PID_LUSTRE" ref="ga0186a9d5ab3efaf690ef00167353726b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PID_LUSTRE</b>&nbsp;&nbsp;&nbsp;12345</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0bfce48264dcc9fb285b7de03a853eb8"></a><!-- doxytag: member="lnet_addr::LNET_TIME_FOREVER" ref="ga0bfce48264dcc9fb285b7de03a853eb8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_TIME_FOREVER</b>&nbsp;&nbsp;&nbsp;(-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga210bb74150029efca18406f77a9fc486"></a><!-- doxytag: member="lnet_addr::WIRE_ATTR" ref="ga210bb74150029efca18406f77a9fc486" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>WIRE_ATTR</b>&nbsp;&nbsp;&nbsp;__attribute__((<a class="el" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb">packed</a>))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39393e7e434c1371ab95cde509a18d8a"></a><!-- doxytag: member="lnet_addr::LNET_PROTO_IB_MAGIC" ref="ga39393e7e434c1371ab95cde509a18d8a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PROTO_IB_MAGIC</b>&nbsp;&nbsp;&nbsp;0x0be91b91</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3ba10ac2c78503ef04d64e1e57460d98"></a><!-- doxytag: member="lnet_addr::LNET_PROTO_GNI_MAGIC" ref="ga3ba10ac2c78503ef04d64e1e57460d98" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PROTO_GNI_MAGIC</b>&nbsp;&nbsp;&nbsp;0xb00fbabe</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3935d219837f3b1b43416bd245890d46"></a><!-- doxytag: member="lnet_addr::LNET_PROTO_TCP_MAGIC" ref="ga3935d219837f3b1b43416bd245890d46" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PROTO_TCP_MAGIC</b>&nbsp;&nbsp;&nbsp;0xeebc0ded</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac3d7b6feded8c0583b42e87a2f59dfd"></a><!-- doxytag: member="lnet_addr::LNET_PROTO_ACCEPTOR_MAGIC" ref="gaac3d7b6feded8c0583b42e87a2f59dfd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PROTO_ACCEPTOR_MAGIC</b>&nbsp;&nbsp;&nbsp;0xacce7100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04f3c19ce453e28acb1208e36113a7c4"></a><!-- doxytag: member="lnet_addr::LNET_PROTO_PING_MAGIC" ref="ga04f3c19ce453e28acb1208e36113a7c4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PROTO_PING_MAGIC</b>&nbsp;&nbsp;&nbsp;0x70696E67</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadced53b5b75c57b0398a87a61626eefb"></a><!-- doxytag: member="lnet_addr::LNET_PROTO_MAGIC" ref="gadced53b5b75c57b0398a87a61626eefb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PROTO_MAGIC</b>&nbsp;&nbsp;&nbsp;0x45726963</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga290c43f2c32cdedb5dab2816ceee5d46"></a><!-- doxytag: member="lnet_addr::LNET_PROTO_TCP_VERSION_MAJOR" ref="ga290c43f2c32cdedb5dab2816ceee5d46" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PROTO_TCP_VERSION_MAJOR</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga19f2ce77a9014c159033b99ce540c406"></a><!-- doxytag: member="lnet_addr::LNET_PROTO_TCP_VERSION_MINOR" ref="ga19f2ce77a9014c159033b99ce540c406" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PROTO_TCP_VERSION_MINOR</b>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71275d5906da3f7505d0a37f8f1cc323"></a><!-- doxytag: member="lnet_addr::LNET_PROTO_ACCEPTOR_VERSION" ref="ga71275d5906da3f7505d0a37f8f1cc323" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_PROTO_ACCEPTOR_VERSION</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9cb9409b79b8f8d0780d66bfde2ef86d"></a><!-- doxytag: member="lnet_addr::LNET_NI_STATUS_UP" ref="ga9cb9409b79b8f8d0780d66bfde2ef86d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_NI_STATUS_UP</b>&nbsp;&nbsp;&nbsp;0x15aac0de</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b4bd2332097cf0b7acf54626dc62fc2"></a><!-- doxytag: member="lnet_addr::LNET_NI_STATUS_DOWN" ref="ga1b4bd2332097cf0b7acf54626dc62fc2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_NI_STATUS_DOWN</b>&nbsp;&nbsp;&nbsp;0xdeadface</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c506ef63c56ea11aea2ee183f4ccfc6"></a><!-- doxytag: member="lnet_addr::LNET_NI_STATUS_INVALID" ref="ga1c506ef63c56ea11aea2ee183f4ccfc6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_NI_STATUS_INVALID</b>&nbsp;&nbsp;&nbsp;0x00000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga068d1aa322aa37d85a4875c9909d2197"></a><!-- doxytag: member="lnet_addr::LNET_MAX_INTERFACES" ref="ga068d1aa322aa37d85a4875c9909d2197" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_MAX_INTERFACES</b>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9f9091866aa1abbba5218deab5c8d85"></a><!-- doxytag: member="lnet_addr::LNET_WIRE_HANDLE_COOKIE_NONE" ref="gae9f9091866aa1abbba5218deab5c8d85" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_WIRE_HANDLE_COOKIE_NONE</b>&nbsp;&nbsp;&nbsp;(-1)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef __u64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Address of an end-point in an LNet <a class="el" href="structnetwork.html">network</a>.  <a href="#ga0d47ef2c4f1002efbdd050547f80a312"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef __u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd">lnet_pid_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID of a process in a node.  <a href="#gafa13bf627f3dbcdec22141de051a61cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafae0b9b9c0f424e6e76ef3321041ffc0"></a><!-- doxytag: member="lnet_addr::lnet_ack_t" ref="gafae0b9b9c0f424e6e76ef3321041ffc0" args="" -->
typedef struct <a class="el" href="structlnet__ack.html">lnet_ack</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_ack_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab26755f44cde8ece0b52cbf74dfc80d1"></a><!-- doxytag: member="lnet_addr::lnet_put_t" ref="gab26755f44cde8ece0b52cbf74dfc80d1" args="" -->
typedef struct <a class="el" href="structlnet__put.html">lnet_put</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_put_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga77fe5fb7aa1936e584eac9d36a9ff9ba"></a><!-- doxytag: member="lnet_addr::lnet_get_t" ref="ga77fe5fb7aa1936e584eac9d36a9ff9ba" args="" -->
typedef struct <a class="el" href="structlnet__get.html">lnet_get</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_get_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa69a9427be339387e886a09e37d29a37"></a><!-- doxytag: member="lnet_addr::lnet_reply_t" ref="gaa69a9427be339387e886a09e37d29a37" args="" -->
typedef struct <a class="el" href="structlnet__reply.html">lnet_reply</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_reply_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed7ea3579ba6e43186b27161c4e7af85"></a><!-- doxytag: member="lnet_addr::lnet_hello_t" ref="gaed7ea3579ba6e43186b27161c4e7af85" args="" -->
typedef struct <a class="el" href="structlnet__hello.html">lnet_hello</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_hello_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga18940be0ca7de18d4c94c7359dd52271"></a><!-- doxytag: member="lnet_addr::lnet_counters_t" ref="ga18940be0ca7de18d4c94c7359dd52271" args="" -->
typedef struct <a class="el" href="structlnet__counters.html">lnet_counters</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_counters_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf2e823a2bab567529ec77972cb1eaf4"></a><!-- doxytag: member="lnet_addr::lnet_handle_eq_t" ref="gadf2e823a2bab567529ec77972cb1eaf4" args="" -->
typedef <a class="el" href="structlnet__handle__any__t.html">lnet_handle_any_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_handle_eq_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a90fa7406296766505f5a34e670cfd6"></a><!-- doxytag: member="lnet_addr::lnet_handle_md_t" ref="ga7a90fa7406296766505f5a34e670cfd6" args="" -->
typedef <a class="el" href="structlnet__handle__any__t.html">lnet_handle_any_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_handle_md_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga42b7c4fceab3738099fdef1db7c2dc58"></a><!-- doxytag: member="lnet_addr::lnet_handle_me_t" ref="ga42b7c4fceab3738099fdef1db7c2dc58" args="" -->
typedef <a class="el" href="structlnet__handle__any__t.html">lnet_handle_any_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_handle_me_t</b></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_msg_type_t</b> { <br/>
&nbsp;&nbsp;<b>LNET_MSG_ACK</b> =  0, 
<b>LNET_MSG_PUT</b>, 
<b>LNET_MSG_GET</b>, 
<b>LNET_MSG_REPLY</b>, 
<br/>
&nbsp;&nbsp;<b>LNET_MSG_HELLO</b>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__addr.html#ga8025f01534cbe778aac39b4f2bae2438">LNetGetId</a> (unsigned int index, <a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a> *id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the <a class="el" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> ID of LNet interface at <em>index</em>.  <a href="#ga8025f01534cbe778aac39b4f2bae2438"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__addr.html#gae4aa770a0f3018754c65958832d70a33">LNetDist</a> (<a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> nid, <a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> *srcnid, __u32 *order)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate distance to node at <em>dstnid</em>.  <a href="#gae4aa770a0f3018754c65958832d70a33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad7d53c90761c53b4634673ce6eb0ed5a"></a><!-- doxytag: member="lnet_addr::LNetSnprintHandle" ref="gad7d53c90761c53b4634673ce6eb0ed5a" args="(char *str, int str_len, lnet_handle_any_t handle)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__addr.html#gad7d53c90761c53b4634673ce6eb0ed5a">LNetSnprintHandle</a> (char *str, int str_len, <a class="el" href="structlnet__handle__any__t.html">lnet_handle_any_t</a> handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a string representation of handle <em>h</em> into buffer <em>str</em> of <em>len</em> bytes. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Addressing scheme and basic data types of LNet. </p>
<p>The LNet API is memory-oriented, so LNet must be able to address not only end-points but also memory region within a process address space. An <a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> addresses an end-point. An <a class="el" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd" title="ID of a process in a node.">lnet_pid_t</a> identifies a process in a node. A portal represents an opening in the address space of a process. Match bits is criteria to identify a region of memory inside a portal, and offset specifies an offset within the memory region.</p>
<p>LNet creates a table of portals for each process during initialization. This table has MAX_PORTALS entries and its size can't be dynamically changed. A portal stays empty until the owning process starts to add memory regions to it. A portal is sometimes called an index because it's an entry in the portals table of a process.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal.">LNetMEAttach</a> </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga9b82f6f47b45c5a95f7475c3f79ca218"></a><!-- doxytag: member="types.h::LNET_RESERVED_PORTAL" ref="ga9b82f6f47b45c5a95f7475c3f79ca218" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_RESERVED_PORTAL&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Portal reserved for LNet's own use. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="lustre__idl_8h_source.html">lustre/include/lustre/lustre_idl.h</a> for Lustre portal assignments. </dd></dl>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00052">52</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga0d47ef2c4f1002efbdd050547f80a312"></a><!-- doxytag: member="types.h::lnet_nid_t" ref="ga0d47ef2c4f1002efbdd050547f80a312" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __u64 <a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Address of an end-point in an LNet <a class="el" href="structnetwork.html">network</a>. </p>
<p>A node can have multiple end-points and hence multiple addresses. An LNet <a class="el" href="structnetwork.html">network</a> can be a simple <a class="el" href="structnetwork.html">network</a> (e.g. tcp0) or a <a class="el" href="structnetwork.html">network</a> of LNet networks connected by LNet routers. Therefore an end-point address has two parts: <a class="el" href="structnetwork.html">network</a> ID, and address within a <a class="el" href="structnetwork.html">network</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>LNET_NIDNET, LNET_NIDADDR, and LNET_MKNID. </dd></dl>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00064">64</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafa13bf627f3dbcdec22141de051a61cd"></a><!-- doxytag: member="types.h::lnet_pid_t" ref="gafa13bf627f3dbcdec22141de051a61cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __u32 <a class="el" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd">lnet_pid_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ID of a process in a node. </p>
<p>Shortened as PID to distinguish from <a class="el" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>, the global process ID. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00069">69</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae4aa770a0f3018754c65958832d70a33"></a><!-- doxytag: member="api.h::LNetDist" ref="gae4aa770a0f3018754c65958832d70a33" args="(lnet_nid_t nid, lnet_nid_t *srcnid, __u32 *order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetDist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a>&nbsp;</td>
          <td class="paramname"> <em>dstnid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> *&nbsp;</td>
          <td class="paramname"> <em>srcnidp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32 *&nbsp;</td>
          <td class="paramname"> <em>orderp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate distance to node at <em>dstnid</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dstnid</em>&nbsp;</td><td>Target NID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcnidp</em>&nbsp;</td><td>If not NULL, NID of the local interface to reach <em>dstnid</em> is saved here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderp</em>&nbsp;</td><td>If not NULL, order of the route to reach <em>dstnid</em> is saved here.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>If <em>dstnid</em> belongs to a local interface, and reserved option local_nid_dist_zero is set, which is the default. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>positives</em>&nbsp;</td><td>Distance to target NID, i.e. number of hops plus one. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EHOSTUNREACH</em>&nbsp;</td><td>If <em>dstnid</em> is not reachable. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-move_8c_source.html#l02460">2460</a> of file <a class="el" href="lib-move_8c_source.html">lib-move.c</a>.</p>

<p>Referenced by <a class="el" href="api-ni_8c_source.html#l01908">LNetCtl()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02461"></a>02461 {
<a name="l02462"></a>02462         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *e;
<a name="l02463"></a>02463         <span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a>          *ni;
<a name="l02464"></a>02464         <a class="code" href="structlnet__remotenet__t.html">lnet_remotenet_t</a>        *rnet;
<a name="l02465"></a>02465         __u32                   dstnet = LNET_NIDNET(dstnid);
<a name="l02466"></a>02466         <span class="keywordtype">int</span>                     hops;
<a name="l02467"></a>02467         <span class="keywordtype">int</span>                     cpt;
<a name="l02468"></a>02468         __u32                   order = 2;
<a name="l02469"></a>02469         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *rn_list;
<a name="l02470"></a>02470 
<a name="l02471"></a>02471         <span class="comment">/* if !local_nid_dist_zero, I don&apos;t return a distance of 0 ever</span>
<a name="l02472"></a>02472 <span class="comment">         * (when lustre sees a distance of 0, it substitutes 0@lo), so I</span>
<a name="l02473"></a>02473 <span class="comment">         * keep order 0 free for 0@lo and order 1 free for a local NID</span>
<a name="l02474"></a>02474 <span class="comment">         * match */</span>
<a name="l02475"></a>02475 
<a name="l02476"></a>02476         LASSERT (the_lnet.ln_refcount &gt; 0);
<a name="l02477"></a>02477 
<a name="l02478"></a>02478         cpt = lnet_net_lock_current();
<a name="l02479"></a>02479 
<a name="l02480"></a>02480         list_for_each(e, &amp;the_lnet.ln_nis) {
<a name="l02481"></a>02481                 ni = list_entry(e, <a class="code" href="structlnet__ni.html">lnet_ni_t</a>, ni_list);
<a name="l02482"></a>02482 
<a name="l02483"></a>02483                 <span class="keywordflow">if</span> (ni-&gt;ni_nid == dstnid) {
<a name="l02484"></a>02484                         <span class="keywordflow">if</span> (srcnidp != NULL)
<a name="l02485"></a>02485                                 *srcnidp = dstnid;
<a name="l02486"></a>02486                         <span class="keywordflow">if</span> (orderp != NULL) {
<a name="l02487"></a>02487                                 <span class="keywordflow">if</span> (LNET_NETTYP(LNET_NIDNET(dstnid)) == LOLND)
<a name="l02488"></a>02488                                         *orderp = 0;
<a name="l02489"></a>02489                                 <span class="keywordflow">else</span>
<a name="l02490"></a>02490                                         *orderp = 1;
<a name="l02491"></a>02491                         }
<a name="l02492"></a>02492                         lnet_net_unlock(cpt);
<a name="l02493"></a>02493 
<a name="l02494"></a>02494                         <span class="keywordflow">return</span> local_nid_dist_zero ? 0 : 1;
<a name="l02495"></a>02495                 }
<a name="l02496"></a>02496 
<a name="l02497"></a>02497                 <span class="keywordflow">if</span> (LNET_NIDNET(ni-&gt;ni_nid) == dstnet) {
<a name="l02498"></a>02498                         <span class="keywordflow">if</span> (srcnidp != NULL)
<a name="l02499"></a>02499                                 *srcnidp = ni-&gt;ni_nid;
<a name="l02500"></a>02500                         <span class="keywordflow">if</span> (orderp != NULL)
<a name="l02501"></a>02501                                 *orderp = order;
<a name="l02502"></a>02502                         lnet_net_unlock(cpt);
<a name="l02503"></a>02503                         <span class="keywordflow">return</span> 1;
<a name="l02504"></a>02504                 }
<a name="l02505"></a>02505 
<a name="l02506"></a>02506                 order++;
<a name="l02507"></a>02507         }
<a name="l02508"></a>02508 
<a name="l02509"></a>02509         rn_list = lnet_net2rnethash(dstnet);
<a name="l02510"></a>02510         list_for_each(e, rn_list) {
<a name="l02511"></a>02511                 rnet = list_entry(e, <a class="code" href="structlnet__remotenet__t.html">lnet_remotenet_t</a>, lrn_list);
<a name="l02512"></a>02512 
<a name="l02513"></a>02513                 <span class="keywordflow">if</span> (rnet-&gt;lrn_net == dstnet) {
<a name="l02514"></a>02514                         <a class="code" href="structlnet__route__t.html">lnet_route_t</a> *route;
<a name="l02515"></a>02515                         <a class="code" href="structlnet__route__t.html">lnet_route_t</a> *shortest = NULL;
<a name="l02516"></a>02516                         __u32 shortest_hops = LNET_UNDEFINED_HOPS;
<a name="l02517"></a>02517                         __u32 route_hops;
<a name="l02518"></a>02518 
<a name="l02519"></a>02519                         LASSERT(!list_empty(&amp;rnet-&gt;lrn_routes));
<a name="l02520"></a>02520 
<a name="l02521"></a>02521                         list_for_each_entry(route, &amp;rnet-&gt;lrn_routes,
<a name="l02522"></a>02522                                             lr_list) {
<a name="l02523"></a>02523                                 route_hops = route-&gt;lr_hops;
<a name="l02524"></a>02524                                 <span class="keywordflow">if</span> (route_hops == LNET_UNDEFINED_HOPS)
<a name="l02525"></a>02525                                         route_hops = 1;
<a name="l02526"></a>02526                                 <span class="keywordflow">if</span> (shortest == NULL ||
<a name="l02527"></a>02527                                     route_hops &lt; shortest_hops) {
<a name="l02528"></a>02528                                         shortest = route;
<a name="l02529"></a>02529                                         shortest_hops = route_hops;
<a name="l02530"></a>02530                                 }
<a name="l02531"></a>02531                         }
<a name="l02532"></a>02532 
<a name="l02533"></a>02533                         LASSERT(shortest != NULL);
<a name="l02534"></a>02534                         hops = shortest_hops;
<a name="l02535"></a>02535                         <span class="keywordflow">if</span> (srcnidp != NULL)
<a name="l02536"></a>02536                                 *srcnidp = shortest-&gt;lr_gateway-&gt;lp_ni-&gt;ni_nid;
<a name="l02537"></a>02537                         <span class="keywordflow">if</span> (orderp != NULL)
<a name="l02538"></a>02538                                 *orderp = order;
<a name="l02539"></a>02539                         lnet_net_unlock(cpt);
<a name="l02540"></a>02540                         <span class="keywordflow">return</span> hops + 1;
<a name="l02541"></a>02541                 }
<a name="l02542"></a>02542                 order++;
<a name="l02543"></a>02543         }
<a name="l02544"></a>02544 
<a name="l02545"></a>02545         lnet_net_unlock(cpt);
<a name="l02546"></a>02546         <span class="keywordflow">return</span> -EHOSTUNREACH;
<a name="l02547"></a>02547 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lnet__addr_gae4aa770a0f3018754c65958832d70a33_icgraph.png" border="0" usemap="#group__lnet__addr_gae4aa770a0f3018754c65958832d70a33_icgraph_map" alt=""></div>
<map name="group__lnet__addr_gae4aa770a0f3018754c65958832d70a33_icgraph_map" id="group__lnet__addr_gae4aa770a0f3018754c65958832d70a33_icgraph">
<area shape="rect" id="node3" href="group__lnet__misc.html#ga4feb5dc040fabdac2a7bd61ee5b2aa64" title="LNet ioctl handler." alt="" coords="140,5,215,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga8025f01534cbe778aac39b4f2bae2438"></a><!-- doxytag: member="api.h::LNetGetId" ref="ga8025f01534cbe778aac39b4f2bae2438" args="(unsigned int index, lnet_process_id_t *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetGetId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a> *&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the <a class="el" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> ID of LNet interface at <em>index</em>. </p>
<p>Note that all interfaces share a same PID, as requested by <a class="el" href="group__lnet__init__fini.html#gac11b9424bc9ddaa74eb75eb1f9bbbb3d" title="Set LNet PID and start LNet interfaces, routing, and forwarding.">LNetNIInit()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the interface to look up. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>On successful return, this location will hold the <a class="el" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> ID of the interface.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>If an interface exists at <em>index</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If no interface has been found. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="api-ni_8c_source.html#l02129">2129</a> of file <a class="el" href="api-ni_8c_source.html">api-ni.c</a>.</p>

<p>Referenced by <a class="el" href="api-ni_8c_source.html#l01908">LNetCtl()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02130"></a>02130 {
<a name="l02131"></a>02131         <span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a>   *ni;
<a name="l02132"></a>02132         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp;
<a name="l02133"></a>02133         <span class="keywordtype">int</span>               cpt;
<a name="l02134"></a>02134         <span class="keywordtype">int</span>               rc = -ENOENT;
<a name="l02135"></a>02135 
<a name="l02136"></a>02136         LASSERT(the_lnet.ln_refcount &gt; 0);
<a name="l02137"></a>02137 
<a name="l02138"></a>02138         cpt = lnet_net_lock_current();
<a name="l02139"></a>02139 
<a name="l02140"></a>02140         list_for_each(tmp, &amp;the_lnet.ln_nis) {
<a name="l02141"></a>02141                 <span class="keywordflow">if</span> (index-- != 0)
<a name="l02142"></a>02142                         <span class="keywordflow">continue</span>;
<a name="l02143"></a>02143 
<a name="l02144"></a>02144                 ni = list_entry(tmp, <a class="code" href="structlnet__ni.html">lnet_ni_t</a>, ni_list);
<a name="l02145"></a>02145 
<a name="l02146"></a>02146                 <span class="keywordtype">id</span>-&gt;nid = ni-&gt;ni_nid;
<a name="l02147"></a>02147                 <span class="keywordtype">id</span>-&gt;pid = the_lnet.ln_pid;
<a name="l02148"></a>02148                 rc = 0;
<a name="l02149"></a>02149                 <span class="keywordflow">break</span>;
<a name="l02150"></a>02150         }
<a name="l02151"></a>02151 
<a name="l02152"></a>02152         lnet_net_unlock(cpt);
<a name="l02153"></a>02153         <span class="keywordflow">return</span> rc;
<a name="l02154"></a>02154 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lnet__addr_ga8025f01534cbe778aac39b4f2bae2438_icgraph.png" border="0" usemap="#group__lnet__addr_ga8025f01534cbe778aac39b4f2bae2438_icgraph_map" alt=""></div>
<map name="group__lnet__addr_ga8025f01534cbe778aac39b4f2bae2438_icgraph_map" id="group__lnet__addr_ga8025f01534cbe778aac39b4f2bae2438_icgraph">
<area shape="rect" id="node3" href="group__lnet__misc.html#ga4feb5dc040fabdac2a7bd61ee5b2aa64" title="LNet ioctl handler." alt="" coords="151,5,225,35"/></map>
</div>
</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:47 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
