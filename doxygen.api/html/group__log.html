<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: log</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>log</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplain__handle__data.html">plain_handle_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcat__handle__data.html">cat_handle_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllog__process__data.html">llog_process_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllog__process__cat__data.html">llog_process_cat_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllog__operations.html">llog_operations</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllog__handle.html">llog_handle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllog__ctxt.html">llog_ctxt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllog__cfg__rec.html">llog_cfg_rec</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74e6cb03b51a4cf136c43118fe7b8e94"></a><!-- doxytag: member="log::LOG_NAME_LIMIT" ref="ga74e6cb03b51a4cf136c43118fe7b8e94" args="(logname, name)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LOG_NAME_LIMIT</b>(logname, name)&nbsp;&nbsp;&nbsp;snprintf(logname, sizeof(logname), &quot;LOGS/%s&quot;, name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga11a3e78a53c53d8166c2ce7b39312626"></a><!-- doxytag: member="log::LLOG_EEMPTY" ref="ga11a3e78a53c53d8166c2ce7b39312626" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLOG_EEMPTY</b>&nbsp;&nbsp;&nbsp;4711</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35da509d8eee29b3b11292e4e81d1c2f"></a><!-- doxytag: member="log::LLOG_FLAG_NODEAMON" ref="ga35da509d8eee29b3b11292e4e81d1c2f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLOG_FLAG_NODEAMON</b>&nbsp;&nbsp;&nbsp;0x0001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9957e14aee1418edfa389cb625de57a7"></a><!-- doxytag: member="log::LLOG_CTXT_FLAG_UNINITIALIZED" ref="ga9957e14aee1418edfa389cb625de57a7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLOG_CTXT_FLAG_UNINITIALIZED</b>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad66792d5e5504a0a7e824ef5c67330d9"></a><!-- doxytag: member="log::LLOG_CTXT_FLAG_STOP" ref="gad66792d5e5504a0a7e824ef5c67330d9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLOG_CTXT_FLAG_STOP</b>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4fb64387d4343fd5387485fc0f600cb0"></a><!-- doxytag: member="log::LLOG_CTXT_FLAG_NORMAL_FID" ref="ga4fb64387d4343fd5387485fc0f600cb0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLOG_CTXT_FLAG_NORMAL_FID</b>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacdf0b47ad08d82835a118113f7472129"></a><!-- doxytag: member="log::LLOG_PROC_BREAK" ref="gacdf0b47ad08d82835a118113f7472129" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLOG_PROC_BREAK</b>&nbsp;&nbsp;&nbsp;0x0001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1504202bf86ed271947570109ba14063"></a><!-- doxytag: member="log::LLOG_DEL_RECORD" ref="ga1504202bf86ed271947570109ba14063" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLOG_DEL_RECORD</b>&nbsp;&nbsp;&nbsp;0x0002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga537dcd78aa2fe2715b25f811bd5b4484"></a><!-- doxytag: member="log::LLOG_DEL_PLAIN" ref="ga537dcd78aa2fe2715b25f811bd5b4484" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLOG_DEL_PLAIN</b>&nbsp;&nbsp;&nbsp;0x0003</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_open_param</b> { <b>LLOG_OPEN_EXISTS</b> =  0x0000, 
<b>LLOG_OPEN_NEW</b> =  0x0001
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>LLOG_NEXT_IDX</b> =  -1, 
<b>LLOG_HEADER_IDX</b> =  0
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga546fd23355c24d4ee2a5a668423c0156"></a><!-- doxytag: member="log::llog_init_handle" ref="ga546fd23355c24d4ee2a5a668423c0156" args="(const struct lu_env *env, struct llog_handle *handle, int flags, struct obd_uuid *uuid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_init_handle</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *handle, int flags, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29d5501b6e8f8d880d210907b6ef8f68"></a><!-- doxytag: member="log::llog_copy_handler" ref="ga29d5501b6e8f8d880d210907b6ef8f68" args="(const struct lu_env *env, struct llog_handle *llh, struct llog_rec_hdr *rec, void *data)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_copy_handler</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *llh, struct <a class="el" href="structllog__rec__hdr.html">llog_rec_hdr</a> *rec, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80616f32350d097166d698292330b6b2"></a><!-- doxytag: member="log::llog_process" ref="ga80616f32350d097166d698292330b6b2" args="(const struct lu_env *env, struct llog_handle *loghandle, llog_cb_t cb, void *data, void *catdata)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_process</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *loghandle, llog_cb_t cb, void *data, void *catdata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0d3652ea7d74d6ac5ee335584a33d72"></a><!-- doxytag: member="log::llog_process_or_fork" ref="gaf0d3652ea7d74d6ac5ee335584a33d72" args="(const struct lu_env *env, struct llog_handle *loghandle, llog_cb_t cb, void *data, void *catdata, bool fork)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_process_or_fork</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *loghandle, llog_cb_t cb, void *data, void *catdata, bool fork)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97008e41a5f1114f3b26e8718c8e73de"></a><!-- doxytag: member="log::llog_reverse_process" ref="ga97008e41a5f1114f3b26e8718c8e73de" args="(const struct lu_env *env, struct llog_handle *loghandle, llog_cb_t cb, void *data, void *catdata)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_reverse_process</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *loghandle, llog_cb_t cb, void *data, void *catdata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae7cdad9d32ae44d0ae5428b11741368d"></a><!-- doxytag: member="log::llog_cancel_rec" ref="gae7cdad9d32ae44d0ae5428b11741368d" args="(const struct lu_env *env, struct llog_handle *loghandle, int index)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cancel_rec</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *loghandle, int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5358b955b7d709ed7f5416022472539"></a><!-- doxytag: member="log::llog_open" ref="gae5358b955b7d709ed7f5416022472539" args="(const struct lu_env *env, struct llog_ctxt *ctxt, struct llog_handle **lgh, struct llog_logid *logid, char *name, enum llog_open_param open_param)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_open</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, struct <a class="el" href="structllog__handle.html">llog_handle</a> **lgh, struct <a class="el" href="structllog__logid.html">llog_logid</a> *logid, char *name, enum llog_open_param open_param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9487d7128a3cf457ff2a9181ce152b74"></a><!-- doxytag: member="log::llog_close" ref="ga9487d7128a3cf457ff2a9181ce152b74" args="(const struct lu_env *env, struct llog_handle *cathandle)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_close</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cathandle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#ga313d57d22838eb9027b38ee417701af3">llog_is_empty</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to get the llog size in records.  <a href="#ga313d57d22838eb9027b38ee417701af3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2abc0dd1d2e6e6e1fca19069346475fa"></a><!-- doxytag: member="log::llog_backup" ref="ga2abc0dd1d2e6e6e1fca19069346475fa" args="(const struct lu_env *env, struct obd_device *obd, struct llog_ctxt *ctxt, struct llog_ctxt *bak_ctxt, char *name, char *backup)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_backup</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structobd__device.html">obd_device</a> *obd, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *bak_ctxt, char *name, char *backup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3dff118eacffed836e2f50775e042350"></a><!-- doxytag: member="log::llog_read_header" ref="ga3dff118eacffed836e2f50775e042350" args="(const struct lu_env *env, struct llog_handle *handle, const struct obd_uuid *uuid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_read_header</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *handle, const struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae74cc5ecdf5ceda1159ad495cef0113"></a><!-- doxytag: member="log::llog_size" ref="gaae74cc5ecdf5ceda1159ad495cef0113" args="(const struct lu_env *env, struct llog_handle *llh)" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_size</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *llh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8b069ab8307aa0e5c401f0d0c3a2f43d"></a><!-- doxytag: member="log::llog_cat_close" ref="ga8b069ab8307aa0e5c401f0d0c3a2f43d" args="(const struct lu_env *env, struct llog_handle *cathandle)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cat_close</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cathandle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab876e211f585e8c75174f6b974e658c6"></a><!-- doxytag: member="log::llog_cat_add_rec" ref="gab876e211f585e8c75174f6b974e658c6" args="(const struct lu_env *env, struct llog_handle *cathandle, struct llog_rec_hdr *rec, struct llog_cookie *reccookie, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cat_add_rec</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cathandle, struct <a class="el" href="structllog__rec__hdr.html">llog_rec_hdr</a> *rec, struct <a class="el" href="structllog__cookie.html">llog_cookie</a> *reccookie, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7eff35965cc93d0bc953eb542a1d6a28"></a><!-- doxytag: member="log::llog_cat_declare_add_rec" ref="ga7eff35965cc93d0bc953eb542a1d6a28" args="(const struct lu_env *env, struct llog_handle *cathandle, struct llog_rec_hdr *rec, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cat_declare_add_rec</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cathandle, struct <a class="el" href="structllog__rec__hdr.html">llog_rec_hdr</a> *rec, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29a5a9134a1ef39c0042541245851ec6"></a><!-- doxytag: member="log::llog_cat_add" ref="ga29a5a9134a1ef39c0042541245851ec6" args="(const struct lu_env *env, struct llog_handle *cathandle, struct llog_rec_hdr *rec, struct llog_cookie *reccookie)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cat_add</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cathandle, struct <a class="el" href="structllog__rec__hdr.html">llog_rec_hdr</a> *rec, struct <a class="el" href="structllog__cookie.html">llog_cookie</a> *reccookie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c7162acb072c7ebd237441cab38a622"></a><!-- doxytag: member="log::llog_cat_cancel_records" ref="ga0c7162acb072c7ebd237441cab38a622" args="(const struct lu_env *env, struct llog_handle *cathandle, int count, struct llog_cookie *cookies)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cat_cancel_records</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cathandle, int count, struct <a class="el" href="structllog__cookie.html">llog_cookie</a> *cookies)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3a958539869b4156163d2c006bd92f5a"></a><!-- doxytag: member="log::llog_cat_process_or_fork" ref="ga3a958539869b4156163d2c006bd92f5a" args="(const struct lu_env *env, struct llog_handle *cat_llh, llog_cb_t cat_cb, llog_cb_t cb, void *data, int startcat, int startidx, bool fork)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cat_process_or_fork</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cat_llh, llog_cb_t cat_cb, llog_cb_t cb, void *data, int startcat, int startidx, bool fork)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga466f538de595963c4d02460408b4ca01"></a><!-- doxytag: member="log::llog_cat_process" ref="ga466f538de595963c4d02460408b4ca01" args="(const struct lu_env *env, struct llog_handle *cat_llh, llog_cb_t cb, void *data, int startcat, int startidx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cat_process</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cat_llh, llog_cb_t cb, void *data, int startcat, int startidx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27b76b93ed632e0efcdeb31e0fac56a3"></a><!-- doxytag: member="log::llog_cat_size" ref="ga27b76b93ed632e0efcdeb31e0fac56a3" args="(const struct lu_env *env, struct llog_handle *cat_llh)" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cat_size</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cat_llh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8fed8fb641b91d077e635dfdc6b8446c"></a><!-- doxytag: member="log::llog_cat_reverse_process" ref="ga8fed8fb641b91d077e635dfdc6b8446c" args="(const struct lu_env *env, struct llog_handle *cat_llh, llog_cb_t cb, void *data)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cat_reverse_process</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *cat_llh, llog_cb_t cb, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaadc4cac8bd450c264283656f9ef4fc78"></a><!-- doxytag: member="log::llog_setup" ref="gaadc4cac8bd450c264283656f9ef4fc78" args="(const struct lu_env *env, struct obd_device *obd, struct obd_llog_group *olg, int index, struct obd_device *disk_obd, struct llog_operations *op)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_setup</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structobd__device.html">obd_device</a> *obd, struct <a class="el" href="structobd__llog__group.html">obd_llog_group</a> *olg, int index, struct <a class="el" href="structobd__device.html">obd_device</a> *disk_obd, struct <a class="el" href="structllog__operations.html">llog_operations</a> *op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab112c9591fc2a2f0efcf70bc2954134f"></a><!-- doxytag: member="log::__llog_ctxt_put" ref="gab112c9591fc2a2f0efcf70bc2954134f" args="(const struct lu_env *env, struct llog_ctxt *ctxt)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>__llog_ctxt_put</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c27342dc9861167548b2e367677a394"></a><!-- doxytag: member="log::llog_cleanup" ref="ga2c27342dc9861167548b2e367677a394" args="(const struct lu_env *env, struct llog_ctxt *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cleanup</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga470133f89aab4b9f9047b2ab53d17de0"></a><!-- doxytag: member="log::llog_sync" ref="ga470133f89aab4b9f9047b2ab53d17de0" args="(struct llog_ctxt *ctxt, struct obd_export *exp, int flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_sync</b> (struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, struct <a class="el" href="structobd__export.html">obd_export</a> *exp, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd31f6ab5afd67b879a840de8c6600da"></a><!-- doxytag: member="log::llog_cancel" ref="gacd31f6ab5afd67b879a840de8c6600da" args="(const struct lu_env *env, struct llog_ctxt *ctxt, struct llog_cookie *cookies, int flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_cancel</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, struct <a class="el" href="structllog__cookie.html">llog_cookie</a> *cookies, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf09a118e062a45bcf3f7b4382b26658c"></a><!-- doxytag: member="log::llog_ioctl" ref="gaf09a118e062a45bcf3f7b4382b26658c" args="(const struct lu_env *env, struct llog_ctxt *ctxt, int cmd, struct obd_ioctl_data *data)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_ioctl</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, int cmd, struct <a class="el" href="structobd__ioctl__data.html">obd_ioctl_data</a> *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ffba3225716e68236cb031d76182315"></a><!-- doxytag: member="log::llog_catalog_list" ref="ga1ffba3225716e68236cb031d76182315" args="(const struct lu_env *env, struct dt_device *d, int count, struct obd_ioctl_data *data, const struct lu_fid *fid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_catalog_list</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *d, int count, struct <a class="el" href="structobd__ioctl__data.html">obd_ioctl_data</a> *data, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9a6174ab2a5e0b1262d0b7c851fabb1"></a><!-- doxytag: member="log::llog_initiator_connect" ref="gad9a6174ab2a5e0b1262d0b7c851fabb1" args="(struct llog_ctxt *ctxt)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_initiator_connect</b> (struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#gaf0dee2455ecbe5cbeeec044344224613">llog_osd_get_cat_list</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *d, int idx, int count, struct <a class="el" href="structllog__catid.html">llog_catid</a> *idarray, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the special file which contains the list of llog catalogs IDs.  <a href="#gaf0dee2455ecbe5cbeeec044344224613"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#ga4b308f3bee04638c301ba0bead3ad070">llog_osd_put_cat_list</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *d, int idx, int count, struct <a class="el" href="structllog__catid.html">llog_catid</a> *idarray, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the special file which contains the list of llog catalogs IDs.  <a href="#ga4b308f3bee04638c301ba0bead3ad070"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac148d3e66927a5ca148207c69ba4b8a5"></a><!-- doxytag: member="log::lustre_cfg_rec_new" ref="gac148d3e66927a5ca148207c69ba4b8a5" args="(int cmd, struct lustre_cfg_bufs *bufs)" -->
struct <a class="el" href="structllog__cfg__rec.html">llog_cfg_rec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_cfg_rec_new</b> (int cmd, struct <a class="el" href="structlustre__cfg__bufs.html">lustre_cfg_bufs</a> *bufs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadac76f066c96cf4ae43ccbce06593e21"></a><!-- doxytag: member="log::lustre_cfg_rec_free" ref="gadac76f066c96cf4ae43ccbce06593e21" args="(struct llog_cfg_rec *lcr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_cfg_rec_free</b> (struct <a class="el" href="structllog__cfg__rec.html">llog_cfg_rec</a> *lcr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#gab4498d20e447d4dbeaff34eb3b305d57">llog_exist</a> (struct <a class="el" href="structllog__handle.html">llog_handle</a> *loghandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">new llog API  <a href="#gab4498d20e447d4dbeaff34eb3b305d57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f29ac09d8ce9183650aa713038b2c92"></a><!-- doxytag: member="log::llog_declare_create" ref="ga4f29ac09d8ce9183650aa713038b2c92" args="(const struct lu_env *env, struct llog_handle *loghandle, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_declare_create</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *loghandle, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad1dcf7f6a3d54acd725f99455d849ca8"></a><!-- doxytag: member="log::llog_create" ref="gad1dcf7f6a3d54acd725f99455d849ca8" args="(const struct lu_env *env, struct llog_handle *handle, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_create</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *handle, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadac4383f18bef43704ff9b2403398263"></a><!-- doxytag: member="log::llog_trans_destroy" ref="gadac4383f18bef43704ff9b2403398263" args="(const struct lu_env *env, struct llog_handle *handle, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_trans_destroy</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *handle, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5fbc4e5a4154513556d4dedc7d23e486"></a><!-- doxytag: member="log::llog_destroy" ref="ga5fbc4e5a4154513556d4dedc7d23e486" args="(const struct lu_env *env, struct llog_handle *handle)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_destroy</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1db1cffd9f210c9f081370af6106a606"></a><!-- doxytag: member="log::llog_declare_write_rec" ref="ga1db1cffd9f210c9f081370af6106a606" args="(const struct lu_env *env, struct llog_handle *handle, struct llog_rec_hdr *rec, int idx, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_declare_write_rec</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *handle, struct <a class="el" href="structllog__rec__hdr.html">llog_rec_hdr</a> *rec, int idx, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38790001c86a4ad331c76a6e8698b6e9"></a><!-- doxytag: member="log::llog_write_rec" ref="ga38790001c86a4ad331c76a6e8698b6e9" args="(const struct lu_env *env, struct llog_handle *handle, struct llog_rec_hdr *rec, struct llog_cookie *logcookies, int idx, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_write_rec</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *handle, struct <a class="el" href="structllog__rec__hdr.html">llog_rec_hdr</a> *rec, struct <a class="el" href="structllog__cookie.html">llog_cookie</a> *logcookies, int idx, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace38c6753f06b86177bebbe0121fde90"></a><!-- doxytag: member="log::llog_add" ref="gace38c6753f06b86177bebbe0121fde90" args="(const struct lu_env *env, struct llog_handle *lgh, struct llog_rec_hdr *rec, struct llog_cookie *logcookies, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_add</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *lgh, struct <a class="el" href="structllog__rec__hdr.html">llog_rec_hdr</a> *rec, struct <a class="el" href="structllog__cookie.html">llog_cookie</a> *logcookies, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga682d7fd8bcbf72f370ee2aab71eadfa9"></a><!-- doxytag: member="log::llog_declare_add" ref="ga682d7fd8bcbf72f370ee2aab71eadfa9" args="(const struct lu_env *env, struct llog_handle *lgh, struct llog_rec_hdr *rec, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_declare_add</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *lgh, struct <a class="el" href="structllog__rec__hdr.html">llog_rec_hdr</a> *rec, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#gab379f30f30f88aebf9be8c61b7f55152">lustre_process_log</a> (struct super_block *sb, char *logname, struct <a class="el" href="structconfig__llog__instance.html">config_llog_instance</a> *cfg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a config log from the MGS and process it.  <a href="#gab379f30f30f88aebf9be8c61b7f55152"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae876fd8eccc7582b545d5e187e5b3e92"></a><!-- doxytag: member="log::lustre_end_log" ref="gae876fd8eccc7582b545d5e187e5b3e92" args="(struct super_block *sb, char *logname, struct config_llog_instance *cfg)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lustre_end_log</b> (struct super_block *sb, char *logname, struct <a class="el" href="structconfig__llog__instance.html">config_llog_instance</a> *cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#gae96db4e0338a67db6a75218a14d22b4f">llog_open_create</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, struct <a class="el" href="structllog__handle.html">llog_handle</a> **res, struct <a class="el" href="structllog__logid.html">llog_logid</a> *logid, char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to open llog or create it if doesn't exist.  <a href="#gae96db4e0338a67db6a75218a14d22b4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf5171710a6a625218951e36e3c7d3e01"></a><!-- doxytag: member="log::llog_erase" ref="gaf5171710a6a625218951e36e3c7d3e01" args="(const struct lu_env *env, struct llog_ctxt *ctxt, struct llog_logid *logid, char *name)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__log.html#gaf5171710a6a625218951e36e3c7d3e01">llog_erase</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, struct <a class="el" href="structllog__logid.html">llog_logid</a> *logid, char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to delete existent llog. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad1dd01ae4a118379d446d5afcbb261fa"></a><!-- doxytag: member="log::llog_write" ref="gad1dd01ae4a118379d446d5afcbb261fa" args="(const struct lu_env *env, struct llog_handle *loghandle, struct llog_rec_hdr *rec, int idx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_write</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structllog__handle.html">llog_handle</a> *loghandle, struct <a class="el" href="structllog__rec__hdr.html">llog_rec_hdr</a> *rec, int idx)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9fe78077b320f0957c7c7c3e8052aaaa"></a><!-- doxytag: member="log::llog_osd_ops" ref="ga9fe78077b320f0957c7c7c3e8052aaaa" args="" -->
struct <a class="el" href="structllog__operations.html">llog_operations</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_osd_ops</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf91e7b25f0a5c9ca6385440f60b7b375"></a><!-- doxytag: member="log::llog_common_cat_ops" ref="gaf91e7b25f0a5c9ca6385440f60b7b375" args="" -->
struct <a class="el" href="structllog__operations.html">llog_operations</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>llog_common_cat_ops</b></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gab4498d20e447d4dbeaff34eb3b305d57"></a><!-- doxytag: member="lustre_log.h::llog_exist" ref="gab4498d20e447d4dbeaff34eb3b305d57" args="(struct llog_handle *loghandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llog_exist </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structllog__handle.html">llog_handle</a> *&nbsp;</td>
          <td class="paramname"> <em>loghandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>new llog API </p>
<p>API functions: llog_open - open llog, may not exist llog_exist - check if llog exists llog_close - close opened llog, pair for open, frees <a class="el" href="structllog__handle.html">llog_handle</a> llog_declare_create - declare llog creation llog_create - create new llog on disk, need transaction handle llog_declare_write_rec - declaration of llog write llog_write_rec - write llog record on disk, need transaction handle llog_declare_add - declare llog catalog record addition llog_add - add llog record in catalog, need transaction handle </p>

<p>Definition at line <a class="el" href="llog_8c_source.html#l00799">799</a> of file <a class="el" href="llog_8c_source.html">llog.c</a>.</p>

<p>References <a class="el" href="structllog__operations.html#ada3ec98e78c44d6186c26adf91f807a6">llog_operations::lop_exist</a>.</p>

<p>Referenced by <a class="el" href="llog_8c_source.html#l00963">llog_open_create()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00800"></a>00800 {
<a name="l00801"></a>00801         <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a>  *lop;
<a name="l00802"></a>00802         <span class="keywordtype">int</span>                      rc;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         ENTRY;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         rc = llog_handle2ops(loghandle, &amp;lop);
<a name="l00807"></a>00807         <span class="keywordflow">if</span> (rc)
<a name="l00808"></a>00808                 RETURN(rc);
<a name="l00809"></a>00809         <span class="keywordflow">if</span> (lop-&gt;<a class="code" href="structllog__operations.html#ada3ec98e78c44d6186c26adf91f807a6" title="Opened llog may not exist and this must be checked where needed using the llog_exist()...">lop_exist</a> == NULL)
<a name="l00810"></a>00810                 RETURN(-EOPNOTSUPP);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812         rc = lop-&gt;<a class="code" href="structllog__operations.html#ada3ec98e78c44d6186c26adf91f807a6" title="Opened llog may not exist and this must be checked where needed using the llog_exist()...">lop_exist</a>(loghandle);
<a name="l00813"></a>00813         RETURN(rc);
<a name="l00814"></a>00814 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__log_gab4498d20e447d4dbeaff34eb3b305d57_icgraph.png" border="0" usemap="#group__log_gab4498d20e447d4dbeaff34eb3b305d57_icgraph_map" alt=""></div>
<map name="group__log_gab4498d20e447d4dbeaff34eb3b305d57_icgraph_map" id="group__log_gab4498d20e447d4dbeaff34eb3b305d57_icgraph">
<area shape="rect" id="node3" href="group__log.html#gae96db4e0338a67db6a75218a14d22b4f" title="Helper function to open llog or create it if doesn&#39;t exist." alt="" coords="140,5,276,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga313d57d22838eb9027b38ee417701af3"></a><!-- doxytag: member="lustre_log.h::llog_is_empty" ref="ga313d57d22838eb9027b38ee417701af3" args="(const struct lu_env *env, struct llog_ctxt *ctxt, char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llog_is_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to get the llog size in records. </p>
<p>It is used by MGS mostly to check that config llog exists and contains data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>llog context </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>llog name</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>if there are records in llog besides a header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>on error or llog without records </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="llog_8c_source.html#l01150">1150</a> of file <a class="el" href="llog_8c_source.html">llog.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01152"></a>01152 {
<a name="l01153"></a>01153         <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a>      *llh;
<a name="l01154"></a>01154         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01155"></a>01155 
<a name="l01156"></a>01156         rc = llog_open(env, ctxt, &amp;llh, NULL, name, LLOG_OPEN_EXISTS);
<a name="l01157"></a>01157         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01158"></a>01158                 <span class="keywordflow">if</span> (likely(rc == -ENOENT))
<a name="l01159"></a>01159                         rc = 0;
<a name="l01160"></a>01160                 GOTO(out, rc);
<a name="l01161"></a>01161         }
<a name="l01162"></a>01162 
<a name="l01163"></a>01163         rc = llog_init_handle(env, llh, LLOG_F_IS_PLAIN, NULL);
<a name="l01164"></a>01164         <span class="keywordflow">if</span> (rc)
<a name="l01165"></a>01165                 GOTO(out_close, rc);
<a name="l01166"></a>01166         rc = llog_get_size(llh);
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 out_close:
<a name="l01169"></a>01169         llog_close(env, llh);
<a name="l01170"></a>01170 out:
<a name="l01171"></a>01171         <span class="comment">/* The header is record 1, the llog is still considered as empty</span>
<a name="l01172"></a>01172 <span class="comment">         * if there is only header */</span>
<a name="l01173"></a>01173         <span class="keywordflow">return</span> (rc &lt;= 1);
<a name="l01174"></a>01174 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae96db4e0338a67db6a75218a14d22b4f"></a><!-- doxytag: member="lustre_log.h::llog_open_create" ref="gae96db4e0338a67db6a75218a14d22b4f" args="(const struct lu_env *env, struct llog_ctxt *ctxt, struct llog_handle **res, struct llog_logid *logid, char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llog_open_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structllog__ctxt.html">llog_ctxt</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structllog__handle.html">llog_handle</a> **&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structllog__logid.html">llog_logid</a> *&nbsp;</td>
          <td class="paramname"> <em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to open llog or create it if doesn't exist. </p>
<p>It hides all transaction handling from caller. </p>

<p>Definition at line <a class="el" href="llog_8c_source.html#l00963">963</a> of file <a class="el" href="llog_8c_source.html">llog.c</a>.</p>

<p>References <a class="el" href="llog_8c_source.html#l00799">llog_exist()</a>, and <a class="el" href="dt__object_8h_source.html#l01848">thandle::th_sync</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00966"></a>00966 {
<a name="l00967"></a>00967         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>        *d;
<a name="l00968"></a>00968         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *th;
<a name="l00969"></a>00969         <span class="keywordtype">int</span>                      rc;
<a name="l00970"></a>00970 
<a name="l00971"></a>00971         ENTRY;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         rc = llog_open(env, ctxt, res, logid, name, LLOG_OPEN_NEW);
<a name="l00974"></a>00974         <span class="keywordflow">if</span> (rc)
<a name="l00975"></a>00975                 RETURN(rc);
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         <span class="keywordflow">if</span> (<a class="code" href="group__log.html#gab4498d20e447d4dbeaff34eb3b305d57" title="new llog API">llog_exist</a>(*res))
<a name="l00978"></a>00978                 RETURN(0);
<a name="l00979"></a>00979 
<a name="l00980"></a>00980         LASSERT((*res)-&gt;lgh_obj != NULL);
<a name="l00981"></a>00981 
<a name="l00982"></a>00982         d = lu2dt_dev((*res)-&gt;lgh_obj-&gt;do_lu.lo_dev);
<a name="l00983"></a>00983 
<a name="l00984"></a>00984         th = dt_trans_create(env, d);
<a name="l00985"></a>00985         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l00986"></a>00986                 GOTO(out, rc = PTR_ERR(th));
<a name="l00987"></a>00987 
<a name="l00988"></a>00988         <span class="comment">/* Create update llog object synchronously, which</span>
<a name="l00989"></a>00989 <span class="comment">         * happens during inialization process see</span>
<a name="l00990"></a>00990 <span class="comment">         * lod_sub_prep_llog(), to make sure the update</span>
<a name="l00991"></a>00991 <span class="comment">         * llog object is created before corss-MDT writing</span>
<a name="l00992"></a>00992 <span class="comment">         * updates into the llog object */</span>
<a name="l00993"></a>00993         <span class="keywordflow">if</span> (ctxt-&gt;loc_flags &amp; LLOG_CTXT_FLAG_NORMAL_FID)
<a name="l00994"></a>00994                 th-&gt;<a class="code" href="structthandle.html#a4ebd1192a1e6fd4868826aee3ad1ec05" title="whether we need sync commit">th_sync</a> = 1;
<a name="l00995"></a>00995 
<a name="l00996"></a>00996         th-&gt;th_wait_submit = 1;
<a name="l00997"></a>00997         rc = llog_declare_create(env, *res, th);
<a name="l00998"></a>00998         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00999"></a>00999                 rc = dt_trans_start_local(env, d, th);
<a name="l01000"></a>01000                 <span class="keywordflow">if</span> (rc == 0)
<a name="l01001"></a>01001                         rc = llog_create(env, *res, th);
<a name="l01002"></a>01002         }
<a name="l01003"></a>01003         dt_trans_stop(env, d, th);
<a name="l01004"></a>01004 out:
<a name="l01005"></a>01005         <span class="keywordflow">if</span> (rc)
<a name="l01006"></a>01006                 llog_close(env, *res);
<a name="l01007"></a>01007         RETURN(rc);
<a name="l01008"></a>01008 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__log_gae96db4e0338a67db6a75218a14d22b4f_cgraph.png" border="0" usemap="#group__log_gae96db4e0338a67db6a75218a14d22b4f_cgraph_map" alt=""></div>
<map name="group__log_gae96db4e0338a67db6a75218a14d22b4f_cgraph_map" id="group__log_gae96db4e0338a67db6a75218a14d22b4f_cgraph">
<area shape="rect" id="node3" href="group__log.html#gab4498d20e447d4dbeaff34eb3b305d57" title="new llog API" alt="" coords="192,5,277,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf0dee2455ecbe5cbeeec044344224613"></a><!-- doxytag: member="lustre_log.h::llog_osd_get_cat_list" ref="gaf0dee2455ecbe5cbeeec044344224613" args="(const struct lu_env *env, struct dt_device *d, int idx, int count, struct llog_catid *idarray, const struct lu_fid *fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llog_osd_get_cat_list </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdt__device.html">dt_device</a> *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structllog__catid.html">llog_catid</a> *&nbsp;</td>
          <td class="paramname"> <em>idarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlu__fid.html">lu_fid</a> *&nbsp;</td>
          <td class="paramname"> <em>fid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the special file which contains the list of llog catalogs IDs. </p>
<p>This function reads the CATALOGS file which contains the array of llog catalogs IDs. The main purpose of this file is to store OSP llogs indexed by OST/MDT number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d</em>&nbsp;</td><td>corresponding storage device </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx</em>&nbsp;</td><td>position to start from, usually OST/MDT index </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>how many catalog IDs to read </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>idarray</em>&nbsp;</td><td>the buffer for the data. If it is NULL then function returns just number of catalog IDs in the file. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>LLOG_CATALOGS_OID for CATALOG object</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on successful read of catalog IDs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>value on error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>positive</em>&nbsp;</td><td>value which is number of records in the file if <em>idarray</em> is NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="llog__osd_8c_source.html#l01913">1913</a> of file <a class="el" href="llog__osd_8c_source.html">llog_osd.c</a>.</p>

<p>References <a class="el" href="dt__object_8h_source.html#l00396">dt_object_format::dof_type</a>, <a class="el" href="dt__object_8c_source.html#l00490">dt_record_read()</a>, <a class="el" href="lu__object_8h_source.html#l00419">lu_attr::la_mode</a>, <a class="el" href="lu__object_8h_source.html#l00409">lu_attr::la_size</a>, <a class="el" href="lu__object_8h_source.html#l00439">lu_attr::la_valid</a>, <a class="el" href="lu__object_8h_source.html#l00287">lu_device::ld_obd</a>, <a class="el" href="lu__object_8h_source.html#l00472">lu_object::lo_dev</a>, <a class="el" href="lu__object_8c_source.html#l00097">lu_object_put()</a>, and <a class="el" href="dt__object_8h_source.html#l01848">thandle::th_sync</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01916"></a>01916 {
<a name="l01917"></a>01917         <span class="keyword">struct </span><a class="code" href="structllog__thread__info.html">llog_thread_info</a> *lgi = llog_info(env);
<a name="l01918"></a>01918         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *o = NULL;
<a name="l01919"></a>01919         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *th;
<a name="l01920"></a>01920         <span class="keywordtype">int</span>                      rc, size;
<a name="l01921"></a>01921 
<a name="l01922"></a>01922         ENTRY;
<a name="l01923"></a>01923 
<a name="l01924"></a>01924         LASSERT(d);
<a name="l01925"></a>01925 
<a name="l01926"></a>01926         size = <span class="keyword">sizeof</span>(*idarray) * count;
<a name="l01927"></a>01927         lgi-&gt;lgi_off = idx *  <span class="keyword">sizeof</span>(*idarray);
<a name="l01928"></a>01928 
<a name="l01929"></a>01929         lgi-&gt;lgi_fid = *fid;
<a name="l01930"></a>01930         o = dt_locate(env, d, &amp;lgi-&gt;lgi_fid);
<a name="l01931"></a>01931         <span class="keywordflow">if</span> (IS_ERR(o))
<a name="l01932"></a>01932                 RETURN(PTR_ERR(o));
<a name="l01933"></a>01933 
<a name="l01934"></a>01934         <span class="keywordflow">if</span> (!dt_object_exists(o)) {
<a name="l01935"></a>01935                 th = dt_trans_create(env, d);
<a name="l01936"></a>01936                 <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l01937"></a>01937                         GOTO(out, rc = PTR_ERR(th));
<a name="l01938"></a>01938 
<a name="l01939"></a>01939                 lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_MODE;
<a name="l01940"></a>01940                 lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> = S_IFREG | S_IRUGO | S_IWUSR;
<a name="l01941"></a>01941                 lgi-&gt;lgi_dof.<a class="code" href="structdt__object__format.html#a7522bce1087145d78c749b182e10357c" title="type for dt object">dof_type</a> = dt_mode_to_dft(S_IFREG);
<a name="l01942"></a>01942 
<a name="l01943"></a>01943                 th-&gt;th_wait_submit = 1;
<a name="l01944"></a>01944                 <span class="comment">/* Make the llog object creation synchronization, so</span>
<a name="l01945"></a>01945 <span class="comment">                 * it will be reliable to the reference, especially</span>
<a name="l01946"></a>01946 <span class="comment">                 * for remote reference */</span>
<a name="l01947"></a>01947                 th-&gt;<a class="code" href="structthandle.html#a4ebd1192a1e6fd4868826aee3ad1ec05" title="whether we need sync commit">th_sync</a> = 1;
<a name="l01948"></a>01948 
<a name="l01949"></a>01949                 rc = dt_declare_create(env, o, &amp;lgi-&gt;lgi_attr, NULL,
<a name="l01950"></a>01950                                        &amp;lgi-&gt;lgi_dof, th);
<a name="l01951"></a>01951                 <span class="keywordflow">if</span> (rc)
<a name="l01952"></a>01952                         GOTO(out_trans, rc);
<a name="l01953"></a>01953 
<a name="l01954"></a>01954                 rc = dt_trans_start_local(env, d, th);
<a name="l01955"></a>01955                 <span class="keywordflow">if</span> (rc)
<a name="l01956"></a>01956                         GOTO(out_trans, rc);
<a name="l01957"></a>01957 
<a name="l01958"></a>01958                 dt_write_lock(env, o, 0);
<a name="l01959"></a>01959                 <span class="keywordflow">if</span> (!dt_object_exists(o))
<a name="l01960"></a>01960                         rc = dt_create(env, o, &amp;lgi-&gt;lgi_attr, NULL,
<a name="l01961"></a>01961                                        &amp;lgi-&gt;lgi_dof, th);
<a name="l01962"></a>01962                 dt_write_unlock(env, o);
<a name="l01963"></a>01963 out_trans:
<a name="l01964"></a>01964                 dt_trans_stop(env, d, th);
<a name="l01965"></a>01965                 <span class="keywordflow">if</span> (rc)
<a name="l01966"></a>01966                         GOTO(out, rc);
<a name="l01967"></a>01967         }
<a name="l01968"></a>01968 
<a name="l01969"></a>01969         rc = dt_attr_get(env, o, &amp;lgi-&gt;lgi_attr);
<a name="l01970"></a>01970         <span class="keywordflow">if</span> (rc)
<a name="l01971"></a>01971                 GOTO(out, rc);
<a name="l01972"></a>01972 
<a name="l01973"></a>01973         <span class="keywordflow">if</span> (!S_ISREG(lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l01974"></a>01974                 CERROR(<span class="stringliteral">&quot;%s: CATALOGS is not a regular file!: mode = %o\n&quot;</span>,
<a name="l01975"></a>01975                        o-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name,
<a name="l01976"></a>01976                        lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>);
<a name="l01977"></a>01977                 GOTO(out, rc = -ENOENT);
<a name="l01978"></a>01978         }
<a name="l01979"></a>01979 
<a name="l01980"></a>01980         CDEBUG(D_CONFIG, <span class="stringliteral">&quot;cat list: disk size=%d, read=%d\n&quot;</span>,
<a name="l01981"></a>01981                (<span class="keywordtype">int</span>)lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a>, size);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983         <span class="comment">/* return just number of llogs */</span>
<a name="l01984"></a>01984         <span class="keywordflow">if</span> (idarray == NULL) {
<a name="l01985"></a>01985                 rc = lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a> / <span class="keyword">sizeof</span>(*idarray);
<a name="l01986"></a>01986                 GOTO(out, rc);
<a name="l01987"></a>01987         }
<a name="l01988"></a>01988 
<a name="l01989"></a>01989         <span class="comment">/* read for new ost index or for empty file */</span>
<a name="l01990"></a>01990         memset(idarray, 0, size);
<a name="l01991"></a>01991         <span class="keywordflow">if</span> (lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a> &lt;= lgi-&gt;lgi_off)
<a name="l01992"></a>01992                 GOTO(out, rc = 0);
<a name="l01993"></a>01993         <span class="keywordflow">if</span> (lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a> &lt; lgi-&gt;lgi_off + size)
<a name="l01994"></a>01994                 size = lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a> - lgi-&gt;lgi_off;
<a name="l01995"></a>01995 
<a name="l01996"></a>01996         lgi-&gt;lgi_buf.lb_buf = idarray;
<a name="l01997"></a>01997         lgi-&gt;lgi_buf.lb_len = size;
<a name="l01998"></a>01998         rc = <a class="code" href="group__dt.html#ga82d909c9a0d09d6c21420825acb9e40e" title="Read structures of fixed size from storage.">dt_record_read</a>(env, o, &amp;lgi-&gt;lgi_buf, &amp;lgi-&gt;lgi_off);
<a name="l01999"></a>01999         <span class="comment">/* -EFAULT means the llog is a sparse file. This is not an error</span>
<a name="l02000"></a>02000 <span class="comment">         * after arbitrary OST index is supported. */</span>
<a name="l02001"></a>02001         <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; rc != -EFAULT) {
<a name="l02002"></a>02002                 CERROR(<span class="stringliteral">&quot;%s: error reading CATALOGS: rc = %d\n&quot;</span>,
<a name="l02003"></a>02003                        o-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name,  rc);
<a name="l02004"></a>02004                 GOTO(out, rc);
<a name="l02005"></a>02005         }
<a name="l02006"></a>02006 
<a name="l02007"></a>02007         EXIT;
<a name="l02008"></a>02008 out:
<a name="l02009"></a>02009         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, &amp;o-&gt;do_lu);
<a name="l02010"></a>02010         RETURN(rc);
<a name="l02011"></a>02011 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__log_gaf0dee2455ecbe5cbeeec044344224613_cgraph.png" border="0" usemap="#group__log_gaf0dee2455ecbe5cbeeec044344224613_cgraph_map" alt=""></div>
<map name="group__log_gaf0dee2455ecbe5cbeeec044344224613_cgraph_map" id="group__log_gaf0dee2455ecbe5cbeeec044344224613_cgraph">
<area shape="rect" id="node3" href="group__dt.html#ga82d909c9a0d09d6c21420825acb9e40e" title="Read structures of fixed size from storage." alt="" coords="217,5,340,35"/><area shape="rect" id="node5" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object." alt="" coords="221,59,336,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga4b308f3bee04638c301ba0bead3ad070"></a><!-- doxytag: member="lustre_log.h::llog_osd_put_cat_list" ref="ga4b308f3bee04638c301ba0bead3ad070" args="(const struct lu_env *env, struct dt_device *d, int idx, int count, struct llog_catid *idarray, const struct lu_fid *fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llog_osd_put_cat_list </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdt__device.html">dt_device</a> *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structllog__catid.html">llog_catid</a> *&nbsp;</td>
          <td class="paramname"> <em>idarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlu__fid.html">lu_fid</a> *&nbsp;</td>
          <td class="paramname"> <em>fid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the special file which contains the list of llog catalogs IDs. </p>
<p>This function writes the CATALOG file which contains the array of llog catalogs IDs. It is used mostly to store OSP llogs indexed by OST/MDT number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d</em>&nbsp;</td><td>corresponding storage device </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx</em>&nbsp;</td><td>position to start from, usually OST/MDT index </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>how many catalog IDs to write </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>idarray</em>&nbsp;</td><td>the buffer with the data to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>LLOG_CATALOGS_OID for CATALOG object</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on successful write of catalog IDs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>value on error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="llog__osd_8c_source.html#l02031">2031</a> of file <a class="el" href="llog__osd_8c_source.html">llog_osd.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00419">lu_attr::la_mode</a>, <a class="el" href="lu__object_8h_source.html#l00287">lu_device::ld_obd</a>, <a class="el" href="lu__object_8h_source.html#l00472">lu_object::lo_dev</a>, <a class="el" href="lu__object_8c_source.html#l00097">lu_object_put()</a>, and <a class="el" href="dt__object_8h_source.html#l01848">thandle::th_sync</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02034"></a>02034 {
<a name="l02035"></a>02035         <span class="keyword">struct </span><a class="code" href="structllog__thread__info.html">llog_thread_info</a> *lgi = llog_info(env);
<a name="l02036"></a>02036         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *o = NULL;
<a name="l02037"></a>02037         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *th;
<a name="l02038"></a>02038         <span class="keywordtype">int</span>                      rc, size;
<a name="l02039"></a>02039 
<a name="l02040"></a>02040         <span class="keywordflow">if</span> (count == 0)
<a name="l02041"></a>02041                 RETURN(0);
<a name="l02042"></a>02042 
<a name="l02043"></a>02043         LASSERT(d);
<a name="l02044"></a>02044 
<a name="l02045"></a>02045         size = <span class="keyword">sizeof</span>(*idarray) * count;
<a name="l02046"></a>02046         lgi-&gt;lgi_off = idx * <span class="keyword">sizeof</span>(*idarray);
<a name="l02047"></a>02047         lgi-&gt;lgi_fid = *fid;
<a name="l02048"></a>02048 
<a name="l02049"></a>02049         o = dt_locate(env, d, &amp;lgi-&gt;lgi_fid);
<a name="l02050"></a>02050         <span class="keywordflow">if</span> (IS_ERR(o))
<a name="l02051"></a>02051                 RETURN(PTR_ERR(o));
<a name="l02052"></a>02052 
<a name="l02053"></a>02053         <span class="keywordflow">if</span> (!dt_object_exists(o))
<a name="l02054"></a>02054                 GOTO(out, rc = -ENOENT);
<a name="l02055"></a>02055 
<a name="l02056"></a>02056         rc = dt_attr_get(env, o, &amp;lgi-&gt;lgi_attr);
<a name="l02057"></a>02057         <span class="keywordflow">if</span> (rc)
<a name="l02058"></a>02058                 GOTO(out, rc);
<a name="l02059"></a>02059 
<a name="l02060"></a>02060         <span class="keywordflow">if</span> (!S_ISREG(lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02061"></a>02061                 CERROR(<span class="stringliteral">&quot;%s: CATALOGS is not a regular file!: mode = %o\n&quot;</span>,
<a name="l02062"></a>02062                        o-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name,
<a name="l02063"></a>02063                        lgi-&gt;lgi_attr.<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>);
<a name="l02064"></a>02064                 GOTO(out, rc = -ENOENT);
<a name="l02065"></a>02065         }
<a name="l02066"></a>02066 
<a name="l02067"></a>02067         th = dt_trans_create(env, d);
<a name="l02068"></a>02068         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l02069"></a>02069                 GOTO(out, rc = PTR_ERR(th));
<a name="l02070"></a>02070 
<a name="l02071"></a>02071         lgi-&gt;lgi_buf.lb_len = size;
<a name="l02072"></a>02072         lgi-&gt;lgi_buf.lb_buf = idarray;
<a name="l02073"></a>02073         rc = dt_declare_record_write(env, o, &amp;lgi-&gt;lgi_buf, lgi-&gt;lgi_off, th);
<a name="l02074"></a>02074         <span class="keywordflow">if</span> (rc)
<a name="l02075"></a>02075                 GOTO(out_trans, rc);
<a name="l02076"></a>02076 
<a name="l02077"></a>02077         <span class="comment">/* For update log, this happens during initialization,</span>
<a name="l02078"></a>02078 <span class="comment">         * see lod_sub_prep_llog(), and we need make sure catlog</span>
<a name="l02079"></a>02079 <span class="comment">         * file ID is written to catlist file(committed) before</span>
<a name="l02080"></a>02080 <span class="comment">         * cross-MDT operation write update records to catlog FILE,</span>
<a name="l02081"></a>02081 <span class="comment">         * otherwise, during failover these update records might</span>
<a name="l02082"></a>02082 <span class="comment">         * missing */</span>
<a name="l02083"></a>02083         <span class="keywordflow">if</span> (fid_is_update_log(fid))
<a name="l02084"></a>02084                 th-&gt;<a class="code" href="structthandle.html#a4ebd1192a1e6fd4868826aee3ad1ec05" title="whether we need sync commit">th_sync</a> = 1;
<a name="l02085"></a>02085 
<a name="l02086"></a>02086         rc = dt_trans_start_local(env, d, th);
<a name="l02087"></a>02087         <span class="keywordflow">if</span> (rc)
<a name="l02088"></a>02088                 GOTO(out_trans, rc);
<a name="l02089"></a>02089 
<a name="l02090"></a>02090         th-&gt;th_wait_submit = 1;
<a name="l02091"></a>02091 
<a name="l02092"></a>02092         rc = dt_record_write(env, o, &amp;lgi-&gt;lgi_buf, &amp;lgi-&gt;lgi_off, th);
<a name="l02093"></a>02093         <span class="keywordflow">if</span> (rc)
<a name="l02094"></a>02094                 CDEBUG(D_INODE, <span class="stringliteral">&quot;can&apos;t write CATALOGS at index %d: rc = %d\n&quot;</span>,
<a name="l02095"></a>02095                        idx, rc);
<a name="l02096"></a>02096 out_trans:
<a name="l02097"></a>02097         dt_trans_stop(env, d, th);
<a name="l02098"></a>02098 out:
<a name="l02099"></a>02099         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, &amp;o-&gt;do_lu);
<a name="l02100"></a>02100         RETURN(rc);
<a name="l02101"></a>02101 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__log_ga4b308f3bee04638c301ba0bead3ad070_cgraph.png" border="0" usemap="#group__log_ga4b308f3bee04638c301ba0bead3ad070_cgraph_map" alt=""></div>
<map name="group__log_ga4b308f3bee04638c301ba0bead3ad070_cgraph_map" id="group__log_ga4b308f3bee04638c301ba0bead3ad070_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object." alt="" coords="216,5,331,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gab379f30f30f88aebf9be8c61b7f55152"></a><!-- doxytag: member="lustre_log.h::lustre_process_log" ref="gab379f30f30f88aebf9be8c61b7f55152" args="(struct super_block *sb, char *logname, struct config_llog_instance *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lustre_process_log </td>
          <td>(</td>
          <td class="paramtype">struct super_block *&nbsp;</td>
          <td class="paramname"> <em>sb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>logname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structconfig__llog__instance.html">config_llog_instance</a> *&nbsp;</td>
          <td class="paramname"> <em>cfg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a config log from the MGS and process it. </p>
<p>This func is called for both clients and servers. Continue to process new statements appended to the logs (whenever the config lock is revoked) until lustre_end_log is called. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sb</em>&nbsp;</td><td>The superblock is used by the MGC to write to the local copy of the config log </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>logname</em>&nbsp;</td><td>The name of the llog to replicate from the MGS </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cfg</em>&nbsp;</td><td>Since the same mgc may be used to follow multiple config logs (e.g. ost1, ost2, client), the <a class="el" href="structconfig__llog__instance.html">config_llog_instance</a> keeps the state for this log, and is added to the mgc's list of logs to follow. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="obd__mount_8c_source.html#l00075">75</a> of file <a class="el" href="obd__mount_8c_source.html">obd_mount.c</a>.</p>

<p>References <a class="el" href="lustre__cfg_8h_source.html#l00088">LCFG_LOG_START</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00077"></a>00077 {
<a name="l00078"></a>00078         <span class="keyword">struct </span><a class="code" href="structlustre__cfg.html">lustre_cfg</a> *lcfg;
<a name="l00079"></a>00079         <span class="keyword">struct </span><a class="code" href="structlustre__cfg__bufs.html">lustre_cfg_bufs</a> *bufs;
<a name="l00080"></a>00080         <span class="keyword">struct </span>lustre_sb_info *lsi = s2lsi(sb);
<a name="l00081"></a>00081         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *mgc = lsi-&gt;lsi_mgc;
<a name="l00082"></a>00082         <span class="keywordtype">int</span> rc;
<a name="l00083"></a>00083         ENTRY;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085         LASSERT(mgc);
<a name="l00086"></a>00086         LASSERT(cfg);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         OBD_ALLOC_PTR(bufs);
<a name="l00089"></a>00089         <span class="keywordflow">if</span> (bufs == NULL)
<a name="l00090"></a>00090                 RETURN(-ENOMEM);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092         <span class="comment">/* mgc_process_config */</span>
<a name="l00093"></a>00093         lustre_cfg_bufs_reset(bufs, mgc-&gt;obd_name);
<a name="l00094"></a>00094         lustre_cfg_bufs_set_string(bufs, 1, logname);
<a name="l00095"></a>00095         lustre_cfg_bufs_set(bufs, 2, cfg, <span class="keyword">sizeof</span>(*cfg));
<a name="l00096"></a>00096         lustre_cfg_bufs_set(bufs, 3, &amp;sb, <span class="keyword">sizeof</span>(sb));
<a name="l00097"></a>00097         lcfg = lustre_cfg_new(<a class="code" href="group__cfg.html#gga980511536826a6f5df2877e44c9af68ba40a6722bef24ca80f8030c7ea800043b" title="mgc only, process a cfg log">LCFG_LOG_START</a>, bufs);
<a name="l00098"></a>00098         <span class="keywordflow">if</span> (lcfg == NULL)
<a name="l00099"></a>00099                 GOTO(out, rc = -ENOMEM);
<a name="l00100"></a>00100         rc = obd_process_config(mgc, <span class="keyword">sizeof</span>(*lcfg), lcfg);
<a name="l00101"></a>00101         lustre_cfg_free(lcfg);
<a name="l00102"></a>00102 out:
<a name="l00103"></a>00103         OBD_FREE_PTR(bufs);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         <span class="keywordflow">if</span> (rc == -EINVAL)
<a name="l00106"></a>00106                 LCONSOLE_ERROR_MSG(0x15b, <span class="stringliteral">&quot;%s: The configuration from log &apos;%s&apos;&quot;</span>
<a name="l00107"></a>00107                                    <span class="stringliteral">&quot;failed from the MGS (%d).  Make sure this &quot;</span>
<a name="l00108"></a>00108                                    <span class="stringliteral">&quot;client and the MGS are running compatible &quot;</span>
<a name="l00109"></a>00109                                    <span class="stringliteral">&quot;versions of Lustre.\n&quot;</span>,
<a name="l00110"></a>00110                                    mgc-&gt;obd_name, logname, rc);
<a name="l00111"></a>00111         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != 0)
<a name="l00112"></a>00112                 LCONSOLE_ERROR_MSG(0x15c, <span class="stringliteral">&quot;%s: The configuration from log &apos;%s&apos; &quot;</span>
<a name="l00113"></a>00113                                    <span class="stringliteral">&quot;failed (%d). This may be the result of &quot;</span>
<a name="l00114"></a>00114                                    <span class="stringliteral">&quot;communication errors between this node and &quot;</span>
<a name="l00115"></a>00115                                    <span class="stringliteral">&quot;the MGS, a bad configuration, or other &quot;</span>
<a name="l00116"></a>00116                                    <span class="stringliteral">&quot;errors. See the syslog for more &quot;</span>
<a name="l00117"></a>00117                                    <span class="stringliteral">&quot;information.\n&quot;</span>, mgc-&gt;obd_name, logname,
<a name="l00118"></a>00118                                    rc);
<a name="l00119"></a>00119 
<a name="l00120"></a>00120         <span class="comment">/* class_obd_list(); */</span>
<a name="l00121"></a>00121         RETURN(rc);
<a name="l00122"></a>00122 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:43 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
