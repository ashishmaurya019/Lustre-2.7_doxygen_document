<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: Match entries</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Match entries<br/>
<small>
[<a class="el" href="group__lnet.html">LNet</a>]</small>
</h1>
<p>A match entry (abbreviated as ME) describes a set of criteria to accept incoming requests.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Match entries:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__lnet__me.png" border="0" alt="" usemap="#group____lnet____me_map"/>
<map name="group____lnet____me_map" id="group____lnet____me">
<area shape="rect" id="node1" href="group__lnet.html" title="The Lustre Networking subsystem." alt="" coords="5,5,61,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9">lnet_unlink_t</a> { <b>LNET_RETAIN</b> =  0, 
<b>LNET_UNLINK</b>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Specifies whether the match entry or memory descriptor should be unlinked automatically (LNET_UNLINK) or not (LNET_RETAIN). </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__me.html#ga292319c5a5ed0c5718ce4edfd3aa1fb4">lnet_ins_pos_t</a> { <a class="el" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a34aed27703f17b6eb2f3e1a1a3b7cf69">LNET_INS_BEFORE</a>, 
<a class="el" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a9c92e271885b81271fa1467f486dcd07">LNET_INS_AFTER</a>, 
<a class="el" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a528b8efb44f170eafe836b2ba25ec437">LNET_INS_LOCAL</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Values of the type lnet_ins_pos_t are used to control where a new match entry is inserted. </p>
 <a href="group__lnet__me.html#ga292319c5a5ed0c5718ce4edfd3aa1fb4">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50">LNetMEAttach</a> (unsigned int portal, <a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a> match_id_in, __u64 match_bits_in, __u64 ignore_bits_in, <a class="el" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9">lnet_unlink_t</a> unlink_in, <a class="el" href="group__lnet__me.html#ga292319c5a5ed0c5718ce4edfd3aa1fb4">lnet_ins_pos_t</a> pos_in, <a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a> *handle_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and attach a match entry to the match list of <em>portal</em>.  <a href="#ga581025ed43fdf21741691e82253b1b50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__me.html#ga780c62e0a297e96b11aaaca7efae1db7">LNetMEInsert</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a> current_in, <a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a> match_id_in, __u64 match_bits_in, __u64 ignore_bits_in, <a class="el" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9">lnet_unlink_t</a> unlink_in, <a class="el" href="group__lnet__me.html#ga292319c5a5ed0c5718ce4edfd3aa1fb4">lnet_ins_pos_t</a> position_in, <a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a> *handle_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and a match entry and insert it before or after the ME pointed to by <em>current_meh</em>.  <a href="#ga780c62e0a297e96b11aaaca7efae1db7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422">LNetMEUnlink</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a> current_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlink a match entry from its match list.  <a href="#gad38e0c2462a6e9a1735783c853345422"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A match entry (abbreviated as ME) describes a set of criteria to accept incoming requests. </p>
<p>A portal is essentially a match list plus a set of attributes. A match list is a chain of MEs. Each ME includes a pointer to a memory descriptor and a set of match criteria. The match criteria can be used to reject incoming requests based on process ID or the match bits provided in the request. MEs can be dynamically inserted into a match list by <a class="el" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal.">LNetMEAttach()</a> and <a class="el" href="group__lnet__me.html#ga780c62e0a297e96b11aaaca7efae1db7" title="Create and a match entry and insert it before or after the ME pointed to by current_meh...">LNetMEInsert()</a>, and removed from its list by <a class="el" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list.">LNetMEUnlink()</a>. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga292319c5a5ed0c5718ce4edfd3aa1fb4"></a><!-- doxytag: member="types.h::lnet_ins_pos_t" ref="ga292319c5a5ed0c5718ce4edfd3aa1fb4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lnet__me.html#ga292319c5a5ed0c5718ce4edfd3aa1fb4">lnet_ins_pos_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Values of the type lnet_ins_pos_t are used to control where a new match entry is inserted. </p>
<p>The value LNET_INS_BEFORE is used to insert the new entry before the current entry or before the head of the list. The value LNET_INS_AFTER is used to insert the new entry after the current entry or after the last item in the list. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga292319c5a5ed0c5718ce4edfd3aa1fb4a34aed27703f17b6eb2f3e1a1a3b7cf69"></a><!-- doxytag: member="LNET_INS_BEFORE" ref="gga292319c5a5ed0c5718ce4edfd3aa1fb4a34aed27703f17b6eb2f3e1a1a3b7cf69" args="" -->LNET_INS_BEFORE</em>&nbsp;</td><td>
<p>insert ME before current position or head of the list </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga292319c5a5ed0c5718ce4edfd3aa1fb4a9c92e271885b81271fa1467f486dcd07"></a><!-- doxytag: member="LNET_INS_AFTER" ref="gga292319c5a5ed0c5718ce4edfd3aa1fb4a9c92e271885b81271fa1467f486dcd07" args="" -->LNET_INS_AFTER</em>&nbsp;</td><td>
<p>insert ME after current position or tail of the list </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga292319c5a5ed0c5718ce4edfd3aa1fb4a528b8efb44f170eafe836b2ba25ec437"></a><!-- doxytag: member="LNET_INS_LOCAL" ref="gga292319c5a5ed0c5718ce4edfd3aa1fb4a528b8efb44f170eafe836b2ba25ec437" args="" -->LNET_INS_LOCAL</em>&nbsp;</td><td>
<p>attach ME at tail of local CPU partition ME list </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00329">329</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00329"></a>00329              {
<a name="l00331"></a>00331         <a class="code" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a34aed27703f17b6eb2f3e1a1a3b7cf69" title="insert ME before current position or head of the list">LNET_INS_BEFORE</a>,
<a name="l00333"></a>00333         <a class="code" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a9c92e271885b81271fa1467f486dcd07" title="insert ME after current position or tail of the list">LNET_INS_AFTER</a>,
<a name="l00335"></a>00335         <a class="code" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a528b8efb44f170eafe836b2ba25ec437" title="attach ME at tail of local CPU partition ME list">LNET_INS_LOCAL</a>
<a name="l00336"></a>00336 } <a class="code" href="group__lnet__me.html#ga292319c5a5ed0c5718ce4edfd3aa1fb4" title="Values of the type lnet_ins_pos_t are used to control where a new match entry is...">lnet_ins_pos_t</a>;
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga581025ed43fdf21741691e82253b1b50"></a><!-- doxytag: member="api.h::LNetMEAttach" ref="ga581025ed43fdf21741691e82253b1b50" args="(unsigned int portal, lnet_process_id_t match_id_in, __u64 match_bits_in, __u64 ignore_bits_in, lnet_unlink_t unlink_in, lnet_ins_pos_t pos_in, lnet_handle_me_t *handle_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetMEAttach </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>match_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>match_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>ignore_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9">lnet_unlink_t</a>&nbsp;</td>
          <td class="paramname"> <em>unlink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__me.html#ga292319c5a5ed0c5718ce4edfd3aa1fb4">lnet_ins_pos_t</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create and attach a match entry to the match list of <em>portal</em>. </p>
<p>The new ME is empty, i.e. not associated with a memory descriptor. <a class="el" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME.">LNetMDAttach()</a> can be used to attach a MD to an empty ME.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>The portal table index where the ME should be attached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_id</em>&nbsp;</td><td>Specifies the match criteria for the process ID of the requester. The constants LNET_PID_ANY and LNET_NID_ANY can be used to wildcard either of the identifiers in the <a class="el" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_bits,ignore_bits</em>&nbsp;</td><td>Specify the match criteria to apply to the match bits in the incoming request. The ignore bits are used to mask out insignificant bits in the incoming match bits. The resulting bits are then compared to the ME's match bits to determine if the incoming request meets the match criteria. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unlink</em>&nbsp;</td><td>Indicates whether the ME should be unlinked when the memory descriptor associated with it is unlinked (Note that the check for unlinking a ME only occurs when the memory descriptor is unlinked.). Valid values are LNET_RETAIN and LNET_UNLINK. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Indicates whether the new ME should be prepended or appended to the match list. Allowed constants: LNET_INS_BEFORE, LNET_INS_AFTER. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>On successful returns, a handle to the newly created ME object is saved here. This handle can be used later in <a class="el" href="group__lnet__me.html#ga780c62e0a297e96b11aaaca7efae1db7" title="Create and a match entry and insert it before or after the ME pointed to by current_meh...">LNetMEInsert()</a>, <a class="el" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list.">LNetMEUnlink()</a>, or <a class="el" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME.">LNetMDAttach()</a> functions.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>On success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>If <em>portal</em> is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>If new ME object cannot be allocated. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-me_8c_source.html#l00076">76</a> of file <a class="el" href="lib-me_8c_source.html">lib-me.c</a>.</p>

<p>References <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00333">LNET_INS_AFTER</a>, and <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00335">LNET_INS_LOCAL</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, <a class="el" href="niobuf_8c_source.html#l00301">ptlrpc_register_bulk()</a>, and <a class="el" href="niobuf_8c_source.html#l00900">ptlrpc_register_rqbd()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00081"></a>00081 {
<a name="l00082"></a>00082         <span class="keyword">struct </span><a class="code" href="structlnet__match__table.html">lnet_match_table</a> *mtable;
<a name="l00083"></a>00083         <span class="keyword">struct </span><a class="code" href="structlnet__me.html">lnet_me</a>          *me;
<a name="l00084"></a>00084         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *head;
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         LASSERT(the_lnet.ln_refcount &gt; 0);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)portal &gt;= the_lnet.ln_nportals)
<a name="l00089"></a>00089                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         mtable = lnet_mt_of_attach(portal, match_id,
<a name="l00092"></a>00092                                    match_bits, ignore_bits, pos);
<a name="l00093"></a>00093         <span class="keywordflow">if</span> (mtable == NULL) <span class="comment">/* can&apos;t match portal type */</span>
<a name="l00094"></a>00094                 <span class="keywordflow">return</span> -EPERM;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         me = lnet_me_alloc();
<a name="l00097"></a>00097         <span class="keywordflow">if</span> (me == NULL)
<a name="l00098"></a>00098                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100         lnet_res_lock(mtable-&gt;mt_cpt);
<a name="l00101"></a>00101 
<a name="l00102"></a>00102         me-&gt;me_portal = portal;
<a name="l00103"></a>00103         me-&gt;me_match_id = match_id;
<a name="l00104"></a>00104         me-&gt;me_match_bits = match_bits;
<a name="l00105"></a>00105         me-&gt;me_ignore_bits = ignore_bits;
<a name="l00106"></a>00106         me-&gt;me_unlink = unlink;
<a name="l00107"></a>00107         me-&gt;me_md = NULL;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109         lnet_res_lh_initialize(the_lnet.ln_me_containers[mtable-&gt;mt_cpt],
<a name="l00110"></a>00110                                &amp;me-&gt;me_lh);
<a name="l00111"></a>00111         <span class="keywordflow">if</span> (ignore_bits != 0)
<a name="l00112"></a>00112                 head = &amp;mtable-&gt;mt_mhash[LNET_MT_HASH_IGNORE];
<a name="l00113"></a>00113         <span class="keywordflow">else</span>
<a name="l00114"></a>00114                 head = lnet_mt_match_head(mtable, match_id, match_bits);
<a name="l00115"></a>00115 
<a name="l00116"></a>00116         me-&gt;me_pos = head - &amp;mtable-&gt;mt_mhash[0];
<a name="l00117"></a>00117         <span class="keywordflow">if</span> (pos == <a class="code" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a9c92e271885b81271fa1467f486dcd07" title="insert ME after current position or tail of the list">LNET_INS_AFTER</a> || pos == <a class="code" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a528b8efb44f170eafe836b2ba25ec437" title="attach ME at tail of local CPU partition ME list">LNET_INS_LOCAL</a>)
<a name="l00118"></a>00118                 list_add_tail(&amp;me-&gt;me_list, head);
<a name="l00119"></a>00119         <span class="keywordflow">else</span>
<a name="l00120"></a>00120                 list_add(&amp;me-&gt;me_list, head);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         lnet_me2handle(handle, me);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         lnet_res_unlock(mtable-&gt;mt_cpt);
<a name="l00125"></a>00125         <span class="keywordflow">return</span> 0;
<a name="l00126"></a>00126 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lnet__me_ga581025ed43fdf21741691e82253b1b50_icgraph.png" border="0" usemap="#group__lnet__me_ga581025ed43fdf21741691e82253b1b50_icgraph_map" alt=""></div>
<map name="group__lnet__me_ga581025ed43fdf21741691e82253b1b50_icgraph_map" id="group__lnet__me_ga581025ed43fdf21741691e82253b1b50_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="384,84,491,113"/><area shape="rect" id="node38" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Register bulk at the sender for later transfer." alt="" coords="180,109,335,139"/><area shape="rect" id="node41" href="group__net.html#gaf7557fc8aa34bbf889ee11612ece2315" title="Register request buffer descriptor for request receiving." alt="" coords="179,163,336,192"/><area shape="rect" id="node5" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="539,84,677,113"/><area shape="rect" id="node7" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="1100,56,1244,85"/><area shape="rect" id="node9" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="727,109,852,139"/><area shape="rect" id="node11" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="901,109,1048,139"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="1097,109,1247,139"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="1104,163,1240,192"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1297,109,1444,139"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1527,29,1647,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1495,83,1679,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1979,108,2221,137"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1516,187,1657,216"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1729,29,1929,59"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="2031,29,2169,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1728,83,1931,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2269,108,2445,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga780c62e0a297e96b11aaaca7efae1db7"></a><!-- doxytag: member="api.h::LNetMEInsert" ref="ga780c62e0a297e96b11aaaca7efae1db7" args="(lnet_handle_me_t current_in, lnet_process_id_t match_id_in, __u64 match_bits_in, __u64 ignore_bits_in, lnet_unlink_t unlink_in, lnet_ins_pos_t position_in, lnet_handle_me_t *handle_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetMEInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a>&nbsp;</td>
          <td class="paramname"> <em>current_meh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>match_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>match_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>ignore_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9">lnet_unlink_t</a>&nbsp;</td>
          <td class="paramname"> <em>unlink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__me.html#ga292319c5a5ed0c5718ce4edfd3aa1fb4">lnet_ins_pos_t</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create and a match entry and insert it before or after the ME pointed to by <em>current_meh</em>. </p>
<p>The new ME is empty, i.e. not associated with a memory descriptor. <a class="el" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME.">LNetMDAttach()</a> can be used to attach a MD to an empty ME.</p>
<p>This function is identical to <a class="el" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal.">LNetMEAttach()</a> except for the position where the new ME is inserted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>current_meh</em>&nbsp;</td><td>A handle for a ME. The new ME will be inserted immediately before or immediately after this ME. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_id,match_bits,ignore_bits,unlink,pos,handle</em>&nbsp;</td><td>See the discussion for <a class="el" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal.">LNetMEAttach()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>On success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>If new ME object cannot be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If <em>current_meh</em> does not point to a valid match entry. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-me_8c_source.html#l00147">147</a> of file <a class="el" href="lib-me_8c_source.html">lib-me.c</a>.</p>

<p>References <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00333">LNET_INS_AFTER</a>, and <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00335">LNET_INS_LOCAL</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00152"></a>00152 {
<a name="l00153"></a>00153         <span class="keyword">struct </span><a class="code" href="structlnet__me.html">lnet_me</a>          *current_me;
<a name="l00154"></a>00154         <span class="keyword">struct </span><a class="code" href="structlnet__me.html">lnet_me</a>          *new_me;
<a name="l00155"></a>00155         <span class="keyword">struct </span><a class="code" href="structlnet__portal.html">lnet_portal</a>      *ptl;
<a name="l00156"></a>00156         <span class="keywordtype">int</span>                     cpt;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158         LASSERT(the_lnet.ln_refcount &gt; 0);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         <span class="keywordflow">if</span> (pos == <a class="code" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a528b8efb44f170eafe836b2ba25ec437" title="attach ME at tail of local CPU partition ME list">LNET_INS_LOCAL</a>)
<a name="l00161"></a>00161                 <span class="keywordflow">return</span> -EPERM;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163         new_me = lnet_me_alloc();
<a name="l00164"></a>00164         <span class="keywordflow">if</span> (new_me == NULL)
<a name="l00165"></a>00165                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167         cpt = lnet_cpt_of_cookie(current_meh.cookie);
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         lnet_res_lock(cpt);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171         current_me = lnet_handle2me(&amp;current_meh);
<a name="l00172"></a>00172         <span class="keywordflow">if</span> (current_me == NULL) {
<a name="l00173"></a>00173                 lnet_me_free(new_me);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175                 lnet_res_unlock(cpt);
<a name="l00176"></a>00176                 <span class="keywordflow">return</span> -ENOENT;
<a name="l00177"></a>00177         }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         LASSERT(current_me-&gt;me_portal &lt; the_lnet.ln_nportals);
<a name="l00180"></a>00180 
<a name="l00181"></a>00181         ptl = the_lnet.ln_portals[current_me-&gt;me_portal];
<a name="l00182"></a>00182         <span class="keywordflow">if</span> (lnet_ptl_is_unique(ptl)) {
<a name="l00183"></a>00183                 <span class="comment">/* nosense to insertion on unique portal */</span>
<a name="l00184"></a>00184                 lnet_me_free(new_me);
<a name="l00185"></a>00185                 lnet_res_unlock(cpt);
<a name="l00186"></a>00186                 <span class="keywordflow">return</span> -EPERM;
<a name="l00187"></a>00187         }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         new_me-&gt;me_pos = current_me-&gt;me_pos;
<a name="l00190"></a>00190         new_me-&gt;me_portal = current_me-&gt;me_portal;
<a name="l00191"></a>00191         new_me-&gt;me_match_id = match_id;
<a name="l00192"></a>00192         new_me-&gt;me_match_bits = match_bits;
<a name="l00193"></a>00193         new_me-&gt;me_ignore_bits = ignore_bits;
<a name="l00194"></a>00194         new_me-&gt;me_unlink = unlink;
<a name="l00195"></a>00195         new_me-&gt;me_md = NULL;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         lnet_res_lh_initialize(the_lnet.ln_me_containers[cpt], &amp;new_me-&gt;me_lh);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         <span class="keywordflow">if</span> (pos == <a class="code" href="group__lnet__me.html#gga292319c5a5ed0c5718ce4edfd3aa1fb4a9c92e271885b81271fa1467f486dcd07" title="insert ME after current position or tail of the list">LNET_INS_AFTER</a>)
<a name="l00200"></a>00200                 list_add(&amp;new_me-&gt;me_list, &amp;current_me-&gt;me_list);
<a name="l00201"></a>00201         <span class="keywordflow">else</span>
<a name="l00202"></a>00202                 list_add_tail(&amp;new_me-&gt;me_list, &amp;current_me-&gt;me_list);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         lnet_me2handle(handle, new_me);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         lnet_res_unlock(cpt);
<a name="l00207"></a>00207 
<a name="l00208"></a>00208         <span class="keywordflow">return</span> 0;
<a name="l00209"></a>00209 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad38e0c2462a6e9a1735783c853345422"></a><!-- doxytag: member="api.h::LNetMEUnlink" ref="gad38e0c2462a6e9a1735783c853345422" args="(lnet_handle_me_t current_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetMEUnlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a>&nbsp;</td>
          <td class="paramname"> <em>meh</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlink a match entry from its match list. </p>
<p>This operation also releases any resources associated with the ME. If a memory descriptor is attached to the ME, then it will be unlinked as well and an unlink event will be generated. It is an error to use the ME handle after calling <a class="el" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list.">LNetMEUnlink()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>meh</em>&nbsp;</td><td>A handle for the ME to be unlinked.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>On success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If <em>meh</em> does not point to a valid ME. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink()</a> for the discussion on delivering unlink event. </dd></dl>

<p>Definition at line <a class="el" href="lib-me_8c_source.html#l00227">227</a> of file <a class="el" href="lib-me_8c_source.html">lib-me.c</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, <a class="el" href="niobuf_8c_source.html#l00301">ptlrpc_register_bulk()</a>, and <a class="el" href="niobuf_8c_source.html#l00900">ptlrpc_register_rqbd()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00228"></a>00228 {
<a name="l00229"></a>00229         <a class="code" href="structlnet__me.html">lnet_me_t</a>       *me;
<a name="l00230"></a>00230         <a class="code" href="structlnet__libmd.html">lnet_libmd_t</a>    *md;
<a name="l00231"></a>00231         <a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>    ev;
<a name="l00232"></a>00232         <span class="keywordtype">int</span>             cpt;
<a name="l00233"></a>00233 
<a name="l00234"></a>00234         LASSERT(the_lnet.ln_refcount &gt; 0);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         cpt = lnet_cpt_of_cookie(meh.cookie);
<a name="l00237"></a>00237         lnet_res_lock(cpt);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239         me = lnet_handle2me(&amp;meh);
<a name="l00240"></a>00240         <span class="keywordflow">if</span> (me == NULL) {
<a name="l00241"></a>00241                 lnet_res_unlock(cpt);
<a name="l00242"></a>00242                 <span class="keywordflow">return</span> -ENOENT;
<a name="l00243"></a>00243         }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245         md = me-&gt;me_md;
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (md != NULL) {
<a name="l00247"></a>00247                 md-&gt;md_flags |= LNET_MD_FLAG_ABORTED;
<a name="l00248"></a>00248                 <span class="keywordflow">if</span> (md-&gt;md_eq != NULL &amp;&amp; md-&gt;md_refcount == 0) {
<a name="l00249"></a>00249                         lnet_build_unlink_event(md, &amp;ev);
<a name="l00250"></a>00250                         lnet_eq_enqueue_event(md-&gt;md_eq, &amp;ev);
<a name="l00251"></a>00251                 }
<a name="l00252"></a>00252         }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254         lnet_me_unlink(me);
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         lnet_res_unlock(cpt);
<a name="l00257"></a>00257         <span class="keywordflow">return</span> 0;
<a name="l00258"></a>00258 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lnet__me_gad38e0c2462a6e9a1735783c853345422_icgraph.png" border="0" usemap="#group__lnet__me_gad38e0c2462a6e9a1735783c853345422_icgraph_map" alt=""></div>
<map name="group__lnet__me_gad38e0c2462a6e9a1735783c853345422_icgraph_map" id="group__lnet__me_gad38e0c2462a6e9a1735783c853345422_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="373,84,480,113"/><area shape="rect" id="node38" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Register bulk at the sender for later transfer." alt="" coords="169,109,324,139"/><area shape="rect" id="node41" href="group__net.html#gaf7557fc8aa34bbf889ee11612ece2315" title="Register request buffer descriptor for request receiving." alt="" coords="168,163,325,192"/><area shape="rect" id="node5" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="528,84,667,113"/><area shape="rect" id="node7" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="1089,56,1233,85"/><area shape="rect" id="node9" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="716,109,841,139"/><area shape="rect" id="node11" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="891,109,1037,139"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="1087,109,1236,139"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="1093,163,1229,192"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1287,109,1433,139"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1516,29,1636,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1484,83,1668,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1968,108,2211,137"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1505,187,1647,216"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1719,29,1919,59"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="2020,29,2159,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1717,83,1920,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2259,108,2435,137"/></map>
</div>
</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:47 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
