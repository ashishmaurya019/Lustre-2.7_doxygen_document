<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/include/lprocfs_status.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/include/lprocfs_status.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lustre/include/lprocfs_status.h</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Top level header file for LProc</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * Author: Hariharan Thantry thantry@users.sourceforge.net</span>
<a name="l00041"></a>00041 <span class="comment"> */</span>
<a name="l00042"></a>00042 <span class="preprocessor">#ifndef _LPROCFS_STATUS_H</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define _LPROCFS_STATUS_H</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;linux/fs.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;linux/proc_fs.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;linux/rwsem.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;linux/spinlock.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;linux/seq_file.h&gt;</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;lustre/lustre_idl.h&gt;</span>
<a name="l00052"></a>00052 
<a name="l00053"></a><a class="code" href="structlprocfs__vars.html">00053</a> <span class="keyword">struct </span><a class="code" href="structlprocfs__vars.html">lprocfs_vars</a> {
<a name="l00054"></a>00054         <span class="keyword">const</span> <span class="keywordtype">char</span>                      *name;
<a name="l00055"></a>00055         <span class="keyword">const</span> <span class="keyword">struct </span>file_operations    *fops;
<a name="l00056"></a>00056         <span class="keywordtype">void</span>                            *data;
<a name="l00060"></a><a class="code" href="structlprocfs__vars.html#a9d6db9022cb3bf75d466623d92e00c22">00060</a>         mode_t                           <a class="code" href="structlprocfs__vars.html#a9d6db9022cb3bf75d466623d92e00c22" title="/proc file mode.">proc_mode</a>;
<a name="l00061"></a>00061 };
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">/* if we find more consumers this could be generalized */</span>
<a name="l00064"></a>00064 <span class="preprocessor">#define OBD_HIST_MAX 32</span>
<a name="l00065"></a><a class="code" href="structobd__histogram.html">00065</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structobd__histogram.html">obd_histogram</a> {
<a name="l00066"></a>00066         spinlock_t      oh_lock;
<a name="l00067"></a>00067         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   oh_buckets[OBD_HIST_MAX];
<a name="l00068"></a>00068 };
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keyword">enum</span> {
<a name="l00071"></a>00071         BRW_R_PAGES = 0,
<a name="l00072"></a>00072         BRW_W_PAGES,
<a name="l00073"></a>00073         BRW_R_RPC_HIST,
<a name="l00074"></a>00074         BRW_W_RPC_HIST,
<a name="l00075"></a>00075         BRW_R_IO_TIME,
<a name="l00076"></a>00076         BRW_W_IO_TIME,
<a name="l00077"></a>00077         BRW_R_DISCONT_PAGES,
<a name="l00078"></a>00078         BRW_W_DISCONT_PAGES,
<a name="l00079"></a>00079         BRW_R_DISCONT_BLOCKS,
<a name="l00080"></a>00080         BRW_W_DISCONT_BLOCKS,
<a name="l00081"></a>00081         BRW_R_DISK_IOSIZE,
<a name="l00082"></a>00082         BRW_W_DISK_IOSIZE,
<a name="l00083"></a>00083         BRW_R_DIO_FRAGS,
<a name="l00084"></a>00084         BRW_W_DIO_FRAGS,
<a name="l00085"></a>00085         BRW_LAST,
<a name="l00086"></a>00086 };
<a name="l00087"></a>00087 
<a name="l00088"></a><a class="code" href="structbrw__stats.html">00088</a> <span class="keyword">struct </span><a class="code" href="structbrw__stats.html">brw_stats</a> {
<a name="l00089"></a>00089         <span class="keyword">struct </span><a class="code" href="structobd__histogram.html">obd_histogram</a> hist[BRW_LAST];
<a name="l00090"></a>00090 };
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="keyword">enum</span> {
<a name="l00093"></a>00093         RENAME_SAMEDIR_SIZE = 0,
<a name="l00094"></a>00094         RENAME_CROSSDIR_SRC_SIZE,
<a name="l00095"></a>00095         RENAME_CROSSDIR_TGT_SIZE,
<a name="l00096"></a>00096         RENAME_LAST,
<a name="l00097"></a>00097 };
<a name="l00098"></a>00098 
<a name="l00099"></a><a class="code" href="structrename__stats.html">00099</a> <span class="keyword">struct </span><a class="code" href="structrename__stats.html">rename_stats</a> {
<a name="l00100"></a>00100         <span class="keyword">struct </span><a class="code" href="structobd__histogram.html">obd_histogram</a> hist[RENAME_LAST];
<a name="l00101"></a>00101 };
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="comment">/* An lprocfs counter can be configured using the enum bit masks below.</span>
<a name="l00104"></a>00104 <span class="comment"> *</span>
<a name="l00105"></a>00105 <span class="comment"> * LPROCFS_CNTR_EXTERNALLOCK indicates that an external lock already</span>
<a name="l00106"></a>00106 <span class="comment"> * protects this counter from concurrent updates. If not specified,</span>
<a name="l00107"></a>00107 <span class="comment"> * lprocfs an internal per-counter lock variable. External locks are</span>
<a name="l00108"></a>00108 <span class="comment"> * not used to protect counter increments, but are used to protect</span>
<a name="l00109"></a>00109 <span class="comment"> * counter readout and resets.</span>
<a name="l00110"></a>00110 <span class="comment"> *</span>
<a name="l00111"></a>00111 <span class="comment"> * LPROCFS_CNTR_AVGMINMAX indicates a multi-valued counter samples,</span>
<a name="l00112"></a>00112 <span class="comment"> * (i.e. counter can be incremented by more than &quot;1&quot;). When specified,</span>
<a name="l00113"></a>00113 <span class="comment"> * the counter maintains min, max and sum in addition to a simple</span>
<a name="l00114"></a>00114 <span class="comment"> * invocation count. This allows averages to be be computed.</span>
<a name="l00115"></a>00115 <span class="comment"> * If not specified, the counter is an increment-by-1 counter.</span>
<a name="l00116"></a>00116 <span class="comment"> * min, max, sum, etc. are not maintained.</span>
<a name="l00117"></a>00117 <span class="comment"> *</span>
<a name="l00118"></a>00118 <span class="comment"> * LPROCFS_CNTR_STDDEV indicates that the counter should track sum of</span>
<a name="l00119"></a>00119 <span class="comment"> * squares (for multi-valued counter samples only). This allows</span>
<a name="l00120"></a>00120 <span class="comment"> * external computation of standard deviation, but involves a 64-bit</span>
<a name="l00121"></a>00121 <span class="comment"> * multiply per counter increment.</span>
<a name="l00122"></a>00122 <span class="comment"> */</span>
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="keyword">enum</span> {
<a name="l00125"></a>00125         LPROCFS_CNTR_EXTERNALLOCK = 0x0001,
<a name="l00126"></a>00126         LPROCFS_CNTR_AVGMINMAX    = 0x0002,
<a name="l00127"></a>00127         LPROCFS_CNTR_STDDEV       = 0x0004,
<a name="l00128"></a>00128 
<a name="l00129"></a>00129         <span class="comment">/* counter data type */</span>
<a name="l00130"></a>00130         LPROCFS_TYPE_REGS         = 0x0100,
<a name="l00131"></a>00131         LPROCFS_TYPE_BYTES        = 0x0200,
<a name="l00132"></a>00132         LPROCFS_TYPE_PAGES        = 0x0400,
<a name="l00133"></a>00133         LPROCFS_TYPE_CYCLE        = 0x0800,
<a name="l00134"></a>00134 };
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="preprocessor">#define LC_MIN_INIT ((~(__u64)0) &gt;&gt; 1)</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>
<a name="l00138"></a><a class="code" href="structlprocfs__counter__header.html">00138</a> <span class="keyword">struct </span><a class="code" href="structlprocfs__counter__header.html">lprocfs_counter_header</a> {
<a name="l00139"></a>00139         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lc_config;
<a name="l00140"></a>00140         <span class="keyword">const</span> <span class="keywordtype">char</span>              *lc_name;   <span class="comment">/* must be static */</span>
<a name="l00141"></a>00141         <span class="keyword">const</span> <span class="keywordtype">char</span>              *lc_units;  <span class="comment">/* must be static */</span>
<a name="l00142"></a>00142 };
<a name="l00143"></a>00143 
<a name="l00144"></a><a class="code" href="structlprocfs__counter.html">00144</a> <span class="keyword">struct </span><a class="code" href="structlprocfs__counter.html">lprocfs_counter</a> {
<a name="l00145"></a>00145         __s64   lc_count;
<a name="l00146"></a>00146         __s64   lc_min;
<a name="l00147"></a>00147         __s64   lc_max;
<a name="l00148"></a>00148         __s64   lc_sumsquare;
<a name="l00149"></a>00149         <span class="comment">/*</span>
<a name="l00150"></a>00150 <span class="comment">         * Every counter has lc_array_sum[0], while lc_array_sum[1] is only</span>
<a name="l00151"></a>00151 <span class="comment">         * for irq context counter, i.e. stats with</span>
<a name="l00152"></a>00152 <span class="comment">         * LPROCFS_STATS_FLAG_IRQ_SAFE flag, its counter need</span>
<a name="l00153"></a>00153 <span class="comment">         * lc_array_sum[1]</span>
<a name="l00154"></a>00154 <span class="comment">         */</span>
<a name="l00155"></a>00155         __s64   lc_array_sum[1];
<a name="l00156"></a>00156 };
<a name="l00157"></a>00157 <span class="preprocessor">#define lc_sum          lc_array_sum[0]</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor">#define lc_sum_irq      lc_array_sum[1]</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a><a class="code" href="structlprocfs__percpu.html">00160</a> <span class="keyword">struct </span><a class="code" href="structlprocfs__percpu.html">lprocfs_percpu</a> {
<a name="l00161"></a>00161         <span class="keyword">struct </span><a class="code" href="structlprocfs__counter.html">lprocfs_counter</a> lp_cntr[0];
<a name="l00162"></a>00162 };
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="keyword">enum</span> lprocfs_stats_lock_ops {
<a name="l00165"></a>00165         LPROCFS_GET_NUM_CPU     = 0x0001, <span class="comment">/* number allocated per-CPU stats */</span>
<a name="l00166"></a>00166         LPROCFS_GET_SMP_ID      = 0x0002, <span class="comment">/* current stat to be updated */</span>
<a name="l00167"></a>00167 };
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="keyword">enum</span> lprocfs_stats_flags {
<a name="l00170"></a>00170         LPROCFS_STATS_FLAG_NONE     = 0x0000, <span class="comment">/* per cpu counter */</span>
<a name="l00171"></a>00171         LPROCFS_STATS_FLAG_NOPERCPU = 0x0001, <span class="comment">/* stats have no percpu</span>
<a name="l00172"></a>00172 <span class="comment">                                               * area and need locking */</span>
<a name="l00173"></a>00173         LPROCFS_STATS_FLAG_IRQ_SAFE = 0x0002, <span class="comment">/* alloc need irq safe */</span>
<a name="l00174"></a>00174 };
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="keyword">enum</span> lprocfs_fields_flags {
<a name="l00177"></a>00177         LPROCFS_FIELDS_FLAGS_CONFIG     = 0x0001,
<a name="l00178"></a>00178         LPROCFS_FIELDS_FLAGS_SUM        = 0x0002,
<a name="l00179"></a>00179         LPROCFS_FIELDS_FLAGS_MIN        = 0x0003,
<a name="l00180"></a>00180         LPROCFS_FIELDS_FLAGS_MAX        = 0x0004,
<a name="l00181"></a>00181         LPROCFS_FIELDS_FLAGS_AVG        = 0x0005,
<a name="l00182"></a>00182         LPROCFS_FIELDS_FLAGS_SUMSQUARE  = 0x0006,
<a name="l00183"></a>00183         LPROCFS_FIELDS_FLAGS_COUNT      = 0x0007,
<a name="l00184"></a>00184 };
<a name="l00185"></a>00185 
<a name="l00186"></a><a class="code" href="structlprocfs__stats.html">00186</a> <span class="keyword">struct </span><a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> {
<a name="l00187"></a>00187         <span class="comment">/* # of counters */</span>
<a name="l00188"></a>00188         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>                  ls_num;
<a name="l00189"></a>00189         <span class="comment">/* 1 + the biggest cpu # whose ls_percpu slot has been allocated */</span>
<a name="l00190"></a>00190         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>                  ls_biggest_alloc_num;
<a name="l00191"></a>00191         <span class="keyword">enum</span> lprocfs_stats_flags        ls_flags;
<a name="l00192"></a>00192         <span class="comment">/* Lock used when there are no percpu stats areas; For percpu stats,</span>
<a name="l00193"></a>00193 <span class="comment">         * it is used to protect ls_biggest_alloc_num change */</span>
<a name="l00194"></a>00194         spinlock_t                      ls_lock;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         <span class="comment">/* has ls_num of counter headers */</span>
<a name="l00197"></a>00197         <span class="keyword">struct </span><a class="code" href="structlprocfs__counter__header.html">lprocfs_counter_header</a>   *ls_cnt_header;
<a name="l00198"></a>00198         <span class="keyword">struct </span><a class="code" href="structlprocfs__percpu.html">lprocfs_percpu</a>           *ls_percpu[0];
<a name="l00199"></a>00199 };
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="preprocessor">#define OPC_RANGE(seg) (seg ## _LAST_OPC - seg ## _FIRST_OPC)</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span>
<a name="l00203"></a>00203 <span class="comment">/* Pack all opcodes down into a single monotonically increasing index */</span>
<a name="l00204"></a>00204 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> opcode_offset(__u32 opc) {
<a name="l00205"></a>00205         <span class="keywordflow">if</span> (opc &lt; OST_LAST_OPC) {
<a name="l00206"></a>00206                  <span class="comment">/* OST opcode */</span>
<a name="l00207"></a>00207                 <span class="keywordflow">return</span> (opc - OST_FIRST_OPC);
<a name="l00208"></a>00208         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; MDS_LAST_OPC) {
<a name="l00209"></a>00209                 <span class="comment">/* MDS opcode */</span>
<a name="l00210"></a>00210                 <span class="keywordflow">return</span> (opc - MDS_FIRST_OPC +
<a name="l00211"></a>00211                         OPC_RANGE(OST));
<a name="l00212"></a>00212         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; LDLM_LAST_OPC) {
<a name="l00213"></a>00213                 <span class="comment">/* LDLM Opcode */</span>
<a name="l00214"></a>00214                 <span class="keywordflow">return</span> (opc - LDLM_FIRST_OPC +
<a name="l00215"></a>00215                         OPC_RANGE(MDS) +
<a name="l00216"></a>00216                         OPC_RANGE(OST));
<a name="l00217"></a>00217         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; MGS_LAST_OPC) {
<a name="l00218"></a>00218                 <span class="comment">/* MGS Opcode */</span>
<a name="l00219"></a>00219                 <span class="keywordflow">return</span> (opc - MGS_FIRST_OPC +
<a name="l00220"></a>00220                         OPC_RANGE(LDLM) +
<a name="l00221"></a>00221                         OPC_RANGE(MDS) +
<a name="l00222"></a>00222                         OPC_RANGE(OST));
<a name="l00223"></a>00223         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; OBD_LAST_OPC) {
<a name="l00224"></a>00224                 <span class="comment">/* OBD Ping */</span>
<a name="l00225"></a>00225                 <span class="keywordflow">return</span> (opc - OBD_FIRST_OPC +
<a name="l00226"></a>00226                         OPC_RANGE(MGS) +
<a name="l00227"></a>00227                         OPC_RANGE(LDLM) +
<a name="l00228"></a>00228                         OPC_RANGE(MDS) +
<a name="l00229"></a>00229                         OPC_RANGE(OST));
<a name="l00230"></a>00230         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; LLOG_LAST_OPC) {
<a name="l00231"></a>00231                 <span class="comment">/* LLOG Opcode */</span>
<a name="l00232"></a>00232                 <span class="keywordflow">return</span> (opc - LLOG_FIRST_OPC +
<a name="l00233"></a>00233                         OPC_RANGE(OBD) +
<a name="l00234"></a>00234                         OPC_RANGE(MGS) +
<a name="l00235"></a>00235                         OPC_RANGE(LDLM) +
<a name="l00236"></a>00236                         OPC_RANGE(MDS) +
<a name="l00237"></a>00237                         OPC_RANGE(OST));
<a name="l00238"></a>00238         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; QUOTA_LAST_OPC) {
<a name="l00239"></a>00239                 <span class="comment">/* LQUOTA Opcode */</span>
<a name="l00240"></a>00240                 <span class="keywordflow">return</span> (opc - QUOTA_FIRST_OPC +
<a name="l00241"></a>00241                         OPC_RANGE(LLOG) +
<a name="l00242"></a>00242                         OPC_RANGE(OBD) +
<a name="l00243"></a>00243                         OPC_RANGE(MGS) +
<a name="l00244"></a>00244                         OPC_RANGE(LDLM) +
<a name="l00245"></a>00245                         OPC_RANGE(MDS) +
<a name="l00246"></a>00246                         OPC_RANGE(OST));
<a name="l00247"></a>00247         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; SEQ_LAST_OPC) {
<a name="l00248"></a>00248                 <span class="comment">/* SEQ opcode */</span>
<a name="l00249"></a>00249                 <span class="keywordflow">return</span> (opc - SEQ_FIRST_OPC +
<a name="l00250"></a>00250                         OPC_RANGE(QUOTA) +
<a name="l00251"></a>00251                         OPC_RANGE(LLOG) +
<a name="l00252"></a>00252                         OPC_RANGE(OBD) +
<a name="l00253"></a>00253                         OPC_RANGE(MGS) +
<a name="l00254"></a>00254                         OPC_RANGE(LDLM) +
<a name="l00255"></a>00255                         OPC_RANGE(MDS) +
<a name="l00256"></a>00256                         OPC_RANGE(OST));
<a name="l00257"></a>00257         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; SEC_LAST_OPC) {
<a name="l00258"></a>00258                 <span class="comment">/* SEC opcode */</span>
<a name="l00259"></a>00259                 <span class="keywordflow">return</span> (opc - SEC_FIRST_OPC +
<a name="l00260"></a>00260                         OPC_RANGE(SEQ) +
<a name="l00261"></a>00261                         OPC_RANGE(QUOTA) +
<a name="l00262"></a>00262                         OPC_RANGE(LLOG) +
<a name="l00263"></a>00263                         OPC_RANGE(OBD) +
<a name="l00264"></a>00264                         OPC_RANGE(MGS) +
<a name="l00265"></a>00265                         OPC_RANGE(LDLM) +
<a name="l00266"></a>00266                         OPC_RANGE(MDS) +
<a name="l00267"></a>00267                         OPC_RANGE(OST));
<a name="l00268"></a>00268         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; FLD_LAST_OPC) {
<a name="l00269"></a>00269                 <span class="comment">/* FLD opcode */</span>
<a name="l00270"></a>00270                  <span class="keywordflow">return</span> (opc - FLD_FIRST_OPC +
<a name="l00271"></a>00271                         OPC_RANGE(SEC) +
<a name="l00272"></a>00272                         OPC_RANGE(SEQ) +
<a name="l00273"></a>00273                         OPC_RANGE(QUOTA) +
<a name="l00274"></a>00274                         OPC_RANGE(LLOG) +
<a name="l00275"></a>00275                         OPC_RANGE(OBD) +
<a name="l00276"></a>00276                         OPC_RANGE(MGS) +
<a name="l00277"></a>00277                         OPC_RANGE(LDLM) +
<a name="l00278"></a>00278                         OPC_RANGE(MDS) +
<a name="l00279"></a>00279                         OPC_RANGE(OST));
<a name="l00280"></a>00280         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; OUT_UPDATE_LAST_OPC) {
<a name="l00281"></a>00281                 <span class="comment">/* update opcode */</span>
<a name="l00282"></a>00282                 <span class="keywordflow">return</span> (opc - OUT_UPDATE_FIRST_OPC +
<a name="l00283"></a>00283                         OPC_RANGE(FLD) +
<a name="l00284"></a>00284                         OPC_RANGE(SEC) +
<a name="l00285"></a>00285                         OPC_RANGE(SEQ) +
<a name="l00286"></a>00286                         OPC_RANGE(QUOTA) +
<a name="l00287"></a>00287                         OPC_RANGE(LLOG) +
<a name="l00288"></a>00288                         OPC_RANGE(OBD) +
<a name="l00289"></a>00289                         OPC_RANGE(MGS) +
<a name="l00290"></a>00290                         OPC_RANGE(LDLM) +
<a name="l00291"></a>00291                         OPC_RANGE(MDS) +
<a name="l00292"></a>00292                         OPC_RANGE(OST));
<a name="l00293"></a>00293         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc &lt; LFSCK_LAST_OPC) {
<a name="l00294"></a>00294                 <span class="comment">/* LFSCK opcode */</span>
<a name="l00295"></a>00295                 <span class="keywordflow">return</span> (opc - LFSCK_FIRST_OPC +
<a name="l00296"></a>00296                         OPC_RANGE(OUT_UPDATE) +
<a name="l00297"></a>00297                         OPC_RANGE(FLD) +
<a name="l00298"></a>00298                         OPC_RANGE(SEC) +
<a name="l00299"></a>00299                         OPC_RANGE(SEQ) +
<a name="l00300"></a>00300                         OPC_RANGE(QUOTA) +
<a name="l00301"></a>00301                         OPC_RANGE(LLOG) +
<a name="l00302"></a>00302                         OPC_RANGE(OBD) +
<a name="l00303"></a>00303                         OPC_RANGE(MGS) +
<a name="l00304"></a>00304                         OPC_RANGE(LDLM) +
<a name="l00305"></a>00305                         OPC_RANGE(MDS) +
<a name="l00306"></a>00306                         OPC_RANGE(OST));
<a name="l00307"></a>00307         } <span class="keywordflow">else</span> {
<a name="l00308"></a>00308                 <span class="comment">/* Unknown Opcode */</span>
<a name="l00309"></a>00309                 <span class="keywordflow">return</span> -1;
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="preprocessor">#define LUSTRE_MAX_OPCODES (OPC_RANGE(OST)  + \</span>
<a name="l00315"></a>00315 <span class="preprocessor">                            OPC_RANGE(MDS)  + \</span>
<a name="l00316"></a>00316 <span class="preprocessor">                            OPC_RANGE(LDLM) + \</span>
<a name="l00317"></a>00317 <span class="preprocessor">                            OPC_RANGE(MGS)  + \</span>
<a name="l00318"></a>00318 <span class="preprocessor">                            OPC_RANGE(OBD)  + \</span>
<a name="l00319"></a>00319 <span class="preprocessor">                            OPC_RANGE(LLOG) + \</span>
<a name="l00320"></a>00320 <span class="preprocessor">                            OPC_RANGE(SEC)  + \</span>
<a name="l00321"></a>00321 <span class="preprocessor">                            OPC_RANGE(SEQ)  + \</span>
<a name="l00322"></a>00322 <span class="preprocessor">                            OPC_RANGE(SEC)  + \</span>
<a name="l00323"></a>00323 <span class="preprocessor">                            OPC_RANGE(FLD)  + \</span>
<a name="l00324"></a>00324 <span class="preprocessor">                            OPC_RANGE(OUT_UPDATE) + \</span>
<a name="l00325"></a>00325 <span class="preprocessor">                            OPC_RANGE(LFSCK))</span>
<a name="l00326"></a>00326 <span class="preprocessor"></span>
<a name="l00327"></a>00327 <span class="preprocessor">#define EXTRA_MAX_OPCODES ((PTLRPC_LAST_CNTR - PTLRPC_FIRST_CNTR)  + \</span>
<a name="l00328"></a>00328 <span class="preprocessor">                            OPC_RANGE(EXTRA))</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span>
<a name="l00330"></a>00330 <span class="keyword">enum</span> {
<a name="l00331"></a>00331         PTLRPC_REQWAIT_CNTR = 0,
<a name="l00332"></a>00332         PTLRPC_REQQDEPTH_CNTR,
<a name="l00333"></a>00333         PTLRPC_REQACTIVE_CNTR,
<a name="l00334"></a>00334         PTLRPC_TIMEOUT,
<a name="l00335"></a>00335         PTLRPC_REQBUF_AVAIL_CNTR,
<a name="l00336"></a>00336         PTLRPC_LAST_CNTR
<a name="l00337"></a>00337 };
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="preprocessor">#define PTLRPC_FIRST_CNTR PTLRPC_REQWAIT_CNTR</span>
<a name="l00340"></a>00340 <span class="preprocessor"></span>
<a name="l00341"></a>00341 <span class="keyword">enum</span> lprocfs_extra_opc {
<a name="l00342"></a>00342         LDLM_GLIMPSE_ENQUEUE = 0,
<a name="l00343"></a>00343         LDLM_PLAIN_ENQUEUE,
<a name="l00344"></a>00344         LDLM_EXTENT_ENQUEUE,
<a name="l00345"></a>00345         LDLM_FLOCK_ENQUEUE,
<a name="l00346"></a>00346         LDLM_IBITS_ENQUEUE,
<a name="l00347"></a>00347         MDS_REINT_SETATTR,
<a name="l00348"></a>00348         MDS_REINT_CREATE,
<a name="l00349"></a>00349         MDS_REINT_LINK,
<a name="l00350"></a>00350         MDS_REINT_UNLINK,
<a name="l00351"></a>00351         MDS_REINT_RENAME,
<a name="l00352"></a>00352         MDS_REINT_OPEN,
<a name="l00353"></a>00353         MDS_REINT_SETXATTR,
<a name="l00354"></a>00354         BRW_READ_BYTES,
<a name="l00355"></a>00355         BRW_WRITE_BYTES,
<a name="l00356"></a>00356         EXTRA_LAST_OPC
<a name="l00357"></a>00357 };
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="preprocessor">#define EXTRA_FIRST_OPC LDLM_GLIMPSE_ENQUEUE</span>
<a name="l00360"></a>00360 <span class="preprocessor"></span><span class="comment">/* class_obd.c */</span>
<a name="l00361"></a>00361 <span class="keyword">extern</span> <span class="keyword">struct </span>proc_dir_entry *proc_lustre_root;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a>;
<a name="l00364"></a>00364 <span class="keyword">struct </span><a class="code" href="structobd__histogram.html">obd_histogram</a>;
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 <span class="comment">/* Days / hours / mins / seconds format */</span>
<a name="l00367"></a><a class="code" href="structdhms.html">00367</a> <span class="keyword">struct </span><a class="code" href="structdhms.html">dhms</a> {
<a name="l00368"></a>00368         <span class="keywordtype">int</span> d,h,m,s;
<a name="l00369"></a>00369 };
<a name="l00370"></a>00370 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> s2dhms(<span class="keyword">struct</span> <a class="code" href="structdhms.html">dhms</a> *ts, time_t secs)
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372         ts-&gt;d = secs / 86400;
<a name="l00373"></a>00373         secs = secs % 86400;
<a name="l00374"></a>00374         ts-&gt;h = secs / 3600;
<a name="l00375"></a>00375         secs = secs % 3600;
<a name="l00376"></a>00376         ts-&gt;m = secs / 60;
<a name="l00377"></a>00377         ts-&gt;s = secs % 60;
<a name="l00378"></a>00378 }
<a name="l00379"></a>00379 <span class="preprocessor">#define DHMS_FMT &quot;%dd%dh%02dm%02ds&quot;</span>
<a name="l00380"></a>00380 <span class="preprocessor"></span><span class="preprocessor">#define DHMS_VARS(x) (x)-&gt;d, (x)-&gt;h, (x)-&gt;m, (x)-&gt;s</span>
<a name="l00381"></a>00381 <span class="preprocessor"></span>
<a name="l00382"></a>00382 <span class="preprocessor">#define JOBSTATS_JOBID_VAR_MAX_LEN      20</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span><span class="preprocessor">#define JOBSTATS_DISABLE                &quot;disable&quot;</span>
<a name="l00384"></a>00384 <span class="preprocessor"></span><span class="preprocessor">#define JOBSTATS_PROCNAME_UID           &quot;procname_uid&quot;</span>
<a name="l00385"></a>00385 <span class="preprocessor"></span><span class="preprocessor">#define JOBSTATS_NODELOCAL              &quot;nodelocal&quot;</span>
<a name="l00386"></a>00386 <span class="preprocessor"></span>
<a name="l00387"></a>00387 <span class="keyword">typedef</span> void (*cntr_init_callback)(<span class="keyword">struct </span><a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats);
<a name="l00388"></a>00388 
<a name="l00389"></a><a class="code" href="structobd__job__stats.html">00389</a> <span class="keyword">struct </span><a class="code" href="structobd__job__stats.html">obd_job_stats</a> {
<a name="l00390"></a>00390         <span class="keyword">struct </span><a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a>        *ojs_hash;       <span class="comment">/* hash of jobids */</span>
<a name="l00391"></a>00391         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        ojs_list;       <span class="comment">/* list of job_stat structs */</span>
<a name="l00392"></a>00392         rwlock_t                ojs_lock;       <span class="comment">/* protect ojs_list/js_list */</span>
<a name="l00393"></a>00393         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            ojs_cleanup_interval;<span class="comment">/* seconds before expiry */</span>
<a name="l00394"></a>00394         time_t                  ojs_last_cleanup; <span class="comment">/* previous cleanup time */</span>
<a name="l00395"></a>00395         cntr_init_callback      ojs_cntr_init_fn;<span class="comment">/* lprocfs_stats initializer */</span>
<a name="l00396"></a>00396         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>          ojs_cntr_num;   <span class="comment">/* number of stats in struct */</span>
<a name="l00397"></a>00397         <span class="keywordtype">bool</span>                    ojs_cleaning;   <span class="comment">/* currently expiring stats */</span>
<a name="l00398"></a>00398 };
<a name="l00399"></a>00399 
<a name="l00400"></a>00400 <span class="preprocessor">#ifdef CONFIG_PROC_FS</span>
<a name="l00401"></a>00401 <span class="preprocessor"></span>
<a name="l00402"></a>00402 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_stats_alloc_one(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats,
<a name="l00403"></a>00403                                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid);
<a name="l00404"></a>00404 
<a name="l00432"></a>00432 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_stats_lock(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats,
<a name="l00433"></a>00433                                      <span class="keyword">enum</span> lprocfs_stats_lock_ops opc,
<a name="l00434"></a>00434                                      <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *flags)
<a name="l00435"></a>00435 {
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (stats-&gt;ls_flags &amp; LPROCFS_STATS_FLAG_NOPERCPU) {
<a name="l00437"></a>00437                 <span class="keywordflow">if</span> (stats-&gt;ls_flags &amp; LPROCFS_STATS_FLAG_IRQ_SAFE)
<a name="l00438"></a>00438                         spin_lock_irqsave(&amp;stats-&gt;ls_lock, *flags);
<a name="l00439"></a>00439                 <span class="keywordflow">else</span>
<a name="l00440"></a>00440                         spin_lock(&amp;stats-&gt;ls_lock);
<a name="l00441"></a>00441                 <span class="keywordflow">return</span> opc == LPROCFS_GET_NUM_CPU ? 1 : 0;
<a name="l00442"></a>00442         }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444         <span class="keywordflow">switch</span> (opc) {
<a name="l00445"></a>00445         <span class="keywordflow">case</span> LPROCFS_GET_SMP_ID: {
<a name="l00446"></a>00446                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid = get_cpu();
<a name="l00447"></a>00447 
<a name="l00448"></a>00448                 <span class="keywordflow">if</span> (unlikely(stats-&gt;ls_percpu[cpuid] == NULL)) {
<a name="l00449"></a>00449                         <span class="keywordtype">int</span> rc = lprocfs_stats_alloc_one(stats, cpuid);
<a name="l00450"></a>00450                         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00451"></a>00451                                 put_cpu();
<a name="l00452"></a>00452                                 <span class="keywordflow">return</span> rc;
<a name="l00453"></a>00453                         }
<a name="l00454"></a>00454                 }
<a name="l00455"></a>00455                 <span class="keywordflow">return</span> cpuid;
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457         <span class="keywordflow">case</span> LPROCFS_GET_NUM_CPU:
<a name="l00458"></a>00458                 <span class="keywordflow">return</span> stats-&gt;ls_biggest_alloc_num;
<a name="l00459"></a>00459         <span class="keywordflow">default</span>:
<a name="l00460"></a>00460                 LBUG();
<a name="l00461"></a>00461         }
<a name="l00462"></a>00462 }
<a name="l00463"></a>00463 
<a name="l00477"></a>00477 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_stats_unlock(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats,
<a name="l00478"></a>00478                                         <span class="keyword">enum</span> lprocfs_stats_lock_ops opc,
<a name="l00479"></a>00479                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *flags)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481         <span class="keywordflow">if</span> (stats-&gt;ls_flags &amp; LPROCFS_STATS_FLAG_NOPERCPU) {
<a name="l00482"></a>00482                 <span class="keywordflow">if</span> (stats-&gt;ls_flags &amp; LPROCFS_STATS_FLAG_IRQ_SAFE)
<a name="l00483"></a>00483                         spin_unlock_irqrestore(&amp;stats-&gt;ls_lock, *flags);
<a name="l00484"></a>00484                 <span class="keywordflow">else</span>
<a name="l00485"></a>00485                         spin_unlock(&amp;stats-&gt;ls_lock);
<a name="l00486"></a>00486         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc == LPROCFS_GET_SMP_ID) {
<a name="l00487"></a>00487                 put_cpu();
<a name="l00488"></a>00488         }
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00492"></a>00492 lprocfs_stats_counter_size(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats)
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> percpusize;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496         percpusize = offsetof(<span class="keyword">struct</span> <a class="code" href="structlprocfs__percpu.html">lprocfs_percpu</a>, lp_cntr[stats-&gt;ls_num]);
<a name="l00497"></a>00497 
<a name="l00498"></a>00498         <span class="comment">/* irq safe stats need lc_array_sum[1] */</span>
<a name="l00499"></a>00499         <span class="keywordflow">if</span> ((stats-&gt;ls_flags &amp; LPROCFS_STATS_FLAG_IRQ_SAFE) != 0)
<a name="l00500"></a>00500                 percpusize += stats-&gt;ls_num * <span class="keyword">sizeof</span>(__s64);
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         <span class="keywordflow">if</span> ((stats-&gt;ls_flags &amp; LPROCFS_STATS_FLAG_NOPERCPU) == 0)
<a name="l00503"></a>00503                 percpusize = L1_CACHE_ALIGN(percpusize);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         <span class="keywordflow">return</span> percpusize;
<a name="l00506"></a>00506 }
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlprocfs__counter.html">lprocfs_counter</a> *
<a name="l00509"></a>00509 lprocfs_stats_counter_get(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid,
<a name="l00510"></a>00510                           <span class="keywordtype">int</span> index)
<a name="l00511"></a>00511 {
<a name="l00512"></a>00512         <span class="keyword">struct </span><a class="code" href="structlprocfs__counter.html">lprocfs_counter</a> *cntr;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         cntr = &amp;stats-&gt;ls_percpu[cpuid]-&gt;lp_cntr[index];
<a name="l00515"></a>00515 
<a name="l00516"></a>00516         <span class="keywordflow">if</span> ((stats-&gt;ls_flags &amp; LPROCFS_STATS_FLAG_IRQ_SAFE) != 0)
<a name="l00517"></a>00517                 cntr = (<span class="keywordtype">void</span> *)cntr + index * <span class="keyword">sizeof</span>(__s64);
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         <span class="keywordflow">return</span> cntr;
<a name="l00520"></a>00520 }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522 <span class="comment">/* Two optimized LPROCFS counter increment functions are provided:</span>
<a name="l00523"></a>00523 <span class="comment"> *     lprocfs_counter_incr(cntr, value) - optimized for by-one counters</span>
<a name="l00524"></a>00524 <span class="comment"> *     lprocfs_counter_add(cntr) - use for multi-valued counters</span>
<a name="l00525"></a>00525 <span class="comment"> * Counter data layout allows config flag, counter lock and the</span>
<a name="l00526"></a>00526 <span class="comment"> * count itself to reside within a single cache line.</span>
<a name="l00527"></a>00527 <span class="comment"> */</span>
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_counter_add(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats, <span class="keywordtype">int</span> idx,
<a name="l00530"></a>00530                                 <span class="keywordtype">long</span> amount);
<a name="l00531"></a>00531 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_counter_sub(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats, <span class="keywordtype">int</span> idx,
<a name="l00532"></a>00532                                 <span class="keywordtype">long</span> amount);
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 <span class="preprocessor">#define lprocfs_counter_incr(stats, idx) \</span>
<a name="l00535"></a>00535 <span class="preprocessor">        lprocfs_counter_add(stats, idx, 1)</span>
<a name="l00536"></a>00536 <span class="preprocessor"></span><span class="preprocessor">#define lprocfs_counter_decr(stats, idx) \</span>
<a name="l00537"></a>00537 <span class="preprocessor">        lprocfs_counter_sub(stats, idx, 1)</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span>
<a name="l00539"></a>00539 <span class="keyword">extern</span> __s64 lprocfs_read_helper(<span class="keyword">struct</span> <a class="code" href="structlprocfs__counter.html">lprocfs_counter</a> *lc,
<a name="l00540"></a>00540                                  <span class="keyword">struct</span> <a class="code" href="structlprocfs__counter__header.html">lprocfs_counter_header</a> *header,
<a name="l00541"></a>00541                                  <span class="keyword">enum</span> lprocfs_stats_flags flags,
<a name="l00542"></a>00542                                  <span class="keyword">enum</span> lprocfs_fields_flags field);
<a name="l00543"></a>00543 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 lprocfs_stats_collector(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats,
<a name="l00544"></a>00544                                             <span class="keywordtype">int</span> idx,
<a name="l00545"></a>00545                                             <span class="keyword">enum</span> lprocfs_fields_flags field)
<a name="l00546"></a>00546 {
<a name="l00547"></a>00547         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  i;
<a name="l00548"></a>00548         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  num_cpu;
<a name="l00549"></a>00549         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags     = 0;
<a name="l00550"></a>00550         __u64         ret       = 0;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         LASSERT(stats != NULL);
<a name="l00553"></a>00553 
<a name="l00554"></a>00554         num_cpu = lprocfs_stats_lock(stats, LPROCFS_GET_NUM_CPU, &amp;flags);
<a name="l00555"></a>00555         <span class="keywordflow">for</span> (i = 0; i &lt; num_cpu; i++) {
<a name="l00556"></a>00556                 <span class="keywordflow">if</span> (stats-&gt;ls_percpu[i] == NULL)
<a name="l00557"></a>00557                         <span class="keywordflow">continue</span>;
<a name="l00558"></a>00558                 ret += lprocfs_read_helper(
<a name="l00559"></a>00559                                 lprocfs_stats_counter_get(stats, i, idx),
<a name="l00560"></a>00560                                 &amp;stats-&gt;ls_cnt_header[idx], stats-&gt;ls_flags,
<a name="l00561"></a>00561                                 field);
<a name="l00562"></a>00562         }
<a name="l00563"></a>00563         lprocfs_stats_unlock(stats, LPROCFS_GET_NUM_CPU, &amp;flags);
<a name="l00564"></a>00564         <span class="keywordflow">return</span> ret;
<a name="l00565"></a>00565 }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *
<a name="l00568"></a>00568 lprocfs_alloc_stats(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num, <span class="keyword">enum</span> lprocfs_stats_flags flags);
<a name="l00569"></a>00569 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_clear_stats(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats);
<a name="l00570"></a>00570 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_free_stats(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> **stats);
<a name="l00571"></a>00571 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_init_ops_stats(<span class="keywordtype">int</span> num_private_stats,
<a name="l00572"></a>00572                                    <span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats);
<a name="l00573"></a>00573 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_init_mps_stats(<span class="keywordtype">int</span> num_private_stats,
<a name="l00574"></a>00574                                    <span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats);
<a name="l00575"></a>00575 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_init_ldlm_stats(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *ldlm_stats);
<a name="l00576"></a>00576 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_alloc_obd_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev,
<a name="l00577"></a>00577                                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_private_stats);
<a name="l00578"></a>00578 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_alloc_md_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev,
<a name="l00579"></a>00579                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_private_stats);
<a name="l00580"></a>00580 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_counter_init(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats, <span class="keywordtype">int</span> index,
<a name="l00581"></a>00581                                  <span class="keywordtype">unsigned</span> conf, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00582"></a>00582                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *units);
<a name="l00583"></a>00583 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_free_obd_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev);
<a name="l00584"></a>00584 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_free_md_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev);
<a name="l00585"></a>00585 <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>;
<a name="l00586"></a>00586 <span class="keyword">struct </span><a class="code" href="structnid__stat.html" title="per-NID statistics structure.">nid_stat</a>;
<a name="l00587"></a>00587 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_add_clear_entry(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> * obd,
<a name="l00588"></a>00588                                    <span class="keyword">struct</span> proc_dir_entry *entry);
<a name="l00589"></a>00589 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00590"></a>00590 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_exp_setup(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> *peer_nid);
<a name="l00591"></a>00591 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_exp_cleanup(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp);
<a name="l00592"></a>00592 <span class="preprocessor">#else</span>
<a name="l00593"></a>00593 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_exp_cleanup(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp)
<a name="l00594"></a>00594 { <span class="keywordflow">return</span> 0; }
<a name="l00595"></a>00595 <span class="preprocessor">#endif</span>
<a name="l00596"></a>00596 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keyword">struct </span>proc_dir_entry *
<a name="l00597"></a>00597 lprocfs_add_simple(<span class="keyword">struct</span> proc_dir_entry *root, <span class="keywordtype">char</span> *name,
<a name="l00598"></a>00598                    <span class="keywordtype">void</span> *data, <span class="keyword">const</span> <span class="keyword">struct</span> file_operations *fops);
<a name="l00599"></a>00599 <span class="keyword">extern</span> <span class="keyword">struct </span>proc_dir_entry *
<a name="l00600"></a>00600 lprocfs_add_symlink(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> proc_dir_entry *parent,
<a name="l00601"></a>00601                     <span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...);
<a name="l00602"></a>00602 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_free_per_client_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd);
<a name="l00603"></a>00603 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span><span class="keyword">extern</span> ssize_t
<a name="l00605"></a>00605 lprocfs_nid_stats_clear_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00606"></a>00606                                         <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00607"></a>00607 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_nid_stats_clear_seq_show(<span class="keyword">struct</span> seq_file *file, <span class="keywordtype">void</span> *data);
<a name="l00608"></a>00608 <span class="preprocessor">#endif</span>
<a name="l00609"></a>00609 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_register_stats(<span class="keyword">struct</span> proc_dir_entry *root, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00610"></a>00610                                   <span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats);
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="comment">/* lprocfs_status.c */</span>
<a name="l00613"></a>00613 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_add_vars(<span class="keyword">struct</span> proc_dir_entry *root,
<a name="l00614"></a>00614                             <span class="keyword">struct</span> <a class="code" href="structlprocfs__vars.html">lprocfs_vars</a> *var, <span class="keywordtype">void</span> *data);
<a name="l00615"></a>00615 <span class="keyword">extern</span> <span class="keyword">struct </span>proc_dir_entry *
<a name="l00616"></a>00616 lprocfs_register(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> proc_dir_entry *parent,
<a name="l00617"></a>00617                  <span class="keyword">struct</span> <a class="code" href="structlprocfs__vars.html">lprocfs_vars</a> *list, <span class="keywordtype">void</span> *data);
<a name="l00618"></a>00618 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_remove(<span class="keyword">struct</span> proc_dir_entry **root);
<a name="l00619"></a>00619 <span class="keyword">extern</span> <span class="keywordtype">void</span> lprocfs_remove_proc_entry(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00620"></a>00620                                       <span class="keyword">struct</span> proc_dir_entry *parent);
<a name="l00621"></a>00621 <span class="preprocessor">#ifndef HAVE_REMOVE_PROC_SUBTREE</span>
<a name="l00622"></a>00622 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> remove_proc_subtree(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00623"></a>00623                                <span class="keyword">struct</span> proc_dir_entry *parent);
<a name="l00624"></a>00624 <span class="preprocessor">#define PDE_DATA(inode)         (PDE(inode)-&gt;data)</span>
<a name="l00625"></a>00625 <span class="preprocessor"></span>
<a name="l00626"></a>00626 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> LPROCFS_ENTRY_CHECK(<span class="keyword">struct</span> inode *inode)
<a name="l00627"></a>00627 {
<a name="l00628"></a>00628         <span class="keyword">struct </span>proc_dir_entry *dp = PDE(inode);
<a name="l00629"></a>00629         <span class="keywordtype">int</span> deleted = 0;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631         spin_lock(&amp;(dp)-&gt;pde_unload_lock);
<a name="l00632"></a>00632         <span class="keywordflow">if</span> (dp-&gt;proc_fops == NULL)
<a name="l00633"></a>00633                 deleted = 1;
<a name="l00634"></a>00634         spin_unlock(&amp;(dp)-&gt;pde_unload_lock);
<a name="l00635"></a>00635         <span class="keywordflow">if</span> (deleted)
<a name="l00636"></a>00636                 <span class="keywordflow">return</span> -ENODEV;
<a name="l00637"></a>00637         <span class="keywordflow">return</span> 0;
<a name="l00638"></a>00638 }
<a name="l00639"></a>00639 <span class="preprocessor">#else</span>
<a name="l00640"></a>00640 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> LPROCFS_ENTRY_CHECK(<span class="keyword">struct</span> inode *inode)
<a name="l00641"></a>00641 { <span class="keywordflow">return</span> 0; }
<a name="l00642"></a>00642 <span class="preprocessor">#endif</span>
<a name="l00643"></a>00643 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_obd_setup(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *dev);
<a name="l00644"></a>00644 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_obd_cleanup(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd);
<a name="l00645"></a>00645 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00646"></a>00646 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>file_operations lprocfs_evict_client_fops;
<a name="l00647"></a>00647 <span class="preprocessor">#endif</span>
<a name="l00648"></a>00648 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_seq_create(<span class="keyword">struct</span> proc_dir_entry *parent, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00649"></a>00649                               mode_t mode,
<a name="l00650"></a>00650                               <span class="keyword">const</span> <span class="keyword">struct</span> file_operations *seq_fops,
<a name="l00651"></a>00651                               <span class="keywordtype">void</span> *data);
<a name="l00652"></a>00652 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_obd_seq_create(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *dev, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00653"></a>00653                                   mode_t mode,
<a name="l00654"></a>00654                                   <span class="keyword">const</span> <span class="keyword">struct</span> file_operations *seq_fops,
<a name="l00655"></a>00655                                   <span class="keywordtype">void</span> *data);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657 <span class="comment">/* Generic callbacks */</span>
<a name="l00658"></a>00658 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_u64_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00659"></a>00659 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_atomic_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00660"></a>00660 <span class="keyword">extern</span> ssize_t lprocfs_atomic_seq_write(<span class="keyword">struct</span> file *file,
<a name="l00661"></a>00661                                         <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00662"></a>00662                                         <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00663"></a>00663 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_uint_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00664"></a>00664 <span class="keyword">extern</span> ssize_t lprocfs_uint_seq_write(<span class="keyword">struct</span> file *file,
<a name="l00665"></a>00665                                       <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00666"></a>00666                                       <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00667"></a>00667 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_wr_uint(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00668"></a>00668                            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count, <span class="keywordtype">void</span> *data);
<a name="l00669"></a>00669 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_uuid_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00670"></a>00670 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_name_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00671"></a>00671 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_server_uuid_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00672"></a>00672 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_conn_uuid_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00673"></a>00673 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_import_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00674"></a>00674 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_state_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00675"></a>00675 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_connect_flags_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00676"></a>00676 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00677"></a>00677 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_num_exports_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00678"></a>00678 <span class="preprocessor">#endif</span>
<a name="l00679"></a>00679 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structadaptive__timeout.html">adaptive_timeout</a>;
<a name="l00680"></a>00680 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_at_hist_helper(<span class="keyword">struct</span> seq_file *m,
<a name="l00681"></a>00681                                   <span class="keyword">struct</span> <a class="code" href="structadaptive__timeout.html">adaptive_timeout</a> *at);
<a name="l00682"></a>00682 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_timeouts_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00683"></a>00683 <span class="keyword">extern</span> ssize_t
<a name="l00684"></a>00684 lprocfs_timeouts_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00685"></a>00685                            <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00686"></a>00686 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span><span class="keyword">extern</span> ssize_t
<a name="l00688"></a>00688 lprocfs_evict_client_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00689"></a>00689                                 <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00690"></a>00690 <span class="preprocessor">#endif</span>
<a name="l00691"></a>00691 <span class="preprocessor"></span><span class="keyword">extern</span> ssize_t
<a name="l00692"></a>00692 lprocfs_ping_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00693"></a>00693                        <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00694"></a>00694 <span class="keyword">extern</span> ssize_t
<a name="l00695"></a>00695 lprocfs_import_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00696"></a>00696                          <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00697"></a>00697 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_pinger_recov_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00698"></a>00698 <span class="keyword">extern</span> ssize_t
<a name="l00699"></a>00699 lprocfs_pinger_recov_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00700"></a>00700                                <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00701"></a>00701 
<a name="l00702"></a>00702 <span class="comment">/* Statfs helpers */</span>
<a name="l00703"></a>00703 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_blksize_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00704"></a>00704 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_kbytestotal_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00705"></a>00705 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_kbytesfree_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00706"></a>00706 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_kbytesavail_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00707"></a>00707 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_filestotal_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00708"></a>00708 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_filesfree_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00709"></a>00709 
<a name="l00710"></a>00710 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_seq_read_frac_helper(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">long</span> val, <span class="keywordtype">int</span> mult);
<a name="l00711"></a>00711 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_read_frac_helper(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count,
<a name="l00712"></a>00712                                     <span class="keywordtype">long</span> val, <span class="keywordtype">int</span> mult);
<a name="l00713"></a>00713 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_str_to_s64(<span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count,
<a name="l00714"></a>00714                               __s64 *val);
<a name="l00715"></a>00715 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_str_with_units_to_s64(<span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00716"></a>00716                                          <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count, __s64 *val,
<a name="l00717"></a>00717                                          <span class="keywordtype">char</span> defunit);
<a name="l00718"></a>00718 <span class="keywordtype">char</span> *lprocfs_find_named_value(<span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00719"></a>00719                                 <span class="keywordtype">size_t</span> *count);
<a name="l00720"></a>00720 <span class="keywordtype">void</span> lprocfs_oh_tally(<span class="keyword">struct</span> <a class="code" href="structobd__histogram.html">obd_histogram</a> *oh, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value);
<a name="l00721"></a>00721 <span class="keywordtype">void</span> lprocfs_oh_tally_log2(<span class="keyword">struct</span> <a class="code" href="structobd__histogram.html">obd_histogram</a> *oh, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value);
<a name="l00722"></a>00722 <span class="keywordtype">void</span> lprocfs_oh_clear(<span class="keyword">struct</span> <a class="code" href="structobd__histogram.html">obd_histogram</a> *oh);
<a name="l00723"></a>00723 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lprocfs_oh_sum(<span class="keyword">struct</span> <a class="code" href="structobd__histogram.html">obd_histogram</a> *oh);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 <span class="keywordtype">void</span> lprocfs_stats_collect(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats, <span class="keywordtype">int</span> idx,
<a name="l00726"></a>00726                            <span class="keyword">struct</span> <a class="code" href="structlprocfs__counter.html">lprocfs_counter</a> *cnt);
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00729"></a>00729 <span class="preprocessor"></span><span class="comment">/* lprocfs_status.c: recovery status */</span>
<a name="l00730"></a>00730 <span class="keywordtype">int</span> lprocfs_recovery_status_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732 <span class="comment">/* lprocfs_status.c: hash statistics */</span>
<a name="l00733"></a>00733 <span class="keywordtype">int</span> lprocfs_hash_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00734"></a>00734 
<a name="l00735"></a>00735 <span class="comment">/* lprocfs_status.c: IR factor */</span>
<a name="l00736"></a>00736 <span class="keywordtype">int</span> lprocfs_ir_factor_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00737"></a>00737 ssize_t
<a name="l00738"></a>00738 lprocfs_ir_factor_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00739"></a>00739                                 <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00740"></a>00740 <span class="preprocessor">#endif</span>
<a name="l00741"></a>00741 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_single_release(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);
<a name="l00742"></a>00742 <span class="keyword">extern</span> <span class="keywordtype">int</span> lprocfs_seq_release(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 <span class="comment">/* You must use these macros when you want to refer to</span>
<a name="l00745"></a>00745 <span class="comment"> * the import in a client obd_device for a lprocfs entry */</span>
<a name="l00746"></a>00746 <span class="preprocessor">#define LPROCFS_CLIMP_CHECK(obd) do {           \</span>
<a name="l00747"></a>00747 <span class="preprocessor">        typecheck(struct obd_device *, obd);    \</span>
<a name="l00748"></a>00748 <span class="preprocessor">        down_read(&amp;(obd)-&gt;u.cli.cl_sem);    \</span>
<a name="l00749"></a>00749 <span class="preprocessor">        if ((obd)-&gt;u.cli.cl_import == NULL) {   \</span>
<a name="l00750"></a>00750 <span class="preprocessor">             up_read(&amp;(obd)-&gt;u.cli.cl_sem); \</span>
<a name="l00751"></a>00751 <span class="preprocessor">             return -ENODEV;                    \</span>
<a name="l00752"></a>00752 <span class="preprocessor">        }                                       \</span>
<a name="l00753"></a>00753 <span class="preprocessor">} while(0)</span>
<a name="l00754"></a>00754 <span class="preprocessor"></span><span class="preprocessor">#define LPROCFS_CLIMP_EXIT(obd)                 \</span>
<a name="l00755"></a>00755 <span class="preprocessor">        up_read(&amp;(obd)-&gt;u.cli.cl_sem);</span>
<a name="l00756"></a>00756 <span class="preprocessor"></span>
<a name="l00757"></a>00757 <span class="comment">/* write the name##_seq_show function, call LPROC_SEQ_FOPS_RO for read-only</span>
<a name="l00758"></a>00758 <span class="comment">  proc entries; otherwise, you will define name##_seq_write function also for</span>
<a name="l00759"></a>00759 <span class="comment">  a read-write proc entry, and then call LPROC_SEQ_SEQ instead. Finally,</span>
<a name="l00760"></a>00760 <span class="comment">  call lprocfs_obd_seq_create(obd, filename, 0444, &amp;name#_fops, data); */</span>
<a name="l00761"></a>00761 <span class="preprocessor">#define __LPROC_SEQ_FOPS(name, custom_seq_write)                        \</span>
<a name="l00762"></a>00762 <span class="preprocessor">static int name##_single_open(struct inode *inode, struct file *file)   \</span>
<a name="l00763"></a>00763 <span class="preprocessor">{                                                                       \</span>
<a name="l00764"></a>00764 <span class="preprocessor">        int rc;                                                         \</span>
<a name="l00765"></a>00765 <span class="preprocessor">                                                                        \</span>
<a name="l00766"></a>00766 <span class="preprocessor">        rc = LPROCFS_ENTRY_CHECK(inode);                                \</span>
<a name="l00767"></a>00767 <span class="preprocessor">        if (rc &lt; 0)                                                     \</span>
<a name="l00768"></a>00768 <span class="preprocessor">                return rc;                                              \</span>
<a name="l00769"></a>00769 <span class="preprocessor">                                                                        \</span>
<a name="l00770"></a>00770 <span class="preprocessor">        return single_open(file, name##_seq_show, PDE_DATA(inode));     \</span>
<a name="l00771"></a>00771 <span class="preprocessor">}                                                                       \</span>
<a name="l00772"></a>00772 <span class="preprocessor">static const struct file_operations name##_fops = {                     \</span>
<a name="l00773"></a>00773 <span class="preprocessor">        .owner   = THIS_MODULE,                                         \</span>
<a name="l00774"></a>00774 <span class="preprocessor">        .open    = name##_single_open,                                  \</span>
<a name="l00775"></a>00775 <span class="preprocessor">        .read    = seq_read,                                            \</span>
<a name="l00776"></a>00776 <span class="preprocessor">        .write   = custom_seq_write,                                    \</span>
<a name="l00777"></a>00777 <span class="preprocessor">        .llseek  = seq_lseek,                                           \</span>
<a name="l00778"></a>00778 <span class="preprocessor">        .release = lprocfs_single_release,                              \</span>
<a name="l00779"></a>00779 <span class="preprocessor">}</span>
<a name="l00780"></a>00780 <span class="preprocessor"></span>
<a name="l00781"></a>00781 <span class="preprocessor">#define LPROC_SEQ_FOPS_RO(name)         __LPROC_SEQ_FOPS(name, NULL)</span>
<a name="l00782"></a>00782 <span class="preprocessor"></span><span class="preprocessor">#define LPROC_SEQ_FOPS(name)            __LPROC_SEQ_FOPS(name, name##_seq_write)</span>
<a name="l00783"></a>00783 <span class="preprocessor"></span>
<a name="l00784"></a>00784 <span class="preprocessor">#define LPROC_SEQ_FOPS_RO_TYPE(name, type)                              \</span>
<a name="l00785"></a>00785 <span class="preprocessor">        static int name##_##type##_seq_show(struct seq_file *m, void *v)\</span>
<a name="l00786"></a>00786 <span class="preprocessor">        {                                                               \</span>
<a name="l00787"></a>00787 <span class="preprocessor">                return lprocfs_##type##_seq_show(m, m-&gt;private);        \</span>
<a name="l00788"></a>00788 <span class="preprocessor">        }                                                               \</span>
<a name="l00789"></a>00789 <span class="preprocessor">        LPROC_SEQ_FOPS_RO(name##_##type)</span>
<a name="l00790"></a>00790 <span class="preprocessor"></span>
<a name="l00791"></a>00791 <span class="preprocessor">#define LPROC_SEQ_FOPS_RW_TYPE(name, type)                              \</span>
<a name="l00792"></a>00792 <span class="preprocessor">        static int name##_##type##_seq_show(struct seq_file *m, void *v)\</span>
<a name="l00793"></a>00793 <span class="preprocessor">        {                                                               \</span>
<a name="l00794"></a>00794 <span class="preprocessor">                return lprocfs_##type##_seq_show(m, m-&gt;private);        \</span>
<a name="l00795"></a>00795 <span class="preprocessor">        }                                                               \</span>
<a name="l00796"></a>00796 <span class="preprocessor">        static ssize_t name##_##type##_seq_write(struct file *file,     \</span>
<a name="l00797"></a>00797 <span class="preprocessor">                        const char __user *buffer, size_t count,        \</span>
<a name="l00798"></a>00798 <span class="preprocessor">                        loff_t *off)                                    \</span>
<a name="l00799"></a>00799 <span class="preprocessor">        {                                                               \</span>
<a name="l00800"></a>00800 <span class="preprocessor">                struct seq_file *seq = file-&gt;private_data;              \</span>
<a name="l00801"></a>00801 <span class="preprocessor">                return lprocfs_##type##_seq_write(file, buffer,         \</span>
<a name="l00802"></a>00802 <span class="preprocessor">                                                count, seq-&gt;private);   \</span>
<a name="l00803"></a>00803 <span class="preprocessor">        }                                                               \</span>
<a name="l00804"></a>00804 <span class="preprocessor">        LPROC_SEQ_FOPS(name##_##type);</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>
<a name="l00806"></a>00806 <span class="preprocessor">#define LPROC_SEQ_FOPS_WO_TYPE(name, type)                              \</span>
<a name="l00807"></a>00807 <span class="preprocessor">        static ssize_t name##_##type##_write(struct file *file,         \</span>
<a name="l00808"></a>00808 <span class="preprocessor">                        const char __user *buffer, size_t count,        \</span>
<a name="l00809"></a>00809 <span class="preprocessor">                        loff_t *off)                                    \</span>
<a name="l00810"></a>00810 <span class="preprocessor">        {                                                               \</span>
<a name="l00811"></a>00811 <span class="preprocessor">                return lprocfs_##type##_seq_write(file, buffer, count, off);\</span>
<a name="l00812"></a>00812 <span class="preprocessor">        }                                                               \</span>
<a name="l00813"></a>00813 <span class="preprocessor">        static int name##_##type##_open(struct inode *inode, struct file *file)\</span>
<a name="l00814"></a>00814 <span class="preprocessor">        {                                                               \</span>
<a name="l00815"></a>00815 <span class="preprocessor">                return single_open(file, NULL, PDE_DATA(inode));        \</span>
<a name="l00816"></a>00816 <span class="preprocessor">        }                                                               \</span>
<a name="l00817"></a>00817 <span class="preprocessor">        static const struct file_operations name##_##type##_fops = {    \</span>
<a name="l00818"></a>00818 <span class="preprocessor">                .open    = name##_##type##_open,                        \</span>
<a name="l00819"></a>00819 <span class="preprocessor">                .write   = name##_##type##_write,                       \</span>
<a name="l00820"></a>00820 <span class="preprocessor">                .release = lprocfs_single_release,                      \</span>
<a name="l00821"></a>00821 <span class="preprocessor">        };</span>
<a name="l00822"></a>00822 <span class="preprocessor"></span>
<a name="l00823"></a>00823 <span class="comment">/* lproc_ptlrpc.c */</span>
<a name="l00824"></a>00824 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>;
<a name="l00825"></a>00825 <span class="keyword">extern</span> <span class="keywordtype">void</span> target_print_req(<span class="keywordtype">void</span> *seq_file, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00826"></a>00826 
<a name="l00827"></a>00827 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00828"></a>00828 <span class="preprocessor"></span><span class="comment">/* lprocfs_jobstats.c */</span>
<a name="l00829"></a>00829 <span class="keywordtype">int</span> lprocfs_job_stats_log(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd, <span class="keywordtype">char</span> *jobid,
<a name="l00830"></a>00830                           <span class="keywordtype">int</span> event, <span class="keywordtype">long</span> amount);
<a name="l00831"></a>00831 <span class="keywordtype">void</span> lprocfs_job_stats_fini(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd);
<a name="l00832"></a>00832 <span class="keywordtype">int</span> lprocfs_job_stats_init(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd, <span class="keywordtype">int</span> cntr_num,
<a name="l00833"></a>00833                            cntr_init_callback fn);
<a name="l00834"></a>00834 <span class="keywordtype">int</span> lprocfs_job_interval_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00835"></a>00835 ssize_t
<a name="l00836"></a>00836 lprocfs_job_interval_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00837"></a>00837                                 <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00838"></a>00838 <span class="comment">/* lproc_status.c */</span>
<a name="l00839"></a>00839 <span class="keywordtype">int</span> lprocfs_recovery_time_soft_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00840"></a>00840 ssize_t lprocfs_recovery_time_soft_seq_write(<span class="keyword">struct</span> file *file,
<a name="l00841"></a>00841                                                 <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00842"></a>00842                                                 <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00843"></a>00843 <span class="keywordtype">int</span> lprocfs_recovery_time_hard_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00844"></a>00844 ssize_t
<a name="l00845"></a>00845 lprocfs_recovery_time_hard_seq_write(<span class="keyword">struct</span> file *file,
<a name="l00846"></a>00846                                      <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00847"></a>00847                                      <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00848"></a>00848 <span class="keywordtype">int</span> lprocfs_target_instance_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00849"></a>00849 <span class="preprocessor">#endif</span>
<a name="l00850"></a>00850 <span class="preprocessor"></span><span class="keywordtype">int</span> lprocfs_obd_max_pages_per_rpc_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data);
<a name="l00851"></a>00851 ssize_t
<a name="l00852"></a>00852 lprocfs_obd_max_pages_per_rpc_seq_write(<span class="keyword">struct</span> file *file,
<a name="l00853"></a>00853                                         <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00854"></a>00854                                         <span class="keywordtype">size_t</span> count, loff_t *off);
<a name="l00855"></a>00855 
<a name="l00856"></a>00856 <span class="keyword">struct </span><a class="code" href="structroot__squash__info.html">root_squash_info</a>;
<a name="l00857"></a>00857 <span class="keywordtype">int</span> lprocfs_wr_root_squash(<span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count,
<a name="l00858"></a>00858                            <span class="keyword">struct</span> <a class="code" href="structroot__squash__info.html">root_squash_info</a> *squash, <span class="keywordtype">char</span> *name);
<a name="l00859"></a>00859 <span class="keywordtype">int</span> lprocfs_wr_nosquash_nids(<span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count,
<a name="l00860"></a>00860                              <span class="keyword">struct</span> <a class="code" href="structroot__squash__info.html">root_squash_info</a> *squash, <span class="keywordtype">char</span> *name);
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="preprocessor">#else </span><span class="comment">/* !CONFIG_PROC_FS */</span>
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 <span class="preprocessor">#define proc_lustre_root NULL</span>
<a name="l00865"></a>00865 <span class="preprocessor"></span>
<a name="l00866"></a>00866 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_counter_add(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats,
<a name="l00867"></a>00867                                        <span class="keywordtype">int</span> index, <span class="keywordtype">long</span> amount)
<a name="l00868"></a>00868 { <span class="keywordflow">return</span>; }
<a name="l00869"></a>00869 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_counter_incr(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats,
<a name="l00870"></a>00870                                         <span class="keywordtype">int</span> index)
<a name="l00871"></a>00871 { <span class="keywordflow">return</span>; }
<a name="l00872"></a>00872 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_counter_sub(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats,
<a name="l00873"></a>00873                                        <span class="keywordtype">int</span> index, <span class="keywordtype">long</span> amount)
<a name="l00874"></a>00874 { <span class="keywordflow">return</span>; }
<a name="l00875"></a>00875 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_counter_decr(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats,
<a name="l00876"></a>00876                                         <span class="keywordtype">int</span> index)
<a name="l00877"></a>00877 { <span class="keywordflow">return</span>; }
<a name="l00878"></a>00878 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_counter_init(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats,
<a name="l00879"></a>00879                                         <span class="keywordtype">int</span> index, <span class="keywordtype">unsigned</span> conf,
<a name="l00880"></a>00880                                         <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
<a name="l00881"></a>00881 { <span class="keywordflow">return</span>; }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 lc_read_helper(<span class="keyword">struct</span> <a class="code" href="structlprocfs__counter.html">lprocfs_counter</a> *lc,
<a name="l00884"></a>00884                                    <span class="keyword">enum</span> lprocfs_fields_flags field)
<a name="l00885"></a>00885 { <span class="keywordflow">return</span> 0; }
<a name="l00886"></a>00886 
<a name="l00887"></a>00887 <span class="comment">/* NB: we return !NULL to satisfy error checker */</span>
<a name="l00888"></a>00888 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *
<a name="l00889"></a>00889 lprocfs_alloc_stats(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num, <span class="keyword">enum</span> lprocfs_stats_flags flags)
<a name="l00890"></a>00890 { <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *)1; }
<a name="l00891"></a>00891 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_clear_stats(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats)
<a name="l00892"></a>00892 { <span class="keywordflow">return</span>; }
<a name="l00893"></a>00893 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_free_stats(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> **stats)
<a name="l00894"></a>00894 { <span class="keywordflow">return</span>; }
<a name="l00895"></a>00895 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_register_stats(<span class="keyword">struct</span> proc_dir_entry *root,
<a name="l00896"></a>00896                                          <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00897"></a>00897                                          <span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats)
<a name="l00898"></a>00898 { <span class="keywordflow">return</span> 0; }
<a name="l00899"></a>00899 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_init_ops_stats(<span class="keywordtype">int</span> num_private_stats,
<a name="l00900"></a>00900                                           <span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats)
<a name="l00901"></a>00901 { <span class="keywordflow">return</span>; }
<a name="l00902"></a>00902 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_init_mps_stats(<span class="keywordtype">int</span> num_private_stats,
<a name="l00903"></a>00903                                           <span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats)
<a name="l00904"></a>00904 { <span class="keywordflow">return</span>; }
<a name="l00905"></a>00905 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_init_ldlm_stats(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *ldlm_stats)
<a name="l00906"></a>00906 { <span class="keywordflow">return</span>; }
<a name="l00907"></a>00907 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_alloc_obd_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev,
<a name="l00908"></a>00908                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_private_stats)
<a name="l00909"></a>00909 { <span class="keywordflow">return</span> 0; }
<a name="l00910"></a>00910 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_alloc_md_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev,
<a name="l00911"></a>00911                                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_private_stats)
<a name="l00912"></a>00912 { <span class="keywordflow">return</span> 0; }
<a name="l00913"></a>00913 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_free_obd_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev)
<a name="l00914"></a>00914 { <span class="keywordflow">return</span>; }
<a name="l00915"></a>00915 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_free_md_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev)
<a name="l00916"></a>00916 { <span class="keywordflow">return</span>; }
<a name="l00917"></a>00917 
<a name="l00918"></a>00918 <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>;
<a name="l00919"></a>00919 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_add_clear_entry(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp)
<a name="l00920"></a>00920 { <span class="keywordflow">return</span> 0; }
<a name="l00921"></a>00921 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_free_per_client_stats(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd)
<a name="l00922"></a>00922 { <span class="keywordflow">return</span>; }
<a name="l00923"></a>00923 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00924"></a>00924 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00925"></a>00925 ssize_t lprocfs_nid_stats_seq_write(<span class="keyword">struct</span> file *file,
<a name="l00926"></a>00926                                     <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00927"></a>00927                                     <span class="keywordtype">size_t</span> count, loff_t *off)
<a name="l00928"></a>00928 {<span class="keywordflow">return</span> 0;}
<a name="l00929"></a>00929 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00930"></a>00930 <span class="keywordtype">int</span> lprocfs_nid_stats_clear_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00931"></a>00931 {<span class="keywordflow">return</span> 0;}
<a name="l00932"></a>00932 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_exp_setup(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,<a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> *peer_nid)
<a name="l00933"></a>00933 { <span class="keywordflow">return</span> 0; }
<a name="l00934"></a>00934 <span class="preprocessor">#endif</span>
<a name="l00935"></a>00935 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_exp_cleanup(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp)
<a name="l00936"></a>00936 { <span class="keywordflow">return</span> 0; }
<a name="l00937"></a>00937 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>proc_dir_entry *
<a name="l00938"></a>00938 lprocfs_add_simple(<span class="keyword">struct</span> proc_dir_entry *root, <span class="keywordtype">char</span> *name,
<a name="l00939"></a>00939                    <span class="keywordtype">void</span> *data, <span class="keyword">const</span> <span class="keyword">struct</span> file_operations *fops)
<a name="l00940"></a>00940 {<span class="keywordflow">return</span> 0; }
<a name="l00941"></a>00941 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>proc_dir_entry *
<a name="l00942"></a>00942 lprocfs_add_symlink(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> proc_dir_entry *parent,
<a name="l00943"></a>00943                     <span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...)
<a name="l00944"></a>00944 {<span class="keywordflow">return</span> NULL; }
<a name="l00945"></a>00945 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_add_vars(<span class="keyword">struct</span> proc_dir_entry *root,
<a name="l00946"></a>00946                                    <span class="keyword">struct</span> <a class="code" href="structlprocfs__vars.html">lprocfs_vars</a> *var, <span class="keywordtype">void</span> *data)
<a name="l00947"></a>00947 { <span class="keywordflow">return</span> 0; }
<a name="l00948"></a>00948 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>proc_dir_entry *
<a name="l00949"></a>00949 lprocfs_register(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> proc_dir_entry *parent,
<a name="l00950"></a>00950                  <span class="keyword">struct</span> <a class="code" href="structlprocfs__vars.html">lprocfs_vars</a> *list, <span class="keywordtype">void</span> *data)
<a name="l00951"></a>00951 { <span class="keywordflow">return</span> NULL; }
<a name="l00952"></a>00952 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_remove(<span class="keyword">struct</span> proc_dir_entry **root)
<a name="l00953"></a>00953 { <span class="keywordflow">return</span>; }
<a name="l00954"></a>00954 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lprocfs_remove_proc_entry(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00955"></a>00955                                              <span class="keyword">struct</span> proc_dir_entry *parent)
<a name="l00956"></a>00956 { <span class="keywordflow">return</span>; }
<a name="l00957"></a>00957 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_obd_setup(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *dev)
<a name="l00958"></a>00958 { <span class="keywordflow">return</span> 0; }
<a name="l00959"></a>00959 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_obd_cleanup(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *dev)
<a name="l00960"></a>00960 { <span class="keywordflow">return</span> 0; }
<a name="l00961"></a>00961 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_uuid_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00962"></a>00962 { <span class="keywordflow">return</span> 0; }
<a name="l00963"></a>00963 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_name_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00964"></a>00964 { <span class="keywordflow">return</span> 0; }
<a name="l00965"></a>00965 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_server_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00966"></a>00966 { <span class="keywordflow">return</span> 0; }
<a name="l00967"></a>00967 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_conn_uuid_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00968"></a>00968 { <span class="keywordflow">return</span> 0; }
<a name="l00969"></a>00969 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_import_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00970"></a>00970 { <span class="keywordflow">return</span> 0; }
<a name="l00971"></a>00971 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_state_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00972"></a>00972 { <span class="keywordflow">return</span> 0; }
<a name="l00973"></a>00973 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_connect_flags_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00974"></a>00974 { <span class="keywordflow">return</span> 0; }
<a name="l00975"></a>00975 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00976"></a>00976 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_num_exports_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00977"></a>00977 { <span class="keywordflow">return</span> 0; }
<a name="l00978"></a>00978 <span class="preprocessor">#endif</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structadaptive__timeout.html">adaptive_timeout</a>;
<a name="l00980"></a>00980 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_at_hist_helper(<span class="keyword">struct</span> seq_file *m,
<a name="l00981"></a>00981                                          <span class="keyword">struct</span> <a class="code" href="structadaptive__timeout.html">adaptive_timeout</a> *at)
<a name="l00982"></a>00982 { <span class="keywordflow">return</span> 0; }
<a name="l00983"></a>00983 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lprocfs_timeouts_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l00984"></a>00984 { <span class="keywordflow">return</span> 0; }
<a name="l00985"></a>00985 <span class="keyword">static</span> <span class="keyword">inline</span> ssize_t
<a name="l00986"></a>00986 lprocfs_timeouts_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00987"></a>00987                            <span class="keywordtype">size_t</span> count, loff_t *off)
<a name="l00988"></a>00988 { <span class="keywordflow">return</span> 0; }
<a name="l00989"></a>00989 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00990"></a>00990 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> ssize_t
<a name="l00991"></a>00991 lprocfs_evict_client_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00992"></a>00992                                <span class="keywordtype">size_t</span> count, loff_t *off)
<a name="l00993"></a>00993 { <span class="keywordflow">return</span> 0; }
<a name="l00994"></a>00994 <span class="preprocessor">#endif</span>
<a name="l00995"></a>00995 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> ssize_t
<a name="l00996"></a>00996 lprocfs_ping_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l00997"></a>00997                        <span class="keywordtype">size_t</span> count, loff_t *off)
<a name="l00998"></a>00998 { <span class="keywordflow">return</span> 0; }
<a name="l00999"></a>00999 <span class="keyword">static</span> <span class="keyword">inline</span> ssize_t
<a name="l01000"></a>01000 lprocfs_import_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l01001"></a>01001                          <span class="keywordtype">size_t</span> count, loff_t *off)
<a name="l01002"></a>01002 { <span class="keywordflow">return</span> 0; }
<a name="l01003"></a>01003 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l01004"></a>01004 lprocfs_pinger_recov_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01005"></a>01005 { <span class="keywordflow">return</span> 0; }
<a name="l01006"></a>01006 <span class="keyword">static</span> <span class="keyword">inline</span> ssize_t
<a name="l01007"></a>01007 lprocfs_pinger_recov_seq_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l01008"></a>01008                                <span class="keywordtype">size_t</span> count, loff_t *off)
<a name="l01009"></a>01009 { <span class="keywordflow">return</span> 0; }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 <span class="comment">/* Statfs helpers */</span>
<a name="l01012"></a>01012 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01013"></a>01013 <span class="keywordtype">int</span> lprocfs_blksize_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01014"></a>01014 { <span class="keywordflow">return</span> 0; }
<a name="l01015"></a>01015 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01016"></a>01016 <span class="keywordtype">int</span> lprocfs_kbytestotal_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01017"></a>01017 { <span class="keywordflow">return</span> 0; }
<a name="l01018"></a>01018 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01019"></a>01019 <span class="keywordtype">int</span> lprocfs_kbytesfree_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01020"></a>01020 { <span class="keywordflow">return</span> 0; }
<a name="l01021"></a>01021 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01022"></a>01022 <span class="keywordtype">int</span> lprocfs_kbytesavail_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01023"></a>01023 { <span class="keywordflow">return</span> 0; }
<a name="l01024"></a>01024 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01025"></a>01025 <span class="keywordtype">int</span> lprocfs_filestotal_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01026"></a>01026 { <span class="keywordflow">return</span> 0; }
<a name="l01027"></a>01027 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01028"></a>01028 <span class="keywordtype">int</span> lprocfs_filesfree_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01029"></a>01029 { <span class="keywordflow">return</span> 0; }
<a name="l01030"></a>01030 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01031"></a>01031 <span class="keywordtype">void</span> lprocfs_oh_tally(<span class="keyword">struct</span> <a class="code" href="structobd__histogram.html">obd_histogram</a> *oh, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
<a name="l01032"></a>01032 { <span class="keywordflow">return</span>; }
<a name="l01033"></a>01033 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01034"></a>01034 <span class="keywordtype">void</span> lprocfs_oh_tally_log2(<span class="keyword">struct</span> <a class="code" href="structobd__histogram.html">obd_histogram</a> *oh, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
<a name="l01035"></a>01035 { <span class="keywordflow">return</span>; }
<a name="l01036"></a>01036 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01037"></a>01037 <span class="keywordtype">void</span> lprocfs_oh_clear(<span class="keyword">struct</span> <a class="code" href="structobd__histogram.html">obd_histogram</a> *oh)
<a name="l01038"></a>01038 { <span class="keywordflow">return</span>; }
<a name="l01039"></a>01039 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01040"></a>01040 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lprocfs_oh_sum(<span class="keyword">struct</span> <a class="code" href="structobd__histogram.html">obd_histogram</a> *oh)
<a name="l01041"></a>01041 { <span class="keywordflow">return</span> 0; }
<a name="l01042"></a>01042 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01043"></a>01043 <span class="keywordtype">void</span> lprocfs_stats_collect(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats, <span class="keywordtype">int</span> idx,
<a name="l01044"></a>01044                            <span class="keyword">struct</span> <a class="code" href="structlprocfs__counter.html">lprocfs_counter</a> *cnt)
<a name="l01045"></a>01045 { <span class="keywordflow">return</span>; }
<a name="l01046"></a>01046 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01047"></a>01047 __u64 lprocfs_stats_collector(<span class="keyword">struct</span> <a class="code" href="structlprocfs__stats.html">lprocfs_stats</a> *stats, <span class="keywordtype">int</span> idx,
<a name="l01048"></a>01048                                <span class="keyword">enum</span> lprocfs_fields_flags field)
<a name="l01049"></a>01049 { <span class="keywordflow">return</span> (__u64)0; }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 <span class="preprocessor">#define LPROC_SEQ_FOPS_RO(name)</span>
<a name="l01052"></a>01052 <span class="preprocessor"></span><span class="preprocessor">#define LPROC_SEQ_FOPS(name)</span>
<a name="l01053"></a>01053 <span class="preprocessor"></span><span class="preprocessor">#define LPROC_SEQ_FOPS_RO_TYPE(name, type)</span>
<a name="l01054"></a>01054 <span class="preprocessor"></span><span class="preprocessor">#define LPROC_SEQ_FOPS_RW_TYPE(name, type)</span>
<a name="l01055"></a>01055 <span class="preprocessor"></span><span class="preprocessor">#define LPROC_SEQ_FOPS_WO_TYPE(name, type)</span>
<a name="l01056"></a>01056 <span class="preprocessor"></span>
<a name="l01057"></a>01057 <span class="comment">/* lprocfs_jobstats.c */</span>
<a name="l01058"></a>01058 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01059"></a>01059 <span class="keywordtype">int</span> lprocfs_job_stats_log(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd, <span class="keywordtype">char</span> *jobid, <span class="keywordtype">int</span> event,
<a name="l01060"></a>01060                           <span class="keywordtype">long</span> amount)
<a name="l01061"></a>01061 { <span class="keywordflow">return</span> 0; }
<a name="l01062"></a>01062 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01063"></a>01063 <span class="keywordtype">void</span> lprocfs_job_stats_fini(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd)
<a name="l01064"></a>01064 { <span class="keywordflow">return</span>; }
<a name="l01065"></a>01065 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01066"></a>01066 <span class="keywordtype">int</span> lprocfs_job_stats_init(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd, <span class="keywordtype">int</span> cntr_num,
<a name="l01067"></a>01067                            cntr_init_callback fn)
<a name="l01068"></a>01068 { <span class="keywordflow">return</span> 0; }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 <span class="comment">/* lproc_ptlrpc.c */</span>
<a name="l01072"></a>01072 <span class="preprocessor">#define target_print_req NULL</span>
<a name="l01073"></a>01073 <span class="preprocessor"></span>
<a name="l01074"></a>01074 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PROC_FS */</span>
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="preprocessor">#endif </span><span class="comment">/* LPROCFS_STATUS_H */</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:13 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
