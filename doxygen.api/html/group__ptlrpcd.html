<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: PortalRPC daemon</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PortalRPC daemon</h1>
<p>ptlrpcd is a special thread with its own set where other user might add requests when they don't want to wait for their completion.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabda60744d497fcfe370cfd6b2d65c7ed"></a><!-- doxytag: member="ptlrpcd::DEBUG_SUBSYSTEM" ref="gabda60744d497fcfe370cfd6b2d65c7ed" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DEBUG_SUBSYSTEM</b>&nbsp;&nbsp;&nbsp;S_RPC</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04063a22d0ab5f2c0df443b03402f9fa"></a><!-- doxytag: member="ptlrpcd::module_param" ref="ga04063a22d0ab5f2c0df443b03402f9fa" args="(max_ptlrpcds, int, 0644)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>module_param</b> (max_ptlrpcds, int, 0644)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5d8f1182b8a0638f8c35a9e48c44f3db"></a><!-- doxytag: member="ptlrpcd::MODULE_PARM_DESC" ref="ga5d8f1182b8a0638f8c35a9e48c44f3db" args="(max_ptlrpcds,&quot;Max ptlrpcd thread count to be started.&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_PARM_DESC</b> (max_ptlrpcds,&quot;Max ptlrpcd thread count to be started.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1cff15935a0a23c6d5234d16a3a282d1"></a><!-- doxytag: member="ptlrpcd::module_param" ref="ga1cff15935a0a23c6d5234d16a3a282d1" args="(ptlrpcd_bind_policy, int, 0644)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>module_param</b> (ptlrpcd_bind_policy, int, 0644)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaace70b4794d14cf0451d150068a47ad6"></a><!-- doxytag: member="ptlrpcd::MODULE_PARM_DESC" ref="gaace70b4794d14cf0451d150068a47ad6" args="(ptlrpcd_bind_policy,&quot;Ptlrpcd threads binding mode (obsolete).&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_PARM_DESC</b> (ptlrpcd_bind_policy,&quot;Ptlrpcd threads binding mode (obsolete).&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga880b4abe7ea4dee766b81450cf56d06d"></a><!-- doxytag: member="ptlrpcd::MODULE_PARM_DESC" ref="ga880b4abe7ea4dee766b81450cf56d06d" args="(ptlrpcd_per_cpt_max,&quot;Max ptlrpcd thread count to be started per cpt.&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_PARM_DESC</b> (ptlrpcd_per_cpt_max,&quot;Max ptlrpcd thread count to be started per cpt.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05cb73fd5f563bdc305d09aa0c4c4f8f"></a><!-- doxytag: member="ptlrpcd::module_param" ref="ga05cb73fd5f563bdc305d09aa0c4c4f8f" args="(ptlrpcd_partner_group_size, int, 0644)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>module_param</b> (ptlrpcd_partner_group_size, int, 0644)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc465e27776c4c8e26953f06b831089f"></a><!-- doxytag: member="ptlrpcd::MODULE_PARM_DESC" ref="gadc465e27776c4c8e26953f06b831089f" args="(ptlrpcd_partner_group_size,&quot;Number of ptlrpcd threads in a partner group.&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_PARM_DESC</b> (ptlrpcd_partner_group_size,&quot;Number of ptlrpcd threads in a partner group.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6d81978a6dd9a0bcaefc3ce49d499dee"></a><!-- doxytag: member="ptlrpcd::module_param" ref="ga6d81978a6dd9a0bcaefc3ce49d499dee" args="(ptlrpcd_cpts, charp, 0644)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>module_param</b> (ptlrpcd_cpts, charp, 0644)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa7e8027b148e5cdf3e97c5b992cb656"></a><!-- doxytag: member="ptlrpcd::MODULE_PARM_DESC" ref="gafa7e8027b148e5cdf3e97c5b992cb656" args="(ptlrpcd_cpts,&quot;CPU partitions ptlrpcd threads should run in&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_PARM_DESC</b> (ptlrpcd_cpts,&quot;CPU partitions ptlrpcd threads should run in&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2acfae9e6349420190608a611125bb78"></a><!-- doxytag: member="ptlrpcd::ptlrpcd_wake" ref="ga2acfae9e6349420190608a611125bb78" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_wake</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ptlrpcd.html#ga8786798db7200aeedbfe4cd0a855232f">ptlrpcd_add_rqset</a> (struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move all request from an existing request set to the ptlrpcd queue.  <a href="#ga8786798db7200aeedbfe4cd0a855232f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8a1fd19f62cb6e52ee2b145c63f5dd1"></a><!-- doxytag: member="ptlrpcd::ptlrpcd_add_req" ref="gad8a1fd19f62cb6e52ee2b145c63f5dd1" args="(struct ptlrpc_request *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ptlrpcd.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1">ptlrpcd_add_req</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check-&gt;<a class="el" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies...">ptlrpc_check_set()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92e1290b388e5bd6c5ae97f5c753589a"></a><!-- doxytag: member="ptlrpcd::ptlrpcd_start" ref="ga92e1290b388e5bd6c5ae97f5c753589a" args="(struct ptlrpcd_ctl *pc)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_start</b> (struct <a class="el" href="structptlrpcd__ctl.html">ptlrpcd_ctl</a> *pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf6c0a253a44e1a561d3650cafa0aeab"></a><!-- doxytag: member="ptlrpcd::ptlrpcd_stop" ref="gadf6c0a253a44e1a561d3650cafa0aeab" args="(struct ptlrpcd_ctl *pc, int force)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_stop</b> (struct <a class="el" href="structptlrpcd__ctl.html">ptlrpcd_ctl</a> *pc, int force)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8ef02e8c2a1c0621b003d24cd5975c4"></a><!-- doxytag: member="ptlrpcd::ptlrpcd_free" ref="gad8ef02e8c2a1c0621b003d24cd5975c4" args="(struct ptlrpcd_ctl *pc)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_free</b> (struct <a class="el" href="structptlrpcd__ctl.html">ptlrpcd_ctl</a> *pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2b4cdaf9bce76784e8efa1f9bda8c58b"></a><!-- doxytag: member="ptlrpcd::ptlrpcd_addref" ref="ga2b4cdaf9bce76784e8efa1f9bda8c58b" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_addref</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54a4bcf408e22400c741b530bbb8ec06"></a><!-- doxytag: member="ptlrpcd::ptlrpcd_decref" ref="ga54a4bcf408e22400c741b530bbb8ec06" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_decref</b> (void)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7723c3e0086e4476292c06bb0fa8db00"></a><!-- doxytag: member="ptlrpcd::ptlrpcd_mutex" ref="ga7723c3e0086e4476292c06bb0fa8db00" args="" -->
struct mutex&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpcd_mutex</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>ptlrpcd is a special thread with its own set where other user might add requests when they don't want to wait for their completion. </p>
<p>PtlRPCD will take care of sending such requests and then processing their replies and calling completion callbacks as necessary. The callbacks are called directly from ptlrpcd context. It is important to never significantly block (esp. on RPCs!) within such completion handler or a deadlock might occur where ptlrpcd enters some callback that attempts to send another RPC and wait for it to return, during which time ptlrpcd is completely blocked, so e.g. if import fails, recovery cannot progress because connection requests are also sent by ptlrpcd. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8786798db7200aeedbfe4cd0a855232f"></a><!-- doxytag: member="ptlrpcd.c::ptlrpcd_add_rqset" ref="ga8786798db7200aeedbfe4cd0a855232f" args="(struct ptlrpc_request_set *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpcd_add_rqset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move all request from an existing request set to the ptlrpcd queue. </p>
<p>All requests from the set must be in phase RQ_PHASE_NEW. </p>

<p>Definition at line <a class="el" href="ptlrpcd_8c_source.html#l00200">200</a> of file <a class="el" href="ptlrpcd_8c_source.html">ptlrpcd.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01910">ptlrpcd_ctl::pc_npartners</a>, <a class="el" href="lustre__net_8h_source.html#l01906">ptlrpcd_ctl::pc_partners</a>, <a class="el" href="lustre__net_8h_source.html#l01886">ptlrpcd_ctl::pc_set</a>, <a class="el" href="lustre__net_8h_source.html#l01009">ptlrpc_request::rq_phase</a>, and <a class="el" href="lustre__net_8h_source.html#l00579">ptlrpc_request_set::set_waitq</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00201"></a>00201 {
<a name="l00202"></a>00202         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp, *pos;
<a name="l00203"></a>00203         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc;
<a name="l00204"></a>00204         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">new</span>;
<a name="l00205"></a>00205         <span class="keywordtype">int</span> count, i;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207         pc = ptlrpcd_select_pc(NULL);
<a name="l00208"></a>00208         <span class="keyword">new</span> = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         list_for_each_safe(pos, tmp, &amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>) {
<a name="l00211"></a>00211                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l00212"></a>00212                         list_entry(pos, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00213"></a>00213                                    rq_set_chain);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW);
<a name="l00216"></a>00216                 req-&gt;rq_set = <span class="keyword">new</span>;
<a name="l00217"></a>00217                 req-&gt;rq_queued_time = cfs_time_current();
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         spin_lock(&amp;new-&gt;set_new_req_lock);
<a name="l00221"></a>00221         list_splice_init(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>, &amp;new-&gt;set_new_requests);
<a name="l00222"></a>00222         i = atomic_read(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>);
<a name="l00223"></a>00223         count = atomic_add_return(i, &amp;new-&gt;set_new_count);
<a name="l00224"></a>00224         atomic_set(&amp;set-&gt;<a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>, 0);
<a name="l00225"></a>00225         spin_unlock(&amp;new-&gt;set_new_req_lock);
<a name="l00226"></a>00226         <span class="keywordflow">if</span> (count == i) {
<a name="l00227"></a>00227                 wake_up(&amp;new-&gt;set_waitq);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229                 <span class="comment">/* XXX: It maybe unnecessary to wakeup all the partners. But to</span>
<a name="l00230"></a>00230 <span class="comment">                 *      guarantee the async RPC can be processed ASAP, we have</span>
<a name="l00231"></a>00231 <span class="comment">                 *      no other better choice. It maybe fixed in future. */</span>
<a name="l00232"></a>00232                 <span class="keywordflow">for</span> (i = 0; i &lt; pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a>; i++)
<a name="l00233"></a>00233                         wake_up(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a>[i]-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>-&gt;<a class="code" href="structptlrpc__request__set.html#afa37e9803cad75f212925a762a9f6d7b" title="wait queue to wait on for request events">set_waitq</a>);
<a name="l00234"></a>00234         }
<a name="l00235"></a>00235 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:47 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
