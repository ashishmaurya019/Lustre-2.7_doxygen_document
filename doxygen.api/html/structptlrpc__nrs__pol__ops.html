<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: ptlrpc_nrs_pol_ops Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ptlrpc_nrs_pol_ops Struct Reference<br/>
<small>
[<a class="el" href="group__nrs.html">Network Request Scheduler</a>]</small>
</h1><!-- doxytag: class="ptlrpc_nrs_pol_ops" -->
<p>NRS policy operations.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ptlrpc_nrs_pol_ops:</div>
<div class="dynsection">
<div class="center"><img src="structptlrpc__nrs__pol__ops__coll__graph.png" border="0" usemap="#ptlrpc__nrs__pol__ops_coll__map" alt="Collaboration graph"/></div>
<map name="ptlrpc__nrs__pol__ops_coll__map" id="ptlrpc__nrs__pol__ops_coll__map">
<area shape="rect" id="node9" href="structptlrpc__nrs__pol__desc.html" title="NRS policy registering descriptor." alt="" coords="723,366,909,573"/><area shape="rect" id="node2" href="structptlrpc__nrs__request.html" title="NRS request." alt="" coords="992,1832,1139,2125"/><area shape="rect" id="node4" href="structptlrpc__nrs__resource.html" title="NRS resource." alt="" coords="751,1282,905,1385"/><area shape="rect" id="node7" href="structptlrpc__nrs__policy.html" title="NRS policy." alt="" coords="592,725,733,984"/><area shape="rect" id="node16" href="structptlrpc__nrs.html" title="NRS head." alt="" coords="401,1187,561,1480"/><area shape="rect" id="node12" href="structlist__head.html" title="{list_head\n|+ next\l+ prev\l|}" alt="" coords="516,101,599,203"/><area shape="rect" id="node19" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data." alt="" coords="311,1563,505,2394"/><area shape="rect" id="node24" href="structptlrpc__service.html" title="Definition of PortalRPC service." alt="" coords="877,2462,1083,2981"/><area shape="rect" id="node41" href="structptlrpc__at__array.html" title="{ptlrpc_at_array\n|+ paa_reqs_array\l+ paa_size\l+ paa_count\l+ paa_deadline\l+ paa_reqs_count\l|}" alt="" coords="161,1008,303,1163"/><area shape="rect" id="node45" href="structnrs__tbf__req.html" title="{nrs_tbf_req\n|+ tr_list\l+ tr_sequence\l|}" alt="" coords="1012,598,1132,701"/><area shape="rect" id="node60" href="structnrs__fifo__req.html" title="{nrs_fifo_req\n|+ fr_list\l+ fr_sequence\l|}" alt="" coords="888,598,1005,701"/><area shape="rect" id="node22" href="structadaptive__timeout.html" title="{adaptive_timeout\n|+ at_binstart\l+ at_hist\l+ at_flags\l+ at_current\l+ at_worst_ever\l+ at_worst_time\l+ at_lock\l|}" alt="" coords="43,1239,184,1428"/><area shape="rect" id="node27" href="structlprocfs__stats.html" title="{lprocfs_stats\n|+ ls_num\l+ ls_biggest_alloc_num\l+ ls_flags\l+ ls_lock\l+ ls_cnt_header\l+ ls_percpu\l|}" alt="" coords="1163,1893,1339,2065"/><area shape="rect" id="node29" href="structlprocfs__percpu.html" title="{lprocfs_percpu\n|+ lp_cntr\l|}" alt="" coords="1691,1291,1808,1376"/><area shape="rect" id="node31" href="structlprocfs__counter.html" title="{lprocfs_counter\n|+ lc_count\l+ lc_min\l+ lc_max\l+ lc_sumsquare\l+ lc_array_sum\l|}" alt="" coords="1687,777,1812,932"/><area shape="rect" id="node33" href="structlprocfs__counter__header.html" title="{lprocfs_counter_header\n|+ lc_config\l+ lc_name\l+ lc_units\l|}" alt="" coords="1488,1273,1667,1393"/><area shape="rect" id="node35" href="structptlrpc__service__ops.html" title="{ptlrpc_service_ops\n|+ so_thr_init\l+ so_thr_done\l+ so_req_handler\l+ so_hpreq_handler\l+ so_req_printer\l|}" alt="" coords="1363,1901,1515,2056"/><area shape="rect" id="node38" href="structcfs__cpt__table.html" title="{cfs_cpt_table\n|+ ctb_nparts\l+ ctb_mask\l+ ctb_nodemask\l+ ctb_version\l|}" alt="" coords="1539,1910,1672,2047"/><area shape="rect" id="node48" href="structnrs__crrn__req.html" title="CRR&#45;N NRS request definition." alt="" coords="1179,1282,1301,1385"/><area shape="rect" id="node50" href="structnrs__orr__req.html" title="ORR/TRR NRS request definition." alt="" coords="1325,1230,1464,1437"/><area shape="rect" id="node52" href="structnrs__orr__key.html" title="As unique keys for grouping RPCs together, we use the object&#39;s OST FID for the..." alt="" coords="1299,795,1397,915"/><area shape="rect" id="node54" href="structlu__fid.html" title="File IDentifier." alt="" coords="1312,409,1384,529"/><area shape="rect" id="node56" href="structnrs__orr__req__range.html" title="Lower and upper byte offsets of a brw RPC." alt="" coords="1421,803,1563,906"/><area shape="rect" id="node58" href="structcfs__binheap__node.html" title="Binary heap node." alt="" coords="585,1291,727,1376"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a569dc08f6db72425acb3af23817016b5">op_policy_init</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called during policy registration; this operation is optional.  <a href="#a569dc08f6db72425acb3af23817016b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a19f8bfc734d211149596592a8381e336">op_policy_fini</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called during policy unregistration; this operation is optional.  <a href="#a19f8bfc734d211149596592a8381e336"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a04b4479f93de2fbd7380f10ffaf5f35c">op_policy_start</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, char *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when activating a policy via lprocfs; policies allocate and initialize their resources here; this operation is optional.  <a href="#a04b4479f93de2fbd7380f10ffaf5f35c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a858a315f60b599de84db2cadfb9d6784">op_policy_stop</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when deactivating a policy via lprocfs; policies deallocate their resources here; this operation is optional.  <a href="#a858a315f60b599de84db2cadfb9d6784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#ad5e959465f0b9fd65ae096036df926d3">op_policy_ctl</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a> opc, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for policy-specific operations; i.e.  <a href="#ad5e959465f0b9fd65ae096036df926d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#affec8ac80f98364807dfe58e82fe4afe">op_res_get</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq, const struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *parent, struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> **resp, bool moving_req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when obtaining references to the resources of the resource hierarchy for a request that has arrived for handling at the PTLRPC service.  <a href="#affec8ac80f98364807dfe58e82fe4afe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a1fc1f744ceed9307e93dc3ad6f9f882b">op_res_put</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, const struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *res)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when releasing references taken for resources in the resource hierarchy for the request; this operation is optional.  <a href="#a1fc1f744ceed9307e93dc3ad6f9f882b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#ad7f082871c0f527c8d6b1c27c40a88e6">op_req_get</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, bool peek, bool force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains a request for handling from the policy, and optionally removes the request from the policy; this operation is mandatory.  <a href="#ad7f082871c0f527c8d6b1c27c40a88e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#ae4c73dc673c0175574a7eee691f846a2">op_req_enqueue</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when attempting to add a request to a policy for later handling; this operation is mandatory.  <a href="#ae4c73dc673c0175574a7eee691f846a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a1eb83c9a1da21c4090e85c6711dbf6d6">op_req_dequeue</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a request from the policy's set of pending requests.  <a href="#a1eb83c9a1da21c4090e85c6711dbf6d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#afda655439032cd5103c48bfdafa6d98a">op_req_stop</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called after the request being carried out.  <a href="#afda655439032cd5103c48bfdafa6d98a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#ad81393abaf1277b8fdebc3f67903c55a">op_lprocfs_init</a> )(struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers the policy's lprocfs interface with a PTLRPC service.  <a href="#ad81393abaf1277b8fdebc3f67903c55a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a4278270d8cf6849261467dd6a69bd19a">op_lprocfs_fini</a> )(struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unegisters the policy's lprocfs interface with a PTLRPC service.  <a href="#a4278270d8cf6849261467dd6a69bd19a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>NRS policy operations. </p>
<p>These determine the behaviour of a policy, and are called in response to NRS core events. </p>

<p>Definition at line <a class="el" href="lustre__nrs_8h_source.html#l00075">75</a> of file <a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a4278270d8cf6849261467dd6a69bd19a"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_lprocfs_fini" ref="a4278270d8cf6849261467dd6a69bd19a" args=")(struct ptlrpc_service *svc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a4278270d8cf6849261467dd6a69bd19a">ptlrpc_nrs_pol_ops::op_lprocfs_fini</a>)(struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unegisters the policy's lprocfs interface with a PTLRPC service. </p>
<p>In cases of failed policy registration in <em><a class="el" href="group__nrs.html#ga5de7e78460dcd401c48a46cf67ac9851" title="Registers a new policy with NRS core.">ptlrpc_nrs_policy_register()</a></em>, this function may be called for a service which has not registered the policy successfully, so implementations of this method should make sure their operations are safe in such cases.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svc</em>&nbsp;</td><td>The service </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad81393abaf1277b8fdebc3f67903c55a"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_lprocfs_init" ref="ad81393abaf1277b8fdebc3f67903c55a" args=")(struct ptlrpc_service *svc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#ad81393abaf1277b8fdebc3f67903c55a">ptlrpc_nrs_pol_ops::op_lprocfs_init</a>)(struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers the policy's lprocfs interface with a PTLRPC service. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svc</em>&nbsp;</td><td>The service</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>!=</em>&nbsp;</td><td>0 error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01165">ptlrpc_nrs_policy_register()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5e959465f0b9fd65ae096036df926d3"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_ctl" ref="ad5e959465f0b9fd65ae096036df926d3" args=")(struct ptlrpc_nrs_policy *policy, enum ptlrpc_nrs_ctl opc, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#ad5e959465f0b9fd65ae096036df926d3">ptlrpc_nrs_pol_ops::op_policy_ctl</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a> opc, void *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used for policy-specific operations; i.e. </p>
<p>not generic ones like <em>PTLRPC_NRS_CTL_START</em> and <em>PTLRPC_NRS_CTL_GET_INFO</em>; analogous to an ioctl; this operation is optional.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy carrying out operation <em>opc</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>opc</em>&nbsp;</td><td>The command operation being carried out </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>An generic buffer for communication between the user and the control operation</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ptlrpc_nrs_policy_control() </dd></dl>

</div>
</div>
<a class="anchor" id="a19f8bfc734d211149596592a8381e336"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_fini" ref="a19f8bfc734d211149596592a8381e336" args=")(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a19f8bfc734d211149596592a8381e336">ptlrpc_nrs_pol_ops::op_policy_fini</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called during policy unregistration; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy being unregistered/finalized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a569dc08f6db72425acb3af23817016b5"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_init" ref="a569dc08f6db72425acb3af23817016b5" args=")(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a569dc08f6db72425acb3af23817016b5">ptlrpc_nrs_pol_ops::op_policy_init</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called during policy registration; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy being initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04b4479f93de2fbd7380f10ffaf5f35c"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_start" ref="a04b4479f93de2fbd7380f10ffaf5f35c" args=")(struct ptlrpc_nrs_policy *policy, char *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a04b4479f93de2fbd7380f10ffaf5f35c">ptlrpc_nrs_pol_ops::op_policy_start</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, char *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when activating a policy via lprocfs; policies allocate and initialize their resources here; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy being started </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>A generic char buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>nrs_policy_start_locked() </dd></dl>

</div>
</div>
<a class="anchor" id="a858a315f60b599de84db2cadfb9d6784"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_stop" ref="a858a315f60b599de84db2cadfb9d6784" args=")(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a858a315f60b599de84db2cadfb9d6784">ptlrpc_nrs_pol_ops::op_policy_stop</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when deactivating a policy via lprocfs; policies deallocate their resources here; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy being stopped</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>nrs_policy_stop0() </dd></dl>

</div>
</div>
<a class="anchor" id="a1eb83c9a1da21c4090e85c6711dbf6d6"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_req_dequeue" ref="a1eb83c9a1da21c4090e85c6711dbf6d6" args=")(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_request *nrq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a1eb83c9a1da21c4090e85c6711dbf6d6">ptlrpc_nrs_pol_ops::op_req_dequeue</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a request from the policy's set of pending requests. </p>
<p>Normally called after a request has been polled successfully from the policy for handling; this operation is mandatory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy the request <em>nrq</em> belongs to </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>The request to dequeue</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ptlrpc_nrs_req_del_nolock() </dd></dl>

</div>
</div>
<a class="anchor" id="ae4c73dc673c0175574a7eee691f846a2"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_req_enqueue" ref="ae4c73dc673c0175574a7eee691f846a2" args=")(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_request *nrq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#ae4c73dc673c0175574a7eee691f846a2">ptlrpc_nrs_pol_ops::op_req_enqueue</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when attempting to add a request to a policy for later handling; this operation is mandatory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy on which to enqueue <em>nrq</em> </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>The request to enqueue</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>!=</em>&nbsp;</td><td>0 error</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ptlrpc_nrs_req_add_nolock() </dd></dl>

</div>
</div>
<a class="anchor" id="ad7f082871c0f527c8d6b1c27c40a88e6"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_req_get" ref="ad7f082871c0f527c8d6b1c27c40a88e6" args=")(struct ptlrpc_nrs_policy *policy, bool peek, bool force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a>*(* <a class="el" href="structptlrpc__nrs__pol__ops.html#ad7f082871c0f527c8d6b1c27c40a88e6">ptlrpc_nrs_pol_ops::op_req_get</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, bool peek, bool force)<code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a request for handling from the policy, and optionally removes the request from the policy; this operation is mandatory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy to poll </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peek</em>&nbsp;</td><td>When set, signifies that we just want to examine the request, and not handle it, so the request is not removed from the policy. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>When set, it will force a policy to return a request if it has one queued.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>No request available for handling </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valid-pointer</em>&nbsp;</td><td>The request polled for handling</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ptlrpc_nrs_req_get_nolock() </dd></dl>

</div>
</div>
<a class="anchor" id="afda655439032cd5103c48bfdafa6d98a"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_req_stop" ref="afda655439032cd5103c48bfdafa6d98a" args=")(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_request *nrq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#afda655439032cd5103c48bfdafa6d98a">ptlrpc_nrs_pol_ops::op_req_stop</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called after the request being carried out. </p>
<p>Could be used for job/resource control; this operation is optional.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy which is stopping to handle request <em>nrq</em> </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>The request</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>assert_spin_locked(&amp;svcpt-&gt;scp_req_lock)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ptlrpc_nrs_req_stop_nolock() </dd></dl>

</div>
</div>
<a class="anchor" id="affec8ac80f98364807dfe58e82fe4afe"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_res_get" ref="affec8ac80f98364807dfe58e82fe4afe" args=")(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_request *nrq, const struct ptlrpc_nrs_resource *parent, struct ptlrpc_nrs_resource **resp, bool moving_req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#affec8ac80f98364807dfe58e82fe4afe">ptlrpc_nrs_pol_ops::op_res_get</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq, const struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *parent, struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> **resp, bool moving_req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when obtaining references to the resources of the resource hierarchy for a request that has arrived for handling at the PTLRPC service. </p>
<p>Policies should return -ve for requests they do not wish to handle. This operation is mandatory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy we're getting resources for. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>The request we are getting resources for. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parent</em>&nbsp;</td><td>The parent resource of the resource being requested; set to NULL if none. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>resp</em>&nbsp;</td><td>The resource is to be returned here; the fallback policy in an NRS head should <em>always</em> return a non-NULL pointer value. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>moving_req</em>&nbsp;</td><td>When set, signifies that this is an attempt to obtain resources for a request being moved to the high-priority NRS head by ldlm_lock_reorder_req(). This implies two things: 1. We are under <a class="el" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">obd_export::exp_rpc_lock</a> and so should not sleep. 2. We should not perform non-idempotent or can skip performing idempotent operations that were carried out when resources were first taken for the request when it was initialized in ptlrpc_nrs_req_initialize().</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0,+ve</em>&nbsp;</td><td>The level of the returned resource in the resource hierarchy; currently only 0 (for a non-leaf resource) and 1 (for a leaf resource) are supported by the framework. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ptlrpc_nrs_req_initialize() </dd>
<dd>
ptlrpc_nrs_hpreq_add_nolock() </dd>
<dd>
<a class="el" href="group__nrs.html#gae517dc74ee0bcadf3b53f6ed4c57e6de" title="Moves request req from the regular to the high-priority NRS head.">ptlrpc_nrs_req_hp_move()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1fc1f744ceed9307e93dc3ad6f9f882b"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_res_put" ref="a1fc1f744ceed9307e93dc3ad6f9f882b" args=")(struct ptlrpc_nrs_policy *policy, const struct ptlrpc_nrs_resource *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a1fc1f744ceed9307e93dc3ad6f9f882b">ptlrpc_nrs_pol_ops::op_res_put</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, const struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *res)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when releasing references taken for resources in the resource hierarchy for the request; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy the resource belongs to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>res</em>&nbsp;</td><td>The resource to be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ptlrpc_nrs_req_finalize() </dd>
<dd>
ptlrpc_nrs_hpreq_add_nolock() </dd>
<dd>
<a class="el" href="group__nrs.html#gae517dc74ee0bcadf3b53f6ed4c57e6de" title="Moves request req from the regular to the high-priority NRS head.">ptlrpc_nrs_req_hp_move()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 21:06:40 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
