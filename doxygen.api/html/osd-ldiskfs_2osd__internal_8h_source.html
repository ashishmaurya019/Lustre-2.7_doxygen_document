<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/osd-ldiskfs/osd_internal.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/osd-ldiskfs/osd_internal.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lustre/osd/osd_internal.h</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Shared definitions and declarations for osd module</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * Author: Nikita Danilov &lt;nikita@clusterfs.com&gt;</span>
<a name="l00041"></a>00041 <span class="comment"> */</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#ifndef _OSD_INTERNAL_H</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#define _OSD_INTERNAL_H</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">/* struct mutex */</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;linux/mutex.h&gt;</span>
<a name="l00049"></a>00049 <span class="comment">/* struct rw_semaphore */</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;linux/rwsem.h&gt;</span>
<a name="l00051"></a>00051 <span class="comment">/* struct dentry */</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;linux/dcache.h&gt;</span>
<a name="l00053"></a>00053 <span class="comment">/* struct dirent64 */</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;linux/dirent.h&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;linux/statfs.h&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;ldiskfs/ldiskfs.h&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;ldiskfs/ldiskfs_jbd2.h&gt;</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="comment">/* LUSTRE_OSD_NAME */</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;obd.h&gt;</span>
<a name="l00061"></a>00061 <span class="comment">/* class_register_type(), class_unregister_type(), class_get_type() */</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &lt;lustre_disk.h&gt;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;dt_object.h&gt;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;lustre_quota.h&gt;</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;osd_oi.h&quot;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &quot;osd_iam.h&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &quot;osd_scrub.h&quot;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &quot;osd_quota_fmt.h&quot;</span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keyword">struct </span>inode;
<a name="l00073"></a>00073 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *dynlock_cachep;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="preprocessor">#define OSD_COUNTERS (0)</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span>
<a name="l00077"></a>00077 <span class="comment">/* ldiskfs special inode::i_state_flags need to be accessed with</span>
<a name="l00078"></a>00078 <span class="comment"> * ldiskfs_{set,clear,test}_inode_state() only */</span>
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="comment">/* OI scrub should skip this inode. */</span>
<a name="l00081"></a>00081 <span class="preprocessor">#define LDISKFS_STATE_LUSTRE_NOSCRUB    31</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#define LDISKFS_STATE_LUSTRE_DESTROY    30</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00085"></a>00085 <span class="preprocessor">#define OSD_THANDLE_STATS (0)</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00087"></a>00087 <span class="preprocessor">#define MAX_OBJID_GROUP (FID_SEQ_ECHO + 1)</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span>
<a name="l00089"></a>00089 <span class="preprocessor">#define OBJECTS         &quot;OBJECTS&quot;</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#define ADMIN_USR       &quot;admin_quotafile_v2.usr&quot;</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#define ADMIN_GRP       &quot;admin_quotafile_v2.grp&quot;</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="comment">/* Statfs space reservation for fragmentation and local objects */</span>
<a name="l00094"></a>00094 <span class="preprocessor">#define OSD_STATFS_RESERVED             (1ULL &lt;&lt; 23) </span><span class="comment">/* 8MB */</span>
<a name="l00095"></a>00095 <span class="preprocessor">#define OSD_STATFS_RESERVED_SHIFT       (7) </span><span class="comment">/* reserve 0.78% of all space */</span>
<a name="l00096"></a>00096 
<a name="l00097"></a><a class="code" href="structosd__directory.html">00097</a> <span class="keyword">struct </span><a class="code" href="structosd__directory.html">osd_directory</a> {
<a name="l00098"></a>00098         <span class="keyword">struct </span><a class="code" href="structiam__container.html">iam_container</a> od_container;
<a name="l00099"></a>00099         <span class="keyword">struct </span><a class="code" href="structiam__descr.html">iam_descr</a>     od_descr;
<a name="l00100"></a>00100 };
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">/*</span>
<a name="l00103"></a>00103 <span class="comment"> * Object Index (oi) instance.</span>
<a name="l00104"></a>00104 <span class="comment"> */</span>
<a name="l00105"></a><a class="code" href="structosd__oi.html">00105</a> <span class="keyword">struct </span><a class="code" href="structosd__oi.html">osd_oi</a> {
<a name="l00106"></a>00106         <span class="comment">/*</span>
<a name="l00107"></a>00107 <span class="comment">         * underlying index object, where fid-&gt;id mapping in stored.</span>
<a name="l00108"></a>00108 <span class="comment">         */</span>
<a name="l00109"></a>00109         <span class="keyword">struct </span>inode         *oi_inode;
<a name="l00110"></a>00110         <span class="keyword">struct </span><a class="code" href="structosd__directory.html">osd_directory</a>  oi_dir;
<a name="l00111"></a>00111 };
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">int</span> osd_dto_credits_noquota[];
<a name="l00114"></a>00114 
<a name="l00115"></a><a class="code" href="structosd__object.html">00115</a> <span class="keyword">struct </span><a class="code" href="structosd__object.html">osd_object</a> {
<a name="l00116"></a>00116         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        oo_dt;
<a name="l00124"></a><a class="code" href="structosd__object.html#ae81e0028f4f47ba8d7bebb5f2d983e12">00124</a>         <span class="keyword">struct </span>inode           *<a class="code" href="structosd__object.html#ae81e0028f4f47ba8d7bebb5f2d983e12" title="Inode for file system object represented by this osd_object.">oo_inode</a>;
<a name="l00128"></a><a class="code" href="structosd__object.html#afc444003c6cfdb46eccb634274606301">00128</a>         <span class="keyword">struct </span>htree_lock_head *<a class="code" href="structosd__object.html#afc444003c6cfdb46eccb634274606301" title="to protect index ops.">oo_hl_head</a>;
<a name="l00129"></a>00129         <span class="keyword">struct </span>rw_semaphore     oo_ext_idx_sem;
<a name="l00130"></a>00130         <span class="keyword">struct </span>rw_semaphore     oo_sem;
<a name="l00131"></a>00131         <span class="keyword">struct </span><a class="code" href="structosd__directory.html">osd_directory</a>    *oo_dir;
<a name="l00133"></a><a class="code" href="structosd__object.html#a0ae5bff884db9403b755de08f7482754">00133</a>         spinlock_t              <a class="code" href="structosd__object.html#a0ae5bff884db9403b755de08f7482754" title="protects inode attributes.">oo_guard</a>;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135         __u32                   oo_destroyed:1;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         <span class="comment">/* the i_flags in LMA */</span>
<a name="l00138"></a>00138         __u32                   oo_lma_flags;
<a name="l00144"></a><a class="code" href="structosd__object.html#a26b2ea0f78f471d664ba28f67fc246a0">00144</a>         <span class="keywordtype">int</span>                     <a class="code" href="structosd__object.html#a26b2ea0f78f471d664ba28f67fc246a0" title="Following two members are used to indicate the presence of dot and dotdot in the...">oo_compat_dot_created</a>;
<a name="l00145"></a>00145         <span class="keywordtype">int</span>                     oo_compat_dotdot_created;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>    *oo_owner;
<a name="l00148"></a>00148 <span class="preprocessor">#ifdef CONFIG_LOCKDEP</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span>        <span class="keyword">struct </span>lockdep_map      oo_dep_map;
<a name="l00150"></a>00150 <span class="preprocessor">#endif</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span>};
<a name="l00152"></a>00152 
<a name="l00153"></a><a class="code" href="structosd__obj__seq.html">00153</a> <span class="keyword">struct </span><a class="code" href="structosd__obj__seq.html">osd_obj_seq</a> {
<a name="l00154"></a>00154         <span class="comment">/* protects on-fly initialization */</span>
<a name="l00155"></a>00155         <span class="keywordtype">int</span>              oos_subdir_count; <span class="comment">/* subdir count for each seq */</span>
<a name="l00156"></a>00156         <span class="keyword">struct </span>dentry    *oos_root;        <span class="comment">/* O/&lt;seq&gt; */</span>
<a name="l00157"></a>00157         <span class="keyword">struct </span>dentry    **oos_dirs;       <span class="comment">/* O/&lt;seq&gt;/d0-dXX */</span>
<a name="l00158"></a>00158         u64              oos_seq;          <span class="comment">/* seq number */</span>
<a name="l00159"></a>00159         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> oos_seq_list;     <span class="comment">/* list to seq_list */</span>
<a name="l00160"></a>00160 };
<a name="l00161"></a>00161 
<a name="l00162"></a><a class="code" href="structosd__obj__map.html">00162</a> <span class="keyword">struct </span><a class="code" href="structosd__obj__map.html">osd_obj_map</a> {
<a name="l00163"></a>00163         <span class="keyword">struct </span>dentry    *om_root;        <span class="comment">/* dentry for /O */</span>
<a name="l00164"></a>00164         rwlock_t         om_seq_list_lock; <span class="comment">/* lock for seq_list */</span>
<a name="l00165"></a>00165         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> om_seq_list;      <span class="comment">/* list head for seq */</span>
<a name="l00166"></a>00166         <span class="keywordtype">int</span>              om_subdir_count;
<a name="l00167"></a>00167         <span class="keyword">struct </span>mutex     om_dir_init_mutex;
<a name="l00168"></a>00168 };
<a name="l00169"></a>00169 
<a name="l00170"></a><a class="code" href="structosd__mdobj.html">00170</a> <span class="keyword">struct </span><a class="code" href="structosd__mdobj.html">osd_mdobj</a> {
<a name="l00171"></a>00171         <span class="keyword">struct </span>dentry   *om_root;      <span class="comment">/* AGENT/&lt;index&gt; */</span>
<a name="l00172"></a>00172         u64              om_index;     <span class="comment">/* mdt index */</span>
<a name="l00173"></a>00173         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> om_list;      <span class="comment">/* list to omm_list */</span>
<a name="l00174"></a>00174 };
<a name="l00175"></a>00175 
<a name="l00176"></a><a class="code" href="structosd__mdobj__map.html">00176</a> <span class="keyword">struct </span><a class="code" href="structosd__mdobj__map.html">osd_mdobj_map</a> {
<a name="l00177"></a>00177         <span class="keyword">struct </span>dentry   *omm_remote_parent;
<a name="l00178"></a>00178 };
<a name="l00179"></a>00179 <span class="keywordtype">int</span> osd_ldiskfs_add_entry(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info,
<a name="l00180"></a>00180                           handle_t *handle, <span class="keyword">struct</span> dentry *child,
<a name="l00181"></a>00181                           <span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> htree_lock *hlock);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="preprocessor">#define OSD_OTABLE_IT_CACHE_SIZE        64</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span><span class="preprocessor">#define OSD_OTABLE_IT_CACHE_MASK        (~(OSD_OTABLE_IT_CACHE_SIZE - 1))</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span>
<a name="l00186"></a><a class="code" href="structosd__inconsistent__item.html">00186</a> <span class="keyword">struct </span><a class="code" href="structosd__inconsistent__item.html">osd_inconsistent_item</a> {
<a name="l00187"></a>00187         <span class="comment">/* link into osd_scrub::os_inconsistent_items,</span>
<a name="l00188"></a>00188 <span class="comment">         * protected by osd_scrub::os_lock. */</span>
<a name="l00189"></a>00189         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>       oii_list;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         <span class="comment">/* The right FID &lt;=&gt; ino#/gen mapping. */</span>
<a name="l00192"></a>00192         <span class="keyword">struct </span><a class="code" href="structosd__idmap__cache.html">osd_idmap_cache</a> oii_cache;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           oii_insert:1; <span class="comment">/* insert or update mapping. */</span>
<a name="l00195"></a>00195 };
<a name="l00196"></a>00196 
<a name="l00197"></a><a class="code" href="structosd__otable__cache.html">00197</a> <span class="keyword">struct </span><a class="code" href="structosd__otable__cache.html">osd_otable_cache</a> {
<a name="l00198"></a>00198         <span class="keyword">struct </span><a class="code" href="structosd__idmap__cache.html">osd_idmap_cache</a> ooc_cache[OSD_OTABLE_IT_CACHE_SIZE];
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         <span class="comment">/* Index for next cache slot to be filled. */</span>
<a name="l00201"></a>00201         <span class="keywordtype">int</span>                    ooc_producer_idx;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         <span class="comment">/* Index for next cache slot to be returned by it::next(). */</span>
<a name="l00204"></a>00204         <span class="keywordtype">int</span>                    ooc_consumer_idx;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="comment">/* How many items in ooc_cache. */</span>
<a name="l00207"></a>00207         <span class="keywordtype">int</span>                    ooc_cached_items;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="comment">/* Position for up layer LFSCK iteration pre-loading. */</span>
<a name="l00210"></a>00210         __u32                  ooc_pos_preload;
<a name="l00211"></a>00211 };
<a name="l00212"></a>00212 
<a name="l00213"></a><a class="code" href="structosd__otable__it.html">00213</a> <span class="keyword">struct </span><a class="code" href="structosd__otable__it.html">osd_otable_it</a> {
<a name="l00214"></a>00214         <span class="keyword">struct </span><a class="code" href="structosd__device.html">osd_device</a>       *ooi_dev;
<a name="l00215"></a>00215         <span class="keyword">struct </span><a class="code" href="structosd__otable__cache.html">osd_otable_cache</a>  ooi_cache;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         <span class="comment">/* The following bits can be updated/checked w/o lock protection.</span>
<a name="l00218"></a>00218 <span class="comment">         * If more bits will be introduced in the future and need lock to</span>
<a name="l00219"></a>00219 <span class="comment">         * protect, please add comment. */</span>
<a name="l00220"></a>00220         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            ooi_used_outside:1, <span class="comment">/* Some user out of OSD</span>
<a name="l00221"></a>00221 <span class="comment">                                                      * uses the iteration. */</span>
<a name="l00222"></a>00222                                  ooi_all_cached:1, <span class="comment">/* No more entries can be</span>
<a name="l00223"></a>00223 <span class="comment">                                                    * filled into cache. */</span>
<a name="l00224"></a>00224                                  ooi_user_ready:1, <span class="comment">/* The user out of OSD is</span>
<a name="l00225"></a>00225 <span class="comment">                                                    * ready to iterate. */</span>
<a name="l00226"></a>00226                                  ooi_waiting:1; <span class="comment">/* it::next is waiting. */</span>
<a name="l00227"></a>00227 };
<a name="l00228"></a>00228 
<a name="l00229"></a><a class="code" href="structosd__obj__orphan.html">00229</a> <span class="keyword">struct </span><a class="code" href="structosd__obj__orphan.html">osd_obj_orphan</a> {
<a name="l00230"></a>00230         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> oor_list;
<a name="l00231"></a>00231         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>   *oor_env; <span class="comment">/* to identify &quot;own&quot; records */</span>
<a name="l00232"></a>00232         __u32 oor_ino;
<a name="l00233"></a>00233 };
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="comment">/*</span>
<a name="l00236"></a>00236 <span class="comment"> * osd device.</span>
<a name="l00237"></a>00237 <span class="comment"> */</span>
<a name="l00238"></a><a class="code" href="structosd__device.html">00238</a> <span class="keyword">struct </span><a class="code" href="structosd__device.html">osd_device</a> {
<a name="l00239"></a>00239         <span class="comment">/* super-class */</span>
<a name="l00240"></a>00240         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>          od_dt_dev;
<a name="l00241"></a>00241         <span class="comment">/* information about underlying file system */</span>
<a name="l00242"></a>00242         <span class="keyword">struct </span>vfsmount          *od_mnt;
<a name="l00243"></a>00243         <span class="comment">/* object index */</span>
<a name="l00244"></a>00244         <span class="keyword">struct </span><a class="code" href="structosd__oi.html">osd_oi</a>           **od_oi_table;
<a name="l00245"></a>00245         <span class="comment">/* total number of OI containers */</span>
<a name="l00246"></a>00246         <span class="keywordtype">int</span>                       od_oi_count;
<a name="l00247"></a>00247         <span class="comment">/*</span>
<a name="l00248"></a>00248 <span class="comment">         * Fid Capability</span>
<a name="l00249"></a>00249 <span class="comment">         */</span>
<a name="l00250"></a>00250         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              od_fl_capa:1,
<a name="l00251"></a>00251                                   od_maybe_new:1,
<a name="l00252"></a>00252                                   od_noscrub:1,
<a name="l00253"></a>00253                                   od_igif_inoi:1,
<a name="l00254"></a>00254                                   od_check_ff:1,
<a name="l00255"></a>00255                                   od_is_ost:1,
<a name="l00256"></a>00256                                   od_index_in_idif:1;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         __u32                     od_dirent_journal;
<a name="l00259"></a>00259         <span class="keywordtype">int</span>                       od_index;
<a name="l00260"></a>00260         <span class="keyword">struct </span>proc_dir_entry    *od_proc_entry;
<a name="l00261"></a>00261         <span class="keyword">struct </span><a class="code" href="structlprocfs__stats.html">lprocfs_stats</a>     *od_stats;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263         spinlock_t                od_osfs_lock;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265         <span class="keywordtype">int</span>                       od_connects;
<a name="l00266"></a>00266         <span class="keyword">struct </span><a class="code" href="structlu__site.html" title="lu_site is a &amp;quot;compartment&amp;quot; within which objects are unique, and LRU discipline...">lu_site</a>            od_site;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         <span class="keyword">struct </span><a class="code" href="structosd__obj__map.html">osd_obj_map</a>      *od_ost_map;
<a name="l00269"></a>00269         <span class="keyword">struct </span><a class="code" href="structosd__mdobj__map.html">osd_mdobj_map</a>    *od_mdt_map;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>      od_readcache_max_filesize;
<a name="l00272"></a>00272         <span class="keywordtype">int</span>                     od_read_cache;
<a name="l00273"></a>00273         <span class="keywordtype">int</span>                     od_writethrough_cache;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         <span class="keyword">struct </span><a class="code" href="structbrw__stats.html">brw_stats</a>        od_brw_stats;
<a name="l00276"></a>00276         atomic_t                od_r_in_flight;
<a name="l00277"></a>00277         atomic_t                od_w_in_flight;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279         <span class="keyword">struct </span>mutex              od_otable_mutex;
<a name="l00280"></a>00280         <span class="keyword">struct </span><a class="code" href="structosd__otable__it.html">osd_otable_it</a>     *od_otable_it;
<a name="l00281"></a>00281         <span class="keyword">struct </span><a class="code" href="structosd__scrub.html">osd_scrub</a>          od_scrub;
<a name="l00282"></a>00282         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                  od_ios_list;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284         <span class="comment">/* service name associated with the osd device */</span>
<a name="l00285"></a>00285         <span class="keywordtype">char</span>                      od_svname[MAX_OBD_NAME];
<a name="l00286"></a>00286         <span class="keywordtype">char</span>                      od_mntdev[MAX_OBD_NAME];
<a name="l00287"></a>00287 
<a name="l00288"></a>00288         <span class="comment">/* quota slave instance */</span>
<a name="l00289"></a>00289         <span class="keyword">struct </span><a class="code" href="structqsd__instance.html">qsd_instance</a>      *od_quota_slave;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291         <span class="comment">/* osd seq instance */</span>
<a name="l00292"></a>00292         <span class="keyword">struct </span><a class="code" href="structlu__client__seq.html">lu_client_seq</a>    *od_cl_seq;
<a name="l00293"></a>00293         <span class="comment">/* If the ratio of &quot;the total OI mappings count&quot; vs</span>
<a name="l00294"></a>00294 <span class="comment">         * &quot;the bad OI mappings count&quot; is lower than the</span>
<a name="l00295"></a>00295 <span class="comment">         * osd_device::od_full_scrub_ratio, then trigger</span>
<a name="l00296"></a>00296 <span class="comment">         * OI scrub to scan the whole the device. */</span>
<a name="l00297"></a>00297         __u64                    od_full_scrub_ratio;
<a name="l00298"></a>00298         <span class="comment">/* If the speed of found bad OI mappings (per minute)</span>
<a name="l00299"></a>00299 <span class="comment">         * exceeds the osd_device::od_full_scrub_threshold_rate,</span>
<a name="l00300"></a>00300 <span class="comment">         * then trigger OI scrub to scan the whole device. */</span>
<a name="l00301"></a>00301         __u64                    od_full_scrub_threshold_rate;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303         <span class="comment">/* a list of orphaned agent inodes, protected with od_osfs_lock */</span>
<a name="l00304"></a>00304         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>         od_orphan_list;
<a name="l00305"></a>00305 };
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="keyword">enum</span> osd_full_scrub_ratio {
<a name="l00308"></a>00308         <span class="comment">/* Trigger OI scrub to scan the whole device directly. */</span>
<a name="l00309"></a>00309         OFSR_DIRECTLY   = 0,
<a name="l00310"></a>00310 
<a name="l00311"></a>00311         <span class="comment">/* Because the bad OI mappings count cannot be larger than</span>
<a name="l00312"></a>00312 <span class="comment">         * the total OI mappints count, then setting OFSR_NEVER means</span>
<a name="l00313"></a>00313 <span class="comment">         * that the whole device scanning cannot be triggered by auto</span>
<a name="l00314"></a>00314 <span class="comment">         * detected bad OI mappings during the RPC services. */</span>
<a name="l00315"></a>00315         OFSR_NEVER      = 1,
<a name="l00316"></a>00316         OFSR_DEFAULT    = 10000,
<a name="l00317"></a>00317 };
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="preprocessor">#define FULL_SCRUB_THRESHOLD_RATE_DEFAULT       60</span>
<a name="l00320"></a>00320 <span class="preprocessor"></span>
<a name="l00321"></a>00321 <span class="comment">/* There are at most 10 uid/gids are affected in a transaction, and</span>
<a name="l00322"></a>00322 <span class="comment"> * that&apos;s rename case:</span>
<a name="l00323"></a>00323 <span class="comment"> * - 2 for source parent uid &amp; gid;</span>
<a name="l00324"></a>00324 <span class="comment"> * - 2 for source child uid &amp; gid (&apos;..&apos; entry update when child is directory);</span>
<a name="l00325"></a>00325 <span class="comment"> * - 2 for target parent uid &amp; gid;</span>
<a name="l00326"></a>00326 <span class="comment"> * - 2 for target child uid &amp; gid (if the target child exists);</span>
<a name="l00327"></a>00327 <span class="comment"> * - 2 for root uid &amp; gid (last_rcvd, llog, etc);</span>
<a name="l00328"></a>00328 <span class="comment"> *</span>
<a name="l00329"></a>00329 <span class="comment"> * The 0 to (OSD_MAX_UGID_CNT - 1) bits of ot_id_type is for indicating</span>
<a name="l00330"></a>00330 <span class="comment"> * the id type of each id in the ot_id_array.</span>
<a name="l00331"></a>00331 <span class="comment"> */</span>
<a name="l00332"></a>00332 <span class="preprocessor">#define OSD_MAX_UGID_CNT        10</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span>
<a name="l00334"></a>00334 <span class="keyword">enum</span> {
<a name="l00335"></a>00335         OSD_OT_ATTR_SET         = 0,
<a name="l00336"></a>00336         OSD_OT_PUNCH            = 1,
<a name="l00337"></a>00337         OSD_OT_XATTR_SET        = 2,
<a name="l00338"></a>00338         OSD_OT_CREATE           = 3,
<a name="l00339"></a>00339         OSD_OT_DESTROY          = 4,
<a name="l00340"></a>00340         OSD_OT_REF_ADD          = 5,
<a name="l00341"></a>00341         OSD_OT_REF_DEL          = 6,
<a name="l00342"></a>00342         OSD_OT_WRITE            = 7,
<a name="l00343"></a>00343         OSD_OT_INSERT           = 8,
<a name="l00344"></a>00344         OSD_OT_DELETE           = 9,
<a name="l00345"></a>00345         OSD_OT_QUOTA            = 10,
<a name="l00346"></a>00346         OSD_OT_MAX              = 11
<a name="l00347"></a>00347 };
<a name="l00348"></a>00348 
<a name="l00349"></a><a class="code" href="structosd__thandle.html">00349</a> <span class="keyword">struct </span><a class="code" href="structosd__thandle.html">osd_thandle</a> {
<a name="l00350"></a>00350         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          ot_super;
<a name="l00351"></a>00351         handle_t               *ot_handle;
<a name="l00352"></a>00352         <span class="keyword">struct </span>ldiskfs_journal_cb_entry ot_jcb;
<a name="l00353"></a>00353         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>       ot_commit_dcb_list;
<a name="l00354"></a>00354         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>       ot_stop_dcb_list;
<a name="l00355"></a>00355         <span class="comment">/* Link to the device, for debugging. */</span>
<a name="l00356"></a>00356         <span class="keyword">struct </span><a class="code" href="structlu__ref__link.html">lu_ref_link</a>      ot_dev_link;
<a name="l00357"></a>00357         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>          ot_credits;
<a name="l00358"></a>00358         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>          ot_id_cnt;
<a name="l00359"></a>00359         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>          ot_id_type;
<a name="l00360"></a>00360         <span class="keywordtype">int</span>                     ot_remove_agents:1;
<a name="l00361"></a>00361         uid_t                   ot_id_array[OSD_MAX_UGID_CNT];
<a name="l00362"></a>00362         <span class="keyword">struct </span><a class="code" href="structlquota__trans.html">lquota_trans</a>    *ot_quota_trans;
<a name="l00363"></a>00363 <span class="preprocessor">#if OSD_THANDLE_STATS</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span>
<a name="l00365"></a>00365         cfs_time_t oth_alloced;
<a name="l00366"></a>00366 
<a name="l00368"></a>00368         cfs_time_t oth_started;
<a name="l00369"></a>00369 <span class="preprocessor">#endif</span>
<a name="l00370"></a>00370 <span class="preprocessor"></span>};
<a name="l00371"></a>00371 
<a name="l00375"></a>00375 <span class="keyword">enum</span> dt_txn_op {
<a name="l00376"></a>00376         DTO_INDEX_INSERT,
<a name="l00377"></a>00377         DTO_INDEX_DELETE,
<a name="l00378"></a>00378         DTO_INDEX_UPDATE,
<a name="l00379"></a>00379         DTO_OBJECT_CREATE,
<a name="l00380"></a>00380         DTO_OBJECT_DELETE,
<a name="l00381"></a>00381         DTO_ATTR_SET_BASE,
<a name="l00382"></a>00382         DTO_XATTR_SET,
<a name="l00383"></a>00383         DTO_WRITE_BASE,
<a name="l00384"></a>00384         DTO_WRITE_BLOCK,
<a name="l00385"></a>00385         DTO_ATTR_SET_CHOWN,
<a name="l00386"></a>00386 
<a name="l00387"></a>00387         DTO_NR
<a name="l00388"></a>00388 };
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="comment">/*</span>
<a name="l00391"></a>00391 <span class="comment"> * osd dev stats</span>
<a name="l00392"></a>00392 <span class="comment"> */</span>
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 <span class="preprocessor">#ifdef CONFIG_PROC_FS</span>
<a name="l00395"></a>00395 <span class="preprocessor"></span><span class="keyword">enum</span> {
<a name="l00396"></a>00396         LPROC_OSD_READ_BYTES    = 0,
<a name="l00397"></a>00397         LPROC_OSD_WRITE_BYTES   = 1,
<a name="l00398"></a>00398         LPROC_OSD_GET_PAGE      = 2,
<a name="l00399"></a>00399         LPROC_OSD_NO_PAGE       = 3,
<a name="l00400"></a>00400         LPROC_OSD_CACHE_ACCESS  = 4,
<a name="l00401"></a>00401         LPROC_OSD_CACHE_HIT     = 5,
<a name="l00402"></a>00402         LPROC_OSD_CACHE_MISS    = 6,
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="preprocessor">#if OSD_THANDLE_STATS</span>
<a name="l00405"></a>00405 <span class="preprocessor"></span>        LPROC_OSD_THANDLE_STARTING,
<a name="l00406"></a>00406         LPROC_OSD_THANDLE_OPEN,
<a name="l00407"></a>00407         LPROC_OSD_THANDLE_CLOSING,
<a name="l00408"></a>00408 <span class="preprocessor">#endif</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span>        LPROC_OSD_LAST,
<a name="l00410"></a>00410 };
<a name="l00411"></a>00411 <span class="preprocessor">#endif</span>
<a name="l00412"></a>00412 <span class="preprocessor"></span>
<a name="l00418"></a><a class="code" href="structosd__fid__pack.html">00418</a> <span class="keyword">struct </span><a class="code" href="structosd__fid__pack.html" title="Storage representation for fids.">osd_fid_pack</a> {
<a name="l00419"></a>00419         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fp_len;
<a name="l00420"></a>00420         <span class="keywordtype">char</span> fp_area[<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>)];
<a name="l00421"></a>00421 };
<a name="l00422"></a>00422 
<a name="l00423"></a><a class="code" href="structosd__it__ea__dirent.html">00423</a> <span class="keyword">struct </span><a class="code" href="structosd__it__ea__dirent.html">osd_it_ea_dirent</a> {
<a name="l00424"></a>00424         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   oied_fid;
<a name="l00425"></a>00425         __u64           oied_ino;
<a name="l00426"></a>00426         __u64           oied_off;
<a name="l00427"></a>00427         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>  oied_namelen;
<a name="l00428"></a>00428         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    oied_type;
<a name="l00429"></a>00429         <span class="keywordtype">char</span>            oied_name[0];
<a name="l00430"></a>00430 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l00431"></a>00431 
<a name="l00439"></a>00439 <span class="preprocessor">#define OSD_IT_EA_BUFSIZE       (PAGE_CACHE_SIZE + PAGE_CACHE_SIZE/4)</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>
<a name="l00445"></a><a class="code" href="structosd__it__ea.html">00445</a> <span class="keyword">struct </span><a class="code" href="structosd__it__ea.html" title="This is iterator&amp;#39;s in-memory data structure in interoperability mode (i.e.">osd_it_ea</a> {
<a name="l00446"></a>00446         <span class="keyword">struct </span><a class="code" href="structosd__object.html">osd_object</a>       *oie_obj;
<a name="l00448"></a><a class="code" href="structosd__it__ea.html#a0b8c9bcde5e0f3725305514527d6375b">00448</a>         <span class="keyword">struct </span>file             <a class="code" href="structosd__it__ea.html#a0b8c9bcde5e0f3725305514527d6375b" title="used in ldiskfs iterator, to stored file pointer">oie_file</a>;
<a name="l00450"></a><a class="code" href="structosd__it__ea.html#a4c4286fffd0f6b35e03ae3056b4842d3">00450</a>         <span class="keywordtype">int</span>                     <a class="code" href="structosd__it__ea.html#a4c4286fffd0f6b35e03ae3056b4842d3" title="how many entries have been read-cached from storage">oie_rd_dirent</a>;
<a name="l00452"></a><a class="code" href="structosd__it__ea.html#ae8f93bbd3ac4d32360962785a8020f44">00452</a>         <span class="keywordtype">int</span>                     <a class="code" href="structosd__it__ea.html#ae8f93bbd3ac4d32360962785a8020f44" title="current entry is being iterated by caller">oie_it_dirent</a>;
<a name="l00454"></a><a class="code" href="structosd__it__ea.html#a9abf464815dd90e055a34485c483a4c5">00454</a>         <span class="keyword">struct </span><a class="code" href="structosd__it__ea__dirent.html">osd_it_ea_dirent</a> *<a class="code" href="structosd__it__ea.html#a9abf464815dd90e055a34485c483a4c5" title="current processing entry">oie_dirent</a>;
<a name="l00456"></a><a class="code" href="structosd__it__ea.html#a2786f970c07aa4943477dd1afc2a039d">00456</a>         <span class="keywordtype">void</span>                    *<a class="code" href="structosd__it__ea.html#a2786f970c07aa4943477dd1afc2a039d" title="buffer to hold entries, size == OSD_IT_EA_BUFSIZE">oie_buf</a>;
<a name="l00457"></a>00457         <span class="keyword">struct </span>dentry           oie_dentry;
<a name="l00458"></a>00458 };
<a name="l00459"></a>00459 
<a name="l00463"></a><a class="code" href="structosd__it__iam.html">00463</a> <span class="keyword">struct </span><a class="code" href="structosd__it__iam.html" title="Iterator&amp;#39;s in-memory data structure for IAM mode.">osd_it_iam</a> {
<a name="l00464"></a>00464         <span class="keyword">struct </span><a class="code" href="structosd__object.html">osd_object</a>     *oi_obj;
<a name="l00465"></a>00465         <span class="keyword">struct </span><a class="code" href="structiam__path__descr.html">iam_path_descr</a> *oi_ipd;
<a name="l00466"></a>00466         <span class="keyword">struct </span><a class="code" href="structiam__iterator.html">iam_iterator</a>    oi_it;
<a name="l00467"></a>00467 };
<a name="l00468"></a>00468 
<a name="l00469"></a><a class="code" href="structosd__quota__leaf.html">00469</a> <span class="keyword">struct </span><a class="code" href="structosd__quota__leaf.html">osd_quota_leaf</a> {
<a name="l00470"></a>00470         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        oql_link;
<a name="l00471"></a>00471         uint            oql_blk;
<a name="l00472"></a>00472 };
<a name="l00473"></a>00473 
<a name="l00477"></a><a class="code" href="structosd__it__quota.html">00477</a> <span class="keyword">struct </span><a class="code" href="structosd__it__quota.html" title="Iterator&amp;#39;s in-memory data structure for quota file.">osd_it_quota</a> {
<a name="l00478"></a>00478         <span class="keyword">struct </span><a class="code" href="structosd__object.html">osd_object</a>       *oiq_obj;
<a name="l00480"></a><a class="code" href="structosd__it__quota.html#a475bf0b9aff5da9b5205184717fda235">00480</a>         uint                     <a class="code" href="structosd__it__quota.html#a475bf0b9aff5da9b5205184717fda235" title="tree blocks path to where the entry is stored">oiq_blk</a>[LUSTRE_DQTREEDEPTH + 1];
<a name="l00482"></a><a class="code" href="structosd__it__quota.html#ad7d4709533063f9e2fb9528b72cb203d">00482</a>         loff_t                   <a class="code" href="structosd__it__quota.html#ad7d4709533063f9e2fb9528b72cb203d" title="on-disk offset for current key where quota record can be found">oiq_offset</a>;
<a name="l00484"></a><a class="code" href="structosd__it__quota.html#a9d8b986954c568d9b521b4bd9b7aff88">00484</a>         __u64                    <a class="code" href="structosd__it__quota.html#a9d8b986954c568d9b521b4bd9b7aff88" title="identifier for current quota record">oiq_id</a>;
<a name="l00486"></a><a class="code" href="structosd__it__quota.html#a7c95f84a37a9542ed148be4e6ead35e3">00486</a>         uint                     <a class="code" href="structosd__it__quota.html#a7c95f84a37a9542ed148be4e6ead35e3" title="the record index in the leaf/index block">oiq_index</a>[LUSTRE_DQTREEDEPTH + 1];
<a name="l00488"></a><a class="code" href="structosd__it__quota.html#afecd67eb2d70bbb449d25ca565ffe94c">00488</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>         <a class="code" href="structosd__it__quota.html#afecd67eb2d70bbb449d25ca565ffe94c" title="list of already processed leaf blocks">oiq_list</a>;
<a name="l00489"></a>00489 };
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="preprocessor">#define MAX_BLOCKS_PER_PAGE (PAGE_CACHE_SIZE / 512)</span>
<a name="l00492"></a>00492 <span class="preprocessor"></span>
<a name="l00493"></a><a class="code" href="structosd__iobuf.html">00493</a> <span class="keyword">struct </span><a class="code" href="structosd__iobuf.html">osd_iobuf</a> {
<a name="l00494"></a>00494         wait_queue_head_t  dr_wait;
<a name="l00495"></a>00495         atomic_t       dr_numreqs;  <span class="comment">/* number of reqs being processed */</span>
<a name="l00496"></a>00496         <span class="keywordtype">int</span>                dr_max_pages;
<a name="l00497"></a>00497         <span class="keywordtype">int</span>                dr_npages;
<a name="l00498"></a>00498         <span class="keywordtype">int</span>                dr_error;
<a name="l00499"></a>00499         <span class="keywordtype">int</span>                dr_frags;
<a name="l00500"></a>00500         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       dr_ignore_quota:1;
<a name="l00501"></a>00501         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       dr_elapsed_valid:1; <span class="comment">/* we really did count time */</span>
<a name="l00502"></a>00502         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       dr_rw:1;
<a name="l00503"></a>00503         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>      dr_pg_buf;
<a name="l00504"></a>00504         <span class="keyword">struct </span>page      **dr_pages;
<a name="l00505"></a>00505         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>      dr_bl_buf;
<a name="l00506"></a>00506         sector_t          *dr_blocks;
<a name="l00507"></a>00507         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>      dr_start_time;
<a name="l00508"></a>00508         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>      dr_elapsed;  <span class="comment">/* how long io took */</span>
<a name="l00509"></a>00509         <span class="keyword">struct </span><a class="code" href="structosd__device.html">osd_device</a> *dr_dev;
<a name="l00510"></a>00510         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       dr_init_at;  <span class="comment">/* the line iobuf was initialized */</span>
<a name="l00511"></a>00511 };
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="preprocessor">#define OSD_INS_CACHE_SIZE      8</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span>
<a name="l00515"></a><a class="code" href="structosd__thread__info.html">00515</a> <span class="keyword">struct </span><a class="code" href="structosd__thread__info.html">osd_thread_info</a> {
<a name="l00516"></a>00516         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>   *oti_env;
<a name="l00520"></a><a class="code" href="structosd__thread__info.html#ab13060bad7d6407028bc061f3e0fd5f5">00520</a>         <span class="keyword">struct </span>dentry          <a class="code" href="structosd__thread__info.html#ab13060bad7d6407028bc061f3e0fd5f5" title="used for index operations.">oti_obj_dentry</a>;
<a name="l00521"></a>00521         <span class="keyword">struct </span>dentry          oti_child_dentry;
<a name="l00522"></a>00522 
<a name="l00524"></a><a class="code" href="structosd__thread__info.html#a9c6f48bd95e460187c5605c13c8e6079">00524</a>         <span class="keyword">struct </span>dentry           <a class="code" href="structosd__thread__info.html#a9c6f48bd95e460187c5605c13c8e6079" title="dentry for Iterator context.">oti_it_dentry</a>;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <span class="keyword">union </span>{
<a name="l00527"></a>00527                 <span class="comment">/* fake struct file for osd_object_sync */</span>
<a name="l00528"></a>00528                 <span class="keyword">struct </span>file             oti_file;
<a name="l00529"></a>00529                 <span class="comment">/* osd_statfs() */</span>
<a name="l00530"></a>00530                 <span class="keyword">struct </span>kstatfs          oti_ksfs;
<a name="l00531"></a>00531         };
<a name="l00532"></a>00532 
<a name="l00533"></a>00533         <span class="keyword">struct </span>htree_lock     *oti_hlock;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>          oti_fid;
<a name="l00536"></a>00536         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>          oti_fid2;
<a name="l00537"></a>00537         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>          oti_fid3;
<a name="l00538"></a>00538         <span class="keyword">struct </span><a class="code" href="structosd__inode__id.html">osd_inode_id</a>    oti_id;
<a name="l00539"></a>00539         <span class="keyword">struct </span><a class="code" href="structosd__inode__id.html">osd_inode_id</a>    oti_id2;
<a name="l00540"></a>00540         <span class="keyword">struct </span><a class="code" href="structosd__inode__id.html">osd_inode_id</a>    oti_id3;
<a name="l00541"></a>00541         <span class="keyword">struct </span><a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a>          oti_ostid;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543         <span class="comment">/*</span>
<a name="l00544"></a>00544 <span class="comment">         * XXX temporary: for -&gt;i_op calls.</span>
<a name="l00545"></a>00545 <span class="comment">         */</span>
<a name="l00546"></a>00546         <span class="keyword">struct </span>timespec        oti_time;
<a name="l00547"></a>00547 
<a name="l00550"></a><a class="code" href="structosd__thread__info.html#aaf0963ea0d67a0b8b25b6868b2ba8bd4">00550</a>         <span class="keyword">struct </span><a class="code" href="structosd__device.html">osd_device</a>     *<a class="code" href="structosd__thread__info.html#aaf0963ea0d67a0b8b25b6868b2ba8bd4" title="osd_device reference, initialized in osd_trans_start() and used in osd_trans_stop()...">oti_dev</a>;
<a name="l00551"></a>00551 
<a name="l00559"></a><a class="code" href="structosd__thread__info.html#a65059bb9aa0ef327e2f8fd6e5f9bbe78">00559</a>         <span class="keywordtype">void</span>                    *<a class="code" href="structosd__thread__info.html#a65059bb9aa0ef327e2f8fd6e5f9bbe78" title="following ipd and it structures are used for osd_index_iam_lookup() these are defined...">oti_it_ea_buf</a>;
<a name="l00560"></a>00560         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            oti_it_ea_buf_used:1;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562         <span class="comment">/* IAM iterator for index operation. */</span>
<a name="l00563"></a>00563         <span class="keyword">struct </span><a class="code" href="structiam__iterator.html">iam_iterator</a>    oti_idx_it;
<a name="l00564"></a>00564 
<a name="l00566"></a>00566         <span class="keyword">union </span>{
<a name="l00567"></a>00567                 <span class="keywordtype">char</span>           oti_name[48];
<a name="l00568"></a>00568                 <span class="keywordtype">char</span>           oti_it_ipd[DX_IPD_MAX_SIZE];
<a name="l00569"></a>00569                 <span class="keywordtype">long</span> <span class="keywordtype">long</span>      oti_alignment_lieutenant;
<a name="l00570"></a>00570         };
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         <span class="keyword">union </span>{
<a name="l00573"></a>00573                 <span class="keywordtype">char</span>           oti_idx_ipd[DX_IPD_MAX_SIZE];
<a name="l00574"></a>00574                 <span class="keywordtype">long</span> <span class="keywordtype">long</span>      oti_alignment_lieutenant_colonel;
<a name="l00575"></a>00575         };
<a name="l00576"></a>00576 
<a name="l00577"></a>00577         <span class="keyword">struct </span><a class="code" href="structosd__idmap__cache.html">osd_idmap_cache</a> oti_cache;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579         <span class="comment">/* dedicated OI cache for insert (which needs inum) */</span>
<a name="l00580"></a>00580         <span class="keyword">struct </span><a class="code" href="structosd__idmap__cache.html">osd_idmap_cache</a> *oti_ins_cache;
<a name="l00581"></a>00581         <span class="keywordtype">int</span>                    oti_ins_cache_size;
<a name="l00582"></a>00582         <span class="keywordtype">int</span>                    oti_ins_cache_used;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584         <span class="keywordtype">int</span>                    oti_r_locks;
<a name="l00585"></a>00585         <span class="keywordtype">int</span>                    oti_w_locks;
<a name="l00586"></a>00586         <span class="keywordtype">int</span>                    oti_txns;
<a name="l00588"></a><a class="code" href="structosd__thread__info.html#a7dc33f62235078a8128d3bdb51574886">00588</a>         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>          <a class="code" href="structosd__thread__info.html#a7dc33f62235078a8128d3bdb51574886" title="used in osd_fid_set() to put xattr">oti_buf</a>;
<a name="l00589"></a>00589         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>          oti_big_buf;
<a name="l00591"></a>00591         <span class="keyword">union </span>{
<a name="l00592"></a>00592                 <span class="keyword">struct </span><a class="code" href="structlustre__mdt__attrs.html" title="Following struct for object attributes, that will be kept inode&amp;#39;s EA.">lustre_mdt_attrs</a> oti_mdt_attrs;
<a name="l00593"></a>00593                 <span class="comment">/* old LMA for compatibility */</span>
<a name="l00594"></a>00594                 <span class="keywordtype">char</span>                    oti_mdt_attrs_old[<a class="code" href="group__lustreuser.html#gaae2dd0d15d4ca9d9d9c3980978ba03df" title="Prior to 2.4, the LMA structure also included SOM attributes which has since been...">LMA_OLD_SIZE</a>];
<a name="l00595"></a>00595                 <span class="keyword">struct </span><a class="code" href="structfilter__fid__old.html">filter_fid_old</a>   oti_ff;
<a name="l00596"></a>00596                 <span class="keyword">struct </span><a class="code" href="structfilter__fid.html">filter_fid</a>       oti_ff_new;
<a name="l00597"></a>00597         };
<a name="l00599"></a><a class="code" href="structosd__thread__info.html#aa06c07d2752199ad935f6e1f25856171">00599</a>         <span class="keyword">struct </span><a class="code" href="structosd__iobuf.html">osd_iobuf</a>       <a class="code" href="structosd__thread__info.html#aa06c07d2752199ad935f6e1f25856171" title="0-copy IO">oti_iobuf</a>;
<a name="l00600"></a>00600         <span class="comment">/* used to access objects in /O */</span>
<a name="l00601"></a>00601         <span class="keyword">struct </span>inode          *oti_inode;
<a name="l00602"></a>00602 <span class="preprocessor">#define OSD_FID_REC_SZ 32</span>
<a name="l00603"></a>00603 <span class="preprocessor"></span>        <span class="keywordtype">char</span>                   oti_ldp[OSD_FID_REC_SZ];
<a name="l00604"></a>00604         <span class="keywordtype">char</span>                   oti_ldp2[OSD_FID_REC_SZ];
<a name="l00605"></a>00605 
<a name="l00606"></a>00606         <span class="comment">/* used by quota code */</span>
<a name="l00607"></a>00607         <span class="keyword">union </span>{
<a name="l00608"></a>00608 <span class="preprocessor">#ifdef HAVE_DQUOT_FS_DISK_QUOTA</span>
<a name="l00609"></a>00609 <span class="preprocessor"></span>                <span class="keyword">struct </span>fs_disk_quota    oti_fdq;
<a name="l00610"></a>00610 <span class="preprocessor">#else</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span>                <span class="keyword">struct </span>if_dqblk         oti_dqblk;
<a name="l00612"></a>00612 <span class="preprocessor">#endif</span>
<a name="l00613"></a>00613 <span class="preprocessor"></span>                <span class="keyword">struct </span>if_dqinfo        oti_dqinfo;
<a name="l00614"></a>00614         };
<a name="l00615"></a>00615         <span class="keyword">struct </span><a class="code" href="structlquota__id__info.html">lquota_id_info</a>   oti_qi;
<a name="l00616"></a>00616         <span class="keyword">struct </span><a class="code" href="structlquota__trans.html">lquota_trans</a>     oti_quota_trans;
<a name="l00617"></a>00617         <span class="keyword">union </span><a class="code" href="unionlquota__rec.html">lquota_rec</a>        oti_quota_rec;
<a name="l00618"></a>00618         __u64                   oti_quota_id;
<a name="l00619"></a>00619         <span class="keyword">struct </span><a class="code" href="structlu__seq__range.html" title="Describes a range of sequence, lsr_start is included but lsr_end is not in the range...">lu_seq_range</a>     oti_seq_range;
<a name="l00620"></a>00620 
<a name="l00621"></a>00621         <span class="comment">/* Tracking for transaction credits, to allow debugging and optimizing</span>
<a name="l00622"></a>00622 <span class="comment">         * cases where a large number of credits are being allocated for</span>
<a name="l00623"></a>00623 <span class="comment">         * single transaction. */</span>
<a name="l00624"></a>00624         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            oti_credits_before;
<a name="l00625"></a>00625         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>          oti_declare_ops[OSD_OT_MAX];
<a name="l00626"></a>00626         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>          oti_declare_ops_cred[OSD_OT_MAX];
<a name="l00627"></a>00627         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>          oti_declare_ops_used[OSD_OT_MAX];
<a name="l00628"></a>00628 };
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="keyword">extern</span> <span class="keywordtype">int</span> ldiskfs_pdo;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> __osd_xattr_get(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> dentry *dentry,
<a name="l00633"></a>00633                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> len)
<a name="l00634"></a>00634 {
<a name="l00635"></a>00635         <span class="keywordflow">if</span> (inode == NULL)
<a name="l00636"></a>00636                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         dentry-&gt;d_inode = inode;
<a name="l00639"></a>00639         dentry-&gt;d_sb = inode-&gt;i_sb;
<a name="l00640"></a>00640         <span class="keywordflow">return</span> inode-&gt;i_op-&gt;getxattr(dentry, name, buf, len);
<a name="l00641"></a>00641 }
<a name="l00642"></a>00642 
<a name="l00643"></a>00643 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> __osd_xattr_set(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info,
<a name="l00644"></a>00644                                   <span class="keyword">struct</span> inode *inode, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00645"></a>00645                                   <span class="keyword">const</span> <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> buflen, <span class="keywordtype">int</span> fl)
<a name="l00646"></a>00646 {
<a name="l00647"></a>00647         <span class="keyword">struct </span>dentry *dentry = &amp;info-&gt;oti_child_dentry;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         ll_vfs_dq_init(inode);
<a name="l00650"></a>00650         dentry-&gt;d_inode = inode;
<a name="l00651"></a>00651         dentry-&gt;d_sb = inode-&gt;i_sb;
<a name="l00652"></a>00652         <span class="keywordflow">return</span> inode-&gt;i_op-&gt;setxattr(dentry, name, buf, buflen, fl);
<a name="l00653"></a>00653 }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655 <span class="preprocessor">#ifdef CONFIG_PROC_FS</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span><span class="comment">/* osd_lproc.c */</span>
<a name="l00657"></a>00657 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlprocfs__vars.html">lprocfs_vars</a> lprocfs_osd_obd_vars[];
<a name="l00658"></a>00658 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlprocfs__vars.html">lprocfs_vars</a> lprocfs_osd_module_vars[];
<a name="l00659"></a>00659 <span class="keywordtype">int</span> osd_procfs_init(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd, <span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l00660"></a>00660 <span class="keywordtype">int</span> osd_procfs_fini(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd);
<a name="l00661"></a>00661 <span class="keywordtype">void</span> osd_brw_stats_update(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd, <span class="keyword">struct</span> <a class="code" href="structosd__iobuf.html">osd_iobuf</a> *iobuf);
<a name="l00662"></a>00662 <span class="preprocessor">#if LUSTRE_VERSION_CODE &lt; OBD_OCD_VERSION(3, 0, 52, 0)</span>
<a name="l00663"></a>00663 <span class="preprocessor"></span><span class="keywordtype">int</span> osd_register_proc_index_in_idif(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd);
<a name="l00664"></a>00664 <span class="preprocessor">#endif</span>
<a name="l00665"></a>00665 <span class="preprocessor"></span>
<a name="l00666"></a>00666 <span class="preprocessor">#endif</span>
<a name="l00667"></a>00667 <span class="preprocessor"></span><span class="keywordtype">int</span> osd_statfs(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__device.html">dt_device</a> *dev,
<a name="l00668"></a>00668                <span class="keyword">struct</span> <a class="code" href="structobd__statfs.html">obd_statfs</a> *sfs);
<a name="l00669"></a>00669 <span class="keyword">struct </span>inode *osd_iget(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev,
<a name="l00670"></a>00670                        <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>);
<a name="l00671"></a>00671 <span class="keywordtype">int</span> osd_ea_fid_set(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> inode *inode,
<a name="l00672"></a>00672                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, __u32 compat, __u32 incompat);
<a name="l00673"></a>00673 <span class="keywordtype">int</span> osd_get_lma(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> inode *inode,
<a name="l00674"></a>00674                 <span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> <a class="code" href="structlustre__mdt__attrs.html" title="Following struct for object attributes, that will be kept inode&amp;#39;s EA.">lustre_mdt_attrs</a> *lma);
<a name="l00675"></a>00675 <span class="keywordtype">void</span> osd_add_oi_cache(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00676"></a>00676                       <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid);
<a name="l00677"></a>00677 <span class="keywordtype">int</span> osd_get_idif(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> inode *inode,
<a name="l00678"></a>00678                  <span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid);
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 <span class="keywordtype">int</span> osd_obj_map_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd);
<a name="l00681"></a>00681 <span class="keywordtype">void</span> osd_obj_map_fini(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev);
<a name="l00682"></a>00682 <span class="keywordtype">int</span> osd_obj_map_lookup(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00683"></a>00683                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>);
<a name="l00684"></a>00684 <span class="keywordtype">int</span> osd_obj_map_insert(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00685"></a>00685                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>,
<a name="l00686"></a>00686                        handle_t *th);
<a name="l00687"></a>00687 <span class="keywordtype">int</span> osd_obj_map_delete(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00688"></a>00688                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, handle_t *th);
<a name="l00689"></a>00689 <span class="keywordtype">int</span> osd_obj_map_update(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00690"></a>00690                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>,
<a name="l00691"></a>00691                        handle_t *th);
<a name="l00692"></a>00692 <span class="keywordtype">int</span> osd_obj_map_recover(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00693"></a>00693                         <span class="keyword">struct</span> inode *src_parent, <span class="keyword">struct</span> dentry *src_child,
<a name="l00694"></a>00694                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid);
<a name="l00695"></a>00695 <span class="keywordtype">int</span> osd_obj_spec_lookup(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00696"></a>00696                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>);
<a name="l00697"></a>00697 <span class="keywordtype">int</span> osd_obj_spec_insert(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00698"></a>00698                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>,
<a name="l00699"></a>00699                         handle_t *th);
<a name="l00700"></a>00700 <span class="keywordtype">int</span> osd_obj_spec_update(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00701"></a>00701                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>,
<a name="l00702"></a>00702                         handle_t *th);
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 <span class="keywordtype">void</span> osd_scrub_file_reset(<span class="keyword">struct</span> <a class="code" href="structosd__scrub.html">osd_scrub</a> *scrub, __u8 *uuid, __u64 flags);
<a name="l00705"></a>00705 <span class="keywordtype">int</span> osd_scrub_file_store(<span class="keyword">struct</span> <a class="code" href="structosd__scrub.html">osd_scrub</a> *scrub);
<a name="l00706"></a>00706 <span class="keywordtype">char</span> *osd_lf_fid2name(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid);
<a name="l00707"></a>00707 <span class="keywordtype">int</span> osd_scrub_start(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev, __u32 flags);
<a name="l00708"></a>00708 <span class="keywordtype">int</span> osd_scrub_setup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev);
<a name="l00709"></a>00709 <span class="keywordtype">void</span> osd_scrub_cleanup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev);
<a name="l00710"></a>00710 <span class="keywordtype">int</span> osd_oii_insert(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev, <span class="keyword">struct</span> <a class="code" href="structosd__idmap__cache.html">osd_idmap_cache</a> *oic,
<a name="l00711"></a>00711                    <span class="keywordtype">int</span> insert);
<a name="l00712"></a>00712 <span class="keywordtype">int</span> osd_oii_lookup(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00713"></a>00713                    <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>);
<a name="l00714"></a>00714 <span class="keywordtype">int</span> osd_scrub_dump(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="keywordtype">int</span> osd_fld_lookup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00717"></a>00717                    u64 seq, <span class="keyword">struct</span> <a class="code" href="structlu__seq__range.html" title="Describes a range of sequence, lsr_start is included but lsr_end is not in the range...">lu_seq_range</a> *range);
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="keywordtype">int</span> osd_delete_from_remote_parent(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00720"></a>00720                                   <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00721"></a>00721                                   <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj,
<a name="l00722"></a>00722                                   <span class="keyword">struct</span> <a class="code" href="structosd__thandle.html">osd_thandle</a> *oh);
<a name="l00723"></a>00723 <span class="keywordtype">int</span> osd_add_to_remote_parent(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00724"></a>00724                              <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structosd__thandle.html">osd_thandle</a> *oh);
<a name="l00725"></a>00725 <span class="keywordtype">int</span> osd_lookup_in_remote_parent(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *oti,
<a name="l00726"></a>00726                                 <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00727"></a>00727                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00728"></a>00728                                 <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>);
<a name="l00729"></a>00729 
<a name="l00730"></a>00730 <span class="keywordtype">int</span> osd_ost_seq_exists(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00731"></a>00731                        __u64 seq);
<a name="l00732"></a>00732 <span class="comment">/* osd_quota_fmt.c */</span>
<a name="l00733"></a>00733 <span class="keywordtype">int</span> walk_tree_dqentry(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj,
<a name="l00734"></a>00734                       <span class="keywordtype">int</span> type, uint blk, <span class="keywordtype">int</span> depth, uint index,
<a name="l00735"></a>00735                       <span class="keyword">struct</span> <a class="code" href="structosd__it__quota.html" title="Iterator&amp;#39;s in-memory data structure for quota file.">osd_it_quota</a> *it);
<a name="l00736"></a>00736 <span class="keywordtype">int</span> walk_block_dqentry(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj,
<a name="l00737"></a>00737                        <span class="keywordtype">int</span> type, uint blk, uint index,
<a name="l00738"></a>00738                        <span class="keyword">struct</span> <a class="code" href="structosd__it__quota.html" title="Iterator&amp;#39;s in-memory data structure for quota file.">osd_it_quota</a> *it);
<a name="l00739"></a>00739 loff_t find_tree_dqentry(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00740"></a>00740                          <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj, <span class="keywordtype">int</span> type,
<a name="l00741"></a>00741                          qid_t dqid, uint blk, <span class="keywordtype">int</span> depth,
<a name="l00742"></a>00742                          <span class="keyword">struct</span> <a class="code" href="structosd__it__quota.html" title="Iterator&amp;#39;s in-memory data structure for quota file.">osd_it_quota</a> *it);
<a name="l00743"></a>00743 <span class="comment">/* osd_quota.c */</span>
<a name="l00744"></a>00744 <span class="keywordtype">int</span> osd_declare_qid(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosd__thandle.html">osd_thandle</a> *oh,
<a name="l00745"></a>00745                     <span class="keyword">struct</span> <a class="code" href="structlquota__id__info.html">lquota_id_info</a> *qi, <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj,
<a name="l00746"></a>00746                     <span class="keywordtype">bool</span> enforce, <span class="keywordtype">int</span> *flags);
<a name="l00747"></a>00747 <span class="keywordtype">int</span> osd_declare_inode_qid(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, qid_t uid, qid_t gid,
<a name="l00748"></a>00748                           <span class="keywordtype">long</span> <span class="keywordtype">long</span> space, <span class="keyword">struct</span> <a class="code" href="structosd__thandle.html">osd_thandle</a> *oh,
<a name="l00749"></a>00749                           <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj, <span class="keywordtype">bool</span> is_blk, <span class="keywordtype">int</span> *flags,
<a name="l00750"></a>00750                           <span class="keywordtype">bool</span> force);
<a name="l00751"></a>00751 <span class="keyword">const</span> <span class="keyword">struct </span>dt_rec *osd_quota_pack(<span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj,
<a name="l00752"></a>00752                                     <span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *rec,
<a name="l00753"></a>00753                                     <span class="keyword">union</span> <a class="code" href="unionlquota__rec.html">lquota_rec</a> *quota_rec);
<a name="l00754"></a>00754 <span class="keywordtype">void</span> osd_quota_unpack(<span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj, <span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *rec);
<a name="l00755"></a>00755 <span class="keywordtype">int</span> osd_quota_migration(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt);
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 <span class="preprocessor">#ifndef HAVE_I_UID_READ</span>
<a name="l00758"></a>00758 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> uid_t i_uid_read(<span class="keyword">const</span> <span class="keyword">struct</span> inode *inode)
<a name="l00759"></a>00759 {
<a name="l00760"></a>00760         <span class="keywordflow">return</span> inode-&gt;i_uid;
<a name="l00761"></a>00761 }
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 <span class="keyword">static</span> <span class="keyword">inline</span> gid_t i_gid_read(<span class="keyword">const</span> <span class="keyword">struct</span> inode *inode)
<a name="l00764"></a>00764 {
<a name="l00765"></a>00765         <span class="keywordflow">return</span> inode-&gt;i_gid;
<a name="l00766"></a>00766 }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> i_uid_write(<span class="keyword">struct</span> inode *inode, uid_t uid)
<a name="l00769"></a>00769 {
<a name="l00770"></a>00770         inode-&gt;i_uid = uid;
<a name="l00771"></a>00771 }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> i_gid_write(<span class="keyword">struct</span> inode *inode, gid_t gid)
<a name="l00774"></a>00774 {
<a name="l00775"></a>00775         inode-&gt;i_gid = gid;
<a name="l00776"></a>00776 }
<a name="l00777"></a>00777 <span class="preprocessor">#endif</span>
<a name="l00778"></a>00778 <span class="preprocessor"></span>
<a name="l00779"></a>00779 <span class="preprocessor">#ifdef LDISKFS_HT_MISC</span>
<a name="l00780"></a>00780 <span class="preprocessor"></span><span class="preprocessor"># define osd_journal_start_sb(sb, type, nblock) \</span>
<a name="l00781"></a>00781 <span class="preprocessor">                ldiskfs_journal_start_sb(sb, type, nblock)</span>
<a name="l00782"></a>00782 <span class="preprocessor"></span><span class="preprocessor"># define osd_ldiskfs_append(handle, inode, nblock) \</span>
<a name="l00783"></a>00783 <span class="preprocessor">                ldiskfs_append(handle, inode, nblock)</span>
<a name="l00784"></a>00784 <span class="preprocessor"></span><span class="preprocessor"># define osd_ldiskfs_find_entry(dir, name, de, inlined, lock) \</span>
<a name="l00785"></a>00785 <span class="preprocessor">                __ldiskfs_find_entry(dir, name, de, inlined, lock)</span>
<a name="l00786"></a>00786 <span class="preprocessor"></span><span class="preprocessor"># define osd_journal_start(inode, type, nblocks) \</span>
<a name="l00787"></a>00787 <span class="preprocessor">                ldiskfs_journal_start(inode, type, nblocks)</span>
<a name="l00788"></a>00788 <span class="preprocessor"></span><span class="preprocessor"># define osd_transaction_size(dev) \</span>
<a name="l00789"></a>00789 <span class="preprocessor">                (osd_journal(dev)-&gt;j_max_transaction_buffers / 2)</span>
<a name="l00790"></a>00790 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00791"></a>00791 <span class="preprocessor"></span><span class="preprocessor"># define LDISKFS_HT_MISC        0</span>
<a name="l00792"></a>00792 <span class="preprocessor"></span><span class="preprocessor"># define osd_journal_start_sb(sb, type, nblock) \</span>
<a name="l00793"></a>00793 <span class="preprocessor">                ldiskfs_journal_start_sb(sb, nblock)</span>
<a name="l00794"></a>00794 <span class="preprocessor"></span>
<a name="l00795"></a>00795 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>buffer_head *osd_ldiskfs_append(handle_t *handle,
<a name="l00796"></a>00796                                                      <span class="keyword">struct</span> inode *inode,
<a name="l00797"></a>00797                                                      ldiskfs_lblk_t *nblock)
<a name="l00798"></a>00798 {
<a name="l00799"></a>00799         <span class="keyword">struct </span>buffer_head *bh;
<a name="l00800"></a>00800         <span class="keywordtype">int</span> err = 0;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802         bh = ldiskfs_append(handle, inode, nblock, &amp;err);
<a name="l00803"></a>00803         <span class="keywordflow">if</span> (bh == NULL)
<a name="l00804"></a>00804                 bh = ERR_PTR(err);
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         <span class="keywordflow">return</span> bh;
<a name="l00807"></a>00807 }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 <span class="preprocessor"># define osd_ldiskfs_find_entry(dir, name, de, inlined, lock) \</span>
<a name="l00810"></a>00810 <span class="preprocessor">                __ldiskfs_find_entry(dir, name, de, lock)</span>
<a name="l00811"></a>00811 <span class="preprocessor"></span><span class="preprocessor"># define osd_journal_start(inode, type, nblocks) \</span>
<a name="l00812"></a>00812 <span class="preprocessor">                ldiskfs_journal_start(inode, nblocks)</span>
<a name="l00813"></a>00813 <span class="preprocessor"></span><span class="preprocessor"># define osd_transaction_size(dev) \</span>
<a name="l00814"></a>00814 <span class="preprocessor">                (osd_journal(dev)-&gt;j_max_transaction_buffers)</span>
<a name="l00815"></a>00815 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00816"></a>00816 <span class="preprocessor"></span>
<a name="l00817"></a>00817 <span class="comment">/*</span>
<a name="l00818"></a>00818 <span class="comment"> * Invariants, assertions.</span>
<a name="l00819"></a>00819 <span class="comment"> */</span>
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 <span class="comment">/*</span>
<a name="l00822"></a>00822 <span class="comment"> * XXX: do not enable this, until invariant checking code is made thread safe</span>
<a name="l00823"></a>00823 <span class="comment"> * in the face of pdirops locking.</span>
<a name="l00824"></a>00824 <span class="comment"> */</span>
<a name="l00825"></a>00825 <span class="preprocessor">#define OSD_INVARIANT_CHECKS (0)</span>
<a name="l00826"></a>00826 <span class="preprocessor"></span>
<a name="l00827"></a>00827 <span class="preprocessor">#if OSD_INVARIANT_CHECKS</span>
<a name="l00828"></a>00828 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> osd_invariant(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj)
<a name="l00829"></a>00829 {
<a name="l00830"></a>00830         <span class="keywordflow">return</span>
<a name="l00831"></a>00831                 obj != NULL &amp;&amp;
<a name="l00832"></a>00832                 ergo(obj-&gt;<a class="code" href="structosd__object.html#ae81e0028f4f47ba8d7bebb5f2d983e12" title="Inode for file system object represented by this osd_object.">oo_inode</a> != NULL,
<a name="l00833"></a>00833                      obj-&gt;<a class="code" href="structosd__object.html#ae81e0028f4f47ba8d7bebb5f2d983e12" title="Inode for file system object represented by this osd_object.">oo_inode</a>-&gt;i_sb == osd_sb(osd_obj2dev(obj)) &amp;&amp;
<a name="l00834"></a>00834                      atomic_read(&amp;obj-&gt;<a class="code" href="structosd__object.html#ae81e0028f4f47ba8d7bebb5f2d983e12" title="Inode for file system object represented by this osd_object.">oo_inode</a>-&gt;i_count) &gt; 0) &amp;&amp;
<a name="l00835"></a>00835                 ergo(obj-&gt;oo_dir != NULL &amp;&amp;
<a name="l00836"></a>00836                      obj-&gt;oo_dir-&gt;od_conationer.ic_object != NULL,
<a name="l00837"></a>00837                      obj-&gt;oo_dir-&gt;od_conationer.ic_object == obj-&gt;<a class="code" href="structosd__object.html#ae81e0028f4f47ba8d7bebb5f2d983e12" title="Inode for file system object represented by this osd_object.">oo_inode</a>);
<a name="l00838"></a>00838 }
<a name="l00839"></a>00839 <span class="preprocessor">#else</span>
<a name="l00840"></a>00840 <span class="preprocessor"></span><span class="preprocessor">#define osd_invariant(obj) (1)</span>
<a name="l00841"></a>00841 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00842"></a>00842 <span class="preprocessor"></span>
<a name="l00843"></a>00843 <span class="preprocessor">#define OSD_MAX_CACHE_SIZE OBD_OBJECT_EOF</span>
<a name="l00844"></a>00844 <span class="preprocessor"></span>
<a name="l00845"></a>00845 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__index__operations.html" title="Per-dt-object operations on object as index.">dt_index_operations</a> osd_otable_ops;
<a name="l00846"></a>00846 
<a name="l00847"></a>00847 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> osd_oi_fid2idx(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev,
<a name="l00848"></a>00848                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00849"></a>00849 {
<a name="l00850"></a>00850         <span class="keywordflow">return</span> fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> &amp; (dev-&gt;od_oi_count - 1);
<a name="l00851"></a>00851 }
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosd__oi.html">osd_oi</a> *osd_fid2oi(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l00854"></a>00854                                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00855"></a>00855 {
<a name="l00856"></a>00856         LASSERTF(!fid_is_idif(fid), DFID<span class="stringliteral">&quot;\n&quot;</span>, PFID(fid));
<a name="l00857"></a>00857         LASSERTF(!fid_is_last_id(fid), DFID<span class="stringliteral">&quot;\n&quot;</span>, PFID(fid));
<a name="l00858"></a>00858         LASSERTF(osd-&gt;od_oi_table != NULL &amp;&amp; osd-&gt;od_oi_count &gt;= 1,
<a name="l00859"></a>00859                  DFID<span class="stringliteral">&quot;\n&quot;</span>, PFID(fid));
<a name="l00860"></a>00860         <span class="comment">/* It can work even od_oi_count equals to 1 although it&apos;s unexpected,</span>
<a name="l00861"></a>00861 <span class="comment">         * the only reason we set it to 1 is for performance measurement */</span>
<a name="l00862"></a>00862         <span class="keywordflow">return</span> osd-&gt;od_oi_table[osd_oi_fid2idx(osd, fid)];
<a name="l00863"></a>00863 }
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__device__operations.html" title="Operations common for data and meta-data devices.">lu_device_operations</a>  osd_lu_ops;
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lu_device_is_osd(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *d)
<a name="l00868"></a>00868 {
<a name="l00869"></a>00869         <span class="keywordflow">return</span> ergo(d != NULL &amp;&amp; d-&gt;<a class="code" href="structlu__device.html#a4cab097ca33e55a7255ad1d848596827" title="Operation vector for this device.">ld_ops</a> != NULL, d-&gt;<a class="code" href="structlu__device.html#a4cab097ca33e55a7255ad1d848596827" title="Operation vector for this device.">ld_ops</a> == &amp;osd_lu_ops);
<a name="l00870"></a>00870 }
<a name="l00871"></a>00871 
<a name="l00872"></a>00872 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosd__device.html">osd_device</a> *osd_dt_dev(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdt__device.html">dt_device</a> *d)
<a name="l00873"></a>00873 {
<a name="l00874"></a>00874         LASSERT(lu_device_is_osd(&amp;d-&gt;dd_lu_dev));
<a name="l00875"></a>00875         <span class="keywordflow">return</span> container_of0(d, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a>, od_dt_dev);
<a name="l00876"></a>00876 }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosd__device.html">osd_device</a> *osd_dev(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *d)
<a name="l00879"></a>00879 {
<a name="l00880"></a>00880         LASSERT(lu_device_is_osd(d));
<a name="l00881"></a>00881         <span class="keywordflow">return</span> osd_dt_dev(container_of0(d, <span class="keyword">struct</span> <a class="code" href="structdt__device.html">dt_device</a>, dd_lu_dev));
<a name="l00882"></a>00882 }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosd__device.html">osd_device</a> *osd_obj2dev(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *o)
<a name="l00885"></a>00885 {
<a name="l00886"></a>00886         <span class="keywordflow">return</span> osd_dev(o-&gt;oo_dt.do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>super_block *osd_sb(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev)
<a name="l00890"></a>00890 {
<a name="l00891"></a>00891         <span class="keywordflow">return</span> dev-&gt;od_mnt-&gt;mnt_sb;
<a name="l00892"></a>00892 }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> osd_object_is_root(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a> *obj)
<a name="l00895"></a>00895 {
<a name="l00896"></a>00896         <span class="keywordflow">return</span> osd_sb(osd_obj2dev(obj))-&gt;s_root-&gt;d_inode == obj-&gt;<a class="code" href="structosd__object.html#ae81e0028f4f47ba8d7bebb5f2d983e12" title="Inode for file system object represented by this osd_object.">oo_inode</a>;
<a name="l00897"></a>00897 }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosd__object.html">osd_object</a> *osd_obj(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *o)
<a name="l00900"></a>00900 {
<a name="l00901"></a>00901         LASSERT(lu_device_is_osd(o-&gt;<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>));
<a name="l00902"></a>00902         <span class="keywordflow">return</span> container_of0(o, <span class="keyword">struct</span> <a class="code" href="structosd__object.html">osd_object</a>, oo_dt.do_lu);
<a name="l00903"></a>00903 }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosd__object.html">osd_object</a> *osd_dt_obj(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *d)
<a name="l00906"></a>00906 {
<a name="l00907"></a>00907         <span class="keywordflow">return</span> osd_obj(&amp;d-&gt;do_lu);
<a name="l00908"></a>00908 }
<a name="l00909"></a>00909 
<a name="l00910"></a>00910 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *osd2lu_dev(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd)
<a name="l00911"></a>00911 {
<a name="l00912"></a>00912         <span class="keywordflow">return</span> &amp;osd-&gt;od_dt_dev.dd_lu_dev;
<a name="l00913"></a>00913 }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915 <span class="keyword">static</span> <span class="keyword">inline</span> journal_t *osd_journal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev)
<a name="l00916"></a>00916 {
<a name="l00917"></a>00917         <span class="keywordflow">return</span> LDISKFS_SB(osd_sb(dev))-&gt;s_journal;
<a name="l00918"></a>00918 }
<a name="l00919"></a>00919 
<a name="l00920"></a>00920 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structseq__server__site.html">seq_server_site</a> *osd_seq_site(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd)
<a name="l00921"></a>00921 {
<a name="l00922"></a>00922         <span class="keywordflow">return</span> osd-&gt;od_dt_dev.dd_lu_dev.<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>-&gt;<a class="code" href="structlu__site.html#ae7ef4565e0e4634a56ca97fbb552d271" title="XXX: a hack! fld has to find md_site via site, remove when possible.">ld_seq_site</a>;
<a name="l00923"></a>00923 }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span> *osd_name(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd)
<a name="l00926"></a>00926 {
<a name="l00927"></a>00927         <span class="keywordflow">return</span> osd-&gt;od_dt_dev.dd_lu_dev.<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name;
<a name="l00928"></a>00928 }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> osd_is_ea_inode(<span class="keyword">struct</span> inode *inode)
<a name="l00931"></a>00931 {
<a name="l00932"></a>00932         <span class="keywordflow">return</span> !!(LDISKFS_I(inode)-&gt;i_flags &amp; LDISKFS_EA_INODE_FL);
<a name="l00933"></a>00933 }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__body__operations.html" title="Per-dt-object operations on &amp;quot;file body&amp;quot; - unstructure raw data.">dt_body_operations</a> osd_body_ops;
<a name="l00936"></a>00936 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> osd_key;
<a name="l00937"></a>00937 
<a name="l00938"></a>00938 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosd__thread__info.html">osd_thread_info</a> *osd_oti_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l00939"></a>00939 {
<a name="l00940"></a>00940         <span class="keywordflow">return</span> <a class="code" href="group__lu.html#ga8fcebe57d8fb288a73a39144693074af" title="Return value associated with key key in context ctx.">lu_context_key_get</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>, &amp;osd_key);
<a name="l00941"></a>00941 }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__body__operations.html" title="Per-dt-object operations on &amp;quot;file body&amp;quot; - unstructure raw data.">dt_body_operations</a> osd_body_ops_new;
<a name="l00944"></a>00944 
<a name="l00948"></a>00948 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00949"></a>00949 <span class="keyword">struct </span><a class="code" href="structiam__path__descr.html">iam_path_descr</a> *osd_it_ipd_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00950"></a>00950                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structiam__container.html">iam_container</a> *bag)
<a name="l00951"></a>00951 {
<a name="l00952"></a>00952         <span class="keywordflow">return</span> bag-&gt;ic_descr-&gt;id_ops-&gt;id_ipd_alloc(bag,
<a name="l00953"></a>00953                                            osd_oti_get(env)-&gt;oti_it_ipd);
<a name="l00954"></a>00954 }
<a name="l00955"></a>00955 
<a name="l00956"></a>00956 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00957"></a>00957 <span class="keyword">struct </span><a class="code" href="structiam__path__descr.html">iam_path_descr</a> *osd_idx_ipd_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00958"></a>00958                                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structiam__container.html">iam_container</a> *bag)
<a name="l00959"></a>00959 {
<a name="l00960"></a>00960         <span class="keywordflow">return</span> bag-&gt;ic_descr-&gt;id_ops-&gt;id_ipd_alloc(bag,
<a name="l00961"></a>00961                                            osd_oti_get(env)-&gt;oti_idx_ipd);
<a name="l00962"></a>00962 }
<a name="l00963"></a>00963 
<a name="l00964"></a>00964 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> osd_ipd_put(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00965"></a>00965                                <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structiam__container.html">iam_container</a> *bag,
<a name="l00966"></a>00966                                <span class="keyword">struct</span> <a class="code" href="structiam__path__descr.html">iam_path_descr</a> *ipd)
<a name="l00967"></a>00967 {
<a name="l00968"></a>00968         bag-&gt;ic_descr-&gt;id_ops-&gt;id_ipd_free(ipd);
<a name="l00969"></a>00969 }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 <span class="keywordtype">int</span> osd_calc_bkmap_credits(<span class="keyword">struct</span> super_block *sb, <span class="keyword">struct</span> inode *inode,
<a name="l00972"></a>00972                            <span class="keyword">const</span> loff_t size, <span class="keyword">const</span> loff_t pos,
<a name="l00973"></a>00973                            <span class="keyword">const</span> <span class="keywordtype">int</span> blocks);
<a name="l00974"></a>00974 
<a name="l00975"></a>00975 <span class="keywordtype">int</span> osd_ldiskfs_read(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> size, loff_t *offs);
<a name="l00976"></a>00976 <span class="keywordtype">int</span> osd_ldiskfs_write_record(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> bufsize,
<a name="l00977"></a>00977                              <span class="keywordtype">int</span> write_NUL, loff_t *offs, handle_t *handle);
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00980"></a>00980 <span class="keyword">struct </span>dentry *osd_child_dentry_by_inode(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00981"></a>00981                                          <span class="keyword">struct</span> inode *inode,
<a name="l00982"></a>00982                                          <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">int</span> namelen)
<a name="l00983"></a>00983 {
<a name="l00984"></a>00984         <span class="keyword">struct </span><a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info = osd_oti_get(env);
<a name="l00985"></a>00985         <span class="keyword">struct </span>dentry *child_dentry = &amp;info-&gt;oti_child_dentry;
<a name="l00986"></a>00986         <span class="keyword">struct </span>dentry *obj_dentry = &amp;info-&gt;<a class="code" href="structosd__thread__info.html#ab13060bad7d6407028bc061f3e0fd5f5" title="used for index operations.">oti_obj_dentry</a>;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988         obj_dentry-&gt;d_inode = inode;
<a name="l00989"></a>00989         obj_dentry-&gt;d_sb = inode-&gt;i_sb;
<a name="l00990"></a>00990         obj_dentry-&gt;d_name.hash = 0;
<a name="l00991"></a>00991 
<a name="l00992"></a>00992         child_dentry-&gt;d_name.hash = 0;
<a name="l00993"></a>00993         child_dentry-&gt;d_parent = obj_dentry;
<a name="l00994"></a>00994         child_dentry-&gt;d_name.name = name;
<a name="l00995"></a>00995         child_dentry-&gt;d_name.len = namelen;
<a name="l00996"></a>00996         <span class="keywordflow">return</span> child_dentry;
<a name="l00997"></a>00997 }
<a name="l00998"></a>00998 
<a name="l00999"></a>00999 <span class="keyword">extern</span> <span class="keywordtype">int</span> osd_trans_declare_op2rb[];
<a name="l01000"></a>01000 <span class="keyword">extern</span> <span class="keywordtype">int</span> ldiskfs_track_declares_assert;
<a name="l01001"></a>01001 <span class="keywordtype">void</span> osd_trans_dump_creds(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> osd_trans_declare_op(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01004"></a>01004                                         <span class="keyword">struct</span> <a class="code" href="structosd__thandle.html">osd_thandle</a> *oh,
<a name="l01005"></a>01005                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> op, <span class="keywordtype">int</span> credits)
<a name="l01006"></a>01006 {
<a name="l01007"></a>01007         <span class="keyword">struct </span><a class="code" href="structosd__thread__info.html">osd_thread_info</a> *oti = osd_oti_get(env);
<a name="l01008"></a>01008 
<a name="l01009"></a>01009         LASSERT(oh-&gt;ot_handle == NULL);
<a name="l01010"></a>01010         <span class="keywordflow">if</span> (unlikely(op &gt;= OSD_OT_MAX)) {
<a name="l01011"></a>01011                 <span class="keywordflow">if</span> (unlikely(ldiskfs_track_declares_assert)) {
<a name="l01012"></a>01012                         LASSERT(op &lt; OSD_OT_MAX);
<a name="l01013"></a>01013                 } <span class="keywordflow">else</span> {
<a name="l01014"></a>01014                         CWARN(<span class="stringliteral">&quot;%s: Invalid operation index %d\n&quot;</span>,
<a name="l01015"></a>01015                               osd_name(osd_dt_dev(oh-&gt;ot_super.<a class="code" href="structthandle.html#ade585afae0d30b274a8259d402e918b6" title="the dt device on which the transactions are executed">th_dev</a>)), op);
<a name="l01016"></a>01016                         libcfs_debug_dumpstack(NULL);
<a name="l01017"></a>01017                 }
<a name="l01018"></a>01018         } <span class="keywordflow">else</span> {
<a name="l01019"></a>01019                 oti-&gt;oti_declare_ops[op]++;
<a name="l01020"></a>01020                 oti-&gt;oti_declare_ops_cred[op] += credits;
<a name="l01021"></a>01021         }
<a name="l01022"></a>01022         oh-&gt;ot_credits += credits;
<a name="l01023"></a>01023 }
<a name="l01024"></a>01024 
<a name="l01025"></a>01025 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> osd_trans_exec_op(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01026"></a>01026                                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> op)
<a name="l01027"></a>01027 {
<a name="l01028"></a>01028         <span class="keyword">struct </span><a class="code" href="structosd__thread__info.html">osd_thread_info</a> *oti = osd_oti_get(env);
<a name="l01029"></a>01029         <span class="keyword">struct </span><a class="code" href="structosd__thandle.html">osd_thandle</a>     *oh  = container_of(th, <span class="keyword">struct</span> <a class="code" href="structosd__thandle.html">osd_thandle</a>,
<a name="l01030"></a>01030                                                    ot_super);
<a name="l01031"></a>01031         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            rb, left;
<a name="l01032"></a>01032 
<a name="l01033"></a>01033         LASSERT(oh-&gt;ot_handle != NULL);
<a name="l01034"></a>01034         <span class="keywordflow">if</span> (unlikely(op &gt;= OSD_OT_MAX)) {
<a name="l01035"></a>01035                 <span class="keywordflow">if</span> (unlikely(ldiskfs_track_declares_assert))
<a name="l01036"></a>01036                         LASSERT(op &lt; OSD_OT_MAX);
<a name="l01037"></a>01037                 <span class="keywordflow">else</span> {
<a name="l01038"></a>01038                         CWARN(<span class="stringliteral">&quot;%s: Invalid operation index %d\n&quot;</span>,
<a name="l01039"></a>01039                               osd_name(osd_dt_dev(oh-&gt;ot_super.<a class="code" href="structthandle.html#ade585afae0d30b274a8259d402e918b6" title="the dt device on which the transactions are executed">th_dev</a>)), op);
<a name="l01040"></a>01040                         libcfs_debug_dumpstack(NULL);
<a name="l01041"></a>01041                         <span class="keywordflow">return</span>;
<a name="l01042"></a>01042                 }
<a name="l01043"></a>01043         }
<a name="l01044"></a>01044 
<a name="l01045"></a>01045         <span class="comment">/* find rollback (or reverse) operation for the given one</span>
<a name="l01046"></a>01046 <span class="comment">         * such an operation doesn&apos;t require additional credits</span>
<a name="l01047"></a>01047 <span class="comment">         * as the same set of blocks are modified */</span>
<a name="l01048"></a>01048         rb = osd_trans_declare_op2rb[op];
<a name="l01049"></a>01049 
<a name="l01050"></a>01050         <span class="comment">/* check whether credits for this operation were reserved at all */</span>
<a name="l01051"></a>01051         <span class="keywordflow">if</span> (unlikely(oti-&gt;oti_declare_ops_cred[op] == 0 &amp;&amp;
<a name="l01052"></a>01052                      oti-&gt;oti_declare_ops_cred[rb] == 0)) {
<a name="l01053"></a>01053                 <span class="comment">/* the API is not perfect yet: CREATE does REF_ADD internally</span>
<a name="l01054"></a>01054 <span class="comment">                 * while DESTROY does not. To rollback CREATE the callers</span>
<a name="l01055"></a>01055 <span class="comment">                 * needs to call REF_DEL+DESTROY which is hard to detect using</span>
<a name="l01056"></a>01056 <span class="comment">                 * a simple table of rollback operations */</span>
<a name="l01057"></a>01057                 <span class="keywordflow">if</span> (op == OSD_OT_REF_DEL &amp;&amp;
<a name="l01058"></a>01058                     oti-&gt;oti_declare_ops_cred[OSD_OT_CREATE] &gt; 0)
<a name="l01059"></a>01059                         <span class="keywordflow">goto</span> proceed;
<a name="l01060"></a>01060                 <span class="keywordflow">if</span> (op == OSD_OT_REF_ADD &amp;&amp;
<a name="l01061"></a>01061                     oti-&gt;oti_declare_ops_cred[OSD_OT_DESTROY] &gt; 0)
<a name="l01062"></a>01062                         <span class="keywordflow">goto</span> proceed;
<a name="l01063"></a>01063                 osd_trans_dump_creds(env, th);
<a name="l01064"></a>01064                 CERROR(<span class="stringliteral">&quot;%s: op = %d, rb = %d\n&quot;</span>,
<a name="l01065"></a>01065                        osd_name(osd_dt_dev(oh-&gt;ot_super.<a class="code" href="structthandle.html#ade585afae0d30b274a8259d402e918b6" title="the dt device on which the transactions are executed">th_dev</a>)), op, rb);
<a name="l01066"></a>01066                 <span class="keywordflow">if</span> (unlikely(ldiskfs_track_declares_assert))
<a name="l01067"></a>01067                         LBUG();
<a name="l01068"></a>01068         }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070 proceed:
<a name="l01071"></a>01071         <span class="comment">/* remember how many credits we have unused before the operation */</span>
<a name="l01072"></a>01072         oti-&gt;oti_credits_before = oh-&gt;ot_handle-&gt;h_buffer_credits;
<a name="l01073"></a>01073         left = oti-&gt;oti_declare_ops_cred[op] - oti-&gt;oti_declare_ops_used[op];
<a name="l01074"></a>01074         <span class="keywordflow">if</span> (unlikely(oti-&gt;oti_credits_before &lt; left)) {
<a name="l01075"></a>01075                 osd_trans_dump_creds(env, th);
<a name="l01076"></a>01076                 CERROR(<span class="stringliteral">&quot;%s: op = %d, rb = %d\n&quot;</span>,
<a name="l01077"></a>01077                        osd_name(osd_dt_dev(oh-&gt;ot_super.<a class="code" href="structthandle.html#ade585afae0d30b274a8259d402e918b6" title="the dt device on which the transactions are executed">th_dev</a>)), op, rb);
<a name="l01078"></a>01078                 <span class="comment">/* on a very small fs (testing?) it&apos;s possible that</span>
<a name="l01079"></a>01079 <span class="comment">                 * the transaction can&apos;t fit 1/4 of journal, so we</span>
<a name="l01080"></a>01080 <span class="comment">                 * just request less credits (see osd_trans_start()).</span>
<a name="l01081"></a>01081 <span class="comment">                 * ignore the same case here */</span>
<a name="l01082"></a>01082                 rb = osd_transaction_size(osd_dt_dev(th-&gt;<a class="code" href="structthandle.html#ade585afae0d30b274a8259d402e918b6" title="the dt device on which the transactions are executed">th_dev</a>));
<a name="l01083"></a>01083                 <span class="keywordflow">if</span> (unlikely(oh-&gt;ot_credits &lt; rb)) {
<a name="l01084"></a>01084                         <span class="keywordflow">if</span> (unlikely(ldiskfs_track_declares_assert))
<a name="l01085"></a>01085                                 LBUG();
<a name="l01086"></a>01086                 }
<a name="l01087"></a>01087         }
<a name="l01088"></a>01088 }
<a name="l01089"></a>01089 
<a name="l01090"></a>01090 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> osd_trans_exec_check(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01091"></a>01091                                         <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th,
<a name="l01092"></a>01092                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> op)
<a name="l01093"></a>01093 {
<a name="l01094"></a>01094         <span class="keyword">struct </span><a class="code" href="structosd__thread__info.html">osd_thread_info</a> *oti = osd_oti_get(env);
<a name="l01095"></a>01095         <span class="keyword">struct </span><a class="code" href="structosd__thandle.html">osd_thandle</a>     *oh  = container_of(th, <span class="keyword">struct</span> <a class="code" href="structosd__thandle.html">osd_thandle</a>,
<a name="l01096"></a>01096                                                    ot_super);
<a name="l01097"></a>01097         <span class="keywordtype">int</span>                     used, over, quota;
<a name="l01098"></a>01098 
<a name="l01099"></a>01099         <span class="comment">/* how many credits have been used by the operation */</span>
<a name="l01100"></a>01100         used = oti-&gt;oti_credits_before - oh-&gt;ot_handle-&gt;h_buffer_credits;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102         <span class="keywordflow">if</span> (unlikely(used &lt; 0)) {
<a name="l01103"></a>01103                 <span class="comment">/* if some block was allocated and released in the same</span>
<a name="l01104"></a>01104 <span class="comment">                 * transaction, then it won&apos;t be a part of the transaction</span>
<a name="l01105"></a>01105 <span class="comment">                 * and delta can be negative */</span>
<a name="l01106"></a>01106                 <span class="keywordflow">return</span>;
<a name="l01107"></a>01107         }
<a name="l01108"></a>01108 
<a name="l01109"></a>01109         <span class="keywordflow">if</span> (used == 0) {
<a name="l01110"></a>01110                 <span class="comment">/* rollback operations (e.g. when we destroy just created</span>
<a name="l01111"></a>01111 <span class="comment">                 * object) should not consume any credits. there is no point</span>
<a name="l01112"></a>01112 <span class="comment">                 * to confuse the checks below */</span>
<a name="l01113"></a>01113                 <span class="keywordflow">return</span>;
<a name="l01114"></a>01114         }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116         oti-&gt;oti_declare_ops_used[op] += used;
<a name="l01117"></a>01117         <span class="keywordflow">if</span> (oti-&gt;oti_declare_ops_used[op] &lt;= oti-&gt;oti_declare_ops_cred[op])
<a name="l01118"></a>01118                 <span class="keywordflow">return</span>;
<a name="l01119"></a>01119 
<a name="l01120"></a>01120         <span class="comment">/* we account quota for a whole transaction and any operation can</span>
<a name="l01121"></a>01121 <span class="comment">         * consume corresponding credits */</span>
<a name="l01122"></a>01122         over = oti-&gt;oti_declare_ops_used[op] -
<a name="l01123"></a>01123                 oti-&gt;oti_declare_ops_cred[op];
<a name="l01124"></a>01124         quota = oti-&gt;oti_declare_ops_cred[OSD_OT_QUOTA] -
<a name="l01125"></a>01125                 oti-&gt;oti_declare_ops_used[OSD_OT_QUOTA];
<a name="l01126"></a>01126         <span class="keywordflow">if</span> (over &lt;= quota) {
<a name="l01127"></a>01127                 <span class="comment">/* probably that credits were consumed by</span>
<a name="l01128"></a>01128 <span class="comment">                 * quota indirectly (in the depths of ldiskfs) */</span>
<a name="l01129"></a>01129                 oti-&gt;oti_declare_ops_used[OSD_OT_QUOTA] += over;
<a name="l01130"></a>01130                 oti-&gt;oti_declare_ops_used[op] -= over;
<a name="l01131"></a>01131         } <span class="keywordflow">else</span> {
<a name="l01132"></a>01132                 CWARN(<span class="stringliteral">&quot;op %d: used %u, used now %u, reserved %u\n&quot;</span>,
<a name="l01133"></a>01133                       op, oti-&gt;oti_declare_ops_used[op], used,
<a name="l01134"></a>01134                       oti-&gt;oti_declare_ops_cred[op]);
<a name="l01135"></a>01135                 osd_trans_dump_creds(env, th);
<a name="l01136"></a>01136                 <span class="keywordflow">if</span> (unlikely(ldiskfs_track_declares_assert))
<a name="l01137"></a>01137                         LBUG();
<a name="l01138"></a>01138         }
<a name="l01139"></a>01139 }
<a name="l01140"></a>01140 
<a name="l01144"></a>01144 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01145"></a>01145 <span class="keywordtype">void</span> <a class="code" href="structosd__fid__pack.html" title="Storage representation for fids.">osd_fid_pack</a>(<span class="keyword">struct</span> <a class="code" href="structosd__fid__pack.html" title="Storage representation for fids.">osd_fid_pack</a> *pack, <span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *fid,
<a name="l01146"></a>01146                   <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *befider)
<a name="l01147"></a>01147 {
<a name="l01148"></a>01148         fid_cpu_to_be(befider, (<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *)fid);
<a name="l01149"></a>01149         memcpy(pack-&gt;fp_area, befider, <span class="keyword">sizeof</span>(*befider));
<a name="l01150"></a>01150         pack-&gt;fp_len =  <span class="keyword">sizeof</span>(*befider) + 1;
<a name="l01151"></a>01151 }
<a name="l01152"></a>01152 
<a name="l01153"></a>01153 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01154"></a>01154 <span class="keywordtype">int</span> osd_fid_unpack(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosd__fid__pack.html" title="Storage representation for fids.">osd_fid_pack</a> *pack)
<a name="l01155"></a>01155 {
<a name="l01156"></a>01156         <span class="keywordtype">int</span> result;
<a name="l01157"></a>01157 
<a name="l01158"></a>01158         result = 0;
<a name="l01159"></a>01159         <span class="keywordflow">switch</span> (pack-&gt;fp_len) {
<a name="l01160"></a>01160         <span class="keywordflow">case</span> <span class="keyword">sizeof</span> *fid + 1:
<a name="l01161"></a>01161                 memcpy(fid, pack-&gt;fp_area, <span class="keyword">sizeof</span> *fid);
<a name="l01162"></a>01162                 fid_be_to_cpu(fid, fid);
<a name="l01163"></a>01163                 <span class="keywordflow">break</span>;
<a name="l01164"></a>01164         <span class="keywordflow">default</span>:
<a name="l01165"></a>01165                 CERROR(<span class="stringliteral">&quot;Unexpected packed fid size: %d\n&quot;</span>, pack-&gt;fp_len);
<a name="l01166"></a>01166                 result = -EIO;
<a name="l01167"></a>01167         }
<a name="l01168"></a>01168         <span class="keywordflow">return</span> result;
<a name="l01169"></a>01169 }
<a name="l01170"></a>01170 
<a name="l01174"></a>01174 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__index__operations.html" title="Per-dt-object operations on object as index.">dt_index_operations</a> osd_acct_index_ops;
<a name="l01175"></a>01175 <span class="keywordtype">int</span> osd_acct_obj_lookup(<span class="keyword">struct</span> <a class="code" href="structosd__thread__info.html">osd_thread_info</a> *info, <span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *osd,
<a name="l01176"></a>01176                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">struct</span> <a class="code" href="structosd__inode__id.html">osd_inode_id</a> *<span class="keywordtype">id</span>);
<a name="l01177"></a>01177 
<a name="l01178"></a>01178 <span class="comment">/* copy from fs/ext4/dir.c */</span>
<a name="l01179"></a>01179 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> is_32bit_api(<span class="keywordtype">void</span>)
<a name="l01180"></a>01180 {
<a name="l01181"></a>01181 <span class="preprocessor">#ifdef CONFIG_COMPAT</span>
<a name="l01182"></a>01182 <span class="preprocessor"></span>        <span class="keywordflow">return</span> is_compat_task();
<a name="l01183"></a>01183 <span class="preprocessor">#else</span>
<a name="l01184"></a>01184 <span class="preprocessor"></span>        <span class="keywordflow">return</span> (BITS_PER_LONG == 32);
<a name="l01185"></a>01185 <span class="preprocessor">#endif</span>
<a name="l01186"></a>01186 <span class="preprocessor"></span>}
<a name="l01187"></a>01187 
<a name="l01188"></a>01188 <span class="keyword">static</span> <span class="keyword">inline</span> loff_t ldiskfs_get_htree_eof(<span class="keyword">struct</span> file *filp)
<a name="l01189"></a>01189 {
<a name="l01190"></a>01190         <span class="keywordflow">if</span> ((filp-&gt;f_mode &amp; FMODE_32BITHASH) ||
<a name="l01191"></a>01191             (!(filp-&gt;f_mode &amp; FMODE_64BITHASH) &amp;&amp; is_32bit_api()))
<a name="l01192"></a>01192                 <span class="keywordflow">return</span> LDISKFS_HTREE_EOF_32BIT;
<a name="l01193"></a>01193         <span class="keywordflow">else</span>
<a name="l01194"></a>01194                 <span class="keywordflow">return</span> LDISKFS_HTREE_EOF_64BIT;
<a name="l01195"></a>01195 }
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> fid_is_internal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l01198"></a>01198 {
<a name="l01199"></a>01199         <span class="keywordflow">return</span> (!fid_is_namespace_visible(fid) &amp;&amp; !fid_is_idif(fid));
<a name="l01200"></a>01200 }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> osd_remote_parent_ino(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *dev)
<a name="l01203"></a>01203 {
<a name="l01204"></a>01204         <span class="keywordflow">return</span> dev-&gt;od_mdt_map-&gt;omm_remote_parent-&gt;d_inode-&gt;i_ino;
<a name="l01205"></a>01205 }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207 <span class="keywordtype">void</span> ldiskfs_inc_count(handle_t *handle, <span class="keyword">struct</span> inode *inode);
<a name="l01208"></a>01208 <span class="keywordtype">void</span> ldiskfs_dec_count(handle_t *handle, <span class="keyword">struct</span> inode *inode);
<a name="l01209"></a>01209 
<a name="l01210"></a>01210 <span class="keywordtype">void</span> osd_fini_iobuf(<span class="keyword">struct</span> <a class="code" href="structosd__device.html">osd_device</a> *d, <span class="keyword">struct</span> <a class="code" href="structosd__iobuf.html">osd_iobuf</a> *iobuf);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212 <span class="preprocessor">#endif </span><span class="comment">/* _OSD_INTERNAL_H */</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:19 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
