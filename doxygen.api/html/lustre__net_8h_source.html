<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/include/lustre_net.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/include/lustre_net.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2010, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> */</span>
<a name="l00050"></a>00050 <span class="preprocessor">#ifndef _LUSTRE_NET_H</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#define _LUSTRE_NET_H</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;linux/uio.h&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;libcfs/libcfs.h&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;lnet/nidstr.h&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;lnet/api.h&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;lustre/lustre_idl.h&gt;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &lt;lustre_ha.h&gt;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;lustre_sec.h&gt;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;lustre_import.h&gt;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;lprocfs_status.h&gt;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;lu_object.h&gt;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &lt;lustre_req_layout.h&gt;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;obd_support.h&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;lustre_ver.h&gt;</span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="comment">/* MD flags we _always_ use */</span>
<a name="l00073"></a>00073 <span class="preprocessor">#define PTLRPC_MD_OPTIONS  0</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00082"></a><a class="code" href="group__net.html#gabf4b4d7a3ddddab43ae78ddefc08af29">00082</a> <span class="preprocessor">#define PTLRPC_BULK_OPS_BITS    4</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#if PTLRPC_BULK_OPS_BITS &gt; 16</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#error &quot;More than 65536 BRW RPCs not allowed by IOOBJ_MAX_BRW_BITS.&quot;</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#define PTLRPC_BULK_OPS_COUNT   (1U &lt;&lt; PTLRPC_BULK_OPS_BITS)</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00094"></a><a class="code" href="group__net.html#ga8b841cf2fb3c1d1c92a9ddcf7068bb4c">00094</a> <span class="preprocessor">#define PTLRPC_BULK_OPS_MASK    (~((__u64)PTLRPC_BULK_OPS_COUNT - 1))</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span>
<a name="l00103"></a><a class="code" href="group__net.html#ga507b0acc65154a8e8842879d5f4db30b">00103</a> <span class="preprocessor">#define PTLRPC_MAX_BRW_BITS     (LNET_MTU_BITS + PTLRPC_BULK_OPS_BITS)</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#define PTLRPC_MAX_BRW_SIZE     (1 &lt;&lt; PTLRPC_MAX_BRW_BITS)</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">#define PTLRPC_MAX_BRW_PAGES    (PTLRPC_MAX_BRW_SIZE &gt;&gt; PAGE_CACHE_SHIFT)</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span>
<a name="l00107"></a>00107 <span class="preprocessor">#define ONE_MB_BRW_SIZE         (1 &lt;&lt; LNET_MTU_BITS)</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#define MD_MAX_BRW_SIZE         (1 &lt;&lt; LNET_MTU_BITS)</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="preprocessor">#define MD_MAX_BRW_PAGES        (MD_MAX_BRW_SIZE &gt;&gt; PAGE_CACHE_SHIFT)</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="preprocessor">#define DT_MAX_BRW_SIZE         PTLRPC_MAX_BRW_SIZE</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="preprocessor">#define DT_MAX_BRW_PAGES        (DT_MAX_BRW_SIZE &gt;&gt; PAGE_CACHE_SHIFT)</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="preprocessor">#define OFD_MAX_BRW_SIZE        (1 &lt;&lt; LNET_MTU_BITS)</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span>
<a name="l00114"></a>00114 <span class="comment">/* When PAGE_SIZE is a constant, we can check our arithmetic here with cpp! */</span>
<a name="l00115"></a>00115 <span class="preprocessor">#if ((PTLRPC_MAX_BRW_PAGES &amp; (PTLRPC_MAX_BRW_PAGES - 1)) != 0)</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span><span class="preprocessor"># error &quot;PTLRPC_MAX_BRW_PAGES isn&apos;t a power of two&quot;</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor">#if (PTLRPC_MAX_BRW_SIZE != (PTLRPC_MAX_BRW_PAGES * PAGE_CACHE_SIZE))</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="preprocessor"># error &quot;PTLRPC_MAX_BRW_SIZE isn&apos;t PTLRPC_MAX_BRW_PAGES * PAGE_CACHE_SIZE&quot;</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="preprocessor">#if (PTLRPC_MAX_BRW_SIZE &gt; LNET_MTU * PTLRPC_BULK_OPS_COUNT)</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor"># error &quot;PTLRPC_MAX_BRW_SIZE too big&quot;</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span><span class="preprocessor">#if (PTLRPC_MAX_BRW_PAGES &gt; LNET_MAX_IOV * PTLRPC_BULK_OPS_COUNT)</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor"># error &quot;PTLRPC_MAX_BRW_PAGES too big&quot;</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span>
<a name="l00128"></a>00128 <span class="preprocessor">#define PTLRPC_NTHRS_INIT       2</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>
<a name="l00237"></a>00237  <span class="comment">/*</span>
<a name="l00238"></a>00238 <span class="comment">  * LDLM threads constants:</span>
<a name="l00239"></a>00239 <span class="comment">  *</span>
<a name="l00240"></a>00240 <span class="comment">  * Given 8 as factor and 24 as base threads number</span>
<a name="l00241"></a>00241 <span class="comment">  *</span>
<a name="l00242"></a>00242 <span class="comment">  * example 1)</span>
<a name="l00243"></a>00243 <span class="comment">  * On 4-core machine we will have 24 + 8 * 4 = 56 threads.</span>
<a name="l00244"></a>00244 <span class="comment">  *</span>
<a name="l00245"></a>00245 <span class="comment">  * example 2)</span>
<a name="l00246"></a>00246 <span class="comment">  * On 8-core machine with 2 partitions we will have 24 + 4 * 8 = 56</span>
<a name="l00247"></a>00247 <span class="comment">  * threads for each partition and total threads number will be 112.</span>
<a name="l00248"></a>00248 <span class="comment">  *</span>
<a name="l00249"></a>00249 <span class="comment">  * example 3)</span>
<a name="l00250"></a>00250 <span class="comment">  * On 64-core machine with 8 partitions we will need LDLM_NTHRS_BASE(24)</span>
<a name="l00251"></a>00251 <span class="comment">  * threads for each partition to keep service healthy, so total threads</span>
<a name="l00252"></a>00252 <span class="comment">  * number should be 24 * 8 = 192.</span>
<a name="l00253"></a>00253 <span class="comment">  *</span>
<a name="l00254"></a>00254 <span class="comment">  * So with these constants, threads number will be at the similar level</span>
<a name="l00255"></a>00255 <span class="comment">  * of old versions, unless target machine has over a hundred cores</span>
<a name="l00256"></a>00256 <span class="comment">  */</span>
<a name="l00257"></a><a class="code" href="group__net.html#ga3a944e6b359ce130537f3ab0efdd5a2a">00257</a> <span class="preprocessor">#define LDLM_THR_FACTOR         8</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_NTHRS_INIT         PTLRPC_NTHRS_INIT</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_NTHRS_BASE         24</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_NTHRS_MAX          (num_online_cpus() == 1 ? 64 : 128)</span>
<a name="l00261"></a>00261 <span class="preprocessor"></span>
<a name="l00262"></a>00262 <span class="preprocessor">#define LDLM_BL_THREADS   LDLM_NTHRS_AUTO_INIT</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_CLIENT_NBUFS 1</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_SERVER_NBUFS 64</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_BUFSIZE      (8 * 1024)</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_MAXREQSIZE   (5 * 1024)</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_MAXREPSIZE   (1024)</span>
<a name="l00268"></a>00268 <span class="preprocessor"></span>
<a name="l00269"></a>00269  <span class="comment">/*</span>
<a name="l00270"></a>00270 <span class="comment">  * MDS threads constants:</span>
<a name="l00271"></a>00271 <span class="comment">  *</span>
<a name="l00272"></a>00272 <span class="comment">  * Please see examples in &quot;Thread Constants&quot;, MDS threads number will be at</span>
<a name="l00273"></a>00273 <span class="comment">  * the comparable level of old versions, unless the server has many cores.</span>
<a name="l00274"></a>00274 <span class="comment">  */</span>
<a name="l00275"></a>00275 <span class="preprocessor">#ifndef MDS_MAX_THREADS</span>
<a name="l00276"></a>00276 <span class="preprocessor"></span><span class="preprocessor">#define MDS_MAX_THREADS         1024</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span><span class="preprocessor">#define MDS_MAX_OTHR_THREADS    256</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span>
<a name="l00279"></a>00279 <span class="preprocessor">#else </span><span class="comment">/* MDS_MAX_THREADS */</span>
<a name="l00280"></a>00280 <span class="preprocessor">#if MDS_MAX_THREADS &lt; PTLRPC_NTHRS_INIT</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span><span class="preprocessor">#undef MDS_MAX_THREADS</span>
<a name="l00282"></a>00282 <span class="preprocessor"></span><span class="preprocessor">#define MDS_MAX_THREADS PTLRPC_NTHRS_INIT</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00284"></a>00284 <span class="preprocessor"></span><span class="preprocessor">#define MDS_MAX_OTHR_THREADS    max(PTLRPC_NTHRS_INIT, MDS_MAX_THREADS / 2)</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>
<a name="l00287"></a>00287 <span class="comment">/* default service */</span>
<a name="l00288"></a>00288 <span class="preprocessor">#define MDS_THR_FACTOR          8</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span><span class="preprocessor">#define MDS_NTHRS_INIT          PTLRPC_NTHRS_INIT</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span><span class="preprocessor">#define MDS_NTHRS_MAX           MDS_MAX_THREADS</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span><span class="preprocessor">#define MDS_NTHRS_BASE          min(64, MDS_NTHRS_MAX)</span>
<a name="l00292"></a>00292 <span class="preprocessor"></span>
<a name="l00293"></a>00293 <span class="comment">/* read-page service */</span>
<a name="l00294"></a>00294 <span class="preprocessor">#define MDS_RDPG_THR_FACTOR     4</span>
<a name="l00295"></a>00295 <span class="preprocessor"></span><span class="preprocessor">#define MDS_RDPG_NTHRS_INIT     PTLRPC_NTHRS_INIT</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span><span class="preprocessor">#define MDS_RDPG_NTHRS_MAX      MDS_MAX_OTHR_THREADS</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span><span class="preprocessor">#define MDS_RDPG_NTHRS_BASE     min(48, MDS_RDPG_NTHRS_MAX)</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>
<a name="l00299"></a>00299 <span class="comment">/* these should be removed when we remove setattr service in the future */</span>
<a name="l00300"></a>00300 <span class="preprocessor">#define MDS_SETA_THR_FACTOR     4</span>
<a name="l00301"></a>00301 <span class="preprocessor"></span><span class="preprocessor">#define MDS_SETA_NTHRS_INIT     PTLRPC_NTHRS_INIT</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span><span class="preprocessor">#define MDS_SETA_NTHRS_MAX      MDS_MAX_OTHR_THREADS</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span><span class="preprocessor">#define MDS_SETA_NTHRS_BASE     min(48, MDS_SETA_NTHRS_MAX)</span>
<a name="l00304"></a>00304 <span class="preprocessor"></span>
<a name="l00305"></a>00305 <span class="comment">/* non-affinity threads */</span>
<a name="l00306"></a>00306 <span class="preprocessor">#define MDS_OTHR_NTHRS_INIT     PTLRPC_NTHRS_INIT</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span><span class="preprocessor">#define MDS_OTHR_NTHRS_MAX      MDS_MAX_OTHR_THREADS</span>
<a name="l00308"></a>00308 <span class="preprocessor"></span>
<a name="l00309"></a>00309 <span class="preprocessor">#define MDS_NBUFS               64</span>
<a name="l00310"></a>00310 <span class="preprocessor"></span>
<a name="l00330"></a><a class="code" href="group__net.html#ga0925bdb5333dd708e0aa362a7b859f87">00330</a> <span class="preprocessor">#define MDS_MAXREQSIZE          (5 * 1024)      </span><span class="comment">/* &gt;= 4736 */</span>
<a name="l00331"></a>00331 <span class="preprocessor">#define MDS_MAXREPSIZE          (9 * 1024)      </span><span class="comment">/* &gt;= 8300 */</span>
<a name="l00332"></a>00332 
<a name="l00337"></a><a class="code" href="group__net.html#ga30f21c5f8837df1463edffb20d62a4f2">00337</a> <span class="preprocessor">#define MDS_LOV_MAXREQSIZE      max(MDS_MAXREQSIZE, \</span>
<a name="l00338"></a>00338 <span class="preprocessor">                                    362 + LOV_MAX_STRIPE_COUNT * 24)</span>
<a name="l00339"></a>00339 <span class="preprocessor"></span>
<a name="l00348"></a><a class="code" href="group__net.html#gacacc3457857ade161935c93720109685">00348</a> <span class="preprocessor">#define MDS_LOV_MAXREPSIZE      MDS_LOV_MAXREQSIZE</span>
<a name="l00349"></a>00349 <span class="preprocessor"></span>
<a name="l00360"></a><a class="code" href="group__net.html#ga11a8ca7b7077906bf6d328588ec4dec4">00360</a> <span class="preprocessor">#define MDS_EA_MAXREQSIZE       66288</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>
<a name="l00366"></a><a class="code" href="group__net.html#ga55304816884c7b0a95e492ced0d476ff">00366</a> <span class="preprocessor">#define MDS_REG_MAXREQSIZE      (((max(MDS_EA_MAXREQSIZE, \</span>
<a name="l00367"></a>00367 <span class="preprocessor">                                       MDS_LOV_MAXREQSIZE) + 1023) &gt;&gt; 10) &lt;&lt; 10)</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span><span class="preprocessor">#define MDS_REG_MAXREPSIZE      MDS_REG_MAXREQSIZE</span>
<a name="l00369"></a>00369 <span class="preprocessor"></span>
<a name="l00375"></a><a class="code" href="group__net.html#ga3061b67fa028fa7ea59239b69b10c911">00375</a> <span class="preprocessor">#define OUT_MAXREQSIZE  (1000 * 1024)</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span><span class="preprocessor">#define OUT_MAXREPSIZE  MDS_MAXREPSIZE</span>
<a name="l00377"></a>00377 <span class="preprocessor"></span>
<a name="l00379"></a><a class="code" href="group__net.html#ga89120bf4c91617f84fb648d3445c4d0d">00379</a> <span class="preprocessor">#define MDS_BUFSIZE             max(MDS_MAXREQSIZE + SPTLRPC_MAX_PAYLOAD, \</span>
<a name="l00380"></a>00380 <span class="preprocessor">                                    8 * 1024)</span>
<a name="l00381"></a>00381 <span class="preprocessor"></span>
<a name="l00398"></a><a class="code" href="group__net.html#gace39c2a24b8ed087135caf8102925f80">00398</a> <span class="preprocessor">#define MDS_REG_BUFSIZE         max(MDS_REG_MAXREQSIZE + SPTLRPC_MAX_PAYLOAD, \</span>
<a name="l00399"></a>00399 <span class="preprocessor">                                    160 * 1024)</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span>
<a name="l00406"></a><a class="code" href="group__net.html#gae34be12e43c77807e8487670d8c4b119">00406</a> <span class="preprocessor">#define OUT_BUFSIZE             max(OUT_MAXREQSIZE + SPTLRPC_MAX_PAYLOAD, \</span>
<a name="l00407"></a>00407 <span class="preprocessor">                                    24 * 1024)</span>
<a name="l00408"></a>00408 <span class="preprocessor"></span>
<a name="l00410"></a><a class="code" href="group__net.html#gacc6001cafee4a86e6ce9e3c564300fba">00410</a> <span class="preprocessor">#define FLD_MAXREQSIZE  (160)</span>
<a name="l00411"></a>00411 <span class="preprocessor"></span>
<a name="l00413"></a><a class="code" href="group__net.html#ga79a13640cdfd7899d81028fd45849e20">00413</a> <span class="preprocessor">#define FLD_MAXREPSIZE  (152)</span>
<a name="l00414"></a>00414 <span class="preprocessor"></span><span class="preprocessor">#define FLD_BUFSIZE     (1 &lt;&lt; 12)</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>
<a name="l00419"></a><a class="code" href="group__net.html#gab00780470dc1dda21d5107cb3439968b">00419</a> <span class="preprocessor">#define SEQ_MAXREQSIZE  (160)</span>
<a name="l00420"></a>00420 <span class="preprocessor"></span>
<a name="l00422"></a><a class="code" href="group__net.html#gad213a2a89d144bd859084578eb412571">00422</a> <span class="preprocessor">#define SEQ_MAXREPSIZE  (152)</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span><span class="preprocessor">#define SEQ_BUFSIZE     (1 &lt;&lt; 12)</span>
<a name="l00424"></a>00424 <span class="preprocessor"></span>
<a name="l00426"></a><a class="code" href="group__net.html#ga12eb8c4f6e3d563a0e5896e9c2b220d5">00426</a> <span class="preprocessor">#define MGS_NTHRS_INIT  (PTLRPC_NTHRS_INIT + 1)</span>
<a name="l00427"></a>00427 <span class="preprocessor"></span><span class="preprocessor">#define MGS_NTHRS_MAX   32</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>
<a name="l00429"></a>00429 <span class="preprocessor">#define MGS_NBUFS       64</span>
<a name="l00430"></a>00430 <span class="preprocessor"></span><span class="preprocessor">#define MGS_BUFSIZE     (8 * 1024)</span>
<a name="l00431"></a>00431 <span class="preprocessor"></span><span class="preprocessor">#define MGS_MAXREQSIZE  (7 * 1024)</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span><span class="preprocessor">#define MGS_MAXREPSIZE  (9 * 1024)</span>
<a name="l00433"></a>00433 <span class="preprocessor"></span>
<a name="l00434"></a>00434  <span class="comment">/*</span>
<a name="l00435"></a>00435 <span class="comment">  * OSS threads constants:</span>
<a name="l00436"></a>00436 <span class="comment">  *</span>
<a name="l00437"></a>00437 <span class="comment">  * Given 8 as factor and 64 as base threads number</span>
<a name="l00438"></a>00438 <span class="comment">  *</span>
<a name="l00439"></a>00439 <span class="comment">  * example 1):</span>
<a name="l00440"></a>00440 <span class="comment">  * On 8-core server configured to 2 partitions, we will have</span>
<a name="l00441"></a>00441 <span class="comment">  * 64 + 8 * 4 = 96 threads for each partition, 192 total threads.</span>
<a name="l00442"></a>00442 <span class="comment">  *</span>
<a name="l00443"></a>00443 <span class="comment">  * example 2):</span>
<a name="l00444"></a>00444 <span class="comment">  * On 32-core machine configured to 4 partitions, we will have</span>
<a name="l00445"></a>00445 <span class="comment">  * 64 + 8 * 8 = 112 threads for each partition, so total threads number</span>
<a name="l00446"></a>00446 <span class="comment">  * will be 112 * 4 = 448.</span>
<a name="l00447"></a>00447 <span class="comment">  *</span>
<a name="l00448"></a>00448 <span class="comment">  * example 3):</span>
<a name="l00449"></a>00449 <span class="comment">  * On 64-core machine configured to 4 partitions, we will have</span>
<a name="l00450"></a>00450 <span class="comment">  * 64 + 16 * 8 = 192 threads for each partition, so total threads number</span>
<a name="l00451"></a>00451 <span class="comment">  * will be 192 * 4 = 768 which is above limit OSS_NTHRS_MAX(512), so we</span>
<a name="l00452"></a>00452 <span class="comment">  * cut off the value to OSS_NTHRS_MAX(512) / 4 which is 128 threads</span>
<a name="l00453"></a>00453 <span class="comment">  * for each partition.</span>
<a name="l00454"></a>00454 <span class="comment">  *</span>
<a name="l00455"></a>00455 <span class="comment">  * So we can see that with these constants, threads number wil be at the</span>
<a name="l00456"></a>00456 <span class="comment">  * similar level of old versions, unless the server has many cores.</span>
<a name="l00457"></a>00457 <span class="comment">  */</span>
<a name="l00458"></a>00458  <span class="comment">/* depress threads factor for VM with small memory size */</span>
<a name="l00459"></a>00459 <span class="preprocessor">#define OSS_THR_FACTOR          min_t(int, 8, \</span>
<a name="l00460"></a>00460 <span class="preprocessor">                                NUM_CACHEPAGES &gt;&gt; (28 - PAGE_CACHE_SHIFT))</span>
<a name="l00461"></a>00461 <span class="preprocessor"></span><span class="preprocessor">#define OSS_NTHRS_INIT          (PTLRPC_NTHRS_INIT + 1)</span>
<a name="l00462"></a>00462 <span class="preprocessor"></span><span class="preprocessor">#define OSS_NTHRS_BASE          64</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>
<a name="l00464"></a>00464 <span class="comment">/* threads for handling &quot;create&quot; request */</span>
<a name="l00465"></a>00465 <span class="preprocessor">#define OSS_CR_THR_FACTOR       1</span>
<a name="l00466"></a>00466 <span class="preprocessor"></span><span class="preprocessor">#define OSS_CR_NTHRS_INIT       PTLRPC_NTHRS_INIT</span>
<a name="l00467"></a>00467 <span class="preprocessor"></span><span class="preprocessor">#define OSS_CR_NTHRS_BASE       8</span>
<a name="l00468"></a>00468 <span class="preprocessor"></span><span class="preprocessor">#define OSS_CR_NTHRS_MAX        64</span>
<a name="l00469"></a>00469 <span class="preprocessor"></span>
<a name="l00480"></a><a class="code" href="group__net.html#ga7effbcacfc90f58c6e550e8441ee9b5d">00480</a> <span class="preprocessor">#define _OST_MAXREQSIZE_SUM (sizeof(struct lustre_msg) + \</span>
<a name="l00481"></a>00481 <span class="preprocessor">                             sizeof(struct ptlrpc_body) + \</span>
<a name="l00482"></a>00482 <span class="preprocessor">                             sizeof(struct obdo) + \</span>
<a name="l00483"></a>00483 <span class="preprocessor">                             sizeof(struct obd_ioobj) + \</span>
<a name="l00484"></a>00484 <span class="preprocessor">                             sizeof(struct niobuf_remote) * DT_MAX_BRW_PAGES)</span>
<a name="l00485"></a>00485 <span class="preprocessor"></span>
<a name="l00488"></a><a class="code" href="group__net.html#ga90591733c0c1eee622c2b8b512fd89e3">00488</a> <span class="preprocessor">#define OST_MAXREQSIZE          (16 * 1024)</span>
<a name="l00489"></a>00489 <span class="preprocessor"></span><span class="preprocessor">#define OST_IO_MAXREQSIZE       max_t(int, OST_MAXREQSIZE, \</span>
<a name="l00490"></a>00490 <span class="preprocessor">                                (((_OST_MAXREQSIZE_SUM - 1) | (1024 - 1)) + 1))</span>
<a name="l00491"></a>00491 <span class="preprocessor"></span>
<a name="l00492"></a>00492 <span class="preprocessor">#define OST_MAXREPSIZE          (9 * 1024)</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span><span class="preprocessor">#define OST_IO_MAXREPSIZE       OST_MAXREPSIZE</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span>
<a name="l00495"></a>00495 <span class="preprocessor">#define OST_NBUFS               64</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span>
<a name="l00497"></a><a class="code" href="group__net.html#gade43b8059a7940089671f1c160b97e8b">00497</a> <span class="preprocessor">#define OST_BUFSIZE             max_t(int, OST_MAXREQSIZE + 1024, 16 * 1024)</span>
<a name="l00498"></a>00498 <span class="preprocessor"></span>
<a name="l00502"></a><a class="code" href="group__net.html#ga112461e50f5b4ce6d060c31e89002f4a">00502</a> <span class="preprocessor">#define OST_IO_BUFSIZE          max_t(int, OST_IO_MAXREQSIZE + 1024, 64 * 1024)</span>
<a name="l00503"></a>00503 <span class="preprocessor"></span>
<a name="l00504"></a>00504 <span class="comment">/* Macro to hide a typecast. */</span>
<a name="l00505"></a>00505 <span class="preprocessor">#define ptlrpc_req_async_args(req) ((void *)&amp;req-&gt;rq_async_args)</span>
<a name="l00506"></a>00506 <span class="preprocessor"></span>
<a name="l00507"></a><a class="code" href="structptlrpc__replay__async__args.html">00507</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__replay__async__args.html">ptlrpc_replay_async_args</a> {
<a name="l00508"></a>00508         <span class="keywordtype">int</span>             praa_old_state;
<a name="l00509"></a>00509         <span class="keywordtype">int</span>             praa_old_status;
<a name="l00510"></a>00510 };
<a name="l00511"></a>00511 
<a name="l00515"></a><a class="code" href="structptlrpc__connection.html">00515</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> {
<a name="l00517"></a><a class="code" href="structptlrpc__connection.html#a3366419b73cdee4231c138d6f28f2535">00517</a>         <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>        <a class="code" href="structptlrpc__connection.html#a3366419b73cdee4231c138d6f28f2535" title="linkage for connections hash table">c_hash</a>;
<a name="l00519"></a><a class="code" href="structptlrpc__connection.html#a002bdb401d67315c931ff672970178b8">00519</a>         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>              <a class="code" href="structptlrpc__connection.html#a002bdb401d67315c931ff672970178b8" title="Our own lnet nid for this connection.">c_self</a>;
<a name="l00521"></a><a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249">00521</a>         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>       <a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>;
<a name="l00523"></a><a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30">00523</a>         <span class="keyword">struct </span><a class="code" href="structobd__uuid.html">obd_uuid</a>         <a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>;
<a name="l00525"></a><a class="code" href="structptlrpc__connection.html#a667c168b3e4836cf87f3d45109249fe9">00525</a>         atomic_t            <a class="code" href="structptlrpc__connection.html#a667c168b3e4836cf87f3d45109249fe9" title="reference counter for this connection">c_refcount</a>;
<a name="l00526"></a>00526 };
<a name="l00527"></a>00527 
<a name="l00529"></a><a class="code" href="structptlrpc__client.html">00529</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__client.html" title="Client definition for PortalRPC.">ptlrpc_client</a> {
<a name="l00531"></a><a class="code" href="structptlrpc__client.html#abbeeccfdcf5796b6ee39005f23d2b8c5">00531</a>         __u32                   <a class="code" href="structptlrpc__client.html#abbeeccfdcf5796b6ee39005f23d2b8c5" title="What lnet portal does this client send messages to by default.">cli_request_portal</a>;
<a name="l00533"></a><a class="code" href="structptlrpc__client.html#a00cb08501a8d056a8620effccaabef95">00533</a>         __u32                   <a class="code" href="structptlrpc__client.html#a00cb08501a8d056a8620effccaabef95" title="What portal do we expect replies on.">cli_reply_portal</a>;
<a name="l00535"></a><a class="code" href="structptlrpc__client.html#a9b61858ed73fc74f022500d88e44d9aa">00535</a>         <span class="keywordtype">char</span>                   *<a class="code" href="structptlrpc__client.html#a9b61858ed73fc74f022500d88e44d9aa" title="Name of the client.">cli_name</a>;
<a name="l00536"></a>00536 };
<a name="l00537"></a>00537 
<a name="l00539"></a>00539 <span class="comment">/* XXX only ones left are those used by the bulk descs as well! */</span>
<a name="l00540"></a><a class="code" href="group__net.html#gab9360fd394863fc72262f905536407ea">00540</a> <span class="preprocessor">#define PTL_RPC_FL_INTR      (1 &lt;&lt; 0)  </span><span class="comment">/* reply wait was interrupted by user */</span>
<a name="l00541"></a>00541 <span class="preprocessor">#define PTL_RPC_FL_TIMEOUT   (1 &lt;&lt; 7)  </span><span class="comment">/* request timed out waiting for reply */</span>
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="preprocessor">#define REQ_MAX_ACK_LOCKS 8</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span>
<a name="l00545"></a><a class="code" href="unionptlrpc__async__args.html">00545</a> <span class="keyword">union </span><a class="code" href="unionptlrpc__async__args.html">ptlrpc_async_args</a> {
<a name="l00553"></a><a class="code" href="unionptlrpc__async__args.html#a0b342d80e8bbe43397dc08b06608a5c1">00553</a>         <span class="keywordtype">void</span>      *<a class="code" href="unionptlrpc__async__args.html#a0b342d80e8bbe43397dc08b06608a5c1" title="Scratchpad for passing args to completion interpreter.">pointer_arg</a>[11];
<a name="l00554"></a>00554         __u64      space[7];
<a name="l00555"></a>00555 };
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a>;
<a name="l00558"></a>00558 <span class="keyword">typedef</span> int (*set_interpreter_func)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *, <span class="keywordtype">void</span> *, int);
<a name="l00559"></a>00559 <span class="keyword">typedef</span> int (*set_producer_func)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *, <span class="keywordtype">void</span> *);
<a name="l00560"></a>00560 
<a name="l00572"></a><a class="code" href="structptlrpc__request__set.html">00572</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> {
<a name="l00573"></a>00573         atomic_t                set_refcount;
<a name="l00575"></a><a class="code" href="structptlrpc__request__set.html#a501b0460a038a221bce0b239f3a4b687">00575</a>         atomic_t                <a class="code" href="structptlrpc__request__set.html#a501b0460a038a221bce0b239f3a4b687" title="number of in queue requests">set_new_count</a>;
<a name="l00577"></a><a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056">00577</a>         atomic_t                <a class="code" href="structptlrpc__request__set.html#aa9a59c6f0eadcb23aaa39af7d6275056" title="number of uncompleted requests">set_remaining</a>;
<a name="l00579"></a><a class="code" href="structptlrpc__request__set.html#afa37e9803cad75f212925a762a9f6d7b">00579</a>         wait_queue_head_t       <a class="code" href="structptlrpc__request__set.html#afa37e9803cad75f212925a762a9f6d7b" title="wait queue to wait on for request events">set_waitq</a>;
<a name="l00580"></a>00580         wait_queue_head_t      *set_wakeup_ptr;
<a name="l00582"></a><a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5">00582</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structptlrpc__request__set.html#adc09a978b08c91b15b329a8b2772ccb5" title="List of requests in the set.">set_requests</a>;
<a name="l00588"></a><a class="code" href="structptlrpc__request__set.html#afd915cdca4eee2fd8b0abdbecd520ce3">00588</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structptlrpc__request__set.html#afd915cdca4eee2fd8b0abdbecd520ce3" title="List of completion callbacks to be called when the set is completed This is only...">set_cblist</a>;
<a name="l00590"></a><a class="code" href="structptlrpc__request__set.html#a3fc57c89c29f05a8fe2dccc5fa321baa">00590</a>         set_interpreter_func    <a class="code" href="structptlrpc__request__set.html#a3fc57c89c29f05a8fe2dccc5fa321baa" title="Completion callback, if only one.">set_interpret</a>;
<a name="l00592"></a><a class="code" href="structptlrpc__request__set.html#a6731b8dc93db539e727857043de0a9ad">00592</a>         <span class="keywordtype">void</span>                    *<a class="code" href="structptlrpc__request__set.html#a6731b8dc93db539e727857043de0a9ad" title="opaq argument passed to completion set_interpret callback.">set_arg</a>;
<a name="l00598"></a><a class="code" href="structptlrpc__request__set.html#ae9098450b33bfdac5eb59f297f3b0c70">00598</a>         spinlock_t              <a class="code" href="structptlrpc__request__set.html#ae9098450b33bfdac5eb59f297f3b0c70" title="Lock for set_new_requests manipulations locked so that any old caller can communicate...">set_new_req_lock</a>;
<a name="l00600"></a><a class="code" href="structptlrpc__request__set.html#aede9d95a4944a6b4d28063de1aa3565b">00600</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structptlrpc__request__set.html#aede9d95a4944a6b4d28063de1aa3565b" title="List of new yet unsent requests.">set_new_requests</a>;
<a name="l00601"></a>00601 
<a name="l00603"></a><a class="code" href="structptlrpc__request__set.html#a2af0674d17e2c26a5fbcea014b6c70ca">00603</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpc__request__set.html#a2af0674d17e2c26a5fbcea014b6c70ca" title="rq_status of requests that have been freed already">set_rc</a>;
<a name="l00606"></a><a class="code" href="structptlrpc__request__set.html#a0394ca46e94e23c6caaab0423d547dab">00606</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpc__request__set.html#a0394ca46e94e23c6caaab0423d547dab" title="Additional fields used by the flow control extension.">set_max_inflight</a>;
<a name="l00608"></a><a class="code" href="structptlrpc__request__set.html#a9be81c226e91f43d9a2b64328b0831a0">00608</a>         set_producer_func       <a class="code" href="structptlrpc__request__set.html#a9be81c226e91f43d9a2b64328b0831a0" title="Callback function used to generate RPCs.">set_producer</a>;
<a name="l00610"></a><a class="code" href="structptlrpc__request__set.html#ac83e6e9755853d8b56bbfbff4f529a83">00610</a>         <span class="keywordtype">void</span>                    *<a class="code" href="structptlrpc__request__set.html#ac83e6e9755853d8b56bbfbff4f529a83" title="opaq argument passed to the producer callback">set_producer_arg</a>;
<a name="l00611"></a>00611         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>             set_allow_intr:1;
<a name="l00612"></a>00612 };
<a name="l00613"></a>00613 
<a name="l00617"></a><a class="code" href="structptlrpc__set__cbdata.html">00617</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__set__cbdata.html" title="Description of a single ptrlrpc_set callback.">ptlrpc_set_cbdata</a> {
<a name="l00619"></a><a class="code" href="structptlrpc__set__cbdata.html#a72f1ec9f7c8e7a2f8ea2e123bf4c0444">00619</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structptlrpc__set__cbdata.html#a72f1ec9f7c8e7a2f8ea2e123bf4c0444" title="List linkage item.">psc_item</a>;
<a name="l00621"></a><a class="code" href="structptlrpc__set__cbdata.html#a7122f5f29318e70ed85129a2195bc247">00621</a>         set_interpreter_func    <a class="code" href="structptlrpc__set__cbdata.html#a7122f5f29318e70ed85129a2195bc247" title="Pointer to interpreting function.">psc_interpret</a>;
<a name="l00623"></a><a class="code" href="structptlrpc__set__cbdata.html#acf9721671bfcc548e1e5fe4276ba9b5c">00623</a>         <span class="keywordtype">void</span>                    *<a class="code" href="structptlrpc__set__cbdata.html#acf9721671bfcc548e1e5fe4276ba9b5c" title="Opaq argument to pass to the callback.">psc_data</a>;
<a name="l00624"></a>00624 };
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a>;
<a name="l00627"></a>00627 <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>;
<a name="l00628"></a>00628 <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>;
<a name="l00629"></a>00629 
<a name="l00633"></a><a class="code" href="structptlrpc__cb__id.html">00633</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__cb__id.html" title="ptlrpc callback &amp;amp; work item stuff">ptlrpc_cb_id</a> {
<a name="l00634"></a>00634         void   (*cbid_fn)(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a> *ev);     <span class="comment">/* specific callback fn */</span>
<a name="l00635"></a>00635         <span class="keywordtype">void</span>    *cbid_arg;                      <span class="comment">/* additional arg */</span>
<a name="l00636"></a>00636 };
<a name="l00637"></a>00637 
<a name="l00639"></a><a class="code" href="group__net.html#ga2d55f86d607f2386cec08e37daa7ce67">00639</a> <span class="preprocessor">#define RS_MAX_LOCKS 8</span>
<a name="l00640"></a>00640 <span class="preprocessor"></span><span class="preprocessor">#define RS_DEBUG     0</span>
<a name="l00641"></a>00641 <span class="preprocessor"></span>
<a name="l00649"></a><a class="code" href="structptlrpc__reply__state.html">00649</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> {
<a name="l00651"></a><a class="code" href="structptlrpc__reply__state.html#a822cfc83a489857d3511fc0bb49de345">00651</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__cb__id.html" title="ptlrpc callback &amp;amp; work item stuff">ptlrpc_cb_id</a>     <a class="code" href="structptlrpc__reply__state.html#a822cfc83a489857d3511fc0bb49de345" title="Callback description.">rs_cb_id</a>;
<a name="l00653"></a><a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd">00653</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>;
<a name="l00655"></a><a class="code" href="structptlrpc__reply__state.html#aa51185c7e39693f894ddb9e9733edf20">00655</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structptlrpc__reply__state.html#aa51185c7e39693f894ddb9e9733edf20" title="Linkage for list of all reply states on same export.">rs_exp_list</a>;
<a name="l00657"></a><a class="code" href="structptlrpc__reply__state.html#a123f596acacfe1cc660bf4ea5407c032">00657</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structptlrpc__reply__state.html#a123f596acacfe1cc660bf4ea5407c032" title="Linkage for list of all reply states for same obd.">rs_obd_list</a>;
<a name="l00658"></a>00658 <span class="preprocessor">#if RS_DEBUG</span>
<a name="l00659"></a>00659 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        rs_debug_list;
<a name="l00660"></a>00660 <span class="preprocessor">#endif</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span>
<a name="l00662"></a><a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe">00662</a>         spinlock_t              <a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>;
<a name="l00664"></a><a class="code" href="structptlrpc__reply__state.html#a053119600f608d97cd028b4e145772f2">00664</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>          <a class="code" href="structptlrpc__reply__state.html#a053119600f608d97cd028b4e145772f2" title="Reply state flags.">rs_difficult</a>:1;     <span class="comment">/* ACK/commit stuff */</span>
<a name="l00665"></a>00665         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>          rs_no_ack:1;    <span class="comment">/* no ACK, even for</span>
<a name="l00666"></a>00666 <span class="comment">                                                  difficult requests */</span>
<a name="l00667"></a>00667         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>          rs_scheduled:1;     <span class="comment">/* being handled? */</span>
<a name="l00668"></a>00668         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>          rs_scheduled_ever:1;<span class="comment">/* any schedule attempts? */</span>
<a name="l00669"></a>00669         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>          rs_handled:1;  <span class="comment">/* been handled yet? */</span>
<a name="l00670"></a>00670         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>          rs_on_net:1;   <span class="comment">/* reply_out_callback pending? */</span>
<a name="l00671"></a>00671         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>          rs_prealloc:1; <span class="comment">/* rs from prealloc list */</span>
<a name="l00672"></a>00672         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>          rs_committed:1;<span class="comment">/* the transaction was committed</span>
<a name="l00673"></a>00673 <span class="comment">                                                 and the rs was dispatched</span>
<a name="l00674"></a>00674 <span class="comment">                                                 by ptlrpc_commit_replies */</span>
<a name="l00675"></a>00675         atomic_t                rs_refcount;    <span class="comment">/* number of users */</span>
<a name="l00677"></a><a class="code" href="structptlrpc__reply__state.html#a971c2d968f9044adfbb3361f6d938e51">00677</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpc__reply__state.html#a971c2d968f9044adfbb3361f6d938e51" title="Number of locks awaiting client ACK.">rs_nlocks</a>;
<a name="l00678"></a>00678 
<a name="l00680"></a><a class="code" href="structptlrpc__reply__state.html#abd444372b3d524a011b825249ea1a7b6">00680</a>         <span class="keywordtype">int</span>                    <a class="code" href="structptlrpc__reply__state.html#abd444372b3d524a011b825249ea1a7b6" title="Size of the state.">rs_size</a>;
<a name="l00682"></a><a class="code" href="structptlrpc__reply__state.html#a159f1f865036a3bafd3bba949d63ff8e">00682</a>         __u32                  <a class="code" href="structptlrpc__reply__state.html#a159f1f865036a3bafd3bba949d63ff8e" title="opcode">rs_opc</a>;
<a name="l00684"></a><a class="code" href="structptlrpc__reply__state.html#aaa25f70935ff08384bd1f64ee0fb3ac0">00684</a>         __u64                  <a class="code" href="structptlrpc__reply__state.html#aaa25f70935ff08384bd1f64ee0fb3ac0" title="Transaction number.">rs_transno</a>;
<a name="l00686"></a><a class="code" href="structptlrpc__reply__state.html#a73136f25efd9632142e418146775c1a3">00686</a>         __u64                  <a class="code" href="structptlrpc__reply__state.html#a73136f25efd9632142e418146775c1a3" title="xid">rs_xid</a>;
<a name="l00687"></a>00687         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>     *rs_export;
<a name="l00688"></a>00688         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *rs_svcpt;
<a name="l00690"></a><a class="code" href="structptlrpc__reply__state.html#a48dd3dc9a45264d8875c1508d61a25e8">00690</a>         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>        <a class="code" href="structptlrpc__reply__state.html#a48dd3dc9a45264d8875c1508d61a25e8" title="Lnet metadata handle for the reply.">rs_md_h</a>;
<a name="l00691"></a>00691 
<a name="l00693"></a><a class="code" href="structptlrpc__reply__state.html#ac2a1d9268241bed06a7375d7e6978a1a">00693</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a>   *<a class="code" href="structptlrpc__reply__state.html#ac2a1d9268241bed06a7375d7e6978a1a" title="Context for the sevice thread.">rs_svc_ctx</a>;
<a name="l00695"></a><a class="code" href="structptlrpc__reply__state.html#a6c58a6733cf86b062ad1c152fb2a3d53">00695</a>         <span class="keyword">struct </span>lustre_msg       *<a class="code" href="structptlrpc__reply__state.html#a6c58a6733cf86b062ad1c152fb2a3d53" title="Reply buffer (actually sent to the client), encoded if needed.">rs_repbuf</a>;     <span class="comment">/* wrapper */</span>
<a name="l00697"></a><a class="code" href="structptlrpc__reply__state.html#acf8a85bb7d5ff6ffc2286605cd23b0b9">00697</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpc__reply__state.html#acf8a85bb7d5ff6ffc2286605cd23b0b9" title="Size of the reply buffer.">rs_repbuf_len</a>;  <span class="comment">/* wrapper buf length */</span>
<a name="l00699"></a><a class="code" href="structptlrpc__reply__state.html#ad8f79dd53c66b683ac2f1906324bf7e3">00699</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpc__reply__state.html#ad8f79dd53c66b683ac2f1906324bf7e3" title="Size of the reply message.">rs_repdata_len</a>; <span class="comment">/* wrapper msg length */</span>
<a name="l00705"></a><a class="code" href="structptlrpc__reply__state.html#af08fd77ced5fd2bf1db68fb9191f3701">00705</a>         <span class="keyword">struct </span>lustre_msg       *<a class="code" href="structptlrpc__reply__state.html#af08fd77ced5fd2bf1db68fb9191f3701" title="Actual reply message.">rs_msg</a>;        <span class="comment">/* reply message */</span>
<a name="l00706"></a>00706 
<a name="l00708"></a><a class="code" href="structptlrpc__reply__state.html#a610b2cfcd3f4e63424d0d21e3faadb63">00708</a>         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    <a class="code" href="structptlrpc__reply__state.html#a610b2cfcd3f4e63424d0d21e3faadb63" title="Handles of locks awaiting client reply ACK.">rs_locks</a>[<a class="code" href="group__net.html#ga2d55f86d607f2386cec08e37daa7ce67" title="Maximum number of locks to fit into reply state.">RS_MAX_LOCKS</a>];
<a name="l00710"></a><a class="code" href="structptlrpc__reply__state.html#ad8efd2c38ee66e40822759cd3d7255fe">00710</a>         <span class="keyword">enum</span> ldlm_mode          <a class="code" href="structptlrpc__reply__state.html#ad8efd2c38ee66e40822759cd3d7255fe" title="Lock modes of locks in rs_locks.">rs_modes</a>[<a class="code" href="group__net.html#ga2d55f86d607f2386cec08e37daa7ce67" title="Maximum number of locks to fit into reply state.">RS_MAX_LOCKS</a>];
<a name="l00711"></a>00711 };
<a name="l00712"></a>00712 
<a name="l00713"></a>00713 <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>;
<a name="l00714"></a>00714 
<a name="l00716"></a><a class="code" href="group__net.html#ga0e456f0c28b52cad4b543eec9efa656a">00716</a> <span class="keyword">enum</span> <a class="code" href="group__net.html#ga0e456f0c28b52cad4b543eec9efa656a" title="RPC stages.">rq_phase</a> {
<a name="l00717"></a>00717         RQ_PHASE_NEW            = 0xebc0de00,
<a name="l00718"></a>00718         RQ_PHASE_RPC            = 0xebc0de01,
<a name="l00719"></a>00719         RQ_PHASE_BULK           = 0xebc0de02,
<a name="l00720"></a>00720         RQ_PHASE_INTERPRET      = 0xebc0de03,
<a name="l00721"></a>00721         RQ_PHASE_COMPLETE       = 0xebc0de04,
<a name="l00722"></a>00722         RQ_PHASE_UNREGISTERING  = 0xebc0de05,
<a name="l00723"></a>00723         RQ_PHASE_UNDEFINED      = 0xebc0de06
<a name="l00724"></a>00724 };
<a name="l00725"></a>00725 
<a name="l00727"></a><a class="code" href="group__net.html#ga80bef25da5dad7e788b4427e8c5e7df6">00727</a> <span class="keyword">typedef</span> int (*<a class="code" href="group__net.html#ga80bef25da5dad7e788b4427e8c5e7df6" title="Type of request interpreter call-back.">ptlrpc_interpterer_t</a>)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00728"></a>00728                                     <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00729"></a>00729                                     <span class="keywordtype">void</span> *arg, <span class="keywordtype">int</span> rc);
<a name="l00731"></a><a class="code" href="group__net.html#gacaae2164af2591db6b5e1d2b208cb6e7">00731</a> <span class="keyword">typedef</span> void (*<a class="code" href="group__net.html#gacaae2164af2591db6b5e1d2b208cb6e7" title="Type of request resend call-back.">ptlrpc_resend_cb_t</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00732"></a>00732                                    <span class="keywordtype">void</span> *arg);
<a name="l00733"></a>00733 
<a name="l00740"></a><a class="code" href="structptlrpc__request__pool.html">00740</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> {
<a name="l00742"></a><a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd">00742</a>         spinlock_t              <a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>;
<a name="l00744"></a><a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66">00744</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66" title="list of ptlrpc_request structs">prp_req_list</a>;
<a name="l00746"></a><a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521">00746</a>         <span class="keywordtype">int</span>                     <a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a>;
<a name="l00748"></a>00748         int (*<a class="code" href="structptlrpc__request__pool.html#a666162961622baf799216fcae4f4dede" title="Function to allocate more requests for this pool.">prp_populate</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *, int);
<a name="l00749"></a>00749 };
<a name="l00750"></a>00750 
<a name="l00751"></a>00751 <span class="keyword">struct </span><a class="code" href="structlu__context.html" title="lu_context.">lu_context</a>;
<a name="l00752"></a>00752 <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>;
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a>;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 <span class="preprocessor">#include &lt;lustre_nrs.h&gt;</span>
<a name="l00757"></a>00757 
<a name="l00767"></a><a class="code" href="structptlrpc__hpreq__ops.html">00767</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__hpreq__ops.html" title="Basic request prioritization operations structure.">ptlrpc_hpreq_ops</a> {
<a name="l00772"></a>00772         int  (*<a class="code" href="structptlrpc__hpreq__ops.html#a3c70481ff128411ab4eeb09dc5eac234" title="Check if the lock handle of the given lock is the same as taken from the request...">hpreq_lock_match</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *, <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *);
<a name="l00776"></a>00776         int  (*<a class="code" href="structptlrpc__hpreq__ops.html#a654252f8000bcba25e02f3f991aa46cd" title="Check if the request is a high priority one.">hpreq_check</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *);
<a name="l00780"></a>00780         void (*<a class="code" href="structptlrpc__hpreq__ops.html#add16854881af7f536d51fd9f158bf958" title="Called after the request has been handled.">hpreq_fini</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *);
<a name="l00781"></a>00781 };
<a name="l00782"></a>00782 
<a name="l00783"></a><a class="code" href="structptlrpc__cli__req.html">00783</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__req.html">ptlrpc_cli_req</a> {
<a name="l00785"></a><a class="code" href="structptlrpc__cli__req.html#aae663f800f4653705bf1c92e1cef2252">00785</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a>         *<a class="code" href="structptlrpc__cli__req.html#aae663f800f4653705bf1c92e1cef2252" title="For bulk requests on client only: bulk descriptor.">cr_bulk</a>;
<a name="l00787"></a><a class="code" href="structptlrpc__cli__req.html#a220c44fcd49794e5217155068e516a84">00787</a>         cfs_duration_t                   <a class="code" href="structptlrpc__cli__req.html#a220c44fcd49794e5217155068e516a84" title="optional time limit for send attempts">cr_delay_limit</a>;
<a name="l00789"></a><a class="code" href="structptlrpc__cli__req.html#ae2b4e3c42d4ff4577c88d51e5e2ea083">00789</a>         cfs_time_t                       <a class="code" href="structptlrpc__cli__req.html#ae2b4e3c42d4ff4577c88d51e5e2ea083" title="time request was first queued">cr_queued_time</a>;
<a name="l00791"></a><a class="code" href="structptlrpc__cli__req.html#a05ba70ab3af32e569e70e6fad8c59c9a">00791</a>         <span class="keyword">struct </span>timeval                   <a class="code" href="structptlrpc__cli__req.html#a05ba70ab3af32e569e70e6fad8c59c9a" title="request sent timeval">cr_sent_tv</a>;
<a name="l00793"></a><a class="code" href="structptlrpc__cli__req.html#a9627df38201990f9c0c9a2468cff4796">00793</a>         time_t                           <a class="code" href="structptlrpc__cli__req.html#a9627df38201990f9c0c9a2468cff4796" title="time for request really sent out">cr_sent_out</a>;
<a name="l00795"></a><a class="code" href="structptlrpc__cli__req.html#a4b0ac95a5a136367201988e1ece51d91">00795</a>         time_t                           <a class="code" href="structptlrpc__cli__req.html#a4b0ac95a5a136367201988e1ece51d91" title="when req reply unlink must finish.">cr_reply_deadline</a>;
<a name="l00797"></a><a class="code" href="structptlrpc__cli__req.html#a1e3e0da23e00f4b17c7058fd6ec2b04c">00797</a>         time_t                           <a class="code" href="structptlrpc__cli__req.html#a1e3e0da23e00f4b17c7058fd6ec2b04c" title="when req bulk unlink must finish.">cr_bulk_deadline</a>;
<a name="l00799"></a><a class="code" href="structptlrpc__cli__req.html#a0d95b41bf30c754892fd204ffaafd19c">00799</a>         <span class="keywordtype">short</span>                            <a class="code" href="structptlrpc__cli__req.html#a0d95b41bf30c754892fd204ffaafd19c" title="Portal to which this request would be sent.">cr_req_ptl</a>;
<a name="l00801"></a><a class="code" href="structptlrpc__cli__req.html#ae06fcfea6f2dc6e80a49f2849dd91b43">00801</a>         <span class="keywordtype">short</span>                            <a class="code" href="structptlrpc__cli__req.html#ae06fcfea6f2dc6e80a49f2849dd91b43" title="Portal where to wait for reply and where reply would be sent.">cr_rep_ptl</a>;
<a name="l00803"></a><a class="code" href="structptlrpc__cli__req.html#ae23691e6f9d7e3772c10771e2d88fd3a">00803</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     <a class="code" href="structptlrpc__cli__req.html#ae23691e6f9d7e3772c10771e2d88fd3a" title="request resending number">cr_resend_nr</a>;
<a name="l00805"></a><a class="code" href="structptlrpc__cli__req.html#af2a552ae7c693b3157880b8cd84b3b12">00805</a>         <span class="keywordtype">int</span>                              <a class="code" href="structptlrpc__cli__req.html#af2a552ae7c693b3157880b8cd84b3b12" title="What was import generation when this request was sent.">cr_imp_gen</a>;
<a name="l00806"></a>00806         <span class="keyword">enum</span> <a class="code" href="group__export.html#ga342f8de0ae2ad4b6cb54d4072d7a97a0" title="Possible import states.">lustre_imp_state</a>            cr_send_state;
<a name="l00808"></a><a class="code" href="structptlrpc__cli__req.html#a4f55926ff95dceedfbee980ba1231a0a">00808</a>         wait_queue_head_t                <a class="code" href="structptlrpc__cli__req.html#a4f55926ff95dceedfbee980ba1231a0a" title="Per-request waitq introduced by bug 21938 for recovery waiting.">cr_set_waitq</a>;
<a name="l00810"></a><a class="code" href="structptlrpc__cli__req.html#ad1b8cb3ec24d979c02728efcec242f9b">00810</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                 <a class="code" href="structptlrpc__cli__req.html#ad1b8cb3ec24d979c02728efcec242f9b" title="Link item for request set lists.">cr_set_chain</a>;
<a name="l00812"></a><a class="code" href="structptlrpc__cli__req.html#aa2c63275b6945247bae7150c2d59bda4">00812</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                 <a class="code" href="structptlrpc__cli__req.html#aa2c63275b6945247bae7150c2d59bda4" title="link to waited ctx">cr_ctx_chain</a>;
<a name="l00813"></a>00813 
<a name="l00815"></a><a class="code" href="structptlrpc__cli__req.html#af615e5e3cffd38a6387ff151f398a072">00815</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>           *<a class="code" href="structptlrpc__cli__req.html#af615e5e3cffd38a6387ff151f398a072" title="client&amp;#39;s half ctx">cr_cli_ctx</a>;
<a name="l00817"></a><a class="code" href="structptlrpc__cli__req.html#a33aaf9206c2fda503a91a8e3c522dcbd">00817</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a>       *<a class="code" href="structptlrpc__cli__req.html#a33aaf9206c2fda503a91a8e3c522dcbd" title="Link back to the request set.">cr_set</a>;
<a name="l00819"></a><a class="code" href="structptlrpc__cli__req.html#aef78cf41fc1bb79722efcd218b87f54d">00819</a>         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>                 <a class="code" href="structptlrpc__cli__req.html#aef78cf41fc1bb79722efcd218b87f54d" title="outgoing request MD handle">cr_req_md_h</a>;
<a name="l00821"></a><a class="code" href="structptlrpc__cli__req.html#af2b3648da9ef68c13068c9156d3a52c0">00821</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__cb__id.html" title="ptlrpc callback &amp;amp; work item stuff">ptlrpc_cb_id</a>              <a class="code" href="structptlrpc__cli__req.html#af2b3648da9ef68c13068c9156d3a52c0" title="request-out callback parameter">cr_req_cbid</a>;
<a name="l00823"></a><a class="code" href="structptlrpc__cli__req.html#ade3c16da9dc386f6702799e600844617">00823</a>         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>                 <a class="code" href="structptlrpc__cli__req.html#ade3c16da9dc386f6702799e600844617" title="incoming reply MD handle">cr_reply_md_h</a>;
<a name="l00824"></a>00824         wait_queue_head_t                cr_reply_waitq;
<a name="l00826"></a><a class="code" href="structptlrpc__cli__req.html#a0798ce3ca0d4a7ad67aec865c9e0c520">00826</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__cb__id.html" title="ptlrpc callback &amp;amp; work item stuff">ptlrpc_cb_id</a>              <a class="code" href="structptlrpc__cli__req.html#a0798ce3ca0d4a7ad67aec865c9e0c520" title="reply callback parameter">cr_reply_cbid</a>;
<a name="l00828"></a><a class="code" href="structptlrpc__cli__req.html#a7095cae20dc2a51a220034d2520fb0d4">00828</a>         <a class="code" href="group__net.html#ga80bef25da5dad7e788b4427e8c5e7df6" title="Type of request interpreter call-back.">ptlrpc_interpterer_t</a>             <a class="code" href="structptlrpc__cli__req.html#a7095cae20dc2a51a220034d2520fb0d4" title="Async completion handler, called when reply is received.">cr_reply_interp</a>;
<a name="l00830"></a><a class="code" href="structptlrpc__cli__req.html#ab16d24a99a3ac3fc451aaeddfd28d18e">00830</a>         <a class="code" href="group__net.html#gacaae2164af2591db6b5e1d2b208cb6e7" title="Type of request resend call-back.">ptlrpc_resend_cb_t</a>               <a class="code" href="structptlrpc__cli__req.html#ab16d24a99a3ac3fc451aaeddfd28d18e" title="Resend handler, called when request is resend to update RPC data.">cr_resend_cb</a>;
<a name="l00832"></a><a class="code" href="structptlrpc__cli__req.html#ad88cd8b3608026360fe2013cc5f05a61">00832</a>         <span class="keyword">union </span><a class="code" href="unionptlrpc__async__args.html">ptlrpc_async_args</a>          <a class="code" href="structptlrpc__cli__req.html#ad88cd8b3608026360fe2013cc5f05a61" title="Async completion context.">cr_async_args</a>;
<a name="l00834"></a><a class="code" href="structptlrpc__cli__req.html#a4474b21a5a0d3fd33ffd7dae806de9c1">00834</a>         <span class="keywordtype">void</span>                            *<a class="code" href="structptlrpc__cli__req.html#a4474b21a5a0d3fd33ffd7dae806de9c1" title="Opaq data for replay and commit callbacks.">cr_cb_data</a>;
<a name="l00836"></a><a class="code" href="structptlrpc__cli__req.html#addf3c255c686237c4b16900c4135f2c0">00836</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                 <a class="code" href="structptlrpc__cli__req.html#addf3c255c686237c4b16900c4135f2c0" title="Link to the imp-&amp;gt;imp_unreplied_list.">cr_unreplied_list</a>;
<a name="l00841"></a>00841         void (*<a class="code" href="structptlrpc__cli__req.html#a436faecd52f4c84bb5ba5ce0554522e6" title="Commit callback, called when request is committed and about to be freed.">cr_commit_cb</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *);
<a name="l00843"></a>00843         void (*<a class="code" href="structptlrpc__cli__req.html#ae46b6791a50a917f7ab6bb5b6846b448" title="Replay callback, called after request is replayed at recovery.">cr_replay_cb</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *);
<a name="l00844"></a>00844 };
<a name="l00845"></a>00845 
<a name="l00847"></a>00847 <span class="comment">/* NB: these alias should NOT be used by any new code, instead they should</span>
<a name="l00848"></a>00848 <span class="comment"> * be removed step by step to avoid potential abuse */</span>
<a name="l00849"></a><a class="code" href="group__net.html#ga4a02f006a097fc5c4f7da0fe2ee8f763">00849</a> <span class="preprocessor">#define rq_bulk                 rq_cli.cr_bulk</span>
<a name="l00850"></a>00850 <span class="preprocessor"></span><span class="preprocessor">#define rq_delay_limit          rq_cli.cr_delay_limit</span>
<a name="l00851"></a>00851 <span class="preprocessor"></span><span class="preprocessor">#define rq_queued_time          rq_cli.cr_queued_time</span>
<a name="l00852"></a>00852 <span class="preprocessor"></span><span class="preprocessor">#define rq_sent_tv              rq_cli.cr_sent_tv</span>
<a name="l00853"></a>00853 <span class="preprocessor"></span><span class="preprocessor">#define rq_real_sent            rq_cli.cr_sent_out</span>
<a name="l00854"></a>00854 <span class="preprocessor"></span><span class="preprocessor">#define rq_reply_deadline       rq_cli.cr_reply_deadline</span>
<a name="l00855"></a>00855 <span class="preprocessor"></span><span class="preprocessor">#define rq_bulk_deadline        rq_cli.cr_bulk_deadline</span>
<a name="l00856"></a>00856 <span class="preprocessor"></span><span class="preprocessor">#define rq_nr_resend            rq_cli.cr_resend_nr</span>
<a name="l00857"></a>00857 <span class="preprocessor"></span><span class="preprocessor">#define rq_request_portal       rq_cli.cr_req_ptl</span>
<a name="l00858"></a>00858 <span class="preprocessor"></span><span class="preprocessor">#define rq_reply_portal         rq_cli.cr_rep_ptl</span>
<a name="l00859"></a>00859 <span class="preprocessor"></span><span class="preprocessor">#define rq_import_generation    rq_cli.cr_imp_gen</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span><span class="preprocessor">#define rq_send_state           rq_cli.cr_send_state</span>
<a name="l00861"></a>00861 <span class="preprocessor"></span><span class="preprocessor">#define rq_set_chain            rq_cli.cr_set_chain</span>
<a name="l00862"></a>00862 <span class="preprocessor"></span><span class="preprocessor">#define rq_ctx_chain            rq_cli.cr_ctx_chain</span>
<a name="l00863"></a>00863 <span class="preprocessor"></span><span class="preprocessor">#define rq_set                  rq_cli.cr_set</span>
<a name="l00864"></a>00864 <span class="preprocessor"></span><span class="preprocessor">#define rq_set_waitq            rq_cli.cr_set_waitq</span>
<a name="l00865"></a>00865 <span class="preprocessor"></span><span class="preprocessor">#define rq_cli_ctx              rq_cli.cr_cli_ctx</span>
<a name="l00866"></a>00866 <span class="preprocessor"></span><span class="preprocessor">#define rq_req_md_h             rq_cli.cr_req_md_h</span>
<a name="l00867"></a>00867 <span class="preprocessor"></span><span class="preprocessor">#define rq_req_cbid             rq_cli.cr_req_cbid</span>
<a name="l00868"></a>00868 <span class="preprocessor"></span><span class="preprocessor">#define rq_reply_md_h           rq_cli.cr_reply_md_h</span>
<a name="l00869"></a>00869 <span class="preprocessor"></span><span class="preprocessor">#define rq_reply_waitq          rq_cli.cr_reply_waitq</span>
<a name="l00870"></a>00870 <span class="preprocessor"></span><span class="preprocessor">#define rq_reply_cbid           rq_cli.cr_reply_cbid</span>
<a name="l00871"></a>00871 <span class="preprocessor"></span><span class="preprocessor">#define rq_interpret_reply      rq_cli.cr_reply_interp</span>
<a name="l00872"></a>00872 <span class="preprocessor"></span><span class="preprocessor">#define rq_resend_cb            rq_cli.cr_resend_cb</span>
<a name="l00873"></a>00873 <span class="preprocessor"></span><span class="preprocessor">#define rq_async_args           rq_cli.cr_async_args</span>
<a name="l00874"></a>00874 <span class="preprocessor"></span><span class="preprocessor">#define rq_cb_data              rq_cli.cr_cb_data</span>
<a name="l00875"></a>00875 <span class="preprocessor"></span><span class="preprocessor">#define rq_unreplied_list       rq_cli.cr_unreplied_list</span>
<a name="l00876"></a>00876 <span class="preprocessor"></span><span class="preprocessor">#define rq_commit_cb            rq_cli.cr_commit_cb</span>
<a name="l00877"></a>00877 <span class="preprocessor"></span><span class="preprocessor">#define rq_replay_cb            rq_cli.cr_replay_cb</span>
<a name="l00878"></a>00878 <span class="preprocessor"></span>
<a name="l00879"></a><a class="code" href="structptlrpc__srv__req.html">00879</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__srv__req.html">ptlrpc_srv_req</a> {
<a name="l00881"></a><a class="code" href="structptlrpc__srv__req.html#a0740e9a6fcd80ab4af92ed1d087379f5">00881</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>            *<a class="code" href="structptlrpc__srv__req.html#a0740e9a6fcd80ab4af92ed1d087379f5" title="initial thread servicing this request">sr_svc_thread</a>;
<a name="l00889"></a><a class="code" href="structptlrpc__srv__req.html#a062d3c4e0f7729c6777aeeaf1799e0d8">00889</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                 <a class="code" href="structptlrpc__srv__req.html#a062d3c4e0f7729c6777aeeaf1799e0d8" title="Server side list of incoming unserved requests sorted by arrival time.">sr_timed_list</a>;
<a name="l00891"></a><a class="code" href="structptlrpc__srv__req.html#a4ae1c32e2bdffe24fa279180b678e4a0">00891</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                 <a class="code" href="structptlrpc__srv__req.html#a4ae1c32e2bdffe24fa279180b678e4a0" title="server-side per-export list">sr_exp_list</a>;
<a name="l00893"></a><a class="code" href="structptlrpc__srv__req.html#ac31b249ac0487171aeb94f252ced8520">00893</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                 <a class="code" href="structptlrpc__srv__req.html#ac31b249ac0487171aeb94f252ced8520" title="server-side history, used for debuging purposes.">sr_hist_list</a>;
<a name="l00895"></a><a class="code" href="structptlrpc__srv__req.html#ab157c9128a9c1c8975aac4cb03018b85">00895</a>         __u64                            <a class="code" href="structptlrpc__srv__req.html#ab157c9128a9c1c8975aac4cb03018b85" title="history sequence #">sr_hist_seq</a>;
<a name="l00897"></a><a class="code" href="structptlrpc__srv__req.html#a387d3579bc250ec64092ea4329be5aba">00897</a>         __u32                            <a class="code" href="structptlrpc__srv__req.html#a387d3579bc250ec64092ea4329be5aba" title="the index of service&amp;#39;s srv_at_array into which request is linked">sr_at_index</a>;
<a name="l00899"></a><a class="code" href="structptlrpc__srv__req.html#a6393de6ce3aeb92137140da8fe9c1c4f">00899</a>         uid_t                            <a class="code" href="structptlrpc__srv__req.html#a6393de6ce3aeb92137140da8fe9c1c4f" title="authed uid">sr_auth_uid</a>;
<a name="l00901"></a><a class="code" href="structptlrpc__srv__req.html#a0bcda225f7c95693fca71db3d07d9bd5">00901</a>         uid_t                            <a class="code" href="structptlrpc__srv__req.html#a0bcda225f7c95693fca71db3d07d9bd5" title="authed uid mapped to">sr_auth_mapped_uid</a>;
<a name="l00903"></a><a class="code" href="structptlrpc__srv__req.html#ab583fcae421bacc0dfa2e0e22460407d">00903</a>         <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a>             <a class="code" href="structptlrpc__srv__req.html#ab583fcae421bacc0dfa2e0e22460407d" title="RPC is generated from what part of Lustre.">sr_sp_from</a>;
<a name="l00905"></a><a class="code" href="structptlrpc__srv__req.html#a79ae9993714c223dc08301c2539a12db">00905</a>         <span class="keyword">struct </span><a class="code" href="structlu__context.html" title="lu_context.">lu_context</a>                <a class="code" href="structptlrpc__srv__req.html#a79ae9993714c223dc08301c2539a12db" title="request session context">sr_ses</a>;
<a name="l00910"></a><a class="code" href="group__nrs.html#ga87c0b624fd16e1aaaac107f6d71e0fd1">00910</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a>        <a class="code" href="group__nrs.html#ga87c0b624fd16e1aaaac107f6d71e0fd1" title="stub for NRS request">sr_nrq</a>;
<a name="l00913"></a><a class="code" href="structptlrpc__srv__req.html#adaee187c99afa55863b5664e50a32411">00913</a>         <span class="keyword">struct </span>timeval                   <a class="code" href="structptlrpc__srv__req.html#adaee187c99afa55863b5664e50a32411" title="request arrival time">sr_arrival_time</a>;
<a name="l00915"></a><a class="code" href="structptlrpc__srv__req.html#ab1f81b41b7fcb7132cefa8962c4bca89">00915</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a>           *<a class="code" href="structptlrpc__srv__req.html#ab1f81b41b7fcb7132cefa8962c4bca89" title="server&amp;#39;s half ctx">sr_svc_ctx</a>;
<a name="l00917"></a><a class="code" href="structptlrpc__srv__req.html#a9a973b609c54502edcad1e033f8b0a2b">00917</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__user__desc.html">ptlrpc_user_desc</a>         *<a class="code" href="structptlrpc__srv__req.html#a9a973b609c54502edcad1e033f8b0a2b" title="(server side), pointed directly into req buffer">sr_user_desc</a>;
<a name="l00919"></a><a class="code" href="structptlrpc__srv__req.html#ab311c302e72db2dd708b7c508ebc46ec">00919</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>       *<a class="code" href="structptlrpc__srv__req.html#ab311c302e72db2dd708b7c508ebc46ec" title="separated reply state, may be vmalloc&amp;#39;d">sr_reply_state</a>;
<a name="l00921"></a><a class="code" href="structptlrpc__srv__req.html#a928b38384eefc30349e3c0d627ee045f">00921</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__hpreq__ops.html" title="Basic request prioritization operations structure.">ptlrpc_hpreq_ops</a>         *<a class="code" href="structptlrpc__srv__req.html#a928b38384eefc30349e3c0d627ee045f" title="server-side hp handlers">sr_ops</a>;
<a name="l00923"></a><a class="code" href="structptlrpc__srv__req.html#aa9406c84dd6a24cb747850fc949a06ca">00923</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *<a class="code" href="structptlrpc__srv__req.html#aa9406c84dd6a24cb747850fc949a06ca" title="incoming request buffer">sr_rqbd</a>;
<a name="l00924"></a>00924 };
<a name="l00925"></a>00925 
<a name="l00927"></a>00927 <span class="comment">/* NB: these alias should NOT be used by any new code, instead they should</span>
<a name="l00928"></a>00928 <span class="comment"> * be removed step by step to avoid potential abuse */</span>
<a name="l00929"></a><a class="code" href="group__net.html#ga2add693a51a7d38acaced35e27bdc861">00929</a> <span class="preprocessor">#define rq_svc_thread           rq_srv.sr_svc_thread</span>
<a name="l00930"></a>00930 <span class="preprocessor"></span><span class="preprocessor">#define rq_timed_list           rq_srv.sr_timed_list</span>
<a name="l00931"></a>00931 <span class="preprocessor"></span><span class="preprocessor">#define rq_exp_list             rq_srv.sr_exp_list</span>
<a name="l00932"></a>00932 <span class="preprocessor"></span><span class="preprocessor">#define rq_history_list         rq_srv.sr_hist_list</span>
<a name="l00933"></a>00933 <span class="preprocessor"></span><span class="preprocessor">#define rq_history_seq          rq_srv.sr_hist_seq</span>
<a name="l00934"></a>00934 <span class="preprocessor"></span><span class="preprocessor">#define rq_at_index             rq_srv.sr_at_index</span>
<a name="l00935"></a>00935 <span class="preprocessor"></span><span class="preprocessor">#define rq_auth_uid             rq_srv.sr_auth_uid</span>
<a name="l00936"></a>00936 <span class="preprocessor"></span><span class="preprocessor">#define rq_auth_mapped_uid      rq_srv.sr_auth_mapped_uid</span>
<a name="l00937"></a>00937 <span class="preprocessor"></span><span class="preprocessor">#define rq_sp_from              rq_srv.sr_sp_from</span>
<a name="l00938"></a>00938 <span class="preprocessor"></span><span class="preprocessor">#define rq_session              rq_srv.sr_ses</span>
<a name="l00939"></a>00939 <span class="preprocessor"></span><span class="preprocessor">#define rq_nrq                  rq_srv.sr_nrq</span>
<a name="l00940"></a>00940 <span class="preprocessor"></span><span class="preprocessor">#define rq_arrival_time         rq_srv.sr_arrival_time</span>
<a name="l00941"></a>00941 <span class="preprocessor"></span><span class="preprocessor">#define rq_reply_state          rq_srv.sr_reply_state</span>
<a name="l00942"></a>00942 <span class="preprocessor"></span><span class="preprocessor">#define rq_svc_ctx              rq_srv.sr_svc_ctx</span>
<a name="l00943"></a>00943 <span class="preprocessor"></span><span class="preprocessor">#define rq_user_desc            rq_srv.sr_user_desc</span>
<a name="l00944"></a>00944 <span class="preprocessor"></span><span class="preprocessor">#define rq_ops                  rq_srv.sr_ops</span>
<a name="l00945"></a>00945 <span class="preprocessor"></span><span class="preprocessor">#define rq_rqbd                 rq_srv.sr_rqbd</span>
<a name="l00946"></a>00946 <span class="preprocessor"></span>
<a name="l00953"></a><a class="code" href="structptlrpc__request.html">00953</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> {
<a name="l00954"></a>00954         <span class="comment">/* Request type: one of PTL_RPC_MSG_* */</span>
<a name="l00955"></a>00955         <span class="keywordtype">int</span>                              rq_type;
<a name="l00957"></a><a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d">00957</a>         <span class="keywordtype">int</span>                              <a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>;
<a name="l00962"></a><a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733">00962</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                 <a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>;
<a name="l00966"></a><a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62">00966</a>         spinlock_t                       <a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>;
<a name="l00968"></a><a class="code" href="structptlrpc__request.html#ae9b053a81331ff81f4568df30b253bf0">00968</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structptlrpc__request.html#a6d4f6fc90fdcc8e2492f4ab902147970" title="client-side flags are serialized by rq_lock">rq_intr</a>:1, rq_replied:1, rq_err:1,
<a name="l00969"></a>00969                 rq_timedout:1, rq_resend:1, rq_restart:1,
<a name="l00979"></a>00979                 <a class="code" href="structptlrpc__request.html#ae9b053a81331ff81f4568df30b253bf0" title="when -&amp;gt;rq_replay is set, request is kept by the client even after server commits...">rq_replay</a>:1,
<a name="l00980"></a>00980                 rq_no_resend:1, rq_waiting:1, rq_receiving_reply:1,
<a name="l00981"></a>00981                 rq_no_delay:1, rq_net_err:1, rq_wait_ctx:1,
<a name="l00982"></a>00982                 rq_early:1,
<a name="l00983"></a>00983                 rq_req_unlinked:1,      <span class="comment">/* unlinked request buffer from lnet */</span>
<a name="l00984"></a>00984                 rq_reply_unlinked:1,    <span class="comment">/* unlinked reply buffer from lnet */</span>
<a name="l00985"></a>00985                 rq_memalloc:1,      <span class="comment">/* req originated from &quot;kswapd&quot; */</span>
<a name="l00986"></a>00986                 rq_committed:1,
<a name="l00987"></a>00987                 rq_reply_truncated:1,
<a name="l00989"></a>00989                 <a class="code" href="structptlrpc__request.html#a3c7a9c4f0292826fffa36e3ab1cedf47" title="whether the &amp;quot;rq_set&amp;quot; is a valid one">rq_invalid_rqset</a>:1,
<a name="l00990"></a>00990                 rq_generation_set:1,
<a name="l00992"></a>00992                 <a class="code" href="structptlrpc__request.html#ab4a9cc6a2c3c14ca670362db92d56ae0" title="do not resend request on -EINPROGRESS">rq_no_retry_einprogress</a>:1,
<a name="l00993"></a>00993                 <span class="comment">/* allow the req to be sent if the import is in recovery</span>
<a name="l00994"></a>00994 <span class="comment">                 * status */</span>
<a name="l00995"></a>00995                 rq_allow_replay:1,
<a name="l00996"></a>00996                 <span class="comment">/* bulk request, sent to server, but uncommitted */</span>
<a name="l00997"></a>00997                 rq_unstable:1,
<a name="l00998"></a>00998                 rq_allow_intr:1;
<a name="l01002"></a>01002         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l01003"></a><a class="code" href="structptlrpc__request.html#aadfcdd8f9119f3f92f018aae66c6ffce">01003</a>                 <a class="code" href="structptlrpc__request.html#a97e5341e8ef49e047ef82b2cfa138ec8" title="server-side flags">rq_hp</a>:1,                
<a name="l01004"></a>01004                 <a class="code" href="structptlrpc__request.html#a9e26278917dfc99ef8c03ce46770d9bf" title="link into service&amp;#39;s srv_at_array">rq_at_linked</a>:1,         
<a name="l01005"></a>01005                 <a class="code" href="structptlrpc__request.html#aadfcdd8f9119f3f92f018aae66c6ffce" title="packed final reply">rq_packed_final</a>:1;      
<a name="l01009"></a><a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b">01009</a>         <span class="keyword">enum</span> <a class="code" href="group__net.html#ga0e456f0c28b52cad4b543eec9efa656a" title="RPC stages.">rq_phase</a>                    <a class="code" href="group__net.html#ga0e456f0c28b52cad4b543eec9efa656a" title="RPC stages.">rq_phase</a>;
<a name="l01011"></a><a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a">01011</a>         <span class="keyword">enum</span> <a class="code" href="group__net.html#ga0e456f0c28b52cad4b543eec9efa656a" title="RPC stages.">rq_phase</a>                    <a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a>;
<a name="l01016"></a><a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df">01016</a>         atomic_t                         <a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>;
<a name="l01022"></a><a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a">01022</a>         <span class="keywordtype">int</span> <a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>;
<a name="l01024"></a><a class="code" href="structptlrpc__request.html#a9746010150c167d5b6e62786d61f18df">01024</a>         <span class="keywordtype">int</span> <a class="code" href="structptlrpc__request.html#a9746010150c167d5b6e62786d61f18df" title="Request length.">rq_reqlen</a>;
<a name="l01026"></a><a class="code" href="structptlrpc__request.html#aaa9ba7e7b71ad2057d1650469ab15076">01026</a>         <span class="keywordtype">int</span> <a class="code" href="structptlrpc__request.html#aaa9ba7e7b71ad2057d1650469ab15076" title="Reply length.">rq_replen</a>;
<a name="l01028"></a><a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4">01028</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a>      *<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a>;
<a name="l01030"></a><a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7">01030</a>         <span class="keyword">struct </span>lustre_msg *<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>;
<a name="l01032"></a><a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e">01032</a>         <span class="keyword">struct </span>lustre_msg *<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>;
<a name="l01034"></a><a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd">01034</a>         __u64 <a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a>;
<a name="l01036"></a><a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2">01036</a>         __u64                            <a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>;
<a name="l01038"></a><a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14">01038</a>         __u64                            <a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a>;
<a name="l01045"></a><a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329">01045</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                 <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>;
<a name="l01047"></a>01047         <span class="keyword">union </span>{
<a name="l01048"></a>01048                 <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__req.html">ptlrpc_cli_req</a>    rq_cli;
<a name="l01049"></a>01049                 <span class="keyword">struct </span><a class="code" href="structptlrpc__srv__req.html">ptlrpc_srv_req</a>    rq_srv;
<a name="l01050"></a>01050         };
<a name="l01055"></a><a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6">01055</a>         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a>            <a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057         <span class="comment">/* client/server security flags */</span>
<a name="l01058"></a>01058         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l01059"></a>01059                                  rq_ctx_init:1,      <span class="comment">/* context initiation */</span>
<a name="l01060"></a>01060                                  rq_ctx_fini:1,      <span class="comment">/* context destroy */</span>
<a name="l01061"></a>01061                                  rq_bulk_read:1,     <span class="comment">/* request bulk read */</span>
<a name="l01062"></a>01062                                  rq_bulk_write:1,    <span class="comment">/* request bulk write */</span>
<a name="l01063"></a>01063                                  <span class="comment">/* server authentication flags */</span>
<a name="l01064"></a>01064                                  rq_auth_gss:1,      <span class="comment">/* authenticated by gss */</span>
<a name="l01065"></a>01065                                  rq_auth_remote:1,   <span class="comment">/* authed as remote user */</span>
<a name="l01066"></a>01066                                  rq_auth_usr_root:1, <span class="comment">/* authed as root */</span>
<a name="l01067"></a>01067                                  rq_auth_usr_mdt:1,  <span class="comment">/* authed as mdt */</span>
<a name="l01068"></a>01068                                  rq_auth_usr_ost:1,  <span class="comment">/* authed as ost */</span>
<a name="l01069"></a>01069                                  <span class="comment">/* security tfm flags */</span>
<a name="l01070"></a>01070                                  rq_pack_udesc:1,
<a name="l01071"></a>01071                                  rq_pack_bulk:1,
<a name="l01072"></a>01072                                  <span class="comment">/* doesn&apos;t expect reply FIXME */</span>
<a name="l01073"></a>01073                                  rq_no_reply:1,
<a name="l01074"></a>01074                                  rq_pill_init:1, <span class="comment">/* pill initialized */</span>
<a name="l01075"></a>01075                                  rq_srv_req:1; <span class="comment">/* server request */</span>
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 
<a name="l01079"></a><a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e">01079</a>         <span class="keyword">struct </span>lustre_msg               *<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>;  
<a name="l01080"></a><a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0">01080</a>         <span class="keywordtype">char</span>                            *<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>;  
<a name="l01081"></a><a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5">01081</a>         <span class="keyword">struct </span>lustre_msg               *<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a>; 
<a name="l01083"></a><a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d">01083</a>         <span class="keyword">struct </span>lustre_msg               *<a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d" title="only in priv mode">rq_clrbuf</a>;
<a name="l01084"></a>01084         <span class="keywordtype">int</span>                      rq_reqbuf_len;  <span class="comment">/* req wrapper buf len */</span>
<a name="l01085"></a>01085         <span class="keywordtype">int</span>                      rq_reqdata_len; <span class="comment">/* req wrapper msg len */</span>
<a name="l01086"></a>01086         <span class="keywordtype">int</span>                      rq_repbuf_len;  <span class="comment">/* rep buffer len */</span>
<a name="l01087"></a>01087         <span class="keywordtype">int</span>                      rq_repdata_len; <span class="comment">/* rep wrapper msg len */</span>
<a name="l01088"></a>01088         <span class="keywordtype">int</span>                      rq_clrbuf_len;  <span class="comment">/* only in priv mode */</span>
<a name="l01089"></a>01089         <span class="keywordtype">int</span>                      rq_clrdata_len; <span class="comment">/* only in priv mode */</span>
<a name="l01090"></a>01090 
<a name="l01092"></a><a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1">01092</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     <a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a>;
<a name="l01096"></a><a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a">01096</a>         __u32                            <a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a>;
<a name="l01097"></a>01097         __u32                            rq_rep_swab_mask;
<a name="l01098"></a>01098 
<a name="l01100"></a><a class="code" href="structptlrpc__request.html#a4107706ff91738c79e18c271469afe8d">01100</a>         <span class="keywordtype">int</span>                              <a class="code" href="structptlrpc__request.html#a4107706ff91738c79e18c271469afe8d" title="how many early replies (for stats)">rq_early_count</a>;
<a name="l01102"></a><a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d">01102</a>         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>               *<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>;
<a name="l01104"></a><a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8">01104</a>         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a>               *<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l01106"></a><a class="code" href="structptlrpc__request.html#a23e7140c61b1569e060509edc7e2727b">01106</a>         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>                       <a class="code" href="structptlrpc__request.html#a23e7140c61b1569e060509edc7e2727b" title="our LNet NID">rq_self</a>;
<a name="l01108"></a><a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e">01108</a>         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>                <a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>;
<a name="l01113"></a><a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460">01113</a>         <span class="keywordtype">int</span>                              <a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>;
<a name="l01117"></a><a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517">01117</a>         time_t                           <a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a>;
<a name="l01119"></a><a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844">01119</a>         time_t                           <a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>;
<a name="l01121"></a><a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5">01121</a>         <span class="keyword">struct </span><a class="code" href="structreq__capsule.html">req_capsule</a>               <a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>;
<a name="l01122"></a>01122 };
<a name="l01123"></a>01123 
<a name="l01128"></a>01128 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_req_interpret(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01129"></a>01129                                        <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> rc)
<a name="l01130"></a>01130 {
<a name="l01131"></a>01131         <span class="keywordflow">if</span> (req-&gt;rq_interpret_reply != NULL) {
<a name="l01132"></a>01132                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = req-&gt;rq_interpret_reply(env, req,
<a name="l01133"></a>01133                                                          &amp;req-&gt;rq_async_args,
<a name="l01134"></a>01134                                                          rc);
<a name="l01135"></a>01135                 <span class="keywordflow">return</span> req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>;
<a name="l01136"></a>01136         }
<a name="l01137"></a>01137         <span class="keywordflow">return</span> rc;
<a name="l01138"></a>01138 }
<a name="l01139"></a>01139 
<a name="l01143"></a>01143 <span class="keywordtype">int</span> <a class="code" href="group__nrs.html#ga5de7e78460dcd401c48a46cf67ac9851" title="Registers a new policy with NRS core.">ptlrpc_nrs_policy_register</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> *conf);
<a name="l01144"></a>01144 <span class="keywordtype">int</span> <a class="code" href="group__nrs.html#gafa9c71a2f34f3e56750abaeba0d358f8" title="Unregisters a previously registered policy with NRS core.">ptlrpc_nrs_policy_unregister</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> *conf);
<a name="l01145"></a>01145 <span class="keywordtype">void</span> <a class="code" href="group__nrs.html#gae517dc74ee0bcadf3b53f6ed4c57e6de" title="Moves request req from the regular to the high-priority NRS head.">ptlrpc_nrs_req_hp_move</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01146"></a>01146 <span class="keywordtype">void</span> nrs_policy_get_info_locked(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy,
<a name="l01147"></a>01147                                 <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__pol__info.html" title="NRS policy information.">ptlrpc_nrs_pol_info</a> *info);
<a name="l01148"></a>01148 
<a name="l01149"></a>01149 <span class="comment">/*</span>
<a name="l01150"></a>01150 <span class="comment"> * Can the request be moved from the regular NRS head to the high-priority NRS</span>
<a name="l01151"></a>01151 <span class="comment"> * head (of the same PTLRPC service partition), if any?</span>
<a name="l01152"></a>01152 <span class="comment"> *</span>
<a name="l01153"></a>01153 <span class="comment"> * For a reliable result, this should be checked under svcpt-&gt;scp_req lock.</span>
<a name="l01154"></a>01154 <span class="comment"> */</span>
<a name="l01155"></a>01155 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_nrs_req_can_move(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01156"></a>01156 {
<a name="l01157"></a>01157         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq = &amp;req-&gt;rq_nrq;
<a name="l01158"></a>01158 
<a name="l01165"></a>01165         <span class="keywordflow">return</span> nrq-&gt;nr_enqueued &amp;&amp; !nrq-&gt;nr_started &amp;&amp; !req-&gt;<a class="code" href="structptlrpc__request.html#a97e5341e8ef49e047ef82b2cfa138ec8" title="server-side flags">rq_hp</a>;
<a name="l01166"></a>01166 }
<a name="l01172"></a>01172 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lustre_req_swabbed(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">size_t</span> index)
<a name="l01173"></a>01173 {
<a name="l01174"></a>01174         LASSERT(index &lt; <span class="keyword">sizeof</span>(req-&gt;<a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a>) * 8);
<a name="l01175"></a>01175         <span class="keywordflow">return</span> req-&gt;<a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a> &amp; (1 &lt;&lt; index);
<a name="l01176"></a>01176 }
<a name="l01177"></a>01177 
<a name="l01181"></a>01181 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lustre_rep_swabbed(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">size_t</span> index)
<a name="l01182"></a>01182 {
<a name="l01183"></a>01183         LASSERT(index &lt; <span class="keyword">sizeof</span>(req-&gt;rq_rep_swab_mask) * 8);
<a name="l01184"></a>01184         <span class="keywordflow">return</span> req-&gt;rq_rep_swab_mask &amp; (1 &lt;&lt; index);
<a name="l01185"></a>01185 }
<a name="l01186"></a>01186 
<a name="l01190"></a>01190 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_req_need_swab(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01191"></a>01191 {
<a name="l01192"></a>01192         <span class="keywordflow">return</span> lustre_req_swabbed(req, <a class="code" href="group__lustreidl.html#gafa5c71e7497acfe5dea4f5efd14ef8ec" title="only use in req-&amp;gt;rq_{req,rep}_swab_mask">MSG_PTLRPC_HEADER_OFF</a>);
<a name="l01193"></a>01193 }
<a name="l01194"></a>01194 
<a name="l01198"></a>01198 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_rep_need_swab(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01199"></a>01199 {
<a name="l01200"></a>01200         <span class="keywordflow">return</span> lustre_rep_swabbed(req, <a class="code" href="group__lustreidl.html#gafa5c71e7497acfe5dea4f5efd14ef8ec" title="only use in req-&amp;gt;rq_{req,rep}_swab_mask">MSG_PTLRPC_HEADER_OFF</a>);
<a name="l01201"></a>01201 }
<a name="l01202"></a>01202 
<a name="l01206"></a>01206 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lustre_set_req_swabbed(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01207"></a>01207                                           <span class="keywordtype">size_t</span> index)
<a name="l01208"></a>01208 {
<a name="l01209"></a>01209         LASSERT(index &lt; <span class="keyword">sizeof</span>(req-&gt;<a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a>) * 8);
<a name="l01210"></a>01210         LASSERT((req-&gt;<a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a> &amp; (1 &lt;&lt; index)) == 0);
<a name="l01211"></a>01211         req-&gt;<a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a> |= 1 &lt;&lt; index;
<a name="l01212"></a>01212 }
<a name="l01213"></a>01213 
<a name="l01217"></a>01217 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lustre_set_rep_swabbed(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01218"></a>01218                                           <span class="keywordtype">size_t</span> index)
<a name="l01219"></a>01219 {
<a name="l01220"></a>01220         LASSERT(index &lt; <span class="keyword">sizeof</span>(req-&gt;rq_rep_swab_mask) * 8);
<a name="l01221"></a>01221         LASSERT((req-&gt;rq_rep_swab_mask &amp; (1 &lt;&lt; index)) == 0);
<a name="l01222"></a>01222         req-&gt;rq_rep_swab_mask |= 1 &lt;&lt; index;
<a name="l01223"></a>01223 }
<a name="l01224"></a>01224 
<a name="l01228"></a>01228 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l01229"></a>01229 ptlrpc_phase2str(<span class="keyword">enum</span> <a class="code" href="group__net.html#ga0e456f0c28b52cad4b543eec9efa656a" title="RPC stages.">rq_phase</a> phase)
<a name="l01230"></a>01230 {
<a name="l01231"></a>01231         <span class="keywordflow">switch</span> (phase) {
<a name="l01232"></a>01232         <span class="keywordflow">case</span> RQ_PHASE_NEW:
<a name="l01233"></a>01233                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;New&quot;</span>;
<a name="l01234"></a>01234         <span class="keywordflow">case</span> RQ_PHASE_RPC:
<a name="l01235"></a>01235                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;Rpc&quot;</span>;
<a name="l01236"></a>01236         <span class="keywordflow">case</span> RQ_PHASE_BULK:
<a name="l01237"></a>01237                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;Bulk&quot;</span>;
<a name="l01238"></a>01238         <span class="keywordflow">case</span> RQ_PHASE_INTERPRET:
<a name="l01239"></a>01239                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;Interpret&quot;</span>;
<a name="l01240"></a>01240         <span class="keywordflow">case</span> RQ_PHASE_COMPLETE:
<a name="l01241"></a>01241                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;Complete&quot;</span>;
<a name="l01242"></a>01242         <span class="keywordflow">case</span> RQ_PHASE_UNREGISTERING:
<a name="l01243"></a>01243                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;Unregistering&quot;</span>;
<a name="l01244"></a>01244         <span class="keywordflow">default</span>:
<a name="l01245"></a>01245                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;?Phase?&quot;</span>;
<a name="l01246"></a>01246         }
<a name="l01247"></a>01247 }
<a name="l01248"></a>01248 
<a name="l01253"></a>01253 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l01254"></a>01254 ptlrpc_rqphase2str(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01255"></a>01255 {
<a name="l01256"></a>01256         <span class="keywordflow">return</span> ptlrpc_phase2str(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a>);
<a name="l01257"></a>01257 }
<a name="l01258"></a>01258 
<a name="l01263"></a>01263 <span class="comment">/* Spare the preprocessor, spoil the bugs. */</span>
<a name="l01264"></a><a class="code" href="group__net.html#gafd94724172cd311f5ce62102d91b8583">01264</a> <span class="preprocessor">#define FLAG(field, str) (field ? str : &quot;&quot;)</span>
<a name="l01265"></a>01265 <span class="preprocessor"></span>
<a name="l01267"></a><a class="code" href="group__net.html#gaf155302427c8b1196ede7e7cd7e7d133">01267</a> <span class="preprocessor">#define DEBUG_REQ_FLAGS(req)                                                    \</span>
<a name="l01268"></a>01268 <span class="preprocessor">        ptlrpc_rqphase2str(req),                                                \</span>
<a name="l01269"></a>01269 <span class="preprocessor">        FLAG(req-&gt;rq_intr, &quot;I&quot;), FLAG(req-&gt;rq_replied, &quot;R&quot;),                    \</span>
<a name="l01270"></a>01270 <span class="preprocessor">        FLAG(req-&gt;rq_err, &quot;E&quot;),                                                 \</span>
<a name="l01271"></a>01271 <span class="preprocessor">        FLAG(req-&gt;rq_timedout, &quot;X&quot;) </span><span class="comment">/* eXpired */</span>, FLAG(req-&gt;rq_resend, &quot;S&quot;),   \
<a name="l01272"></a>01272         FLAG(req-&gt;rq_restart, &quot;T&quot;), FLAG(req-&gt;rq_replay, &quot;P&quot;),                  \
<a name="l01273"></a>01273         FLAG(req-&gt;rq_no_resend, &quot;N&quot;),                                           \
<a name="l01274"></a>01274         FLAG(req-&gt;rq_waiting, &quot;W&quot;),                                             \
<a name="l01275"></a>01275         FLAG(req-&gt;rq_wait_ctx, &quot;C&quot;), FLAG(req-&gt;rq_hp, &quot;H&quot;),                     \
<a name="l01276"></a>01276         FLAG(req-&gt;rq_committed, &quot;M&quot;)
<a name="l01277"></a>01277 
<a name="l01278"></a>01278 <span class="preprocessor">#define REQ_FLAGS_FMT &quot;%s:%s%s%s%s%s%s%s%s%s%s%s%s&quot;</span>
<a name="l01279"></a>01279 <span class="preprocessor"></span>
<a name="l01280"></a>01280 <span class="keywordtype">void</span> _debug_req(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01281"></a>01281                 <span class="keyword">struct</span> <a class="code" href="structlibcfs__debug__msg__data.html">libcfs_debug_msg_data</a> *data, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
<a name="l01282"></a>01282         __attribute__ ((format (printf, 3, 4)));
<a name="l01283"></a>01283 
<a name="l01288"></a><a class="code" href="group__net.html#gaa7f4f5cd9c831160823af2e141bca1c2">01288</a> <span class="preprocessor">#define debug_req(msgdata, mask, cdls, req, fmt, a...)                        \</span>
<a name="l01289"></a>01289 <span class="preprocessor">do {                                                                          \</span>
<a name="l01290"></a>01290 <span class="preprocessor">        CFS_CHECK_STACK(msgdata, mask, cdls);                                 \</span>
<a name="l01291"></a>01291 <span class="preprocessor">                                                                              \</span>
<a name="l01292"></a>01292 <span class="preprocessor">        if (((mask) &amp; D_CANTMASK) != 0 ||                                     \</span>
<a name="l01293"></a>01293 <span class="preprocessor">            ((libcfs_debug &amp; (mask)) != 0 &amp;&amp;                                  \</span>
<a name="l01294"></a>01294 <span class="preprocessor">             (libcfs_subsystem_debug &amp; DEBUG_SUBSYSTEM) != 0))                \</span>
<a name="l01295"></a>01295 <span class="preprocessor">                _debug_req((req), msgdata, fmt, ##a);                         \</span>
<a name="l01296"></a>01296 <span class="preprocessor">} while(0)</span>
<a name="l01297"></a>01297 <span class="preprocessor"></span>
<a name="l01302"></a><a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf">01302</a> <span class="preprocessor">#define DEBUG_REQ(level, req, fmt, args...)                                   \</span>
<a name="l01303"></a>01303 <span class="preprocessor">do {                                                                          \</span>
<a name="l01304"></a>01304 <span class="preprocessor">        if ((level) &amp; (D_ERROR | D_WARNING)) {                                \</span>
<a name="l01305"></a>01305 <span class="preprocessor">                static struct cfs_debug_limit_state cdls;                     \</span>
<a name="l01306"></a>01306 <span class="preprocessor">                LIBCFS_DEBUG_MSG_DATA_DECL(msgdata, level, &amp;cdls);            \</span>
<a name="l01307"></a>01307 <span class="preprocessor">                debug_req(&amp;msgdata, level, &amp;cdls, req, &quot;@@@ &quot;fmt&quot; &quot;, ## args);\</span>
<a name="l01308"></a>01308 <span class="preprocessor">        } else {                                                              \</span>
<a name="l01309"></a>01309 <span class="preprocessor">                LIBCFS_DEBUG_MSG_DATA_DECL(msgdata, level, NULL);             \</span>
<a name="l01310"></a>01310 <span class="preprocessor">                debug_req(&amp;msgdata, level, NULL, req, &quot;@@@ &quot;fmt&quot; &quot;, ## args); \</span>
<a name="l01311"></a>01311 <span class="preprocessor">        }                                                                     \</span>
<a name="l01312"></a>01312 <span class="preprocessor">} while (0)</span>
<a name="l01313"></a>01313 <span class="preprocessor"></span>
<a name="l01318"></a><a class="code" href="structptlrpc__bulk__page.html">01318</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__page.html" title="Structure that defines a single page of a bulk transfer.">ptlrpc_bulk_page</a> {
<a name="l01320"></a><a class="code" href="structptlrpc__bulk__page.html#a574c3151b07b9deccc4f714d4c1ce65c">01320</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> <a class="code" href="structptlrpc__bulk__page.html#a574c3151b07b9deccc4f714d4c1ce65c" title="Linkage to list of pages in a bulk.">bp_link</a>;
<a name="l01324"></a><a class="code" href="structptlrpc__bulk__page.html#a843d4d9e2cc0b161bceb984207d1377c">01324</a>         <span class="keywordtype">int</span>              <a class="code" href="structptlrpc__bulk__page.html#a843d4d9e2cc0b161bceb984207d1377c" title="Number of bytes in a page to transfer starting from bp_pageoffset.">bp_buflen</a>;
<a name="l01326"></a><a class="code" href="structptlrpc__bulk__page.html#a8ea8ffcce64cc81aed126c57f1412536">01326</a>         <span class="keywordtype">int</span>              <a class="code" href="structptlrpc__bulk__page.html#a8ea8ffcce64cc81aed126c57f1412536" title="offset within a page">bp_pageoffset</a>;
<a name="l01328"></a><a class="code" href="structptlrpc__bulk__page.html#a9b823a4a85c3cef2c9b34bc755e397f3">01328</a>         <span class="keyword">struct </span>page     *<a class="code" href="structptlrpc__bulk__page.html#a9b823a4a85c3cef2c9b34bc755e397f3" title="The page itself.">bp_page</a>;
<a name="l01329"></a>01329 };
<a name="l01330"></a>01330 
<a name="l01331"></a>01331 <span class="keyword">enum</span> ptlrpc_bulk_op_type {
<a name="l01332"></a>01332         PTLRPC_BULK_OP_ACTIVE =  0x00000001,
<a name="l01333"></a>01333         PTLRPC_BULK_OP_PASSIVE = 0x00000002,
<a name="l01334"></a>01334         PTLRPC_BULK_OP_PUT =     0x00000004,
<a name="l01335"></a>01335         PTLRPC_BULK_OP_GET =     0x00000008,
<a name="l01336"></a>01336         PTLRPC_BULK_BUF_KVEC =   0x00000010,
<a name="l01337"></a>01337         PTLRPC_BULK_BUF_KIOV =   0x00000020,
<a name="l01338"></a>01338         PTLRPC_BULK_GET_SOURCE = PTLRPC_BULK_OP_PASSIVE | PTLRPC_BULK_OP_GET,
<a name="l01339"></a>01339         PTLRPC_BULK_PUT_SINK =   PTLRPC_BULK_OP_PASSIVE | PTLRPC_BULK_OP_PUT,
<a name="l01340"></a>01340         PTLRPC_BULK_GET_SINK =   PTLRPC_BULK_OP_ACTIVE | PTLRPC_BULK_OP_GET,
<a name="l01341"></a>01341         PTLRPC_BULK_PUT_SOURCE = PTLRPC_BULK_OP_ACTIVE | PTLRPC_BULK_OP_PUT,
<a name="l01342"></a>01342 };
<a name="l01343"></a>01343 
<a name="l01344"></a>01344 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_is_bulk_op_get(<span class="keyword">enum</span> ptlrpc_bulk_op_type type)
<a name="l01345"></a>01345 {
<a name="l01346"></a>01346         <span class="keywordflow">return</span> (type &amp; PTLRPC_BULK_OP_GET) == PTLRPC_BULK_OP_GET;
<a name="l01347"></a>01347 }
<a name="l01348"></a>01348 
<a name="l01349"></a>01349 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_is_bulk_get_source(<span class="keyword">enum</span> ptlrpc_bulk_op_type type)
<a name="l01350"></a>01350 {
<a name="l01351"></a>01351         <span class="keywordflow">return</span> (type &amp; PTLRPC_BULK_GET_SOURCE) == PTLRPC_BULK_GET_SOURCE;
<a name="l01352"></a>01352 }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_is_bulk_put_sink(<span class="keyword">enum</span> ptlrpc_bulk_op_type type)
<a name="l01355"></a>01355 {
<a name="l01356"></a>01356         <span class="keywordflow">return</span> (type &amp; PTLRPC_BULK_PUT_SINK) == PTLRPC_BULK_PUT_SINK;
<a name="l01357"></a>01357 }
<a name="l01358"></a>01358 
<a name="l01359"></a>01359 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_is_bulk_get_sink(<span class="keyword">enum</span> ptlrpc_bulk_op_type type)
<a name="l01360"></a>01360 {
<a name="l01361"></a>01361         <span class="keywordflow">return</span> (type &amp; PTLRPC_BULK_GET_SINK) == PTLRPC_BULK_GET_SINK;
<a name="l01362"></a>01362 }
<a name="l01363"></a>01363 
<a name="l01364"></a>01364 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_is_bulk_put_source(<span class="keyword">enum</span> ptlrpc_bulk_op_type type)
<a name="l01365"></a>01365 {
<a name="l01366"></a>01366         <span class="keywordflow">return</span> (type &amp; PTLRPC_BULK_PUT_SOURCE) == PTLRPC_BULK_PUT_SOURCE;
<a name="l01367"></a>01367 }
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_is_bulk_desc_kvec(<span class="keyword">enum</span> ptlrpc_bulk_op_type type)
<a name="l01370"></a>01370 {
<a name="l01371"></a>01371         <span class="keywordflow">return</span> ((type &amp; PTLRPC_BULK_BUF_KVEC) | (type &amp; PTLRPC_BULK_BUF_KIOV))
<a name="l01372"></a>01372                         == PTLRPC_BULK_BUF_KVEC;
<a name="l01373"></a>01373 }
<a name="l01374"></a>01374 
<a name="l01375"></a>01375 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_is_bulk_desc_kiov(<span class="keyword">enum</span> ptlrpc_bulk_op_type type)
<a name="l01376"></a>01376 {
<a name="l01377"></a>01377         <span class="keywordflow">return</span> ((type &amp; PTLRPC_BULK_BUF_KVEC) | (type &amp; PTLRPC_BULK_BUF_KIOV))
<a name="l01378"></a>01378                         == PTLRPC_BULK_BUF_KIOV;
<a name="l01379"></a>01379 }
<a name="l01380"></a>01380 
<a name="l01381"></a>01381 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_is_bulk_op_active(<span class="keyword">enum</span> ptlrpc_bulk_op_type type)
<a name="l01382"></a>01382 {
<a name="l01383"></a>01383         <span class="keywordflow">return</span> ((type &amp; PTLRPC_BULK_OP_ACTIVE) |
<a name="l01384"></a>01384                 (type &amp; PTLRPC_BULK_OP_PASSIVE))
<a name="l01385"></a>01385                         == PTLRPC_BULK_OP_ACTIVE;
<a name="l01386"></a>01386 }
<a name="l01387"></a>01387 
<a name="l01388"></a>01388 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ptlrpc_is_bulk_op_passive(<span class="keyword">enum</span> ptlrpc_bulk_op_type type)
<a name="l01389"></a>01389 {
<a name="l01390"></a>01390         <span class="keywordflow">return</span> ((type &amp; PTLRPC_BULK_OP_ACTIVE) |
<a name="l01391"></a>01391                 (type &amp; PTLRPC_BULK_OP_PASSIVE))
<a name="l01392"></a>01392                         == PTLRPC_BULK_OP_PASSIVE;
<a name="l01393"></a>01393 }
<a name="l01394"></a>01394 
<a name="l01395"></a><a class="code" href="structptlrpc__bulk__frag__ops.html">01395</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> {
<a name="l01401"></a>01401         void (*<a class="code" href="structptlrpc__bulk__frag__ops.html#a3338125828618910ae190978e235d52a" title="Add a page page to the bulk descriptor desc Data to transfer in the page starts at...">add_kiov_frag</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l01402"></a>01402                               <span class="keyword">struct </span>page *page, <span class="keywordtype">int</span> pageoffset, <span class="keywordtype">int</span> len);
<a name="l01403"></a>01403 
<a name="l01404"></a>01404         <span class="comment">/*</span>
<a name="l01405"></a>01405 <span class="comment">         * Add a \a fragment to the bulk descriptor \a desc.</span>
<a name="l01406"></a>01406 <span class="comment">         * Data to transfer in the fragment is pointed to by \a frag</span>
<a name="l01407"></a>01407 <span class="comment">         * The size of the fragment is \a len</span>
<a name="l01408"></a>01408 <span class="comment">         */</span>
<a name="l01409"></a>01409         int (*add_iov_frag)(<span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc, <span class="keywordtype">void</span> *frag, <span class="keywordtype">int</span> len);
<a name="l01410"></a>01410 
<a name="l01415"></a>01415         void (*<a class="code" href="structptlrpc__bulk__frag__ops.html#a2604b1837635c96693183c071925fd15" title="Uninitialize and free bulk descriptor desc.">release_frags</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l01416"></a>01416 };
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> ptlrpc_bulk_kiov_pin_ops;
<a name="l01419"></a>01419 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> ptlrpc_bulk_kiov_nopin_ops;
<a name="l01420"></a>01420 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> ptlrpc_bulk_kvec_ops;
<a name="l01421"></a>01421 
<a name="l01422"></a>01422 <span class="comment">/*</span>
<a name="l01423"></a>01423 <span class="comment"> * Definition of bulk descriptor.</span>
<a name="l01424"></a>01424 <span class="comment"> * Bulks are special &quot;Two phase&quot; RPCs where initial request message</span>
<a name="l01425"></a>01425 <span class="comment"> * is sent first and it is followed bt a transfer (o receiving) of a large</span>
<a name="l01426"></a>01426 <span class="comment"> * amount of data to be settled into pages referenced from the bulk descriptors.</span>
<a name="l01427"></a>01427 <span class="comment"> * Bulks transfers (the actual data following the small requests) are done</span>
<a name="l01428"></a>01428 <span class="comment"> * on separate LNet portals.</span>
<a name="l01429"></a>01429 <span class="comment"> * In lustre we use bulk transfers for READ and WRITE transfers from/to OSTs.</span>
<a name="l01430"></a>01430 <span class="comment"> *  Another user is readpage for MDT.</span>
<a name="l01431"></a>01431 <span class="comment"> */</span>
<a name="l01432"></a><a class="code" href="structptlrpc__bulk__desc.html">01432</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> {
<a name="l01434"></a><a class="code" href="structptlrpc__bulk__desc.html#ad2c8f2d528e849f5032676b40f040f0c">01434</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="structptlrpc__bulk__desc.html#ad2c8f2d528e849f5032676b40f040f0c" title="completed with failure">bd_failure</a>:1;
<a name="l01436"></a><a class="code" href="structptlrpc__bulk__desc.html#a29bfcbd3cf54cdbc36b530bd00362ea4">01436</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="structptlrpc__bulk__desc.html#a29bfcbd3cf54cdbc36b530bd00362ea4" title="client side">bd_registered</a>:1;
<a name="l01438"></a><a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10">01438</a>         spinlock_t <a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>;
<a name="l01440"></a><a class="code" href="structptlrpc__bulk__desc.html#a939c59e8ca2ab48321d206fb7ac148b5">01440</a>         <span class="keywordtype">int</span> <a class="code" href="structptlrpc__bulk__desc.html#a939c59e8ca2ab48321d206fb7ac148b5" title="Import generation when request for this bulk was sent.">bd_import_generation</a>;
<a name="l01442"></a><a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8">01442</a>         <span class="keyword">enum</span> ptlrpc_bulk_op_type <a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a>;
<a name="l01444"></a><a class="code" href="structptlrpc__bulk__desc.html#a18b9d9682e655499c82b9e785343d0df">01444</a>         __u32 <a class="code" href="structptlrpc__bulk__desc.html#a18b9d9682e655499c82b9e785343d0df" title="LNet portal for this bulk.">bd_portal</a>;
<a name="l01446"></a><a class="code" href="structptlrpc__bulk__desc.html#a079104697abfc4ecef92f7f954f3c3d7">01446</a>         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *<a class="code" href="structptlrpc__bulk__desc.html#a079104697abfc4ecef92f7f954f3c3d7" title="Server side - export this bulk created for.">bd_export</a>;
<a name="l01448"></a><a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381">01448</a>         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a>;
<a name="l01450"></a><a class="code" href="structptlrpc__bulk__desc.html#a4d18b5020a6fbf0bb1c7f7e1af278707">01450</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *<a class="code" href="structptlrpc__bulk__desc.html#a4d18b5020a6fbf0bb1c7f7e1af278707" title="Back pointer to the request.">bd_req</a>;
<a name="l01451"></a>01451         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> *bd_frag_ops;
<a name="l01452"></a>01452         wait_queue_head_t      bd_waitq;        <span class="comment">/* server side only WQ */</span>
<a name="l01453"></a>01453         <span class="keywordtype">int</span>                    bd_iov_count;    <span class="comment">/* # entries in bd_iov */</span>
<a name="l01454"></a>01454         <span class="keywordtype">int</span>                    bd_max_iov;      <span class="comment">/* allocated size of bd_iov */</span>
<a name="l01455"></a>01455         <span class="keywordtype">int</span>                    bd_nob;          <span class="comment">/* # bytes covered */</span>
<a name="l01456"></a>01456         <span class="keywordtype">int</span>                    bd_nob_transferred; <span class="comment">/* # bytes GOT/PUT */</span>
<a name="l01457"></a>01457 
<a name="l01458"></a>01458         __u64                  bd_last_mbits;
<a name="l01459"></a>01459 
<a name="l01460"></a>01460         <span class="keyword">struct </span><a class="code" href="structptlrpc__cb__id.html" title="ptlrpc callback &amp;amp; work item stuff">ptlrpc_cb_id</a>    bd_cbid;         <span class="comment">/* network callback info */</span>
<a name="l01461"></a>01461         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>             bd_sender;       <span class="comment">/* stash event::sender */</span>
<a name="l01462"></a>01462         <span class="keywordtype">int</span>                     bd_md_count;    <span class="comment">/* # valid entries in bd_mds */</span>
<a name="l01463"></a>01463         <span class="keywordtype">int</span>                     bd_md_max_brw;  <span class="comment">/* max entries in bd_mds */</span>
<a name="l01465"></a><a class="code" href="structptlrpc__bulk__desc.html#a39514074e69f6f37f43699541282c288">01465</a>         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>        <a class="code" href="structptlrpc__bulk__desc.html#a39514074e69f6f37f43699541282c288" title="array of associated MDs">bd_mds</a>[PTLRPC_BULK_OPS_COUNT];
<a name="l01466"></a>01466 
<a name="l01467"></a>01467         <span class="keyword">union </span>{
<a name="l01468"></a>01468                 <span class="keyword">struct </span>{
<a name="l01469"></a>01469                         <span class="comment">/*</span>
<a name="l01470"></a>01470 <span class="comment">                         * encrypt iov, size is either 0 or bd_iov_count.</span>
<a name="l01471"></a>01471 <span class="comment">                         */</span>
<a name="l01472"></a>01472                         <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a> *bd_enc_vec;
<a name="l01473"></a>01473                         <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a> *bd_vec;
<a name="l01474"></a>01474                 } bd_kiov;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476                 <span class="keyword">struct </span>{
<a name="l01477"></a>01477                         <span class="keyword">struct </span>kvec *bd_enc_kvec;
<a name="l01478"></a>01478                         <span class="keyword">struct </span>kvec *bd_kvec;
<a name="l01479"></a>01479                 } bd_kvec;
<a name="l01480"></a>01480         } bd_u;
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 };
<a name="l01483"></a>01483 
<a name="l01484"></a>01484 <span class="preprocessor">#define GET_KIOV(desc)                  ((desc)-&gt;bd_u.bd_kiov.bd_vec)</span>
<a name="l01485"></a>01485 <span class="preprocessor"></span><span class="preprocessor">#define BD_GET_KIOV(desc, i)            ((desc)-&gt;bd_u.bd_kiov.bd_vec[i])</span>
<a name="l01486"></a>01486 <span class="preprocessor"></span><span class="preprocessor">#define GET_ENC_KIOV(desc)              ((desc)-&gt;bd_u.bd_kiov.bd_enc_vec)</span>
<a name="l01487"></a>01487 <span class="preprocessor"></span><span class="preprocessor">#define BD_GET_ENC_KIOV(desc, i)        ((desc)-&gt;bd_u.bd_kiov.bd_enc_vec[i])</span>
<a name="l01488"></a>01488 <span class="preprocessor"></span><span class="preprocessor">#define GET_KVEC(desc)                  ((desc)-&gt;bd_u.bd_kvec.bd_kvec)</span>
<a name="l01489"></a>01489 <span class="preprocessor"></span><span class="preprocessor">#define BD_GET_KVEC(desc, i)            ((desc)-&gt;bd_u.bd_kvec.bd_kvec[i])</span>
<a name="l01490"></a>01490 <span class="preprocessor"></span><span class="preprocessor">#define GET_ENC_KVEC(desc)              ((desc)-&gt;bd_u.bd_kvec.bd_enc_kvec)</span>
<a name="l01491"></a>01491 <span class="preprocessor"></span><span class="preprocessor">#define BD_GET_ENC_KVEC(desc, i)        ((desc)-&gt;bd_u.bd_kvec.bd_enc_kvec[i])</span>
<a name="l01492"></a>01492 <span class="preprocessor"></span>
<a name="l01493"></a>01493 <span class="keyword">enum</span> {
<a name="l01494"></a>01494         SVC_STOPPED     = 1 &lt;&lt; 0,
<a name="l01495"></a>01495         SVC_STOPPING    = 1 &lt;&lt; 1,
<a name="l01496"></a>01496         SVC_STARTING    = 1 &lt;&lt; 2,
<a name="l01497"></a>01497         SVC_RUNNING     = 1 &lt;&lt; 3,
<a name="l01498"></a>01498         SVC_EVENT       = 1 &lt;&lt; 4,
<a name="l01499"></a>01499         SVC_SIGNAL      = 1 &lt;&lt; 5,
<a name="l01500"></a>01500 };
<a name="l01501"></a>01501 
<a name="l01502"></a>01502 <span class="preprocessor">#define PTLRPC_THR_NAME_LEN             32</span>
<a name="l01503"></a>01503 <span class="preprocessor"></span>
<a name="l01506"></a><a class="code" href="structptlrpc__thread.html">01506</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> {
<a name="l01510"></a><a class="code" href="structptlrpc__thread.html#aae3239900e0e33d2fc4bd21382712c25">01510</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> <a class="code" href="structptlrpc__thread.html#aae3239900e0e33d2fc4bd21382712c25" title="List of active threads in svc-&amp;gt;srv_threads.">t_link</a>;
<a name="l01514"></a><a class="code" href="structptlrpc__thread.html#a4c277215a3191c5f3f9bdee5e6bff62d">01514</a>         <span class="keywordtype">void</span> *<a class="code" href="structptlrpc__thread.html#a4c277215a3191c5f3f9bdee5e6bff62d" title="thread-private data (preallocated vmalloc&amp;#39;d memory)">t_data</a>;
<a name="l01515"></a>01515         __u32 t_flags;
<a name="l01519"></a><a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894">01519</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a>;
<a name="l01523"></a><a class="code" href="structptlrpc__thread.html#aa8c67cb27a88779527ca37106a52e095">01523</a>         pid_t <a class="code" href="structptlrpc__thread.html#aa8c67cb27a88779527ca37106a52e095" title="service thread pid">t_pid</a>;
<a name="l01527"></a><a class="code" href="structptlrpc__thread.html#a03dcaad73307322e1dfe8430c7aa2049">01527</a>         <span class="keyword">struct </span>lc_watchdog *<a class="code" href="structptlrpc__thread.html#a03dcaad73307322e1dfe8430c7aa2049" title="put watchdog in the structure per thread b=14840">t_watchdog</a>;
<a name="l01531"></a><a class="code" href="structptlrpc__thread.html#af71d131dfdec9144aa2eac252e1e49e4">01531</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *<a class="code" href="structptlrpc__thread.html#af71d131dfdec9144aa2eac252e1e49e4" title="the svc this thread belonged to b=18582">t_svcpt</a>;
<a name="l01532"></a>01532         wait_queue_head_t               t_ctl_waitq;
<a name="l01533"></a>01533         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>                   *t_env;
<a name="l01534"></a>01534         <span class="keywordtype">char</span>                            t_name[PTLRPC_THR_NAME_LEN];
<a name="l01535"></a>01535 };
<a name="l01536"></a>01536 
<a name="l01537"></a>01537 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> thread_is_init(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread)
<a name="l01538"></a>01538 {
<a name="l01539"></a>01539         <span class="keywordflow">return</span> thread-&gt;t_flags == 0;
<a name="l01540"></a>01540 }
<a name="l01541"></a>01541 
<a name="l01542"></a>01542 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> thread_is_stopped(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread)
<a name="l01543"></a>01543 {
<a name="l01544"></a>01544         <span class="keywordflow">return</span> !!(thread-&gt;t_flags &amp; SVC_STOPPED);
<a name="l01545"></a>01545 }
<a name="l01546"></a>01546 
<a name="l01547"></a>01547 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> thread_is_stopping(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread)
<a name="l01548"></a>01548 {
<a name="l01549"></a>01549         <span class="keywordflow">return</span> !!(thread-&gt;t_flags &amp; SVC_STOPPING);
<a name="l01550"></a>01550 }
<a name="l01551"></a>01551 
<a name="l01552"></a>01552 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> thread_is_starting(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread)
<a name="l01553"></a>01553 {
<a name="l01554"></a>01554         <span class="keywordflow">return</span> !!(thread-&gt;t_flags &amp; SVC_STARTING);
<a name="l01555"></a>01555 }
<a name="l01556"></a>01556 
<a name="l01557"></a>01557 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> thread_is_running(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread)
<a name="l01558"></a>01558 {
<a name="l01559"></a>01559         <span class="keywordflow">return</span> !!(thread-&gt;t_flags &amp; SVC_RUNNING);
<a name="l01560"></a>01560 }
<a name="l01561"></a>01561 
<a name="l01562"></a>01562 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> thread_is_event(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread)
<a name="l01563"></a>01563 {
<a name="l01564"></a>01564         <span class="keywordflow">return</span> !!(thread-&gt;t_flags &amp; SVC_EVENT);
<a name="l01565"></a>01565 }
<a name="l01566"></a>01566 
<a name="l01567"></a>01567 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> thread_is_signal(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread)
<a name="l01568"></a>01568 {
<a name="l01569"></a>01569         <span class="keywordflow">return</span> !!(thread-&gt;t_flags &amp; SVC_SIGNAL);
<a name="l01570"></a>01570 }
<a name="l01571"></a>01571 
<a name="l01572"></a>01572 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> thread_clear_flags(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread, __u32 flags)
<a name="l01573"></a>01573 {
<a name="l01574"></a>01574         thread-&gt;t_flags &amp;= ~flags;
<a name="l01575"></a>01575 }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> thread_set_flags(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread, __u32 flags)
<a name="l01578"></a>01578 {
<a name="l01579"></a>01579         thread-&gt;t_flags = flags;
<a name="l01580"></a>01580 }
<a name="l01581"></a>01581 
<a name="l01582"></a>01582 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> thread_add_flags(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread, __u32 flags)
<a name="l01583"></a>01583 {
<a name="l01584"></a>01584         thread-&gt;t_flags |= flags;
<a name="l01585"></a>01585 }
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> thread_test_and_clear_flags(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thread,
<a name="l01588"></a>01588                                               __u32 flags)
<a name="l01589"></a>01589 {
<a name="l01590"></a>01590         <span class="keywordflow">if</span> (thread-&gt;t_flags &amp; flags) {
<a name="l01591"></a>01591                 thread-&gt;t_flags &amp;= ~flags;
<a name="l01592"></a>01592                 <span class="keywordflow">return</span> 1;
<a name="l01593"></a>01593         }
<a name="l01594"></a>01594         <span class="keywordflow">return</span> 0;
<a name="l01595"></a>01595 }
<a name="l01596"></a>01596 
<a name="l01604"></a><a class="code" href="structptlrpc__request__buffer__desc.html">01604</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> {
<a name="l01606"></a><a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107">01606</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>;
<a name="l01608"></a><a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f">01608</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>;
<a name="l01610"></a><a class="code" href="structptlrpc__request__buffer__desc.html#a1e7bb4edc15fbecb9ef0800039fe255e">01610</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *<a class="code" href="structptlrpc__request__buffer__desc.html#a1e7bb4edc15fbecb9ef0800039fe255e" title="Back pointer to service for which this buffer is registered.">rqbd_svcpt</a>;
<a name="l01612"></a><a class="code" href="structptlrpc__request__buffer__desc.html#a1dbe83278f677b1c4bfa121131373418">01612</a>         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>                <a class="code" href="structptlrpc__request__buffer__desc.html#a1dbe83278f677b1c4bfa121131373418" title="LNet descriptor.">rqbd_md_h</a>;
<a name="l01613"></a>01613         <span class="keywordtype">int</span>                             rqbd_refcount;
<a name="l01615"></a><a class="code" href="structptlrpc__request__buffer__desc.html#ad4b53ddbaa302876b0e01ecf24287ce4">01615</a>         <span class="keywordtype">char</span>                            *<a class="code" href="structptlrpc__request__buffer__desc.html#ad4b53ddbaa302876b0e01ecf24287ce4" title="The buffer itself.">rqbd_buffer</a>;
<a name="l01616"></a>01616         <span class="keyword">struct </span><a class="code" href="structptlrpc__cb__id.html" title="ptlrpc callback &amp;amp; work item stuff">ptlrpc_cb_id</a>             rqbd_cbid;
<a name="l01621"></a><a class="code" href="structptlrpc__request__buffer__desc.html#a039d2591d32389c3b0e9c739c33cf263">01621</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>           <a class="code" href="structptlrpc__request__buffer__desc.html#a039d2591d32389c3b0e9c739c33cf263" title="This &amp;quot;embedded&amp;quot; request structure is only used for the last request to...">rqbd_req</a>;
<a name="l01622"></a>01622 };
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 <span class="keyword">typedef</span> int  (*svc_handler_t)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01625"></a>01625 
<a name="l01626"></a><a class="code" href="structptlrpc__service__ops.html">01626</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__service__ops.html">ptlrpc_service_ops</a> {
<a name="l01631"></a>01631         int             (*<a class="code" href="structptlrpc__service__ops.html#a46b48cb79fc9aa8a65bb59b204ef6f29" title="if non-NULL called during thread creation (ptlrpc_start_thread()) to initialize service...">so_thr_init</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thr);
<a name="l01636"></a>01636         void            (*<a class="code" href="structptlrpc__service__ops.html#ae5aa4ea05c5025d162fbef6e3cd11b20" title="if non-NULL called during thread shutdown (ptlrpc_main()) to destruct state created...">so_thr_done</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *thr);
<a name="l01640"></a>01640         int             (*<a class="code" href="structptlrpc__service__ops.html#ace0bd2960a564f7e405763b10879d854" title="Handler function for incoming requests for this service.">so_req_handler</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01645"></a>01645         int             (*<a class="code" href="structptlrpc__service__ops.html#a3b99111ca745490f2cd0cfd183482174" title="function to determine priority of the request, it&amp;#39;s called on every new request...">so_hpreq_handler</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *);
<a name="l01649"></a>01649         void            (*<a class="code" href="structptlrpc__service__ops.html#ab2cb41eb7d52ec069e16aca7757f167c" title="service-specific print fn">so_req_printer</a>)(<span class="keywordtype">void</span> *, <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *);
<a name="l01650"></a>01650 };
<a name="l01651"></a>01651 
<a name="l01652"></a>01652 <span class="preprocessor">#ifndef __cfs_cacheline_aligned</span>
<a name="l01653"></a>01653 <span class="preprocessor"></span><span class="comment">/* NB: put it here for reducing patche dependence */</span>
<a name="l01654"></a>01654 <span class="preprocessor"># define __cfs_cacheline_aligned</span>
<a name="l01655"></a>01655 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01656"></a>01656 <span class="preprocessor"></span>
<a name="l01661"></a><a class="code" href="group__net.html#ga4f4d7f4b592db13b248e9f0973608f71">01661</a> <span class="preprocessor">#define PTLRPC_SVC_HP_RATIO 10</span>
<a name="l01662"></a>01662 <span class="preprocessor"></span>
<a name="l01669"></a><a class="code" href="structptlrpc__service.html">01669</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> {
<a name="l01671"></a><a class="code" href="structptlrpc__service.html#a2a1688cbca333e023932a1d01da3adf2">01671</a>         spinlock_t                      <a class="code" href="structptlrpc__service.html#a2a1688cbca333e023932a1d01da3adf2" title="serialize /proc operations">srv_lock</a>;
<a name="l01674"></a><a class="code" href="structptlrpc__service.html#a7b76c93b05ae8b75256861ab53f5db59">01674</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service.html#a7b76c93b05ae8b75256861ab53f5db59" title="most often accessed fields">srv_list</a>;
<a name="l01676"></a><a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90">01676</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__ops.html">ptlrpc_service_ops</a>       <a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90" title="service operations table">srv_ops</a>;
<a name="l01678"></a><a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55">01678</a>         <span class="keywordtype">char</span>                           *<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>;
<a name="l01680"></a><a class="code" href="structptlrpc__service.html#a3618e53f527140ea9c7861f64565b321">01680</a>         <span class="keywordtype">char</span>                           *<a class="code" href="structptlrpc__service.html#a3618e53f527140ea9c7861f64565b321" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_thread_name</a>;
<a name="l01682"></a><a class="code" href="structptlrpc__service.html#a5a7a4999f0e19f7a4896f1092d53e0c3">01682</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service.html#a5a7a4999f0e19f7a4896f1092d53e0c3" title="service thread list">srv_threads</a>;
<a name="l01684"></a><a class="code" href="structptlrpc__service.html#adcfb71b3b7e40714db19751ebf3889ad">01684</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#adcfb71b3b7e40714db19751ebf3889ad" title="threads # should be created for each partition on initializing">srv_nthrs_cpt_init</a>;
<a name="l01686"></a><a class="code" href="structptlrpc__service.html#ab1eb42fd85f14f4a6bccd9025ed5e101">01686</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#ab1eb42fd85f14f4a6bccd9025ed5e101" title="limit of threads number for each partition">srv_nthrs_cpt_limit</a>;
<a name="l01688"></a><a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691">01688</a>         <span class="keyword">struct </span>proc_dir_entry           *<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a>;
<a name="l01690"></a><a class="code" href="structptlrpc__service.html#a47394cf36a95669f10d8ccaaa21e3e82">01690</a>         <span class="keyword">struct </span><a class="code" href="structlprocfs__stats.html">lprocfs_stats</a>           *<a class="code" href="structptlrpc__service.html#a47394cf36a95669f10d8ccaaa21e3e82" title="Pointer to statistic data for this service.">srv_stats</a>;
<a name="l01692"></a><a class="code" href="structptlrpc__service.html#a73de1e37738df30184d39314262bebbb">01692</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#a73de1e37738df30184d39314262bebbb" title="# hp per lp reqs to handle">srv_hpreq_ratio</a>;
<a name="l01694"></a><a class="code" href="structptlrpc__service.html#a4e6fb169a6bd2375b8f724ec9c5c57bc">01694</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#a4e6fb169a6bd2375b8f724ec9c5c57bc" title="biggest request to receive">srv_max_req_size</a>;
<a name="l01696"></a><a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51">01696</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51" title="biggest reply to send">srv_max_reply_size</a>;
<a name="l01698"></a><a class="code" href="structptlrpc__service.html#ad777e605aff6b7a216384cec5917575b">01698</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#ad777e605aff6b7a216384cec5917575b" title="size of individual buffers">srv_buf_size</a>;
<a name="l01700"></a><a class="code" href="structptlrpc__service.html#a54dfbef346d31cd165d5815410fe7b25">01700</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#a54dfbef346d31cd165d5815410fe7b25" title="# buffers to allocate in 1 group">srv_nbuf_per_group</a>;
<a name="l01702"></a><a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b">01702</a>         __u32                           <a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>;
<a name="l01704"></a><a class="code" href="structptlrpc__service.html#a80ea8b17769802197d27c45a7a485958">01704</a>         __u32                           <a class="code" href="structptlrpc__service.html#a80ea8b17769802197d27c45a7a485958" title="Portal on the client to send replies to.">srv_rep_portal</a>;
<a name="l01709"></a><a class="code" href="structptlrpc__service.html#af76e91c99923a872836d738214efad63">01709</a>         __u32                           <a class="code" href="structptlrpc__service.html#af76e91c99923a872836d738214efad63" title="Tags for lu_context associated with this thread, see struct lu_context.">srv_ctx_tags</a>;
<a name="l01711"></a><a class="code" href="structptlrpc__service.html#a1117d58e40a577dce38f8985a491c895">01711</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#a1117d58e40a577dce38f8985a491c895" title="soft watchdog timeout multiplier">srv_watchdog_factor</a>;
<a name="l01713"></a><a class="code" href="structptlrpc__service.html#a356fa84033571129333ab81646a283df">01713</a>         <span class="keywordtype">unsigned</span>                        <a class="code" href="structptlrpc__service.html#a356fa84033571129333ab81646a283df" title="under unregister_service">srv_is_stopping</a>:1;
<a name="l01714"></a>01714 
<a name="l01716"></a><a class="code" href="structptlrpc__service.html#ab8c2b2b1eaca9032c565e830244fdfdb">01716</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#ab8c2b2b1eaca9032c565e830244fdfdb" title="max # request buffers in history per partition">srv_hist_nrqbds_cpt_max</a>;
<a name="l01718"></a><a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a">01718</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>;
<a name="l01720"></a><a class="code" href="structptlrpc__service.html#a2c32ba2dab0f289ff0ebbd2f093fe7ba">01720</a>         __u32                           *<a class="code" href="structptlrpc__service.html#a2c32ba2dab0f289ff0ebbd2f093fe7ba" title="CPTs array this service bound on.">srv_cpts</a>;
<a name="l01722"></a><a class="code" href="structptlrpc__service.html#a073426a7d8cdc28ce5ebe9849cc49695">01722</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service.html#a073426a7d8cdc28ce5ebe9849cc49695" title="2^srv_cptab_bits &amp;gt;= cfs_cpt_numbert(srv_cptable)">srv_cpt_bits</a>;
<a name="l01724"></a><a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189">01724</a>         <span class="keyword">struct </span><a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>            *<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>;
<a name="l01728"></a><a class="code" href="structptlrpc__service.html#a7e35faf6ba1087f8f57b57fd8ef98bb8">01728</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *<a class="code" href="structptlrpc__service.html#a7e35faf6ba1087f8f57b57fd8ef98bb8" title="partition data for ptlrpc service">srv_parts</a>[0];
<a name="l01729"></a>01729 };
<a name="l01730"></a>01730 
<a name="l01749"></a><a class="code" href="structptlrpc__service__part.html">01749</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> {
<a name="l01751"></a><a class="code" href="structptlrpc__service__part.html#a45f53648b1a614576a8044aa875fa4cc">01751</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>           *scp_service <a class="code" href="structptlrpc__service__part.html#a45f53648b1a614576a8044aa875fa4cc" title="back reference to owner">__cfs_cacheline_aligned</a>;
<a name="l01752"></a>01752         <span class="comment">/* CPT id, reserved */</span>
<a name="l01753"></a>01753         <span class="keywordtype">int</span>                             scp_cpt;
<a name="l01755"></a><a class="code" href="structptlrpc__service__part.html#af6581a250bb165eb31291b5daf4a422e">01755</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#af6581a250bb165eb31291b5daf4a422e" title="always increasing number">scp_thr_nextid</a>;
<a name="l01757"></a><a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a">01757</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a" title="# of starting threads">scp_nthrs_starting</a>;
<a name="l01759"></a><a class="code" href="structptlrpc__service__part.html#ac4d1c9dcf8c480670ff145c147964a9c">01759</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#ac4d1c9dcf8c480670ff145c147964a9c" title="# of stopping threads, reserved for shrinking threads">scp_nthrs_stopping</a>;
<a name="l01761"></a><a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77">01761</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a>;
<a name="l01763"></a><a class="code" href="structptlrpc__service__part.html#a658b2ed23da83f38e3acbe91191412e0">01763</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service__part.html#a658b2ed23da83f38e3acbe91191412e0" title="service threads list">scp_threads</a>;
<a name="l01764"></a>01764 
<a name="l01770"></a><a class="code" href="structptlrpc__service__part.html#ac032a55e8e53094bebf77b83f52f9095">01770</a>         spinlock_t                      scp_lock  <a class="code" href="structptlrpc__service__part.html#a45f53648b1a614576a8044aa875fa4cc" title="back reference to owner">__cfs_cacheline_aligned</a>;
<a name="l01772"></a><a class="code" href="structptlrpc__service__part.html#a44b088268ad85c097e75785018da059f">01772</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#a44b088268ad85c097e75785018da059f" title="total # req buffer descs allocated">scp_nrqbds_total</a>;
<a name="l01774"></a><a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a">01774</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a" title="# posted request buffers for receiving">scp_nrqbds_posted</a>;
<a name="l01776"></a><a class="code" href="structptlrpc__service__part.html#ad128b103863a3a90a2a0fffeaa9b0198">01776</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#ad128b103863a3a90a2a0fffeaa9b0198" title="in progress of allocating rqbd">scp_rqbd_allocating</a>;
<a name="l01778"></a><a class="code" href="structptlrpc__service__part.html#a8283d58f626b885a04d59e22ac5b234a">01778</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#a8283d58f626b885a04d59e22ac5b234a" title="# incoming reqs">scp_nreqs_incoming</a>;
<a name="l01780"></a><a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b">01780</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>;
<a name="l01782"></a><a class="code" href="structptlrpc__service__part.html#acd3cb2ad8f3ef3e78751f83373c0e688">01782</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service__part.html#acd3cb2ad8f3ef3e78751f83373c0e688" title="req buffers receiving">scp_rqbd_posted</a>;
<a name="l01784"></a><a class="code" href="structptlrpc__service__part.html#a54fb502a4f6c138aaa49eb9afea6e39c">01784</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service__part.html#a54fb502a4f6c138aaa49eb9afea6e39c" title="incoming reqs">scp_req_incoming</a>;
<a name="l01786"></a><a class="code" href="structptlrpc__service__part.html#a22eb45de0fb6b349d79bb092fb83c00a">01786</a>         cfs_duration_t                  <a class="code" href="structptlrpc__service__part.html#a22eb45de0fb6b349d79bb092fb83c00a" title="timeout before re-posting reqs, in tick">scp_rqbd_timeout</a>;
<a name="l01791"></a><a class="code" href="structptlrpc__service__part.html#aea613ac08a7dc84e671b4a260eed2765">01791</a>         wait_queue_head_t               <a class="code" href="structptlrpc__service__part.html#aea613ac08a7dc84e671b4a260eed2765" title="all threads sleep on this.">scp_waitq</a>;
<a name="l01792"></a>01792 
<a name="l01794"></a><a class="code" href="structptlrpc__service__part.html#a73331d554c2adc1cd1b47d6949cee7b4">01794</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service__part.html#a73331d554c2adc1cd1b47d6949cee7b4" title="request history">scp_hist_reqs</a>;
<a name="l01796"></a><a class="code" href="structptlrpc__service__part.html#aa72950e08d334ab8f1964a2640971efd">01796</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service__part.html#aa72950e08d334ab8f1964a2640971efd" title="request buffer history">scp_hist_rqbds</a>;
<a name="l01798"></a><a class="code" href="structptlrpc__service__part.html#a46f749b9c04d8a939db8e29cbadadb0f">01798</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#a46f749b9c04d8a939db8e29cbadadb0f" title="# request buffers in history">scp_hist_nrqbds</a>;
<a name="l01800"></a><a class="code" href="structptlrpc__service__part.html#a9331a053ab8db12d43cfc74d75043f4e">01800</a>         __u64                           <a class="code" href="structptlrpc__service__part.html#a9331a053ab8db12d43cfc74d75043f4e" title="sequence number for request">scp_hist_seq</a>;
<a name="l01802"></a><a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a">01802</a>         __u64                           <a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a" title="highest seq culled from history">scp_hist_seq_culled</a>;
<a name="l01803"></a>01803 
<a name="l01808"></a><a class="code" href="structptlrpc__service__part.html#aa728eb6851d386b9eee3fd84ff1d37e5">01808</a>         spinlock_t                      scp_req_lock <a class="code" href="structptlrpc__service__part.html#a45f53648b1a614576a8044aa875fa4cc" title="back reference to owner">__cfs_cacheline_aligned</a>;
<a name="l01811"></a><a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65">01811</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a>;
<a name="l01813"></a><a class="code" href="structptlrpc__service__part.html#a5cb3e1be6fad443994888bc086aa5283">01813</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#a5cb3e1be6fad443994888bc086aa5283" title="# HPreqs being served">scp_nhreqs_active</a>;
<a name="l01815"></a><a class="code" href="structptlrpc__service__part.html#af8d242d89a56c88d4522319d5ec82b94">01815</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__service__part.html#af8d242d89a56c88d4522319d5ec82b94" title="# hp requests handled">scp_hreq_count</a>;
<a name="l01816"></a>01816 
<a name="l01818"></a><a class="code" href="structptlrpc__service__part.html#aaf079ff0824776d6cbf221ce0a736d4e">01818</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs.html" title="NRS head.">ptlrpc_nrs</a>               <a class="code" href="structptlrpc__service__part.html#aaf079ff0824776d6cbf221ce0a736d4e" title="NRS head for regular requests.">scp_nrs_reg</a>;
<a name="l01821"></a><a class="code" href="structptlrpc__service__part.html#a2daee35dee137743332c42d1ba3eaea1">01821</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs.html" title="NRS head.">ptlrpc_nrs</a>              *<a class="code" href="structptlrpc__service__part.html#a2daee35dee137743332c42d1ba3eaea1" title="NRS head for HP requests; this is only valid for services that can handle HP requests...">scp_nrs_hp</a>;
<a name="l01822"></a>01822 
<a name="l01829"></a><a class="code" href="structptlrpc__service__part.html#a690c0b60917bb43cf55d824846572969">01829</a>         spinlock_t                      scp_at_lock <a class="code" href="structptlrpc__service__part.html#a45f53648b1a614576a8044aa875fa4cc" title="back reference to owner">__cfs_cacheline_aligned</a>;
<a name="l01831"></a><a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754">01831</a>         <span class="keyword">struct </span><a class="code" href="structadaptive__timeout.html">adaptive_timeout</a>         <a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754" title="estimated rpc service time">scp_at_estimate</a>;
<a name="l01833"></a><a class="code" href="structptlrpc__service__part.html#aba4a06d005f80a1ffb87884f00b68698">01833</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__at__array.html">ptlrpc_at_array</a>          <a class="code" href="structptlrpc__service__part.html#aba4a06d005f80a1ffb87884f00b68698" title="reqs waiting for replies">scp_at_array</a>;
<a name="l01835"></a><a class="code" href="structptlrpc__service__part.html#ac1e4c68a5aa6d83f2e5441ea05fe9d52">01835</a>         <span class="keyword">struct </span>timer_list               <a class="code" href="structptlrpc__service__part.html#ac1e4c68a5aa6d83f2e5441ea05fe9d52" title="early reply timer">scp_at_timer</a>;
<a name="l01837"></a><a class="code" href="structptlrpc__service__part.html#aa705fe1ad3fe28ba1b44a3ea327e185f">01837</a>         cfs_time_t                      <a class="code" href="structptlrpc__service__part.html#aa705fe1ad3fe28ba1b44a3ea327e185f" title="debug">scp_at_checktime</a>;
<a name="l01839"></a><a class="code" href="structptlrpc__service__part.html#af1d7d89389261e865e0333f652c77b22">01839</a>         <span class="keywordtype">unsigned</span>                        <a class="code" href="structptlrpc__service__part.html#af1d7d89389261e865e0333f652c77b22" title="check early replies">scp_at_check</a>;
<a name="l01846"></a><a class="code" href="structptlrpc__service__part.html#aa25cfa93e5fe2aec6d68558d70e03b69">01846</a>         spinlock_t                      scp_rep_lock <a class="code" href="structptlrpc__service__part.html#a45f53648b1a614576a8044aa875fa4cc" title="back reference to owner">__cfs_cacheline_aligned</a>;
<a name="l01848"></a><a class="code" href="structptlrpc__service__part.html#a38155a97f15fe794ff8720e2f8bcf249">01848</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service__part.html#a38155a97f15fe794ff8720e2f8bcf249" title="all the active replies">scp_rep_active</a>;
<a name="l01850"></a><a class="code" href="structptlrpc__service__part.html#a1ba1dd17ce94daf0c4b82611d2203b77">01850</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                <a class="code" href="structptlrpc__service__part.html#a1ba1dd17ce94daf0c4b82611d2203b77" title="List of free reply_states.">scp_rep_idle</a>;
<a name="l01852"></a><a class="code" href="structptlrpc__service__part.html#a2053b8073689ec3cedd16a7095656a13">01852</a>         wait_queue_head_t               <a class="code" href="structptlrpc__service__part.html#a2053b8073689ec3cedd16a7095656a13" title="waitq to run, when adding stuff to srv_free_rs_list">scp_rep_waitq</a>;
<a name="l01854"></a><a class="code" href="structptlrpc__service__part.html#a53b120d0b76021b70f62730a7fb490fe">01854</a>         atomic_t                        <a class="code" href="structptlrpc__service__part.html#a53b120d0b76021b70f62730a7fb490fe" title="# &amp;#39;difficult&amp;#39; replies">scp_nreps_difficult</a>;
<a name="l01855"></a>01855 };
<a name="l01856"></a>01856 
<a name="l01857"></a>01857 <span class="preprocessor">#define ptlrpc_service_for_each_part(part, i, svc)                      \</span>
<a name="l01858"></a>01858 <span class="preprocessor">        for (i = 0;                                                     \</span>
<a name="l01859"></a>01859 <span class="preprocessor">             i &lt; (svc)-&gt;srv_ncpts &amp;&amp;                                    \</span>
<a name="l01860"></a>01860 <span class="preprocessor">             (svc)-&gt;srv_parts != NULL &amp;&amp;                                \</span>
<a name="l01861"></a>01861 <span class="preprocessor">             ((part) = (svc)-&gt;srv_parts[i]) != NULL; i++)</span>
<a name="l01862"></a>01862 <span class="preprocessor"></span>
<a name="l01866"></a><a class="code" href="structptlrpcd__ctl.html">01866</a> <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> {
<a name="l01870"></a><a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64">01870</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                   <a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>;
<a name="l01874"></a><a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3">01874</a>         spinlock_t                      <a class="code" href="structptlrpcd__ctl.html#aa58e7a9f6b9360c8dea93ae0780187f3" title="Thread lock protecting structure fields.">pc_lock</a>;
<a name="l01878"></a><a class="code" href="structptlrpcd__ctl.html#a2f5b4f907e1a3cf5805be6a4e83c434c">01878</a>         <span class="keyword">struct </span>completion               <a class="code" href="structptlrpcd__ctl.html#a2f5b4f907e1a3cf5805be6a4e83c434c" title="Start completion.">pc_starting</a>;
<a name="l01882"></a><a class="code" href="structptlrpcd__ctl.html#a2db10d4650ee83958fb147906b6fce82">01882</a>         <span class="keyword">struct </span>completion               <a class="code" href="structptlrpcd__ctl.html#a2db10d4650ee83958fb147906b6fce82" title="Stop completion.">pc_finishing</a>;
<a name="l01886"></a><a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c">01886</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a>       *<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>;
<a name="l01890"></a><a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc">01890</a>         <span class="keywordtype">char</span>                            <a class="code" href="structptlrpcd__ctl.html#a454e986f73afca473f47fd2a4b88e8bc" title="Thread name used in kthread_run().">pc_name</a>[16];
<a name="l01894"></a><a class="code" href="structptlrpcd__ctl.html#aaa5b4e6a52cdd4a27ffd97bcd3c5e92c">01894</a>         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>                   <a class="code" href="structptlrpcd__ctl.html#aaa5b4e6a52cdd4a27ffd97bcd3c5e92c" title="Environment for request interpreters to run in.">pc_env</a>;
<a name="l01898"></a><a class="code" href="structptlrpcd__ctl.html#acffe95b63858d215c0bfb98dc516b16b">01898</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpcd__ctl.html#acffe95b63858d215c0bfb98dc516b16b" title="CPT the thread is bound on.">pc_cpt</a>;
<a name="l01902"></a><a class="code" href="structptlrpcd__ctl.html#a30f77aca89f1a762790e589793d06a16">01902</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpcd__ctl.html#a30f77aca89f1a762790e589793d06a16" title="Index of ptlrpcd thread in the array.">pc_index</a>;
<a name="l01906"></a><a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80">01906</a>         <span class="keyword">struct </span><a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a>              **<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a>;
<a name="l01910"></a><a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c">01910</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a>;
<a name="l01914"></a><a class="code" href="structptlrpcd__ctl.html#a018fce2ef0c3cd9dfa971ddb4aaf4891">01914</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpcd__ctl.html#a018fce2ef0c3cd9dfa971ddb4aaf4891" title="Record the partner index to be processed next.">pc_cursor</a>;
<a name="l01918"></a><a class="code" href="structptlrpcd__ctl.html#a191cb4d4f68f14efd9c9661ff5caad0c">01918</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpcd__ctl.html#a191cb4d4f68f14efd9c9661ff5caad0c" title="Error code if the thread failed to fully start.">pc_error</a>;
<a name="l01919"></a>01919 };
<a name="l01920"></a>01920 
<a name="l01921"></a>01921 <span class="comment">/* Bits for pc_flags */</span>
<a name="l01922"></a><a class="code" href="group__net.html#gaaa41ab709a4804427e6eb05360ebbed4">01922</a> <span class="keyword">enum</span> <a class="code" href="group__net.html#gaaa41ab709a4804427e6eb05360ebbed4">ptlrpcd_ctl_flags</a> {
<a name="l01926"></a><a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c">01926</a>         <a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a895f6bfb71c0ef4b2dccbfad7483ce5c" title="Ptlrpc thread start flag.">LIOD_START</a>       = 1 &lt;&lt; 0,
<a name="l01930"></a><a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c">01930</a>         <a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c" title="Ptlrpc thread stop flag.">LIOD_STOP</a>        = 1 &lt;&lt; 1,
<a name="l01936"></a><a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4ad315ddb8cfd7bec02047607f28de70e2">01936</a>         <a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4ad315ddb8cfd7bec02047607f28de70e2" title="Ptlrpc thread force flag (only stop force so far).">LIOD_FORCE</a>       = 1 &lt;&lt; 2,
<a name="l01940"></a><a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a5a3062cb119fabc0613a8b5dc2e7b75b">01940</a>         <a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4a5a3062cb119fabc0613a8b5dc2e7b75b" title="This is a recovery ptlrpc thread.">LIOD_RECOVERY</a>    = 1 &lt;&lt; 3,
<a name="l01941"></a>01941 };
<a name="l01942"></a>01942 
<a name="l01956"></a>01956 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> nrs_policy_compat_all(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc,
<a name="l01957"></a>01957                                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__pol__desc.html" title="NRS policy registering descriptor.">ptlrpc_nrs_pol_desc</a> *desc)
<a name="l01958"></a>01958 {
<a name="l01959"></a>01959         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01960"></a>01960 }
<a name="l01961"></a>01961 
<a name="l01975"></a>01975 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> nrs_policy_compat_one(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc,
<a name="l01976"></a>01976                                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__pol__desc.html" title="NRS policy registering descriptor.">ptlrpc_nrs_pol_desc</a> *desc)
<a name="l01977"></a>01977 {
<a name="l01978"></a>01978         LASSERT(desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#aa6f674582366294297bfed84b1b14581" title="Set for policies that are compatible with only one PTLRPC service.">pd_compat_svc_name</a> != NULL);
<a name="l01979"></a>01979         <span class="keywordflow">return</span> strcmp(svc-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#aa6f674582366294297bfed84b1b14581" title="Set for policies that are compatible with only one PTLRPC service.">pd_compat_svc_name</a>) == 0;
<a name="l01980"></a>01980 }
<a name="l01981"></a>01981 
<a name="l01984"></a>01984 <span class="comment">/* ptlrpc/events.c */</span>
<a name="l01985"></a>01985 <span class="keyword">extern</span> <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_eq_t</a> ptlrpc_eq_h;
<a name="l01986"></a>01986 <span class="keyword">extern</span> <span class="keywordtype">int</span> ptlrpc_uuid_to_peer(<span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid,
<a name="l01987"></a>01987                                <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> *peer, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> *<span class="keyword">self</span>);
<a name="l01993"></a>01993 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga888caf60135e2eecdef05fce1b2de9b6" title="These callbacks are invoked by LNet when something happened to underlying buffer...">request_out_callback</a>(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a> *ev);
<a name="l01994"></a>01994 <span class="keyword">extern</span> <span class="keywordtype">void</span> reply_in_callback(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a> *ev);
<a name="l01995"></a>01995 <span class="keyword">extern</span> <span class="keywordtype">void</span> client_bulk_callback(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a> *ev);
<a name="l01996"></a>01996 <span class="keyword">extern</span> <span class="keywordtype">void</span> request_in_callback(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a> *ev);
<a name="l01997"></a>01997 <span class="keyword">extern</span> <span class="keywordtype">void</span> reply_out_callback(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a> *ev);
<a name="l01998"></a>01998 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l01999"></a>01999 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">void</span> server_bulk_callback(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a> *ev);
<a name="l02000"></a>02000 <span class="preprocessor">#endif</span>
<a name="l02001"></a>02001 <span class="preprocessor"></span>
<a name="l02003"></a>02003 <span class="comment">/* ptlrpc/connection.c */</span>
<a name="l02004"></a>02004 <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> *ptlrpc_connection_get(<a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> peer,
<a name="l02005"></a>02005                                                 <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> <span class="keyword">self</span>,
<a name="l02006"></a>02006                                                 <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid);
<a name="l02007"></a>02007 <span class="keywordtype">int</span> ptlrpc_connection_put(<span class="keyword">struct</span> <a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> *c);
<a name="l02008"></a>02008 <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> *ptlrpc_connection_addref(<span class="keyword">struct</span> <a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> *);
<a name="l02009"></a>02009 <span class="keywordtype">int</span> ptlrpc_connection_init(<span class="keywordtype">void</span>);
<a name="l02010"></a>02010 <span class="keywordtype">void</span> ptlrpc_connection_fini(<span class="keywordtype">void</span>);
<a name="l02011"></a>02011 <span class="keyword">extern</span> <a class="code" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd" title="ID of a process in a node.">lnet_pid_t</a> ptl_get_pid(<span class="keywordtype">void</span>);
<a name="l02012"></a>02012 
<a name="l02013"></a>02013 <span class="comment">/* ptlrpc/niobuf.c */</span>
<a name="l02018"></a>02018 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02019"></a>02019 <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *ptlrpc_prep_bulk_exp(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02020"></a>02020                                               <span class="keywordtype">unsigned</span> nfrags, <span class="keywordtype">unsigned</span> max_brw,
<a name="l02021"></a>02021                                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> type,
<a name="l02022"></a>02022                                               <span class="keywordtype">unsigned</span> portal,
<a name="l02023"></a>02023                                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a>
<a name="l02024"></a>02024                                                 *ops);
<a name="l02025"></a>02025 <span class="keywordtype">int</span> ptlrpc_start_bulk_transfer(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l02026"></a>02026 <span class="keywordtype">void</span> ptlrpc_abort_bulk(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l02027"></a>02027 
<a name="l02028"></a>02028 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_server_bulk_active(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l02029"></a>02029 {
<a name="l02030"></a>02030         <span class="keywordtype">int</span> rc;
<a name="l02031"></a>02031 
<a name="l02032"></a>02032         LASSERT(desc != NULL);
<a name="l02033"></a>02033 
<a name="l02034"></a>02034         spin_lock(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>);
<a name="l02035"></a>02035         rc = desc-&gt;bd_md_count;
<a name="l02036"></a>02036         spin_unlock(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>);
<a name="l02037"></a>02037         <span class="keywordflow">return</span> rc;
<a name="l02038"></a>02038 }
<a name="l02039"></a>02039 <span class="preprocessor">#endif</span>
<a name="l02040"></a>02040 <span class="preprocessor"></span>
<a name="l02041"></a>02041 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Actual interfacing with LNet to put/get/register/unregister stuff.">ptlrpc_register_bulk</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02042"></a>02042 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> async);
<a name="l02043"></a>02043 
<a name="l02044"></a>02044 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_client_bulk_active(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02045"></a>02045 {
<a name="l02046"></a>02046         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc;
<a name="l02047"></a>02047         <span class="keywordtype">int</span>                      rc;
<a name="l02048"></a>02048 
<a name="l02049"></a>02049         LASSERT(req != NULL);
<a name="l02050"></a>02050         desc = req-&gt;rq_bulk;
<a name="l02051"></a>02051 
<a name="l02052"></a>02052         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_BULK_UNLINK) &amp;&amp;
<a name="l02053"></a>02053             req-&gt;rq_bulk_deadline &gt; cfs_time_current_sec())
<a name="l02054"></a>02054                 <span class="keywordflow">return</span> 1;
<a name="l02055"></a>02055 
<a name="l02056"></a>02056         <span class="keywordflow">if</span> (!desc)
<a name="l02057"></a>02057                 <span class="keywordflow">return</span> 0;
<a name="l02058"></a>02058 
<a name="l02059"></a>02059         spin_lock(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>);
<a name="l02060"></a>02060         rc = desc-&gt;bd_md_count;
<a name="l02061"></a>02061         spin_unlock(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>);
<a name="l02062"></a>02062         <span class="keywordflow">return</span> rc;
<a name="l02063"></a>02063 }
<a name="l02064"></a>02064 
<a name="l02065"></a>02065 <span class="preprocessor">#define PTLRPC_REPLY_MAYBE_DIFFICULT 0x01</span>
<a name="l02066"></a>02066 <span class="preprocessor"></span><span class="preprocessor">#define PTLRPC_REPLY_EARLY           0x02</span>
<a name="l02067"></a>02067 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="group__net.html#ga563a5d436790759334ba2a51f0dce12e" title="Send request reply from request req reply buffer.">ptlrpc_send_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> flags);
<a name="l02068"></a>02068 <span class="keywordtype">int</span> ptlrpc_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02069"></a>02069 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gac2a8de93c376592370228d10fd94761d" title="For request req send an error reply back.">ptlrpc_send_error</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> difficult);
<a name="l02070"></a>02070 <span class="keywordtype">int</span> ptlrpc_error(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02071"></a>02071 <span class="keywordtype">int</span> ptlrpc_at_get_net_latency(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02072"></a>02072 <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request.">ptl_send_rpc</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request, <span class="keywordtype">int</span> noreply);
<a name="l02073"></a>02073 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gaf7557fc8aa34bbf889ee11612ece2315" title="Register request buffer descriptor for request receiving.">ptlrpc_register_rqbd</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *rqbd);
<a name="l02076"></a>02076 <span class="comment">/* ptlrpc/client.c */</span>
<a name="l02082"></a>02082 <span class="keywordtype">void</span> <a class="code" href="group__net.html#gacab48d448ba12ade8093383e054814cc" title="Client-side portals API.">ptlrpc_request_committed</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> force);
<a name="l02083"></a>02083 
<a name="l02084"></a>02084 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga8274d1c6229aa8679c30551cc4768778" title="Initialize passed in client structure cl.">ptlrpc_init_client</a>(<span class="keywordtype">int</span> req_portal, <span class="keywordtype">int</span> rep_portal, <span class="keywordtype">char</span> *name,
<a name="l02085"></a>02085                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__client.html" title="Client definition for PortalRPC.">ptlrpc_client</a> *);
<a name="l02086"></a>02086 <span class="keywordtype">void</span> ptlrpc_cleanup_client(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02087"></a>02087 <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> *<a class="code" href="group__net.html#gac16251a340153c3059c8727b8b39d400" title="Return PortalRPC connection for remore uud uuid.">ptlrpc_uuid_to_connection</a>(<span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid);
<a name="l02088"></a>02088 
<a name="l02089"></a>02089 <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes.">ptlrpc_queue_wait</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02090"></a>02090 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gafd4a53f20e90893d5ae03f1996ecb2fc" title="Prepares and queues request for replay.">ptlrpc_replay_req</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02091"></a>02091 <span class="keywordtype">void</span> ptlrpc_restart_req(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02092"></a>02092 <span class="keywordtype">void</span> <a class="code" href="group__net.html#gaebf74d120543fbad3a68316dc1a5c97c" title="Aborts all in-flight request on import imp sending and delayed lists.">ptlrpc_abort_inflight</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02093"></a>02093 <span class="keywordtype">void</span> ptlrpc_cleanup_imp(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02094"></a>02094 <span class="keywordtype">void</span> <a class="code" href="group__net.html#gacf9a01538061117dbbb8787fb7b81b77" title="Abort all uncompleted requests in request set set.">ptlrpc_abort_set</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>);
<a name="l02095"></a>02095 
<a name="l02096"></a>02096 <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT.">ptlrpc_prep_set</a>(<span class="keywordtype">void</span>);
<a name="l02097"></a>02097 <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<a class="code" href="group__net.html#ga2d9ff5fa185af154f37c364df7b5c4cc" title="Allocate and initialize new request set structure with flow control extension.">ptlrpc_prep_fcset</a>(<span class="keywordtype">int</span> max, set_producer_func func,
<a name="l02098"></a>02098                                              <span class="keywordtype">void</span> *arg);
<a name="l02099"></a>02099 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gad92b893a7fb440c2f0eed3ce0e79f6af" title="Add a callback function fn to the set.">ptlrpc_set_add_cb</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>,
<a name="l02100"></a>02100                       set_interpreter_func fn, <span class="keywordtype">void</span> *data);
<a name="l02101"></a>02101 <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies...">ptlrpc_check_set</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>);
<a name="l02102"></a>02102 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set...">ptlrpc_set_wait</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *);
<a name="l02103"></a>02103 <span class="keywordtype">void</span> <a class="code" href="group__net.html#gaf50ebcc46ea5f7316c23362915fd5ce7" title="Sets rq_intr flag in req under spinlock.">ptlrpc_mark_interrupted</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02104"></a>02104 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set...">ptlrpc_set_destroy</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *);
<a name="l02105"></a>02105 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set.">ptlrpc_set_add_req</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *);
<a name="l02106"></a>02106 
<a name="l02107"></a>02107 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga1b3e3fff15de45e0042c071e5bb806f4" title="Wind down request pool pool.">ptlrpc_free_rq_pool</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *pool);
<a name="l02108"></a>02108 <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga07d19311543ebd57e6514926b08ddd08" title="Allocates, initializes and adds num_rq requests to the pool pool.">ptlrpc_add_rqs_to_pool</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *pool, <span class="keywordtype">int</span> num_rq);
<a name="l02109"></a>02109 
<a name="l02110"></a>02110 <span class="keyword">struct </span><a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *
<a name="l02111"></a>02111 <a class="code" href="group__net.html#ga297dfeefaa23e0c6265ca8c0ad81e818" title="Create and initialize new request pool with given attributes: num_rq - initial number...">ptlrpc_init_rq_pool</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>,
<a name="l02112"></a>02112                     <span class="keywordtype">int</span> (*populate_pool)(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *, <span class="keywordtype">int</span>));
<a name="l02113"></a>02113 
<a name="l02114"></a>02114 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e.">ptlrpc_at_set_req_timeout</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02115"></a>02115 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *<a class="code" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure...">ptlrpc_request_alloc</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l02116"></a>02116                                             <span class="keyword">const</span> <span class="keyword">struct</span> req_format *format);
<a name="l02117"></a>02117 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *<a class="code" href="group__net.html#ga0aa209ecf9cb734df89fec89a61d00a1" title="Allocate new request structure for import imp from pool pool and initialize its buffer...">ptlrpc_request_alloc_pool</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l02118"></a>02118                                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *,
<a name="l02119"></a>02119                                             <span class="keyword">const</span> <span class="keyword">struct</span> req_format *format);
<a name="l02120"></a>02120 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure.">ptlrpc_request_free</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request);
<a name="l02121"></a>02121 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps...">ptlrpc_request_pack</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request,
<a name="l02122"></a>02122                         __u32 version, <span class="keywordtype">int</span> opcode);
<a name="l02123"></a>02123 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *<a class="code" href="group__net.html#gac578ffdc47c9c2141c34c4798a55cce4" title="Allocate new request for operatione opcode and immediatelly pack it for network transfer...">ptlrpc_request_alloc_pack</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l02124"></a>02124                                                 <span class="keyword">const</span> <span class="keyword">struct</span> req_format *format,
<a name="l02125"></a>02125                                                 __u32 version, <span class="keywordtype">int</span> opcode);
<a name="l02126"></a>02126 <span class="keywordtype">int</span> ptlrpc_request_bufs_pack(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request,
<a name="l02127"></a>02127                              __u32 version, <span class="keywordtype">int</span> opcode, <span class="keywordtype">char</span> **bufs,
<a name="l02128"></a>02128                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx);
<a name="l02129"></a>02129 <span class="keywordtype">void</span> <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request);
<a name="l02130"></a>02130 <span class="keywordtype">void</span> <a class="code" href="group__net.html#gac030d75f1b39211b69e4974fc328669d" title="Drop one request reference.">ptlrpc_req_finished_with_imp_lock</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request);
<a name="l02131"></a>02131 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *<a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02132"></a>02132 <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *<a class="code" href="group__net.html#ga42ea756e2d84491e4b6ea2e53616d7cb" title="Prepare bulk descriptor for specified outgoing request req that can fit nfrags *...">ptlrpc_prep_bulk_imp</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02133"></a>02133                                               <span class="keywordtype">unsigned</span> nfrags, <span class="keywordtype">unsigned</span> max_brw,
<a name="l02134"></a>02134                                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> type,
<a name="l02135"></a>02135                                               <span class="keywordtype">unsigned</span> portal,
<a name="l02136"></a>02136                                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a>
<a name="l02137"></a>02137                                                 *ops);
<a name="l02138"></a>02138 
<a name="l02139"></a>02139 <span class="keywordtype">int</span> ptlrpc_prep_bulk_frag(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l02140"></a>02140                           <span class="keywordtype">void</span> *frag, <span class="keywordtype">int</span> len);
<a name="l02141"></a>02141 <span class="keywordtype">void</span> __ptlrpc_prep_bulk_page(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l02142"></a>02142                              <span class="keyword">struct</span> page *page, <span class="keywordtype">int</span> pageoffset, <span class="keywordtype">int</span> len,
<a name="l02143"></a>02143                              <span class="keywordtype">int</span> pin);
<a name="l02144"></a>02144 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ptlrpc_prep_bulk_page_pin(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l02145"></a>02145                                              <span class="keyword">struct</span> page *page, <span class="keywordtype">int</span> pageoffset,
<a name="l02146"></a>02146                                              <span class="keywordtype">int</span> len)
<a name="l02147"></a>02147 {
<a name="l02148"></a>02148         __ptlrpc_prep_bulk_page(desc, page, pageoffset, len, 1);
<a name="l02149"></a>02149 }
<a name="l02150"></a>02150 
<a name="l02151"></a>02151 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ptlrpc_prep_bulk_page_nopin(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l02152"></a>02152                                                <span class="keyword">struct</span> page *page, <span class="keywordtype">int</span> pageoffset,
<a name="l02153"></a>02153                                                <span class="keywordtype">int</span> len)
<a name="l02154"></a>02154 {
<a name="l02155"></a>02155         __ptlrpc_prep_bulk_page(desc, page, pageoffset, len, 0);
<a name="l02156"></a>02156 }
<a name="l02157"></a>02157 
<a name="l02158"></a>02158 <span class="keywordtype">void</span> ptlrpc_free_bulk(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *bulk);
<a name="l02159"></a>02159 
<a name="l02160"></a>02160 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ptlrpc_release_bulk_page_pin(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l02161"></a>02161 {
<a name="l02162"></a>02162         <span class="keywordtype">int</span> i;
<a name="l02163"></a>02163 
<a name="l02164"></a>02164         <span class="keywordflow">for</span> (i = 0; i &lt; desc-&gt;bd_iov_count ; i++)
<a name="l02165"></a>02165                 page_cache_release(BD_GET_KIOV(desc, i).kiov_page);
<a name="l02166"></a>02166 }
<a name="l02167"></a>02167 
<a name="l02168"></a>02168 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ptlrpc_release_bulk_noop(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l02169"></a>02169 {
<a name="l02170"></a>02170 }
<a name="l02171"></a>02171 
<a name="l02172"></a>02172 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga74e4777d34c1f5305c03de9d365a6268" title="Add a request to import replay_list.">ptlrpc_retain_replayable_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02173"></a>02173                                       <span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02174"></a>02174 __u64 <a class="code" href="group__net.html#gaf2442fe17f822101d45881701da27f40" title="Increase xid and returns resulting new value to the caller.">ptlrpc_next_xid</a>(<span class="keywordtype">void</span>);
<a name="l02175"></a>02175 __u64 <a class="code" href="group__net.html#gac08edd7ffd185c9f01d010fa5da16fd3" title="Get a glimpse at what next xid value might have been.">ptlrpc_sample_next_xid</a>(<span class="keywordtype">void</span>);
<a name="l02176"></a>02176 __u64 <a class="code" href="group__net.html#ga283d8a396288df3e34efd571d9d30018" title="Returns xid of a request.">ptlrpc_req_xid</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request);
<a name="l02177"></a>02177 
<a name="l02178"></a>02178 <span class="comment">/* Set of routines to run a function in ptlrpcd context */</span>
<a name="l02179"></a>02179 <span class="keywordtype">void</span> *<a class="code" href="group__net.html#ga56ad09ae5c5df58c7555e7299dc02108" title="Create a work for ptlrpc.">ptlrpcd_alloc_work</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l02180"></a>02180                          <span class="keywordtype">int</span> (*cb)(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *, <span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *data);
<a name="l02181"></a>02181 <span class="keywordtype">void</span> ptlrpcd_destroy_work(<span class="keywordtype">void</span> *handler);
<a name="l02182"></a>02182 <span class="keywordtype">int</span> ptlrpcd_queue_work(<span class="keywordtype">void</span> *handler);
<a name="l02183"></a>02183 
<a name="l02185"></a><a class="code" href="structptlrpc__service__buf__conf.html">02185</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__service__buf__conf.html">ptlrpc_service_buf_conf</a> {
<a name="l02186"></a>02186         <span class="comment">/* nbufs is buffers # to allocate when growing the pool */</span>
<a name="l02187"></a>02187         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    bc_nbufs;
<a name="l02188"></a>02188         <span class="comment">/* buffer size to post */</span>
<a name="l02189"></a>02189         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    bc_buf_size;
<a name="l02190"></a>02190         <span class="comment">/* portal to listed for requests on */</span>
<a name="l02191"></a>02191         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    bc_req_portal;
<a name="l02192"></a>02192         <span class="comment">/* portal of where to send replies to */</span>
<a name="l02193"></a>02193         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    bc_rep_portal;
<a name="l02194"></a>02194         <span class="comment">/* maximum request size to be accepted for this service */</span>
<a name="l02195"></a>02195         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    bc_req_max_size;
<a name="l02196"></a>02196         <span class="comment">/* maximum reply size this service can ever send */</span>
<a name="l02197"></a>02197         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    bc_rep_max_size;
<a name="l02198"></a>02198 };
<a name="l02199"></a>02199 
<a name="l02200"></a><a class="code" href="structptlrpc__service__thr__conf.html">02200</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__service__thr__conf.html">ptlrpc_service_thr_conf</a> {
<a name="l02201"></a>02201         <span class="comment">/* threadname should be 8 characters or less - 6 will be added on */</span>
<a name="l02202"></a>02202         <span class="keywordtype">char</span>                            *tc_thr_name;
<a name="l02203"></a>02203         <span class="comment">/* threads increasing factor for each CPU */</span>
<a name="l02204"></a>02204         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    tc_thr_factor;
<a name="l02205"></a>02205         <span class="comment">/* service threads # to start on each partition while initializing */</span>
<a name="l02206"></a>02206         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    tc_nthrs_init;
<a name="l02207"></a>02207         <span class="comment">/*</span>
<a name="l02208"></a>02208 <span class="comment">         * low water of threads # upper-limit on each partition while running,</span>
<a name="l02209"></a>02209 <span class="comment">         * service availability may be impacted if threads number is lower</span>
<a name="l02210"></a>02210 <span class="comment">         * than this value. It can be ZERO if the service doesn&apos;t require</span>
<a name="l02211"></a>02211 <span class="comment">         * CPU affinity or there is only one partition.</span>
<a name="l02212"></a>02212 <span class="comment">         */</span>
<a name="l02213"></a>02213         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    tc_nthrs_base;
<a name="l02214"></a>02214         <span class="comment">/* &quot;soft&quot; limit for total threads number */</span>
<a name="l02215"></a>02215         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    tc_nthrs_max;
<a name="l02216"></a>02216         <span class="comment">/* user specified threads number, it will be validated due to</span>
<a name="l02217"></a>02217 <span class="comment">         * other members of this structure. */</span>
<a name="l02218"></a>02218         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    tc_nthrs_user;
<a name="l02219"></a>02219         <span class="comment">/* set NUMA node affinity for service threads */</span>
<a name="l02220"></a>02220         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    tc_cpu_affinity;
<a name="l02221"></a>02221         <span class="comment">/* Tags for lu_context associated with service thread */</span>
<a name="l02222"></a>02222         __u32                           tc_ctx_tags;
<a name="l02223"></a>02223 };
<a name="l02224"></a>02224 
<a name="l02225"></a><a class="code" href="structptlrpc__service__cpt__conf.html">02225</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__service__cpt__conf.html">ptlrpc_service_cpt_conf</a> {
<a name="l02226"></a>02226         <span class="keyword">struct </span><a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>            *cc_cptable;
<a name="l02227"></a>02227         <span class="comment">/* string pattern to describe CPTs for a service */</span>
<a name="l02228"></a>02228         <span class="keywordtype">char</span>                            *cc_pattern;
<a name="l02229"></a>02229 };
<a name="l02230"></a>02230 
<a name="l02231"></a><a class="code" href="structptlrpc__service__conf.html">02231</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__service__conf.html">ptlrpc_service_conf</a> {
<a name="l02232"></a>02232         <span class="comment">/* service name */</span>
<a name="l02233"></a>02233         <span class="keywordtype">char</span>                            *psc_name;
<a name="l02234"></a>02234         <span class="comment">/* soft watchdog timeout multiplifier to print stuck service traces */</span>
<a name="l02235"></a>02235         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    psc_watchdog_factor;
<a name="l02236"></a>02236         <span class="comment">/* buffer information */</span>
<a name="l02237"></a>02237         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__buf__conf.html">ptlrpc_service_buf_conf</a>  psc_buf;
<a name="l02238"></a>02238         <span class="comment">/* thread information */</span>
<a name="l02239"></a>02239         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__thr__conf.html">ptlrpc_service_thr_conf</a>  psc_thr;
<a name="l02240"></a>02240         <span class="comment">/* CPU partition information */</span>
<a name="l02241"></a>02241         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__cpt__conf.html">ptlrpc_service_cpt_conf</a>  psc_cpt;
<a name="l02242"></a>02242         <span class="comment">/* function table */</span>
<a name="l02243"></a>02243         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__ops.html">ptlrpc_service_ops</a>       psc_ops;
<a name="l02244"></a>02244 };
<a name="l02245"></a>02245 
<a name="l02246"></a>02246 <span class="comment">/* ptlrpc/service.c */</span>
<a name="l02253"></a>02253 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga686ce1d3f4b5ce9b59e59136cb6b265c" title="Server-side services API.">ptlrpc_save_lock</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02254"></a>02254                       <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lock, <span class="keywordtype">int</span> mode, <span class="keywordtype">int</span> no_ack);
<a name="l02255"></a>02255 <span class="keywordtype">void</span> ptlrpc_commit_replies(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp);
<a name="l02256"></a>02256 <span class="keywordtype">void</span> <a class="code" href="group__net.html#gac133162c229195f6e9479dd79aac6473" title="Put reply state into a queue for processing because we received ACK from the client...">ptlrpc_dispatch_difficult_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs);
<a name="l02257"></a>02257 <span class="keywordtype">void</span> ptlrpc_schedule_difficult_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs);
<a name="l02258"></a>02258 <span class="keywordtype">int</span> ptlrpc_hpreq_handler(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02259"></a>02259 <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *<a class="code" href="group__net.html#ga13835bf69545de9744051ff7ef02a4c3" title="Initialize service on a given portal.">ptlrpc_register_service</a>(
<a name="l02260"></a>02260                                 <span class="keyword">struct</span> <a class="code" href="structptlrpc__service__conf.html">ptlrpc_service_conf</a> *conf,
<a name="l02261"></a>02261                                 <span class="keyword">struct</span> proc_dir_entry *proc_entry);
<a name="l02262"></a>02262 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga59db7fb30a02fd79e28791330f99fb3c" title="Stops all threads of a particular service svc.">ptlrpc_stop_all_threads</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc);
<a name="l02263"></a>02263 
<a name="l02264"></a>02264 <span class="keywordtype">int</span> ptlrpc_start_threads(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc);
<a name="l02265"></a>02265 <span class="keywordtype">int</span> ptlrpc_unregister_service(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *service);
<a name="l02266"></a>02266 <span class="keywordtype">int</span> liblustre_check_services(<span class="keywordtype">void</span> *arg);
<a name="l02267"></a>02267 <span class="keywordtype">void</span> ptlrpc_daemonize(<span class="keywordtype">char</span> *name);
<a name="l02268"></a>02268 <span class="keywordtype">int</span> ptlrpc_service_health_check(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *);
<a name="l02269"></a>02269 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga45bbc99a8cb3940b830d5ac581cd2f10" title="drop a reference count of the request.">ptlrpc_server_drop_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02270"></a>02270 <span class="keywordtype">void</span> <a class="code" href="group__net.html#gaedae07eef44eef7ce7d1b0cfe437804f" title="Change request export and move hp request from old export to new.">ptlrpc_request_change_export</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02271"></a>02271                                   <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *export);
<a name="l02272"></a>02272 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga3b962a1b6e534a49a4848336555d1d89" title="This function makes sure dead exports are evicted in a timely manner.">ptlrpc_update_export_timer</a>(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp, <span class="keywordtype">long</span> extra_delay);
<a name="l02273"></a>02273 
<a name="l02274"></a>02274 <span class="keywordtype">int</span> ptlrpc_hr_init(<span class="keywordtype">void</span>);
<a name="l02275"></a>02275 <span class="keywordtype">void</span> ptlrpc_hr_fini(<span class="keywordtype">void</span>);
<a name="l02276"></a>02276 
<a name="l02279"></a>02279 <span class="comment">/* ptlrpc/import.c */</span>
<a name="l02284"></a>02284 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gae524031a54066bf23dda2ad572bbcfdf" title="Import API.">ptlrpc_connect_import</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02285"></a>02285 <span class="keywordtype">int</span> ptlrpc_init_import(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02286"></a>02286 <span class="keywordtype">int</span> ptlrpc_disconnect_import(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp, <span class="keywordtype">int</span> noclose);
<a name="l02287"></a>02287 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gae24ff0ea3f19794b41cb4da94ffa9ce2" title="This is the state machine for client-side recovery on import.">ptlrpc_import_recovery_state_machine</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02288"></a>02288 <span class="keywordtype">void</span> deuuidify(<span class="keywordtype">char</span> *uuid, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, <span class="keywordtype">char</span> **uuid_start,
<a name="l02289"></a>02289                <span class="keywordtype">int</span> *uuid_len);
<a name="l02290"></a>02290 <span class="keywordtype">void</span> ptlrpc_import_enter_resend(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02291"></a>02291 <span class="comment">/* ptlrpc/pack_generic.c */</span>
<a name="l02292"></a>02292 <span class="keywordtype">int</span> ptlrpc_reconnect_import(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02300"></a>02300 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gaa22239843a54a1577998de2a44fd8af7" title="ptlrpc msg buffer and swab interface">ptlrpc_buf_need_swab</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keyword">const</span> <span class="keywordtype">int</span> inout,
<a name="l02301"></a>02301                          __u32 index);
<a name="l02302"></a>02302 <span class="keywordtype">void</span> ptlrpc_buf_set_swabbed(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keyword">const</span> <span class="keywordtype">int</span> inout,
<a name="l02303"></a>02303                             __u32 index);
<a name="l02304"></a>02304 <span class="keywordtype">int</span> ptlrpc_unpack_rep_msg(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> len);
<a name="l02305"></a>02305 <span class="keywordtype">int</span> ptlrpc_unpack_req_msg(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> len);
<a name="l02306"></a>02306 
<a name="l02307"></a>02307 <span class="keywordtype">int</span> lustre_msg_check_version(<span class="keyword">struct</span> lustre_msg *msg, __u32 version);
<a name="l02308"></a>02308 <span class="keywordtype">void</span> lustre_init_msg_v2(<span class="keyword">struct</span> <a class="code" href="structlustre__msg__v2.html">lustre_msg_v2</a> *msg, <span class="keywordtype">int</span> count, __u32 *lens,
<a name="l02309"></a>02309                         <span class="keywordtype">char</span> **bufs);
<a name="l02310"></a>02310 <span class="keywordtype">int</span> lustre_pack_request(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *, __u32 magic, <span class="keywordtype">int</span> count,
<a name="l02311"></a>02311                         __u32 *lens, <span class="keywordtype">char</span> **bufs);
<a name="l02312"></a>02312 <span class="keywordtype">int</span> lustre_pack_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *, <span class="keywordtype">int</span> count, __u32 *lens,
<a name="l02313"></a>02313                       <span class="keywordtype">char</span> **bufs);
<a name="l02314"></a>02314 <span class="keywordtype">int</span> lustre_pack_reply_v2(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> count,
<a name="l02315"></a>02315                          __u32 *lens, <span class="keywordtype">char</span> **bufs, <span class="keywordtype">int</span> flags);
<a name="l02316"></a>02316 <span class="preprocessor">#define LPRFL_EARLY_REPLY 1</span>
<a name="l02317"></a>02317 <span class="preprocessor"></span><span class="keywordtype">int</span> lustre_pack_reply_flags(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *, <span class="keywordtype">int</span> count, __u32 *lens,
<a name="l02318"></a>02318                             <span class="keywordtype">char</span> **bufs, <span class="keywordtype">int</span> flags);
<a name="l02319"></a>02319 <span class="keywordtype">int</span> lustre_shrink_msg(<span class="keyword">struct</span> lustre_msg *msg, <span class="keywordtype">int</span> segment,
<a name="l02320"></a>02320                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newlen, <span class="keywordtype">int</span> move_data);
<a name="l02321"></a>02321 <span class="keywordtype">void</span> lustre_free_reply_state(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs);
<a name="l02322"></a>02322 <span class="keywordtype">int</span> __lustre_unpack_msg(<span class="keyword">struct</span> lustre_msg *m, <span class="keywordtype">int</span> len);
<a name="l02323"></a>02323 __u32 lustre_msg_hdr_size(__u32 magic, __u32 count);
<a name="l02324"></a>02324 __u32 lustre_msg_size(__u32 magic, <span class="keywordtype">int</span> count, __u32 *lengths);
<a name="l02325"></a>02325 __u32 lustre_msg_size_v2(<span class="keywordtype">int</span> count, __u32 *lengths);
<a name="l02326"></a>02326 __u32 lustre_packed_msg_size(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02327"></a>02327 __u32 lustre_msg_early_size(<span class="keywordtype">void</span>);
<a name="l02328"></a>02328 <span class="keywordtype">void</span> *lustre_msg_buf_v2(<span class="keyword">struct</span> <a class="code" href="structlustre__msg__v2.html">lustre_msg_v2</a> *m, __u32 n, __u32 min_size);
<a name="l02329"></a>02329 <span class="keywordtype">void</span> *lustre_msg_buf(<span class="keyword">struct</span> lustre_msg *m, __u32 n, __u32 minlen);
<a name="l02330"></a>02330 __u32 <a class="code" href="group__net.html#ga8ddfe4bfdb34b2159b8281fb3c6e09a4" title="lustre_msg_buflen - return the length of buffer n in message m ">lustre_msg_buflen</a>(<span class="keyword">struct</span> lustre_msg *m, __u32 n);
<a name="l02331"></a>02331 <span class="keywordtype">void</span> lustre_msg_set_buflen(<span class="keyword">struct</span> lustre_msg *m, __u32 n, __u32 len);
<a name="l02332"></a>02332 __u32 lustre_msg_bufcount(<span class="keyword">struct</span> lustre_msg *m);
<a name="l02333"></a>02333 <span class="keywordtype">char</span> *lustre_msg_string(<span class="keyword">struct</span> lustre_msg *m, __u32 n, __u32 max_len);
<a name="l02334"></a>02334 __u32 lustre_msghdr_get_flags(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02335"></a>02335 <span class="keywordtype">void</span> lustre_msghdr_set_flags(<span class="keyword">struct</span> lustre_msg *msg, __u32 flags);
<a name="l02336"></a>02336 __u32 lustre_msg_get_flags(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02337"></a>02337 <span class="keywordtype">void</span> lustre_msg_add_flags(<span class="keyword">struct</span> lustre_msg *msg, __u32 flags);
<a name="l02338"></a>02338 <span class="keywordtype">void</span> lustre_msg_set_flags(<span class="keyword">struct</span> lustre_msg *msg, __u32 flags);
<a name="l02339"></a>02339 <span class="keywordtype">void</span> lustre_msg_clear_flags(<span class="keyword">struct</span> lustre_msg *msg, __u32 flags);
<a name="l02340"></a>02340 __u32 lustre_msg_get_op_flags(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02341"></a>02341 <span class="keywordtype">void</span> lustre_msg_add_op_flags(<span class="keyword">struct</span> lustre_msg *msg, __u32 flags);
<a name="l02342"></a>02342 <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> *lustre_msg_get_handle(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02343"></a>02343 __u32 lustre_msg_get_type(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02344"></a>02344 __u32 lustre_msg_get_version(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02345"></a>02345 <span class="keywordtype">void</span> lustre_msg_add_version(<span class="keyword">struct</span> lustre_msg *msg, __u32 version);
<a name="l02346"></a>02346 __u32 lustre_msg_get_opc(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02347"></a>02347 __u64 lustre_msg_get_last_xid(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02348"></a>02348 __u16 lustre_msg_get_tag(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02349"></a>02349 __u64 lustre_msg_get_last_committed(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02350"></a>02350 __u64 *lustre_msg_get_versions(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02351"></a>02351 __u64 lustre_msg_get_transno(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02352"></a>02352 __u64 lustre_msg_get_slv(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02353"></a>02353 __u32 lustre_msg_get_limit(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02354"></a>02354 <span class="keywordtype">void</span> lustre_msg_set_slv(<span class="keyword">struct</span> lustre_msg *msg, __u64 slv);
<a name="l02355"></a>02355 <span class="keywordtype">void</span> lustre_msg_set_limit(<span class="keyword">struct</span> lustre_msg *msg, __u64 limit);
<a name="l02356"></a>02356 <span class="keywordtype">int</span> lustre_msg_get_status(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02357"></a>02357 __u32 lustre_msg_get_conn_cnt(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02358"></a>02358 __u32 lustre_msg_get_magic(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02359"></a>02359 __u32 lustre_msg_get_timeout(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02360"></a>02360 __u32 lustre_msg_get_service_time(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02361"></a>02361 <span class="keywordtype">char</span> *lustre_msg_get_jobid(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02362"></a>02362 __u32 lustre_msg_get_cksum(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02363"></a>02363 __u64 lustre_msg_get_mbits(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02364"></a>02364 __u32 lustre_msg_calc_cksum(<span class="keyword">struct</span> lustre_msg *msg);
<a name="l02365"></a>02365 <span class="keywordtype">void</span> lustre_msg_set_handle(<span class="keyword">struct</span> lustre_msg *msg,<span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *handle);
<a name="l02366"></a>02366 <span class="keywordtype">void</span> lustre_msg_set_type(<span class="keyword">struct</span> lustre_msg *msg, __u32 type);
<a name="l02367"></a>02367 <span class="keywordtype">void</span> lustre_msg_set_opc(<span class="keyword">struct</span> lustre_msg *msg, __u32 opc);
<a name="l02368"></a>02368 <span class="keywordtype">void</span> lustre_msg_set_last_xid(<span class="keyword">struct</span> lustre_msg *msg, __u64 last_xid);
<a name="l02369"></a>02369 <span class="keywordtype">void</span> lustre_msg_set_tag(<span class="keyword">struct</span> lustre_msg *msg, __u16 tag);
<a name="l02370"></a>02370 <span class="keywordtype">void</span> lustre_msg_set_last_committed(<span class="keyword">struct</span> lustre_msg *msg,__u64 last_committed);
<a name="l02371"></a>02371 <span class="keywordtype">void</span> lustre_msg_set_versions(<span class="keyword">struct</span> lustre_msg *msg, __u64 *versions);
<a name="l02372"></a>02372 <span class="keywordtype">void</span> lustre_msg_set_transno(<span class="keyword">struct</span> lustre_msg *msg, __u64 transno);
<a name="l02373"></a>02373 <span class="keywordtype">void</span> lustre_msg_set_status(<span class="keyword">struct</span> lustre_msg *msg, __u32 status);
<a name="l02374"></a>02374 <span class="keywordtype">void</span> lustre_msg_set_conn_cnt(<span class="keyword">struct</span> lustre_msg *msg, __u32 conn_cnt);
<a name="l02375"></a>02375 <span class="keywordtype">void</span> ptlrpc_req_set_repsize(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> count, __u32 *sizes);
<a name="l02376"></a>02376 <span class="keywordtype">void</span> ptlrpc_request_set_replen(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02377"></a>02377 <span class="keywordtype">void</span> lustre_msg_set_timeout(<span class="keyword">struct</span> lustre_msg *msg, __u32 timeout);
<a name="l02378"></a>02378 <span class="keywordtype">void</span> lustre_msg_set_service_time(<span class="keyword">struct</span> lustre_msg *msg, __u32 service_time);
<a name="l02379"></a>02379 <span class="keywordtype">void</span> lustre_msg_set_jobid(<span class="keyword">struct</span> lustre_msg *msg, <span class="keywordtype">char</span> *jobid);
<a name="l02380"></a>02380 <span class="keywordtype">void</span> lustre_msg_set_cksum(<span class="keyword">struct</span> lustre_msg *msg, __u32 cksum);
<a name="l02381"></a>02381 <span class="keywordtype">void</span> lustre_msg_set_mbits(<span class="keyword">struct</span> lustre_msg *msg, __u64 mbits);
<a name="l02382"></a>02382 
<a name="l02383"></a>02383 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02384"></a>02384 lustre_shrink_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> segment,
<a name="l02385"></a>02385                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newlen, <span class="keywordtype">int</span> move_data)
<a name="l02386"></a>02386 {
<a name="l02387"></a>02387         LASSERT(req-&gt;rq_reply_state);
<a name="l02388"></a>02388         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l02389"></a>02389         req-&gt;<a class="code" href="structptlrpc__request.html#aaa9ba7e7b71ad2057d1650469ab15076" title="Reply length.">rq_replen</a> = lustre_shrink_msg(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>, segment,
<a name="l02390"></a>02390                                            newlen, move_data);
<a name="l02391"></a>02391 }
<a name="l02392"></a>02392 
<a name="l02393"></a>02393 <span class="preprocessor">#ifdef LUSTRE_TRANSLATE_ERRNOS</span>
<a name="l02394"></a>02394 <span class="preprocessor"></span>
<a name="l02395"></a>02395 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_status_hton(<span class="keywordtype">int</span> h)
<a name="l02396"></a>02396 {
<a name="l02397"></a>02397         <span class="comment">/*</span>
<a name="l02398"></a>02398 <span class="comment">         * Positive errnos must be network errnos, such as LUSTRE_EDEADLK,</span>
<a name="l02399"></a>02399 <span class="comment">         * ELDLM_LOCK_ABORTED, etc.</span>
<a name="l02400"></a>02400 <span class="comment">         */</span>
<a name="l02401"></a>02401         <span class="keywordflow">if</span> (h &lt; 0)
<a name="l02402"></a>02402                 <span class="keywordflow">return</span> -lustre_errno_hton(-h);
<a name="l02403"></a>02403         <span class="keywordflow">else</span>
<a name="l02404"></a>02404                 <span class="keywordflow">return</span> h;
<a name="l02405"></a>02405 }
<a name="l02406"></a>02406 
<a name="l02407"></a>02407 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_status_ntoh(<span class="keywordtype">int</span> n)
<a name="l02408"></a>02408 {
<a name="l02409"></a>02409         <span class="comment">/*</span>
<a name="l02410"></a>02410 <span class="comment">         * See the comment in ptlrpc_status_hton().</span>
<a name="l02411"></a>02411 <span class="comment">         */</span>
<a name="l02412"></a>02412         <span class="keywordflow">if</span> (n &lt; 0)
<a name="l02413"></a>02413                 <span class="keywordflow">return</span> -lustre_errno_ntoh(-n);
<a name="l02414"></a>02414         <span class="keywordflow">else</span>
<a name="l02415"></a>02415                 <span class="keywordflow">return</span> n;
<a name="l02416"></a>02416 }
<a name="l02417"></a>02417 
<a name="l02418"></a>02418 <span class="preprocessor">#else</span>
<a name="l02419"></a>02419 <span class="preprocessor"></span>
<a name="l02420"></a>02420 <span class="preprocessor">#define ptlrpc_status_hton(h) (h)</span>
<a name="l02421"></a>02421 <span class="preprocessor"></span><span class="preprocessor">#define ptlrpc_status_ntoh(n) (n)</span>
<a name="l02422"></a>02422 <span class="preprocessor"></span>
<a name="l02423"></a>02423 <span class="preprocessor">#endif</span>
<a name="l02424"></a>02424 <span class="preprocessor"></span>
<a name="l02427"></a>02427 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02428"></a>02428 ptlrpc_rqphase_move(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keyword">enum</span> <a class="code" href="group__net.html#ga0e456f0c28b52cad4b543eec9efa656a" title="RPC stages.">rq_phase</a> new_phase)
<a name="l02429"></a>02429 {
<a name="l02430"></a>02430         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == new_phase)
<a name="l02431"></a>02431                 <span class="keywordflow">return</span>;
<a name="l02432"></a>02432 
<a name="l02433"></a>02433         <span class="keywordflow">if</span> (new_phase == RQ_PHASE_UNREGISTERING) {
<a name="l02434"></a>02434                 req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a> = req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a>;
<a name="l02435"></a>02435                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>)
<a name="l02436"></a>02436                         atomic_inc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a7486b4c70db32e592a5f7310a0f9539b" title="Number of requests currently unregistering.">imp_unregistering</a>);
<a name="l02437"></a>02437         }
<a name="l02438"></a>02438 
<a name="l02439"></a>02439         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_UNREGISTERING) {
<a name="l02440"></a>02440                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>)
<a name="l02441"></a>02441                         atomic_dec(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a7486b4c70db32e592a5f7310a0f9539b" title="Number of requests currently unregistering.">imp_unregistering</a>);
<a name="l02442"></a>02442         }
<a name="l02443"></a>02443 
<a name="l02444"></a>02444         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_INFO, req, <span class="stringliteral">&quot;move req \&quot;%s\&quot; -&gt; \&quot;%s\&quot;&quot;</span>,
<a name="l02445"></a>02445                   ptlrpc_rqphase2str(req), ptlrpc_phase2str(new_phase));
<a name="l02446"></a>02446 
<a name="l02447"></a>02447         req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> = new_phase;
<a name="l02448"></a>02448 }
<a name="l02449"></a>02449 
<a name="l02453"></a>02453 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02454"></a>02454 ptlrpc_client_early(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02455"></a>02455 {
<a name="l02456"></a>02456         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK) &amp;&amp;
<a name="l02457"></a>02457             req-&gt;rq_reply_deadline &gt; cfs_time_current_sec())
<a name="l02458"></a>02458                 <span class="keywordflow">return</span> 0;
<a name="l02459"></a>02459         <span class="keywordflow">return</span> req-&gt;rq_early;
<a name="l02460"></a>02460 }
<a name="l02461"></a>02461 
<a name="l02465"></a>02465 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02466"></a>02466 ptlrpc_client_replied(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02467"></a>02467 {
<a name="l02468"></a>02468         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK) &amp;&amp;
<a name="l02469"></a>02469             req-&gt;rq_reply_deadline &gt; cfs_time_current_sec())
<a name="l02470"></a>02470                 <span class="keywordflow">return</span> 0;
<a name="l02471"></a>02471         <span class="keywordflow">return</span> req-&gt;rq_replied;
<a name="l02472"></a>02472 }
<a name="l02473"></a>02473 
<a name="l02475"></a>02475 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02476"></a>02476 ptlrpc_client_recv(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02477"></a>02477 {
<a name="l02478"></a>02478         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK) &amp;&amp;
<a name="l02479"></a>02479             req-&gt;rq_reply_deadline &gt; cfs_time_current_sec())
<a name="l02480"></a>02480                 <span class="keywordflow">return</span> 1;
<a name="l02481"></a>02481         <span class="keywordflow">return</span> req-&gt;rq_receiving_reply;
<a name="l02482"></a>02482 }
<a name="l02483"></a>02483 
<a name="l02484"></a>02484 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02485"></a>02485 ptlrpc_client_recv_or_unlink(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02486"></a>02486 {
<a name="l02487"></a>02487         <span class="keywordtype">int</span> rc;
<a name="l02488"></a>02488 
<a name="l02489"></a>02489         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02490"></a>02490         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK) &amp;&amp;
<a name="l02491"></a>02491             req-&gt;rq_reply_deadline &gt; cfs_time_current_sec()) {
<a name="l02492"></a>02492                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02493"></a>02493                 <span class="keywordflow">return</span> 1;
<a name="l02494"></a>02494         }
<a name="l02495"></a>02495         rc = !req-&gt;rq_req_unlinked || !req-&gt;rq_reply_unlinked ||
<a name="l02496"></a>02496              req-&gt;rq_receiving_reply;
<a name="l02497"></a>02497         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02498"></a>02498         <span class="keywordflow">return</span> rc;
<a name="l02499"></a>02499 }
<a name="l02500"></a>02500 
<a name="l02501"></a>02501 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02502"></a>02502 ptlrpc_client_wake_req(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02503"></a>02503 {
<a name="l02504"></a>02504         <span class="keywordflow">if</span> (req-&gt;rq_set == NULL)
<a name="l02505"></a>02505                 wake_up(&amp;req-&gt;rq_reply_waitq);
<a name="l02506"></a>02506         <span class="keywordflow">else</span>
<a name="l02507"></a>02507                 wake_up(&amp;req-&gt;rq_set-&gt;set_waitq);
<a name="l02508"></a>02508 }
<a name="l02509"></a>02509 
<a name="l02510"></a>02510 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02511"></a>02511 ptlrpc_rs_addref(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs)
<a name="l02512"></a>02512 {
<a name="l02513"></a>02513         LASSERT(atomic_read(&amp;rs-&gt;rs_refcount) &gt; 0);
<a name="l02514"></a>02514         atomic_inc(&amp;rs-&gt;rs_refcount);
<a name="l02515"></a>02515 }
<a name="l02516"></a>02516 
<a name="l02517"></a>02517 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02518"></a>02518 ptlrpc_rs_decref(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs)
<a name="l02519"></a>02519 {
<a name="l02520"></a>02520         LASSERT(atomic_read(&amp;rs-&gt;rs_refcount) &gt; 0);
<a name="l02521"></a>02521         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;rs-&gt;rs_refcount))
<a name="l02522"></a>02522                 lustre_free_reply_state(rs);
<a name="l02523"></a>02523 }
<a name="l02524"></a>02524 
<a name="l02525"></a>02525 <span class="comment">/* Should only be called once per req */</span>
<a name="l02526"></a>02526 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ptlrpc_req_drop_rs(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02527"></a>02527 {
<a name="l02528"></a>02528         <span class="keywordflow">if</span> (req-&gt;rq_reply_state == NULL)
<a name="l02529"></a>02529                 <span class="keywordflow">return</span>; <span class="comment">/* shouldn&apos;t occur */</span>
<a name="l02530"></a>02530         ptlrpc_rs_decref(req-&gt;rq_reply_state);
<a name="l02531"></a>02531         req-&gt;rq_reply_state = NULL;
<a name="l02532"></a>02532         req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> = NULL;
<a name="l02533"></a>02533 }
<a name="l02534"></a>02534 
<a name="l02535"></a>02535 <span class="keyword">static</span> <span class="keyword">inline</span> __u32 lustre_request_magic(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02536"></a>02536 {
<a name="l02537"></a>02537         <span class="keywordflow">return</span> lustre_msg_get_magic(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l02538"></a>02538 }
<a name="l02539"></a>02539 
<a name="l02540"></a>02540 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_req_get_repsize(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02541"></a>02541 {
<a name="l02542"></a>02542         <span class="keywordflow">switch</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>-&gt;lm_magic) {
<a name="l02543"></a>02543         <span class="keywordflow">case</span> LUSTRE_MSG_MAGIC_V2:
<a name="l02544"></a>02544                 <span class="keywordflow">return</span> req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>-&gt;lm_repsize;
<a name="l02545"></a>02545         <span class="keywordflow">default</span>:
<a name="l02546"></a>02546                 LASSERTF(0, <span class="stringliteral">&quot;incorrect message magic: %08x\n&quot;</span>,
<a name="l02547"></a>02547                          req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>-&gt;lm_magic);
<a name="l02548"></a>02548                 <span class="keywordflow">return</span> -EFAULT;
<a name="l02549"></a>02549         }
<a name="l02550"></a>02550 }
<a name="l02551"></a>02551 
<a name="l02552"></a>02552 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_send_limit_expired(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02553"></a>02553 {
<a name="l02554"></a>02554         <span class="keywordflow">if</span> (req-&gt;rq_delay_limit != 0 &amp;&amp;
<a name="l02555"></a>02555             cfs_time_before(cfs_time_add(req-&gt;rq_queued_time,
<a name="l02556"></a>02556                                          cfs_time_seconds(req-&gt;rq_delay_limit)),
<a name="l02557"></a>02557                             cfs_time_current())) {
<a name="l02558"></a>02558                 <span class="keywordflow">return</span> 1;
<a name="l02559"></a>02559         }
<a name="l02560"></a>02560         <span class="keywordflow">return</span> 0;
<a name="l02561"></a>02561 }
<a name="l02562"></a>02562 
<a name="l02563"></a>02563 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_no_resend(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02564"></a>02564 {
<a name="l02565"></a>02565         <span class="keywordflow">if</span> (!req-&gt;rq_no_resend &amp;&amp; ptlrpc_send_limit_expired(req)) {
<a name="l02566"></a>02566                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02567"></a>02567                 req-&gt;rq_no_resend = 1;
<a name="l02568"></a>02568                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02569"></a>02569         }
<a name="l02570"></a>02570         <span class="keywordflow">return</span> req-&gt;rq_no_resend;
<a name="l02571"></a>02571 }
<a name="l02572"></a>02572 
<a name="l02573"></a>02573 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02574"></a>02574 ptlrpc_server_get_timeout(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02575"></a>02575 {
<a name="l02576"></a>02576         <span class="keywordtype">int</span> at = AT_OFF ? 0 : at_get(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754" title="estimated rpc service time">scp_at_estimate</a>);
<a name="l02577"></a>02577 
<a name="l02578"></a>02578         <span class="keywordflow">return</span> svcpt-&gt;scp_service-&gt;srv_watchdog_factor *
<a name="l02579"></a>02579                max_t(<span class="keywordtype">int</span>, at, obd_timeout);
<a name="l02580"></a>02580 }
<a name="l02581"></a>02581 
<a name="l02582"></a>02582 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *
<a name="l02583"></a>02583 ptlrpc_req2svc(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02584"></a>02584 {
<a name="l02585"></a>02585         LASSERT(req-&gt;rq_rqbd != NULL);
<a name="l02586"></a>02586         <span class="keywordflow">return</span> req-&gt;rq_rqbd-&gt;rqbd_svcpt-&gt;scp_service;
<a name="l02587"></a>02587 }
<a name="l02588"></a>02588 
<a name="l02589"></a>02589 <span class="comment">/* ldlm/ldlm_lib.c */</span>
<a name="l02594"></a>02594 <span class="keywordtype">int</span> <a class="code" href="group__net.html#gabcdaa31fdbdb87a69a06d19c43bbcda0" title="Target client logic.">client_obd_setup</a>(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev, <span class="keyword">struct</span> <a class="code" href="structlustre__cfg.html">lustre_cfg</a> *lcfg);
<a name="l02595"></a>02595 <span class="keywordtype">int</span> client_obd_cleanup(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev);
<a name="l02596"></a>02596 <span class="keywordtype">int</span> client_connect_import(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02597"></a>02597                           <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> **exp, <span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd,
<a name="l02598"></a>02598                           <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *cluuid, <span class="keyword">struct</span> <a class="code" href="structobd__connect__data.html">obd_connect_data</a> *,
<a name="l02599"></a>02599                           <span class="keywordtype">void</span> *localdata);
<a name="l02600"></a>02600 <span class="keywordtype">int</span> client_disconnect_export(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp);
<a name="l02601"></a>02601 <span class="keywordtype">int</span> client_import_add_conn(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp, <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid,
<a name="l02602"></a>02602                            <span class="keywordtype">int</span> priority);
<a name="l02603"></a>02603 <span class="keywordtype">int</span> client_import_del_conn(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp, <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid);
<a name="l02604"></a>02604 <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga0d66e2da6f0da4bb948be01b9719af5c" title="Find conn UUID by peer NID.">client_import_find_conn</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> peer,
<a name="l02605"></a>02605                             <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid);
<a name="l02606"></a>02606 <span class="keywordtype">int</span> import_set_conn_priority(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp, <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid);
<a name="l02607"></a>02607 <span class="keywordtype">void</span> client_destroy_import(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02610"></a>02610 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02611"></a>02611 <span class="preprocessor"></span><span class="keywordtype">int</span> server_disconnect_export(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp);
<a name="l02612"></a>02612 <span class="preprocessor">#endif</span>
<a name="l02613"></a>02613 <span class="preprocessor"></span>
<a name="l02614"></a>02614 <span class="comment">/* ptlrpc/pinger.c */</span>
<a name="l02619"></a><a class="code" href="group__net.html#ga83197c087490e096e36a4397091d0c3f">02619</a> <span class="keyword">enum</span> <a class="code" href="group__net.html#ga83197c087490e096e36a4397091d0c3f" title="Pinger API (client side only).">timeout_event</a> {
<a name="l02620"></a>02620         TIMEOUT_GRANT = 1
<a name="l02621"></a>02621 };
<a name="l02622"></a>02622 <span class="keyword">struct </span><a class="code" href="structtimeout__item.html">timeout_item</a>;
<a name="l02623"></a>02623 <span class="keyword">typedef</span> int (*timeout_cb_t)(<span class="keyword">struct </span><a class="code" href="structtimeout__item.html">timeout_item</a> *, <span class="keywordtype">void</span> *);
<a name="l02624"></a>02624 <span class="keywordtype">int</span> ptlrpc_pinger_add_import(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02625"></a>02625 <span class="keywordtype">int</span> ptlrpc_pinger_del_import(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02626"></a>02626 <span class="keywordtype">int</span> ptlrpc_add_timeout_client(<span class="keywordtype">int</span> time, <span class="keyword">enum</span> <a class="code" href="group__net.html#ga83197c087490e096e36a4397091d0c3f" title="Pinger API (client side only).">timeout_event</a> event,
<a name="l02627"></a>02627                               timeout_cb_t cb, <span class="keywordtype">void</span> *data,
<a name="l02628"></a>02628                               <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *obd_list);
<a name="l02629"></a>02629 <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga43e79605481156aa499fd539a3e1265c">ptlrpc_del_timeout_client</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *obd_list,
<a name="l02630"></a>02630                               <span class="keyword">enum</span> <a class="code" href="group__net.html#ga83197c087490e096e36a4397091d0c3f" title="Pinger API (client side only).">timeout_event</a> event);
<a name="l02631"></a>02631 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> * ptlrpc_prep_ping(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l02632"></a>02632 <span class="keywordtype">int</span> ptlrpc_obd_ping(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd);
<a name="l02633"></a>02633 <span class="keywordtype">void</span> ping_evictor_start(<span class="keywordtype">void</span>);
<a name="l02634"></a>02634 <span class="keywordtype">void</span> ping_evictor_stop(<span class="keywordtype">void</span>);
<a name="l02635"></a>02635 <span class="keywordtype">void</span> ptlrpc_pinger_ir_up(<span class="keywordtype">void</span>);
<a name="l02636"></a>02636 <span class="keywordtype">void</span> ptlrpc_pinger_ir_down(<span class="keywordtype">void</span>);
<a name="l02638"></a>02638 <span class="keywordtype">int</span> ptlrpc_pinger_suppress_pings(<span class="keywordtype">void</span>);
<a name="l02639"></a>02639 
<a name="l02640"></a>02640 <span class="comment">/* ptlrpc/ptlrpcd.c */</span>
<a name="l02641"></a>02641 <span class="keywordtype">void</span> ptlrpcd_stop(<span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc, <span class="keywordtype">int</span> force);
<a name="l02642"></a>02642 <span class="keywordtype">void</span> ptlrpcd_free(<span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc);
<a name="l02643"></a>02643 <span class="keywordtype">void</span> ptlrpcd_wake(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02644"></a>02644 <span class="keywordtype">void</span> <a class="code" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check-&amp;gt;ptlrpc_check_set()...">ptlrpcd_add_req</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02645"></a>02645 <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga8786798db7200aeedbfe4cd0a855232f" title="Move all request from an existing request set to the ptlrpcd queue.">ptlrpcd_add_rqset</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>);
<a name="l02646"></a>02646 <span class="keywordtype">int</span> ptlrpcd_addref(<span class="keywordtype">void</span>);
<a name="l02647"></a>02647 <span class="keywordtype">void</span> ptlrpcd_decref(<span class="keywordtype">void</span>);
<a name="l02648"></a>02648 
<a name="l02649"></a>02649 <span class="comment">/* ptlrpc/lproc_ptlrpc.c */</span>
<a name="l02654"></a>02654 <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="group__net.html#gac9b02b599f8ac342b03f25da53bcb168" title="procfs output related functions">ll_opcode2str</a>(__u32 opcode);
<a name="l02655"></a>02655 <span class="preprocessor">#ifdef CONFIG_PROC_FS</span>
<a name="l02656"></a>02656 <span class="preprocessor"></span><span class="keywordtype">void</span> ptlrpc_lprocfs_register_obd(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd);
<a name="l02657"></a>02657 <span class="keywordtype">void</span> ptlrpc_lprocfs_unregister_obd(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd);
<a name="l02658"></a>02658 <span class="keywordtype">void</span> ptlrpc_lprocfs_brw(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> bytes);
<a name="l02659"></a>02659 <span class="preprocessor">#else</span>
<a name="l02660"></a>02660 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ptlrpc_lprocfs_register_obd(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd) {}
<a name="l02661"></a>02661 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ptlrpc_lprocfs_unregister_obd(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd) {}
<a name="l02662"></a>02662 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ptlrpc_lprocfs_brw(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> bytes) {}
<a name="l02663"></a>02663 <span class="preprocessor">#endif</span>
<a name="l02664"></a>02664 <span class="preprocessor"></span>
<a name="l02666"></a>02666 <span class="comment">/* ptlrpc/llog_server.c */</span>
<a name="l02667"></a>02667 <span class="keywordtype">int</span> llog_origin_handle_open(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02668"></a>02668 <span class="keywordtype">int</span> llog_origin_handle_destroy(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02669"></a>02669 <span class="keywordtype">int</span> llog_origin_handle_prev_block(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02670"></a>02670 <span class="keywordtype">int</span> llog_origin_handle_next_block(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02671"></a>02671 <span class="keywordtype">int</span> llog_origin_handle_read_header(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02672"></a>02672 <span class="keywordtype">int</span> llog_origin_handle_close(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l02673"></a>02673 
<a name="l02674"></a>02674 <span class="comment">/* ptlrpc/llog_client.c */</span>
<a name="l02675"></a>02675 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a> llog_client_ops;
<a name="l02678"></a>02678 <span class="preprocessor">#endif</span>
<a name="l02679"></a>02679 <span class="preprocessor"></span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:13 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
