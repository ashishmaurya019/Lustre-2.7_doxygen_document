<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ptlrpc/nrs_orr.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/ptlrpc/nrs_orr.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment"> * GNU General Public License version 2 for more details.  A copy is</span>
<a name="l00014"></a>00014 <span class="comment"> * included in the COPYING file that accompanied this code.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * along with this program; if not, write to the Free Software</span>
<a name="l00018"></a>00018 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * GPL HEADER END</span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 <span class="comment">/*</span>
<a name="l00023"></a>00023 <span class="comment"> * Copyright (c) 2013, 2015, Intel Corporation.</span>
<a name="l00024"></a>00024 <span class="comment"> *</span>
<a name="l00025"></a>00025 <span class="comment"> * Copyright 2012 Xyratex Technology Limited</span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 <span class="comment">/*</span>
<a name="l00028"></a>00028 <span class="comment"> * lustre/ptlrpc/nrs_orr.c</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Network Request Scheduler (NRS) ORR and TRR policies</span>
<a name="l00031"></a>00031 <span class="comment"> *</span>
<a name="l00032"></a>00032 <span class="comment"> * Request scheduling in a Round-Robin manner over backend-fs objects and OSTs</span>
<a name="l00033"></a>00033 <span class="comment"> * respectively</span>
<a name="l00034"></a>00034 <span class="comment"> *</span>
<a name="l00035"></a>00035 <span class="comment"> * Author: Liang Zhen &lt;liang@whamcloud.com&gt;</span>
<a name="l00036"></a>00036 <span class="comment"> * Author: Nikitas Angelinas &lt;nikitas_angelinas@xyratex.com&gt;</span>
<a name="l00037"></a>00037 <span class="comment"> */</span>
<a name="l00038"></a>00038 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_RPC</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;obd_support.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;lustre_net.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;lustre/lustre_idl.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;lustre_req_layout.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;ptlrpc_internal.h&quot;</span>
<a name="l00051"></a>00051 
<a name="l00078"></a>00078 <span class="preprocessor">#define NRS_POL_NAME_ORR        &quot;orr&quot;</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#define NRS_POL_NAME_TRR        &quot;trr&quot;</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span>
<a name="l00092"></a>00092 <span class="keyword">static</span> <span class="keywordtype">bool</span> nrs_orr_req_supported(<span class="keyword">struct</span> <a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a> *orrd,
<a name="l00093"></a>00093                                   <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq, __u32 *opcode)
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>  *req = container_of(nrq, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00096"></a>00096                                                    rq_nrq);
<a name="l00097"></a>00097         __u32                   opc = lustre_msg_get_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l00098"></a>00098         <span class="keywordtype">bool</span>                    rc = <span class="keyword">false</span>;
<a name="l00099"></a>00099 
<a name="l00103"></a>00103         <span class="keywordflow">switch</span> (opc) {
<a name="l00104"></a>00104         <span class="keywordflow">case</span> OST_READ:
<a name="l00105"></a>00105                 rc = orrd-&gt;<a class="code" href="structnrs__orr__data.html#a43f5f363becf4e5b91920996c99726b8" title="RPC types that are currently supported.">od_supp</a> &amp; NOS_OST_READ;
<a name="l00106"></a>00106                 <span class="keywordflow">break</span>;
<a name="l00107"></a>00107         <span class="keywordflow">case</span> OST_WRITE:
<a name="l00108"></a>00108                 rc = orrd-&gt;<a class="code" href="structnrs__orr__data.html#a43f5f363becf4e5b91920996c99726b8" title="RPC types that are currently supported.">od_supp</a> &amp; NOS_OST_WRITE;
<a name="l00109"></a>00109                 <span class="keywordflow">break</span>;
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         <span class="keywordflow">if</span> (rc)
<a name="l00113"></a>00113                 *opcode = opc;
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <span class="keywordflow">return</span> rc;
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00130"></a>00130 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_key_fill(<span class="keyword">struct</span> <a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a> *orrd,
<a name="l00131"></a>00131                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq, __u32 opc,
<a name="l00132"></a>00132                             <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structnrs__orr__key.html" title="As unique keys for grouping RPCs together, we use the object&amp;#39;s OST FID for the...">nrs_orr_key</a> *key)
<a name="l00133"></a>00133 {
<a name="l00134"></a>00134         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>  *req = container_of(nrq, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00135"></a>00135                                                    rq_nrq);
<a name="l00136"></a>00136         <span class="keyword">struct </span><a class="code" href="structost__body.html">ost_body</a>        *body;
<a name="l00137"></a>00137         __u32                   ost_idx;
<a name="l00138"></a>00138         <span class="keywordtype">bool</span>                    is_orr = strncmp(name, NRS_POL_NAME_ORR,
<a name="l00139"></a>00139                                                  NRS_POL_NAME_MAX) == 0;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141         LASSERT(req != NULL);
<a name="l00142"></a>00142 
<a name="l00151"></a>00151         <span class="keywordflow">if</span> ((is_orr &amp;&amp; nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a2664027842a6e75ba2c72d61ad9e20d9" title="An ORR policy instance has filled in request information while enqueueing the request...">or_orr_set</a>) ||
<a name="l00152"></a>00152             (!is_orr &amp;&amp; nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a43953763ea429fba150c76148fa05a6c" title="A TRR policy instance has filled in request information while enqueueing the request...">or_trr_set</a>)) {
<a name="l00153"></a>00153                 *key = nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a95e38aab4f159e38fae5a89bb4e0f021" title="For debugging purposes.">or_key</a>;
<a name="l00154"></a>00154                 <span class="keywordflow">return</span> 0;
<a name="l00155"></a>00155         }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157         <span class="comment">/* Bounce unconnected requests to the default policy. */</span>
<a name="l00158"></a>00158         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> == NULL)
<a name="l00159"></a>00159                 <span class="keywordflow">return</span> -ENOTCONN;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161         <span class="keywordflow">if</span> (nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a2664027842a6e75ba2c72d61ad9e20d9" title="An ORR policy instance has filled in request information while enqueueing the request...">or_orr_set</a> || nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a43953763ea429fba150c76148fa05a6c" title="A TRR policy instance has filled in request information while enqueueing the request...">or_trr_set</a>)
<a name="l00162"></a>00162                 memset(&amp;nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a95e38aab4f159e38fae5a89bb4e0f021" title="For debugging purposes.">or_key</a>, 0, <span class="keyword">sizeof</span>(nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a95e38aab4f159e38fae5a89bb4e0f021" title="For debugging purposes.">or_key</a>));
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         ost_idx = class_server_data(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>)-&gt;lsd_osd_index;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <span class="keywordflow">if</span> (is_orr) {
<a name="l00167"></a>00167                 <span class="keywordtype">int</span>     rc;
<a name="l00174"></a>00174                 body = <a class="code" href="group__req__layout.html#ga0ecb097da2dfa5ac12ec0ef1f33d3e88" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC request buffer...">req_capsule_client_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_OST_BODY);
<a name="l00175"></a>00175                 <span class="keywordflow">if</span> (body == NULL)
<a name="l00176"></a>00176                         RETURN(-EFAULT);
<a name="l00177"></a>00177 
<a name="l00178"></a>00178                 rc = ostid_to_fid(&amp;key-&gt;<a class="code" href="structnrs__orr__key.html#aadc407f51783ee56827551dacda307ff" title="object FID for ORR">ok_fid</a>, &amp;body-&gt;oa.o_oi, ost_idx);
<a name="l00179"></a>00179                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00180"></a>00180                         <span class="keywordflow">return</span> rc;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182                 nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a2664027842a6e75ba2c72d61ad9e20d9" title="An ORR policy instance has filled in request information while enqueueing the request...">or_orr_set</a> = 1;
<a name="l00183"></a>00183         } <span class="keywordflow">else</span> {
<a name="l00184"></a>00184                 key-&gt;<a class="code" href="structnrs__orr__key.html#a552903e8e7499e085caedc764fc5e2b1" title="OST index for TRR.">ok_idx</a> = ost_idx;
<a name="l00185"></a>00185                 nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a43953763ea429fba150c76148fa05a6c" title="A TRR policy instance has filled in request information while enqueueing the request...">or_trr_set</a> = 1;
<a name="l00186"></a>00186         }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188         <span class="keywordflow">return</span> 0;
<a name="l00189"></a>00189 }
<a name="l00190"></a>00190 
<a name="l00199"></a>00199 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_range_fill_logical(<span class="keyword">struct</span> <a class="code" href="structniobuf__remote.html">niobuf_remote</a> *nb, <span class="keywordtype">int</span> niocount,
<a name="l00200"></a>00200                                        <span class="keyword">struct</span> <a class="code" href="structnrs__orr__req__range.html" title="Lower and upper byte offsets of a brw RPC.">nrs_orr_req_range</a> *range)
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202         <span class="comment">/* Should we do this at page boundaries ? */</span>
<a name="l00203"></a>00203         range-&gt;or_start = nb[0].rnb_offset &amp; PAGE_MASK;
<a name="l00204"></a>00204         range-&gt;or_end = (nb[niocount - 1].rnb_offset +
<a name="l00205"></a>00205                          nb[niocount - 1].rnb_len - 1) | ~PAGE_MASK;
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00212"></a>00212 <span class="preprocessor">#define ORR_NUM_EXTENTS 1</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>
<a name="l00228"></a>00228 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_range_fill_physical(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq,
<a name="l00229"></a>00229                                        <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa,
<a name="l00230"></a>00230                                        <span class="keyword">struct</span> <a class="code" href="structnrs__orr__req__range.html" title="Lower and upper byte offsets of a brw RPC.">nrs_orr_req_range</a> *range)
<a name="l00231"></a>00231 {
<a name="l00232"></a>00232         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>     *req = container_of(nrq,
<a name="l00233"></a>00233                                                       <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00234"></a>00234                                                       rq_nrq);
<a name="l00235"></a>00235         <span class="keywordtype">char</span>                       fiemap_buf[offsetof(<span class="keyword">struct</span> fiemap,
<a name="l00236"></a>00236                                                   fm_extents[ORR_NUM_EXTENTS])];
<a name="l00237"></a>00237         <span class="keyword">struct </span>fiemap              *fiemap = (<span class="keyword">struct </span>fiemap *)fiemap_buf;
<a name="l00238"></a>00238         <span class="keyword">struct </span><a class="code" href="structll__fiemap__info__key.html">ll_fiemap_info_key</a>  key;
<a name="l00239"></a>00239         loff_t                     start;
<a name="l00240"></a>00240         loff_t                     end;
<a name="l00241"></a>00241         <span class="keywordtype">int</span>                        rc;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243         key = (typeof(key)) {
<a name="l00244"></a>00244                 .lfik_name = KEY_FIEMAP,
<a name="l00245"></a>00245                 .lfik_oa = *oa,
<a name="l00246"></a>00246                 .lfik_fiemap = {
<a name="l00247"></a>00247                         .fm_start = range-&gt;or_start,
<a name="l00248"></a>00248                         .fm_length = range-&gt;or_end - range-&gt;or_start,
<a name="l00249"></a>00249                         .fm_extent_count = ORR_NUM_EXTENTS
<a name="l00250"></a>00250                 }
<a name="l00251"></a>00251         };
<a name="l00252"></a>00252 
<a name="l00253"></a>00253         rc = obd_get_info(req-&gt;rq_svc_thread-&gt;t_env, req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>,
<a name="l00254"></a>00254                           <span class="keyword">sizeof</span>(key), &amp;key, NULL, fiemap);
<a name="l00255"></a>00255         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00256"></a>00256                 GOTO(out, rc);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         <span class="keywordflow">if</span> (fiemap-&gt;fm_mapped_extents == 0 ||
<a name="l00259"></a>00259             fiemap-&gt;fm_mapped_extents &gt; ORR_NUM_EXTENTS)
<a name="l00260"></a>00260                 GOTO(out, rc = -EFAULT);
<a name="l00261"></a>00261 
<a name="l00266"></a>00266         start = fiemap-&gt;fm_extents[0].fe_physical + range-&gt;or_start -
<a name="l00267"></a>00267                 fiemap-&gt;fm_extents[0].fe_logical;
<a name="l00268"></a>00268         end = start + range-&gt;or_end - range-&gt;or_start;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         range-&gt;or_start = start;
<a name="l00271"></a>00271         range-&gt;or_end = end;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273         nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a13c74a6e845b01bcc25c5526ff96975f" title="Request offset ranges have been filled in with physical offset values.">or_physical_set</a> = 1;
<a name="l00274"></a>00274 out:
<a name="l00275"></a>00275         <span class="keywordflow">return</span> rc;
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00291"></a>00291 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_range_fill(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq,
<a name="l00292"></a>00292                               <span class="keyword">struct</span> <a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a> *orrd, __u32 opc,
<a name="l00293"></a>00293                               <span class="keywordtype">bool</span> moving_req)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>       *req = container_of(nrq,
<a name="l00296"></a>00296                                                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00297"></a>00297                                                         rq_nrq);
<a name="l00298"></a>00298         <span class="keyword">struct </span><a class="code" href="structobd__ioobj.html">obd_ioobj</a>            *ioo;
<a name="l00299"></a>00299         <span class="keyword">struct </span><a class="code" href="structniobuf__remote.html">niobuf_remote</a>        *nb;
<a name="l00300"></a>00300         <span class="keyword">struct </span><a class="code" href="structost__body.html">ost_body</a>             *body;
<a name="l00301"></a>00301         <span class="keyword">struct </span><a class="code" href="structnrs__orr__req__range.html" title="Lower and upper byte offsets of a brw RPC.">nrs_orr_req_range</a>     range;
<a name="l00302"></a>00302         <span class="keywordtype">int</span>                          niocount;
<a name="l00303"></a>00303         <span class="keywordtype">int</span>                          rc = 0;
<a name="l00304"></a>00304 
<a name="l00316"></a>00316         <span class="keywordflow">if</span> (orrd-&gt;<a class="code" href="structnrs__orr__data.html#ae018aa64046d05c257039af8b149ba14" title="Whether to use physical disk offsets or logical file offsets.">od_physical</a> &amp;&amp; nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a13c74a6e845b01bcc25c5526ff96975f" title="Request offset ranges have been filled in with physical offset values.">or_physical_set</a>)
<a name="l00317"></a>00317                 <span class="keywordflow">return</span> 0;
<a name="l00318"></a>00318 
<a name="l00319"></a>00319         ioo = <a class="code" href="group__req__layout.html#ga0ecb097da2dfa5ac12ec0ef1f33d3e88" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC request buffer...">req_capsule_client_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_OBD_IOOBJ);
<a name="l00320"></a>00320         <span class="keywordflow">if</span> (ioo == NULL)
<a name="l00321"></a>00321                 GOTO(out, rc = -EFAULT);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323         niocount = ioo-&gt;ioo_bufcnt;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         nb = <a class="code" href="group__req__layout.html#ga0ecb097da2dfa5ac12ec0ef1f33d3e88" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC request buffer...">req_capsule_client_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_NIOBUF_REMOTE);
<a name="l00326"></a>00326         <span class="keywordflow">if</span> (nb == NULL)
<a name="l00327"></a>00327                 GOTO(out, rc = -EFAULT);
<a name="l00328"></a>00328 
<a name="l00332"></a>00332         nrs_orr_range_fill_logical(nb, niocount, &amp;range);
<a name="l00333"></a>00333 
<a name="l00342"></a>00342         <span class="keywordflow">if</span> (orrd-&gt;<a class="code" href="structnrs__orr__data.html#ae018aa64046d05c257039af8b149ba14" title="Whether to use physical disk offsets or logical file offsets.">od_physical</a> &amp;&amp; opc == OST_READ &amp;&amp; !moving_req) {
<a name="l00343"></a>00343                 body = <a class="code" href="group__req__layout.html#ga0ecb097da2dfa5ac12ec0ef1f33d3e88" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC request buffer...">req_capsule_client_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_OST_BODY);
<a name="l00344"></a>00344                 <span class="keywordflow">if</span> (body == NULL)
<a name="l00345"></a>00345                         GOTO(out, rc = -EFAULT);
<a name="l00346"></a>00346 
<a name="l00353"></a>00353                 nrs_orr_range_fill_physical(nrq, &amp;body-&gt;oa, &amp;range);
<a name="l00354"></a>00354         }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a1f9064e42dab8c2cd50bc0972a169af3" title="The offset range this request covers.">or_range</a> = range;
<a name="l00357"></a>00357 out:
<a name="l00358"></a>00358         <span class="keywordflow">return</span> rc;
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 
<a name="l00372"></a>00372 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_genobjname(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy, <span class="keywordtype">char</span> *name)
<a name="l00373"></a>00373 {
<a name="l00374"></a>00374         snprintf(name, NRS_ORR_OBJ_NAME_MAX, <span class="stringliteral">&quot;%s%s%s%d&quot;</span>,
<a name="l00375"></a>00375                  <span class="stringliteral">&quot;nrs_&quot;</span>, policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a966ade252ef1fc27ced667269a199a95" title="Policy descriptor for this policy instance.">pol_desc</a>-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>,
<a name="l00376"></a>00376                  policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a7975af6770c4e7082ed4d14a1b9b44d2" title="The NRS head this policy has been created at.">pol_nrs</a>-&gt;<a class="code" href="structptlrpc__nrs.html#a5bb6a1b3602c1dd56d01a820e0e14228" title="This NRS head handles either HP or regular requests.">nrs_queue_type</a> == PTLRPC_NRS_QUEUE_REG ?
<a name="l00377"></a>00377                  <span class="stringliteral">&quot;_reg_&quot;</span> : <span class="stringliteral">&quot;_hp_&quot;</span>, nrs_pol2cptid(policy));
<a name="l00378"></a>00378 }
<a name="l00379"></a>00379 
<a name="l00383"></a>00383 <span class="preprocessor">#define NRS_ORR_BITS            24</span>
<a name="l00384"></a>00384 <span class="preprocessor"></span><span class="preprocessor">#define NRS_ORR_BKT_BITS        12</span>
<a name="l00385"></a>00385 <span class="preprocessor"></span><span class="preprocessor">#define NRS_ORR_HASH_FLAGS      (CFS_HASH_SPIN_BKTLOCK | CFS_HASH_ASSERT_EMPTY)</span>
<a name="l00386"></a>00386 <span class="preprocessor"></span>
<a name="l00387"></a>00387 <span class="preprocessor">#define NRS_TRR_BITS            4</span>
<a name="l00388"></a>00388 <span class="preprocessor"></span><span class="preprocessor">#define NRS_TRR_BKT_BITS        2</span>
<a name="l00389"></a>00389 <span class="preprocessor"></span><span class="preprocessor">#define NRS_TRR_HASH_FLAGS      CFS_HASH_SPIN_BKTLOCK</span>
<a name="l00390"></a>00390 <span class="preprocessor"></span>
<a name="l00391"></a>00391 <span class="keyword">static</span> <span class="keywordtype">unsigned</span>
<a name="l00392"></a>00392 nrs_orr_hop_hash(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs, <span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">unsigned</span> mask)
<a name="l00393"></a>00393 {
<a name="l00394"></a>00394         <span class="keywordflow">return</span> cfs_hash_djb2_hash(key, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structnrs__orr__key.html" title="As unique keys for grouping RPCs together, we use the object&amp;#39;s OST FID for the...">nrs_orr_key</a>), mask);
<a name="l00395"></a>00395 }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 <span class="keyword">static</span> <span class="keywordtype">void</span> *nrs_orr_hop_key(<span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00398"></a>00398 {
<a name="l00399"></a>00399         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a> *orro = hlist_entry(hnode,
<a name="l00400"></a>00400                                                       <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>,
<a name="l00401"></a>00401                                                       oo_hnode);
<a name="l00402"></a>00402         <span class="keywordflow">return</span> &amp;orro-&gt;<a class="code" href="structnrs__orr__object.html#a20e1ce9fee23cabc705d4abfe3e81ebf" title="The key of the object or OST for which this structure instance is scheduling RPCs...">oo_key</a>;
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_hop_keycmp(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00406"></a>00406 {
<a name="l00407"></a>00407         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a> *orro = hlist_entry(hnode,
<a name="l00408"></a>00408                                                       <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>,
<a name="l00409"></a>00409                                                       oo_hnode);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411         <span class="keywordflow">return</span> lu_fid_eq(&amp;orro-&gt;<a class="code" href="structnrs__orr__object.html#a20e1ce9fee23cabc705d4abfe3e81ebf" title="The key of the object or OST for which this structure instance is scheduling RPCs...">oo_key</a>.<a class="code" href="structnrs__orr__key.html#aadc407f51783ee56827551dacda307ff" title="object FID for ORR">ok_fid</a>,
<a name="l00412"></a>00412                          &amp;((<span class="keyword">struct</span> <a class="code" href="structnrs__orr__key.html" title="As unique keys for grouping RPCs together, we use the object&amp;#39;s OST FID for the...">nrs_orr_key</a> *)key)-&gt;ok_fid);
<a name="l00413"></a>00413 }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 <span class="keyword">static</span> <span class="keywordtype">void</span> *nrs_orr_hop_object(<span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00416"></a>00416 {
<a name="l00417"></a>00417         <span class="keywordflow">return</span> hlist_entry(hnode, <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>, oo_hnode);
<a name="l00418"></a>00418 }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_hop_get(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00421"></a>00421 {
<a name="l00422"></a>00422         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a> *orro = hlist_entry(hnode,
<a name="l00423"></a>00423                                                       <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>,
<a name="l00424"></a>00424                                                       oo_hnode);
<a name="l00425"></a>00425         orro-&gt;oo_ref++;
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00432"></a>00432 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_hop_put_free(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00433"></a>00433 {
<a name="l00434"></a>00434         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a> *orro = hlist_entry(hnode,
<a name="l00435"></a>00435                                                       <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>,
<a name="l00436"></a>00436                                                       oo_hnode);
<a name="l00437"></a>00437         <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>   *orrd = container_of(orro-&gt;oo_res.<a class="code" href="structptlrpc__nrs__resource.html#ad0e4dbe1fe93c3751bf54b78c6d81abd" title="This NRS resource&amp;#39;s parent; is NULL for resources embedded in NRS policy instances;...">res_parent</a>,
<a name="l00438"></a>00438                                                    <span class="keyword">struct</span> <a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>, od_res);
<a name="l00439"></a>00439         <span class="keyword">struct </span><a class="code" href="structcfs__hash__bd.html" title="cfs_hash bucket descriptor, it&amp;#39;s normally in stack of caller">cfs_hash_bd</a>     bd;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         cfs_hash_bd_get_and_lock(hs, &amp;orro-&gt;<a class="code" href="structnrs__orr__object.html#a20e1ce9fee23cabc705d4abfe3e81ebf" title="The key of the object or OST for which this structure instance is scheduling RPCs...">oo_key</a>, &amp;bd, 1);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443         <span class="keywordflow">if</span> (--orro-&gt;oo_ref &gt; 1) {
<a name="l00444"></a>00444                 cfs_hash_bd_unlock(hs, &amp;bd, 1);
<a name="l00445"></a>00445 
<a name="l00446"></a>00446                 <span class="keywordflow">return</span>;
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448         LASSERT(orro-&gt;oo_ref == 1);
<a name="l00449"></a>00449 
<a name="l00450"></a>00450         cfs_hash_bd_del_locked(hs, &amp;bd, hnode);
<a name="l00451"></a>00451         cfs_hash_bd_unlock(hs, &amp;bd, 1);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         OBD_SLAB_FREE_PTR(orro, orrd-&gt;od_cache);
<a name="l00454"></a>00454 }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_hop_put(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00457"></a>00457 {
<a name="l00458"></a>00458         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a> *orro = hlist_entry(hnode,
<a name="l00459"></a>00459                                                       <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>,
<a name="l00460"></a>00460                                                       oo_hnode);
<a name="l00461"></a>00461         orro-&gt;oo_ref--;
<a name="l00462"></a>00462 }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_trr_hop_keycmp(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00465"></a>00465 {
<a name="l00466"></a>00466         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a> *orro = hlist_entry(hnode,
<a name="l00467"></a>00467                                                       <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>,
<a name="l00468"></a>00468                                                       oo_hnode);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470         <span class="keywordflow">return</span> orro-&gt;<a class="code" href="structnrs__orr__object.html#a20e1ce9fee23cabc705d4abfe3e81ebf" title="The key of the object or OST for which this structure instance is scheduling RPCs...">oo_key</a>.<a class="code" href="structnrs__orr__key.html#a552903e8e7499e085caedc764fc5e2b1" title="OST index for TRR.">ok_idx</a> == ((<span class="keyword">struct </span><a class="code" href="structnrs__orr__key.html" title="As unique keys for grouping RPCs together, we use the object&amp;#39;s OST FID for the...">nrs_orr_key</a> *)key)-&gt;ok_idx;
<a name="l00471"></a>00471 }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_trr_hop_exit(<span class="keyword">struct</span> <a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *hs, <span class="keyword">struct</span> <a class="code" href="structhlist__node.html">hlist_node</a> *hnode)
<a name="l00474"></a>00474 {
<a name="l00475"></a>00475         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a> *orro = hlist_entry(hnode,
<a name="l00476"></a>00476                                                       <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>,
<a name="l00477"></a>00477                                                       oo_hnode);
<a name="l00478"></a>00478         <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>   *orrd = container_of(orro-&gt;oo_res.<a class="code" href="structptlrpc__nrs__resource.html#ad0e4dbe1fe93c3751bf54b78c6d81abd" title="This NRS resource&amp;#39;s parent; is NULL for resources embedded in NRS policy instances;...">res_parent</a>,
<a name="l00479"></a>00479                                                    <span class="keyword">struct</span> <a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>, od_res);
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         LASSERTF(orro-&gt;oo_ref == 0,
<a name="l00482"></a>00482                  <span class="stringliteral">&quot;Busy NRS TRR policy object for OST with index %u, with %ld &quot;</span>
<a name="l00483"></a>00483                  <span class="stringliteral">&quot;refs\n&quot;</span>, orro-&gt;<a class="code" href="structnrs__orr__object.html#a20e1ce9fee23cabc705d4abfe3e81ebf" title="The key of the object or OST for which this structure instance is scheduling RPCs...">oo_key</a>.<a class="code" href="structnrs__orr__key.html#a552903e8e7499e085caedc764fc5e2b1" title="OST index for TRR.">ok_idx</a>, orro-&gt;oo_ref);
<a name="l00484"></a>00484 
<a name="l00485"></a>00485         OBD_SLAB_FREE_PTR(orro, orrd-&gt;od_cache);
<a name="l00486"></a>00486 }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcfs__hash__ops.html">cfs_hash_ops</a> nrs_orr_hash_ops = {
<a name="l00489"></a>00489         .hs_hash        = nrs_orr_hop_hash,
<a name="l00490"></a>00490         .hs_key         = nrs_orr_hop_key,
<a name="l00491"></a>00491         .hs_keycmp      = nrs_orr_hop_keycmp,
<a name="l00492"></a>00492         .hs_object      = nrs_orr_hop_object,
<a name="l00493"></a>00493         .hs_get         = nrs_orr_hop_get,
<a name="l00494"></a>00494         .hs_put         = nrs_orr_hop_put_free,
<a name="l00495"></a>00495         .hs_put_locked  = nrs_orr_hop_put,
<a name="l00496"></a>00496 };
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcfs__hash__ops.html">cfs_hash_ops</a> nrs_trr_hash_ops = {
<a name="l00499"></a>00499         .hs_hash        = nrs_orr_hop_hash,
<a name="l00500"></a>00500         .hs_key         = nrs_orr_hop_key,
<a name="l00501"></a>00501         .hs_keycmp      = nrs_trr_hop_keycmp,
<a name="l00502"></a>00502         .hs_object      = nrs_orr_hop_object,
<a name="l00503"></a>00503         .hs_get         = nrs_orr_hop_get,
<a name="l00504"></a>00504         .hs_put         = nrs_orr_hop_put,
<a name="l00505"></a>00505         .hs_put_locked  = nrs_orr_hop_put,
<a name="l00506"></a>00506         .hs_exit        = nrs_trr_hop_exit,
<a name="l00507"></a>00507 };
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="preprocessor">#define NRS_ORR_QUANTUM_DFLT    256</span>
<a name="l00510"></a>00510 <span class="preprocessor"></span>
<a name="l00527"></a>00527 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00528"></a>00528 orr_req_compare(<span class="keyword">struct</span> <a class="code" href="structcfs__binheap__node.html" title="Binary heap node.">cfs_binheap_node</a> *e1, <span class="keyword">struct</span> <a class="code" href="structcfs__binheap__node.html" title="Binary heap node.">cfs_binheap_node</a> *e2)
<a name="l00529"></a>00529 {
<a name="l00530"></a>00530         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq1;
<a name="l00531"></a>00531         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq2;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533         nrq1 = container_of(e1, <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a>, nr_node);
<a name="l00534"></a>00534         nrq2 = container_of(e2, <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a>, nr_node);
<a name="l00535"></a>00535 
<a name="l00539"></a>00539         <span class="keywordflow">if</span> (nrq1-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a> &lt; nrq2-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>)
<a name="l00540"></a>00540                 <span class="keywordflow">return</span> 1;
<a name="l00541"></a>00541         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nrq1-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a> &gt; nrq2-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>)
<a name="l00542"></a>00542                 <span class="keywordflow">return</span> 0;
<a name="l00543"></a>00543 
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (nrq1-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#af8f7e76e2146293803f3df4b13d56838" title="Sequence number for this request; shared with all other requests in the same batch...">or_sequence</a> &lt; nrq2-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#af8f7e76e2146293803f3df4b13d56838" title="Sequence number for this request; shared with all other requests in the same batch...">or_sequence</a>)
<a name="l00551"></a>00551                 <span class="keywordflow">return</span> 1;
<a name="l00552"></a>00552         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nrq1-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#af8f7e76e2146293803f3df4b13d56838" title="Sequence number for this request; shared with all other requests in the same batch...">or_sequence</a> &gt; nrq2-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#af8f7e76e2146293803f3df4b13d56838" title="Sequence number for this request; shared with all other requests in the same batch...">or_sequence</a>)
<a name="l00553"></a>00553                 <span class="keywordflow">return</span> 0;
<a name="l00554"></a>00554 
<a name="l00563"></a>00563         <span class="keywordflow">if</span> (nrq1-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a1f9064e42dab8c2cd50bc0972a169af3" title="The offset range this request covers.">or_range</a>.or_start &lt;
<a name="l00564"></a>00564             nrq2-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a1f9064e42dab8c2cd50bc0972a169af3" title="The offset range this request covers.">or_range</a>.or_start) {
<a name="l00565"></a>00565                 <span class="keywordflow">return</span> 1;
<a name="l00566"></a>00566         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nrq1-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a1f9064e42dab8c2cd50bc0972a169af3" title="The offset range this request covers.">or_range</a>.or_start &gt;
<a name="l00567"></a>00567                  nrq2-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a1f9064e42dab8c2cd50bc0972a169af3" title="The offset range this request covers.">or_range</a>.or_start) {
<a name="l00568"></a>00568                 <span class="keywordflow">return</span> 0;
<a name="l00569"></a>00569         } <span class="keywordflow">else</span> {
<a name="l00575"></a>00575                 <span class="keywordflow">return</span> nrq1-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a1f9064e42dab8c2cd50bc0972a169af3" title="The offset range this request covers.">or_range</a>.or_end &lt;
<a name="l00576"></a>00576                        nrq2-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a1f9064e42dab8c2cd50bc0972a169af3" title="The offset range this request covers.">or_range</a>.or_end;
<a name="l00577"></a>00577         }
<a name="l00578"></a>00578 }
<a name="l00579"></a>00579 
<a name="l00583"></a>00583 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcfs__binheap__ops.html" title="Binary heap operations.">cfs_binheap_ops</a> nrs_orr_heap_ops = {
<a name="l00584"></a>00584         .hop_enter      = NULL,
<a name="l00585"></a>00585         .hop_exit       = NULL,
<a name="l00586"></a>00586         .hop_compare    = orr_req_compare,
<a name="l00587"></a>00587 };
<a name="l00588"></a>00588 
<a name="l00598"></a>00598 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_init(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy)
<a name="l00599"></a>00599 {
<a name="l00600"></a>00600         <span class="keywordflow">if</span> (policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a7975af6770c4e7082ed4d14a1b9b44d2" title="The NRS head this policy has been created at.">pol_nrs</a>-&gt;<a class="code" href="structptlrpc__nrs.html#abf2a529023ae89332f4b185930f1a537" title="Service partition for this NRS head.">nrs_svcpt</a>-&gt;scp_service-&gt;srv_ncpts &gt; 1)
<a name="l00601"></a>00601                 CDEBUG(D_CONFIG, <span class="stringliteral">&quot;%s: The %s NRS policy was registered on a &quot;</span>
<a name="l00602"></a>00602                       <span class="stringliteral">&quot;service with multiple service partitions. This policy &quot;</span>
<a name="l00603"></a>00603                       <span class="stringliteral">&quot;may perform better with a single partition.\n&quot;</span>,
<a name="l00604"></a>00604                       policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a7975af6770c4e7082ed4d14a1b9b44d2" title="The NRS head this policy has been created at.">pol_nrs</a>-&gt;<a class="code" href="structptlrpc__nrs.html#abf2a529023ae89332f4b185930f1a537" title="Service partition for this NRS head.">nrs_svcpt</a>-&gt;scp_service-&gt;srv_name,
<a name="l00605"></a>00605                       policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a966ade252ef1fc27ced667269a199a95" title="Policy descriptor for this policy instance.">pol_desc</a>-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607         <span class="keywordflow">return</span> 0;
<a name="l00608"></a>00608 }
<a name="l00609"></a>00609 
<a name="l00618"></a>00618 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_start(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy, <span class="keywordtype">char</span> *arg)
<a name="l00619"></a>00619 {
<a name="l00620"></a>00620         <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>    *orrd;
<a name="l00621"></a>00621         <span class="keyword">struct </span><a class="code" href="structcfs__hash__ops.html">cfs_hash_ops</a>            *ops;
<a name="l00622"></a>00622         <span class="keywordtype">unsigned</span>                cur_bits;
<a name="l00623"></a>00623         <span class="keywordtype">unsigned</span>                max_bits;
<a name="l00624"></a>00624         <span class="keywordtype">unsigned</span>                bkt_bits;
<a name="l00625"></a>00625         <span class="keywordtype">unsigned</span>                flags;
<a name="l00626"></a>00626         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00627"></a>00627         ENTRY;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629         OBD_CPT_ALLOC_PTR(orrd, nrs_pol2cptab(policy), nrs_pol2cptid(policy));
<a name="l00630"></a>00630         <span class="keywordflow">if</span> (orrd == NULL)
<a name="l00631"></a>00631                 RETURN(-ENOMEM);
<a name="l00632"></a>00632 
<a name="l00633"></a>00633         <span class="comment">/*</span>
<a name="l00634"></a>00634 <span class="comment">         * Binary heap instance for sorted incoming requests.</span>
<a name="l00635"></a>00635 <span class="comment">         */</span>
<a name="l00636"></a>00636         orrd-&gt;od_binheap = <a class="code" href="group__heap.html#gaca8b0cf2ec8b0240e39a18600a58acab" title="Creates and initializes a binary heap instance.">cfs_binheap_create</a>(&amp;nrs_orr_heap_ops,
<a name="l00637"></a>00637                                               CBH_FLAG_ATOMIC_GROW, 4096, NULL,
<a name="l00638"></a>00638                                               nrs_pol2cptab(policy),
<a name="l00639"></a>00639                                               nrs_pol2cptid(policy));
<a name="l00640"></a>00640         <span class="keywordflow">if</span> (orrd-&gt;od_binheap == NULL)
<a name="l00641"></a>00641                 GOTO(failed, rc = -ENOMEM);
<a name="l00642"></a>00642 
<a name="l00643"></a>00643         nrs_orr_genobjname(policy, orrd-&gt;<a class="code" href="structnrs__orr__data.html#a48b2c0d28db24653b61bddafa0cfd098" title="XXX: We need to provide a persistently allocated string to hold unique object names...">od_objname</a>);
<a name="l00644"></a>00644 
<a name="l00648"></a>00648         orrd-&gt;od_cache = kmem_cache_create(orrd-&gt;<a class="code" href="structnrs__orr__data.html#a48b2c0d28db24653b61bddafa0cfd098" title="XXX: We need to provide a persistently allocated string to hold unique object names...">od_objname</a>,
<a name="l00649"></a>00649                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>),
<a name="l00650"></a>00650                                            0, 0, NULL);
<a name="l00651"></a>00651         <span class="keywordflow">if</span> (orrd-&gt;od_cache == NULL)
<a name="l00652"></a>00652                 GOTO(failed, rc = -ENOMEM);
<a name="l00653"></a>00653 
<a name="l00654"></a>00654         <span class="keywordflow">if</span> (strncmp(policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a966ade252ef1fc27ced667269a199a95" title="Policy descriptor for this policy instance.">pol_desc</a>-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>, NRS_POL_NAME_ORR,
<a name="l00655"></a>00655                     NRS_POL_NAME_MAX) == 0) {
<a name="l00656"></a>00656                 ops = &amp;nrs_orr_hash_ops;
<a name="l00657"></a>00657                 cur_bits = NRS_ORR_BITS;
<a name="l00658"></a>00658                 max_bits = NRS_ORR_BITS;
<a name="l00659"></a>00659                 bkt_bits = NRS_ORR_BKT_BITS;
<a name="l00660"></a>00660                 flags = NRS_ORR_HASH_FLAGS;
<a name="l00661"></a>00661         } <span class="keywordflow">else</span> {
<a name="l00662"></a>00662                 ops = &amp;nrs_trr_hash_ops;
<a name="l00663"></a>00663                 cur_bits = NRS_TRR_BITS;
<a name="l00664"></a>00664                 max_bits = NRS_TRR_BITS;
<a name="l00665"></a>00665                 bkt_bits = NRS_TRR_BKT_BITS;
<a name="l00666"></a>00666                 flags = NRS_TRR_HASH_FLAGS;
<a name="l00667"></a>00667         }
<a name="l00668"></a>00668 
<a name="l00675"></a>00675         orrd-&gt;od_obj_hash = cfs_hash_create(orrd-&gt;<a class="code" href="structnrs__orr__data.html#a48b2c0d28db24653b61bddafa0cfd098" title="XXX: We need to provide a persistently allocated string to hold unique object names...">od_objname</a>, cur_bits,
<a name="l00676"></a>00676                                             max_bits, bkt_bits, 0,
<a name="l00677"></a>00677                                             CFS_HASH_MIN_THETA,
<a name="l00678"></a>00678                                             CFS_HASH_MAX_THETA, ops, flags);
<a name="l00679"></a>00679         <span class="keywordflow">if</span> (orrd-&gt;od_obj_hash == NULL)
<a name="l00680"></a>00680                 GOTO(failed, rc = -ENOMEM);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682         <span class="comment">/* XXX: Fields accessed unlocked */</span>
<a name="l00683"></a>00683         orrd-&gt;<a class="code" href="structnrs__orr__data.html#af0ea79af64d1d65364e08e33fed143eb" title="Round Robin quantum; the maxium number of RPCs that each request batch for each object...">od_quantum</a> = NRS_ORR_QUANTUM_DFLT;
<a name="l00684"></a>00684         orrd-&gt;<a class="code" href="structnrs__orr__data.html#a43f5f363becf4e5b91920996c99726b8" title="RPC types that are currently supported.">od_supp</a> = NOS_DFLT;
<a name="l00685"></a>00685         orrd-&gt;<a class="code" href="structnrs__orr__data.html#ae018aa64046d05c257039af8b149ba14" title="Whether to use physical disk offsets or logical file offsets.">od_physical</a> = <span class="keyword">true</span>;
<a name="l00690"></a>00690         orrd-&gt;<a class="code" href="structnrs__orr__data.html#af6de581c03e001f0c8f0a5fe54418ec0" title="Determines the relevant ordering amongst request batches within a scheduling round...">od_sequence</a> = 1;
<a name="l00691"></a>00691 
<a name="l00692"></a>00692         policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a> = orrd;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694         RETURN(rc);
<a name="l00695"></a>00695 
<a name="l00696"></a>00696 failed:
<a name="l00697"></a>00697         <span class="keywordflow">if</span> (orrd-&gt;od_cache)
<a name="l00698"></a>00698                 kmem_cache_destroy(orrd-&gt;od_cache);
<a name="l00699"></a>00699         <span class="keywordflow">if</span> (orrd-&gt;od_binheap != NULL)
<a name="l00700"></a>00700                 <a class="code" href="group__heap.html#ga5cfc116d87eae85890585d4a195db252" title="Releases all resources associated with a binary heap instance.">cfs_binheap_destroy</a>(orrd-&gt;od_binheap);
<a name="l00701"></a>00701 
<a name="l00702"></a>00702         OBD_FREE_PTR(orrd);
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         RETURN(rc);
<a name="l00705"></a>00705 }
<a name="l00706"></a>00706 
<a name="l00716"></a>00716 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_stop(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy)
<a name="l00717"></a>00717 {
<a name="l00718"></a>00718         <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a> *orrd = policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a>;
<a name="l00719"></a>00719         ENTRY;
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         LASSERT(orrd != NULL);
<a name="l00722"></a>00722         LASSERT(orrd-&gt;od_binheap != NULL);
<a name="l00723"></a>00723         LASSERT(orrd-&gt;od_obj_hash != NULL);
<a name="l00724"></a>00724         LASSERT(orrd-&gt;od_cache != NULL);
<a name="l00725"></a>00725         LASSERT(cfs_binheap_is_empty(orrd-&gt;od_binheap));
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         <a class="code" href="group__heap.html#ga5cfc116d87eae85890585d4a195db252" title="Releases all resources associated with a binary heap instance.">cfs_binheap_destroy</a>(orrd-&gt;od_binheap);
<a name="l00728"></a>00728         cfs_hash_putref(orrd-&gt;od_obj_hash);
<a name="l00729"></a>00729         kmem_cache_destroy(orrd-&gt;od_cache);
<a name="l00730"></a>00730 
<a name="l00731"></a>00731         OBD_FREE_PTR(orrd);
<a name="l00732"></a>00732 }
<a name="l00733"></a>00733 
<a name="l00748"></a>00748 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_ctl(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy,
<a name="l00749"></a>00749                        <span class="keyword">enum</span> <a class="code" href="group__nrs.html#gaa3db631148675f8074864fa452691540" title="NRS control operations.">ptlrpc_nrs_ctl</a> opc, <span class="keywordtype">void</span> *arg)
<a name="l00750"></a>00750 {
<a name="l00751"></a>00751         assert_spin_locked(&amp;policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a7975af6770c4e7082ed4d14a1b9b44d2" title="The NRS head this policy has been created at.">pol_nrs</a>-&gt;nrs_lock);
<a name="l00752"></a>00752 
<a name="l00753"></a>00753         <span class="keywordflow">switch</span>((<span class="keyword">enum</span> nrs_ctl_orr)opc) {
<a name="l00754"></a>00754         <span class="keywordflow">default</span>:
<a name="l00755"></a>00755                 RETURN(-EINVAL);
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         <span class="keywordflow">case</span> NRS_CTL_ORR_RD_QUANTUM: {
<a name="l00758"></a>00758                 <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>     *orrd = policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a>;
<a name="l00759"></a>00759 
<a name="l00760"></a>00760                 *(__u16 *)arg = orrd-&gt;<a class="code" href="structnrs__orr__data.html#af0ea79af64d1d65364e08e33fed143eb" title="Round Robin quantum; the maxium number of RPCs that each request batch for each object...">od_quantum</a>;
<a name="l00761"></a>00761                 }
<a name="l00762"></a>00762                 <span class="keywordflow">break</span>;
<a name="l00763"></a>00763 
<a name="l00764"></a>00764         <span class="keywordflow">case</span> NRS_CTL_ORR_WR_QUANTUM: {
<a name="l00765"></a>00765                 <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>     *orrd = policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a>;
<a name="l00766"></a>00766 
<a name="l00767"></a>00767                 orrd-&gt;<a class="code" href="structnrs__orr__data.html#af0ea79af64d1d65364e08e33fed143eb" title="Round Robin quantum; the maxium number of RPCs that each request batch for each object...">od_quantum</a> = *(__u16 *)arg;
<a name="l00768"></a>00768                 LASSERT(orrd-&gt;<a class="code" href="structnrs__orr__data.html#af0ea79af64d1d65364e08e33fed143eb" title="Round Robin quantum; the maxium number of RPCs that each request batch for each object...">od_quantum</a> != 0);
<a name="l00769"></a>00769                 }
<a name="l00770"></a>00770                 <span class="keywordflow">break</span>;
<a name="l00771"></a>00771 
<a name="l00772"></a>00772         <span class="keywordflow">case</span> NRS_CTL_ORR_RD_OFF_TYPE: {
<a name="l00773"></a>00773                 <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>     *orrd = policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a>;
<a name="l00774"></a>00774 
<a name="l00775"></a>00775                 *(<span class="keywordtype">bool</span> *)arg = orrd-&gt;<a class="code" href="structnrs__orr__data.html#ae018aa64046d05c257039af8b149ba14" title="Whether to use physical disk offsets or logical file offsets.">od_physical</a>;
<a name="l00776"></a>00776                 }
<a name="l00777"></a>00777                 <span class="keywordflow">break</span>;
<a name="l00778"></a>00778 
<a name="l00779"></a>00779         <span class="keywordflow">case</span> NRS_CTL_ORR_WR_OFF_TYPE: {
<a name="l00780"></a>00780                 <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>     *orrd = policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a>;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782                 orrd-&gt;<a class="code" href="structnrs__orr__data.html#ae018aa64046d05c257039af8b149ba14" title="Whether to use physical disk offsets or logical file offsets.">od_physical</a> = *(<span class="keywordtype">bool</span> *)arg;
<a name="l00783"></a>00783                 }
<a name="l00784"></a>00784                 <span class="keywordflow">break</span>;
<a name="l00785"></a>00785 
<a name="l00786"></a>00786         <span class="keywordflow">case</span> NRS_CTL_ORR_RD_SUPP_REQ: {
<a name="l00787"></a>00787                 <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>     *orrd = policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a>;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789                 *(<span class="keyword">enum</span> nrs_orr_supp *)arg = orrd-&gt;<a class="code" href="structnrs__orr__data.html#a43f5f363becf4e5b91920996c99726b8" title="RPC types that are currently supported.">od_supp</a>;
<a name="l00790"></a>00790                 }
<a name="l00791"></a>00791                 <span class="keywordflow">break</span>;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793         <span class="keywordflow">case</span> NRS_CTL_ORR_WR_SUPP_REQ: {
<a name="l00794"></a>00794                 <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>     *orrd = policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a>;
<a name="l00795"></a>00795 
<a name="l00796"></a>00796                 orrd-&gt;<a class="code" href="structnrs__orr__data.html#a43f5f363becf4e5b91920996c99726b8" title="RPC types that are currently supported.">od_supp</a> = *(<span class="keyword">enum</span> nrs_orr_supp *)arg;
<a name="l00797"></a>00797                 LASSERT((orrd-&gt;<a class="code" href="structnrs__orr__data.html#a43f5f363becf4e5b91920996c99726b8" title="RPC types that are currently supported.">od_supp</a> &amp; NOS_OST_RW) != 0);
<a name="l00798"></a>00798                 }
<a name="l00799"></a>00799                 <span class="keywordflow">break</span>;
<a name="l00800"></a>00800         }
<a name="l00801"></a>00801         RETURN(0);
<a name="l00802"></a>00802 }
<a name="l00803"></a>00803 
<a name="l00826"></a>00826 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_res_get(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy,
<a name="l00827"></a>00827                            <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq,
<a name="l00828"></a>00828                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__resource.html" title="NRS resource.">ptlrpc_nrs_resource</a> *parent,
<a name="l00829"></a>00829                            <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__resource.html" title="NRS resource.">ptlrpc_nrs_resource</a> **resp, <span class="keywordtype">bool</span> moving_req)
<a name="l00830"></a>00830 {
<a name="l00831"></a>00831         <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>            *orrd;
<a name="l00832"></a>00832         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>          *orro;
<a name="l00833"></a>00833         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>          *tmp;
<a name="l00834"></a>00834         <span class="keyword">struct </span><a class="code" href="structnrs__orr__key.html" title="As unique keys for grouping RPCs together, we use the object&amp;#39;s OST FID for the...">nrs_orr_key</a>              key = { { { 0 } } };
<a name="l00835"></a>00835         __u32                           opc;
<a name="l00836"></a>00836         <span class="keywordtype">int</span>                             rc = 0;
<a name="l00837"></a>00837 
<a name="l00841"></a>00841         <span class="keywordflow">if</span> (parent == NULL) {
<a name="l00842"></a>00842                 *resp = &amp;((<span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a> *)policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a>)-&gt;od_res;
<a name="l00843"></a>00843                 <span class="keywordflow">return</span> 0;
<a name="l00844"></a>00844         }
<a name="l00845"></a>00845 
<a name="l00846"></a>00846         orrd = container_of(parent, <span class="keyword">struct</span> <a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>, od_res);
<a name="l00847"></a>00847 
<a name="l00852"></a>00852         <span class="keywordflow">if</span> (!nrs_orr_req_supported(orrd, nrq, &amp;opc))
<a name="l00853"></a>00853                 <span class="keywordflow">return</span> -1;
<a name="l00854"></a>00854 
<a name="l00859"></a>00859         rc = nrs_orr_key_fill(orrd, nrq, opc, policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a966ade252ef1fc27ced667269a199a95" title="Policy descriptor for this policy instance.">pol_desc</a>-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>, &amp;key);
<a name="l00860"></a>00860         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00861"></a>00861                 RETURN(rc);
<a name="l00862"></a>00862 
<a name="l00866"></a>00866         rc = nrs_orr_range_fill(nrq, orrd, opc, moving_req);
<a name="l00867"></a>00867         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00868"></a>00868                 RETURN(rc);
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         orro = cfs_hash_lookup(orrd-&gt;od_obj_hash, &amp;key);
<a name="l00871"></a>00871         <span class="keywordflow">if</span> (orro != NULL)
<a name="l00872"></a>00872                 <span class="keywordflow">goto</span> out;
<a name="l00873"></a>00873 
<a name="l00874"></a>00874         OBD_SLAB_CPT_ALLOC_PTR_GFP(orro, orrd-&gt;od_cache,
<a name="l00875"></a>00875                                    nrs_pol2cptab(policy), nrs_pol2cptid(policy),
<a name="l00876"></a>00876                                    moving_req ? GFP_ATOMIC : GFP_NOFS);
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (orro == NULL)
<a name="l00878"></a>00878                 RETURN(-ENOMEM);
<a name="l00879"></a>00879 
<a name="l00880"></a>00880         orro-&gt;<a class="code" href="structnrs__orr__object.html#a20e1ce9fee23cabc705d4abfe3e81ebf" title="The key of the object or OST for which this structure instance is scheduling RPCs...">oo_key</a> = key;
<a name="l00881"></a>00881         orro-&gt;oo_ref = 1;
<a name="l00882"></a>00882 
<a name="l00883"></a>00883         tmp = cfs_hash_findadd_unique(orrd-&gt;od_obj_hash, &amp;orro-&gt;<a class="code" href="structnrs__orr__object.html#a20e1ce9fee23cabc705d4abfe3e81ebf" title="The key of the object or OST for which this structure instance is scheduling RPCs...">oo_key</a>,
<a name="l00884"></a>00884                                       &amp;orro-&gt;oo_hnode);
<a name="l00885"></a>00885         <span class="keywordflow">if</span> (tmp != orro) {
<a name="l00886"></a>00886                 OBD_SLAB_FREE_PTR(orro, orrd-&gt;od_cache);
<a name="l00887"></a>00887                 orro = tmp;
<a name="l00888"></a>00888         }
<a name="l00889"></a>00889 out:
<a name="l00893"></a>00893         nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a95e38aab4f159e38fae5a89bb4e0f021" title="For debugging purposes.">or_key</a> = orro-&gt;<a class="code" href="structnrs__orr__object.html#a20e1ce9fee23cabc705d4abfe3e81ebf" title="The key of the object or OST for which this structure instance is scheduling RPCs...">oo_key</a>;
<a name="l00894"></a>00894 
<a name="l00895"></a>00895         *resp = &amp;orro-&gt;oo_res;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897         <span class="keywordflow">return</span> 1;
<a name="l00898"></a>00898 }
<a name="l00899"></a>00899 
<a name="l00907"></a>00907 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_res_put(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy,
<a name="l00908"></a>00908                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__resource.html" title="NRS resource.">ptlrpc_nrs_resource</a> *res)
<a name="l00909"></a>00909 {
<a name="l00910"></a>00910         <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>     *orrd;
<a name="l00911"></a>00911         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>   *orro;
<a name="l00912"></a>00912 
<a name="l00916"></a>00916         <span class="keywordflow">if</span> (res-&gt;<a class="code" href="structptlrpc__nrs__resource.html#ad0e4dbe1fe93c3751bf54b78c6d81abd" title="This NRS resource&amp;#39;s parent; is NULL for resources embedded in NRS policy instances;...">res_parent</a> == NULL)
<a name="l00917"></a>00917                 <span class="keywordflow">return</span>;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         orro = container_of(res, <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>, oo_res);
<a name="l00920"></a>00920         orrd = container_of(res-&gt;<a class="code" href="structptlrpc__nrs__resource.html#ad0e4dbe1fe93c3751bf54b78c6d81abd" title="This NRS resource&amp;#39;s parent; is NULL for resources embedded in NRS policy instances;...">res_parent</a>, <span class="keyword">struct</span> <a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>, od_res);
<a name="l00921"></a>00921 
<a name="l00922"></a>00922         cfs_hash_put(orrd-&gt;od_obj_hash, &amp;orro-&gt;oo_hnode);
<a name="l00923"></a>00923 }
<a name="l00924"></a>00924 
<a name="l00943"></a>00943 <span class="keyword">static</span>
<a name="l00944"></a>00944 <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrs_orr_req_get(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy,
<a name="l00945"></a>00945                                            <span class="keywordtype">bool</span> peek, <span class="keywordtype">bool</span> force)
<a name="l00946"></a>00946 {
<a name="l00947"></a>00947         <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>       *orrd = policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a65f5afb21e9da75ae93e9b0b64887272" title="Private policy data; varies by policy type.">pol_private</a>;
<a name="l00948"></a>00948         <span class="keyword">struct </span><a class="code" href="structcfs__binheap__node.html" title="Binary heap node.">cfs_binheap_node</a>   *node = cfs_binheap_root(orrd-&gt;od_binheap);
<a name="l00949"></a>00949         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq;
<a name="l00950"></a>00950 
<a name="l00951"></a>00951         nrq = unlikely(node == NULL) ? NULL :
<a name="l00952"></a>00952               container_of(node, <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a>, nr_node);
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         <span class="keywordflow">if</span> (likely(!peek &amp;&amp; nrq != NULL)) {
<a name="l00955"></a>00955                 <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a> *orro;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957                 orro = container_of(nrs_request_resource(nrq),
<a name="l00958"></a>00958                                     <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>, oo_res);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960                 LASSERT(nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a> &lt;= orro-&gt;<a class="code" href="structnrs__orr__object.html#af354a979a7993266e923912ac8b0e2ad" title="The round number against which requests are being scheduled for this object or OST...">oo_round</a>);
<a name="l00961"></a>00961 
<a name="l00962"></a>00962                 <a class="code" href="group__heap.html#ga2508e7b6c81ff6b17dae6189dd410e26" title="Removes a node from the binary heap.">cfs_binheap_remove</a>(orrd-&gt;od_binheap, &amp;nrq-&gt;nr_node);
<a name="l00963"></a>00963                 orro-&gt;<a class="code" href="structnrs__orr__object.html#a1f1baa427ff3737ab157921ad205b8f6" title="# of pending requests for this object or OST, on all existing rounds">oo_active</a>--;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965                 <span class="keywordflow">if</span> (strncmp(policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a966ade252ef1fc27ced667269a199a95" title="Policy descriptor for this policy instance.">pol_desc</a>-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>, NRS_POL_NAME_ORR,
<a name="l00966"></a>00966                                  NRS_POL_NAME_MAX) == 0)
<a name="l00967"></a>00967                         CDEBUG(D_RPCTRACE,
<a name="l00968"></a>00968                                <span class="stringliteral">&quot;NRS: starting to handle %s request for object &quot;</span>
<a name="l00969"></a>00969                                <span class="stringliteral">&quot;with FID &quot;</span>DFID<span class="stringliteral">&quot;, from OST with index %u, with &quot;</span>
<a name="l00970"></a>00970                                <span class="stringliteral">&quot;round &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>, NRS_POL_NAME_ORR,
<a name="l00971"></a>00971                                PFID(&amp;orro-&gt;<a class="code" href="structnrs__orr__object.html#a20e1ce9fee23cabc705d4abfe3e81ebf" title="The key of the object or OST for which this structure instance is scheduling RPCs...">oo_key</a>.<a class="code" href="structnrs__orr__key.html#aadc407f51783ee56827551dacda307ff" title="object FID for ORR">ok_fid</a>),
<a name="l00972"></a>00972                                nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a95e38aab4f159e38fae5a89bb4e0f021" title="For debugging purposes.">or_key</a>.<a class="code" href="structnrs__orr__key.html#a552903e8e7499e085caedc764fc5e2b1" title="OST index for TRR.">ok_idx</a>,
<a name="l00973"></a>00973                                nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>);
<a name="l00974"></a>00974                 <span class="keywordflow">else</span>
<a name="l00975"></a>00975                         CDEBUG(D_RPCTRACE,
<a name="l00976"></a>00976                                <span class="stringliteral">&quot;NRS: starting to handle %s request from OST &quot;</span>
<a name="l00977"></a>00977                                <span class="stringliteral">&quot;with index %u, with round &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00978"></a>00978                                NRS_POL_NAME_TRR, nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a95e38aab4f159e38fae5a89bb4e0f021" title="For debugging purposes.">or_key</a>.<a class="code" href="structnrs__orr__key.html#a552903e8e7499e085caedc764fc5e2b1" title="OST index for TRR.">ok_idx</a>,
<a name="l00979"></a>00979                                nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>);
<a name="l00980"></a>00980 
<a name="l00982"></a>00982                 node = cfs_binheap_root(orrd-&gt;od_binheap);
<a name="l00983"></a>00983 
<a name="l00985"></a>00985                 <span class="keywordflow">if</span> (unlikely(node == NULL)) {
<a name="l00986"></a>00986                         orrd-&gt;<a class="code" href="structnrs__orr__data.html#a6b4cba253af6e9e2303e2a5cafaf949a" title="Used when a new scheduling round commences, in order to synchronize all object or...">od_round</a>++;
<a name="l00987"></a>00987                 } <span class="keywordflow">else</span> {
<a name="l00988"></a>00988                         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *next;
<a name="l00989"></a>00989 
<a name="l00990"></a>00990                         next = container_of(node, <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a>,
<a name="l00991"></a>00991                                             nr_node);
<a name="l00992"></a>00992 
<a name="l00993"></a>00993                         <span class="keywordflow">if</span> (orrd-&gt;<a class="code" href="structnrs__orr__data.html#a6b4cba253af6e9e2303e2a5cafaf949a" title="Used when a new scheduling round commences, in order to synchronize all object or...">od_round</a> &lt; next-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>)
<a name="l00994"></a>00994                                 orrd-&gt;<a class="code" href="structnrs__orr__data.html#a6b4cba253af6e9e2303e2a5cafaf949a" title="Used when a new scheduling round commences, in order to synchronize all object or...">od_round</a> = next-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>;
<a name="l00995"></a>00995                 }
<a name="l00996"></a>00996         }
<a name="l00997"></a>00997 
<a name="l00998"></a>00998         <span class="keywordflow">return</span> nrq;
<a name="l00999"></a>00999 }
<a name="l01000"></a>01000 
<a name="l01034"></a>01034 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_req_add(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy,
<a name="l01035"></a>01035                            <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq)
<a name="l01036"></a>01036 {
<a name="l01037"></a>01037         <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>     *orrd;
<a name="l01038"></a>01038         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>   *orro;
<a name="l01039"></a>01039         <span class="keywordtype">int</span>                      rc;
<a name="l01040"></a>01040 
<a name="l01041"></a>01041         orro = container_of(nrs_request_resource(nrq),
<a name="l01042"></a>01042                             <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>, oo_res);
<a name="l01043"></a>01043         orrd = container_of(nrs_request_resource(nrq)-&gt;res_parent,
<a name="l01044"></a>01044                             <span class="keyword">struct</span> <a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>, od_res);
<a name="l01045"></a>01045 
<a name="l01046"></a>01046         <span class="keywordflow">if</span> (orro-&gt;<a class="code" href="structnrs__orr__object.html#a685bde1b48a1890024a6062427c9e579" title="Round Robin quantum; the maximum number of RPCs that are allowed to be scheduled...">oo_quantum</a> == 0 || orro-&gt;<a class="code" href="structnrs__orr__object.html#af354a979a7993266e923912ac8b0e2ad" title="The round number against which requests are being scheduled for this object or OST...">oo_round</a> &lt; orrd-&gt;<a class="code" href="structnrs__orr__data.html#a6b4cba253af6e9e2303e2a5cafaf949a" title="Used when a new scheduling round commences, in order to synchronize all object or...">od_round</a> ||
<a name="l01047"></a>01047             (orro-&gt;<a class="code" href="structnrs__orr__object.html#a1f1baa427ff3737ab157921ad205b8f6" title="# of pending requests for this object or OST, on all existing rounds">oo_active</a> == 0 &amp;&amp; orro-&gt;<a class="code" href="structnrs__orr__object.html#a685bde1b48a1890024a6062427c9e579" title="Round Robin quantum; the maximum number of RPCs that are allowed to be scheduled...">oo_quantum</a> &gt; 0)) {
<a name="l01048"></a>01048 
<a name="l01060"></a>01060                 <span class="keywordflow">if</span> (orro-&gt;<a class="code" href="structnrs__orr__object.html#a1f1baa427ff3737ab157921ad205b8f6" title="# of pending requests for this object or OST, on all existing rounds">oo_active</a> == 0 &amp;&amp; orro-&gt;<a class="code" href="structnrs__orr__object.html#a685bde1b48a1890024a6062427c9e579" title="Round Robin quantum; the maximum number of RPCs that are allowed to be scheduled...">oo_quantum</a> &gt; 0)
<a name="l01061"></a>01061                         orro-&gt;<a class="code" href="structnrs__orr__object.html#af354a979a7993266e923912ac8b0e2ad" title="The round number against which requests are being scheduled for this object or OST...">oo_round</a>++;
<a name="l01062"></a>01062 
<a name="l01064"></a>01064                 <span class="keywordflow">if</span> (orro-&gt;<a class="code" href="structnrs__orr__object.html#af354a979a7993266e923912ac8b0e2ad" title="The round number against which requests are being scheduled for this object or OST...">oo_round</a> &lt; orrd-&gt;<a class="code" href="structnrs__orr__data.html#a6b4cba253af6e9e2303e2a5cafaf949a" title="Used when a new scheduling round commences, in order to synchronize all object or...">od_round</a>)
<a name="l01065"></a>01065                         orro-&gt;<a class="code" href="structnrs__orr__object.html#af354a979a7993266e923912ac8b0e2ad" title="The round number against which requests are being scheduled for this object or OST...">oo_round</a> = orrd-&gt;<a class="code" href="structnrs__orr__data.html#a6b4cba253af6e9e2303e2a5cafaf949a" title="Used when a new scheduling round commences, in order to synchronize all object or...">od_round</a>;
<a name="l01066"></a>01066 
<a name="l01068"></a>01068                 <span class="keywordflow">if</span> (orro-&gt;<a class="code" href="structnrs__orr__object.html#a7c305a16532e773b7bca5f48d2444ac7" title="The sequence number used for requests scheduled for this object or OST during the...">oo_sequence</a> &lt; orrd-&gt;<a class="code" href="structnrs__orr__data.html#af6de581c03e001f0c8f0a5fe54418ec0" title="Determines the relevant ordering amongst request batches within a scheduling round...">od_sequence</a>)
<a name="l01069"></a>01069                         orro-&gt;<a class="code" href="structnrs__orr__object.html#a7c305a16532e773b7bca5f48d2444ac7" title="The sequence number used for requests scheduled for this object or OST during the...">oo_sequence</a> = ++orrd-&gt;<a class="code" href="structnrs__orr__data.html#af6de581c03e001f0c8f0a5fe54418ec0" title="Determines the relevant ordering amongst request batches within a scheduling round...">od_sequence</a>;
<a name="l01076"></a>01076                 orro-&gt;<a class="code" href="structnrs__orr__object.html#a685bde1b48a1890024a6062427c9e579" title="Round Robin quantum; the maximum number of RPCs that are allowed to be scheduled...">oo_quantum</a> = orrd-&gt;<a class="code" href="structnrs__orr__data.html#af0ea79af64d1d65364e08e33fed143eb" title="Round Robin quantum; the maxium number of RPCs that each request batch for each object...">od_quantum</a>;
<a name="l01077"></a>01077         }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079         nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a> = orro-&gt;<a class="code" href="structnrs__orr__object.html#af354a979a7993266e923912ac8b0e2ad" title="The round number against which requests are being scheduled for this object or OST...">oo_round</a>;
<a name="l01080"></a>01080         nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#af8f7e76e2146293803f3df4b13d56838" title="Sequence number for this request; shared with all other requests in the same batch...">or_sequence</a> = orro-&gt;<a class="code" href="structnrs__orr__object.html#a7c305a16532e773b7bca5f48d2444ac7" title="The sequence number used for requests scheduled for this object or OST during the...">oo_sequence</a>;
<a name="l01081"></a>01081 
<a name="l01082"></a>01082         rc = <a class="code" href="group__heap.html#gad2addbe43a8767c18143e564f3384033" title="Sort-inserts a node into the binary heap.">cfs_binheap_insert</a>(orrd-&gt;od_binheap, &amp;nrq-&gt;nr_node);
<a name="l01083"></a>01083         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01084"></a>01084                 orro-&gt;<a class="code" href="structnrs__orr__object.html#a1f1baa427ff3737ab157921ad205b8f6" title="# of pending requests for this object or OST, on all existing rounds">oo_active</a>++;
<a name="l01085"></a>01085                 <span class="keywordflow">if</span> (--orro-&gt;<a class="code" href="structnrs__orr__object.html#a685bde1b48a1890024a6062427c9e579" title="Round Robin quantum; the maximum number of RPCs that are allowed to be scheduled...">oo_quantum</a> == 0)
<a name="l01086"></a>01086                         orro-&gt;<a class="code" href="structnrs__orr__object.html#af354a979a7993266e923912ac8b0e2ad" title="The round number against which requests are being scheduled for this object or OST...">oo_round</a>++;
<a name="l01087"></a>01087         }
<a name="l01088"></a>01088         <span class="keywordflow">return</span> rc;
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 
<a name="l01098"></a>01098 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_req_del(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy,
<a name="l01099"></a>01099                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq)
<a name="l01100"></a>01100 {
<a name="l01101"></a>01101         <span class="keyword">struct </span><a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>     *orrd;
<a name="l01102"></a>01102         <span class="keyword">struct </span><a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>   *orro;
<a name="l01103"></a>01103         <span class="keywordtype">bool</span>                     is_root;
<a name="l01104"></a>01104 
<a name="l01105"></a>01105         orro = container_of(nrs_request_resource(nrq),
<a name="l01106"></a>01106                             <span class="keyword">struct</span> <a class="code" href="structnrs__orr__object.html" title="Represents a backend-fs object or OST in the ORR and TRR policies respectively.">nrs_orr_object</a>, oo_res);
<a name="l01107"></a>01107         orrd = container_of(nrs_request_resource(nrq)-&gt;res_parent,
<a name="l01108"></a>01108                             <span class="keyword">struct</span> <a class="code" href="structnrs__orr__data.html" title="private data structure for ORR and TRR NRS">nrs_orr_data</a>, od_res);
<a name="l01109"></a>01109 
<a name="l01110"></a>01110         LASSERT(nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a> &lt;= orro-&gt;<a class="code" href="structnrs__orr__object.html#af354a979a7993266e923912ac8b0e2ad" title="The round number against which requests are being scheduled for this object or OST...">oo_round</a>);
<a name="l01111"></a>01111 
<a name="l01112"></a>01112         is_root = &amp;nrq-&gt;nr_node == cfs_binheap_root(orrd-&gt;od_binheap);
<a name="l01113"></a>01113 
<a name="l01114"></a>01114         <a class="code" href="group__heap.html#ga2508e7b6c81ff6b17dae6189dd410e26" title="Removes a node from the binary heap.">cfs_binheap_remove</a>(orrd-&gt;od_binheap, &amp;nrq-&gt;nr_node);
<a name="l01115"></a>01115         orro-&gt;<a class="code" href="structnrs__orr__object.html#a1f1baa427ff3737ab157921ad205b8f6" title="# of pending requests for this object or OST, on all existing rounds">oo_active</a>--;
<a name="l01116"></a>01116 
<a name="l01121"></a>01121         <span class="keywordflow">if</span> (unlikely(is_root)) {
<a name="l01123"></a>01123                 <span class="keyword">struct </span><a class="code" href="structcfs__binheap__node.html" title="Binary heap node.">cfs_binheap_node</a> *node = cfs_binheap_root(orrd-&gt;od_binheap);
<a name="l01124"></a>01124 
<a name="l01126"></a>01126                 <span class="keywordflow">if</span> (unlikely(node == NULL)) {
<a name="l01127"></a>01127                         orrd-&gt;<a class="code" href="structnrs__orr__data.html#a6b4cba253af6e9e2303e2a5cafaf949a" title="Used when a new scheduling round commences, in order to synchronize all object or...">od_round</a>++;
<a name="l01128"></a>01128                 } <span class="keywordflow">else</span> {
<a name="l01129"></a>01129                         nrq = container_of(node, <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a>,
<a name="l01130"></a>01130                                            nr_node);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132                         <span class="keywordflow">if</span> (orrd-&gt;<a class="code" href="structnrs__orr__data.html#a6b4cba253af6e9e2303e2a5cafaf949a" title="Used when a new scheduling round commences, in order to synchronize all object or...">od_round</a> &lt; nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>)
<a name="l01133"></a>01133                                 orrd-&gt;<a class="code" href="structnrs__orr__data.html#a6b4cba253af6e9e2303e2a5cafaf949a" title="Used when a new scheduling round commences, in order to synchronize all object or...">od_round</a> = nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>;
<a name="l01134"></a>01134                 }
<a name="l01135"></a>01135         }
<a name="l01136"></a>01136 }
<a name="l01137"></a>01137 
<a name="l01145"></a>01145 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_req_stop(<span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> *policy,
<a name="l01146"></a>01146                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a> *nrq)
<a name="l01147"></a>01147 {
<a name="l01149"></a>01149         <span class="keywordflow">if</span> (strncmp(policy-&gt;<a class="code" href="structptlrpc__nrs__policy.html#a966ade252ef1fc27ced667269a199a95" title="Policy descriptor for this policy instance.">pol_desc</a>-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>, NRS_POL_NAME_ORR,
<a name="l01150"></a>01150                     NRS_POL_NAME_MAX) == 0)
<a name="l01151"></a>01151                 CDEBUG(D_RPCTRACE,
<a name="l01152"></a>01152                        <span class="stringliteral">&quot;NRS: finished handling %s request for object with FID &quot;</span>
<a name="l01153"></a>01153                        DFID<span class="stringliteral">&quot;, from OST with index %u, with round &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01154"></a>01154                        NRS_POL_NAME_ORR, PFID(&amp;nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a95e38aab4f159e38fae5a89bb4e0f021" title="For debugging purposes.">or_key</a>.<a class="code" href="structnrs__orr__key.html#aadc407f51783ee56827551dacda307ff" title="object FID for ORR">ok_fid</a>),
<a name="l01155"></a>01155                        nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a95e38aab4f159e38fae5a89bb4e0f021" title="For debugging purposes.">or_key</a>.<a class="code" href="structnrs__orr__key.html#a552903e8e7499e085caedc764fc5e2b1" title="OST index for TRR.">ok_idx</a>, nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>);
<a name="l01156"></a>01156         <span class="keywordflow">else</span>
<a name="l01157"></a>01157                 CDEBUG(D_RPCTRACE,
<a name="l01158"></a>01158                        <span class="stringliteral">&quot;NRS: finished handling %s request from OST with index %u,&quot;</span>
<a name="l01159"></a>01159                        <span class="stringliteral">&quot; with round &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01160"></a>01160                        NRS_POL_NAME_TRR, nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#a95e38aab4f159e38fae5a89bb4e0f021" title="For debugging purposes.">or_key</a>.<a class="code" href="structnrs__orr__key.html#a552903e8e7499e085caedc764fc5e2b1" title="OST index for TRR.">ok_idx</a>,
<a name="l01161"></a>01161                        nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#acbdc1427ee55ee33c12d38a71a262f05" title="Policy-specific fields, used for determining a request&amp;#39;s scheduling priority...">nr_u</a>.<a class="code" href="structptlrpc__nrs__request.html#a557196ff063c995ef5ea81fd1ff03f4f" title="ORR and TRR share the same request definition.">orr</a>.<a class="code" href="structnrs__orr__req.html#ab6fd2264717bd7fd9a5fe3920f997f39" title="Round number for this request; shared with all other requests in the same batch.">or_round</a>);
<a name="l01162"></a>01162 }
<a name="l01163"></a>01163 
<a name="l01168"></a>01168 <span class="preprocessor">#ifdef CONFIG_PROC_FS</span>
<a name="l01169"></a>01169 <span class="preprocessor"></span>
<a name="l01175"></a>01175 <span class="keyword">static</span> <span class="keyword">struct </span>nrs_lprocfs_orr_data {
<a name="l01176"></a>01176         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>   *svc;
<a name="l01177"></a>01177         <span class="keywordtype">char</span>                    *name;
<a name="l01178"></a>01178 } lprocfs_orr_data = {
<a name="l01179"></a>01179         .name = NRS_POL_NAME_ORR
<a name="l01180"></a>01180 }, lprocfs_trr_data = {
<a name="l01181"></a>01181         .name = NRS_POL_NAME_TRR
<a name="l01182"></a>01182 };
<a name="l01183"></a>01183 
<a name="l01201"></a>01201 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01202"></a>01202 ptlrpc_lprocfs_nrs_orr_quantum_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01203"></a>01203 {
<a name="l01204"></a>01204         <span class="keyword">struct </span>nrs_lprocfs_orr_data *orr_data = m-&gt;private;
<a name="l01205"></a>01205         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>       *svc = orr_data-&gt;svc;
<a name="l01206"></a>01206         __u16                        quantum;
<a name="l01207"></a>01207         <span class="keywordtype">int</span>                          rc;
<a name="l01208"></a>01208 
<a name="l01214"></a>01214         rc = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_REG,
<a name="l01215"></a>01215                                        orr_data-&gt;name,
<a name="l01216"></a>01216                                        NRS_CTL_ORR_RD_QUANTUM,
<a name="l01217"></a>01217                                        <span class="keyword">true</span>, &amp;quantum);
<a name="l01218"></a>01218         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01219"></a>01219                 seq_printf(m, NRS_LPROCFS_QUANTUM_NAME_REG <span class="stringliteral">&quot;%-5d\n&quot;</span>, quantum);
<a name="l01224"></a>01224         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENODEV) {
<a name="l01225"></a>01225                 <span class="keywordflow">return</span> rc;
<a name="l01226"></a>01226         }
<a name="l01227"></a>01227 
<a name="l01233"></a>01233         <span class="keywordflow">if</span> (!nrs_svc_has_hp(svc))
<a name="l01234"></a>01234                 <span class="keywordflow">goto</span> no_hp;
<a name="l01235"></a>01235 
<a name="l01236"></a>01236         rc = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_HP,
<a name="l01237"></a>01237                                        orr_data-&gt;name, NRS_CTL_ORR_RD_QUANTUM,
<a name="l01238"></a>01238                                        <span class="keyword">true</span>, &amp;quantum);
<a name="l01239"></a>01239         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01240"></a>01240                 seq_printf(m, NRS_LPROCFS_QUANTUM_NAME_HP<span class="stringliteral">&quot;%-5d\n&quot;</span>, quantum);
<a name="l01245"></a>01245         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENODEV) {
<a name="l01246"></a>01246                 <span class="keywordflow">return</span> rc;
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248 
<a name="l01249"></a>01249 no_hp:
<a name="l01250"></a>01250 
<a name="l01251"></a>01251         <span class="keywordflow">return</span> rc;
<a name="l01252"></a>01252 }
<a name="l01253"></a>01253 
<a name="l01280"></a>01280 <span class="keyword">static</span> ssize_t
<a name="l01281"></a>01281 ptlrpc_lprocfs_nrs_orr_quantum_seq_write(<span class="keyword">struct</span> file *file,
<a name="l01282"></a>01282                                          <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l01283"></a>01283                                          <span class="keywordtype">size_t</span> count, loff_t *off)
<a name="l01284"></a>01284 {
<a name="l01285"></a>01285         <span class="keyword">struct </span>seq_file             *m = file-&gt;private_data;
<a name="l01286"></a>01286         <span class="keyword">struct </span>nrs_lprocfs_orr_data *orr_data = m-&gt;private;
<a name="l01287"></a>01287         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>       *svc = orr_data-&gt;svc;
<a name="l01288"></a>01288         <span class="keyword">enum</span> <a class="code" href="group__nrs.html#ga79e63c48a144326744316f397c52a883" title="NRS queue type.">ptlrpc_nrs_queue_type</a>   queue = 0;
<a name="l01289"></a>01289         <span class="keywordtype">char</span>                         kernbuf[LPROCFS_NRS_WR_QUANTUM_MAX_CMD];
<a name="l01290"></a>01290         <span class="keywordtype">char</span>                        *val;
<a name="l01291"></a>01291         <span class="keywordtype">long</span>                         quantum_reg;
<a name="l01292"></a>01292         <span class="keywordtype">long</span>                         quantum_hp;
<a name="l01294"></a>01294         <span class="keywordtype">size_t</span>                       count_copy;
<a name="l01295"></a>01295         <span class="keywordtype">int</span>                          rc = 0;
<a name="l01296"></a>01296         <span class="keywordtype">int</span>                          rc2 = 0;
<a name="l01297"></a>01297 
<a name="l01298"></a>01298         <span class="keywordflow">if</span> (count &gt; (<span class="keyword">sizeof</span>(kernbuf) - 1))
<a name="l01299"></a>01299                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301         <span class="keywordflow">if</span> (copy_from_user(kernbuf, buffer, count))
<a name="l01302"></a>01302                 <span class="keywordflow">return</span> -EFAULT;
<a name="l01303"></a>01303 
<a name="l01304"></a>01304         kernbuf[count] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01305"></a>01305 
<a name="l01306"></a>01306         count_copy = count;
<a name="l01307"></a>01307 
<a name="l01311"></a>01311         val = lprocfs_find_named_value(kernbuf, NRS_LPROCFS_QUANTUM_NAME_REG,
<a name="l01312"></a>01312                                        &amp;count_copy);
<a name="l01313"></a>01313         <span class="keywordflow">if</span> (val != kernbuf) {
<a name="l01314"></a>01314                 quantum_reg = simple_strtol(val, NULL, 10);
<a name="l01315"></a>01315 
<a name="l01316"></a>01316                 queue |= PTLRPC_NRS_QUEUE_REG;
<a name="l01317"></a>01317         }
<a name="l01318"></a>01318 
<a name="l01319"></a>01319         count_copy = count;
<a name="l01320"></a>01320 
<a name="l01324"></a>01324         val = lprocfs_find_named_value(kernbuf, NRS_LPROCFS_QUANTUM_NAME_HP,
<a name="l01325"></a>01325                                        &amp;count_copy);
<a name="l01326"></a>01326         <span class="keywordflow">if</span> (val != kernbuf) {
<a name="l01327"></a>01327                 <span class="keywordflow">if</span> (!nrs_svc_has_hp(svc))
<a name="l01328"></a>01328                         <span class="keywordflow">return</span> -ENODEV;
<a name="l01329"></a>01329 
<a name="l01330"></a>01330                 quantum_hp = simple_strtol(val, NULL, 10);
<a name="l01331"></a>01331 
<a name="l01332"></a>01332                 queue |= PTLRPC_NRS_QUEUE_HP;
<a name="l01333"></a>01333         }
<a name="l01334"></a>01334 
<a name="l01339"></a>01339         <span class="keywordflow">if</span> (queue == 0) {
<a name="l01340"></a>01340                 <span class="keywordflow">if</span> (!isdigit(kernbuf[0]))
<a name="l01341"></a>01341                         <span class="keywordflow">return</span> -EINVAL;
<a name="l01342"></a>01342 
<a name="l01343"></a>01343                 quantum_reg = simple_strtol(kernbuf, NULL, 10);
<a name="l01344"></a>01344 
<a name="l01345"></a>01345                 queue = PTLRPC_NRS_QUEUE_REG;
<a name="l01346"></a>01346 
<a name="l01347"></a>01347                 <span class="keywordflow">if</span> (nrs_svc_has_hp(svc)) {
<a name="l01348"></a>01348                         queue |= PTLRPC_NRS_QUEUE_HP;
<a name="l01349"></a>01349                         quantum_hp = quantum_reg;
<a name="l01350"></a>01350                 }
<a name="l01351"></a>01351         }
<a name="l01352"></a>01352 
<a name="l01353"></a>01353         <span class="keywordflow">if</span> ((((queue &amp; PTLRPC_NRS_QUEUE_REG) != 0) &amp;&amp;
<a name="l01354"></a>01354             ((quantum_reg &gt; LPROCFS_NRS_QUANTUM_MAX || quantum_reg &lt;= 0))) ||
<a name="l01355"></a>01355             (((queue &amp; PTLRPC_NRS_QUEUE_HP) != 0) &amp;&amp;
<a name="l01356"></a>01356             ((quantum_hp &gt; LPROCFS_NRS_QUANTUM_MAX || quantum_hp &lt;= 0))))
<a name="l01357"></a>01357                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01358"></a>01358 
<a name="l01369"></a>01369         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_REG) != 0) {
<a name="l01370"></a>01370                 rc = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_REG,
<a name="l01371"></a>01371                                                orr_data-&gt;name,
<a name="l01372"></a>01372                                                NRS_CTL_ORR_WR_QUANTUM, <span class="keyword">false</span>,
<a name="l01373"></a>01373                                                &amp;quantum_reg);
<a name="l01374"></a>01374                 <span class="keywordflow">if</span> ((rc &lt; 0 &amp;&amp; rc != -ENODEV) ||
<a name="l01375"></a>01375                     (rc == -ENODEV &amp;&amp; queue == PTLRPC_NRS_QUEUE_REG))
<a name="l01376"></a>01376                         <span class="keywordflow">return</span> rc;
<a name="l01377"></a>01377         }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_HP) != 0) {
<a name="l01380"></a>01380                 rc2 = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_HP,
<a name="l01381"></a>01381                                                 orr_data-&gt;name,
<a name="l01382"></a>01382                                                 NRS_CTL_ORR_WR_QUANTUM, <span class="keyword">false</span>,
<a name="l01383"></a>01383                                                 &amp;quantum_hp);
<a name="l01384"></a>01384                 <span class="keywordflow">if</span> ((rc2 &lt; 0 &amp;&amp; rc2 != -ENODEV) ||
<a name="l01385"></a>01385                     (rc2 == -ENODEV &amp;&amp; queue == PTLRPC_NRS_QUEUE_HP))
<a name="l01386"></a>01386                         <span class="keywordflow">return</span> rc2;
<a name="l01387"></a>01387         }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389         <span class="keywordflow">return</span> rc == -ENODEV &amp;&amp; rc2 == -ENODEV ? -ENODEV : count;
<a name="l01390"></a>01390 }
<a name="l01391"></a>01391 LPROC_SEQ_FOPS(ptlrpc_lprocfs_nrs_orr_quantum);
<a name="l01392"></a>01392 
<a name="l01393"></a>01393 <span class="preprocessor">#define LPROCFS_NRS_OFF_NAME_REG                &quot;reg_offset_type:&quot;</span>
<a name="l01394"></a>01394 <span class="preprocessor"></span><span class="preprocessor">#define LPROCFS_NRS_OFF_NAME_HP                 &quot;hp_offset_type:&quot;</span>
<a name="l01395"></a>01395 <span class="preprocessor"></span>
<a name="l01396"></a>01396 <span class="preprocessor">#define LPROCFS_NRS_OFF_NAME_PHYSICAL           &quot;physical&quot;</span>
<a name="l01397"></a>01397 <span class="preprocessor"></span><span class="preprocessor">#define LPROCFS_NRS_OFF_NAME_LOGICAL            &quot;logical&quot;</span>
<a name="l01398"></a>01398 <span class="preprocessor"></span>
<a name="l01413"></a>01413 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01414"></a>01414 ptlrpc_lprocfs_nrs_orr_offset_type_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01415"></a>01415 {
<a name="l01416"></a>01416         <span class="keyword">struct </span>nrs_lprocfs_orr_data *orr_data = m-&gt;private;
<a name="l01417"></a>01417         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>       *svc = orr_data-&gt;svc;
<a name="l01418"></a>01418         <span class="keywordtype">bool</span>                         physical;
<a name="l01419"></a>01419         <span class="keywordtype">int</span>                          rc;
<a name="l01420"></a>01420 
<a name="l01426"></a>01426         rc = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_REG,
<a name="l01427"></a>01427                                        orr_data-&gt;name, NRS_CTL_ORR_RD_OFF_TYPE,
<a name="l01428"></a>01428                                        <span class="keyword">true</span>, &amp;physical);
<a name="l01429"></a>01429         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01430"></a>01430                 seq_printf(m, LPROCFS_NRS_OFF_NAME_REG<span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l01431"></a>01431                            physical ? LPROCFS_NRS_OFF_NAME_PHYSICAL :
<a name="l01432"></a>01432                            LPROCFS_NRS_OFF_NAME_LOGICAL);
<a name="l01437"></a>01437         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENODEV) {
<a name="l01438"></a>01438                 <span class="keywordflow">return</span> rc;
<a name="l01439"></a>01439         }
<a name="l01440"></a>01440 
<a name="l01446"></a>01446         <span class="keywordflow">if</span> (!nrs_svc_has_hp(svc))
<a name="l01447"></a>01447                 <span class="keywordflow">goto</span> no_hp;
<a name="l01448"></a>01448 
<a name="l01449"></a>01449         rc = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_HP,
<a name="l01450"></a>01450                                        orr_data-&gt;name, NRS_CTL_ORR_RD_OFF_TYPE,
<a name="l01451"></a>01451                                        <span class="keyword">true</span>, &amp;physical);
<a name="l01452"></a>01452         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01453"></a>01453                 seq_printf(m, LPROCFS_NRS_OFF_NAME_HP<span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l01454"></a>01454                            physical ? LPROCFS_NRS_OFF_NAME_PHYSICAL :
<a name="l01455"></a>01455                            LPROCFS_NRS_OFF_NAME_LOGICAL);
<a name="l01460"></a>01460         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENODEV) {
<a name="l01461"></a>01461                 <span class="keywordflow">return</span> rc;
<a name="l01462"></a>01462         }
<a name="l01463"></a>01463 
<a name="l01464"></a>01464 no_hp:
<a name="l01465"></a>01465         <span class="keywordflow">return</span> rc;
<a name="l01466"></a>01466 }
<a name="l01467"></a>01467 
<a name="l01472"></a>01472 <span class="preprocessor">#define LPROCFS_NRS_WR_OFF_TYPE_MAX_CMD                                        \</span>
<a name="l01473"></a>01473 <span class="preprocessor">        sizeof(LPROCFS_NRS_OFF_NAME_REG LPROCFS_NRS_OFF_NAME_PHYSICAL &quot; &quot;      \</span>
<a name="l01474"></a>01474 <span class="preprocessor">               LPROCFS_NRS_OFF_NAME_HP LPROCFS_NRS_OFF_NAME_PHYSICAL)</span>
<a name="l01475"></a>01475 <span class="preprocessor"></span>
<a name="l01494"></a>01494 <span class="keyword">static</span> ssize_t
<a name="l01495"></a>01495 ptlrpc_lprocfs_nrs_orr_offset_type_seq_write(<span class="keyword">struct</span> file *file,
<a name="l01496"></a>01496                                              <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l01497"></a>01497                                               <span class="keywordtype">size_t</span> count,
<a name="l01498"></a>01498                                              loff_t *off)
<a name="l01499"></a>01499 {
<a name="l01500"></a>01500         <span class="keyword">struct </span>seq_file             *m = file-&gt;private_data;
<a name="l01501"></a>01501         <span class="keyword">struct </span>nrs_lprocfs_orr_data *orr_data = m-&gt;private;
<a name="l01502"></a>01502         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>       *svc = orr_data-&gt;svc;
<a name="l01503"></a>01503         <span class="keyword">enum</span> <a class="code" href="group__nrs.html#ga79e63c48a144326744316f397c52a883" title="NRS queue type.">ptlrpc_nrs_queue_type</a>   queue = 0;
<a name="l01504"></a>01504         <span class="keywordtype">char</span>                         kernbuf[LPROCFS_NRS_WR_OFF_TYPE_MAX_CMD];
<a name="l01505"></a>01505         <span class="keywordtype">char</span>                        *val_reg;
<a name="l01506"></a>01506         <span class="keywordtype">char</span>                        *val_hp;
<a name="l01507"></a>01507         <span class="keywordtype">bool</span>                         physical_reg;
<a name="l01508"></a>01508         <span class="keywordtype">bool</span>                         physical_hp;
<a name="l01509"></a>01509         <span class="keywordtype">size_t</span>                       count_copy;
<a name="l01510"></a>01510         <span class="keywordtype">int</span>                          rc = 0;
<a name="l01511"></a>01511         <span class="keywordtype">int</span>                          rc2 = 0;
<a name="l01512"></a>01512 
<a name="l01513"></a>01513         <span class="keywordflow">if</span> (count &gt; (<span class="keyword">sizeof</span>(kernbuf) - 1))
<a name="l01514"></a>01514                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01515"></a>01515 
<a name="l01516"></a>01516         <span class="keywordflow">if</span> (copy_from_user(kernbuf, buffer, count))
<a name="l01517"></a>01517                 <span class="keywordflow">return</span> -EFAULT;
<a name="l01518"></a>01518 
<a name="l01519"></a>01519         kernbuf[count] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01520"></a>01520 
<a name="l01521"></a>01521         count_copy = count;
<a name="l01522"></a>01522 
<a name="l01526"></a>01526         val_reg = lprocfs_find_named_value(kernbuf,
<a name="l01527"></a>01527                                            LPROCFS_NRS_OFF_NAME_REG,
<a name="l01528"></a>01528                                            &amp;count_copy);
<a name="l01529"></a>01529         <span class="keywordflow">if</span> (val_reg != kernbuf)
<a name="l01530"></a>01530                 queue |= PTLRPC_NRS_QUEUE_REG;
<a name="l01531"></a>01531 
<a name="l01532"></a>01532         count_copy = count;
<a name="l01533"></a>01533 
<a name="l01537"></a>01537         val_hp = lprocfs_find_named_value(kernbuf, LPROCFS_NRS_OFF_NAME_HP,
<a name="l01538"></a>01538                                           &amp;count_copy);
<a name="l01539"></a>01539         <span class="keywordflow">if</span> (val_hp != kernbuf) {
<a name="l01540"></a>01540                 <span class="keywordflow">if</span> (!nrs_svc_has_hp(svc))
<a name="l01541"></a>01541                         <span class="keywordflow">return</span> -ENODEV;
<a name="l01542"></a>01542 
<a name="l01543"></a>01543                 queue |= PTLRPC_NRS_QUEUE_HP;
<a name="l01544"></a>01544         }
<a name="l01545"></a>01545 
<a name="l01550"></a>01550         <span class="keywordflow">if</span> (queue == 0) {
<a name="l01551"></a>01551                 queue = PTLRPC_NRS_QUEUE_REG;
<a name="l01552"></a>01552 
<a name="l01553"></a>01553                 <span class="keywordflow">if</span> (nrs_svc_has_hp(svc))
<a name="l01554"></a>01554                         queue |= PTLRPC_NRS_QUEUE_HP;
<a name="l01555"></a>01555         }
<a name="l01556"></a>01556 
<a name="l01557"></a>01557         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_REG) != 0) {
<a name="l01558"></a>01558                 <span class="keywordflow">if</span> (strncmp(val_reg, LPROCFS_NRS_OFF_NAME_PHYSICAL,
<a name="l01559"></a>01559                             <span class="keyword">sizeof</span>(LPROCFS_NRS_OFF_NAME_PHYSICAL) - 1) == 0)
<a name="l01560"></a>01560                         physical_reg = <span class="keyword">true</span>;
<a name="l01561"></a>01561                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(val_reg, LPROCFS_NRS_OFF_NAME_LOGICAL,
<a name="l01562"></a>01562                          <span class="keyword">sizeof</span>(LPROCFS_NRS_OFF_NAME_LOGICAL) - 1) == 0)
<a name="l01563"></a>01563                         physical_reg = <span class="keyword">false</span>;
<a name="l01564"></a>01564                 <span class="keywordflow">else</span>
<a name="l01565"></a>01565                         <span class="keywordflow">return</span> -EINVAL;
<a name="l01566"></a>01566         }
<a name="l01567"></a>01567 
<a name="l01568"></a>01568         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_HP) != 0) {
<a name="l01569"></a>01569                 <span class="keywordflow">if</span> (strncmp(val_hp, LPROCFS_NRS_OFF_NAME_PHYSICAL,
<a name="l01570"></a>01570                             <span class="keyword">sizeof</span>(LPROCFS_NRS_OFF_NAME_PHYSICAL) - 1) == 0)
<a name="l01571"></a>01571                         physical_hp = <span class="keyword">true</span>;
<a name="l01572"></a>01572                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(val_hp, LPROCFS_NRS_OFF_NAME_LOGICAL,
<a name="l01573"></a>01573                                  <span class="keyword">sizeof</span>(LPROCFS_NRS_OFF_NAME_LOGICAL) - 1) == 0)
<a name="l01574"></a>01574                         physical_hp = <span class="keyword">false</span>;
<a name="l01575"></a>01575                 <span class="keywordflow">else</span>
<a name="l01576"></a>01576                         <span class="keywordflow">return</span> -EINVAL;
<a name="l01577"></a>01577         }
<a name="l01578"></a>01578 
<a name="l01589"></a>01589         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_REG) != 0) {
<a name="l01590"></a>01590                 rc = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_REG,
<a name="l01591"></a>01591                                                orr_data-&gt;name,
<a name="l01592"></a>01592                                                NRS_CTL_ORR_WR_OFF_TYPE, <span class="keyword">false</span>,
<a name="l01593"></a>01593                                                &amp;physical_reg);
<a name="l01594"></a>01594                 <span class="keywordflow">if</span> ((rc &lt; 0 &amp;&amp; rc != -ENODEV) ||
<a name="l01595"></a>01595                     (rc == -ENODEV &amp;&amp; queue == PTLRPC_NRS_QUEUE_REG))
<a name="l01596"></a>01596                         <span class="keywordflow">return</span> rc;
<a name="l01597"></a>01597         }
<a name="l01598"></a>01598 
<a name="l01599"></a>01599         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_HP) != 0) {
<a name="l01600"></a>01600                 rc2 = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_HP,
<a name="l01601"></a>01601                                                 orr_data-&gt;name,
<a name="l01602"></a>01602                                                 NRS_CTL_ORR_WR_OFF_TYPE, <span class="keyword">false</span>,
<a name="l01603"></a>01603                                                 &amp;physical_hp);
<a name="l01604"></a>01604                 <span class="keywordflow">if</span> ((rc2 &lt; 0 &amp;&amp; rc2 != -ENODEV) ||
<a name="l01605"></a>01605                     (rc2 == -ENODEV &amp;&amp; queue == PTLRPC_NRS_QUEUE_HP))
<a name="l01606"></a>01606                         <span class="keywordflow">return</span> rc2;
<a name="l01607"></a>01607         }
<a name="l01608"></a>01608 
<a name="l01609"></a>01609         <span class="keywordflow">return</span> rc == -ENODEV &amp;&amp; rc2 == -ENODEV ? -ENODEV : count;
<a name="l01610"></a>01610 }
<a name="l01611"></a>01611 LPROC_SEQ_FOPS(ptlrpc_lprocfs_nrs_orr_offset_type);
<a name="l01612"></a>01612 
<a name="l01613"></a>01613 <span class="preprocessor">#define NRS_LPROCFS_REQ_SUPP_NAME_REG           &quot;reg_supported:&quot;</span>
<a name="l01614"></a>01614 <span class="preprocessor"></span><span class="preprocessor">#define NRS_LPROCFS_REQ_SUPP_NAME_HP            &quot;hp_supported:&quot;</span>
<a name="l01615"></a>01615 <span class="preprocessor"></span>
<a name="l01616"></a>01616 <span class="preprocessor">#define LPROCFS_NRS_SUPP_NAME_READS             &quot;reads&quot;</span>
<a name="l01617"></a>01617 <span class="preprocessor"></span><span class="preprocessor">#define LPROCFS_NRS_SUPP_NAME_WRITES            &quot;writes&quot;</span>
<a name="l01618"></a>01618 <span class="preprocessor"></span><span class="preprocessor">#define LPROCFS_NRS_SUPP_NAME_READWRITES        &quot;reads_and_writes&quot;</span>
<a name="l01619"></a>01619 <span class="preprocessor"></span>
<a name="l01623"></a>01623 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *nrs_orr_supp2str(<span class="keyword">enum</span> nrs_orr_supp supp)
<a name="l01624"></a>01624 {
<a name="l01625"></a>01625         <span class="keywordflow">switch</span>(supp) {
<a name="l01626"></a>01626         <span class="keywordflow">default</span>:
<a name="l01627"></a>01627                 LBUG();
<a name="l01628"></a>01628         <span class="keywordflow">case</span> NOS_OST_READ:
<a name="l01629"></a>01629                 <span class="keywordflow">return</span> LPROCFS_NRS_SUPP_NAME_READS;
<a name="l01630"></a>01630         <span class="keywordflow">case</span> NOS_OST_WRITE:
<a name="l01631"></a>01631                 <span class="keywordflow">return</span> LPROCFS_NRS_SUPP_NAME_WRITES;
<a name="l01632"></a>01632         <span class="keywordflow">case</span> NOS_OST_RW:
<a name="l01633"></a>01633                 <span class="keywordflow">return</span> LPROCFS_NRS_SUPP_NAME_READWRITES;
<a name="l01634"></a>01634         }
<a name="l01635"></a>01635 }
<a name="l01636"></a>01636 
<a name="l01640"></a>01640 <span class="keyword">static</span> <span class="keyword">enum</span> nrs_orr_supp nrs_orr_str2supp(<span class="keyword">const</span> <span class="keywordtype">char</span> *val)
<a name="l01641"></a>01641 {
<a name="l01642"></a>01642         <span class="keywordflow">if</span> (strncmp(val, LPROCFS_NRS_SUPP_NAME_READWRITES,
<a name="l01643"></a>01643                     <span class="keyword">sizeof</span>(LPROCFS_NRS_SUPP_NAME_READWRITES) - 1) == 0)
<a name="l01644"></a>01644                 <span class="keywordflow">return</span> NOS_OST_RW;
<a name="l01645"></a>01645         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(val, LPROCFS_NRS_SUPP_NAME_READS,
<a name="l01646"></a>01646                          <span class="keyword">sizeof</span>(LPROCFS_NRS_SUPP_NAME_READS) - 1) == 0)
<a name="l01647"></a>01647                 <span class="keywordflow">return</span> NOS_OST_READ;
<a name="l01648"></a>01648         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(val, LPROCFS_NRS_SUPP_NAME_WRITES,
<a name="l01649"></a>01649                          <span class="keyword">sizeof</span>(LPROCFS_NRS_SUPP_NAME_WRITES) - 1) == 0)
<a name="l01650"></a>01650                 <span class="keywordflow">return</span> NOS_OST_WRITE;
<a name="l01651"></a>01651         <span class="keywordflow">else</span>
<a name="l01652"></a>01652                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01653"></a>01653 }
<a name="l01654"></a>01654 
<a name="l01670"></a>01670 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01671"></a>01671 ptlrpc_lprocfs_nrs_orr_supported_seq_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *data)
<a name="l01672"></a>01672 {
<a name="l01673"></a>01673         <span class="keyword">struct </span>nrs_lprocfs_orr_data *orr_data = m-&gt;private;
<a name="l01674"></a>01674         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>       *svc = orr_data-&gt;svc;
<a name="l01675"></a>01675         <span class="keyword">enum</span> nrs_orr_supp            supported;
<a name="l01676"></a>01676         <span class="keywordtype">int</span>                          rc;
<a name="l01677"></a>01677 
<a name="l01683"></a>01683         rc = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_REG,
<a name="l01684"></a>01684                                        orr_data-&gt;name,
<a name="l01685"></a>01685                                        NRS_CTL_ORR_RD_SUPP_REQ, <span class="keyword">true</span>,
<a name="l01686"></a>01686                                        &amp;supported);
<a name="l01687"></a>01687 
<a name="l01688"></a>01688         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01689"></a>01689                 seq_printf(m, NRS_LPROCFS_REQ_SUPP_NAME_REG<span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l01690"></a>01690                            nrs_orr_supp2str(supported));
<a name="l01695"></a>01695         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENODEV) {
<a name="l01696"></a>01696                 <span class="keywordflow">return</span> rc;
<a name="l01697"></a>01697         }
<a name="l01698"></a>01698 
<a name="l01704"></a>01704         <span class="keywordflow">if</span> (!nrs_svc_has_hp(svc))
<a name="l01705"></a>01705                 <span class="keywordflow">goto</span> no_hp;
<a name="l01706"></a>01706 
<a name="l01707"></a>01707         rc = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_HP,
<a name="l01708"></a>01708                                        orr_data-&gt;name,
<a name="l01709"></a>01709                                        NRS_CTL_ORR_RD_SUPP_REQ, <span class="keyword">true</span>,
<a name="l01710"></a>01710                                        &amp;supported);
<a name="l01711"></a>01711         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01712"></a>01712                 seq_printf(m, NRS_LPROCFS_REQ_SUPP_NAME_HP<span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l01713"></a>01713                            nrs_orr_supp2str(supported));
<a name="l01718"></a>01718         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENODEV) {
<a name="l01719"></a>01719                 <span class="keywordflow">return</span> rc;
<a name="l01720"></a>01720         }
<a name="l01721"></a>01721 
<a name="l01722"></a>01722 no_hp:
<a name="l01723"></a>01723 
<a name="l01724"></a>01724         <span class="keywordflow">return</span> rc;
<a name="l01725"></a>01725 }
<a name="l01726"></a>01726 
<a name="l01731"></a>01731 <span class="preprocessor">#define LPROCFS_NRS_WR_REQ_SUPP_MAX_CMD                                        \</span>
<a name="l01732"></a>01732 <span class="preprocessor">        sizeof(NRS_LPROCFS_REQ_SUPP_NAME_REG LPROCFS_NRS_SUPP_NAME_READWRITES  \</span>
<a name="l01733"></a>01733 <span class="preprocessor">               NRS_LPROCFS_REQ_SUPP_NAME_HP LPROCFS_NRS_SUPP_NAME_READWRITES   \</span>
<a name="l01734"></a>01734 <span class="preprocessor">               &quot; &quot;)</span>
<a name="l01735"></a>01735 <span class="preprocessor"></span>
<a name="l01754"></a>01754 <span class="keyword">static</span> ssize_t
<a name="l01755"></a>01755 ptlrpc_lprocfs_nrs_orr_supported_seq_write(<span class="keyword">struct</span> file *file,
<a name="l01756"></a>01756                                            <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buffer,
<a name="l01757"></a>01757                                            <span class="keywordtype">size_t</span> count,
<a name="l01758"></a>01758                                            loff_t *off)
<a name="l01759"></a>01759 {
<a name="l01760"></a>01760         <span class="keyword">struct </span>seq_file             *m = file-&gt;private_data;
<a name="l01761"></a>01761         <span class="keyword">struct </span>nrs_lprocfs_orr_data *orr_data = m-&gt;private;
<a name="l01762"></a>01762         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>       *svc = orr_data-&gt;svc;
<a name="l01763"></a>01763         <span class="keyword">enum</span> <a class="code" href="group__nrs.html#ga79e63c48a144326744316f397c52a883" title="NRS queue type.">ptlrpc_nrs_queue_type</a>   queue = 0;
<a name="l01764"></a>01764         <span class="keywordtype">char</span>                         kernbuf[LPROCFS_NRS_WR_REQ_SUPP_MAX_CMD];
<a name="l01765"></a>01765         <span class="keywordtype">char</span>                        *val_reg;
<a name="l01766"></a>01766         <span class="keywordtype">char</span>                        *val_hp;
<a name="l01767"></a>01767         <span class="keyword">enum</span> nrs_orr_supp            supp_reg;
<a name="l01768"></a>01768         <span class="keyword">enum</span> nrs_orr_supp            supp_hp;
<a name="l01769"></a>01769         <span class="keywordtype">size_t</span>                       count_copy;
<a name="l01770"></a>01770         <span class="keywordtype">int</span>                          rc = 0;
<a name="l01771"></a>01771         <span class="keywordtype">int</span>                          rc2 = 0;
<a name="l01772"></a>01772 
<a name="l01773"></a>01773         <span class="keywordflow">if</span> (count &gt; (<span class="keyword">sizeof</span>(kernbuf) - 1))
<a name="l01774"></a>01774                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01775"></a>01775 
<a name="l01776"></a>01776         <span class="keywordflow">if</span> (copy_from_user(kernbuf, buffer, count))
<a name="l01777"></a>01777                 <span class="keywordflow">return</span> -EFAULT;
<a name="l01778"></a>01778 
<a name="l01779"></a>01779         kernbuf[count] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01780"></a>01780 
<a name="l01781"></a>01781         count_copy = count;
<a name="l01782"></a>01782 
<a name="l01786"></a>01786         val_reg = lprocfs_find_named_value(kernbuf,
<a name="l01787"></a>01787                                            NRS_LPROCFS_REQ_SUPP_NAME_REG,
<a name="l01788"></a>01788                                            &amp;count_copy);
<a name="l01789"></a>01789         <span class="keywordflow">if</span> (val_reg != kernbuf)
<a name="l01790"></a>01790                 queue |= PTLRPC_NRS_QUEUE_REG;
<a name="l01791"></a>01791 
<a name="l01792"></a>01792         count_copy = count;
<a name="l01793"></a>01793 
<a name="l01798"></a>01798         val_hp = lprocfs_find_named_value(kernbuf, NRS_LPROCFS_REQ_SUPP_NAME_HP,
<a name="l01799"></a>01799                                           &amp;count_copy);
<a name="l01800"></a>01800         <span class="keywordflow">if</span> (val_hp != kernbuf) {
<a name="l01801"></a>01801                 <span class="keywordflow">if</span> (!nrs_svc_has_hp(svc))
<a name="l01802"></a>01802                         <span class="keywordflow">return</span> -ENODEV;
<a name="l01803"></a>01803 
<a name="l01804"></a>01804                 queue |= PTLRPC_NRS_QUEUE_HP;
<a name="l01805"></a>01805         }
<a name="l01806"></a>01806 
<a name="l01811"></a>01811         <span class="keywordflow">if</span> (queue == 0) {
<a name="l01812"></a>01812                 queue = PTLRPC_NRS_QUEUE_REG;
<a name="l01813"></a>01813 
<a name="l01814"></a>01814                 <span class="keywordflow">if</span> (nrs_svc_has_hp(svc))
<a name="l01815"></a>01815                         queue |= PTLRPC_NRS_QUEUE_HP;
<a name="l01816"></a>01816         }
<a name="l01817"></a>01817 
<a name="l01818"></a>01818         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_REG) != 0) {
<a name="l01819"></a>01819                 supp_reg = nrs_orr_str2supp(val_reg);
<a name="l01820"></a>01820                 <span class="keywordflow">if</span> (supp_reg == -EINVAL)
<a name="l01821"></a>01821                         <span class="keywordflow">return</span> -EINVAL;
<a name="l01822"></a>01822         }
<a name="l01823"></a>01823 
<a name="l01824"></a>01824         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_HP) != 0) {
<a name="l01825"></a>01825                 supp_hp = nrs_orr_str2supp(val_hp);
<a name="l01826"></a>01826                 <span class="keywordflow">if</span> (supp_hp == -EINVAL)
<a name="l01827"></a>01827                         <span class="keywordflow">return</span> -EINVAL;
<a name="l01828"></a>01828         }
<a name="l01829"></a>01829 
<a name="l01840"></a>01840         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_REG) != 0) {
<a name="l01841"></a>01841                 rc = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_REG,
<a name="l01842"></a>01842                                                orr_data-&gt;name,
<a name="l01843"></a>01843                                                NRS_CTL_ORR_WR_SUPP_REQ, <span class="keyword">false</span>,
<a name="l01844"></a>01844                                                &amp;supp_reg);
<a name="l01845"></a>01845                 <span class="keywordflow">if</span> ((rc &lt; 0 &amp;&amp; rc != -ENODEV) ||
<a name="l01846"></a>01846                     (rc == -ENODEV &amp;&amp; queue == PTLRPC_NRS_QUEUE_REG))
<a name="l01847"></a>01847                         <span class="keywordflow">return</span> rc;
<a name="l01848"></a>01848         }
<a name="l01849"></a>01849 
<a name="l01850"></a>01850         <span class="keywordflow">if</span> ((queue &amp; PTLRPC_NRS_QUEUE_HP) != 0) {
<a name="l01851"></a>01851                 rc2 = ptlrpc_nrs_policy_control(svc, PTLRPC_NRS_QUEUE_HP,
<a name="l01852"></a>01852                                                 orr_data-&gt;name,
<a name="l01853"></a>01853                                                 NRS_CTL_ORR_WR_SUPP_REQ, <span class="keyword">false</span>,
<a name="l01854"></a>01854                                                 &amp;supp_hp);
<a name="l01855"></a>01855                 <span class="keywordflow">if</span> ((rc2 &lt; 0 &amp;&amp; rc2 != -ENODEV) ||
<a name="l01856"></a>01856                     (rc2 == -ENODEV &amp;&amp; queue == PTLRPC_NRS_QUEUE_HP))
<a name="l01857"></a>01857                         <span class="keywordflow">return</span> rc2;
<a name="l01858"></a>01858         }
<a name="l01859"></a>01859 
<a name="l01860"></a>01860         <span class="keywordflow">return</span> rc == -ENODEV &amp;&amp; rc2 == -ENODEV ? -ENODEV : count;
<a name="l01861"></a>01861 }
<a name="l01862"></a>01862 LPROC_SEQ_FOPS(ptlrpc_lprocfs_nrs_orr_supported);
<a name="l01863"></a>01863 
<a name="l01864"></a>01864 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_orr_lprocfs_init(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l01865"></a>01865 {
<a name="l01866"></a>01866         <span class="keywordtype">int</span>     i;
<a name="l01867"></a>01867 
<a name="l01868"></a>01868         <span class="keyword">struct </span><a class="code" href="structlprocfs__vars.html">lprocfs_vars</a> nrs_orr_lprocfs_vars[] = {
<a name="l01869"></a>01869                 { .name         = <span class="stringliteral">&quot;nrs_orr_quantum&quot;</span>,
<a name="l01870"></a>01870                   .fops         = &amp;ptlrpc_lprocfs_nrs_orr_quantum_fops  },
<a name="l01871"></a>01871                 { .name         = <span class="stringliteral">&quot;nrs_orr_offset_type&quot;</span>,
<a name="l01872"></a>01872                   .fops         = &amp;ptlrpc_lprocfs_nrs_orr_offset_type_fops },
<a name="l01873"></a>01873                 { .name         = <span class="stringliteral">&quot;nrs_orr_supported&quot;</span>,
<a name="l01874"></a>01874                   .fops         = &amp;ptlrpc_lprocfs_nrs_orr_supported_fops },
<a name="l01875"></a>01875                 { NULL }
<a name="l01876"></a>01876         };
<a name="l01877"></a>01877 
<a name="l01878"></a>01878         <span class="keywordflow">if</span> (svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a> == NULL)
<a name="l01879"></a>01879                 <span class="keywordflow">return</span> 0;
<a name="l01880"></a>01880 
<a name="l01881"></a>01881         lprocfs_orr_data.svc = svc;
<a name="l01882"></a>01882 
<a name="l01883"></a>01883         <span class="keywordflow">for</span> (i = 0; i &lt; ARRAY_SIZE(nrs_orr_lprocfs_vars); i++)
<a name="l01884"></a>01884                 nrs_orr_lprocfs_vars[i].data = &amp;lprocfs_orr_data;
<a name="l01885"></a>01885 
<a name="l01886"></a>01886         <span class="keywordflow">return</span> lprocfs_add_vars(svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a>, nrs_orr_lprocfs_vars, NULL);
<a name="l01887"></a>01887 }
<a name="l01888"></a>01888 
<a name="l01889"></a>01889 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_orr_lprocfs_fini(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l01890"></a>01890 {
<a name="l01891"></a>01891         <span class="keywordflow">if</span> (svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a> == NULL)
<a name="l01892"></a>01892                 <span class="keywordflow">return</span>;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894         lprocfs_remove_proc_entry(<span class="stringliteral">&quot;nrs_orr_quantum&quot;</span>, svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a>);
<a name="l01895"></a>01895         lprocfs_remove_proc_entry(<span class="stringliteral">&quot;nrs_orr_offset_type&quot;</span>, svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a>);
<a name="l01896"></a>01896         lprocfs_remove_proc_entry(<span class="stringliteral">&quot;nrs_orr_supported&quot;</span>, svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a>);
<a name="l01897"></a>01897 }
<a name="l01898"></a>01898 
<a name="l01899"></a>01899 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PROC_FS */</span>
<a name="l01900"></a>01900 
<a name="l01901"></a>01901 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__pol__ops.html" title="NRS policy operations.">ptlrpc_nrs_pol_ops</a> nrs_orr_ops = {
<a name="l01902"></a>01902         .op_policy_init         = nrs_orr_init,
<a name="l01903"></a>01903         .op_policy_start        = nrs_orr_start,
<a name="l01904"></a>01904         .op_policy_stop         = nrs_orr_stop,
<a name="l01905"></a>01905         .op_policy_ctl          = nrs_orr_ctl,
<a name="l01906"></a>01906         .op_res_get             = nrs_orr_res_get,
<a name="l01907"></a>01907         .op_res_put             = nrs_orr_res_put,
<a name="l01908"></a>01908         .op_req_get             = nrs_orr_req_get,
<a name="l01909"></a>01909         .op_req_enqueue         = nrs_orr_req_add,
<a name="l01910"></a>01910         .op_req_dequeue         = nrs_orr_req_del,
<a name="l01911"></a>01911         .op_req_stop            = nrs_orr_req_stop,
<a name="l01912"></a>01912 <span class="preprocessor">#ifdef CONFIG_PROC_FS</span>
<a name="l01913"></a>01913 <span class="preprocessor"></span>        .op_lprocfs_init        = nrs_orr_lprocfs_init,
<a name="l01914"></a>01914         .op_lprocfs_fini        = nrs_orr_lprocfs_fini,
<a name="l01915"></a>01915 <span class="preprocessor">#endif</span>
<a name="l01916"></a>01916 <span class="preprocessor"></span>};
<a name="l01917"></a>01917 
<a name="l01918"></a>01918 <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> nrs_conf_orr = {
<a name="l01919"></a>01919         .nc_name                = NRS_POL_NAME_ORR,
<a name="l01920"></a>01920         .nc_ops                 = &amp;nrs_orr_ops,
<a name="l01921"></a>01921         .nc_compat              = nrs_policy_compat_one,
<a name="l01922"></a>01922         .nc_compat_svc_name     = <span class="stringliteral">&quot;ost_io&quot;</span>,
<a name="l01923"></a>01923 };
<a name="l01924"></a>01924 
<a name="l01931"></a>01931 <span class="preprocessor">#ifdef CONFIG_PROC_FS</span>
<a name="l01932"></a>01932 <span class="preprocessor"></span>
<a name="l01933"></a>01933 <span class="keyword">static</span> <span class="keywordtype">int</span> nrs_trr_lprocfs_init(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l01934"></a>01934 {
<a name="l01935"></a>01935         <span class="keywordtype">int</span>     i;
<a name="l01936"></a>01936 
<a name="l01937"></a>01937         <span class="keyword">struct </span><a class="code" href="structlprocfs__vars.html">lprocfs_vars</a> nrs_trr_lprocfs_vars[] = {
<a name="l01938"></a>01938                 { .name         = <span class="stringliteral">&quot;nrs_trr_quantum&quot;</span>,
<a name="l01939"></a>01939                   .fops         = &amp;ptlrpc_lprocfs_nrs_orr_quantum_fops },
<a name="l01940"></a>01940                 { .name         = <span class="stringliteral">&quot;nrs_trr_offset_type&quot;</span>,
<a name="l01941"></a>01941                   .fops         = &amp;ptlrpc_lprocfs_nrs_orr_offset_type_fops },
<a name="l01942"></a>01942                 { .name         = <span class="stringliteral">&quot;nrs_trr_supported&quot;</span>,
<a name="l01943"></a>01943                   .fops         = &amp;ptlrpc_lprocfs_nrs_orr_supported_fops },
<a name="l01944"></a>01944                 { NULL }
<a name="l01945"></a>01945         };
<a name="l01946"></a>01946 
<a name="l01947"></a>01947         <span class="keywordflow">if</span> (svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a> == NULL)
<a name="l01948"></a>01948                 <span class="keywordflow">return</span> 0;
<a name="l01949"></a>01949 
<a name="l01950"></a>01950         lprocfs_trr_data.svc = svc;
<a name="l01951"></a>01951 
<a name="l01952"></a>01952         <span class="keywordflow">for</span> (i = 0; i &lt; ARRAY_SIZE(nrs_trr_lprocfs_vars); i++)
<a name="l01953"></a>01953                 nrs_trr_lprocfs_vars[i].data = &amp;lprocfs_trr_data;
<a name="l01954"></a>01954 
<a name="l01955"></a>01955         <span class="keywordflow">return</span> lprocfs_add_vars(svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a>, nrs_trr_lprocfs_vars, NULL);
<a name="l01956"></a>01956 }
<a name="l01957"></a>01957 
<a name="l01958"></a>01958 <span class="keyword">static</span> <span class="keywordtype">void</span> nrs_trr_lprocfs_fini(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l01959"></a>01959 {
<a name="l01960"></a>01960         <span class="keywordflow">if</span> (svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a> == NULL)
<a name="l01961"></a>01961                 <span class="keywordflow">return</span>;
<a name="l01962"></a>01962 
<a name="l01963"></a>01963         lprocfs_remove_proc_entry(<span class="stringliteral">&quot;nrs_trr_quantum&quot;</span>, svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a>);
<a name="l01964"></a>01964         lprocfs_remove_proc_entry(<span class="stringliteral">&quot;nrs_trr_offset_type&quot;</span>, svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a>);
<a name="l01965"></a>01965         lprocfs_remove_proc_entry(<span class="stringliteral">&quot;nrs_trr_supported&quot;</span>, svc-&gt;<a class="code" href="structptlrpc__service.html#a2cf9a28d5e09cfdf07c8a6f8a77e3691" title="Root of /proc dir tree for this service.">srv_procroot</a>);
<a name="l01966"></a>01966 }
<a name="l01967"></a>01967 
<a name="l01968"></a>01968 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PROC_FS */</span>
<a name="l01969"></a>01969 
<a name="l01973"></a>01973 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__pol__ops.html" title="NRS policy operations.">ptlrpc_nrs_pol_ops</a> nrs_trr_ops = {
<a name="l01974"></a>01974         .op_policy_init         = nrs_orr_init,
<a name="l01975"></a>01975         .op_policy_start        = nrs_orr_start,
<a name="l01976"></a>01976         .op_policy_stop         = nrs_orr_stop,
<a name="l01977"></a>01977         .op_policy_ctl          = nrs_orr_ctl,
<a name="l01978"></a>01978         .op_res_get             = nrs_orr_res_get,
<a name="l01979"></a>01979         .op_res_put             = nrs_orr_res_put,
<a name="l01980"></a>01980         .op_req_get             = nrs_orr_req_get,
<a name="l01981"></a>01981         .op_req_enqueue         = nrs_orr_req_add,
<a name="l01982"></a>01982         .op_req_dequeue         = nrs_orr_req_del,
<a name="l01983"></a>01983         .op_req_stop            = nrs_orr_req_stop,
<a name="l01984"></a>01984 <span class="preprocessor">#ifdef CONFIG_PROC_FS</span>
<a name="l01985"></a>01985 <span class="preprocessor"></span>        .op_lprocfs_init        = nrs_trr_lprocfs_init,
<a name="l01986"></a>01986         .op_lprocfs_fini        = nrs_trr_lprocfs_fini,
<a name="l01987"></a>01987 <span class="preprocessor">#endif</span>
<a name="l01988"></a>01988 <span class="preprocessor"></span>};
<a name="l01989"></a>01989 
<a name="l01990"></a>01990 <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> nrs_conf_trr = {
<a name="l01991"></a>01991         .nc_name                = NRS_POL_NAME_TRR,
<a name="l01992"></a>01992         .nc_ops                 = &amp;nrs_trr_ops,
<a name="l01993"></a>01993         .nc_compat              = nrs_policy_compat_one,
<a name="l01994"></a>01994         .nc_compat_svc_name     = <span class="stringliteral">&quot;ost_io&quot;</span>,
<a name="l01995"></a>01995 };
<a name="l01996"></a>01996 
<a name="l02001"></a>02001 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:21 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
