<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/include/lustre_log.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/include/lustre_log.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.gnu.org/licenses/gpl-2.0.html</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * GPL HEADER END</span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 <span class="comment">/*</span>
<a name="l00023"></a>00023 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00024"></a>00024 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00025"></a>00025 <span class="comment"> *</span>
<a name="l00026"></a>00026 <span class="comment"> * Copyright (c) 2012, 2015, Intel Corporation.</span>
<a name="l00027"></a>00027 <span class="comment"> */</span>
<a name="l00028"></a>00028 <span class="comment">/*</span>
<a name="l00029"></a>00029 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> * lustre/include/lustre_log.h</span>
<a name="l00032"></a>00032 <span class="comment"> *</span>
<a name="l00033"></a>00033 <span class="comment"> * Generic infrastructure for managing a collection of logs.</span>
<a name="l00034"></a>00034 <span class="comment"> * These logs are used for:</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * - orphan recovery: OST adds record on create</span>
<a name="l00037"></a>00037 <span class="comment"> * - mtime/size consistency: the OST adds a record on first write</span>
<a name="l00038"></a>00038 <span class="comment"> * - open/unlinked objects: OST adds a record on destroy</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * - mds unlink log: the MDS adds an entry upon delete</span>
<a name="l00041"></a>00041 <span class="comment"> *</span>
<a name="l00042"></a>00042 <span class="comment"> * - raid1 replication log between OST&apos;s</span>
<a name="l00043"></a>00043 <span class="comment"> * - MDS replication logs</span>
<a name="l00044"></a>00044 <span class="comment"> */</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#ifndef _LUSTRE_LOG_H</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#define _LUSTRE_LOG_H</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;lustre/lustre_idl.h&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;dt_object.h&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;lustre_log_user.h&gt;</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="preprocessor">#define LOG_NAME_LIMIT(logname, name)                   \</span>
<a name="l00060"></a>00060 <span class="preprocessor">        snprintf(logname, sizeof(logname), &quot;LOGS/%s&quot;, name)</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define LLOG_EEMPTY 4711</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="keyword">enum</span> llog_open_param {
<a name="l00064"></a>00064         LLOG_OPEN_EXISTS        = 0x0000,
<a name="l00065"></a>00065         LLOG_OPEN_NEW           = 0x0001,
<a name="l00066"></a>00066 };
<a name="l00067"></a>00067 
<a name="l00068"></a><a class="code" href="structplain__handle__data.html">00068</a> <span class="keyword">struct </span><a class="code" href="structplain__handle__data.html">plain_handle_data</a> {
<a name="l00069"></a>00069         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        phd_entry;
<a name="l00070"></a>00070         <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a>      *phd_cat_handle;
<a name="l00071"></a>00071         <span class="comment">/* cookie of this log in its cat */</span>
<a name="l00072"></a>00072         <span class="keyword">struct </span><a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a>      phd_cookie;
<a name="l00073"></a>00073 };
<a name="l00074"></a>00074 
<a name="l00075"></a><a class="code" href="structcat__handle__data.html">00075</a> <span class="keyword">struct </span><a class="code" href="structcat__handle__data.html">cat_handle_data</a> {
<a name="l00076"></a>00076         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        chd_head;
<a name="l00077"></a>00077         <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a>     *chd_current_log;<span class="comment">/* currently open log */</span>
<a name="l00078"></a>00078         <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a>     *chd_next_log;   <span class="comment">/* llog to be used next */</span>
<a name="l00079"></a>00079 };
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a>;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment">/* llog.c  -  general API */</span>
<a name="l00084"></a>00084 <span class="keywordtype">int</span> llog_init_handle(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *handle,
<a name="l00085"></a>00085                      <span class="keywordtype">int</span> flags, <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid);
<a name="l00086"></a>00086 <span class="keywordtype">int</span> llog_copy_handler(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *llh,
<a name="l00087"></a>00087                       <span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keywordtype">void</span> *data);
<a name="l00088"></a>00088 <span class="keywordtype">int</span> llog_process(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle,
<a name="l00089"></a>00089                  llog_cb_t cb, <span class="keywordtype">void</span> *data, <span class="keywordtype">void</span> *catdata);
<a name="l00090"></a>00090 <span class="keywordtype">int</span> llog_process_or_fork(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00091"></a>00091                          <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle,
<a name="l00092"></a>00092                          llog_cb_t cb, <span class="keywordtype">void</span> *data, <span class="keywordtype">void</span> *catdata, <span class="keywordtype">bool</span> fork);
<a name="l00093"></a>00093 <span class="keywordtype">int</span> llog_reverse_process(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00094"></a>00094                          <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle, llog_cb_t cb,
<a name="l00095"></a>00095                          <span class="keywordtype">void</span> *data, <span class="keywordtype">void</span> *catdata);
<a name="l00096"></a>00096 <span class="keywordtype">int</span> llog_cancel_rec(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle,
<a name="l00097"></a>00097                     <span class="keywordtype">int</span> index);
<a name="l00098"></a>00098 <span class="keywordtype">int</span> llog_open(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt,
<a name="l00099"></a>00099               <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> **lgh, <span class="keyword">struct</span> <a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a> *logid,
<a name="l00100"></a>00100               <span class="keywordtype">char</span> *name, <span class="keyword">enum</span> llog_open_param open_param);
<a name="l00101"></a>00101 <span class="keywordtype">int</span> llog_close(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cathandle);
<a name="l00102"></a>00102 <span class="keywordtype">int</span> <a class="code" href="group__log.html#ga313d57d22838eb9027b38ee417701af3" title="Helper function to get the llog size in records.">llog_is_empty</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt,
<a name="l00103"></a>00103                   <span class="keywordtype">char</span> *name);
<a name="l00104"></a>00104 <span class="keywordtype">int</span> llog_backup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd,
<a name="l00105"></a>00105                 <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *bak_ctxt,
<a name="l00106"></a>00106                 <span class="keywordtype">char</span> *name, <span class="keywordtype">char</span> *backup);
<a name="l00107"></a>00107 <span class="keywordtype">int</span> llog_read_header(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *handle,
<a name="l00108"></a>00108                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid);
<a name="l00109"></a>00109 __u64 llog_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *llh);
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">/* llog_process flags */</span>
<a name="l00112"></a>00112 <span class="preprocessor">#define LLOG_FLAG_NODEAMON 0x0001</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span>
<a name="l00114"></a>00114 <span class="comment">/* llog_cat.c - catalog api */</span>
<a name="l00115"></a><a class="code" href="structllog__process__data.html">00115</a> <span class="keyword">struct </span><a class="code" href="structllog__process__data.html">llog_process_data</a> {
<a name="l00120"></a><a class="code" href="structllog__process__data.html#a648146cbe02366a5d4d9f0c02f80a405">00120</a>         <span class="keywordtype">void</span>                *<a class="code" href="structllog__process__data.html#a648146cbe02366a5d4d9f0c02f80a405" title="Any useful data needed while processing catalog.">lpd_data</a>;
<a name="l00125"></a><a class="code" href="structllog__process__data.html#a1a2d3c012640e757f3da9ab5a10725f0">00125</a>         llog_cb_t            <a class="code" href="structllog__process__data.html#a1a2d3c012640e757f3da9ab5a10725f0" title="Catalog process callback function, called for each record in catalog.">lpd_cb</a>;
<a name="l00129"></a><a class="code" href="structllog__process__data.html#a051255f0e379f17774529e445a4549ac">00129</a>         <span class="keywordtype">int</span>                  <a class="code" href="structllog__process__data.html#a051255f0e379f17774529e445a4549ac" title="Start processing the catalog from startcat/startidx.">lpd_startcat</a>;
<a name="l00130"></a>00130         <span class="keywordtype">int</span>                  lpd_startidx;
<a name="l00131"></a>00131 };
<a name="l00132"></a>00132 
<a name="l00133"></a><a class="code" href="structllog__process__cat__data.html">00133</a> <span class="keyword">struct </span><a class="code" href="structllog__process__cat__data.html">llog_process_cat_data</a> {
<a name="l00137"></a><a class="code" href="structllog__process__cat__data.html#a7ab2ded8bab7d2d749f397911acc686a">00137</a>         <span class="keywordtype">int</span>                  <a class="code" href="structllog__process__cat__data.html#a7ab2ded8bab7d2d749f397911acc686a" title="Temporary stored first_idx while scanning log.">lpcd_first_idx</a>;
<a name="l00141"></a><a class="code" href="structllog__process__cat__data.html#aed95ee6a3cc58810fe47fad32e072b1b">00141</a>         <span class="keywordtype">int</span>                  <a class="code" href="structllog__process__cat__data.html#aed95ee6a3cc58810fe47fad32e072b1b" title="Temporary stored last_idx while scanning log.">lpcd_last_idx</a>;
<a name="l00142"></a>00142 };
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keywordtype">int</span> llog_cat_close(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cathandle);
<a name="l00145"></a>00145 <span class="keywordtype">int</span> llog_cat_add_rec(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cathandle,
<a name="l00146"></a>00146                      <span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keyword">struct</span> <a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> *reccookie,
<a name="l00147"></a>00147                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00148"></a>00148 <span class="keywordtype">int</span> llog_cat_declare_add_rec(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00149"></a>00149                              <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cathandle,
<a name="l00150"></a>00150                              <span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00151"></a>00151 <span class="keywordtype">int</span> llog_cat_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cathandle,
<a name="l00152"></a>00152                  <span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keyword">struct</span> <a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> *reccookie);
<a name="l00153"></a>00153 <span class="keywordtype">int</span> llog_cat_cancel_records(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00154"></a>00154                             <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cathandle, <span class="keywordtype">int</span> count,
<a name="l00155"></a>00155                             <span class="keyword">struct</span> <a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> *cookies);
<a name="l00156"></a>00156 <span class="keywordtype">int</span> llog_cat_process_or_fork(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00157"></a>00157                              <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cat_llh, llog_cb_t cat_cb,
<a name="l00158"></a>00158                              llog_cb_t cb, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> startcat,
<a name="l00159"></a>00159                              <span class="keywordtype">int</span> startidx, <span class="keywordtype">bool</span> fork);
<a name="l00160"></a>00160 <span class="keywordtype">int</span> llog_cat_process(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cat_llh,
<a name="l00161"></a>00161                      llog_cb_t cb, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> startcat, <span class="keywordtype">int</span> startidx);
<a name="l00162"></a>00162 __u64 llog_cat_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cat_llh);
<a name="l00163"></a>00163 <span class="keywordtype">int</span> llog_cat_reverse_process(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00164"></a>00164                              <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *cat_llh, llog_cb_t cb,
<a name="l00165"></a>00165                              <span class="keywordtype">void</span> *data);
<a name="l00166"></a>00166 <span class="comment">/* llog_obd.c */</span>
<a name="l00167"></a>00167 <span class="keywordtype">int</span> llog_setup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd,
<a name="l00168"></a>00168                <span class="keyword">struct</span> <a class="code" href="structobd__llog__group.html">obd_llog_group</a> *olg, <span class="keywordtype">int</span> index,
<a name="l00169"></a>00169                <span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *disk_obd, <span class="keyword">struct</span> <a class="code" href="structllog__operations.html">llog_operations</a> *op);
<a name="l00170"></a>00170 <span class="keywordtype">int</span> __llog_ctxt_put(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt);
<a name="l00171"></a>00171 <span class="keywordtype">int</span> llog_cleanup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *);
<a name="l00172"></a>00172 <span class="keywordtype">int</span> llog_sync(<span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp, <span class="keywordtype">int</span> flags);
<a name="l00173"></a>00173 <span class="keywordtype">int</span> llog_cancel(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt,
<a name="l00174"></a>00174                 <span class="keyword">struct</span> <a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> *cookies, <span class="keywordtype">int</span> flags);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">/* llog_ioctl.c */</span>
<a name="l00177"></a>00177 <span class="keyword">struct </span><a class="code" href="structobd__ioctl__data.html">obd_ioctl_data</a>;
<a name="l00178"></a>00178 <span class="keywordtype">int</span> llog_ioctl(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, <span class="keywordtype">int</span> cmd,
<a name="l00179"></a>00179                <span class="keyword">struct</span> <a class="code" href="structobd__ioctl__data.html">obd_ioctl_data</a> *data);
<a name="l00180"></a>00180 <span class="keywordtype">int</span> llog_catalog_list(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__device.html">dt_device</a> *d,
<a name="l00181"></a>00181                       <span class="keywordtype">int</span> count, <span class="keyword">struct</span> <a class="code" href="structobd__ioctl__data.html">obd_ioctl_data</a> *data,
<a name="l00182"></a>00182                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="comment">/* llog_net.c */</span>
<a name="l00185"></a>00185 <span class="keywordtype">int</span> llog_initiator_connect(<span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt);
<a name="l00186"></a>00186 
<a name="l00187"></a><a class="code" href="structllog__operations.html">00187</a> <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a> {
<a name="l00188"></a>00188         int (*lop_declare_destroy)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00189"></a>00189                            <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *handle, <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00190"></a>00190         int (*lop_destroy)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00191"></a>00191                            <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *handle, <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00192"></a>00192         int (*lop_next_block)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *h,
<a name="l00193"></a>00193                               <span class="keywordtype">int</span> *curr_idx, <span class="keywordtype">int</span> next_idx, __u64 *offset,
<a name="l00194"></a>00194                               <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> len);
<a name="l00195"></a>00195         int (*lop_prev_block)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *h,
<a name="l00196"></a>00196                               <span class="keywordtype">int</span> prev_idx, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> len);
<a name="l00197"></a>00197         int (*lop_read_header)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00198"></a>00198                                <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *handle);
<a name="l00199"></a>00199         int (*lop_setup)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd,
<a name="l00200"></a>00200                          <span class="keyword">struct </span><a class="code" href="structobd__llog__group.html">obd_llog_group</a> *olg, <span class="keywordtype">int</span> ctxt_idx,
<a name="l00201"></a>00201                          <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *disk_obd);
<a name="l00202"></a>00202         int (*lop_sync)(<span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,
<a name="l00203"></a>00203                         <span class="keywordtype">int</span> flags);
<a name="l00204"></a>00204         int (*lop_cleanup)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt);
<a name="l00205"></a>00205         int (*lop_cancel)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt,
<a name="l00206"></a>00206                           <span class="keyword">struct </span><a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> *cookies, <span class="keywordtype">int</span> flags);
<a name="l00207"></a>00207         int (*lop_connect)(<span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, <span class="keyword">struct </span><a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a> *logid,
<a name="l00208"></a>00208                            <span class="keyword">struct </span><a class="code" href="structllog__gen.html">llog_gen</a> *gen, <span class="keyword">struct </span><a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid);
<a name="l00214"></a>00214         int (*<a class="code" href="structllog__operations.html#a139a9f0deac13b8017cc19644232ecfb" title="Any llog file must be opened first using llog_open().">lop_open</a>)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *lgh,
<a name="l00215"></a>00215                         <span class="keyword">struct </span><a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a> *logid, <span class="keywordtype">char</span> *name,
<a name="l00216"></a>00216                         <span class="keyword">enum</span> llog_open_param);
<a name="l00221"></a>00221         int (*<a class="code" href="structllog__operations.html#ada3ec98e78c44d6186c26adf91f807a6" title="Opened llog may not exist and this must be checked where needed using the llog_exist()...">lop_exist</a>)(<span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *lgh);
<a name="l00226"></a>00226         int (*<a class="code" href="structllog__operations.html#ad1e04ab8212c5c53d654ea391c870b28" title="Close llog file and calls llog_free_handle() implicitly.">lop_close</a>)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *handle);
<a name="l00231"></a>00231         int (*<a class="code" href="structllog__operations.html#ad999e480d8c46187a83855f78e8184ab" title="Create new llog file.">lop_declare_create</a>)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00232"></a>00232                                   <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *handle,
<a name="l00233"></a>00233                                   <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00234"></a>00234         int (*lop_create)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *handle,
<a name="l00235"></a>00235                           <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00240"></a>00240         int (*<a class="code" href="structllog__operations.html#ada38484d5d6669b28db201124b9ebc9e" title="write new record in llog.">lop_declare_write_rec</a>)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00241"></a>00241                                      <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *lgh,
<a name="l00242"></a>00242                                      <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec,
<a name="l00243"></a>00243                                      <span class="keywordtype">int</span> idx, <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00244"></a>00244         int (*lop_write_rec)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00245"></a>00245                              <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *loghandle,
<a name="l00246"></a>00246                              <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec,
<a name="l00247"></a>00247                              <span class="keyword">struct </span><a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> *cookie,
<a name="l00248"></a>00248                              <span class="keywordtype">int</span> idx, <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00253"></a>00253         int (*<a class="code" href="structllog__operations.html#a8d45958b3740ebc3a1e5316abaf002c7" title="Add new record in llog catalog.">lop_declare_add</a>)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00254"></a>00254                                <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *lgh,
<a name="l00255"></a>00255                                <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00256"></a>00256         int (*lop_add)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> *lgh,
<a name="l00257"></a>00257                        <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keyword">struct </span><a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> *cookie,
<a name="l00258"></a>00258                        <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00259"></a>00259 };
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="comment">/* In-memory descriptor for a log object or log catalog */</span>
<a name="l00262"></a><a class="code" href="structllog__handle.html">00262</a> <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a> {
<a name="l00263"></a>00263         <span class="keyword">struct </span>rw_semaphore      lgh_lock;
<a name="l00264"></a>00264         <span class="keyword">struct </span>mutex             lgh_hdr_mutex; <span class="comment">/* protect lgh_hdr data */</span>
<a name="l00265"></a>00265         <span class="keyword">struct </span><a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a>        lgh_id; <span class="comment">/* id of this log */</span>
<a name="l00266"></a>00266         <span class="keyword">struct </span><a class="code" href="structllog__log__hdr.html">llog_log_hdr</a>     *lgh_hdr; <span class="comment">/* may be vmalloc&apos;d */</span>
<a name="l00267"></a>00267         <span class="keywordtype">size_t</span>                  lgh_hdr_size;
<a name="l00268"></a>00268         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *lgh_obj;
<a name="l00269"></a>00269         <span class="comment">/* For a Catalog, is the last/newest used index for a plain slot.</span>
<a name="l00270"></a>00270 <span class="comment">         * Used in conjunction with llh_cat_idx to handle Catalog wrap-around</span>
<a name="l00271"></a>00271 <span class="comment">         * case, after it will have reached LLOG_HDR_BITMAP_SIZE, llh_cat_idx</span>
<a name="l00272"></a>00272 <span class="comment">         * will become its upper limit */</span>
<a name="l00273"></a>00273         <span class="keywordtype">int</span>                      lgh_last_idx;
<a name="l00274"></a>00274         <span class="keywordtype">int</span>                      lgh_cur_idx; <span class="comment">/* used during llog_process */</span>
<a name="l00275"></a>00275         __u64                    lgh_cur_offset; <span class="comment">/* used during llog_process */</span>
<a name="l00276"></a>00276         <span class="comment">/* used during llog_osd_write_rec */</span>
<a name="l00277"></a>00277         __u64                    lgh_write_offset;
<a name="l00278"></a>00278         <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a>        *lgh_ctxt;
<a name="l00279"></a>00279         <span class="keyword">union </span>{
<a name="l00280"></a>00280                 <span class="keyword">struct </span><a class="code" href="structplain__handle__data.html">plain_handle_data</a>         phd;
<a name="l00281"></a>00281                 <span class="keyword">struct </span><a class="code" href="structcat__handle__data.html">cat_handle_data</a>           chd;
<a name="l00282"></a>00282         } u;
<a name="l00283"></a>00283         <span class="keywordtype">char</span>                    *lgh_name;
<a name="l00284"></a>00284         <span class="keywordtype">void</span>                    *private_data;
<a name="l00285"></a>00285         <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a>  *lgh_logops;
<a name="l00286"></a>00286         atomic_t                 lgh_refcount;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288         __u32                   lgh_stale:1;
<a name="l00289"></a>00289 };
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="comment">/* llog_osd.c */</span>
<a name="l00292"></a>00292 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a> llog_osd_ops;
<a name="l00293"></a>00293 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a> llog_common_cat_ops;
<a name="l00294"></a>00294 <span class="keywordtype">int</span> <a class="code" href="group__log.html#gaf0dee2455ecbe5cbeeec044344224613" title="Read the special file which contains the list of llog catalogs IDs.">llog_osd_get_cat_list</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__device.html">dt_device</a> *d,
<a name="l00295"></a>00295                           <span class="keywordtype">int</span> idx, <span class="keywordtype">int</span> count, <span class="keyword">struct</span> <a class="code" href="structllog__catid.html">llog_catid</a> *idarray,
<a name="l00296"></a>00296                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid);
<a name="l00297"></a>00297 <span class="keywordtype">int</span> <a class="code" href="group__log.html#ga4b308f3bee04638c301ba0bead3ad070" title="Write the special file which contains the list of llog catalogs IDs.">llog_osd_put_cat_list</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__device.html">dt_device</a> *d,
<a name="l00298"></a>00298                           <span class="keywordtype">int</span> idx, <span class="keywordtype">int</span> count, <span class="keyword">struct</span> <a class="code" href="structllog__catid.html">llog_catid</a> *idarray,
<a name="l00299"></a>00299                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="preprocessor">#define LLOG_CTXT_FLAG_UNINITIALIZED     0x00000001</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span><span class="preprocessor">#define LLOG_CTXT_FLAG_STOP              0x00000002</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span>
<a name="l00304"></a>00304 <span class="comment">/* Indicate the llog objects under this context are normal FID objects,</span>
<a name="l00305"></a>00305 <span class="comment"> * instead of objects with local FID. */</span>
<a name="l00306"></a>00306 <span class="preprocessor">#define LLOG_CTXT_FLAG_NORMAL_FID        0x00000004</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>
<a name="l00308"></a><a class="code" href="structllog__ctxt.html">00308</a> <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a> {
<a name="l00309"></a>00309         <span class="keywordtype">int</span>                      loc_idx; <span class="comment">/* my index the obd array of ctxt&apos;s */</span>
<a name="l00310"></a>00310         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a>       *loc_obd; <span class="comment">/* points back to the containing obd*/</span>
<a name="l00311"></a>00311         <span class="keyword">struct </span><a class="code" href="structobd__llog__group.html">obd_llog_group</a>   *loc_olg; <span class="comment">/* group containing that ctxt */</span>
<a name="l00312"></a>00312         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>       *loc_exp; <span class="comment">/* parent &quot;disk&quot; export (e.g. MDS) */</span>
<a name="l00313"></a>00313         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a>       *loc_imp; <span class="comment">/* to use in RPC&apos;s: can be backward</span>
<a name="l00314"></a>00314 <span class="comment">                                             pointing import */</span>
<a name="l00315"></a>00315         <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a>  *loc_logops;
<a name="l00316"></a>00316         <span class="keyword">struct </span><a class="code" href="structllog__handle.html">llog_handle</a>      *loc_handle;
<a name="l00317"></a>00317         <span class="keyword">struct </span>mutex             loc_mutex; <span class="comment">/* protect loc_imp */</span>
<a name="l00318"></a>00318         atomic_t                 loc_refcount;
<a name="l00319"></a>00319         <span class="keywordtype">long</span>                     loc_flags; <span class="comment">/* flags, see above defines */</span>
<a name="l00320"></a>00320         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *loc_dir;
<a name="l00321"></a>00321         <span class="keyword">struct </span><a class="code" href="structlocal__oid__storage.html">local_oid_storage</a> *loc_los_nameless;
<a name="l00322"></a>00322         <span class="keyword">struct </span><a class="code" href="structlocal__oid__storage.html">local_oid_storage</a> *loc_los_named;
<a name="l00323"></a>00323         <span class="comment">/* llog chunk size, and llog record size can not be bigger than</span>
<a name="l00324"></a>00324 <span class="comment">         * loc_chunk_size */</span>
<a name="l00325"></a>00325         __u32                    loc_chunk_size;
<a name="l00326"></a>00326 };
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="preprocessor">#define LLOG_PROC_BREAK 0x0001</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span><span class="preprocessor">#define LLOG_DEL_RECORD 0x0002</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span><span class="preprocessor">#define LLOG_DEL_PLAIN  0x0003</span>
<a name="l00331"></a>00331 <span class="preprocessor"></span>
<a name="l00332"></a>00332 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_obd2ops(<span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt,
<a name="l00333"></a>00333                                <span class="keyword">struct</span> <a class="code" href="structllog__operations.html">llog_operations</a> **lop)
<a name="l00334"></a>00334 {
<a name="l00335"></a>00335         <span class="keywordflow">if</span> (ctxt == NULL)
<a name="l00336"></a>00336                 <span class="keywordflow">return</span> -ENOTCONN;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338         *lop = ctxt-&gt;loc_logops;
<a name="l00339"></a>00339         <span class="keywordflow">if</span> (*lop == NULL)
<a name="l00340"></a>00340                 <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342         <span class="keywordflow">return</span> 0;
<a name="l00343"></a>00343 }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_handle2ops(<span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle,
<a name="l00346"></a>00346                                   <span class="keyword">struct</span> <a class="code" href="structllog__operations.html">llog_operations</a> **lop)
<a name="l00347"></a>00347 {
<a name="l00348"></a>00348         <span class="keywordflow">if</span> (loghandle == NULL || loghandle-&gt;lgh_logops == NULL)
<a name="l00349"></a>00349                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00350"></a>00350 
<a name="l00351"></a>00351         *lop = loghandle-&gt;lgh_logops;
<a name="l00352"></a>00352         <span class="keywordflow">return</span> 0;
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_data_len(<span class="keywordtype">int</span> len)
<a name="l00356"></a>00356 {
<a name="l00357"></a>00357         <span class="keywordflow">return</span> cfs_size_round(len);
<a name="l00358"></a>00358 }
<a name="l00359"></a>00359 
<a name="l00360"></a>00360 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_get_size(<span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle)
<a name="l00361"></a>00361 {
<a name="l00362"></a>00362         <span class="keywordflow">if</span> (loghandle &amp;&amp; loghandle-&gt;lgh_hdr)
<a name="l00363"></a>00363                 <span class="keywordflow">return</span> loghandle-&gt;lgh_hdr-&gt;llh_count;
<a name="l00364"></a>00364         <span class="keywordflow">return</span> 0;
<a name="l00365"></a>00365 }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a> *llog_ctxt_get(<span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt)
<a name="l00368"></a>00368 {
<a name="l00369"></a>00369         atomic_inc(&amp;ctxt-&gt;loc_refcount);
<a name="l00370"></a>00370         CDEBUG(D_INFO, <span class="stringliteral">&quot;GETting ctxt %p : new refcount %d\n&quot;</span>, ctxt,
<a name="l00371"></a>00371                atomic_read(&amp;ctxt-&gt;loc_refcount));
<a name="l00372"></a>00372         <span class="keywordflow">return</span> ctxt;
<a name="l00373"></a>00373 }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> llog_ctxt_put(<span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt)
<a name="l00376"></a>00376 {
<a name="l00377"></a>00377         <span class="keywordflow">if</span> (ctxt == NULL)
<a name="l00378"></a>00378                 <span class="keywordflow">return</span>;
<a name="l00379"></a>00379         LASSERT_ATOMIC_GT_LT(&amp;ctxt-&gt;loc_refcount, 0, LI_POISON);
<a name="l00380"></a>00380         CDEBUG(D_INFO, <span class="stringliteral">&quot;PUTting ctxt %p : new refcount %d\n&quot;</span>, ctxt,
<a name="l00381"></a>00381                atomic_read(&amp;ctxt-&gt;loc_refcount) - 1);
<a name="l00382"></a>00382         __llog_ctxt_put(NULL, ctxt);
<a name="l00383"></a>00383 }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> llog_group_init(<span class="keyword">struct</span> <a class="code" href="structobd__llog__group.html">obd_llog_group</a> *olg)
<a name="l00386"></a>00386 {
<a name="l00387"></a>00387         init_waitqueue_head(&amp;olg-&gt;olg_waitq);
<a name="l00388"></a>00388         spin_lock_init(&amp;olg-&gt;olg_lock);
<a name="l00389"></a>00389         mutex_init(&amp;olg-&gt;olg_cat_processing);
<a name="l00390"></a>00390 }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_group_set_ctxt(<span class="keyword">struct</span> <a class="code" href="structobd__llog__group.html">obd_llog_group</a> *olg,
<a name="l00393"></a>00393                                       <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt, <span class="keywordtype">int</span> index)
<a name="l00394"></a>00394 {
<a name="l00395"></a>00395         LASSERT(index &gt;= 0 &amp;&amp; index &lt; LLOG_MAX_CTXTS);
<a name="l00396"></a>00396 
<a name="l00397"></a>00397         spin_lock(&amp;olg-&gt;olg_lock);
<a name="l00398"></a>00398         <span class="keywordflow">if</span> (olg-&gt;olg_ctxts[index] != NULL) {
<a name="l00399"></a>00399                 spin_unlock(&amp;olg-&gt;olg_lock);
<a name="l00400"></a>00400                 <span class="keywordflow">return</span> -EEXIST;
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402         olg-&gt;olg_ctxts[index] = ctxt;
<a name="l00403"></a>00403         spin_unlock(&amp;olg-&gt;olg_lock);
<a name="l00404"></a>00404         <span class="keywordflow">return</span> 0;
<a name="l00405"></a>00405 }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a> *llog_group_get_ctxt(<span class="keyword">struct</span> <a class="code" href="structobd__llog__group.html">obd_llog_group</a> *olg,
<a name="l00408"></a>00408                                                     <span class="keywordtype">int</span> index)
<a name="l00409"></a>00409 {
<a name="l00410"></a>00410         <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt;
<a name="l00411"></a>00411 
<a name="l00412"></a>00412         LASSERT(index &gt;= 0 &amp;&amp; index &lt; LLOG_MAX_CTXTS);
<a name="l00413"></a>00413 
<a name="l00414"></a>00414         spin_lock(&amp;olg-&gt;olg_lock);
<a name="l00415"></a>00415         <span class="keywordflow">if</span> (olg-&gt;olg_ctxts[index] == NULL)
<a name="l00416"></a>00416                 ctxt = NULL;
<a name="l00417"></a>00417         <span class="keywordflow">else</span>
<a name="l00418"></a>00418                 ctxt = llog_ctxt_get(olg-&gt;olg_ctxts[index]);
<a name="l00419"></a>00419         spin_unlock(&amp;olg-&gt;olg_lock);
<a name="l00420"></a>00420         <span class="keywordflow">return</span> ctxt;
<a name="l00421"></a>00421 }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> llog_group_clear_ctxt(<span class="keyword">struct</span> <a class="code" href="structobd__llog__group.html">obd_llog_group</a> *olg, <span class="keywordtype">int</span> index)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425         LASSERT(index &gt;= 0 &amp;&amp; index &lt; LLOG_MAX_CTXTS);
<a name="l00426"></a>00426         spin_lock(&amp;olg-&gt;olg_lock);
<a name="l00427"></a>00427         olg-&gt;olg_ctxts[index] = NULL;
<a name="l00428"></a>00428         spin_unlock(&amp;olg-&gt;olg_lock);
<a name="l00429"></a>00429 }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a> *llog_get_context(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd,
<a name="l00432"></a>00432                                                  <span class="keywordtype">int</span> index)
<a name="l00433"></a>00433 {
<a name="l00434"></a>00434         <span class="keywordflow">return</span> llog_group_get_ctxt(&amp;obd-&gt;obd_olg, index);
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_group_ctxt_null(<span class="keyword">struct</span> <a class="code" href="structobd__llog__group.html">obd_llog_group</a> *olg, <span class="keywordtype">int</span> index)
<a name="l00438"></a>00438 {
<a name="l00439"></a>00439         <span class="keywordflow">return</span> (olg-&gt;olg_ctxts[index] == NULL);
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_ctxt_null(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd, <span class="keywordtype">int</span> index)
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444         <span class="keywordflow">return</span> (llog_group_ctxt_null(&amp;obd-&gt;obd_olg, index));
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_next_block(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00448"></a>00448                                   <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle, <span class="keywordtype">int</span> *cur_idx,
<a name="l00449"></a>00449                                   <span class="keywordtype">int</span> next_idx, __u64 *cur_offset, <span class="keywordtype">void</span> *buf,
<a name="l00450"></a>00450                                   <span class="keywordtype">int</span> len)
<a name="l00451"></a>00451 {
<a name="l00452"></a>00452         <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a> *lop;
<a name="l00453"></a>00453         <span class="keywordtype">int</span> rc;
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         ENTRY;
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         rc = llog_handle2ops(loghandle, &amp;lop);
<a name="l00458"></a>00458         <span class="keywordflow">if</span> (rc)
<a name="l00459"></a>00459                 RETURN(rc);
<a name="l00460"></a>00460         <span class="keywordflow">if</span> (lop-&gt;lop_next_block == NULL)
<a name="l00461"></a>00461                 RETURN(-EOPNOTSUPP);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463         rc = lop-&gt;lop_next_block(env, loghandle, cur_idx, next_idx,
<a name="l00464"></a>00464                                  cur_offset, buf, len);
<a name="l00465"></a>00465         RETURN(rc);
<a name="l00466"></a>00466 }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_prev_block(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00469"></a>00469                                   <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle,
<a name="l00470"></a>00470                                   <span class="keywordtype">int</span> prev_idx, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> len)
<a name="l00471"></a>00471 {
<a name="l00472"></a>00472         <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a> *lop;
<a name="l00473"></a>00473         <span class="keywordtype">int</span> rc;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         ENTRY;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         rc = llog_handle2ops(loghandle, &amp;lop);
<a name="l00478"></a>00478         <span class="keywordflow">if</span> (rc)
<a name="l00479"></a>00479                 RETURN(rc);
<a name="l00480"></a>00480         <span class="keywordflow">if</span> (lop-&gt;lop_prev_block == NULL)
<a name="l00481"></a>00481                 RETURN(-EOPNOTSUPP);
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         rc = lop-&gt;lop_prev_block(env, loghandle, prev_idx, buf, len);
<a name="l00484"></a>00484         RETURN(rc);
<a name="l00485"></a>00485 }
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_connect(<span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt,
<a name="l00488"></a>00488                                <span class="keyword">struct</span> <a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a> *logid, <span class="keyword">struct</span> <a class="code" href="structllog__gen.html">llog_gen</a> *gen,
<a name="l00489"></a>00489                                <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid)
<a name="l00490"></a>00490 {
<a name="l00491"></a>00491         <span class="keyword">struct </span><a class="code" href="structllog__operations.html">llog_operations</a>  *lop;
<a name="l00492"></a>00492         <span class="keywordtype">int</span>                      rc;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494         ENTRY;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496         rc = llog_obd2ops(ctxt, &amp;lop);
<a name="l00497"></a>00497         <span class="keywordflow">if</span> (rc)
<a name="l00498"></a>00498                 RETURN(rc);
<a name="l00499"></a>00499         <span class="keywordflow">if</span> (lop-&gt;lop_connect == NULL)
<a name="l00500"></a>00500                 RETURN(-EOPNOTSUPP);
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         rc = lop-&gt;lop_connect(ctxt, logid, gen, uuid);
<a name="l00503"></a>00503         RETURN(rc);
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> llog_is_full(<span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *llh)
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508         <span class="keywordflow">return</span> llh-&gt;lgh_last_idx &gt;= LLOG_HDR_BITMAP_SIZE(llh-&gt;lgh_hdr) - 1;
<a name="l00509"></a>00509 }
<a name="l00510"></a>00510 
<a name="l00511"></a><a class="code" href="structllog__cfg__rec.html">00511</a> <span class="keyword">struct </span><a class="code" href="structllog__cfg__rec.html">llog_cfg_rec</a> {
<a name="l00512"></a>00512         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     lcr_hdr;
<a name="l00513"></a>00513         <span class="keyword">struct </span><a class="code" href="structlustre__cfg.html">lustre_cfg</a>       lcr_cfg;
<a name="l00514"></a>00514         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>    lcr_tail;
<a name="l00515"></a>00515 };
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="keyword">struct </span><a class="code" href="structllog__cfg__rec.html">llog_cfg_rec</a> *lustre_cfg_rec_new(<span class="keywordtype">int</span> cmd, <span class="keyword">struct</span> <a class="code" href="structlustre__cfg__bufs.html">lustre_cfg_bufs</a> *bufs);
<a name="l00518"></a>00518 <span class="keywordtype">void</span> lustre_cfg_rec_free(<span class="keyword">struct</span> <a class="code" href="structllog__cfg__rec.html">llog_cfg_rec</a> *lcr);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="keyword">enum</span> {
<a name="l00521"></a>00521         LLOG_NEXT_IDX = -1,
<a name="l00522"></a>00522         LLOG_HEADER_IDX = 0,
<a name="l00523"></a>00523 };
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 <span class="comment">/* llog.c */</span>
<a name="l00526"></a>00526 <span class="keywordtype">int</span> <a class="code" href="group__log.html#gab4498d20e447d4dbeaff34eb3b305d57" title="new llog API">llog_exist</a>(<span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle);
<a name="l00527"></a>00527 <span class="keywordtype">int</span> llog_declare_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00528"></a>00528                         <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00529"></a>00529 <span class="keywordtype">int</span> llog_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *handle,
<a name="l00530"></a>00530                 <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00531"></a>00531 <span class="keywordtype">int</span> llog_trans_destroy(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *handle,
<a name="l00532"></a>00532                        <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00533"></a>00533 <span class="keywordtype">int</span> llog_destroy(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *handle);
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 <span class="keywordtype">int</span> llog_declare_write_rec(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00536"></a>00536                            <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *handle,
<a name="l00537"></a>00537                            <span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keywordtype">int</span> idx,
<a name="l00538"></a>00538                            <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00539"></a>00539 <span class="keywordtype">int</span> llog_write_rec(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *handle,
<a name="l00540"></a>00540                    <span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keyword">struct</span> <a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> *logcookies,
<a name="l00541"></a>00541                    <span class="keywordtype">int</span> idx, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00542"></a>00542 <span class="keywordtype">int</span> llog_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *lgh,
<a name="l00543"></a>00543              <span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keyword">struct</span> <a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> *logcookies,
<a name="l00544"></a>00544              <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00545"></a>00545 <span class="keywordtype">int</span> llog_declare_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *lgh,
<a name="l00546"></a>00546                      <span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th);
<a name="l00547"></a>00547 <span class="keywordtype">int</span> <a class="code" href="group__log.html#gab379f30f30f88aebf9be8c61b7f55152" title="Get a config log from the MGS and process it.">lustre_process_log</a>(<span class="keyword">struct</span> super_block *sb, <span class="keywordtype">char</span> *logname,
<a name="l00548"></a>00548                        <span class="keyword">struct</span> <a class="code" href="structconfig__llog__instance.html">config_llog_instance</a> *cfg);
<a name="l00549"></a>00549 <span class="keywordtype">int</span> lustre_end_log(<span class="keyword">struct</span> super_block *sb, <span class="keywordtype">char</span> *logname,
<a name="l00550"></a>00550                    <span class="keyword">struct</span> <a class="code" href="structconfig__llog__instance.html">config_llog_instance</a> *cfg);
<a name="l00551"></a>00551 <span class="keywordtype">int</span> <a class="code" href="group__log.html#gae96db4e0338a67db6a75218a14d22b4f" title="Helper function to open llog or create it if doesn&amp;#39;t exist.">llog_open_create</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt,
<a name="l00552"></a>00552                      <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> **res, <span class="keyword">struct</span> <a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a> *logid,
<a name="l00553"></a>00553                      <span class="keywordtype">char</span> *name);
<a name="l00554"></a>00554 <span class="keywordtype">int</span> <a class="code" href="group__log.html#gaf5171710a6a625218951e36e3c7d3e01" title="Helper function to delete existent llog.">llog_erase</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__ctxt.html">llog_ctxt</a> *ctxt,
<a name="l00555"></a>00555                <span class="keyword">struct</span> <a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a> *logid, <span class="keywordtype">char</span> *name);
<a name="l00556"></a>00556 <span class="keywordtype">int</span> llog_write(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structllog__handle.html">llog_handle</a> *loghandle,
<a name="l00557"></a>00557                <span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec, <span class="keywordtype">int</span> idx);
<a name="l00558"></a>00558 
<a name="l00561"></a>00561 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:13 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
