<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: cl_io_operations Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cl_io_operations Struct Reference<br/>
<small>
[<a class="el" href="group__cl__io.html">cl_io</a>]</small>
</h1><!-- doxytag: class="cl_io_operations" -->
<p>Per-layer io operations.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl__object_8h_source.html">cl_object.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" >struct {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;int(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io__operations.html#aeedb0fcc4555583225020c012c5b84e1">cio_iter_init</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare io iteration at a given layer.  <a href="#ad74f24e28e7d0d72610e1449d2325e57"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;void(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io__operations.html#a2c6f9fa7cecb546bd2b46156d57b10dd">cio_iter_fini</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize io iteration.  <a href="#ae1e74fce78ecd662a7a5b874fb9eb1ad"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;int(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io__operations.html#a4211dc9e2bf48da829c2fffd4633b1cf">cio_lock</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect locks for the current iteration of io.  <a href="#aa24a19a66eaad7ff273d4a43c3538bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;void(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io__operations.html#a8f4e4c71f42b1acdc2b935826d2a6e90">cio_unlock</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize unlocking.  <a href="#a0b0d47707b3107d686a21638a3da8968"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;int(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io__operations.html#a29bbb031f049b8a1a5e54d575fa88209">cio_start</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start io iteration.  <a href="#a7822dd1b2fc8c20add63c7c1f2713c4e"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;void(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io__operations.html#a4d3dfb49a0fbf1f90b3de60841183d0a">cio_end</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called top-to-bottom at the end of io loop.  <a href="#ab0188362993033631b2f402e19055174"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;void(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io__operations.html#a32c79a8ffbf81724ef4df5c2fd05e263">cio_advance</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice, size_t nob)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called bottom-to-top to notify layers that read/write IO iteration finished, with <em>nob</em> bytes transferred. <br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;void(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io__operations.html#a09ecbd759c7a3569d67a75e9f201d1ba">cio_fini</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called once per io, bottom-to-top to release io resources. <br/></td></tr>
<tr><td class="memItemLeft" valign="top">}&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282">op</a> [CIT_OP_NR]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of io state transition methods for every io type.  <a href="#a646d5084e9960fc83c6ac20e37640282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io__operations.html#a2aa87d92a0f183a26ae076afc9b8b74f">cio_submit</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt, struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit pages from <em>queue-&gt;c2_qin</em> for IO, and move successfully submitted pages into <em>queue-&gt;c2_qout</em>.  <a href="#a2aa87d92a0f183a26ae076afc9b8b74f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io__operations.html#a1c88c4ec4901b77c0a32b3951f217f8c">cio_commit_async</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *queue, int from, int to, cl_commit_cbt cb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue async page for write.  <a href="#a1c88c4ec4901b77c0a32b3951f217f8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io__operations.html#a4a7f6334b0e726f9c7fc52b8064a2613">cio_read_ahead</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice, pgoff_t start, struct <a class="el" href="structcl__read__ahead.html">cl_read_ahead</a> *ra)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decide maximum read ahead extent.  <a href="#a4a7f6334b0e726f9c7fc52b8064a2613"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io__operations.html#a4f9f80a35b71985f258a226cb32c91cf">cio_print</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> p, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional debugging helper.  <a href="#a4f9f80a35b71985f258a226cb32c91cf"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Per-layer io operations. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>vvp_io_ops, lov_io_ops, lovsub_io_ops, osc_io_ops </dd></dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01481">1481</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a1c88c4ec4901b77c0a32b3951f217f8c"></a><!-- doxytag: member="cl_io_operations::cio_commit_async" ref="a1c88c4ec4901b77c0a32b3951f217f8c" args=")(const struct lu_env *env, const struct cl_io_slice *slice, struct cl_page_list *queue, int from, int to, cl_commit_cbt cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__io__operations.html#a1c88c4ec4901b77c0a32b3951f217f8c">cl_io_operations::cio_commit_async</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice, struct <a class="el" href="structcl__page__list.html">cl_page_list</a> *queue, int from, int to, cl_commit_cbt cb)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue async page for write. </p>
<p>The difference between cio_submit and cio_queue is that cio_submit is for urgent request. </p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00646">cl_io_commit_async()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d3dfb49a0fbf1f90b3de60841183d0a"></a><!-- doxytag: member="cl_io_operations::cio_end" ref="a4d3dfb49a0fbf1f90b3de60841183d0a" args=")(const struct lu_env *env, const struct cl_io_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__io__operations.html#a4d3dfb49a0fbf1f90b3de60841183d0a">cl_io_operations::cio_end</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called top-to-bottom at the end of io loop. </p>
<p>Here layer might wait for an unfinished asynchronous io. </p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00593">cl_io_end()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c6f9fa7cecb546bd2b46156d57b10dd"></a><!-- doxytag: member="cl_io_operations::cio_iter_fini" ref="a2c6f9fa7cecb546bd2b46156d57b10dd" args=")(const struct lu_env *env, const struct cl_io_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__io__operations.html#a2c6f9fa7cecb546bd2b46156d57b10dd">cl_io_operations::cio_iter_fini</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalize io iteration. </p>
<p>Called bottom-to-top at the end of each iteration of "io
 loop". Here layers can decide whether IO has to be continued.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__io__operations.html#aeedb0fcc4555583225020c012c5b84e1" title="Prepare io iteration at a given layer.">cl_io_operations::cio_iter_init()</a> </dd></dl>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00469">cl_io_iter_fini()</a>.</p>

</div>
</div>
<a class="anchor" id="aeedb0fcc4555583225020c012c5b84e1"></a><!-- doxytag: member="cl_io_operations::cio_iter_init" ref="aeedb0fcc4555583225020c012c5b84e1" args=")(const struct lu_env *env, const struct cl_io_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__io__operations.html#aeedb0fcc4555583225020c012c5b84e1">cl_io_operations::cio_iter_init</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare io iteration at a given layer. </p>
<p>Called top-to-bottom at the beginning of each iteration of "io loop" (if it makes sense for this type of io). Here layer selects what work it will do during this iteration.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__io__operations.html#a2c6f9fa7cecb546bd2b46156d57b10dd" title="Finalize io iteration.">cl_io_operations::cio_iter_fini()</a> </dd></dl>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00439">cl_io_iter_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a4211dc9e2bf48da829c2fffd4633b1cf"></a><!-- doxytag: member="cl_io_operations::cio_lock" ref="a4211dc9e2bf48da829c2fffd4633b1cf" args=")(const struct lu_env *env, const struct cl_io_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__io__operations.html#a4211dc9e2bf48da829c2fffd4633b1cf">cl_io_operations::cio_lock</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Collect locks for the current iteration of io. </p>
<p>Called top-to-bottom to collect all locks necessary for this iteration. This methods shouldn't actually enqueue anything, instead it should post a lock through <a class="el" href="group__cl__io.html#ga80fe084e78e83a4a66fceb0e2c605b6e" title="Adds a lock to a lockset.">cl_io_lock_add()</a>. Once all locks are collected, they are sorted and enqueued in the proper order. </p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00363">cl_io_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f9f80a35b71985f258a226cb32c91cf"></a><!-- doxytag: member="cl_io_operations::cio_print" ref="a4f9f80a35b71985f258a226cb32c91cf" args=")(const struct lu_env *env, void *cookie, lu_printer_t p, const struct cl_io_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__io__operations.html#a4f9f80a35b71985f258a226cb32c91cf">cl_io_operations::cio_print</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> p, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optional debugging helper. </p>
<p>Print given io slice. </p>

</div>
</div>
<a class="anchor" id="a4a7f6334b0e726f9c7fc52b8064a2613"></a><!-- doxytag: member="cl_io_operations::cio_read_ahead" ref="a4a7f6334b0e726f9c7fc52b8064a2613" args=")(const struct lu_env *env, const struct cl_io_slice *slice, pgoff_t start, struct cl_read_ahead *ra)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__io__operations.html#a4a7f6334b0e726f9c7fc52b8064a2613">cl_io_operations::cio_read_ahead</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice, pgoff_t start, struct <a class="el" href="structcl__read__ahead.html">cl_read_ahead</a> *ra)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decide maximum read ahead extent. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>io-&gt;ci_type == CIT_READ </dd></dl>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00617">cl_io_read_ahead()</a>.</p>

</div>
</div>
<a class="anchor" id="a29bbb031f049b8a1a5e54d575fa88209"></a><!-- doxytag: member="cl_io_operations::cio_start" ref="a29bbb031f049b8a1a5e54d575fa88209" args=")(const struct lu_env *env, const struct cl_io_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__io__operations.html#a29bbb031f049b8a1a5e54d575fa88209">cl_io_operations::cio_start</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start io iteration. </p>
<p>Once all locks are acquired, called top-to-bottom to commence actual IO. In the current implementation, top-level vvp_io_{read,write}_start() does all the work synchronously by calling generic_file_*(), so other layers are called when everything is done. </p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00565">cl_io_start()</a>.</p>

</div>
</div>
<a class="anchor" id="a2aa87d92a0f183a26ae076afc9b8b74f"></a><!-- doxytag: member="cl_io_operations::cio_submit" ref="a2aa87d92a0f183a26ae076afc9b8b74f" args=")(const struct lu_env *env, const struct cl_io_slice *slice, enum cl_req_type crt, struct cl_2queue *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__io__operations.html#a2aa87d92a0f183a26ae076afc9b8b74f">cl_io_operations::cio_submit</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt, struct <a class="el" href="structcl__2queue.html">cl_2queue</a> *queue)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit pages from <em>queue-&gt;c2_qin</em> for IO, and move successfully submitted pages into <em>queue-&gt;c2_qout</em>. </p>
<p>Return non-zero if failed to submit even the single page. If submission failed after some pages were moved into <em>queue-&gt;c2_qout</em>, completion callback with non-zero ioret is executed on them. </p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00676">cl_io_submit_rw()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f4e4c71f42b1acdc2b935826d2a6e90"></a><!-- doxytag: member="cl_io_operations::cio_unlock" ref="a8f4e4c71f42b1acdc2b935826d2a6e90" args=")(const struct lu_env *env, const struct cl_io_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__io__operations.html#a8f4e4c71f42b1acdc2b935826d2a6e90">cl_io_operations::cio_unlock</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__io__slice.html">cl_io_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalize unlocking. </p>
<p>Called bottom-to-top to finish layer specific unlocking functionality, after generic code released all locks acquired by <a class="el" href="structcl__io__operations.html#a4211dc9e2bf48da829c2fffd4633b1cf" title="Collect locks for the current iteration of io.">cl_io_operations::cio_lock()</a>. </p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00395">cl_io_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a646d5084e9960fc83c6ac20e37640282"></a><!-- doxytag: member="cl_io_operations::op" ref="a646d5084e9960fc83c6ac20e37640282" args="[CIT_OP_NR]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   <a class="el" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282">cl_io_operations::op</a>[CIT_OP_NR]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector of io state transition methods for every io type. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485" title="Request type dependent vector of operations.">cl_page_operations::io</a> </dd></dl>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00593">cl_io_end()</a>, <a class="el" href="cl__io_8c_source.html#l00103">cl_io_fini()</a>, <a class="el" href="cl__io_8c_source.html#l00469">cl_io_iter_fini()</a>, <a class="el" href="cl__io_8c_source.html#l00439">cl_io_iter_init()</a>, <a class="el" href="cl__io_8c_source.html#l00363">cl_io_lock()</a>, <a class="el" href="cl__io_8c_source.html#l00490">cl_io_rw_advance()</a>, <a class="el" href="cl__io_8c_source.html#l00565">cl_io_start()</a>, and <a class="el" href="cl__io_8c_source.html#l00395">cl_io_unlock()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="cl__object_8h_source.html">cl_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:56:01 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
