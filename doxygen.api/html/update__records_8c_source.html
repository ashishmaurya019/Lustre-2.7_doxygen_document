<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/target/update_records.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/target/update_records.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.gnu.org/licenses/gpl-2.0.html</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * GPL HEADER END</span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 <span class="comment">/*</span>
<a name="l00023"></a>00023 <span class="comment"> * Copyright (c) 2014, 2015, Intel Corporation.</span>
<a name="l00024"></a>00024 <span class="comment"> */</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * lustre/target/update_records.c</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> * This file implement the methods to pack updates as update records, which</span>
<a name="l00030"></a>00030 <span class="comment"> * will be written to the disk as llog record, and might be used during</span>
<a name="l00031"></a>00031 <span class="comment"> * recovery.</span>
<a name="l00032"></a>00032 <span class="comment"> *</span>
<a name="l00033"></a>00033 <span class="comment"> * For cross-MDT operation, all of updates of the operation needs to be</span>
<a name="l00034"></a>00034 <span class="comment"> * recorded in the disk, then during recovery phase, the recovery thread</span>
<a name="l00035"></a>00035 <span class="comment"> * will retrieve and redo these updates if it needed.</span>
<a name="l00036"></a>00036 <span class="comment"> *</span>
<a name="l00037"></a>00037 <span class="comment"> * See comments above struct update_records for the format of update_records.</span>
<a name="l00038"></a>00038 <span class="comment"> *</span>
<a name="l00039"></a>00039 <span class="comment"> * Author: Di Wang &lt;di.wang@intel.com&gt;</span>
<a name="l00040"></a>00040 <span class="comment"> */</span>
<a name="l00041"></a>00041 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_CLASS</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;lu_target.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;lustre_obdo.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;lustre_update.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;obd.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;tgt_internal.h&quot;</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#define UPDATE_RECORDS_BUFFER_SIZE      8192</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define UPDATE_PARAMS_BUFFER_SIZE       8192</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="keywordtype">void</span> update_records_dump(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structupdate__records.html">update_records</a> *records,
<a name="l00064"></a>00064                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask, <span class="keywordtype">bool</span> dump_updates)
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structupdate__ops.html">update_ops</a> *ops;
<a name="l00067"></a>00067         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structupdate__op.html">update_op</a>  *op = NULL;
<a name="l00068"></a>00068         <span class="keyword">struct </span><a class="code" href="structupdate__params.html">update_params</a>    *params = NULL;
<a name="l00069"></a>00069         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
<a name="l00070"></a>00070 
<a name="l00071"></a>00071         CDEBUG(mask, <span class="stringliteral">&quot;master transno = &quot;</span>LPU64<span class="stringliteral">&quot; batchid = &quot;</span>LPU64<span class="stringliteral">&quot; flags = %x&quot;</span>
<a name="l00072"></a>00072                <span class="stringliteral">&quot; ops = %d params = %d\n&quot;</span>, records-&gt;ur_master_transno,
<a name="l00073"></a>00073                records-&gt;ur_batchid, records-&gt;ur_flags, records-&gt;ur_update_count,
<a name="l00074"></a>00074                records-&gt;ur_param_count);
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <span class="keywordflow">if</span> (records-&gt;ur_update_count == 0)
<a name="l00077"></a>00077                 <span class="keywordflow">return</span>;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079         <span class="keywordflow">if</span> (!dump_updates)
<a name="l00080"></a>00080                 <span class="keywordflow">return</span>;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082         ops = &amp;records-&gt;ur_ops;
<a name="l00083"></a>00083         <span class="keywordflow">if</span> (records-&gt;ur_param_count &gt; 0)
<a name="l00084"></a>00084                 params = update_records_get_params(records);
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         op = &amp;ops-&gt;uops_op[0];
<a name="l00087"></a>00087         <span class="keywordflow">for</span> (i = 0; i &lt; records-&gt;ur_update_count; i++,
<a name="l00088"></a>00088                                   op = update_op_next_op(op)) {
<a name="l00089"></a>00089                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091                 CDEBUG(mask, <span class="stringliteral">&quot;update %dth &quot;</span>DFID<span class="stringliteral">&quot; %s params_count = %hu\n&quot;</span>, i,
<a name="l00092"></a>00092                        PFID(&amp;op-&gt;uop_fid), update_op_str(op-&gt;uop_type),
<a name="l00093"></a>00093                        op-&gt;uop_param_count);
<a name="l00094"></a>00094 
<a name="l00095"></a>00095                 <span class="keywordflow">if</span> (params == NULL)
<a name="l00096"></a>00096                         <span class="keywordflow">continue</span>;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098                 <span class="keywordflow">for</span> (j = 0;  j &lt; op-&gt;uop_param_count; j++) {
<a name="l00099"></a>00099                         <span class="keyword">struct </span><a class="code" href="structobject__update__param.html">object_update_param</a> *param;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101                         param = update_params_get_param(params,
<a name="l00102"></a>00102                                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)op-&gt;uop_params_off[j],
<a name="l00103"></a>00103                                         records-&gt;ur_param_count);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105                         <span class="keywordflow">if</span> (param == NULL)
<a name="l00106"></a>00106                                 <span class="keywordflow">continue</span>;
<a name="l00107"></a>00107                         CDEBUG(mask, <span class="stringliteral">&quot;param = %p %dth off = %hu size = %hu\n&quot;</span>,
<a name="l00108"></a>00108                                param, j, op-&gt;uop_params_off[j], param-&gt;oup_len);
<a name="l00109"></a>00109                 }
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111 }
<a name="l00112"></a>00112 
<a name="l00128"></a>00128 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> update_records_param_pack(<span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00129"></a>00129                                               <span class="keyword">const</span> <span class="keywordtype">void</span> *new_param,
<a name="l00130"></a>00130                                               <span class="keywordtype">size_t</span> new_param_size,
<a name="l00131"></a>00131                                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count)
<a name="l00132"></a>00132 {
<a name="l00133"></a>00133         <span class="keyword">struct </span><a class="code" href="structobject__update__param.html">object_update_param</a>      *param;
<a name="l00134"></a>00134         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    i;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136         <span class="keywordflow">for</span> (i = 0; i &lt; *param_count; i++) {
<a name="l00137"></a>00137                 <span class="keyword">struct </span><a class="code" href="structobject__update__param.html">object_update_param</a> *param;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139                 param = update_params_get_param(params, i, *param_count);
<a name="l00140"></a>00140                 <span class="keywordflow">if</span> ((new_param == NULL &amp;&amp; param-&gt;oup_len == new_param_size) ||
<a name="l00141"></a>00141                     (param-&gt;oup_len == new_param_size &amp;&amp;
<a name="l00142"></a>00142                      memcmp(param-&gt;oup_buf, new_param, new_param_size) == 0))
<a name="l00143"></a>00143                         <span class="comment">/* Found the parameter and return its index */</span>
<a name="l00144"></a>00144                         <span class="keywordflow">return</span> i;
<a name="l00145"></a>00145         }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147         param = (<span class="keyword">struct </span><a class="code" href="structobject__update__param.html">object_update_param</a> *)((<span class="keywordtype">char</span> *)params +
<a name="l00148"></a>00148                                 update_params_size(params, *param_count));
<a name="l00149"></a>00149 
<a name="l00150"></a>00150         param-&gt;oup_len = new_param_size;
<a name="l00151"></a>00151         <span class="keywordflow">if</span> (new_param != NULL)
<a name="l00152"></a>00152                 memcpy(param-&gt;oup_buf, new_param, new_param_size);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         *param_count = *param_count + 1;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156         <span class="keywordflow">return</span> *param_count - 1;
<a name="l00157"></a>00157 }
<a name="l00158"></a>00158 
<a name="l00184"></a>00184 <span class="keyword">static</span> <span class="keywordtype">int</span> update_records_update_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00185"></a>00185                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00186"></a>00186                                       <span class="keyword">enum</span> <a class="code" href="group__lustreidl.html#ga2d1a90f202540bfbcbd72a8c0f94b586" title="OUT_UPDATE RPC Format.">update_type</a> op_type,
<a name="l00187"></a>00187                                       <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00188"></a>00188                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00189"></a>00189                                       <span class="keywordtype">size_t</span> *max_op_size,
<a name="l00190"></a>00190                                       <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00191"></a>00191                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00192"></a>00192                                       <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00193"></a>00193                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> param_bufs_count,
<a name="l00194"></a>00194                                       <span class="keyword">const</span> <span class="keywordtype">void</span> **param_bufs,
<a name="l00195"></a>00195                                       <span class="keywordtype">size_t</span> *param_sizes)
<a name="l00196"></a>00196 {
<a name="l00197"></a>00197         <span class="keyword">struct </span><a class="code" href="structupdate__op.html">update_op</a>        *op;
<a name="l00198"></a>00198         <span class="keywordtype">size_t</span>                  total_param_sizes = 0;
<a name="l00199"></a>00199         <span class="keywordtype">int</span>                     index;
<a name="l00200"></a>00200         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="comment">/* Check whether the packing exceeding the maximum update size */</span>
<a name="l00203"></a>00203         <span class="keywordflow">if</span> (unlikely(*max_op_size &lt; update_op_size(param_bufs_count))) {
<a name="l00204"></a>00204                 CDEBUG(D_INFO, <span class="stringliteral">&quot;max_op_size = %zu update_op = %zu\n&quot;</span>,
<a name="l00205"></a>00205                        *max_op_size, update_op_size(param_bufs_count));
<a name="l00206"></a>00206                 *max_op_size = update_op_size(param_bufs_count);
<a name="l00207"></a>00207                 <span class="keywordflow">return</span> -E2BIG;
<a name="l00208"></a>00208         }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <span class="keywordflow">for</span> (i = 0; i &lt; param_bufs_count; i++)
<a name="l00211"></a>00211                 total_param_sizes +=
<a name="l00212"></a>00212                         cfs_size_round(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structobject__update__param.html">object_update_param</a>) +
<a name="l00213"></a>00213                                        param_sizes[i]);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         <span class="comment">/* Check whether the packing exceeding the maximum parameter size */</span>
<a name="l00216"></a>00216         <span class="keywordflow">if</span> (unlikely(*max_param_size &lt; total_param_sizes)) {
<a name="l00217"></a>00217                 CDEBUG(D_INFO, <span class="stringliteral">&quot;max_param_size = %zu params size = %zu\n&quot;</span>,
<a name="l00218"></a>00218                        *max_param_size, total_param_sizes);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220                 *max_param_size = total_param_sizes;
<a name="l00221"></a>00221                 <span class="keywordflow">return</span> -E2BIG;
<a name="l00222"></a>00222         }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224         op = update_ops_get_op(ops, *op_count, *op_count);
<a name="l00225"></a>00225         op-&gt;uop_fid = *fid;
<a name="l00226"></a>00226         op-&gt;uop_type = op_type;
<a name="l00227"></a>00227         op-&gt;uop_param_count = param_bufs_count;
<a name="l00228"></a>00228         <span class="keywordflow">for</span> (i = 0; i &lt; param_bufs_count; i++) {
<a name="l00229"></a>00229                 index = update_records_param_pack(params, param_bufs[i],
<a name="l00230"></a>00230                                                   param_sizes[i], param_count);
<a name="l00231"></a>00231                 <span class="keywordflow">if</span> (index &lt; 0)
<a name="l00232"></a>00232                         <span class="keywordflow">return</span> index;
<a name="l00233"></a>00233 
<a name="l00234"></a>00234                 CDEBUG(D_INFO, <span class="stringliteral">&quot;%s %uth param offset = %d size = %zu\n&quot;</span>,
<a name="l00235"></a>00235                        update_op_str(op_type), i, index, param_sizes[i]);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237                 op-&gt;uop_params_off[i] = index;
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239         CDEBUG(D_INFO, <span class="stringliteral">&quot;%huth &quot;</span>DFID<span class="stringliteral">&quot; %s param_count = %u\n&quot;</span>,
<a name="l00240"></a>00240                *op_count, PFID(fid), update_op_str(op_type), *param_count);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         *op_count = *op_count + 1;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244         <span class="keywordflow">return</span> 0;
<a name="l00245"></a>00245 }
<a name="l00246"></a>00246 
<a name="l00257"></a>00257 <span class="keyword">static</span> <span class="keywordtype">size_t</span> update_records_update_size(__u32 param_count, <span class="keywordtype">size_t</span> *sizes)
<a name="l00258"></a>00258 {
<a name="l00259"></a>00259         <span class="keywordtype">int</span> i;
<a name="l00260"></a>00260         <span class="keywordtype">size_t</span> size;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         <span class="comment">/* Check whether the packing exceeding the maximum update size */</span>
<a name="l00263"></a>00263         size = update_op_size(param_count);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265         <span class="keywordflow">for</span> (i = 0; i &lt; param_count; i++)
<a name="l00266"></a>00266                 size += cfs_size_round(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structobject__update__param.html">object_update_param</a>) +
<a name="l00267"></a>00267                                        sizes[i]);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         <span class="keywordflow">return</span> size;
<a name="l00270"></a>00270 }
<a name="l00271"></a>00271 
<a name="l00284"></a>00284 <span class="keywordtype">size_t</span> update_records_create_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00285"></a>00285                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00286"></a>00286                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l00287"></a>00287                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint,
<a name="l00288"></a>00288                                   <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof)
<a name="l00289"></a>00289 {
<a name="l00290"></a>00290         <span class="keywordtype">size_t</span>  sizes[2];
<a name="l00291"></a>00291         <span class="keywordtype">int</span>     param_count = 0;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         <span class="keywordflow">if</span> (attr != NULL) {
<a name="l00294"></a>00294                 sizes[param_count] = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structobdo.html">obdo</a>);
<a name="l00295"></a>00295                 param_count++;
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298         <span class="keywordflow">if</span> (hint != NULL &amp;&amp; hint-&gt;dah_parent != NULL) {
<a name="l00299"></a>00299                 sizes[param_count] = <span class="keyword">sizeof</span>(*fid);
<a name="l00300"></a>00300                 param_count++;
<a name="l00301"></a>00301         }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303         <span class="keywordflow">return</span> update_records_update_size(param_count, sizes);
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 EXPORT_SYMBOL(update_records_create_size);
<a name="l00306"></a>00306 
<a name="l00327"></a>00327 <span class="keywordtype">int</span> update_records_create_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00328"></a>00328                                <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00329"></a>00329                                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00330"></a>00330                                <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00331"></a>00331                                <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00332"></a>00332                                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00333"></a>00333                                <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00334"></a>00334                                <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00335"></a>00335                                <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l00336"></a>00336                                <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint,
<a name="l00337"></a>00337                                <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof)
<a name="l00338"></a>00338 {
<a name="l00339"></a>00339         <span class="keywordtype">size_t</span>                  sizes[2];
<a name="l00340"></a>00340         <span class="keyword">const</span> <span class="keywordtype">void</span>              *bufs[2];
<a name="l00341"></a>00341         <span class="keywordtype">int</span>                     buf_count = 0;
<a name="l00342"></a>00342         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>     *parent_fid = NULL;
<a name="l00343"></a>00343         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           tmp_fid;
<a name="l00344"></a>00344         <span class="keywordtype">int</span>                     rc;
<a name="l00345"></a>00345         <span class="keyword">struct </span><a class="code" href="structobdo.html">obdo</a>             *<a class="code" href="structobdo.html">obdo</a>;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         <span class="keywordflow">if</span> (attr != NULL) {
<a name="l00348"></a>00348                 obdo = &amp;update_env_info(env)-&gt;uti_obdo;
<a name="l00349"></a>00349                 obdo-&gt;o_valid = 0;
<a name="l00350"></a>00350                 obdo_from_la(obdo, attr, attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a>);
<a name="l00351"></a>00351                 lustre_set_wire_obdo(NULL, obdo, obdo);
<a name="l00352"></a>00352                 bufs[buf_count] = obdo;
<a name="l00353"></a>00353                 sizes[buf_count] = <span class="keyword">sizeof</span>(*obdo);
<a name="l00354"></a>00354                 buf_count++;
<a name="l00355"></a>00355         }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357         <span class="keywordflow">if</span> (hint != NULL &amp;&amp; hint-&gt;dah_parent != NULL) {
<a name="l00358"></a>00358                 parent_fid = lu_object_fid(&amp;hint-&gt;dah_parent-&gt;do_lu);
<a name="l00359"></a>00359                 fid_cpu_to_le(&amp;tmp_fid, parent_fid);
<a name="l00360"></a>00360                 bufs[buf_count] = &amp;tmp_fid;
<a name="l00361"></a>00361                 sizes[buf_count] = <span class="keyword">sizeof</span>(tmp_fid);
<a name="l00362"></a>00362                 buf_count++;
<a name="l00363"></a>00363         }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365         rc = update_records_update_pack(env, fid, OUT_CREATE, ops, op_count,
<a name="l00366"></a>00366                                         max_ops_size, params, param_count,
<a name="l00367"></a>00367                                         max_param_size, buf_count, bufs, sizes);
<a name="l00368"></a>00368         <span class="keywordflow">return</span> rc;
<a name="l00369"></a>00369 }
<a name="l00370"></a>00370 EXPORT_SYMBOL(update_records_create_pack);
<a name="l00371"></a>00371 
<a name="l00382"></a>00382 <span class="keywordtype">size_t</span> update_records_attr_set_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00383"></a>00383                                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00384"></a>00384                                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr)
<a name="l00385"></a>00385 {
<a name="l00386"></a>00386         <span class="keywordtype">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>obdo);
<a name="l00387"></a>00387 
<a name="l00388"></a>00388         <span class="keywordflow">return</span> update_records_update_size(1, &amp;size);
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 EXPORT_SYMBOL(update_records_attr_set_size);
<a name="l00391"></a>00391 
<a name="l00410"></a>00410 <span class="keywordtype">int</span> update_records_attr_set_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00411"></a>00411                                  <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00412"></a>00412                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00413"></a>00413                                  <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00414"></a>00414                                  <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00415"></a>00415                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00416"></a>00416                                  <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00417"></a>00417                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00418"></a>00418                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr)
<a name="l00419"></a>00419 {
<a name="l00420"></a>00420         <span class="keyword">struct </span>obdo *obdo = &amp;update_env_info(env)-&gt;uti_obdo;
<a name="l00421"></a>00421         <span class="keywordtype">size_t</span> size = <span class="keyword">sizeof</span>(*obdo);
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         obdo-&gt;o_valid = 0;
<a name="l00424"></a>00424         obdo_from_la(obdo, attr, attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a>);
<a name="l00425"></a>00425         lustre_set_wire_obdo(NULL, obdo, obdo);
<a name="l00426"></a>00426         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_ATTR_SET, ops, op_count,
<a name="l00427"></a>00427                                           max_ops_size, params, param_count,
<a name="l00428"></a>00428                                           max_param_size, 1,
<a name="l00429"></a>00429                                           (<span class="keyword">const</span> <span class="keywordtype">void</span> **)&amp;obdo, &amp;size);
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 EXPORT_SYMBOL(update_records_attr_set_pack);
<a name="l00432"></a>00432 
<a name="l00441"></a>00441 <span class="keywordtype">size_t</span> update_records_ref_add_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00442"></a>00442                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444         <span class="keywordflow">return</span> update_records_update_size(0, NULL);
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 EXPORT_SYMBOL(update_records_ref_add_size);
<a name="l00447"></a>00447 
<a name="l00465"></a>00465 <span class="keywordtype">int</span> update_records_ref_add_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00466"></a>00466                                 <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00467"></a>00467                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00468"></a>00468                                 <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00469"></a>00469                                 <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00470"></a>00470                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00471"></a>00471                                 <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00472"></a>00472                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00473"></a>00473 {
<a name="l00474"></a>00474         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_REF_ADD, ops, op_count,
<a name="l00475"></a>00475                                           max_ops_size, params, param_count,
<a name="l00476"></a>00476                                           max_param_size, 0, NULL, NULL);
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 EXPORT_SYMBOL(update_records_ref_add_pack);
<a name="l00479"></a>00479 
<a name="l00499"></a>00499 <span class="keywordtype">int</span> update_records_noop_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00500"></a>00500                              <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00501"></a>00501                              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00502"></a>00502                              <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00503"></a>00503                              <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00504"></a>00504                              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00505"></a>00505                              <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00506"></a>00506                              <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_NOOP, ops, op_count,
<a name="l00509"></a>00509                                           max_ops_size, params, param_count,
<a name="l00510"></a>00510                                           max_param_size, 0, NULL, NULL);
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 EXPORT_SYMBOL(update_records_noop_pack);
<a name="l00513"></a>00513 
<a name="l00522"></a>00522 <span class="keywordtype">size_t</span> update_records_ref_del_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00523"></a>00523                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00524"></a>00524 {
<a name="l00525"></a>00525         <span class="keywordflow">return</span> update_records_update_size(0, NULL);
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 EXPORT_SYMBOL(update_records_ref_del_size);
<a name="l00528"></a>00528 
<a name="l00546"></a>00546 <span class="keywordtype">int</span> update_records_ref_del_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00547"></a>00547                                 <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00548"></a>00548                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00549"></a>00549                                 <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00550"></a>00550                                 <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00551"></a>00551                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00552"></a>00552                                 <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00553"></a>00553                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00554"></a>00554 {
<a name="l00555"></a>00555         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_REF_DEL, ops, op_count,
<a name="l00556"></a>00556                                           max_ops_size, params, param_count,
<a name="l00557"></a>00557                                           max_param_size, 0, NULL, NULL);
<a name="l00558"></a>00558 }
<a name="l00559"></a>00559 EXPORT_SYMBOL(update_records_ref_del_pack);
<a name="l00560"></a>00560 
<a name="l00569"></a>00569 <span class="keywordtype">size_t</span> update_records_object_destroy_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00570"></a>00570                                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00571"></a>00571 {
<a name="l00572"></a>00572         <span class="keywordflow">return</span> update_records_update_size(0, NULL);
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 EXPORT_SYMBOL(update_records_object_destroy_size);
<a name="l00575"></a>00575 
<a name="l00593"></a>00593 <span class="keywordtype">int</span> update_records_object_destroy_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00594"></a>00594                                        <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00595"></a>00595                                        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00596"></a>00596                                        <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00597"></a>00597                                        <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00598"></a>00598                                        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00599"></a>00599                                        <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00600"></a>00600                                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00601"></a>00601 {
<a name="l00602"></a>00602         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_DESTROY, ops, op_count,
<a name="l00603"></a>00603                                           max_ops_size, params, param_count,
<a name="l00604"></a>00604                                           max_param_size, 0, NULL, NULL);
<a name="l00605"></a>00605 }
<a name="l00606"></a>00606 EXPORT_SYMBOL(update_records_object_destroy_pack);
<a name="l00607"></a>00607 
<a name="l00618"></a>00618 <span class="keywordtype">size_t</span> update_records_index_insert_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00619"></a>00619                                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00620"></a>00620                                         <span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *rec,
<a name="l00621"></a>00621                                         <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key)
<a name="l00622"></a>00622 {
<a name="l00623"></a>00623         <span class="keywordtype">size_t</span>                     sizes[3] = { strlen((<span class="keyword">const</span> <span class="keywordtype">char</span> *)key) + 1,
<a name="l00624"></a>00624                                                 <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>),
<a name="l00625"></a>00625                                                 sizeof(__u32) };
<a name="l00626"></a>00626         <span class="keywordflow">return</span> update_records_update_size(3, sizes);
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 EXPORT_SYMBOL(update_records_index_insert_size);
<a name="l00629"></a>00629 
<a name="l00649"></a>00649 <span class="keywordtype">int</span> update_records_index_insert_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00650"></a>00650                                      <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00651"></a>00651                                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00652"></a>00652                                      <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00653"></a>00653                                      <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00654"></a>00654                                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00655"></a>00655                                      <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00656"></a>00656                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00657"></a>00657                                      <span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *rec,
<a name="l00658"></a>00658                                      <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>       *rec1 = (<span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a> *)rec;
<a name="l00661"></a>00661         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>              rec_fid;
<a name="l00662"></a>00662         __u32                      type = cpu_to_le32(rec1-&gt;rec_type);
<a name="l00663"></a>00663         <span class="keywordtype">size_t</span>                     sizes[3] = { strlen((<span class="keyword">const</span> <span class="keywordtype">char</span> *)key) + 1,
<a name="l00664"></a>00664                                                 <span class="keyword">sizeof</span>(rec_fid),
<a name="l00665"></a>00665                                                 <span class="keyword">sizeof</span>(type) };
<a name="l00666"></a>00666         <span class="keyword">const</span> <span class="keywordtype">void</span>                 *bufs[3] = { key,
<a name="l00667"></a>00667                                                 &amp;rec_fid,
<a name="l00668"></a>00668                                                 &amp;type };
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         fid_cpu_to_le(&amp;rec_fid, rec1-&gt;rec_fid);
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_INDEX_INSERT, ops,
<a name="l00673"></a>00673                                           op_count, max_ops_size, params,
<a name="l00674"></a>00674                                           param_count, max_param_size,
<a name="l00675"></a>00675                                           3, bufs, sizes);
<a name="l00676"></a>00676 }
<a name="l00677"></a>00677 EXPORT_SYMBOL(update_records_index_insert_pack);
<a name="l00678"></a>00678 
<a name="l00688"></a>00688 <span class="keywordtype">size_t</span> update_records_index_delete_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00689"></a>00689                                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00690"></a>00690                                         <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key)
<a name="l00691"></a>00691 {
<a name="l00692"></a>00692         <span class="keywordtype">size_t</span> size = strlen((<span class="keyword">const</span> <span class="keywordtype">char</span> *)key) + 1;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694         <span class="keywordflow">return</span> update_records_update_size(1, &amp;size);
<a name="l00695"></a>00695 }
<a name="l00696"></a>00696 EXPORT_SYMBOL(update_records_index_delete_size);
<a name="l00697"></a>00697 
<a name="l00716"></a>00716 <span class="keywordtype">int</span> update_records_index_delete_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00717"></a>00717                                      <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00718"></a>00718                                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00719"></a>00719                                      <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00720"></a>00720                                      <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00721"></a>00721                                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00722"></a>00722                                      <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00723"></a>00723                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00724"></a>00724                                      <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key)
<a name="l00725"></a>00725 {
<a name="l00726"></a>00726         <span class="keywordtype">size_t</span> size = strlen((<span class="keyword">const</span> <span class="keywordtype">char</span> *)key) + 1;
<a name="l00727"></a>00727 
<a name="l00728"></a>00728         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_INDEX_DELETE, ops,
<a name="l00729"></a>00729                                           op_count, max_ops_size, params,
<a name="l00730"></a>00730                                           param_count, max_param_size,
<a name="l00731"></a>00731                                           1, (<span class="keyword">const</span> <span class="keywordtype">void</span> **)&amp;key, &amp;size);
<a name="l00732"></a>00732 }
<a name="l00733"></a>00733 EXPORT_SYMBOL(update_records_index_delete_pack);
<a name="l00734"></a>00734 
<a name="l00746"></a>00746 <span class="keywordtype">size_t</span> update_records_xattr_set_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00747"></a>00747                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00748"></a>00748                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l00749"></a>00749                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *name, __u32 flag)
<a name="l00750"></a>00750 {
<a name="l00751"></a>00751         <span class="keywordtype">size_t</span>  sizes[3] = {strlen(name) + 1, buf-&gt;lb_len, <span class="keyword">sizeof</span>(flag)};
<a name="l00752"></a>00752 
<a name="l00753"></a>00753         <span class="keywordflow">return</span> update_records_update_size(3, sizes);
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 EXPORT_SYMBOL(update_records_xattr_set_size);
<a name="l00756"></a>00756 
<a name="l00777"></a>00777 <span class="keywordtype">int</span> update_records_xattr_set_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00778"></a>00778                                   <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00779"></a>00779                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00780"></a>00780                                   <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00781"></a>00781                                   <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00782"></a>00782                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00783"></a>00783                                   <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00784"></a>00784                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00785"></a>00785                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00786"></a>00786                                   __u32 flag)
<a name="l00787"></a>00787 {
<a name="l00788"></a>00788         <span class="keywordtype">size_t</span>  sizes[3] = {strlen(name) + 1, buf-&gt;lb_len, <span class="keyword">sizeof</span>(flag)};
<a name="l00789"></a>00789         <span class="keyword">const</span> <span class="keywordtype">void</span> *bufs[3] = {name, buf-&gt;lb_buf, &amp;flag};
<a name="l00790"></a>00790 
<a name="l00791"></a>00791         flag = cpu_to_le32(flag);
<a name="l00792"></a>00792 
<a name="l00793"></a>00793         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_XATTR_SET, ops,
<a name="l00794"></a>00794                                           op_count, max_ops_size, params,
<a name="l00795"></a>00795                                           param_count, max_param_size,
<a name="l00796"></a>00796                                           3, bufs, sizes);
<a name="l00797"></a>00797 }
<a name="l00798"></a>00798 EXPORT_SYMBOL(update_records_xattr_set_pack);
<a name="l00799"></a>00799 
<a name="l00809"></a>00809 <span class="keywordtype">size_t</span> update_records_xattr_del_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00810"></a>00810                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00811"></a>00811                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l00812"></a>00812 {
<a name="l00813"></a>00813         <span class="keywordtype">size_t</span>  size = strlen(name) + 1;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815         <span class="keywordflow">return</span> update_records_update_size(1, &amp;size);
<a name="l00816"></a>00816 }
<a name="l00817"></a>00817 EXPORT_SYMBOL(update_records_xattr_del_size);
<a name="l00818"></a>00818 
<a name="l00837"></a>00837 <span class="keywordtype">int</span> update_records_xattr_del_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00838"></a>00838                                   <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00839"></a>00839                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00840"></a>00840                                   <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00841"></a>00841                                   <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00842"></a>00842                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00843"></a>00843                                   <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00844"></a>00844                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00845"></a>00845                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l00846"></a>00846 {
<a name="l00847"></a>00847         <span class="keywordtype">size_t</span>  size = strlen(name) + 1;
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_XATTR_DEL, ops,
<a name="l00850"></a>00850                                           op_count, max_ops_size, params,
<a name="l00851"></a>00851                                           param_count, max_param_size,
<a name="l00852"></a>00852                                           1, (<span class="keyword">const</span> <span class="keywordtype">void</span> **)&amp;name, &amp;size);
<a name="l00853"></a>00853 }
<a name="l00854"></a>00854 EXPORT_SYMBOL(update_records_xattr_del_pack);
<a name="l00855"></a>00855 
<a name="l00866"></a>00866 <span class="keywordtype">size_t</span> update_records_write_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00867"></a>00867                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00868"></a>00868                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l00869"></a>00869                                  __u64 pos)
<a name="l00870"></a>00870 {
<a name="l00871"></a>00871         <span class="keywordtype">size_t</span>  sizes[2] = {buf-&gt;lb_len, <span class="keyword">sizeof</span>(pos)};
<a name="l00872"></a>00872 
<a name="l00873"></a>00873         <span class="keywordflow">return</span> update_records_update_size(2, sizes);
<a name="l00874"></a>00874 }
<a name="l00875"></a>00875 EXPORT_SYMBOL(update_records_write_size);
<a name="l00876"></a>00876 
<a name="l00896"></a>00896 <span class="keywordtype">int</span> update_records_write_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00897"></a>00897                               <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00898"></a>00898                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00899"></a>00899                               <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00900"></a>00900                               <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00901"></a>00901                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00902"></a>00902                               <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00903"></a>00903                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00904"></a>00904                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l00905"></a>00905                               __u64 pos)
<a name="l00906"></a>00906 {
<a name="l00907"></a>00907         <span class="keywordtype">size_t</span>          sizes[2] = {buf-&gt;lb_len, <span class="keyword">sizeof</span>(pos)};
<a name="l00908"></a>00908         <span class="keyword">const</span> <span class="keywordtype">void</span>      *bufs[2] = {buf-&gt;lb_buf, &amp;pos};
<a name="l00909"></a>00909 
<a name="l00910"></a>00910         pos = cpu_to_le64(pos);
<a name="l00911"></a>00911 
<a name="l00912"></a>00912         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_WRITE, ops,
<a name="l00913"></a>00913                                           op_count, max_ops_size, params,
<a name="l00914"></a>00914                                           param_count, max_param_size,
<a name="l00915"></a>00915                                           2, bufs, sizes);
<a name="l00916"></a>00916 }
<a name="l00917"></a>00917 EXPORT_SYMBOL(update_records_write_pack);
<a name="l00918"></a>00918 
<a name="l00929"></a>00929 <span class="keywordtype">size_t</span> update_records_punch_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00930"></a>00930                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00931"></a>00931                                  __u64 start, __u64 end)
<a name="l00932"></a>00932 {
<a name="l00933"></a>00933         <span class="keywordtype">size_t</span>  sizes[2] = {<span class="keyword">sizeof</span>(start), <span class="keyword">sizeof</span>(end)};
<a name="l00934"></a>00934 
<a name="l00935"></a>00935         <span class="keywordflow">return</span> update_records_update_size(2, sizes);
<a name="l00936"></a>00936 }
<a name="l00937"></a>00937 EXPORT_SYMBOL(update_records_punch_size);
<a name="l00938"></a>00938 
<a name="l00958"></a>00958 <span class="keywordtype">int</span> update_records_punch_pack(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00959"></a>00959                               <span class="keyword">struct</span> <a class="code" href="structupdate__ops.html">update_ops</a> *ops,
<a name="l00960"></a>00960                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *op_count,
<a name="l00961"></a>00961                               <span class="keywordtype">size_t</span> *max_ops_size,
<a name="l00962"></a>00962                               <span class="keyword">struct</span> <a class="code" href="structupdate__params.html">update_params</a> *params,
<a name="l00963"></a>00963                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *param_count,
<a name="l00964"></a>00964                               <span class="keywordtype">size_t</span> *max_param_size,
<a name="l00965"></a>00965                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00966"></a>00966                               __u64 start, __u64 end)
<a name="l00967"></a>00967 {
<a name="l00968"></a>00968         <span class="keywordtype">size_t</span>          sizes[2] = {<span class="keyword">sizeof</span>(start), <span class="keyword">sizeof</span>(end)};
<a name="l00969"></a>00969         <span class="keyword">const</span> <span class="keywordtype">void</span>      *bufs[2] = {&amp;start, &amp;end};
<a name="l00970"></a>00970 
<a name="l00971"></a>00971         start = cpu_to_le64(start);
<a name="l00972"></a>00972         end = cpu_to_le64(end);
<a name="l00973"></a>00973 
<a name="l00974"></a>00974         <span class="keywordflow">return</span> update_records_update_pack(env, fid, OUT_PUNCH, ops, op_count,
<a name="l00975"></a>00975                                           max_ops_size, params, param_count,
<a name="l00976"></a>00976                                           max_param_size, 2, bufs, sizes);
<a name="l00977"></a>00977 }
<a name="l00978"></a>00978 EXPORT_SYMBOL(update_records_punch_pack);
<a name="l00979"></a>00979 
<a name="l00991"></a>00991 <span class="keyword">static</span> <span class="keywordtype">int</span> tur_update_records_create(<span class="keyword">struct</span> <a class="code" href="structthandle__update__records.html" title="Attached in the thandle to record the updates for distribute distribution.">thandle_update_records</a> *tur)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993         <span class="keywordflow">if</span> (tur-&gt;tur_update_records != NULL)
<a name="l00994"></a>00994                 <span class="keywordflow">return</span> 0;
<a name="l00995"></a>00995 
<a name="l00996"></a>00996         OBD_ALLOC_LARGE(tur-&gt;tur_update_records,
<a name="l00997"></a>00997                         UPDATE_RECORDS_BUFFER_SIZE);
<a name="l00998"></a>00998 
<a name="l00999"></a>00999         <span class="keywordflow">if</span> (tur-&gt;tur_update_records == NULL)
<a name="l01000"></a>01000                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01001"></a>01001 
<a name="l01002"></a>01002         tur-&gt;tur_update_records_buf_size = UPDATE_RECORDS_BUFFER_SIZE;
<a name="l01003"></a>01003 
<a name="l01004"></a>01004         <span class="keywordflow">return</span> 0;
<a name="l01005"></a>01005 }
<a name="l01006"></a>01006 
<a name="l01017"></a>01017 <span class="keywordtype">int</span> tur_update_records_extend(<span class="keyword">struct</span> <a class="code" href="structthandle__update__records.html" title="Attached in the thandle to record the updates for distribute distribution.">thandle_update_records</a> *tur,
<a name="l01018"></a>01018                               <span class="keywordtype">size_t</span> new_size)
<a name="l01019"></a>01019 {
<a name="l01020"></a>01020         <span class="keyword">struct </span><a class="code" href="structllog__update__record.html">llog_update_record</a>       *record;
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         OBD_ALLOC_LARGE(record, new_size);
<a name="l01023"></a>01023         <span class="keywordflow">if</span> (record == NULL)
<a name="l01024"></a>01024                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01025"></a>01025 
<a name="l01026"></a>01026         <span class="keywordflow">if</span> (tur-&gt;tur_update_records != NULL) {
<a name="l01027"></a>01027                 memcpy(record, tur-&gt;tur_update_records,
<a name="l01028"></a>01028                        tur-&gt;tur_update_records_buf_size);
<a name="l01029"></a>01029                 OBD_FREE_LARGE(tur-&gt;tur_update_records,
<a name="l01030"></a>01030                                tur-&gt;tur_update_records_buf_size);
<a name="l01031"></a>01031         }
<a name="l01032"></a>01032 
<a name="l01033"></a>01033         tur-&gt;tur_update_records = record;
<a name="l01034"></a>01034         tur-&gt;tur_update_records_buf_size = new_size;
<a name="l01035"></a>01035 
<a name="l01036"></a>01036         <span class="keywordflow">return</span> 0;
<a name="l01037"></a>01037 }
<a name="l01038"></a>01038 EXPORT_SYMBOL(tur_update_records_extend);
<a name="l01039"></a>01039 
<a name="l01054"></a>01054 <span class="keywordtype">int</span> tur_update_extend(<span class="keyword">struct</span> <a class="code" href="structthandle__update__records.html" title="Attached in the thandle to record the updates for distribute distribution.">thandle_update_records</a> *tur,
<a name="l01055"></a>01055                       <span class="keywordtype">size_t</span> new_op_size, <span class="keywordtype">size_t</span> new_param_size)
<a name="l01056"></a>01056 {
<a name="l01057"></a>01057         <span class="keywordtype">size_t</span> record_size;
<a name="l01058"></a>01058         <span class="keywordtype">size_t</span> params_size;
<a name="l01059"></a>01059         <span class="keywordtype">size_t</span> extend_size;
<a name="l01060"></a>01060         <span class="keywordtype">int</span> rc;
<a name="l01061"></a>01061         ENTRY;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063         record_size = llog_update_record_size(tur-&gt;tur_update_records);
<a name="l01064"></a>01064         <span class="comment">/* extend update records buffer */</span>
<a name="l01065"></a>01065         <span class="keywordflow">if</span> (new_op_size &gt;= (tur-&gt;tur_update_records_buf_size - record_size)) {
<a name="l01066"></a>01066                 extend_size = round_up(new_op_size, UPDATE_RECORDS_BUFFER_SIZE);
<a name="l01067"></a>01067                 rc = tur_update_records_extend(tur,
<a name="l01068"></a>01068                                 tur-&gt;tur_update_records_buf_size +
<a name="l01069"></a>01069                                 extend_size);
<a name="l01070"></a>01070                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01071"></a>01071                         RETURN(rc);
<a name="l01072"></a>01072         }
<a name="l01073"></a>01073 
<a name="l01074"></a>01074         <span class="comment">/* extend parameters buffer */</span>
<a name="l01075"></a>01075         params_size = update_params_size(tur-&gt;tur_update_params,
<a name="l01076"></a>01076                                          tur-&gt;tur_update_param_count);
<a name="l01077"></a>01077         <span class="keywordflow">if</span> (new_param_size &gt;= (tur-&gt;tur_update_params_buf_size -
<a name="l01078"></a>01078                               params_size)) {
<a name="l01079"></a>01079                 extend_size = round_up(new_param_size,
<a name="l01080"></a>01080                                        UPDATE_PARAMS_BUFFER_SIZE);
<a name="l01081"></a>01081                 rc = tur_update_params_extend(tur,
<a name="l01082"></a>01082                                 tur-&gt;tur_update_params_buf_size +
<a name="l01083"></a>01083                                 extend_size);
<a name="l01084"></a>01084                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01085"></a>01085                         RETURN(rc);
<a name="l01086"></a>01086         }
<a name="l01087"></a>01087 
<a name="l01088"></a>01088         RETURN(0);
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 EXPORT_SYMBOL(tur_update_extend);
<a name="l01091"></a>01091 
<a name="l01103"></a>01103 <span class="keyword">static</span> <span class="keywordtype">int</span> tur_update_params_create(<span class="keyword">struct</span> <a class="code" href="structthandle__update__records.html" title="Attached in the thandle to record the updates for distribute distribution.">thandle_update_records</a> *tur)
<a name="l01104"></a>01104 {
<a name="l01105"></a>01105         <span class="keywordflow">if</span> (tur-&gt;tur_update_params != NULL)
<a name="l01106"></a>01106                 <span class="keywordflow">return</span> 0;
<a name="l01107"></a>01107 
<a name="l01108"></a>01108         OBD_ALLOC_LARGE(tur-&gt;tur_update_params, UPDATE_PARAMS_BUFFER_SIZE);
<a name="l01109"></a>01109         <span class="keywordflow">if</span> (tur-&gt;tur_update_params == NULL)
<a name="l01110"></a>01110                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01111"></a>01111 
<a name="l01112"></a>01112         tur-&gt;tur_update_params_buf_size = UPDATE_PARAMS_BUFFER_SIZE;
<a name="l01113"></a>01113         <span class="keywordflow">return</span> 0;
<a name="l01114"></a>01114 }
<a name="l01115"></a>01115 
<a name="l01126"></a>01126 <span class="keywordtype">int</span> tur_update_params_extend(<span class="keyword">struct</span> <a class="code" href="structthandle__update__records.html" title="Attached in the thandle to record the updates for distribute distribution.">thandle_update_records</a> *tur,
<a name="l01127"></a>01127                              <span class="keywordtype">size_t</span> new_size)
<a name="l01128"></a>01128 {
<a name="l01129"></a>01129         <span class="keyword">struct </span><a class="code" href="structupdate__params.html">update_params</a>    *params;
<a name="l01130"></a>01130 
<a name="l01131"></a>01131         OBD_ALLOC_LARGE(params, new_size);
<a name="l01132"></a>01132         <span class="keywordflow">if</span> (params == NULL)
<a name="l01133"></a>01133                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01134"></a>01134 
<a name="l01135"></a>01135         <span class="keywordflow">if</span> (tur-&gt;tur_update_params != NULL) {
<a name="l01136"></a>01136                 memcpy(params, tur-&gt;tur_update_params,
<a name="l01137"></a>01137                        tur-&gt;tur_update_params_buf_size);
<a name="l01138"></a>01138                 OBD_FREE_LARGE(tur-&gt;tur_update_params,
<a name="l01139"></a>01139                                tur-&gt;tur_update_params_buf_size);
<a name="l01140"></a>01140         }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142         tur-&gt;tur_update_params = params;
<a name="l01143"></a>01143         tur-&gt;tur_update_params_buf_size = new_size;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145         <span class="keywordflow">return</span> 0;
<a name="l01146"></a>01146 }
<a name="l01147"></a>01147 EXPORT_SYMBOL(tur_update_params_extend);
<a name="l01148"></a>01148 
<a name="l01161"></a>01161 <span class="keywordtype">int</span> check_and_prepare_update_record(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01162"></a>01162                                     <span class="keyword">struct</span> <a class="code" href="structthandle__update__records.html" title="Attached in the thandle to record the updates for distribute distribution.">thandle_update_records</a> *tur)
<a name="l01163"></a>01163 {
<a name="l01164"></a>01164         <span class="keyword">struct </span><a class="code" href="structllog__update__record.html">llog_update_record</a>       *lur;
<a name="l01165"></a>01165         <span class="keywordtype">int</span> rc;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167         <span class="keywordflow">if</span> (tur-&gt;tur_update_records == NULL) {
<a name="l01168"></a>01168                 rc = tur_update_records_create(tur);
<a name="l01169"></a>01169                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01170"></a>01170                         RETURN(rc);
<a name="l01171"></a>01171         }
<a name="l01172"></a>01172 
<a name="l01173"></a>01173         <span class="keywordflow">if</span> (tur-&gt;tur_update_params == NULL) {
<a name="l01174"></a>01174                 rc = tur_update_params_create(tur);
<a name="l01175"></a>01175                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01176"></a>01176                         RETURN(rc);
<a name="l01177"></a>01177         }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179         lur = tur-&gt;tur_update_records;
<a name="l01180"></a>01180         lur-&gt;lur_update_rec.ur_update_count = 0;
<a name="l01181"></a>01181         lur-&gt;lur_update_rec.ur_param_count = 0;
<a name="l01182"></a>01182         lur-&gt;lur_update_rec.ur_master_transno = 0;
<a name="l01183"></a>01183         lur-&gt;lur_update_rec.ur_batchid = 0;
<a name="l01184"></a>01184         lur-&gt;lur_update_rec.ur_flags = 0;
<a name="l01185"></a>01185         lur-&gt;lur_hdr.lrh_len = LLOG_MIN_CHUNK_SIZE;
<a name="l01186"></a>01186 
<a name="l01187"></a>01187         tur-&gt;tur_update_param_count = 0;
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         RETURN(0);
<a name="l01190"></a>01190 }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192 <span class="keyword">static</span> <span class="keywordtype">void</span> update_key_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx,
<a name="l01193"></a>01193                             <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key, <span class="keywordtype">void</span> *data)
<a name="l01194"></a>01194 {
<a name="l01195"></a>01195         <span class="keyword">struct </span><a class="code" href="structupdate__thread__info.html">update_thread_info</a> *info = data;
<a name="l01196"></a>01196         <span class="keyword">struct </span><a class="code" href="structthandle__exec__args.html">thandle_exec_args</a>  *args = &amp;info-&gt;uti_tea;
<a name="l01197"></a>01197         <span class="keywordtype">int</span>                       i;
<a name="l01198"></a>01198 
<a name="l01199"></a>01199         <span class="keywordflow">for</span> (i = 0; i &lt; args-&gt;ta_alloc_args; i++) {
<a name="l01200"></a>01200                 <span class="keywordflow">if</span> (args-&gt;ta_args[i] != NULL)
<a name="l01201"></a>01201                         OBD_FREE_PTR(args-&gt;ta_args[i]);
<a name="l01202"></a>01202         }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204         <span class="keywordflow">if</span> (args-&gt;ta_args != NULL)
<a name="l01205"></a>01205                 OBD_FREE(args-&gt;ta_args, <span class="keyword">sizeof</span>(args-&gt;ta_args[0]) *
<a name="l01206"></a>01206                          args-&gt;ta_alloc_args);
<a name="l01207"></a>01207 
<a name="l01208"></a>01208         <span class="keywordflow">if</span> (info-&gt;uti_tur.tur_update_records != NULL)
<a name="l01209"></a>01209                 OBD_FREE_LARGE(info-&gt;uti_tur.tur_update_records,
<a name="l01210"></a>01210                                info-&gt;uti_tur.tur_update_records_buf_size);
<a name="l01211"></a>01211         <span class="keywordflow">if</span> (info-&gt;uti_tur.tur_update_params != NULL)
<a name="l01212"></a>01212                 OBD_FREE_LARGE(info-&gt;uti_tur.tur_update_params,
<a name="l01213"></a>01213                                info-&gt;uti_tur.tur_update_params_buf_size);
<a name="l01214"></a>01214 
<a name="l01215"></a>01215         OBD_FREE_PTR(info);
<a name="l01216"></a>01216 }
<a name="l01217"></a>01217 
<a name="l01218"></a>01218 <span class="comment">/* context key constructor/destructor: update_key_init, update_key_fini */</span>
<a name="l01219"></a>01219 LU_KEY_INIT(update, <span class="keyword">struct</span> <a class="code" href="structupdate__thread__info.html">update_thread_info</a>);
<a name="l01220"></a>01220 <span class="comment">/* context key: update_thread_key */</span>
<a name="l01221"></a>01221 LU_CONTEXT_KEY_DEFINE(update, <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa51f264f8e3ea36a381cf8aaaa9672752" title="Thread on md server.">LCT_MD_THREAD</a> | <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa582fa482375137187e808b1f5f8662d1" title="MGS device thread.">LCT_MG_THREAD</a> |
<a name="l01222"></a>01222                               <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f" title="Thread on dt server.">LCT_DT_THREAD</a> | <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aae4ff6019628711d8f1dbefee9e3edfee" title="Context for transaction handle.">LCT_TX_HANDLE</a> | <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa87bf2c0c71c5af685cf15e809a7ed551" title="Context for local operations.">LCT_LOCAL</a>);
<a name="l01223"></a>01223 EXPORT_SYMBOL(update_thread_key);
<a name="l01224"></a>01224 LU_KEY_INIT_GENERIC(update);
<a name="l01225"></a>01225 
<a name="l01226"></a>01226 <span class="keywordtype">void</span> update_info_init(<span class="keywordtype">void</span>)
<a name="l01227"></a>01227 {
<a name="l01228"></a>01228         update_key_init_generic(&amp;update_thread_key, NULL);
<a name="l01229"></a>01229         <a class="code" href="group__lu.html#ga1eef6b147da5ae4489576e136772d404" title="Register new key.">lu_context_key_register</a>(&amp;update_thread_key);
<a name="l01230"></a>01230 }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232 <span class="keywordtype">void</span> update_info_fini(<span class="keywordtype">void</span>)
<a name="l01233"></a>01233 {
<a name="l01234"></a>01234         <a class="code" href="group__lu.html#ga6e069db37ac446fe47b8b211c3d721c5" title="Deregister key.">lu_context_key_degister</a>(&amp;update_thread_key);
<a name="l01235"></a>01235 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:35 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
