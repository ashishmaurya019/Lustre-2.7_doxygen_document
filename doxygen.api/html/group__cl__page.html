<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: cl_page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cl_page<br/>
<small>
[<a class="el" href="group__clio.html">clio</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for cl_page:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__cl__page.png" border="0" alt="" usemap="#group____cl____page_map"/>
<map name="group____cl____page_map" id="group____cl____page">
<area shape="rect" id="node1" href="group__clio.html" title="Client objects implement io operations and cache pages." alt="" coords="7,5,49,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page.html">cl_page</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fields are protected by the lock on struct page, except for atomics and immutables.  <a href="structcl__page.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__slice.html">cl_page_slice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-layer part of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>.  <a href="structcl__page__slice.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html">cl_page_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-layer page operations.  <a href="structcl__page__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__client__cache.html">cl_client_cache</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data structure managing a client's cached pages.  <a href="structcl__client__cache.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga912e7c9c7d73f184c724593eb42f857a">CL_PAGE_DEBUG</a>(mask, env, page, format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper macro, dumping detailed information about <em>page</em> into a log.  <a href="#ga912e7c9c7d73f184c724593eb42f857a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4">CL_PAGE_HEADER</a>(mask, env, page, format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper macro, dumping shorter information about <em>page</em> into a log.  <a href="#gaeeca225390e016ad5bb7ab7ab31e3ab4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f36ee0c41000fd2b189406ddfc160f1"></a><!-- doxytag: member="cl_page::cl_page_in_use" ref="ga3f36ee0c41000fd2b189406ddfc160f1" args="(pg)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga3f36ee0c41000fd2b189406ddfc160f1">cl_page_in_use</a>(pg)&nbsp;&nbsp;&nbsp;__page_in_use(pg, 1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Caller itself holds a refcount of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3d3c2d56b9ba8a228c82c097258b596"></a><!-- doxytag: member="cl_page::cl_page_in_use_noref" ref="gad3d3c2d56b9ba8a228c82c097258b596" args="(pg)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gad3d3c2d56b9ba8a228c82c097258b596">cl_page_in_use_noref</a>(pg)&nbsp;&nbsp;&nbsp;__page_in_use(pg, 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Caller doesn't hold a refcount. <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">cl_page_state</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba">CPS_CACHED</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9">CPS_OWNED</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4">CPS_PAGEOUT</a>, 
<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998">CPS_PAGEIN</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8">CPS_FREEING</a>, 
<b>CPS_NR</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>States of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
 <a href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> { <a class="el" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936">CPT_CACHEABLE</a> =  1, 
<a class="el" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d">CPT_TRANSIENT</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> { <b>CRT_READ</b>, 
<b>CRT_WRITE</b>, 
<b>CRT_NR</b>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Requested transfer type. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>CLP_GANG_OKAY</b> =  0, 
<b>CLP_GANG_RESCHED</b>, 
<b>CLP_GANG_AGAIN</b>, 
<b>CLP_GANG_ABORT</b>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga448fbdaea940886c756e4a2d659982ba">cl_page_find</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, pgoff_t idx, struct page *vmpage, enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> with index <em>idx</em> at the object <em>o</em>, and associated with the VM page <em>vmpage</em>.  <a href="#ga448fbdaea940886c756e4a2d659982ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga630af4228e1e42063ce55e844dfc8c30"></a><!-- doxytag: member="cl_page::cl_page_alloc" ref="ga630af4228e1e42063ce55e844dfc8c30" args="(const struct lu_env *env, struct cl_object *o, pgoff_t ind, struct page *vmpage, enum cl_page_type type)" -->
struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_page_alloc</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *o, pgoff_t ind, struct page *vmpage, enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gafc2fc785c3daf1db46bb250244dfde13">cl_page_get</a> (struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquires an additional reference to a page.  <a href="#gafc2fc785c3daf1db46bb250244dfde13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1">cl_page_put</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases a reference to a page.  <a href="#ga1dc4205fd892e559c96ce97aad4eebf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c8a48c83e51dbc9dd7a79933c1133d2"></a><!-- doxytag: member="cl_page::cl_page_print" ref="ga8c8a48c83e51dbc9dd7a79933c1133d2" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct cl_page *pg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga8c8a48c83e51dbc9dd7a79933c1133d2">cl_page_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>pg</em> to the <em>f</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga410da950184d24fa1232acf2470c9bab"></a><!-- doxytag: member="cl_page::cl_page_header_print" ref="ga410da950184d24fa1232acf2470c9bab" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct cl_page *pg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga410da950184d24fa1232acf2470c9bab">cl_page_header_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>pg</em> to the <em>f</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac3255abeeef8f9d9f3a4c80f553a75ed"></a><!-- doxytag: member="cl_page::cl_vmpage_page" ref="gac3255abeeef8f9d9f3a4c80f553a75ed" args="(struct page *vmpage, struct cl_object *obj)" -->
struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gac3255abeeef8f9d9f3a4c80f553a75ed">cl_vmpage_page</a> (struct page *vmpage, struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> associated with a VM page, and given <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5751d9274f61529ae1ec5a2b03b20db2"></a><!-- doxytag: member="cl_page::cl_page_top" ref="ga5751d9274f61529ae1ec5a2b03b20db2" args="(struct cl_page *page)" -->
struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_page_top</b> (struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab700fa091971e5f4dd53b2e7ec47334d"></a><!-- doxytag: member="cl_page::cl_page_at" ref="gab700fa091971e5f4dd53b2e7ec47334d" args="(const struct cl_page *page, const struct lu_device_type *dtype)" -->
struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_page_at</b> (const struct <a class="el" href="structcl__page.html">cl_page</a> *page, const struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *dtype)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa9cb2d06a33d48e9c15d7e311fb3c2be"></a><!-- doxytag: member="cl_page::cl_cache_init" ref="gaa9cb2d06a33d48e9c15d7e311fb3c2be" args="(unsigned long lru_page_max)" -->
struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaa9cb2d06a33d48e9c15d7e311fb3c2be">cl_cache_init</a> (unsigned long lru_page_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cl_cache functions <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81d50c8e80031f53132c1e66c54ee2c6"></a><!-- doxytag: member="cl_page::cl_cache_incref" ref="ga81d50c8e80031f53132c1e66c54ee2c6" args="(struct cl_client_cache *cache)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga81d50c8e80031f53132c1e66c54ee2c6">cl_cache_incref</a> (struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *cache)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase cl_cache refcount. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaaabf78f7ae327b269ded9a824d9ccebf">cl_cache_decref</a> (struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *cache)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease cl_cache refcount and free the cache if refcount=0.  <a href="#gaaabf78f7ae327b269ded9a824d9ccebf"></a><br/></td></tr>
<tr><td colspan="2"><h2>ownership</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpb46b517b77d347176f23adef739a8f39"></a>Functions dealing with the ownership of page by io. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a">cl_page_own</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Own a page, might be blocked.  <a href="#ga2f91322039a4254d13f6e0a668e5746a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga105c7ed0e326d75ffc75980986186bb7">cl_page_own_try</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nonblock version of <a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own()</a>.  <a href="#ga105c7ed0e326d75ffc75980986186bb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga77a2e8592e58cc9c514cb4ac38a9d2f4">cl_page_assume</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assume page ownership.  <a href="#ga77a2e8592e58cc9c514cb4ac38a9d2f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga4e7db1845b76bea8277b4e3d2a482f61">cl_page_unassume</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases page ownership without unlocking the page.  <a href="#ga4e7db1845b76bea8277b4e3d2a482f61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gae41a4c98faae723b2566a721b6e4b7fb">cl_page_disown</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases page ownership.  <a href="#gae41a4c98faae723b2566a721b6e4b7fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf5979233c47e0913f8d438d01051ebf"></a><!-- doxytag: member="cl_page::cl_page_is_owned" ref="gabf5979233c47e0913f8d438d01051ebf" args="(const struct cl_page *pg, const struct cl_io *io)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf">cl_page_is_owned</a> (const struct <a class="el" href="structcl__page.html">cl_page</a> *pg, const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true, iff page is owned by the given io. <br/></td></tr>
<tr><td colspan="2"><h2>transfer</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp84a0f3455dcca894ace136be62efa292"></a>Functions dealing with the preparation of a page for a transfer, and tracking transfer state. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga8216a843e48aa6d45d049b6aacb13744">cl_page_prep</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares page for immediate transfer.  <a href="#ga8216a843e48aa6d45d049b6aacb13744"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga778ad6a1a849ef9701db714913c879ec">cl_page_completion</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt, int ioret)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify layers about transfer completion.  <a href="#ga778ad6a1a849ef9701db714913c879ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga864bcec4bff9dd1f988f928348c08796">cl_page_make_ready</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify layers that transfer formation engine decided to yank this page from the cache and to make it a part of a transfer.  <a href="#ga864bcec4bff9dd1f988f928348c08796"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9022b1fa30e82cf1e69bd534022ffb8f"></a><!-- doxytag: member="cl_page::cl_page_cache_add" ref="ga9022b1fa30e82cf1e69bd534022ffb8f" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg, enum cl_req_type crt)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_page_cache_add</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga2218cff8efc343a14d1c312f64e15e1f">cl_page_clip</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, int from, int to)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells transfer engine that only part of a page is to be transmitted.  <a href="#ga2218cff8efc343a14d1c312f64e15e1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2b98b954f28349bd90316fec9ebaec83"></a><!-- doxytag: member="cl_page::cl_page_cancel" ref="ga2b98b954f28349bd90316fec9ebaec83" args="(const struct lu_env *env, struct cl_page *page)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga2b98b954f28349bd90316fec9ebaec83">cl_page_cancel</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *page)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel a page which is still in a transfer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga0616bcd8605ed9a75e799f64bcdd5a2d">cl_page_flush</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called if a pge is being written back by kernel's intention.  <a href="#ga0616bcd8605ed9a75e799f64bcdd5a2d"></a><br/></td></tr>
<tr><td colspan="2"><h2>helper routines</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbc5b051d66841a94152b2b685d83a4c9"></a>Functions to discard, delete and export a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga775efaa18bd22d404f7588fd35f6cd03">cl_page_discard</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when page is to be removed from the object, e.g., as a result of truncate.  <a href="#ga775efaa18bd22d404f7588fd35f6cd03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#ga55a51f6efaa6effc3b5b3d045d4ee432">cl_page_delete</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a decision is made to throw page out of memory.  <a href="#ga55a51f6efaa6effc3b5b3d045d4ee432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaff21e5139bb0af2f15e2cfb9cfb587f3"></a><!-- doxytag: member="cl_page::cl_page_is_vmlocked" ref="gaff21e5139bb0af2f15e2cfb9cfb587f3" args="(const struct lu_env *env, const struct cl_page *pg)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaff21e5139bb0af2f15e2cfb9cfb587f3">cl_page_is_vmlocked</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page.html">cl_page</a> *pg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true, iff <em>pg</em> is VM locked in a suitable sense by the calling thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gafacf1187afd6e200c6f8d59539baf50c">cl_page_export</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page.html">cl_page</a> *pg, int uptodate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks page up-to-date.  <a href="#gafacf1187afd6e200c6f8d59539baf50c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace31c47f7197adaedc4124bcddbca515"></a><!-- doxytag: member="cl_page::cl_offset" ref="gace31c47f7197adaedc4124bcddbca515" args="(const struct cl_object *obj, pgoff_t idx)" -->
loff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gace31c47f7197adaedc4124bcddbca515">cl_offset</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj, pgoff_t idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a byte offset within object <em>obj</em> into a page index. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa04da32f8652bb1f20f7017d8ed387e4"></a><!-- doxytag: member="cl_page::cl_index" ref="gaa04da32f8652bb1f20f7017d8ed387e4" args="(const struct cl_object *obj, loff_t offset)" -->
pgoff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4">cl_index</a> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj, loff_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a page index into a byte offset within object <em>obj</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43006a6bc8ca6f3de9ce4af48d944cc7"></a><!-- doxytag: member="cl_page::cl_page_size" ref="ga43006a6bc8ca6f3de9ce4af48d944cc7" args="(const struct cl_object *obj)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_page_size</b> (const struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae62cdffcc2ad419c1efe15d3f7e2b7be"></a><!-- doxytag: member="cl_page::cl_lock_print" ref="gae62cdffcc2ad419c1efe15d3f7e2b7be" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct cl_lock *lock)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gae62cdffcc2ad419c1efe15d3f7e2b7be">cl_lock_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of <em>lock</em> to the <em>f</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad2a636ba7685701e15adf1818874fd50"></a><!-- doxytag: member="cl_page::cl_lock_descr_print" ref="gad2a636ba7685701e15adf1818874fd50" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct cl_lock_descr *descr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__page.html#gad2a636ba7685701e15adf1818874fd50">cl_lock_descr_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structcl__lock__descr.html">cl_lock_descr</a> *descr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints human readable representation of a lock description. <br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga912e7c9c7d73f184c724593eb42f857a"></a><!-- doxytag: member="cl_object.h::CL_PAGE_DEBUG" ref="ga912e7c9c7d73f184c724593eb42f857a" args="(mask, env, page, format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CL_PAGE_DEBUG</td>
          <td>(</td>
          <td class="paramtype">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">env, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">page, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                    \
        <span class="keywordflow">if</span> (cfs_cdebug_show(mask, DEBUG_SUBSYSTEM)) {                   \
                LIBCFS_DEBUG_MSG_DATA_DECL(msgdata, mask, NULL);        \
                <a class="code" href="group__cl__page.html#ga8c8a48c83e51dbc9dd7a79933c1133d2" title="Prints human readable representation of pg to the f.">cl_page_print</a>(env, &amp;msgdata, <a class="code" href="group__lu.html#gaea04856d0829f02ff6e8b5b957cd8a52" title="Printer function emitting messages through libcfs_debug_msg().">lu_cdebug_printer</a>, page);  \
                CDEBUG(mask, format , ## __VA_ARGS__);                  \
        }                                                               \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Helper macro, dumping detailed information about <em>page</em> into a log. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01005">1005</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeeca225390e016ad5bb7ab7ab31e3ab4"></a><!-- doxytag: member="cl_object.h::CL_PAGE_HEADER" ref="gaeeca225390e016ad5bb7ab7ab31e3ab4" args="(mask, env, page, format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CL_PAGE_HEADER</td>
          <td>(</td>
          <td class="paramtype">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">env, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">page, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                          \
        <span class="keywordflow">if</span> (cfs_cdebug_show(mask, DEBUG_SUBSYSTEM)) {                         \
                LIBCFS_DEBUG_MSG_DATA_DECL(msgdata, mask, NULL);              \
                <a class="code" href="group__cl__page.html#ga410da950184d24fa1232acf2470c9bab" title="Prints human readable representation of pg to the f.">cl_page_header_print</a>(env, &amp;msgdata, <a class="code" href="group__lu.html#gaea04856d0829f02ff6e8b5b957cd8a52" title="Printer function emitting messages through libcfs_debug_msg().">lu_cdebug_printer</a>, page); \
                CDEBUG(mask, format , ## __VA_ARGS__);                        \
        }                                                                     \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Helper macro, dumping shorter information about <em>page</em> into a log. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01017">1017</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00995">cl_page_clip()</a>, <a class="el" href="cl__page_8c_source.html#l00909">cl_page_completion()</a>, <a class="el" href="cl__page_8c_source.html#l00973">cl_page_flush()</a>, <a class="el" href="cl__page_8c_source.html#l00943">cl_page_make_ready()</a>, <a class="el" href="cl__page_8c_source.html#l00866">cl_page_prep()</a>, and <a class="el" href="cl__page_8c_source.html#l00372">cl_page_put()</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga762f808d1d3ac30a12a132d0344f1f39"></a><!-- doxytag: member="cl_object.h::cl_page_state" ref="ga762f808d1d3ac30a12a132d0344f1f39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__page.html#ga762f808d1d3ac30a12a132d0344f1f39">cl_page_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>States of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
<p><a class="el" href="cl__page_8c_source.html">cl_page.c</a> assumes particular order here.</p>
<p>The page state machine is rather crude, as it doesn't recognize finer page states like "dirty" or "up to date". This is because such states are not always well defined for the whole stack (see, for example, the implementation of the read-ahead, that hides page up-to-dateness to track cache hits accurately). Such sub-states are maintained by the layers that are interested in them. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba"></a><!-- doxytag: member="CPS_CACHED" ref="gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" args="" -->CPS_CACHED</em>&nbsp;</td><td>
<p>Page is in the cache, un-owned. </p>
<p>Page leaves cached state in the following cases:</p>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">cl_page_state::CPS_OWNED</a>] io comes across the page and owns it;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a>] page is dirty, the req-formation engine decides that it wants to include this page into an RPC being constructed, and yanks it from the cache;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a>] VM callback is executed to evict the page form the memory;</li>
</ul>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd><a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> == NULL &amp;&amp; cl_page::cp_req == NULL </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9"></a><!-- doxytag: member="CPS_OWNED" ref="gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" args="" -->CPS_OWNED</em>&nbsp;</td><td>
<p>Page is exclusively owned by some <a class="el" href="structcl__io.html" title="State for io.">cl_io</a>. </p>
<p>Page may end up in this state as a result of</p>
<ul>
<li>io creating new page and immediately owning it;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a>] io finding existing cached page and owning it;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">cl_page_state::CPS_OWNED</a>] io finding existing owned page and waiting for owner to release the page;</li>
</ul>
<p>Page leaves owned state in the following cases:</p>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a>] io decides to leave the page in the cache, doing nothing;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998" title="Page is being read in, as a part of a transfer.">cl_page_state::CPS_PAGEIN</a>] io starts read transfer for this page;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a>] io starts immediate write transfer for this page;</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a>] io decides to destroy this page (e.g., as part of truncate or extent lock cancellation).</li>
</ul>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd><a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> != NULL &amp;&amp; cl_page::cp_req == NULL </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4"></a><!-- doxytag: member="CPS_PAGEOUT" ref="gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" args="" -->CPS_PAGEOUT</em>&nbsp;</td><td>
<p>Page is being written out, as a part of a transfer. </p>
<p>This state is entered when req-formation logic decided that it wants this page to be sent through the wire _now_. Specifically, it means that once this state is achieved, transfer completion handler (with either success or failure indication) is guaranteed to be executed against this page independently of any locks and any scheduling decisions made by the hosting environment (that effectively means that the page is never put into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a> state "in
 advance". This property is mentioned, because it is important when reasoning about possible dead-locks in the system). The page can enter this state as a result of</p>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">cl_page_state::CPS_OWNED</a>] an io requesting an immediate write-out of this page, or</li>
</ul>
<ul>
<li>[<a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a>] req-forming engine deciding that it has enough dirty pages cached to issue a "good" transfer.</li>
</ul>
<p>The page leaves <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a> state when the transfer is completed---it is moved into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a> state.</p>
<p>Underlying VM page is locked for the duration of transfer.</p>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>: <a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> == NULL &amp;&amp; cl_page::cp_req != NULL </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998"></a><!-- doxytag: member="CPS_PAGEIN" ref="gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998" args="" -->CPS_PAGEIN</em>&nbsp;</td><td>
<p>Page is being read in, as a part of a transfer. </p>
<p>This is quite similar to the <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">cl_page_state::CPS_PAGEOUT</a> state, except that read-in is always "immediate"---there is no such thing a sudden construction of read request from cached, presumably not up to date, pages.</p>
<p>Underlying VM page is locked for the duration of transfer.</p>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>: <a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> == NULL &amp;&amp; cl_page::cp_req != NULL </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8"></a><!-- doxytag: member="CPS_FREEING" ref="gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" args="" -->CPS_FREEING</em>&nbsp;</td><td>
<p>Page is being destroyed. </p>
<p>This state is entered when client decides that page has to be deleted from its host object, as, e.g., a part of truncate.</p>
<p>Once this state is reached, there is no way to escape it.</p>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>: <a class="el" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cl_page::cp_owner</a> == NULL &amp;&amp; cl_page::cp_req == NULL </dd></dl>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00594">594</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00594"></a>00594                    {
<a name="l00611"></a>00611         <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">CPS_CACHED</a>,
<a name="l00640"></a>00640         <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">CPS_OWNED</a>,
<a name="l00668"></a>00668         <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a5508b13b7d061f6806482dbb1c20d9e4" title="Page is being written out, as a part of a transfer.">CPS_PAGEOUT</a>,
<a name="l00680"></a>00680         <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a23d1b66d4877127e29434eb39ee1b998" title="Page is being read in, as a part of a transfer.">CPS_PAGEIN</a>,
<a name="l00690"></a>00690         <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">CPS_FREEING</a>,
<a name="l00691"></a>00691         CPS_NR
<a name="l00692"></a>00692 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga04ed60b0572c2fcfa6c2590aac97f92d"></a><!-- doxytag: member="cl_object.h::cl_page_type" ref="ga04ed60b0572c2fcfa6c2590aac97f92d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936"></a><!-- doxytag: member="CPT_CACHEABLE" ref="gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936" args="" -->CPT_CACHEABLE</em>&nbsp;</td><td>
<p>Host page, the page is from the host inode which the <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> belongs to. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d"></a><!-- doxytag: member="CPT_TRANSIENT" ref="gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d" args="" -->CPT_TRANSIENT</em>&nbsp;</td><td>
<p>Transient page, the transient <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is used to bind a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> to vmpage which is not belonging to the same object of <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>. </p>
<p>it is used in DirectIO, lockless IO and liblustre. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00694">694</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00694"></a>00694                   {
<a name="l00697"></a>00697         <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936" title="Host page, the page is from the host inode which the cl_page belongs to.">CPT_CACHEABLE</a> = 1,
<a name="l00698"></a>00698 
<a name="l00702"></a>00702         <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d" title="Transient page, the transient cl_page is used to bind a cl_page to vmpage which is...">CPT_TRANSIENT</a>,
<a name="l00703"></a>00703 };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaaabf78f7ae327b269ded9a824d9ccebf"></a><!-- doxytag: member="cl_object.h::cl_cache_decref" ref="gaaabf78f7ae327b269ded9a824d9ccebf" args="(struct cl_client_cache *cache)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_cache_decref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcl__client__cache.html">cl_client_cache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrease cl_cache refcount and free the cache if refcount=0. </p>
<p>Since llite, lov and osc all hold cl_cache refcount, the free will not cause race. (LU-6173) </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l01136">1136</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l02183">cl_client_cache::ccc_users</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01137"></a>01137 {
<a name="l01138"></a>01138         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;cache-&gt;<a class="code" href="structcl__client__cache.html#a57c96eb85dc16678ffc511f4d8ace7f2" title="# of client cache refcount # of users (OSCs) + 2 (held by llite and lov)">ccc_users</a>))
<a name="l01139"></a>01139                 OBD_FREE(cache, <span class="keyword">sizeof</span>(*cache));
<a name="l01140"></a>01140 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga77a2e8592e58cc9c514cb4ac38a9d2f4"></a><!-- doxytag: member="cl_object.h::cl_page_assume" ref="ga77a2e8592e58cc9c514cb4ac38a9d2f4" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_assume </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assume page ownership. </p>
<p>Called when page is already locked by the hosting VM.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!cl_page_is_owned(pg, io) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>cl_page_is_owned(pg, io)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a252f84a75b3822e0d7fb071f9b7bca85" title="Called for a page that is already &quot;owned&quot; by io from VM point of view.">cl_page_operations::cpo_assume()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00652">652</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01752">cl_io::ci_obj</a>, <a class="el" href="cl__io_8c_source.html#l01152">cl_io_top()</a>, <a class="el" href="cl__object_8h_source.html#l00720">cp_obj</a>, <a class="el" href="cl__object_8h_source.html#l00742">cp_owner</a>, and <a class="el" href="cl__object_8h_source.html#l00640">CPS_OWNED</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l01038">cl_page_list_assume()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00654"></a>00654 {
<a name="l00655"></a>00655         PINVRNT(env, pg, cl_object_same(pg-&gt;<a class="code" href="structcl__page.html#aa26f7281959921dababe7892b869abb2" title="An object this page is a part of.">cp_obj</a>, io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a>));
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         ENTRY;
<a name="l00658"></a>00658         io = <a class="code" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top-level io.">cl_io_top</a>(io);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660         cl_page_invoid(env, io, pg, CL_PAGE_OP(cpo_assume));
<a name="l00661"></a>00661         PASSERT(env, pg, pg-&gt;<a class="code" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cp_owner</a> == NULL);
<a name="l00662"></a>00662         pg-&gt;<a class="code" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cp_owner</a> = <a class="code" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top-level io.">cl_io_top</a>(io);
<a name="l00663"></a>00663         cl_page_owner_set(pg);
<a name="l00664"></a>00664         cl_page_state_set(env, pg, <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39ac64ebd72495a45cc57902f32131deee9" title="Page is exclusively owned by some cl_io.">CPS_OWNED</a>);
<a name="l00665"></a>00665         EXIT;
<a name="l00666"></a>00666 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga77a2e8592e58cc9c514cb4ac38a9d2f4_cgraph.png" border="0" usemap="#group__cl__page_ga77a2e8592e58cc9c514cb4ac38a9d2f4_cgraph_map" alt=""></div>
<map name="group__cl__page_ga77a2e8592e58cc9c514cb4ac38a9d2f4_cgraph_map" id="group__cl__page_ga77a2e8592e58cc9c514cb4ac38a9d2f4_cgraph">
<area shape="rect" id="node3" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top&#45;level io." alt="" coords="188,5,268,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga77a2e8592e58cc9c514cb4ac38a9d2f4_icgraph.png" border="0" usemap="#group__cl__page_ga77a2e8592e58cc9c514cb4ac38a9d2f4_icgraph_map" alt=""></div>
<map name="group__cl__page_ga77a2e8592e58cc9c514cb4ac38a9d2f4_icgraph_map" id="group__cl__page_ga77a2e8592e58cc9c514cb4ac38a9d2f4_icgraph">
<area shape="rect" id="node3" href="group__cl__page__list.html#ga321527c28a251fead1c4d8e7967da693" title="Assumes all pages in a queue." alt="" coords="188,32,345,61"/><area shape="rect" id="node5" href="group__cl__page__list.html#gaf1c12344f300cfdabbaabba9544db1da" title="Assume to own the pages in cl_2queue." alt="" coords="395,5,544,35"/><area shape="rect" id="node7" href="group__cl__io.html#ga575a43e2ec65ba4aa6c926cf5e49fe70" title="Submit a sync_io and wait for the IO to be finished, or error happens." alt="" coords="399,59,540,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga2218cff8efc343a14d1c312f64e15e1f"></a><!-- doxytag: member="cl_object.h::cl_page_clip" ref="ga2218cff8efc343a14d1c312f64e15e1f" args="(const struct lu_env *env, struct cl_page *pg, int from, int to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_clip </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells transfer engine that only part of a page is to be transmitted. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#aece03986dfa3b574ef3cc06ce36a830b" title="Tell transfer engine that only [to, from] part of a page should be transmitted.">cl_page_operations::cpo_clip()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00995">995</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00997"></a>00997 {
<a name="l00998"></a>00998         PINVRNT(env, pg, cl_page_invariant(pg));
<a name="l00999"></a>00999 
<a name="l01000"></a>01000         <a class="code" href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4" title="Helper macro, dumping shorter information about page into a log.">CL_PAGE_HEADER</a>(D_TRACE, env, pg, <span class="stringliteral">&quot;%d %d\n&quot;</span>, from, to);
<a name="l01001"></a>01001         CL_PAGE_INVOID(env, pg, CL_PAGE_OP(cpo_clip),
<a name="l01002"></a>01002                        (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *,
<a name="l01003"></a>01003                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *,<span class="keywordtype">int</span>, <span class="keywordtype">int</span>),
<a name="l01004"></a>01004                        from, to);
<a name="l01005"></a>01005 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga778ad6a1a849ef9701db714913c879ec"></a><!-- doxytag: member="cl_object.h::cl_page_completion" ref="ga778ad6a1a849ef9701db714913c879ec" args="(const struct lu_env *env, struct cl_page *pg, enum cl_req_type crt, int ioret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_completion </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a>&nbsp;</td>
          <td class="paramname"> <em>crt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ioret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify layers about transfer completion. </p>
<p>Invoked by transfer sub-system (which is a part of osc) to notify layers that a transfer, of which this page is a part of has completed.</p>
<p>Completion call-backs are executed in the bottom-up order, so that uppermost layer (llite), responsible for the VFS/VM interaction runs last and can release locks safely.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>pg-&gt;cp_state == CPS_PAGEIN || pg-&gt;cp_state == CPS_PAGEOUT </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>pg-&gt;cp_state == CPS_CACHED</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a10efe3c32edb23a4fb1f6b1af177bf95" title="Completion handler.">cl_page_operations::cpo_completion()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00909">909</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__io_8c_source.html#l01258">cl_sync_io_note()</a>, <a class="el" href="cl__object_8h_source.html#l00731">cp_state</a>, <a class="el" href="cl__object_8h_source.html#l00750">cp_sync_io</a>, and <a class="el" href="cl__object_8h_source.html#l00611">CPS_CACHED</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00911"></a>00911 {
<a name="l00912"></a>00912         <span class="keyword">struct </span><a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a> *anchor = pg-&gt;<a class="code" href="structcl__page.html#a9fee0561b08bf01258f9824f0c2b62d2" title="Assigned if doing a sync_io.">cp_sync_io</a>;
<a name="l00913"></a>00913 
<a name="l00914"></a>00914         PASSERT(env, pg, crt &lt; CRT_NR);
<a name="l00915"></a>00915         PASSERT(env, pg, pg-&gt;<a class="code" href="structcl__page.html#a96e9addda3754eb5551faaa00f94e903" title="Page state.">cp_state</a> == cl_req_type_state(crt));
<a name="l00916"></a>00916 
<a name="l00917"></a>00917         ENTRY;
<a name="l00918"></a>00918         <a class="code" href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4" title="Helper macro, dumping shorter information about page into a log.">CL_PAGE_HEADER</a>(D_TRACE, env, pg, <span class="stringliteral">&quot;%d %d\n&quot;</span>, crt, ioret);
<a name="l00919"></a>00919         cl_page_state_set(env, pg, <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">CPS_CACHED</a>);
<a name="l00920"></a>00920         <span class="keywordflow">if</span> (crt &gt;= CRT_NR)
<a name="l00921"></a>00921                 <span class="keywordflow">return</span>;
<a name="l00922"></a>00922         CL_PAGE_INVOID_REVERSE(env, pg, CL_PAGE_OP(io[crt].cpo_completion),
<a name="l00923"></a>00923                                (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *,
<a name="l00924"></a>00924                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *, <span class="keywordtype">int</span>), ioret);
<a name="l00925"></a>00925         <span class="keywordflow">if</span> (anchor != NULL) {
<a name="l00926"></a>00926                 LASSERT(pg-&gt;<a class="code" href="structcl__page.html#a9fee0561b08bf01258f9824f0c2b62d2" title="Assigned if doing a sync_io.">cp_sync_io</a> == anchor);
<a name="l00927"></a>00927                 pg-&gt;<a class="code" href="structcl__page.html#a9fee0561b08bf01258f9824f0c2b62d2" title="Assigned if doing a sync_io.">cp_sync_io</a> = NULL;
<a name="l00928"></a>00928                 <a class="code" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9" title="Indicate that transfer of a single page completed.">cl_sync_io_note</a>(env, anchor, ioret);
<a name="l00929"></a>00929         }
<a name="l00930"></a>00930         EXIT;
<a name="l00931"></a>00931 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga778ad6a1a849ef9701db714913c879ec_cgraph.png" border="0" usemap="#group__cl__page_ga778ad6a1a849ef9701db714913c879ec_cgraph_map" alt=""></div>
<map name="group__cl__page_ga778ad6a1a849ef9701db714913c879ec_cgraph_map" id="group__cl__page_ga778ad6a1a849ef9701db714913c879ec_cgraph">
<area shape="rect" id="node3" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9" title="Indicate that transfer of a single page completed." alt="" coords="208,5,336,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga55a51f6efaa6effc3b5b3d045d4ee432"></a><!-- doxytag: member="cl_object.h::cl_page_delete" ref="ga55a51f6efaa6effc3b5b3d045d4ee432" args="(const struct lu_env *env, struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_delete </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when a decision is made to throw page out of memory. </p>
<p>Notifies all layers about page destruction by calling <a class="el" href="structcl__page__operations.html#a5c6692ed54cf2c677e7b8bd90b08a013" title="Called when page is removed from the cache, and is about to being destroyed.">cl_page_operations::cpo_delete()</a> method top-to-bottom.</p>
<p>Moves page into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a> state (this is the only place where transition to this state happens).</p>
<p>Eliminates all venues through which new references to the page can be obtained:</p>
<ul>
<li>removes page from the radix trees,</li>
</ul>
<ul>
<li>breaks linkage from VM page to <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>.</li>
</ul>
<p>Once page reaches <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a>, all remaining references will drain after some time, at which point page will be recycled.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>VM page is locked </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>pg-&gt;cp_state == CPS_FREEING</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a5c6692ed54cf2c677e7b8bd90b08a013" title="Called when page is removed from the cache, and is about to being destroyed.">cl_page_operations::cpo_delete()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00790">790</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00791"></a>00791 {
<a name="l00792"></a>00792         PINVRNT(env, pg, cl_page_invariant(pg));
<a name="l00793"></a>00793         ENTRY;
<a name="l00794"></a>00794         cl_page_delete0(env, pg);
<a name="l00795"></a>00795         EXIT;
<a name="l00796"></a>00796 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga775efaa18bd22d404f7588fd35f6cd03"></a><!-- doxytag: member="cl_object.h::cl_page_discard" ref="ga775efaa18bd22d404f7588fd35f6cd03" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_discard </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when page is to be removed from the object, e.g., as a result of truncate. </p>
<p>Calls <a class="el" href="structcl__page__operations.html#a56791c4e1490f9df55b3e4f6fc83c845" title="Page destruction.">cl_page_operations::cpo_discard()</a> top-to-bottom.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>cl_page_is_owned(pg, io)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a56791c4e1490f9df55b3e4f6fc83c845" title="Page destruction.">cl_page_operations::cpo_discard()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00732">732</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l01052">cl_page_list_discard()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00734"></a>00734 {
<a name="l00735"></a>00735         PINVRNT(env, pg, <a class="code" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io.">cl_page_is_owned</a>(pg, io));
<a name="l00736"></a>00736         PINVRNT(env, pg, cl_page_invariant(pg));
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         cl_page_invoid(env, io, pg, CL_PAGE_OP(cpo_discard));
<a name="l00739"></a>00739 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga775efaa18bd22d404f7588fd35f6cd03_cgraph.png" border="0" usemap="#group__cl__page_ga775efaa18bd22d404f7588fd35f6cd03_cgraph_map" alt=""></div>
<map name="group__cl__page_ga775efaa18bd22d404f7588fd35f6cd03_cgraph_map" id="group__cl__page_ga775efaa18bd22d404f7588fd35f6cd03_cgraph">
<area shape="rect" id="node3" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io." alt="" coords="181,5,323,35"/><area shape="rect" id="node5" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top&#45;level io." alt="" coords="372,5,452,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga775efaa18bd22d404f7588fd35f6cd03_icgraph.png" border="0" usemap="#group__cl__page_ga775efaa18bd22d404f7588fd35f6cd03_icgraph_map" alt=""></div>
<map name="group__cl__page_ga775efaa18bd22d404f7588fd35f6cd03_icgraph_map" id="group__cl__page_ga775efaa18bd22d404f7588fd35f6cd03_icgraph">
<area shape="rect" id="node3" href="group__cl__page__list.html#gabe8fbe4bdda923be3d8ee245549230f8" title="Discards all pages in a queue." alt="" coords="181,5,336,35"/><area shape="rect" id="node5" href="group__cl__page__list.html#gab47261ab07f2e439b306dccb18a0980e" title="Discard (truncate) pages in both lists of a 2&#45;queue." alt="" coords="384,5,528,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gae41a4c98faae723b2566a721b6e4b7fb"></a><!-- doxytag: member="cl_object.h::cl_page_disown" ref="gae41a4c98faae723b2566a721b6e4b7fb" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_disown </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases page ownership. </p>
<p>Moves page into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>cl_page_is_owned(pg, io) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>!cl_page_is_owned(pg, io)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own()</a> </dd>
<dd>
<a class="el" href="structcl__page__operations.html#a4d11c1fa2d9422c18786f613c9221138" title="Called when ownership it yielded.">cl_page_operations::cpo_disown()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00709">709</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__io_8c_source.html#l01152">cl_io_top()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, <a class="el" href="cl__object_8h_source.html#l00731">cp_state</a>, and <a class="el" href="cl__object_8h_source.html#l00690">CPS_FREEING</a>.</p>

<p>Referenced by <a class="el" href="osc__page_8c_source.html#l00667">osc_lru_shrink()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00711"></a>00711 {
<a name="l00712"></a>00712         PINVRNT(env, pg, <a class="code" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io.">cl_page_is_owned</a>(pg, io) ||
<a name="l00713"></a>00713                 pg-&gt;<a class="code" href="structcl__page.html#a96e9addda3754eb5551faaa00f94e903" title="Page state.">cp_state</a> == <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">CPS_FREEING</a>);
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         ENTRY;
<a name="l00716"></a>00716         io = <a class="code" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top-level io.">cl_io_top</a>(io);
<a name="l00717"></a>00717         cl_page_disown0(env, io, pg);
<a name="l00718"></a>00718         EXIT;
<a name="l00719"></a>00719 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_gae41a4c98faae723b2566a721b6e4b7fb_cgraph.png" border="0" usemap="#group__cl__page_gae41a4c98faae723b2566a721b6e4b7fb_cgraph_map" alt=""></div>
<map name="group__cl__page_gae41a4c98faae723b2566a721b6e4b7fb_cgraph_map" id="group__cl__page_gae41a4c98faae723b2566a721b6e4b7fb_cgraph">
<area shape="rect" id="node3" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top&#45;level io." alt="" coords="369,5,449,35"/><area shape="rect" id="node5" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io." alt="" coords="179,31,320,60"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_gae41a4c98faae723b2566a721b6e4b7fb_icgraph.png" border="0" usemap="#group__cl__page_gae41a4c98faae723b2566a721b6e4b7fb_icgraph_map" alt=""></div>
<map name="group__cl__page_gae41a4c98faae723b2566a721b6e4b7fb_icgraph_map" id="group__cl__page_gae41a4c98faae723b2566a721b6e4b7fb_icgraph">
<area shape="rect" id="node3" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop &#160;of pages from LRU at most." alt="" coords="180,5,292,35"/><area shape="rect" id="node5" href="group__osc.html#ga084c788be8d116db87ebdd3c273d9a23" title="Scan and try to reclaim sc&#45;&gt;nr_to_scan cached LRU pages." alt="" coords="341,5,517,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gafacf1187afd6e200c6f8d59539baf50c"></a><!-- doxytag: member="cl_object.h::cl_page_export" ref="gafacf1187afd6e200c6f8d59539baf50c" args="(const struct lu_env *env, struct cl_page *pg, int uptodate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_export </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uptodate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks page up-to-date. </p>
<p>Call <a class="el" href="structcl__page__operations.html#ad84c50cbd10e0aabbffd4c7d2fd15197" title="Announces whether the page contains valid data or not by uptodate.">cl_page_operations::cpo_export()</a> through all layers top-to-bottom. The layer responsible for VM interaction has to mark/clear page as up-to-date by the <em>uptodate</em> argument.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#ad84c50cbd10e0aabbffd4c7d2fd15197" title="Announces whether the page contains valid data or not by uptodate.">cl_page_operations::cpo_export()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00808">808</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00809"></a>00809 {
<a name="l00810"></a>00810         PINVRNT(env, pg, cl_page_invariant(pg));
<a name="l00811"></a>00811         CL_PAGE_INVOID(env, pg, CL_PAGE_OP(cpo_export),
<a name="l00812"></a>00812                        (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *,
<a name="l00813"></a>00813                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *, <span class="keywordtype">int</span>), uptodate);
<a name="l00814"></a>00814 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga448fbdaea940886c756e4a2d659982ba"></a><!-- doxytag: member="cl_object.h::cl_page_find" ref="ga448fbdaea940886c756e4a2d659982ba" args="(const struct lu_env *env, struct cl_object *obj, pgoff_t idx, struct page *vmpage, enum cl_page_type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__page.html">cl_page</a>* cl_page_find </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct page *&nbsp;</td>
          <td class="paramname"> <em>vmpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga04ed60b0572c2fcfa6c2590aac97f92d">cl_page_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> with index <em>idx</em> at the object <em>o</em>, and associated with the VM page <em>vmpage</em>. </p>
<p>This is the main entry point into the <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> caching interface. First, a cache (implemented as a per-object radix tree) is consulted. If page is found there, it is returned immediately. Otherwise new page is allocated and returned. In any case, additional reference to page is acquired.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__object.html#gacc02a64c0c65d5fab9a6fafc83771acd" title="Returns a cl_object with a given fid.">cl_object_find()</a>, cl_lock_find() </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00231">231</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__page_8c_source.html#l00398">cl_vmpage_page()</a>, <a class="el" href="cl__object_8h_source.html#l00421">cl_object_header::coh_lu</a>, <a class="el" href="cl__object_8h_source.html#l00697">CPT_CACHEABLE</a>, <a class="el" href="cl__object_8h_source.html#l00702">CPT_TRANSIENT</a>, and <a class="el" href="lu__object_8h_source.html#l00525">lu_object_header::loh_fid</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00235"></a>00235 {
<a name="l00236"></a>00236         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>          *page = NULL;
<a name="l00237"></a>00237         <span class="keyword">struct </span><a class="code" href="structcl__object__header.html" title="Extended header for client object.">cl_object_header</a> *hdr;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239         LASSERT(type == <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936" title="Host page, the page is from the host inode which the cl_page belongs to.">CPT_CACHEABLE</a> || type == <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d" title="Transient page, the transient cl_page is used to bind a cl_page to vmpage which is...">CPT_TRANSIENT</a>);
<a name="l00240"></a>00240         might_sleep();
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         ENTRY;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244         hdr = <a class="code" href="structcl__object__header.html" title="Extended header for client object.">cl_object_header</a>(o);
<a name="l00245"></a>00245         CS_PAGE_INC(o, lookup);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         CDEBUG(D_PAGE, <span class="stringliteral">&quot;%lu@&quot;</span>DFID<span class="stringliteral">&quot; %p %lx %d\n&quot;</span>,
<a name="l00248"></a>00248                idx, PFID(&amp;hdr-&gt;<a class="code" href="structcl__object__header.html#ae1f6b59740d6bf9e0bbc6d8786fbc677" title="Standard lu_object_header.">coh_lu</a>.<a class="code" href="structlu__object__header.html#ae1336fa61cf0b1730f951b8255b9a4d7" title="Fid, uniquely identifying this object.">loh_fid</a>), vmpage, vmpage-&gt;private, type);
<a name="l00249"></a>00249         <span class="comment">/* fast path. */</span>
<a name="l00250"></a>00250         <span class="keywordflow">if</span> (type == <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936" title="Host page, the page is from the host inode which the cl_page belongs to.">CPT_CACHEABLE</a>) {
<a name="l00251"></a>00251                 <span class="comment">/* vmpage lock is used to protect the child/parent</span>
<a name="l00252"></a>00252 <span class="comment">                 * relationship */</span>
<a name="l00253"></a>00253                 KLASSERT(PageLocked(vmpage));
<a name="l00254"></a>00254                 <span class="comment">/*</span>
<a name="l00255"></a>00255 <span class="comment">                 * cl_vmpage_page() can be called here without any locks as</span>
<a name="l00256"></a>00256 <span class="comment">                 *</span>
<a name="l00257"></a>00257 <span class="comment">                 *     - &quot;vmpage&quot; is locked (which prevents -&gt;private from</span>
<a name="l00258"></a>00258 <span class="comment">                 *       concurrent updates), and</span>
<a name="l00259"></a>00259 <span class="comment">                 *</span>
<a name="l00260"></a>00260 <span class="comment">                 *     - &quot;o&quot; cannot be destroyed while current thread holds a</span>
<a name="l00261"></a>00261 <span class="comment">                 *       reference on it.</span>
<a name="l00262"></a>00262 <span class="comment">                 */</span>
<a name="l00263"></a>00263                 page = <a class="code" href="group__cl__page.html#gac3255abeeef8f9d9f3a4c80f553a75ed" title="Returns a cl_page associated with a VM page, and given cl_object.">cl_vmpage_page</a>(vmpage, o);
<a name="l00264"></a>00264                 <span class="keywordflow">if</span> (page != NULL) {
<a name="l00265"></a>00265                         CS_PAGE_INC(o, hit);
<a name="l00266"></a>00266                         RETURN(page);
<a name="l00267"></a>00267                 }
<a name="l00268"></a>00268         }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         <span class="comment">/* allocate and initialize cl_page */</span>
<a name="l00271"></a>00271         page = cl_page_alloc(env, o, idx, vmpage, type);
<a name="l00272"></a>00272         RETURN(page);
<a name="l00273"></a>00273 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga448fbdaea940886c756e4a2d659982ba_cgraph.png" border="0" usemap="#group__cl__page_ga448fbdaea940886c756e4a2d659982ba_cgraph_map" alt=""></div>
<map name="group__cl__page_ga448fbdaea940886c756e4a2d659982ba_cgraph_map" id="group__cl__page_ga448fbdaea940886c756e4a2d659982ba_cgraph">
<area shape="rect" id="node3" href="group__cl__page.html#gac3255abeeef8f9d9f3a4c80f553a75ed" title="Returns a cl_page associated with a VM page, and given cl_object." alt="" coords="159,5,292,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga0616bcd8605ed9a75e799f64bcdd5a2d"></a><!-- doxytag: member="cl_object.h::cl_page_flush" ref="ga0616bcd8605ed9a75e799f64bcdd5a2d" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_flush </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called if a pge is being written back by kernel's intention. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>cl_page_is_owned(pg, io) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>ergo(result == 0, pg-&gt;cp_state == CPS_PAGEOUT)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#a0056ad7a02f61f50cfa8dc6362b1be44" title="Write out a page by kernel.">cl_page_operations::cpo_flush()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00973">973</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, and <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00975"></a>00975 {
<a name="l00976"></a>00976         <span class="keywordtype">int</span> result;
<a name="l00977"></a>00977 
<a name="l00978"></a>00978         PINVRNT(env, pg, <a class="code" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io.">cl_page_is_owned</a>(pg, io));
<a name="l00979"></a>00979         PINVRNT(env, pg, cl_page_invariant(pg));
<a name="l00980"></a>00980 
<a name="l00981"></a>00981         ENTRY;
<a name="l00982"></a>00982 
<a name="l00983"></a>00983         result = cl_page_invoke(env, io, pg, CL_PAGE_OP(cpo_flush));
<a name="l00984"></a>00984 
<a name="l00985"></a>00985         <a class="code" href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4" title="Helper macro, dumping shorter information about page into a log.">CL_PAGE_HEADER</a>(D_TRACE, env, pg, <span class="stringliteral">&quot;%d\n&quot;</span>, result);
<a name="l00986"></a>00986         RETURN(result);
<a name="l00987"></a>00987 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga0616bcd8605ed9a75e799f64bcdd5a2d_cgraph.png" border="0" usemap="#group__cl__page_ga0616bcd8605ed9a75e799f64bcdd5a2d_cgraph_map" alt=""></div>
<map name="group__cl__page_ga0616bcd8605ed9a75e799f64bcdd5a2d_cgraph_map" id="group__cl__page_ga0616bcd8605ed9a75e799f64bcdd5a2d_cgraph">
<area shape="rect" id="node3" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io." alt="" coords="165,5,307,35"/><area shape="rect" id="node5" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top&#45;level io." alt="" coords="356,5,436,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gafc2fc785c3daf1db46bb250244dfde13"></a><!-- doxytag: member="cl_object.h::cl_page_get" ref="gafc2fc785c3daf1db46bb250244dfde13" args="(struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>page</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Acquires an additional reference to a page. </p>
<p>This can be called only by caller already possessing a reference to <em>page</em>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__object.html#gae84de86afc6e9dbf1f9e1a7219bd202b" title="Acquire an additional reference to the object o.">cl_object_get()</a>, cl_lock_get(). </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00355">355</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00866">cl_page_list_add()</a>, and <a class="el" href="osc__page_8c_source.html#l00667">osc_lru_shrink()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00356"></a>00356 {
<a name="l00357"></a>00357         ENTRY;
<a name="l00358"></a>00358         cl_page_get_trust(page);
<a name="l00359"></a>00359         EXIT;
<a name="l00360"></a>00360 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_gafc2fc785c3daf1db46bb250244dfde13_icgraph.png" border="0" usemap="#group__cl__page_gafc2fc785c3daf1db46bb250244dfde13_icgraph_map" alt=""></div>
<map name="group__cl__page_gafc2fc785c3daf1db46bb250244dfde13_icgraph_map" id="group__cl__page_gafc2fc785c3daf1db46bb250244dfde13_icgraph">
<area shape="rect" id="node3" href="group__cl__page__list.html#ga78d782095ec6f5d72e432d0ef0b35b3a" title="Adds a page to a page list." alt="" coords="157,5,288,35"/><area shape="rect" id="node9" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop &#160;of pages from LRU at most." alt="" coords="167,59,279,88"/><area shape="rect" id="node5" href="group__cl__page__list.html#ga55b5a5a4118185f0a7212299f2a65fac" title="Add a page to the incoming page list of 2&#45;queue." alt="" coords="364,5,484,35"/><area shape="rect" id="node7" href="group__cl__page__list.html#gac54e35928bc036fca6e31c480285924c" title="Initialize a 2&#45;queue to contain page in its incoming page list." alt="" coords="561,5,719,35"/><area shape="rect" id="node11" href="group__osc.html#ga084c788be8d116db87ebdd3c273d9a23" title="Scan and try to reclaim sc&#45;&gt;nr_to_scan cached LRU pages." alt="" coords="336,59,512,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga864bcec4bff9dd1f988f928348c08796"></a><!-- doxytag: member="cl_object.h::cl_page_make_ready" ref="ga864bcec4bff9dd1f988f928348c08796" args="(const struct lu_env *env, struct cl_page *pg, enum cl_req_type crt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_make_ready </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a>&nbsp;</td>
          <td class="paramname"> <em>crt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify layers that transfer formation engine decided to yank this page from the cache and to make it a part of a transfer. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>pg-&gt;cp_state == CPS_CACHED </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>pg-&gt;cp_state == CPS_PAGEIN || pg-&gt;cp_state == CPS_PAGEOUT</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structcl__page__operations.html#ac9f10051729d6cdc35868c30fcb81cea" title="Called when cached page is about to be added to the ptlrpc request as a part of req...">cl_page_operations::cpo_make_ready()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00943">943</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__object_8h_source.html#l00731">cp_state</a>, and <a class="el" href="cl__object_8h_source.html#l00611">CPS_CACHED</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00945"></a>00945 {
<a name="l00946"></a>00946         <span class="keywordtype">int</span> result;
<a name="l00947"></a>00947 
<a name="l00948"></a>00948         PINVRNT(env, pg, crt &lt; CRT_NR);
<a name="l00949"></a>00949 
<a name="l00950"></a>00950         ENTRY;
<a name="l00951"></a>00951         <span class="keywordflow">if</span> (crt &gt;= CRT_NR)
<a name="l00952"></a>00952                 RETURN(-EINVAL);
<a name="l00953"></a>00953         result = CL_PAGE_INVOKE(env, pg, CL_PAGE_OP(io[crt].cpo_make_ready),
<a name="l00954"></a>00954                                 (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *,
<a name="l00955"></a>00955                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *));
<a name="l00956"></a>00956         <span class="keywordflow">if</span> (result == 0) {
<a name="l00957"></a>00957                 PASSERT(env, pg, pg-&gt;<a class="code" href="structcl__page.html#a96e9addda3754eb5551faaa00f94e903" title="Page state.">cp_state</a> == <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">CPS_CACHED</a>);
<a name="l00958"></a>00958                 cl_page_io_start(env, pg, crt);
<a name="l00959"></a>00959         }
<a name="l00960"></a>00960         <a class="code" href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4" title="Helper macro, dumping shorter information about page into a log.">CL_PAGE_HEADER</a>(D_TRACE, env, pg, <span class="stringliteral">&quot;%d %d\n&quot;</span>, crt, result);
<a name="l00961"></a>00961         RETURN(result);
<a name="l00962"></a>00962 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2f91322039a4254d13f6e0a668e5746a"></a><!-- doxytag: member="cl_object.h::cl_page_own" ref="ga2f91322039a4254d13f6e0a668e5746a" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_own </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Own a page, might be blocked. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>cl_page_own0() </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00623">623</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l01015">cl_page_list_own()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00624"></a>00624 {
<a name="l00625"></a>00625         <span class="keywordflow">return</span> cl_page_own0(env, io, pg, 0);
<a name="l00626"></a>00626 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga2f91322039a4254d13f6e0a668e5746a_icgraph.png" border="0" usemap="#group__cl__page_ga2f91322039a4254d13f6e0a668e5746a_icgraph_map" alt=""></div>
<map name="group__cl__page_ga2f91322039a4254d13f6e0a668e5746a_icgraph_map" id="group__cl__page_ga2f91322039a4254d13f6e0a668e5746a_icgraph">
<area shape="rect" id="node3" href="group__cl__page__list.html#gaddbba15e99055d90aba88ec1b282455a" title="Owns all pages in a queue." alt="" coords="161,5,295,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga105c7ed0e326d75ffc75980986186bb7"></a><!-- doxytag: member="cl_object.h::cl_page_own_try" ref="ga105c7ed0e326d75ffc75980986186bb7" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_own_try </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nonblock version of <a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>cl_page_own0() </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00634">634</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>Referenced by <a class="el" href="osc__page_8c_source.html#l00667">osc_lru_shrink()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00636"></a>00636 {
<a name="l00637"></a>00637         <span class="keywordflow">return</span> cl_page_own0(env, io, pg, 1);
<a name="l00638"></a>00638 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga105c7ed0e326d75ffc75980986186bb7_icgraph.png" border="0" usemap="#group__cl__page_ga105c7ed0e326d75ffc75980986186bb7_icgraph_map" alt=""></div>
<map name="group__cl__page_ga105c7ed0e326d75ffc75980986186bb7_icgraph_map" id="group__cl__page_ga105c7ed0e326d75ffc75980986186bb7_icgraph">
<area shape="rect" id="node3" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop &#160;of pages from LRU at most." alt="" coords="191,5,303,35"/><area shape="rect" id="node5" href="group__osc.html#ga084c788be8d116db87ebdd3c273d9a23" title="Scan and try to reclaim sc&#45;&gt;nr_to_scan cached LRU pages." alt="" coords="352,5,528,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga8216a843e48aa6d45d049b6aacb13744"></a><!-- doxytag: member="cl_object.h::cl_page_prep" ref="ga8216a843e48aa6d45d049b6aacb13744" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg, enum cl_req_type crt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_page_prep </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a>&nbsp;</td>
          <td class="paramname"> <em>crt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares page for immediate transfer. </p>
<p><a class="el" href="structcl__page__operations.html#a544c974f96094f81cfb62d875f26e492" title="Called when a page is submitted for a transfer as a part of cl_page_list.">cl_page_operations::cpo_prep()</a> is called top-to-bottom. Every layer either agrees to submit this page (by returning 0), or requests to omit this page (by returning -EALREADY). Layer handling interactions with the VM also has to inform VM that page is under transfer now. </p>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00866">866</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, <a class="el" href="cl__object_8h_source.html#l00736">cp_type</a>, and <a class="el" href="cl__object_8h_source.html#l00697">CPT_CACHEABLE</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00868"></a>00868 {
<a name="l00869"></a>00869         <span class="keywordtype">int</span> result;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871         PINVRNT(env, pg, <a class="code" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io.">cl_page_is_owned</a>(pg, io));
<a name="l00872"></a>00872         PINVRNT(env, pg, cl_page_invariant(pg));
<a name="l00873"></a>00873         PINVRNT(env, pg, crt &lt; CRT_NR);
<a name="l00874"></a>00874 
<a name="l00875"></a>00875         <span class="comment">/*</span>
<a name="l00876"></a>00876 <span class="comment">         * XXX this has to be called bottom-to-top, so that llite can set up</span>
<a name="l00877"></a>00877 <span class="comment">         * PG_writeback without risking other layers deciding to skip this</span>
<a name="l00878"></a>00878 <span class="comment">         * page.</span>
<a name="l00879"></a>00879 <span class="comment">         */</span>
<a name="l00880"></a>00880         <span class="keywordflow">if</span> (crt &gt;= CRT_NR)
<a name="l00881"></a>00881                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00882"></a>00882         result = cl_page_invoke(env, io, pg, CL_PAGE_OP(io[crt].cpo_prep));
<a name="l00883"></a>00883         <span class="keywordflow">if</span> (result == 0)
<a name="l00884"></a>00884                 cl_page_io_start(env, pg, crt);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886         KLASSERT(ergo(crt == CRT_WRITE &amp;&amp; pg-&gt;<a class="code" href="structcl__page.html#a5b1df421c69f4dd003decae6bfa71467" title="Page type.">cp_type</a> == <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92da241d19f60653ebad43a9cdd3eb5af936" title="Host page, the page is from the host inode which the cl_page belongs to.">CPT_CACHEABLE</a>,
<a name="l00887"></a>00887                       equi(result == 0,
<a name="l00888"></a>00888                            PageWriteback(cl_page_vmpage(pg)))));
<a name="l00889"></a>00889         <a class="code" href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4" title="Helper macro, dumping shorter information about page into a log.">CL_PAGE_HEADER</a>(D_TRACE, env, pg, <span class="stringliteral">&quot;%d %d\n&quot;</span>, crt, result);
<a name="l00890"></a>00890         <span class="keywordflow">return</span> result;
<a name="l00891"></a>00891 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga8216a843e48aa6d45d049b6aacb13744_cgraph.png" border="0" usemap="#group__cl__page_ga8216a843e48aa6d45d049b6aacb13744_cgraph_map" alt=""></div>
<map name="group__cl__page_ga8216a843e48aa6d45d049b6aacb13744_cgraph_map" id="group__cl__page_ga8216a843e48aa6d45d049b6aacb13744_cgraph">
<area shape="rect" id="node3" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io." alt="" coords="165,5,307,35"/><area shape="rect" id="node5" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top&#45;level io." alt="" coords="356,5,436,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga1dc4205fd892e559c96ce97aad4eebf1"></a><!-- doxytag: member="cl_object.h::cl_page_put" ref="ga1dc4205fd892e559c96ce97aad4eebf1" args="(const struct lu_env *env, struct cl_page *page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_put </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>page</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases a reference to a page. </p>
<p>When last reference is released, page is returned to the cache, unless it is in <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">cl_page_state::CPS_FREEING</a> state, in which case it is immediately destroyed.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put()</a>, cl_lock_put(). </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00372">372</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l01017">CL_PAGE_HEADER</a>, <a class="el" href="cl__object_8h_source.html#l00724">cp_batch</a>, <a class="el" href="cl__object_8h_source.html#l00742">cp_owner</a>, <a class="el" href="cl__object_8h_source.html#l00716">cp_ref</a>, <a class="el" href="cl__object_8h_source.html#l00731">cp_state</a>, and <a class="el" href="cl__object_8h_source.html#l00690">CPS_FREEING</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00886">cl_page_list_del()</a>, and <a class="el" href="cl__io_8c_source.html#l00963">cl_page_list_disown()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00373"></a>00373 {
<a name="l00374"></a>00374         ENTRY;
<a name="l00375"></a>00375         <a class="code" href="group__cl__page.html#gaeeca225390e016ad5bb7ab7ab31e3ab4" title="Helper macro, dumping shorter information about page into a log.">CL_PAGE_HEADER</a>(D_TRACE, env, page, <span class="stringliteral">&quot;%d\n&quot;</span>,
<a name="l00376"></a>00376                        atomic_read(&amp;page-&gt;<a class="code" href="structcl__page.html#a1dc94f624c3d567c7e870e75d0bd2954" title="Reference counter.">cp_ref</a>));
<a name="l00377"></a>00377 
<a name="l00378"></a>00378         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;page-&gt;<a class="code" href="structcl__page.html#a1dc94f624c3d567c7e870e75d0bd2954" title="Reference counter.">cp_ref</a>)) {
<a name="l00379"></a>00379                 LASSERT(page-&gt;<a class="code" href="structcl__page.html#a96e9addda3754eb5551faaa00f94e903" title="Page state.">cp_state</a> == <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">CPS_FREEING</a>);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381                 LASSERT(atomic_read(&amp;page-&gt;<a class="code" href="structcl__page.html#a1dc94f624c3d567c7e870e75d0bd2954" title="Reference counter.">cp_ref</a>) == 0);
<a name="l00382"></a>00382                 PASSERT(env, page, page-&gt;<a class="code" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cp_owner</a> == NULL);
<a name="l00383"></a>00383                 PASSERT(env, page, list_empty(&amp;page-&gt;<a class="code" href="structcl__page.html#a728db31646edabc4ff8c8cfc3f30f10f" title="Linkage of pages within group.">cp_batch</a>));
<a name="l00384"></a>00384                 <span class="comment">/*</span>
<a name="l00385"></a>00385 <span class="comment">                 * Page is no longer reachable by other threads. Tear</span>
<a name="l00386"></a>00386 <span class="comment">                 * it down.</span>
<a name="l00387"></a>00387 <span class="comment">                 */</span>
<a name="l00388"></a>00388                 cl_page_free(env, page);
<a name="l00389"></a>00389         }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391         EXIT;
<a name="l00392"></a>00392 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga1dc4205fd892e559c96ce97aad4eebf1_icgraph.png" border="0" usemap="#group__cl__page_ga1dc4205fd892e559c96ce97aad4eebf1_icgraph_map" alt=""></div>
<map name="group__cl__page_ga1dc4205fd892e559c96ce97aad4eebf1_icgraph_map" id="group__cl__page_ga1dc4205fd892e559c96ce97aad4eebf1_icgraph">
<area shape="rect" id="node3" href="group__cl__page__list.html#ga365b60118b6d1e7cf4ce21d58babf5b9" title="Removes a page from a page list." alt="" coords="171,59,296,88"/><area shape="rect" id="node11" href="group__cl__page__list.html#ga6775317c52f6e2540b62563f559cfab6" title="Disowns pages in a queue." alt="" coords="157,112,309,141"/><area shape="rect" id="node5" href="group__cl__page__list.html#gaf77c34a166e78fa83a75ec296dc0d3fe" title="Releases pages from queue." alt="" coords="367,5,492,35"/><area shape="rect" id="node9" href="group__cl__page__list.html#gaddbba15e99055d90aba88ec1b282455a" title="Owns all pages in a queue." alt="" coords="363,59,496,88"/><area shape="rect" id="node7" href="group__cl__page__list.html#gafce330d7c8aa93047c5716cba8f4f379" title="Finalize both page lists of a 2&#45;queue." alt="" coords="551,5,665,35"/><area shape="rect" id="node13" href="group__cl__page__list.html#ga70c6911b231ec808fedc50b9e27e2699" title="Disown pages in both lists of a 2&#45;queue." alt="" coords="359,112,500,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga4e7db1845b76bea8277b4e3d2a482f61"></a><!-- doxytag: member="cl_object.h::cl_page_unassume" ref="ga4e7db1845b76bea8277b4e3d2a482f61" args="(const struct lu_env *env, struct cl_io *io, struct cl_page *pg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_page_unassume </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;</td>
          <td class="paramname"> <em>pg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases page ownership without unlocking the page. </p>
<p>Moves page into <a class="el" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">cl_page_state::CPS_CACHED</a> without releasing a lock on the underlying VM page (as VM is supposed to do this itself).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>cl_page_is_owned(pg, io) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>!cl_page_is_owned(pg, io)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga77a2e8592e58cc9c514cb4ac38a9d2f4" title="Assume page ownership.">cl_page_assume()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__page_8c_source.html#l00680">680</a> of file <a class="el" href="cl__page_8c_source.html">cl_page.c</a>.</p>

<p>References <a class="el" href="cl__io_8c_source.html#l01152">cl_io_top()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, and <a class="el" href="cl__object_8h_source.html#l00611">CPS_CACHED</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00682"></a>00682 {
<a name="l00683"></a>00683         PINVRNT(env, pg, <a class="code" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io.">cl_page_is_owned</a>(pg, io));
<a name="l00684"></a>00684         PINVRNT(env, pg, cl_page_invariant(pg));
<a name="l00685"></a>00685 
<a name="l00686"></a>00686         ENTRY;
<a name="l00687"></a>00687         io = <a class="code" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top-level io.">cl_io_top</a>(io);
<a name="l00688"></a>00688         cl_page_owner_clear(pg);
<a name="l00689"></a>00689         cl_page_state_set(env, pg, <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a820b29d9f4041d5672898ba94a52a7ba" title="Page is in the cache, un-owned.">CPS_CACHED</a>);
<a name="l00690"></a>00690         CL_PAGE_INVOID_REVERSE(env, pg, CL_PAGE_OP(cpo_unassume),
<a name="l00691"></a>00691                                (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *,
<a name="l00692"></a>00692                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *),
<a name="l00693"></a>00693                                io);
<a name="l00694"></a>00694         EXIT;
<a name="l00695"></a>00695 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__page_ga4e7db1845b76bea8277b4e3d2a482f61_cgraph.png" border="0" usemap="#group__cl__page_ga4e7db1845b76bea8277b4e3d2a482f61_cgraph_map" alt=""></div>
<map name="group__cl__page_ga4e7db1845b76bea8277b4e3d2a482f61_cgraph_map" id="group__cl__page_ga4e7db1845b76bea8277b4e3d2a482f61_cgraph">
<area shape="rect" id="node3" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top&#45;level io." alt="" coords="393,5,473,35"/><area shape="rect" id="node5" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io." alt="" coords="203,31,344,60"/></map>
</div>
</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:37 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
