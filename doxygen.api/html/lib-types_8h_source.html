<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lnet/include/lnet/lib-types.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lnet/include/lnet/lib-types.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2012, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lnet/include/lnet/lib-types.h</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Types used by the library side routines that do not need to be</span>
<a name="l00039"></a>00039 <span class="comment"> * exposed to the user application</span>
<a name="l00040"></a>00040 <span class="comment"> */</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#ifndef __LNET_LIB_TYPES_H__</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define __LNET_LIB_TYPES_H__</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="preprocessor">#ifndef __KERNEL__</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor"># error This include is only for kernel use.</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;linux/kthread.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;linux/uio.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;linux/types.h&gt;</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;lnet/lnetctl.h&gt;</span>
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">/* Max payload size */</span>
<a name="l00056"></a>00056 <span class="preprocessor">#ifndef CONFIG_LNET_MAX_PAYLOAD</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor"># error &quot;CONFIG_LNET_MAX_PAYLOAD must be defined in config.h&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="preprocessor">#define LNET_MAX_PAYLOAD       CONFIG_LNET_MAX_PAYLOAD</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#if (LNET_MAX_PAYLOAD &lt; LNET_MTU)</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor"># error &quot;LNET_MAX_PAYLOAD too small - error in configure --with-max-payload-mb&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#elif (LNET_MAX_PAYLOAD &gt; (PAGE_SIZE * LNET_MAX_IOV))</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor"># error &quot;LNET_MAX_PAYLOAD too large - error in configure --with-max-payload-mb&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span>
<a name="l00067"></a>00067 <span class="comment">/* forward refs */</span>
<a name="l00068"></a>00068 <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a>;
<a name="l00069"></a>00069 
<a name="l00070"></a><a class="code" href="structlnet__msg.html">00070</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__msg.html">lnet_msg</a> {
<a name="l00071"></a>00071         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        msg_activelist;
<a name="l00072"></a>00072         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        msg_list;       <span class="comment">/* Q for credits/MD */</span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>       msg_target;
<a name="l00075"></a>00075         <span class="comment">/* where is it from, it&apos;s only for building event */</span>
<a name="l00076"></a>00076         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>              msg_from;
<a name="l00077"></a>00077         __u32                   msg_type;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079         <span class="comment">/* committed for sending */</span>
<a name="l00080"></a>00080         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            msg_tx_committed:1;
<a name="l00081"></a>00081         <span class="comment">/* CPT # this message committed for sending */</span>
<a name="l00082"></a>00082         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            msg_tx_cpt:15;
<a name="l00083"></a>00083         <span class="comment">/* committed for receiving */</span>
<a name="l00084"></a>00084         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            msg_rx_committed:1;
<a name="l00085"></a>00085         <span class="comment">/* CPT # this message committed for receiving */</span>
<a name="l00086"></a>00086         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            msg_rx_cpt:15;
<a name="l00087"></a>00087         <span class="comment">/* queued for tx credit */</span>
<a name="l00088"></a>00088         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            msg_tx_delayed:1;
<a name="l00089"></a>00089         <span class="comment">/* queued for RX buffer */</span>
<a name="l00090"></a>00090         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            msg_rx_delayed:1;
<a name="l00091"></a>00091         <span class="comment">/* ready for pending on RX delay list */</span>
<a name="l00092"></a>00092         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            msg_rx_ready_delay:1;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_vmflush:1;      <span class="comment">/* VM trying to free memory */</span>
<a name="l00095"></a>00095         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_target_is_router:1; <span class="comment">/* sending to a router */</span>
<a name="l00096"></a>00096         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_routing:1;      <span class="comment">/* being forwarded */</span>
<a name="l00097"></a>00097         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_ack:1;          <span class="comment">/* ack on finalize (PUT) */</span>
<a name="l00098"></a>00098         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_sending:1;      <span class="comment">/* outgoing message */</span>
<a name="l00099"></a>00099         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_receiving:1;    <span class="comment">/* being received */</span>
<a name="l00100"></a>00100         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_txcredit:1;     <span class="comment">/* taken an NI send credit */</span>
<a name="l00101"></a>00101         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_peertxcredit:1; <span class="comment">/* taken a peer send credit */</span>
<a name="l00102"></a>00102         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_rtrcredit:1;    <span class="comment">/* taken a globel router credit */</span>
<a name="l00103"></a>00103         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_peerrtrcredit:1; <span class="comment">/* taken a peer router credit */</span>
<a name="l00104"></a>00104         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_onactivelist:1; <span class="comment">/* on the activelist */</span>
<a name="l00105"></a>00105         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_rdma_get:1;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         <span class="keyword">struct </span><a class="code" href="structlnet__peer.html">lnet_peer</a>     *msg_txpeer;         <span class="comment">/* peer I&apos;m sending to */</span>
<a name="l00108"></a>00108         <span class="keyword">struct </span><a class="code" href="structlnet__peer.html">lnet_peer</a>     *msg_rxpeer;         <span class="comment">/* peer I received from */</span>
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         <span class="keywordtype">void</span>                 *msg_private;
<a name="l00111"></a>00111         <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a>    *msg_md;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_len;
<a name="l00114"></a>00114         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_wanted;
<a name="l00115"></a>00115         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_offset;
<a name="l00116"></a>00116         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          msg_niov;
<a name="l00117"></a>00117         <span class="keyword">struct </span>kvec          *msg_iov;
<a name="l00118"></a>00118         <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a>          *msg_kiov;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120         <a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>          msg_ev;
<a name="l00121"></a>00121         lnet_hdr_t            msg_hdr;
<a name="l00122"></a>00122 } <a class="code" href="structlnet__msg.html">lnet_msg_t</a>;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 
<a name="l00125"></a><a class="code" href="structlnet__libhandle.html">00125</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__libhandle.html">lnet_libhandle</a> {
<a name="l00126"></a>00126         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lh_hash_chain;
<a name="l00127"></a>00127         __u64                   lh_cookie;
<a name="l00128"></a>00128 } <a class="code" href="structlnet__libhandle.html">lnet_libhandle_t</a>;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="preprocessor">#define lh_entry(ptr, type, member) \</span>
<a name="l00131"></a>00131 <span class="preprocessor">        ((type *)((char *)(ptr)-(char *)(&amp;((type *)0)-&gt;member)))</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>
<a name="l00133"></a><a class="code" href="structlnet__eq.html">00133</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__eq.html">lnet_eq</a> {
<a name="l00134"></a>00134         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        eq_list;
<a name="l00135"></a>00135         <a class="code" href="structlnet__libhandle.html">lnet_libhandle_t</a>        eq_lh;
<a name="l00136"></a>00136         lnet_seq_t              eq_enq_seq;
<a name="l00137"></a>00137         lnet_seq_t              eq_deq_seq;
<a name="l00138"></a>00138         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            eq_size;
<a name="l00139"></a>00139         <a class="code" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e" title="Event queue handler function type.">lnet_eq_handler_t</a>       eq_callback;
<a name="l00140"></a>00140         <a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>            *eq_events;
<a name="l00141"></a>00141         <span class="keywordtype">int</span>                     **eq_refs;      <span class="comment">/* percpt refcount for EQ */</span>
<a name="l00142"></a>00142 } <a class="code" href="structlnet__eq.html">lnet_eq_t</a>;
<a name="l00143"></a>00143 
<a name="l00144"></a><a class="code" href="structlnet__me.html">00144</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__me.html">lnet_me</a> {
<a name="l00145"></a>00145         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        me_list;
<a name="l00146"></a>00146         <a class="code" href="structlnet__libhandle.html">lnet_libhandle_t</a>        me_lh;
<a name="l00147"></a>00147         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>       me_match_id;
<a name="l00148"></a>00148         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            me_portal;
<a name="l00149"></a>00149         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            me_pos;         <span class="comment">/* hash offset in mt_hash */</span>
<a name="l00150"></a>00150         __u64                   me_match_bits;
<a name="l00151"></a>00151         __u64                   me_ignore_bits;
<a name="l00152"></a>00152         <a class="code" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9" title="Specifies whether the match entry or memory descriptor should be unlinked automatically...">lnet_unlink_t</a>           me_unlink;
<a name="l00153"></a>00153         <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a>      *me_md;
<a name="l00154"></a>00154 } <a class="code" href="structlnet__me.html">lnet_me_t</a>;
<a name="l00155"></a>00155 
<a name="l00156"></a><a class="code" href="structlnet__libmd.html">00156</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a> {
<a name="l00157"></a>00157         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        md_list;
<a name="l00158"></a>00158         <a class="code" href="structlnet__libhandle.html">lnet_libhandle_t</a>        md_lh;
<a name="l00159"></a>00159         <a class="code" href="structlnet__me.html">lnet_me_t</a>              *md_me;
<a name="l00160"></a>00160         <span class="keywordtype">char</span>                   *md_start;
<a name="l00161"></a>00161         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            md_offset;
<a name="l00162"></a>00162         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            md_length;
<a name="l00163"></a>00163         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            md_max_size;
<a name="l00164"></a>00164         <span class="keywordtype">int</span>                     md_threshold;
<a name="l00165"></a>00165         <span class="keywordtype">int</span>                     md_refcount;
<a name="l00166"></a>00166         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            md_options;
<a name="l00167"></a>00167         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            md_flags;
<a name="l00168"></a>00168         <span class="keywordtype">void</span>                   *md_user_ptr;
<a name="l00169"></a>00169         <a class="code" href="structlnet__eq.html">lnet_eq_t</a>              *md_eq;
<a name="l00170"></a>00170         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            md_niov;        <span class="comment">/* # frags */</span>
<a name="l00171"></a>00171         <span class="keyword">union </span>{
<a name="l00172"></a>00172                 <span class="keyword">struct </span>kvec     iov[LNET_MAX_IOV];
<a name="l00173"></a>00173                 <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a>     kiov[LNET_MAX_IOV];
<a name="l00174"></a>00174         } md_iov;
<a name="l00175"></a>00175 } <a class="code" href="structlnet__libmd.html">lnet_libmd_t</a>;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="preprocessor">#define LNET_MD_FLAG_ZOMBIE      (1 &lt;&lt; 0)</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span><span class="preprocessor">#define LNET_MD_FLAG_AUTO_UNLINK (1 &lt;&lt; 1)</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="preprocessor">#define LNET_MD_FLAG_ABORTED     (1 &lt;&lt; 2)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span>
<a name="l00181"></a><a class="code" href="structlnet__test__peer__t.html">00181</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00182"></a>00182         <span class="comment">/* info about peers we are trying to fail */</span>
<a name="l00183"></a>00183         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        tp_list;        <span class="comment">/* ln_test_peers */</span>
<a name="l00184"></a>00184         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>              tp_nid;         <span class="comment">/* matching nid */</span>
<a name="l00185"></a>00185         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            tp_threshold;   <span class="comment">/* # failures to simulate */</span>
<a name="l00186"></a>00186 } <a class="code" href="structlnet__test__peer__t.html">lnet_test_peer_t</a>;
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="preprocessor">#define LNET_COOKIE_TYPE_MD    1</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span><span class="preprocessor">#define LNET_COOKIE_TYPE_ME    2</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span><span class="preprocessor">#define LNET_COOKIE_TYPE_EQ    3</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span><span class="preprocessor">#define LNET_COOKIE_TYPE_BITS  2</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span><span class="preprocessor">#define LNET_COOKIE_MASK        ((1ULL &lt;&lt; LNET_COOKIE_TYPE_BITS) - 1ULL)</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span>
<a name="l00194"></a>00194 <span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a>;                                  <span class="comment">/* forward ref */</span>
<a name="l00195"></a>00195 <span class="keyword">struct </span>socket;
<a name="l00196"></a>00196 
<a name="l00197"></a><a class="code" href="structlnet__lnd.html">00197</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__lnd.html">lnet_lnd</a>
<a name="l00198"></a>00198 {
<a name="l00199"></a>00199         <span class="comment">/* fields managed by portals */</span>
<a name="l00200"></a>00200         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lnd_list;       <span class="comment">/* stash in the LND table */</span>
<a name="l00201"></a>00201         <span class="keywordtype">int</span>                     lnd_refcount;   <span class="comment">/* # active instances */</span>
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         <span class="comment">/* fields initialized by the LND */</span>
<a name="l00204"></a>00204         __u32                   lnd_type;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         int  (*lnd_startup) (<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni);
<a name="l00207"></a>00207         void (*lnd_shutdown) (<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni);
<a name="l00208"></a>00208         int  (*lnd_ctl)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd, <span class="keywordtype">void</span> *arg);
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <span class="comment">/* In data movement APIs below, payload buffers are described as a set</span>
<a name="l00211"></a>00211 <span class="comment">         * of &apos;niov&apos; fragments which are...</span>
<a name="l00212"></a>00212 <span class="comment">         * EITHER</span>
<a name="l00213"></a>00213 <span class="comment">         *    in virtual memory (struct kvec *iov != NULL)</span>
<a name="l00214"></a>00214 <span class="comment">         * OR</span>
<a name="l00215"></a>00215 <span class="comment">         *    in pages (kernel only: plt_kiov_t *kiov != NULL).</span>
<a name="l00216"></a>00216 <span class="comment">         * The LND may NOT overwrite these fragment descriptors.</span>
<a name="l00217"></a>00217 <span class="comment">         * An &apos;offset&apos; and may specify a byte offset within the set of</span>
<a name="l00218"></a>00218 <span class="comment">         * fragments to start from</span>
<a name="l00219"></a>00219 <span class="comment">         */</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         <span class="comment">/* Start sending a preformatted message.  &apos;private&apos; is NULL for PUT and</span>
<a name="l00222"></a>00222 <span class="comment">         * GET messages; otherwise this is a response to an incoming message</span>
<a name="l00223"></a>00223 <span class="comment">         * and &apos;private&apos; is the &apos;private&apos; passed to lnet_parse().  Return</span>
<a name="l00224"></a>00224 <span class="comment">         * non-zero for immediate failure, otherwise complete later with</span>
<a name="l00225"></a>00225 <span class="comment">         * lnet_finalize() */</span>
<a name="l00226"></a>00226         int (*lnd_send)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keywordtype">void</span> *<span class="keyword">private</span>, <a class="code" href="structlnet__msg.html">lnet_msg_t</a> *msg);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228         <span class="comment">/* Start receiving &apos;mlen&apos; bytes of payload data, skipping the following</span>
<a name="l00229"></a>00229 <span class="comment">         * &apos;rlen&apos; - &apos;mlen&apos; bytes. &apos;private&apos; is the &apos;private&apos; passed to</span>
<a name="l00230"></a>00230 <span class="comment">         * lnet_parse().  Return non-zero for immedaite failure, otherwise</span>
<a name="l00231"></a>00231 <span class="comment">         * complete later with lnet_finalize().  This also gives back a receive</span>
<a name="l00232"></a>00232 <span class="comment">         * credit if the LND does flow control. */</span>
<a name="l00233"></a>00233         int (*lnd_recv)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keywordtype">void</span> *<span class="keyword">private</span>, <a class="code" href="structlnet__msg.html">lnet_msg_t</a> *msg,
<a name="l00234"></a>00234                         <span class="keywordtype">int</span> delayed, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> niov,
<a name="l00235"></a>00235                         <span class="keyword">struct </span>kvec *iov, <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a> *kiov,
<a name="l00236"></a>00236                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rlen);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         <span class="comment">/* lnet_parse() has had to delay processing of this message</span>
<a name="l00239"></a>00239 <span class="comment">         * (e.g. waiting for a forwarding buffer or send credits).  Give the</span>
<a name="l00240"></a>00240 <span class="comment">         * LND a chance to free urgently needed resources.  If called, return 0</span>
<a name="l00241"></a>00241 <span class="comment">         * for success and do NOT give back a receive credit; that has to wait</span>
<a name="l00242"></a>00242 <span class="comment">         * until lnd_recv() gets called.  On failure return &lt; 0 and</span>
<a name="l00243"></a>00243 <span class="comment">         * release resources; lnd_recv() will not be called. */</span>
<a name="l00244"></a>00244         int (*lnd_eager_recv)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keywordtype">void</span> *<span class="keyword">private</span>, <a class="code" href="structlnet__msg.html">lnet_msg_t</a> *msg,
<a name="l00245"></a>00245                               <span class="keywordtype">void</span> **new_privatep);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         <span class="comment">/* notification of peer health */</span>
<a name="l00248"></a>00248         void (*lnd_notify)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> peer, <span class="keywordtype">int</span> alive);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         <span class="comment">/* query of peer aliveness */</span>
<a name="l00251"></a>00251         void (*lnd_query)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> peer, cfs_time_t *when);
<a name="l00252"></a>00252 
<a name="l00253"></a>00253         <span class="comment">/* accept a new connection */</span>
<a name="l00254"></a>00254         int (*lnd_accept)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keyword">struct </span>socket *sock);
<a name="l00255"></a>00255 } <a class="code" href="structlnet__lnd.html">lnd_t</a>;
<a name="l00256"></a>00256 
<a name="l00257"></a><a class="code" href="structWIRE__ATTR.html">00257</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00258"></a>00258         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> ns_nid;
<a name="l00259"></a>00259         __u32      ns_status;
<a name="l00260"></a>00260         __u32      ns_unused;
<a name="l00261"></a>00261 } <a class="code" href="structWIRE__ATTR.html">WIRE_ATTR</a> lnet_ni_status_t;
<a name="l00262"></a>00262 
<a name="l00263"></a><a class="code" href="structlnet__tx__queue.html">00263</a> <span class="keyword">struct </span><a class="code" href="structlnet__tx__queue.html">lnet_tx_queue</a> {
<a name="l00264"></a>00264         <span class="keywordtype">int</span>                     tq_credits;     <span class="comment">/* # tx credits free */</span>
<a name="l00265"></a>00265         <span class="keywordtype">int</span>                     tq_credits_min; <span class="comment">/* lowest it&apos;s been */</span>
<a name="l00266"></a>00266         <span class="keywordtype">int</span>                     tq_credits_max; <span class="comment">/* total # tx credits */</span>
<a name="l00267"></a>00267         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        tq_delayed;     <span class="comment">/* delayed TXs */</span>
<a name="l00268"></a>00268 };
<a name="l00269"></a>00269 
<a name="l00270"></a><a class="code" href="structlnet__ni.html">00270</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> {
<a name="l00271"></a>00271         spinlock_t              ni_lock;
<a name="l00272"></a>00272         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        ni_list;        <span class="comment">/* chain on ln_nis */</span>
<a name="l00273"></a>00273         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        ni_cptlist;     <span class="comment">/* chain on ln_nis_cpt */</span>
<a name="l00274"></a>00274         <span class="keywordtype">int</span>                     ni_maxtxcredits; <span class="comment">/* # tx credits  */</span>
<a name="l00275"></a>00275         <span class="comment">/* # per-peer send credits */</span>
<a name="l00276"></a>00276         <span class="keywordtype">int</span>                     ni_peertxcredits;
<a name="l00277"></a>00277         <span class="comment">/* # per-peer router buffer credits */</span>
<a name="l00278"></a>00278         <span class="keywordtype">int</span>                     ni_peerrtrcredits;
<a name="l00279"></a>00279         <span class="comment">/* seconds to consider peer dead */</span>
<a name="l00280"></a>00280         <span class="keywordtype">int</span>                     ni_peertimeout;
<a name="l00281"></a>00281         <span class="keywordtype">int</span>                     ni_ncpts;       <span class="comment">/* number of CPTs */</span>
<a name="l00282"></a>00282         __u32                   *ni_cpts;       <span class="comment">/* bond NI on some CPTs */</span>
<a name="l00283"></a>00283         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>              ni_nid;         <span class="comment">/* interface&apos;s NID */</span>
<a name="l00284"></a>00284         <span class="keywordtype">void</span>                    *ni_data;       <span class="comment">/* instance-specific data */</span>
<a name="l00285"></a>00285         <a class="code" href="structlnet__lnd.html">lnd_t</a>                   *ni_lnd;        <span class="comment">/* procedural interface */</span>
<a name="l00286"></a>00286         <span class="keyword">struct </span><a class="code" href="structlnet__tx__queue.html">lnet_tx_queue</a>    **ni_tx_queues; <span class="comment">/* percpt TX queues */</span>
<a name="l00287"></a>00287         <span class="keywordtype">int</span>                     **ni_refs;      <span class="comment">/* percpt reference count */</span>
<a name="l00288"></a>00288         <span class="keywordtype">long</span>                    ni_last_alive;  <span class="comment">/* when I was last alive */</span>
<a name="l00289"></a>00289         lnet_ni_status_t        *ni_status;     <span class="comment">/* my health status */</span>
<a name="l00290"></a>00290         <span class="comment">/* per NI LND tunables */</span>
<a name="l00291"></a>00291         <span class="keyword">struct </span><a class="code" href="structlnet__ioctl__config__lnd__tunables.html">lnet_ioctl_config_lnd_tunables</a> *ni_lnd_tunables;
<a name="l00292"></a>00292         <span class="comment">/* equivalent interfaces to use */</span>
<a name="l00293"></a>00293         <span class="keywordtype">char</span>                    *ni_interfaces[LNET_MAX_INTERFACES];
<a name="l00294"></a>00294 } <a class="code" href="structlnet__ni.html">lnet_ni_t</a>;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="preprocessor">#define LNET_PROTO_PING_MATCHBITS       0x8000000000000000LL</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span>
<a name="l00298"></a>00298 <span class="comment">/* NB: value of these features equal to LNET_PROTO_PING_VERSION_x</span>
<a name="l00299"></a>00299 <span class="comment"> * of old LNet, so there shouldn&apos;t be any compatibility issue */</span>
<a name="l00300"></a>00300 <span class="preprocessor">#define LNET_PING_FEAT_INVAL            (0)             </span><span class="comment">/* no feature */</span>
<a name="l00301"></a>00301 <span class="preprocessor">#define LNET_PING_FEAT_BASE             (1 &lt;&lt; 0)        </span><span class="comment">/* just a ping */</span>
<a name="l00302"></a>00302 <span class="preprocessor">#define LNET_PING_FEAT_NI_STATUS        (1 &lt;&lt; 1)        </span><span class="comment">/* return NI status */</span>
<a name="l00303"></a>00303 <span class="preprocessor">#define LNET_PING_FEAT_RTE_DISABLED     (1 &lt;&lt; 2)        </span><span class="comment">/* Routing enabled */</span>
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="preprocessor">#define LNET_PING_FEAT_MASK             (LNET_PING_FEAT_BASE | \</span>
<a name="l00306"></a>00306 <span class="preprocessor">                                         LNET_PING_FEAT_NI_STATUS)</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>
<a name="l00308"></a>00308 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00309"></a>00309         __u32                   pi_magic;
<a name="l00310"></a>00310         __u32                   pi_features;
<a name="l00311"></a>00311         <a class="code" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd" title="ID of a process in a node.">lnet_pid_t</a>              pi_pid;
<a name="l00312"></a>00312         __u32                   pi_nnis;
<a name="l00313"></a>00313         lnet_ni_status_t        pi_ni[0];
<a name="l00314"></a>00314 } <a class="code" href="structWIRE__ATTR.html">WIRE_ATTR</a> lnet_ping_info_t;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">/* router checker data, per router */</span>
<a name="l00317"></a>00317 <span class="preprocessor">#define LNET_MAX_RTR_NIS   16</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span><span class="preprocessor">#define LNET_PINGINFO_SIZE offsetof(lnet_ping_info_t, pi_ni[LNET_MAX_RTR_NIS])</span>
<a name="l00319"></a><a class="code" href="structlnet__rc__data__t.html">00319</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00320"></a>00320         <span class="comment">/* chain on the_lnet.ln_zombie_rcd or ln_deathrow_rcd */</span>
<a name="l00321"></a>00321         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        rcd_list;
<a name="l00322"></a>00322         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>        rcd_mdh;        <span class="comment">/* ping buffer MD */</span>
<a name="l00323"></a>00323         <span class="keyword">struct </span><a class="code" href="structlnet__peer.html">lnet_peer</a>        *rcd_gateway;   <span class="comment">/* reference to gateway */</span>
<a name="l00324"></a>00324         lnet_ping_info_t        *rcd_pinginfo;  <span class="comment">/* ping buffer */</span>
<a name="l00325"></a>00325 } <a class="code" href="structlnet__rc__data__t.html">lnet_rc_data_t</a>;
<a name="l00326"></a>00326 
<a name="l00327"></a><a class="code" href="structlnet__peer.html">00327</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__peer.html">lnet_peer</a> {
<a name="l00328"></a>00328         <span class="comment">/* chain on peer hash */</span>
<a name="l00329"></a>00329         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lp_hashlist;
<a name="l00330"></a>00330         <span class="comment">/* messages blocking for tx credits */</span>
<a name="l00331"></a>00331         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lp_txq;
<a name="l00332"></a>00332         <span class="comment">/* messages blocking for router credits */</span>
<a name="l00333"></a>00333         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lp_rtrq;
<a name="l00334"></a>00334         <span class="comment">/* chain on router list */</span>
<a name="l00335"></a>00335         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lp_rtr_list;
<a name="l00336"></a>00336         <span class="comment">/* # tx credits available */</span>
<a name="l00337"></a>00337         <span class="keywordtype">int</span>                     lp_txcredits;
<a name="l00338"></a>00338         <span class="comment">/* low water mark */</span>
<a name="l00339"></a>00339         <span class="keywordtype">int</span>                     lp_mintxcredits;
<a name="l00340"></a>00340         <span class="comment">/* # router credits */</span>
<a name="l00341"></a>00341         <span class="keywordtype">int</span>                     lp_rtrcredits;
<a name="l00342"></a>00342         <span class="comment">/* low water mark */</span>
<a name="l00343"></a>00343         <span class="keywordtype">int</span>                     lp_minrtrcredits;
<a name="l00344"></a>00344         <span class="comment">/* alive/dead? */</span>
<a name="l00345"></a>00345         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lp_alive:1;
<a name="l00346"></a>00346         <span class="comment">/* notification outstanding? */</span>
<a name="l00347"></a>00347         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lp_notify:1;
<a name="l00348"></a>00348         <span class="comment">/* outstanding notification for LND? */</span>
<a name="l00349"></a>00349         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lp_notifylnd:1;
<a name="l00350"></a>00350         <span class="comment">/* some thread is handling notification */</span>
<a name="l00351"></a>00351         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lp_notifying:1;
<a name="l00352"></a>00352         <span class="comment">/* SEND event outstanding from ping */</span>
<a name="l00353"></a>00353         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lp_ping_notsent;
<a name="l00354"></a>00354         <span class="comment">/* # times router went dead&lt;-&gt;alive */</span>
<a name="l00355"></a>00355         <span class="keywordtype">int</span>                     lp_alive_count;
<a name="l00356"></a>00356         <span class="comment">/* bytes queued for sending */</span>
<a name="l00357"></a>00357         <span class="keywordtype">long</span>                    lp_txqnob;
<a name="l00358"></a>00358         <span class="comment">/* time of last aliveness news */</span>
<a name="l00359"></a>00359         cfs_time_t              lp_timestamp;
<a name="l00360"></a>00360         <span class="comment">/* time of last ping attempt */</span>
<a name="l00361"></a>00361         cfs_time_t              lp_ping_timestamp;
<a name="l00362"></a>00362         <span class="comment">/* != 0 if ping reply expected */</span>
<a name="l00363"></a>00363         cfs_time_t              lp_ping_deadline;
<a name="l00364"></a>00364         <span class="comment">/* when I was last alive */</span>
<a name="l00365"></a>00365         cfs_time_t              lp_last_alive;
<a name="l00366"></a>00366         <span class="comment">/* when lp_ni was queried last time */</span>
<a name="l00367"></a>00367         cfs_time_t              lp_last_query;
<a name="l00368"></a>00368         <span class="comment">/* interface peer is on */</span>
<a name="l00369"></a>00369         <a class="code" href="structlnet__ni.html">lnet_ni_t</a>               *lp_ni;
<a name="l00370"></a>00370         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>              lp_nid;         <span class="comment">/* peer&apos;s NID */</span>
<a name="l00371"></a>00371         <span class="keywordtype">int</span>                     lp_refcount;    <span class="comment">/* # refs */</span>
<a name="l00372"></a>00372         <span class="keywordtype">int</span>                     lp_cpt;         <span class="comment">/* CPT this peer attached on */</span>
<a name="l00373"></a>00373         <span class="comment">/* # refs from lnet_route_t::lr_gateway */</span>
<a name="l00374"></a>00374         <span class="keywordtype">int</span>                     lp_rtr_refcount;
<a name="l00375"></a>00375         <span class="comment">/* returned RC ping features */</span>
<a name="l00376"></a>00376         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lp_ping_feats;
<a name="l00377"></a>00377         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lp_routes;      <span class="comment">/* routers on this peer */</span>
<a name="l00378"></a>00378         <a class="code" href="structlnet__rc__data__t.html">lnet_rc_data_t</a>          *lp_rcd;        <span class="comment">/* router checker state */</span>
<a name="l00379"></a>00379 } <a class="code" href="structlnet__peer.html">lnet_peer_t</a>;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="comment">/* peer hash size */</span>
<a name="l00382"></a>00382 <span class="preprocessor">#define LNET_PEER_HASH_BITS     9</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span><span class="preprocessor">#define LNET_PEER_HASH_SIZE     (1 &lt;&lt; LNET_PEER_HASH_BITS)</span>
<a name="l00384"></a>00384 <span class="preprocessor"></span>
<a name="l00385"></a>00385 <span class="comment">/* peer hash table */</span>
<a name="l00386"></a><a class="code" href="structlnet__peer__table.html">00386</a> <span class="keyword">struct </span><a class="code" href="structlnet__peer__table.html">lnet_peer_table</a> {
<a name="l00387"></a>00387         <span class="keywordtype">int</span>                     pt_version;     <span class="comment">/* /proc validity stamp */</span>
<a name="l00388"></a>00388         <span class="keywordtype">int</span>                     pt_number;      <span class="comment">/* # peers extant */</span>
<a name="l00389"></a>00389         <span class="keywordtype">int</span>                     pt_zombies;     <span class="comment">/* # zombies to go to deathrow</span>
<a name="l00390"></a>00390 <span class="comment">                                                 * (and not there yet) */</span>
<a name="l00391"></a>00391         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        pt_deathrow;    <span class="comment">/* zombie peers */</span>
<a name="l00392"></a>00392         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *pt_hash;       <span class="comment">/* NID-&gt;peer hash */</span>
<a name="l00393"></a>00393 };
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="comment">/* peer aliveness is enabled only on routers for peers in a network where the</span>
<a name="l00396"></a>00396 <span class="comment"> * lnet_ni_t::ni_peertimeout has been set to a positive value */</span>
<a name="l00397"></a>00397 <span class="preprocessor">#define lnet_peer_aliveness_enabled(lp) (the_lnet.ln_routing != 0 &amp;&amp; \</span>
<a name="l00398"></a>00398 <span class="preprocessor">                                         (lp)-&gt;lp_ni-&gt;ni_peertimeout &gt; 0)</span>
<a name="l00399"></a>00399 <span class="preprocessor"></span>
<a name="l00400"></a><a class="code" href="structlnet__route__t.html">00400</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00401"></a>00401         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lr_list;        <span class="comment">/* chain on net */</span>
<a name="l00402"></a>00402         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lr_gwlist;      <span class="comment">/* chain on gateway */</span>
<a name="l00403"></a>00403         <a class="code" href="structlnet__peer.html">lnet_peer_t</a>             *lr_gateway;    <span class="comment">/* router node */</span>
<a name="l00404"></a>00404         __u32                   lr_net;         <span class="comment">/* remote network number */</span>
<a name="l00405"></a>00405         <span class="keywordtype">int</span>                     lr_seq;         <span class="comment">/* sequence for round-robin */</span>
<a name="l00406"></a>00406         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lr_downis;      <span class="comment">/* number of down NIs */</span>
<a name="l00407"></a>00407         __u32                   lr_hops;        <span class="comment">/* how far I am */</span>
<a name="l00408"></a>00408         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lr_priority;    <span class="comment">/* route priority */</span>
<a name="l00409"></a>00409 } <a class="code" href="structlnet__route__t.html">lnet_route_t</a>;
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="preprocessor">#define LNET_REMOTE_NETS_HASH_DEFAULT   (1U &lt;&lt; 7)</span>
<a name="l00412"></a>00412 <span class="preprocessor"></span><span class="preprocessor">#define LNET_REMOTE_NETS_HASH_MAX       (1U &lt;&lt; 16)</span>
<a name="l00413"></a>00413 <span class="preprocessor"></span><span class="preprocessor">#define LNET_REMOTE_NETS_HASH_SIZE      (1 &lt;&lt; the_lnet.ln_remote_nets_hbits)</span>
<a name="l00414"></a>00414 <span class="preprocessor"></span>
<a name="l00415"></a><a class="code" href="structlnet__remotenet__t.html">00415</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00416"></a>00416         <span class="comment">/* chain on ln_remote_nets_hash */</span>
<a name="l00417"></a>00417         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lrn_list;
<a name="l00418"></a>00418         <span class="comment">/* routes to me */</span>
<a name="l00419"></a>00419         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lrn_routes;
<a name="l00420"></a>00420         <span class="comment">/* my net number */</span>
<a name="l00421"></a>00421         __u32                   lrn_net;
<a name="l00422"></a>00422 } <a class="code" href="structlnet__remotenet__t.html">lnet_remotenet_t</a>;
<a name="l00423"></a>00423 
<a name="l00425"></a>00425 <span class="preprocessor">#define LNET_CREDIT_OK          0</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>
<a name="l00427"></a>00427 <span class="preprocessor">#define LNET_CREDIT_WAIT        1</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>
<a name="l00429"></a><a class="code" href="structlnet__rtrbufpool__t.html">00429</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00430"></a>00430         <span class="comment">/* my free buffer pool */</span>
<a name="l00431"></a>00431         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        rbp_bufs;
<a name="l00432"></a>00432         <span class="comment">/* messages blocking for a buffer */</span>
<a name="l00433"></a>00433         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        rbp_msgs;
<a name="l00434"></a>00434         <span class="comment">/* # pages in each buffer */</span>
<a name="l00435"></a>00435         <span class="keywordtype">int</span>                     rbp_npages;
<a name="l00436"></a>00436         <span class="comment">/* requested number of buffers */</span>
<a name="l00437"></a>00437         <span class="keywordtype">int</span>                     rbp_req_nbuffers;
<a name="l00438"></a>00438         <span class="comment">/* # buffers actually allocated */</span>
<a name="l00439"></a>00439         <span class="keywordtype">int</span>                     rbp_nbuffers;
<a name="l00440"></a>00440         <span class="comment">/* # free buffers / blocked messages */</span>
<a name="l00441"></a>00441         <span class="keywordtype">int</span>                     rbp_credits;
<a name="l00442"></a>00442         <span class="comment">/* low water mark */</span>
<a name="l00443"></a>00443         <span class="keywordtype">int</span>                     rbp_mincredits;
<a name="l00444"></a>00444 } <a class="code" href="structlnet__rtrbufpool__t.html">lnet_rtrbufpool_t</a>;
<a name="l00445"></a>00445 
<a name="l00446"></a><a class="code" href="structlnet__rtrbuf__t.html">00446</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00447"></a>00447         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>         rb_list;       <span class="comment">/* chain on rbp_bufs */</span>
<a name="l00448"></a>00448         <a class="code" href="structlnet__rtrbufpool__t.html">lnet_rtrbufpool_t</a>       *rb_pool;       <span class="comment">/* owning pool */</span>
<a name="l00449"></a>00449         <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a>              rb_kiov[0];    <span class="comment">/* the buffer space */</span>
<a name="l00450"></a>00450 } <a class="code" href="structlnet__rtrbuf__t.html">lnet_rtrbuf_t</a>;
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 <span class="preprocessor">#define LNET_PEER_HASHSIZE   503                </span><span class="comment">/* prime! */</span>
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="keyword">enum</span> {
<a name="l00455"></a>00455         <span class="comment">/* Didn&apos;t match anything */</span>
<a name="l00456"></a>00456         LNET_MATCHMD_NONE       = (1 &lt;&lt; 0),
<a name="l00457"></a>00457         <span class="comment">/* Matched OK */</span>
<a name="l00458"></a>00458         LNET_MATCHMD_OK         = (1 &lt;&lt; 1),
<a name="l00459"></a>00459         <span class="comment">/* Must be discarded */</span>
<a name="l00460"></a>00460         LNET_MATCHMD_DROP       = (1 &lt;&lt; 2),
<a name="l00461"></a>00461         <span class="comment">/* match and buffer is exhausted */</span>
<a name="l00462"></a>00462         LNET_MATCHMD_EXHAUSTED  = (1 &lt;&lt; 3),
<a name="l00463"></a>00463         <span class="comment">/* match or drop */</span>
<a name="l00464"></a>00464         LNET_MATCHMD_FINISH     = (LNET_MATCHMD_OK | LNET_MATCHMD_DROP),
<a name="l00465"></a>00465 };
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="comment">/* Options for lnet_portal_t::ptl_options */</span>
<a name="l00468"></a>00468 <span class="preprocessor">#define LNET_PTL_LAZY               (1 &lt;&lt; 0)</span>
<a name="l00469"></a>00469 <span class="preprocessor"></span><span class="preprocessor">#define LNET_PTL_MATCH_UNIQUE       (1 &lt;&lt; 1)    </span><span class="comment">/* unique match, for RDMA */</span>
<a name="l00470"></a>00470 <span class="preprocessor">#define LNET_PTL_MATCH_WILDCARD     (1 &lt;&lt; 2)    </span><span class="comment">/* wildcard match, request portal */</span>
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="comment">/* parameter for matching operations (GET, PUT) */</span>
<a name="l00473"></a><a class="code" href="structlnet__match__info.html">00473</a> <span class="keyword">struct </span><a class="code" href="structlnet__match__info.html">lnet_match_info</a> {
<a name="l00474"></a>00474         __u64                   mi_mbits;
<a name="l00475"></a>00475         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>       mi_id;
<a name="l00476"></a>00476         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            mi_opc;
<a name="l00477"></a>00477         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            mi_portal;
<a name="l00478"></a>00478         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            mi_rlength;
<a name="l00479"></a>00479         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            mi_roffset;
<a name="l00480"></a>00480 };
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="comment">/* ME hash of RDMA portal */</span>
<a name="l00483"></a>00483 <span class="preprocessor">#define LNET_MT_HASH_BITS               8</span>
<a name="l00484"></a>00484 <span class="preprocessor"></span><span class="preprocessor">#define LNET_MT_HASH_SIZE               (1 &lt;&lt; LNET_MT_HASH_BITS)</span>
<a name="l00485"></a>00485 <span class="preprocessor"></span><span class="preprocessor">#define LNET_MT_HASH_MASK               (LNET_MT_HASH_SIZE - 1)</span>
<a name="l00486"></a>00486 <span class="preprocessor"></span><span class="comment">/* we allocate (LNET_MT_HASH_SIZE + 1) entries for lnet_match_table::mt_hash,</span>
<a name="l00487"></a>00487 <span class="comment"> * the last entry is reserved for MEs with ignore-bits */</span>
<a name="l00488"></a>00488 <span class="preprocessor">#define LNET_MT_HASH_IGNORE             LNET_MT_HASH_SIZE</span>
<a name="l00489"></a>00489 <span class="preprocessor"></span><span class="comment">/* __u64 has 2^6 bits, so need 2^(LNET_MT_HASH_BITS - LNET_MT_BITS_U64) which</span>
<a name="l00490"></a>00490 <span class="comment"> * is 4 __u64s as bit-map, and add an extra __u64 (only use one bit) for the</span>
<a name="l00491"></a>00491 <span class="comment"> * ME-list with ignore-bits, which is mtable::mt_hash[LNET_MT_HASH_IGNORE] */</span>
<a name="l00492"></a>00492 <span class="preprocessor">#define LNET_MT_BITS_U64                6       </span><span class="comment">/* 2^6 bits */</span>
<a name="l00493"></a>00493 <span class="preprocessor">#define LNET_MT_EXHAUSTED_BITS          (LNET_MT_HASH_BITS - LNET_MT_BITS_U64)</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span><span class="preprocessor">#define LNET_MT_EXHAUSTED_BMAP          ((1 &lt;&lt; LNET_MT_EXHAUSTED_BITS) + 1)</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span>
<a name="l00496"></a>00496 <span class="comment">/* portal match table */</span>
<a name="l00497"></a><a class="code" href="structlnet__match__table.html">00497</a> <span class="keyword">struct </span><a class="code" href="structlnet__match__table.html">lnet_match_table</a> {
<a name="l00498"></a>00498         <span class="comment">/* reserved for upcoming patches, CPU partition ID */</span>
<a name="l00499"></a>00499         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            mt_cpt;
<a name="l00500"></a>00500         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            mt_portal;      <span class="comment">/* portal index */</span>
<a name="l00501"></a>00501         <span class="comment">/* match table is set as &quot;enabled&quot; if there&apos;s non-exhausted MD</span>
<a name="l00502"></a>00502 <span class="comment">         * attached on mt_mhash, it&apos;s only valid for wildcard portal */</span>
<a name="l00503"></a>00503         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            mt_enabled;
<a name="l00504"></a>00504         <span class="comment">/* bitmap to flag whether MEs on mt_hash are exhausted or not */</span>
<a name="l00505"></a>00505         __u64                   mt_exhausted[LNET_MT_EXHAUSTED_BMAP];
<a name="l00506"></a>00506         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *mt_mhash;      <span class="comment">/* matching hash */</span>
<a name="l00507"></a>00507 };
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="comment">/* these are only useful for wildcard portal */</span>
<a name="l00510"></a>00510 <span class="comment">/* Turn off message rotor for wildcard portals */</span>
<a name="l00511"></a>00511 <span class="preprocessor">#define LNET_PTL_ROTOR_OFF      0</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span><span class="comment">/* round-robin dispatch all PUT messages for wildcard portals */</span>
<a name="l00513"></a>00513 <span class="preprocessor">#define LNET_PTL_ROTOR_ON       1</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span><span class="comment">/* round-robin dispatch routed PUT message for wildcard portals */</span>
<a name="l00515"></a>00515 <span class="preprocessor">#define LNET_PTL_ROTOR_RR_RT    2</span>
<a name="l00516"></a>00516 <span class="preprocessor"></span><span class="comment">/* dispatch routed PUT message by hashing source NID for wildcard portals */</span>
<a name="l00517"></a>00517 <span class="preprocessor">#define LNET_PTL_ROTOR_HASH_RT  3</span>
<a name="l00518"></a>00518 <span class="preprocessor"></span>
<a name="l00519"></a><a class="code" href="structlnet__portal.html">00519</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__portal.html">lnet_portal</a> {
<a name="l00520"></a>00520         spinlock_t              ptl_lock;
<a name="l00521"></a>00521         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            ptl_index;      <span class="comment">/* portal ID, reserved */</span>
<a name="l00522"></a>00522         <span class="comment">/* flags on this portal: lazy, unique... */</span>
<a name="l00523"></a>00523         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            ptl_options;
<a name="l00524"></a>00524         <span class="comment">/* list of messages which are stealing buffer */</span>
<a name="l00525"></a>00525         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        ptl_msg_stealing;
<a name="l00526"></a>00526         <span class="comment">/* messages blocking for MD */</span>
<a name="l00527"></a>00527         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        ptl_msg_delayed;
<a name="l00528"></a>00528         <span class="comment">/* Match table for each CPT */</span>
<a name="l00529"></a>00529         <span class="keyword">struct </span><a class="code" href="structlnet__match__table.html">lnet_match_table</a> **ptl_mtables;
<a name="l00530"></a>00530         <span class="comment">/* spread rotor of incoming &quot;PUT&quot; */</span>
<a name="l00531"></a>00531         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            ptl_rotor;
<a name="l00532"></a>00532         <span class="comment">/* # active entries for this portal */</span>
<a name="l00533"></a>00533         <span class="keywordtype">int</span>                     ptl_mt_nmaps;
<a name="l00534"></a>00534         <span class="comment">/* array of active entries&apos; cpu-partition-id */</span>
<a name="l00535"></a>00535         <span class="keywordtype">int</span>                     ptl_mt_maps[0];
<a name="l00536"></a>00536 } <a class="code" href="structlnet__portal.html">lnet_portal_t</a>;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="preprocessor">#define LNET_LH_HASH_BITS       12</span>
<a name="l00539"></a>00539 <span class="preprocessor"></span><span class="preprocessor">#define LNET_LH_HASH_SIZE       (1ULL &lt;&lt; LNET_LH_HASH_BITS)</span>
<a name="l00540"></a>00540 <span class="preprocessor"></span><span class="preprocessor">#define LNET_LH_HASH_MASK       (LNET_LH_HASH_SIZE - 1)</span>
<a name="l00541"></a>00541 <span class="preprocessor"></span>
<a name="l00542"></a>00542 <span class="comment">/* resource container (ME, MD, EQ) */</span>
<a name="l00543"></a><a class="code" href="structlnet__res__container.html">00543</a> <span class="keyword">struct </span><a class="code" href="structlnet__res__container.html">lnet_res_container</a> {
<a name="l00544"></a>00544         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            rec_type;       <span class="comment">/* container type */</span>
<a name="l00545"></a>00545         __u64                   rec_lh_cookie;  <span class="comment">/* cookie generator */</span>
<a name="l00546"></a>00546         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        rec_active;     <span class="comment">/* active resource list */</span>
<a name="l00547"></a>00547         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *rec_lh_hash;   <span class="comment">/* handle hash */</span>
<a name="l00548"></a>00548 };
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="comment">/* message container */</span>
<a name="l00551"></a><a class="code" href="structlnet__msg__container.html">00551</a> <span class="keyword">struct </span><a class="code" href="structlnet__msg__container.html">lnet_msg_container</a> {
<a name="l00552"></a>00552         <span class="keywordtype">int</span>                     msc_init;       <span class="comment">/* initialized or not */</span>
<a name="l00553"></a>00553         <span class="comment">/* max # threads finalizing */</span>
<a name="l00554"></a>00554         <span class="keywordtype">int</span>                     msc_nfinalizers;
<a name="l00555"></a>00555         <span class="comment">/* msgs waiting to complete finalizing */</span>
<a name="l00556"></a>00556         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        msc_finalizing;
<a name="l00557"></a>00557         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        msc_active;     <span class="comment">/* active message list */</span>
<a name="l00558"></a>00558         <span class="comment">/* threads doing finalization */</span>
<a name="l00559"></a>00559         <span class="keywordtype">void</span>                    **msc_finalizers;
<a name="l00560"></a>00560 };
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="comment">/* Router Checker states */</span>
<a name="l00563"></a>00563 <span class="preprocessor">#define LNET_RC_STATE_SHUTDOWN          0       </span><span class="comment">/* not started */</span>
<a name="l00564"></a>00564 <span class="preprocessor">#define LNET_RC_STATE_RUNNING           1       </span><span class="comment">/* started up OK */</span>
<a name="l00565"></a>00565 <span class="preprocessor">#define LNET_RC_STATE_STOPPING          2       </span><span class="comment">/* telling thread to stop */</span>
<a name="l00566"></a>00566 
<a name="l00567"></a><a class="code" href="structlnet__t.html">00567</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00568"></a>00568 {
<a name="l00569"></a>00569         <span class="comment">/* CPU partition table of LNet */</span>
<a name="l00570"></a>00570         <span class="keyword">struct </span><a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>            *ln_cpt_table;
<a name="l00571"></a>00571         <span class="comment">/* number of CPTs in ln_cpt_table */</span>
<a name="l00572"></a>00572         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    ln_cpt_number;
<a name="l00573"></a>00573         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    ln_cpt_bits;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         <span class="comment">/* protect LNet resources (ME/MD/EQ) */</span>
<a name="l00576"></a>00576         <span class="keyword">struct </span><a class="code" href="structcfs__percpt__lock.html">cfs_percpt_lock</a>          *ln_res_lock;
<a name="l00577"></a>00577         <span class="comment">/* # portals */</span>
<a name="l00578"></a>00578         <span class="keywordtype">int</span>                             ln_nportals;
<a name="l00579"></a>00579         <span class="comment">/* the vector of portals */</span>
<a name="l00580"></a>00580         <a class="code" href="structlnet__portal.html">lnet_portal_t</a>                   **ln_portals;
<a name="l00581"></a>00581         <span class="comment">/* percpt ME containers */</span>
<a name="l00582"></a>00582         <span class="keyword">struct </span><a class="code" href="structlnet__res__container.html">lnet_res_container</a>       **ln_me_containers;
<a name="l00583"></a>00583         <span class="comment">/* percpt MD container */</span>
<a name="l00584"></a>00584         <span class="keyword">struct </span><a class="code" href="structlnet__res__container.html">lnet_res_container</a>       **ln_md_containers;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586         <span class="comment">/* Event Queue container */</span>
<a name="l00587"></a>00587         <span class="keyword">struct </span><a class="code" href="structlnet__res__container.html">lnet_res_container</a>       ln_eq_container;
<a name="l00588"></a>00588         wait_queue_head_t               ln_eq_waitq;
<a name="l00589"></a>00589         spinlock_t                      ln_eq_wait_lock;
<a name="l00590"></a>00590 
<a name="l00591"></a>00591         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    ln_remote_nets_hbits;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         <span class="comment">/* protect NI, peer table, credits, routers, rtrbuf... */</span>
<a name="l00594"></a>00594         <span class="keyword">struct </span><a class="code" href="structcfs__percpt__lock.html">cfs_percpt_lock</a>          *ln_net_lock;
<a name="l00595"></a>00595         <span class="comment">/* percpt message containers for active/finalizing/freed message */</span>
<a name="l00596"></a>00596         <span class="keyword">struct </span><a class="code" href="structlnet__msg__container.html">lnet_msg_container</a>       **ln_msg_containers;
<a name="l00597"></a>00597         <a class="code" href="structlnet__counters.html">lnet_counters_t</a>                 **ln_counters;
<a name="l00598"></a>00598         <span class="keyword">struct </span><a class="code" href="structlnet__peer__table.html">lnet_peer_table</a>          **ln_peer_tables;
<a name="l00599"></a>00599         <span class="comment">/* failure simulation */</span>
<a name="l00600"></a>00600         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_test_peers;
<a name="l00601"></a>00601         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_drop_rules;
<a name="l00602"></a>00602         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_delay_rules;
<a name="l00603"></a>00603 
<a name="l00604"></a>00604         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_nis;         <span class="comment">/* LND instances */</span>
<a name="l00605"></a>00605         <span class="comment">/* NIs bond on specific CPT(s) */</span>
<a name="l00606"></a>00606         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_nis_cpt;
<a name="l00607"></a>00607         <span class="comment">/* dying LND instances */</span>
<a name="l00608"></a>00608         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_nis_zombie;
<a name="l00609"></a>00609         <a class="code" href="structlnet__ni.html">lnet_ni_t</a>                       *ln_loni;       <span class="comment">/* the loopback NI */</span>
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         <span class="comment">/* remote networks with routes to them */</span>
<a name="l00612"></a>00612         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                *ln_remote_nets_hash;
<a name="l00613"></a>00613         <span class="comment">/* validity stamp */</span>
<a name="l00614"></a>00614         __u64                           ln_remote_nets_version;
<a name="l00615"></a>00615         <span class="comment">/* list of all known routers */</span>
<a name="l00616"></a>00616         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_routers;
<a name="l00617"></a>00617         <span class="comment">/* validity stamp */</span>
<a name="l00618"></a>00618         __u64                           ln_routers_version;
<a name="l00619"></a>00619         <span class="comment">/* percpt router buffer pools */</span>
<a name="l00620"></a>00620         <a class="code" href="structlnet__rtrbufpool__t.html">lnet_rtrbufpool_t</a>               **ln_rtrpools;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>                ln_ping_target_md;
<a name="l00623"></a>00623         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_eq_t</a>                ln_ping_target_eq;
<a name="l00624"></a>00624         lnet_ping_info_t                *ln_ping_info;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="comment">/* router checker startup/shutdown state */</span>
<a name="l00627"></a>00627         <span class="keywordtype">int</span>                             ln_rc_state;
<a name="l00628"></a>00628         <span class="comment">/* router checker&apos;s event queue */</span>
<a name="l00629"></a>00629         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_eq_t</a>                ln_rc_eqh;
<a name="l00630"></a>00630         <span class="comment">/* rcd still pending on net */</span>
<a name="l00631"></a>00631         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_rcd_deathrow;
<a name="l00632"></a>00632         <span class="comment">/* rcd ready for free */</span>
<a name="l00633"></a>00633         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_rcd_zombie;
<a name="l00634"></a>00634         <span class="comment">/* serialise startup/shutdown */</span>
<a name="l00635"></a>00635         <span class="keyword">struct </span>semaphore                ln_rc_signal;
<a name="l00636"></a>00636 
<a name="l00637"></a>00637         <span class="keyword">struct </span>mutex                    ln_api_mutex;
<a name="l00638"></a>00638         <span class="keyword">struct </span>mutex                    ln_lnd_mutex;
<a name="l00639"></a>00639         <span class="comment">/* Have I called LNetNIInit myself? */</span>
<a name="l00640"></a>00640         <span class="keywordtype">int</span>                             ln_niinit_self;
<a name="l00641"></a>00641         <span class="comment">/* LNetNIInit/LNetNIFini counter */</span>
<a name="l00642"></a>00642         <span class="keywordtype">int</span>                             ln_refcount;
<a name="l00643"></a>00643         <span class="comment">/* shutdown in progress */</span>
<a name="l00644"></a>00644         <span class="keywordtype">int</span>                             ln_shutdown;
<a name="l00645"></a>00645 
<a name="l00646"></a>00646         <span class="keywordtype">int</span>                             ln_routing;     <span class="comment">/* am I a router? */</span>
<a name="l00647"></a>00647         <a class="code" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd" title="ID of a process in a node.">lnet_pid_t</a>                      ln_pid;         <span class="comment">/* requested pid */</span>
<a name="l00648"></a>00648         <span class="comment">/* uniquely identifies this ni in this epoch */</span>
<a name="l00649"></a>00649         __u64                           ln_interface_cookie;
<a name="l00650"></a>00650         <span class="comment">/* registered LNDs */</span>
<a name="l00651"></a>00651         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_lnds;
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         <span class="comment">/* test protocol compatibility flags */</span>
<a name="l00654"></a>00654         <span class="keywordtype">int</span>                             ln_testprotocompat;
<a name="l00655"></a>00655 
<a name="l00656"></a>00656         <span class="comment">/* 0 - load the NIs from the mod params</span>
<a name="l00657"></a>00657 <span class="comment">         * 1 - do not load the NIs from the mod params</span>
<a name="l00658"></a>00658 <span class="comment">         * Reverse logic to ensure that other calls to LNetNIInit</span>
<a name="l00659"></a>00659 <span class="comment">         * need no change</span>
<a name="l00660"></a>00660 <span class="comment">         */</span>
<a name="l00661"></a>00661         <span class="keywordtype">bool</span>                            ln_nis_from_mod_params;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663         <span class="comment">/* waitq for router checker.  As long as there are no routes in</span>
<a name="l00664"></a>00664 <span class="comment">         * the list, the router checker will sleep on this queue.  when</span>
<a name="l00665"></a>00665 <span class="comment">         * routes are added the thread will wake up */</span>
<a name="l00666"></a>00666         wait_queue_head_t               ln_rc_waitq;
<a name="l00667"></a>00667 } <a class="code" href="structlnet__t.html">lnet_t</a>;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:11 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
