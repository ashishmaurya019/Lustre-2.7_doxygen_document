<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ptlrpc/client.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/ptlrpc/client.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> */</span>
<a name="l00036"></a>00036 
<a name="l00039"></a>00039 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_RPC</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;obd_support.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;lustre_lib.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;lustre_ha.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;lustre_import.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;lustre_req_layout.h&gt;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;ptlrpc_internal.h&quot;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> ptlrpc_bulk_kiov_pin_ops = {
<a name="l00051"></a>00051         .<a class="code" href="structptlrpc__bulk__frag__ops.html#a3338125828618910ae190978e235d52a" title="Add a page page to the bulk descriptor desc Data to transfer in the page starts at...">add_kiov_frag</a>  = ptlrpc_prep_bulk_page_pin,
<a name="l00052"></a>00052         .release_frags  = ptlrpc_release_bulk_page_pin,
<a name="l00053"></a>00053 };
<a name="l00054"></a>00054 EXPORT_SYMBOL(ptlrpc_bulk_kiov_pin_ops);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> ptlrpc_bulk_kiov_nopin_ops = {
<a name="l00057"></a>00057         .<a class="code" href="structptlrpc__bulk__frag__ops.html#a3338125828618910ae190978e235d52a" title="Add a page page to the bulk descriptor desc Data to transfer in the page starts at...">add_kiov_frag</a>  = ptlrpc_prep_bulk_page_nopin,
<a name="l00058"></a>00058         .release_frags  = ptlrpc_release_bulk_noop,
<a name="l00059"></a>00059 };
<a name="l00060"></a>00060 EXPORT_SYMBOL(ptlrpc_bulk_kiov_nopin_ops);
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> ptlrpc_bulk_kvec_ops = {
<a name="l00063"></a>00063         .add_iov_frag = ptlrpc_prep_bulk_frag,
<a name="l00064"></a>00064 };
<a name="l00065"></a>00065 EXPORT_SYMBOL(ptlrpc_bulk_kvec_ops);
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpc_send_new_req(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpcd_check_work(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00069"></a>00069 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpc_unregister_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request, <span class="keywordtype">int</span> async);
<a name="l00070"></a>00070 
<a name="l00074"></a><a class="code" href="group__net.html#ga8274d1c6229aa8679c30551cc4768778">00074</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga8274d1c6229aa8679c30551cc4768778" title="Initialize passed in client structure cl.">ptlrpc_init_client</a>(<span class="keywordtype">int</span> req_portal, <span class="keywordtype">int</span> rep_portal, <span class="keywordtype">char</span> *name,
<a name="l00075"></a>00075                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__client.html" title="Client definition for PortalRPC.">ptlrpc_client</a> *cl)
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077         cl-&gt;<a class="code" href="structptlrpc__client.html#abbeeccfdcf5796b6ee39005f23d2b8c5" title="What lnet portal does this client send messages to by default.">cli_request_portal</a> = req_portal;
<a name="l00078"></a>00078         cl-&gt;<a class="code" href="structptlrpc__client.html#a00cb08501a8d056a8620effccaabef95" title="What portal do we expect replies on.">cli_reply_portal</a>   = rep_portal;
<a name="l00079"></a>00079         cl-&gt;<a class="code" href="structptlrpc__client.html#a9b61858ed73fc74f022500d88e44d9aa" title="Name of the client.">cli_name</a>           = name;
<a name="l00080"></a>00080 }
<a name="l00081"></a>00081 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga8274d1c6229aa8679c30551cc4768778" title="Initialize passed in client structure cl.">ptlrpc_init_client</a>);
<a name="l00082"></a>00082 
<a name="l00086"></a><a class="code" href="group__net.html#gac16251a340153c3059c8727b8b39d400">00086</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> *<a class="code" href="group__net.html#gac16251a340153c3059c8727b8b39d400" title="Return PortalRPC connection for remore uud uuid.">ptlrpc_uuid_to_connection</a>(<span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *uuid)
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088         <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a> *c;
<a name="l00089"></a>00089         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>                <span class="keyword">self</span>;
<a name="l00090"></a>00090         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>         peer;
<a name="l00091"></a>00091         <span class="keywordtype">int</span>                       err;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093         <span class="comment">/* ptlrpc_uuid_to_peer() initializes its 2nd parameter</span>
<a name="l00094"></a>00094 <span class="comment">         * before accessing its values. */</span>
<a name="l00095"></a>00095         <span class="comment">/* coverity[uninit_use_in_call] */</span>
<a name="l00096"></a>00096         err = ptlrpc_uuid_to_peer(uuid, &amp;peer, &amp;<span class="keyword">self</span>);
<a name="l00097"></a>00097         <span class="keywordflow">if</span> (err != 0) {
<a name="l00098"></a>00098                 CNETERR(<span class="stringliteral">&quot;cannot find peer %s!\n&quot;</span>, uuid-&gt;uuid);
<a name="l00099"></a>00099                 <span class="keywordflow">return</span> NULL;
<a name="l00100"></a>00100         }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102         c = ptlrpc_connection_get(peer, <span class="keyword">self</span>, uuid);
<a name="l00103"></a>00103         <span class="keywordflow">if</span> (c) {
<a name="l00104"></a>00104                 memcpy(c-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>.uuid,
<a name="l00105"></a>00105                        uuid-&gt;uuid, <span class="keyword">sizeof</span>(c-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>.uuid));
<a name="l00106"></a>00106         }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108         CDEBUG(D_INFO, <span class="stringliteral">&quot;%s -&gt; %p\n&quot;</span>, uuid-&gt;uuid, c);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         <span class="keywordflow">return</span> c;
<a name="l00111"></a>00111 }
<a name="l00112"></a>00112 
<a name="l00117"></a>00117 <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *ptlrpc_new_bulk(<span class="keywordtype">unsigned</span> nfrags, <span class="keywordtype">unsigned</span> max_brw,
<a name="l00118"></a>00118                                          <span class="keyword">enum</span> ptlrpc_bulk_op_type type,
<a name="l00119"></a>00119                                          <span class="keywordtype">unsigned</span> portal,
<a name="l00120"></a>00120                                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> *ops)
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc;
<a name="l00123"></a>00123         <span class="keywordtype">int</span> i;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125         <span class="comment">/* ensure that only one of KIOV or IOVEC is set but not both */</span>
<a name="l00126"></a>00126         LASSERT((ptlrpc_is_bulk_desc_kiov(type) &amp;&amp;
<a name="l00127"></a>00127                  ops-&gt;<a class="code" href="structptlrpc__bulk__frag__ops.html#a3338125828618910ae190978e235d52a" title="Add a page page to the bulk descriptor desc Data to transfer in the page starts at...">add_kiov_frag</a> != NULL) ||
<a name="l00128"></a>00128                 (ptlrpc_is_bulk_desc_kvec(type) &amp;&amp;
<a name="l00129"></a>00129                  ops-&gt;add_iov_frag != NULL));
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         OBD_ALLOC_PTR(desc);
<a name="l00132"></a>00132         <span class="keywordflow">if</span> (desc == NULL)
<a name="l00133"></a>00133                 <span class="keywordflow">return</span> NULL;
<a name="l00134"></a>00134         <span class="keywordflow">if</span> (type &amp; PTLRPC_BULK_BUF_KIOV) {
<a name="l00135"></a>00135                 OBD_ALLOC_LARGE(GET_KIOV(desc),
<a name="l00136"></a>00136                                 nfrags * <span class="keyword">sizeof</span>(*GET_KIOV(desc)));
<a name="l00137"></a>00137                 <span class="keywordflow">if</span> (GET_KIOV(desc) == NULL)
<a name="l00138"></a>00138                         <span class="keywordflow">goto</span> out;
<a name="l00139"></a>00139         } <span class="keywordflow">else</span> {
<a name="l00140"></a>00140                 OBD_ALLOC_LARGE(GET_KVEC(desc),
<a name="l00141"></a>00141                                 nfrags * <span class="keyword">sizeof</span>(*GET_KVEC(desc)));
<a name="l00142"></a>00142                 <span class="keywordflow">if</span> (GET_KVEC(desc) == NULL)
<a name="l00143"></a>00143                         <span class="keywordflow">goto</span> out;
<a name="l00144"></a>00144         }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         spin_lock_init(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a52f0b671643e7e34bb40e845cadf4e10" title="For serialization with callback.">bd_lock</a>);
<a name="l00147"></a>00147         init_waitqueue_head(&amp;desc-&gt;bd_waitq);
<a name="l00148"></a>00148         desc-&gt;bd_max_iov = nfrags;
<a name="l00149"></a>00149         desc-&gt;bd_iov_count = 0;
<a name="l00150"></a>00150         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a18b9d9682e655499c82b9e785343d0df" title="LNet portal for this bulk.">bd_portal</a> = portal;
<a name="l00151"></a>00151         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a> = type;
<a name="l00152"></a>00152         desc-&gt;bd_md_count = 0;
<a name="l00153"></a>00153         desc-&gt;bd_frag_ops = (<span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a> *) ops;
<a name="l00154"></a>00154         LASSERT(max_brw &gt; 0);
<a name="l00155"></a>00155         desc-&gt;bd_md_max_brw = min(max_brw, PTLRPC_BULK_OPS_COUNT);
<a name="l00156"></a>00156         <span class="comment">/* PTLRPC_BULK_OPS_COUNT is the compile-time transfer limit for this</span>
<a name="l00157"></a>00157 <span class="comment">         * node. Negotiated ocd_brw_size will always be &lt;= this number. */</span>
<a name="l00158"></a>00158         <span class="keywordflow">for</span> (i = 0; i &lt; PTLRPC_BULK_OPS_COUNT; i++)
<a name="l00159"></a>00159                 LNetInvalidateHandle(&amp;desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a39514074e69f6f37f43699541282c288" title="array of associated MDs">bd_mds</a>[i]);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161         <span class="keywordflow">return</span> desc;
<a name="l00162"></a>00162 out:
<a name="l00163"></a>00163         OBD_FREE_PTR(desc);
<a name="l00164"></a>00164         <span class="keywordflow">return</span> NULL;
<a name="l00165"></a>00165 }
<a name="l00166"></a>00166 
<a name="l00174"></a><a class="code" href="group__net.html#ga42ea756e2d84491e4b6ea2e53616d7cb">00174</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *<a class="code" href="group__net.html#ga42ea756e2d84491e4b6ea2e53616d7cb" title="Prepare bulk descriptor for specified outgoing request req that can fit nfrags *...">ptlrpc_prep_bulk_imp</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00175"></a>00175                                               <span class="keywordtype">unsigned</span> nfrags, <span class="keywordtype">unsigned</span> max_brw,
<a name="l00176"></a>00176                                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> type,
<a name="l00177"></a>00177                                               <span class="keywordtype">unsigned</span> portal,
<a name="l00178"></a>00178                                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__frag__ops.html">ptlrpc_bulk_frag_ops</a>
<a name="l00179"></a>00179                                                 *ops)
<a name="l00180"></a>00180 {
<a name="l00181"></a>00181         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l00182"></a>00182         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         ENTRY;
<a name="l00185"></a>00185         LASSERT(ptlrpc_is_bulk_op_passive(type));
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         desc = ptlrpc_new_bulk(nfrags, max_brw, type, portal, ops);
<a name="l00188"></a>00188         <span class="keywordflow">if</span> (desc == NULL)
<a name="l00189"></a>00189                 RETURN(NULL);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a939c59e8ca2ab48321d206fb7ac148b5" title="Import generation when request for this bulk was sent.">bd_import_generation</a> = req-&gt;rq_import_generation;
<a name="l00192"></a>00192         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a> = class_import_get(imp);
<a name="l00193"></a>00193         desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a4d18b5020a6fbf0bb1c7f7e1af278707" title="Back pointer to the request.">bd_req</a> = req;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         desc-&gt;bd_cbid.cbid_fn  = client_bulk_callback;
<a name="l00196"></a>00196         desc-&gt;bd_cbid.cbid_arg = desc;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198         <span class="comment">/* This makes req own desc, and free it when she frees herself */</span>
<a name="l00199"></a>00199         req-&gt;rq_bulk = desc;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201         <span class="keywordflow">return</span> desc;
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga42ea756e2d84491e4b6ea2e53616d7cb" title="Prepare bulk descriptor for specified outgoing request req that can fit nfrags *...">ptlrpc_prep_bulk_imp</a>);
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keywordtype">void</span> __ptlrpc_prep_bulk_page(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l00206"></a>00206                              <span class="keyword">struct</span> page *page, <span class="keywordtype">int</span> pageoffset, <span class="keywordtype">int</span> len,
<a name="l00207"></a>00207                              <span class="keywordtype">int</span> pin)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209         <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a> *kiov;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         LASSERT(desc-&gt;bd_iov_count &lt; desc-&gt;bd_max_iov);
<a name="l00212"></a>00212         LASSERT(page != NULL);
<a name="l00213"></a>00213         LASSERT(pageoffset &gt;= 0);
<a name="l00214"></a>00214         LASSERT(len &gt; 0);
<a name="l00215"></a>00215         LASSERT(pageoffset + len &lt;= PAGE_CACHE_SIZE);
<a name="l00216"></a>00216         LASSERT(ptlrpc_is_bulk_desc_kiov(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a>));
<a name="l00217"></a>00217 
<a name="l00218"></a>00218         kiov = &amp;BD_GET_KIOV(desc, desc-&gt;bd_iov_count);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         desc-&gt;bd_nob += len;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222         <span class="keywordflow">if</span> (pin)
<a name="l00223"></a>00223                 page_cache_get(page);
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         kiov-&gt;<a class="code" href="structlnet__kiov__t.html#a50a346ec3d5a573b47b1b81082fe15ba" title="Pointer to the page where the fragment resides.">kiov_page</a> = page;
<a name="l00226"></a>00226         kiov-&gt;<a class="code" href="structlnet__kiov__t.html#a69ee2663fd9cca4f0991bfe03ee1eae7" title="Starting offset of the fragment within the page.">kiov_offset</a> = pageoffset;
<a name="l00227"></a>00227         kiov-&gt;<a class="code" href="structlnet__kiov__t.html#a7a568ff46457ba3eabafde610e393ee4" title="Length in bytes of the fragment.">kiov_len</a> = len;
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         desc-&gt;bd_iov_count++;
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 EXPORT_SYMBOL(__ptlrpc_prep_bulk_page);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="keywordtype">int</span> ptlrpc_prep_bulk_frag(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l00234"></a>00234                           <span class="keywordtype">void</span> *frag, <span class="keywordtype">int</span> len)
<a name="l00235"></a>00235 {
<a name="l00236"></a>00236         <span class="keyword">struct </span>kvec *iovec;
<a name="l00237"></a>00237         ENTRY;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239         LASSERT(desc-&gt;bd_iov_count &lt; desc-&gt;bd_max_iov);
<a name="l00240"></a>00240         LASSERT(frag != NULL);
<a name="l00241"></a>00241         LASSERT(len &gt; 0);
<a name="l00242"></a>00242         LASSERT(ptlrpc_is_bulk_desc_kvec(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a>));
<a name="l00243"></a>00243 
<a name="l00244"></a>00244         iovec = &amp;BD_GET_KVEC(desc, desc-&gt;bd_iov_count);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246         desc-&gt;bd_nob += len;
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         iovec-&gt;iov_base = frag;
<a name="l00249"></a>00249         iovec-&gt;iov_len = len;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251         desc-&gt;bd_iov_count++;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253         RETURN(desc-&gt;bd_nob);
<a name="l00254"></a>00254 }
<a name="l00255"></a>00255 EXPORT_SYMBOL(ptlrpc_prep_bulk_frag);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keywordtype">void</span> ptlrpc_free_bulk(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l00258"></a>00258 {
<a name="l00259"></a>00259         ENTRY;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261         LASSERT(desc != NULL);
<a name="l00262"></a>00262         LASSERT(desc-&gt;bd_iov_count != LI_POISON); <span class="comment">/* not freed already */</span>
<a name="l00263"></a>00263         LASSERT(desc-&gt;bd_md_count == 0);         <span class="comment">/* network hands off */</span>
<a name="l00264"></a>00264         LASSERT((desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a079104697abfc4ecef92f7f954f3c3d7" title="Server side - export this bulk created for.">bd_export</a> != NULL) ^ (desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a> != NULL));
<a name="l00265"></a>00265         LASSERT(desc-&gt;bd_frag_ops != NULL);
<a name="l00266"></a>00266 
<a name="l00267"></a>00267         <span class="keywordflow">if</span> (ptlrpc_is_bulk_desc_kiov(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a>))
<a name="l00268"></a>00268                 sptlrpc_enc_pool_put_pages(desc);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         <span class="keywordflow">if</span> (desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a079104697abfc4ecef92f7f954f3c3d7" title="Server side - export this bulk created for.">bd_export</a>)
<a name="l00271"></a>00271                 class_export_put(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a079104697abfc4ecef92f7f954f3c3d7" title="Server side - export this bulk created for.">bd_export</a>);
<a name="l00272"></a>00272         <span class="keywordflow">else</span>
<a name="l00273"></a>00273                 class_import_put(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a>);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         <span class="keywordflow">if</span> (desc-&gt;bd_frag_ops-&gt;<a class="code" href="structptlrpc__bulk__frag__ops.html#a2604b1837635c96693183c071925fd15" title="Uninitialize and free bulk descriptor desc.">release_frags</a> != NULL)
<a name="l00276"></a>00276                 desc-&gt;bd_frag_ops-&gt;<a class="code" href="structptlrpc__bulk__frag__ops.html#a2604b1837635c96693183c071925fd15" title="Uninitialize and free bulk descriptor desc.">release_frags</a>(desc);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278         <span class="keywordflow">if</span> (ptlrpc_is_bulk_desc_kiov(desc-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a1a24b94865575c0049c586b36fb20ca8" title="{put,get}{source,sink}{kvec,kiov}">bd_type</a>))
<a name="l00279"></a>00279                 OBD_FREE_LARGE(GET_KIOV(desc),
<a name="l00280"></a>00280                         desc-&gt;bd_max_iov * <span class="keyword">sizeof</span>(*GET_KIOV(desc)));
<a name="l00281"></a>00281         <span class="keywordflow">else</span>
<a name="l00282"></a>00282                 OBD_FREE_LARGE(GET_KVEC(desc),
<a name="l00283"></a>00283                         desc-&gt;bd_max_iov * <span class="keyword">sizeof</span>(*GET_KVEC(desc)));
<a name="l00284"></a>00284         OBD_FREE_PTR(desc);
<a name="l00285"></a>00285         EXIT;
<a name="l00286"></a>00286 }
<a name="l00287"></a>00287 EXPORT_SYMBOL(ptlrpc_free_bulk);
<a name="l00288"></a>00288 
<a name="l00293"></a><a class="code" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7">00293</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e.">ptlrpc_at_set_req_timeout</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295         __u32 serv_est;
<a name="l00296"></a>00296         <span class="keywordtype">int</span> idx;
<a name="l00297"></a>00297         <span class="keyword">struct </span><a class="code" href="structimp__at.html">imp_at</a> *at;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301         <span class="keywordflow">if</span> (AT_OFF) {
<a name="l00302"></a>00302                 <span class="comment">/* non-AT settings */</span>
<a name="l00310"></a>00310                 req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a> = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;imp_server_timeout ?
<a name="l00311"></a>00311                                   obd_timeout / 2 : obd_timeout;
<a name="l00312"></a>00312         } <span class="keywordflow">else</span> {
<a name="l00313"></a>00313                 at = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;imp_at;
<a name="l00314"></a>00314                 idx = import_at_get_index(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>,
<a name="l00315"></a>00315                                           req-&gt;rq_request_portal);
<a name="l00316"></a>00316                 serv_est = at_get(&amp;at-&gt;iat_service_estimate[idx]);
<a name="l00317"></a>00317                 req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a> = at_est2timeout(serv_est);
<a name="l00318"></a>00318         }
<a name="l00319"></a>00319         <span class="comment">/* We could get even fancier here, using history to predict increased</span>
<a name="l00320"></a>00320 <span class="comment">           loading... */</span>
<a name="l00321"></a>00321 
<a name="l00322"></a>00322         <span class="comment">/* Let the server know what this RPC timeout is by putting it in the</span>
<a name="l00323"></a>00323 <span class="comment">           reqmsg*/</span>
<a name="l00324"></a>00324         lustre_msg_set_timeout(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>);
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e.">ptlrpc_at_set_req_timeout</a>);
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="comment">/* Adjust max service estimate based on server value */</span>
<a name="l00329"></a>00329 <span class="keyword">static</span> <span class="keywordtype">void</span> ptlrpc_at_adj_service(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00330"></a>00330                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> serv_est)
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332         <span class="keywordtype">int</span> idx;
<a name="l00333"></a>00333         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldse;
<a name="l00334"></a>00334         <span class="keyword">struct </span><a class="code" href="structimp__at.html">imp_at</a> *at;
<a name="l00335"></a>00335 
<a name="l00336"></a>00336         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>);
<a name="l00337"></a>00337         at = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;imp_at;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339         idx = import_at_get_index(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>, req-&gt;rq_request_portal);
<a name="l00340"></a>00340         <span class="comment">/* max service estimates are tracked on the server side,</span>
<a name="l00341"></a>00341 <span class="comment">           so just keep minimal history here */</span>
<a name="l00342"></a>00342         oldse = at_measured(&amp;at-&gt;iat_service_estimate[idx], serv_est);
<a name="l00343"></a>00343         <span class="keywordflow">if</span> (oldse != 0)
<a name="l00344"></a>00344                 CDEBUG(<a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a>, <span class="stringliteral">&quot;The RPC service estimate for %s ptl %d &quot;</span>
<a name="l00345"></a>00345                        <span class="stringliteral">&quot;has changed from %d to %d\n&quot;</span>,
<a name="l00346"></a>00346                        req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,req-&gt;rq_request_portal,
<a name="l00347"></a>00347                        oldse, at_get(&amp;at-&gt;iat_service_estimate[idx]));
<a name="l00348"></a>00348 }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 <span class="comment">/* Expected network latency per remote node (secs) */</span>
<a name="l00351"></a>00351 <span class="keywordtype">int</span> ptlrpc_at_get_net_latency(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00352"></a>00352 {
<a name="l00353"></a>00353         <span class="keywordflow">return</span> AT_OFF ? 0 : at_get(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;imp_at.iat_net_latency);
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">/* Adjust expected network latency */</span>
<a name="l00357"></a>00357 <span class="keywordtype">void</span> ptlrpc_at_adj_net_latency(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00358"></a>00358                                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> service_time)
<a name="l00359"></a>00359 {
<a name="l00360"></a>00360         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nl, oldnl;
<a name="l00361"></a>00361         <span class="keyword">struct </span><a class="code" href="structimp__at.html">imp_at</a> *at;
<a name="l00362"></a>00362         time_t now = cfs_time_current_sec();
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>);
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         <span class="keywordflow">if</span> (service_time &gt; now - req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> + 3) {
<a name="l00367"></a>00367                 <span class="comment">/* bz16408, however, this can also happen if early reply</span>
<a name="l00368"></a>00368 <span class="comment">                 * is lost and client RPC is expired and resent, early reply</span>
<a name="l00369"></a>00369 <span class="comment">                 * or reply of original RPC can still be fit in reply buffer</span>
<a name="l00370"></a>00370 <span class="comment">                 * of resent RPC, now client is measuring time from the</span>
<a name="l00371"></a>00371 <span class="comment">                 * resent time, but server sent back service time of original</span>
<a name="l00372"></a>00372 <span class="comment">                 * RPC.</span>
<a name="l00373"></a>00373 <span class="comment">                 */</span>
<a name="l00374"></a>00374                 CDEBUG((lustre_msg_get_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; MSG_RESENT) ?
<a name="l00375"></a>00375                        <a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a> : D_WARNING,
<a name="l00376"></a>00376                        <span class="stringliteral">&quot;Reported service time %u &gt; total measured time &quot;</span>
<a name="l00377"></a>00377                        CFS_DURATION_T<span class="stringliteral">&quot;\n&quot;</span>, service_time,
<a name="l00378"></a>00378                        cfs_time_sub(now, req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a>));
<a name="l00379"></a>00379                 <span class="keywordflow">return</span>;
<a name="l00380"></a>00380         }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382         <span class="comment">/* Network latency is total time less server processing time */</span>
<a name="l00383"></a>00383         nl = max_t(<span class="keywordtype">int</span>, now - req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> -
<a name="l00384"></a>00384                         service_time, 0) + 1; <span class="comment">/* st rounding */</span>
<a name="l00385"></a>00385         at = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;imp_at;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387         oldnl = at_measured(&amp;at-&gt;iat_net_latency, nl);
<a name="l00388"></a>00388         <span class="keywordflow">if</span> (oldnl != 0)
<a name="l00389"></a>00389                 CDEBUG(<a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a>, <span class="stringliteral">&quot;The network latency for %s (nid %s) &quot;</span>
<a name="l00390"></a>00390                        <span class="stringliteral">&quot;has changed from %d to %d\n&quot;</span>,
<a name="l00391"></a>00391                        req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l00392"></a>00392                        obd_uuid2str(
<a name="l00393"></a>00393                                &amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>),
<a name="l00394"></a>00394                        oldnl, at_get(&amp;at-&gt;iat_net_latency));
<a name="l00395"></a>00395 }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 <span class="keyword">static</span> <span class="keywordtype">int</span> unpack_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00398"></a>00398 {
<a name="l00399"></a>00399         <span class="keywordtype">int</span> rc;
<a name="l00400"></a>00400 
<a name="l00401"></a>00401         <span class="keywordflow">if</span> (SPTLRPC_FLVR_POLICY(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) != SPTLRPC_POLICY_NULL) {
<a name="l00402"></a>00402                 rc = ptlrpc_unpack_rep_msg(req, req-&gt;<a class="code" href="structptlrpc__request.html#aaa9ba7e7b71ad2057d1650469ab15076" title="Reply length.">rq_replen</a>);
<a name="l00403"></a>00403                 <span class="keywordflow">if</span> (rc) {
<a name="l00404"></a>00404                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;unpack_rep failed: %d&quot;</span>, rc);
<a name="l00405"></a>00405                         <span class="keywordflow">return</span>(-EPROTO);
<a name="l00406"></a>00406                 }
<a name="l00407"></a>00407         }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409         rc = lustre_unpack_rep_ptlrpc_body(req, MSG_PTLRPC_BODY_OFF);
<a name="l00410"></a>00410         <span class="keywordflow">if</span> (rc) {
<a name="l00411"></a>00411                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;unpack ptlrpc body failed: %d&quot;</span>, rc);
<a name="l00412"></a>00412                 <span class="keywordflow">return</span>(-EPROTO);
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414         <span class="keywordflow">return</span> 0;
<a name="l00415"></a>00415 }
<a name="l00416"></a>00416 
<a name="l00421"></a>00421 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpc_at_recv_early_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00422"></a>00422 __must_hold(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>)
<a name="l00423"></a>00423 {
<a name="l00424"></a>00424         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *early_req;
<a name="l00425"></a>00425         time_t                 olddl;
<a name="l00426"></a>00426         <span class="keywordtype">int</span>                    rc;
<a name="l00427"></a>00427         ENTRY;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429         req-&gt;rq_early = 0;
<a name="l00430"></a>00430         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00431"></a>00431 
<a name="l00432"></a>00432         rc = <a class="code" href="group__sptlrpc.html#ga555969de6cd1c126c5a8887b740e1354" title="Used by ptlrpc client, to perform security transformation upon the early reply message...">sptlrpc_cli_unwrap_early_reply</a>(req, &amp;early_req);
<a name="l00433"></a>00433         <span class="keywordflow">if</span> (rc) {
<a name="l00434"></a>00434                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00435"></a>00435                 RETURN(rc);
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         rc = unpack_reply(early_req);
<a name="l00439"></a>00439         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00440"></a>00440                 <a class="code" href="group__sptlrpc.html#ga9e900c41f0c033d65d6a108d1a1a553c" title="Used by ptlrpc client, to release a processed early reply early_req.">sptlrpc_cli_finish_early_reply</a>(early_req);
<a name="l00441"></a>00441                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00442"></a>00442                 RETURN(rc);
<a name="l00443"></a>00443         }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445         <span class="comment">/* Use new timeout value just to adjust the local value for this</span>
<a name="l00446"></a>00446 <span class="comment">         * request, don&apos;t include it into at_history. It is unclear yet why</span>
<a name="l00447"></a>00447 <span class="comment">         * service time increased and should it be counted or skipped, e.g.</span>
<a name="l00448"></a>00448 <span class="comment">         * that can be recovery case or some error or server, the real reply</span>
<a name="l00449"></a>00449 <span class="comment">         * will add all new data if it is worth to add. */</span>
<a name="l00450"></a>00450         req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a> = lustre_msg_get_timeout(early_req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l00451"></a>00451         lustre_msg_set_timeout(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         <span class="comment">/* Network latency can be adjusted, it is pure network delays */</span>
<a name="l00454"></a>00454         ptlrpc_at_adj_net_latency(req,
<a name="l00455"></a>00455                         lustre_msg_get_service_time(early_req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>));
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         <a class="code" href="group__sptlrpc.html#ga9e900c41f0c033d65d6a108d1a1a553c" title="Used by ptlrpc client, to release a processed early reply early_req.">sptlrpc_cli_finish_early_reply</a>(early_req);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00460"></a>00460         olddl = req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>;
<a name="l00461"></a>00461         <span class="comment">/* server assumes it now has rq_timeout from when the request</span>
<a name="l00462"></a>00462 <span class="comment">         * arrived, so the client should give it at least that long.</span>
<a name="l00463"></a>00463 <span class="comment">         * since we don&apos;t know the arrival time we&apos;ll use the original</span>
<a name="l00464"></a>00464 <span class="comment">         * sent time */</span>
<a name="l00465"></a>00465         req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> = req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> + req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a> +
<a name="l00466"></a>00466                            ptlrpc_at_get_net_latency(req);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a>, req,
<a name="l00469"></a>00469                   <span class="stringliteral">&quot;Early reply #%d, new deadline in &quot;</span>CFS_DURATION_T<span class="stringliteral">&quot;s &quot;</span>
<a name="l00470"></a>00470                   <span class="stringliteral">&quot;(&quot;</span>CFS_DURATION_T<span class="stringliteral">&quot;s)&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#a4107706ff91738c79e18c271469afe8d" title="how many early replies (for stats)">rq_early_count</a>,
<a name="l00471"></a>00471                   cfs_time_sub(req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>, cfs_time_current_sec()),
<a name="l00472"></a>00472                   cfs_time_sub(req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>, olddl));
<a name="l00473"></a>00473 
<a name="l00474"></a>00474         RETURN(rc);
<a name="l00475"></a>00475 }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="keyword">static</span> <span class="keyword">struct </span>kmem_cache *request_cache;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="keywordtype">int</span> ptlrpc_request_cache_init(<span class="keywordtype">void</span>)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481         request_cache = kmem_cache_create(<span class="stringliteral">&quot;ptlrpc_cache&quot;</span>,
<a name="l00482"></a>00482                                           <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>),
<a name="l00483"></a>00483                                           0, SLAB_HWCACHE_ALIGN, NULL);
<a name="l00484"></a>00484         <span class="keywordflow">return</span> request_cache == NULL ? -ENOMEM : 0;
<a name="l00485"></a>00485 }
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="keywordtype">void</span> ptlrpc_request_cache_fini(<span class="keywordtype">void</span>)
<a name="l00488"></a>00488 {
<a name="l00489"></a>00489         kmem_cache_destroy(request_cache);
<a name="l00490"></a>00490 }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *ptlrpc_request_cache_alloc(gfp_t flags)
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496         OBD_SLAB_ALLOC_PTR_GFP(req, request_cache, flags);
<a name="l00497"></a>00497         <span class="keywordflow">return</span> req;
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="keywordtype">void</span> ptlrpc_request_cache_free(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00501"></a>00501 {
<a name="l00502"></a>00502         OBD_SLAB_FREE_PTR(req, request_cache);
<a name="l00503"></a>00503 }
<a name="l00504"></a>00504 
<a name="l00509"></a><a class="code" href="group__net.html#ga1b3e3fff15de45e0042c071e5bb806f4">00509</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga1b3e3fff15de45e0042c071e5bb806f4" title="Wind down request pool pool.">ptlrpc_free_rq_pool</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *pool)
<a name="l00510"></a>00510 {
<a name="l00511"></a>00511         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *l, *tmp;
<a name="l00512"></a>00512         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         LASSERT(pool != NULL);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516         spin_lock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00517"></a>00517         list_for_each_safe(l, tmp, &amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66" title="list of ptlrpc_request structs">prp_req_list</a>) {
<a name="l00518"></a>00518                 req = list_entry(l, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, <a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l00519"></a>00519                 list_del(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l00520"></a>00520                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>);
<a name="l00521"></a>00521                 LASSERT(req-&gt;rq_reqbuf_len == pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a>);
<a name="l00522"></a>00522                 OBD_FREE_LARGE(req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>, pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a>);
<a name="l00523"></a>00523                 ptlrpc_request_cache_free(req);
<a name="l00524"></a>00524         }
<a name="l00525"></a>00525         spin_unlock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00526"></a>00526         OBD_FREE(pool, <span class="keyword">sizeof</span>(*pool));
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga1b3e3fff15de45e0042c071e5bb806f4" title="Wind down request pool pool.">ptlrpc_free_rq_pool</a>);
<a name="l00529"></a>00529 
<a name="l00533"></a><a class="code" href="group__net.html#ga07d19311543ebd57e6514926b08ddd08">00533</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga07d19311543ebd57e6514926b08ddd08" title="Allocates, initializes and adds num_rq requests to the pool pool.">ptlrpc_add_rqs_to_pool</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *pool, <span class="keywordtype">int</span> num_rq)
<a name="l00534"></a>00534 {
<a name="l00535"></a>00535         <span class="keywordtype">int</span> i;
<a name="l00536"></a>00536         <span class="keywordtype">int</span> size = 1;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538         <span class="keywordflow">while</span> (size &lt; pool-&gt;prp_rq_size)
<a name="l00539"></a>00539                 size &lt;&lt;= 1;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         LASSERTF(list_empty(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66" title="list of ptlrpc_request structs">prp_req_list</a>) ||
<a name="l00542"></a>00542                  size == pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a>,
<a name="l00543"></a>00543                  <span class="stringliteral">&quot;Trying to change pool size with nonempty pool &quot;</span>
<a name="l00544"></a>00544                  <span class="stringliteral">&quot;from %d to %d bytes\n&quot;</span>, pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a>, size);
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         spin_lock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00547"></a>00547         pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a> = size;
<a name="l00548"></a>00548         <span class="keywordflow">for</span> (i = 0; i &lt; num_rq; i++) {
<a name="l00549"></a>00549                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l00550"></a>00550                 <span class="keyword">struct </span>lustre_msg *msg;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552                 spin_unlock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00553"></a>00553                 req = ptlrpc_request_cache_alloc(GFP_NOFS);
<a name="l00554"></a>00554                 <span class="keywordflow">if</span> (!req)
<a name="l00555"></a>00555                         <span class="keywordflow">return</span> i;
<a name="l00556"></a>00556                 OBD_ALLOC_LARGE(msg, size);
<a name="l00557"></a>00557                 <span class="keywordflow">if</span> (!msg) {
<a name="l00558"></a>00558                         ptlrpc_request_cache_free(req);
<a name="l00559"></a>00559                         <span class="keywordflow">return</span> i;
<a name="l00560"></a>00560                 }
<a name="l00561"></a>00561                 req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> = msg;
<a name="l00562"></a>00562                 req-&gt;rq_reqbuf_len = size;
<a name="l00563"></a>00563                 req-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a> = pool;
<a name="l00564"></a>00564                 spin_lock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00565"></a>00565                 list_add_tail(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>, &amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66" title="list of ptlrpc_request structs">prp_req_list</a>);
<a name="l00566"></a>00566         }
<a name="l00567"></a>00567         spin_unlock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00568"></a>00568         <span class="keywordflow">return</span> num_rq;
<a name="l00569"></a>00569 }
<a name="l00570"></a>00570 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga07d19311543ebd57e6514926b08ddd08" title="Allocates, initializes and adds num_rq requests to the pool pool.">ptlrpc_add_rqs_to_pool</a>);
<a name="l00571"></a>00571 
<a name="l00580"></a>00580 <span class="keyword">struct </span><a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *
<a name="l00581"></a><a class="code" href="group__net.html#ga297dfeefaa23e0c6265ca8c0ad81e818">00581</a> <a class="code" href="group__net.html#ga297dfeefaa23e0c6265ca8c0ad81e818" title="Create and initialize new request pool with given attributes: num_rq - initial number...">ptlrpc_init_rq_pool</a>(<span class="keywordtype">int</span> num_rq, <span class="keywordtype">int</span> msgsize,
<a name="l00582"></a>00582                     <span class="keywordtype">int</span> (*populate_pool)(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *, <span class="keywordtype">int</span>))
<a name="l00583"></a>00583 {
<a name="l00584"></a>00584         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *pool;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586         OBD_ALLOC(pool, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a>));
<a name="l00587"></a>00587         <span class="keywordflow">if</span> (!pool)
<a name="l00588"></a>00588                 <span class="keywordflow">return</span> NULL;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590         <span class="comment">/* Request next power of two for the allocation, because internally</span>
<a name="l00591"></a>00591 <span class="comment">           kernel would do exactly this */</span>
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         spin_lock_init(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00594"></a>00594         INIT_LIST_HEAD(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66" title="list of ptlrpc_request structs">prp_req_list</a>);
<a name="l00595"></a>00595         pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a> = msgsize + SPTLRPC_MAX_PAYLOAD;
<a name="l00596"></a>00596         pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a666162961622baf799216fcae4f4dede" title="Function to allocate more requests for this pool.">prp_populate</a> = populate_pool;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598         populate_pool(pool, num_rq);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600         <span class="keywordflow">return</span> pool;
<a name="l00601"></a>00601 }
<a name="l00602"></a>00602 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga297dfeefaa23e0c6265ca8c0ad81e818" title="Create and initialize new request pool with given attributes: num_rq - initial number...">ptlrpc_init_rq_pool</a>);
<a name="l00603"></a>00603 
<a name="l00607"></a>00607 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *
<a name="l00608"></a>00608 ptlrpc_prep_req_from_pool(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *pool)
<a name="l00609"></a>00609 {
<a name="l00610"></a>00610         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request;
<a name="l00611"></a>00611         <span class="keyword">struct </span>lustre_msg *reqbuf;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613         <span class="keywordflow">if</span> (!pool)
<a name="l00614"></a>00614                 <span class="keywordflow">return</span> NULL;
<a name="l00615"></a>00615 
<a name="l00616"></a>00616         spin_lock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00617"></a>00617 
<a name="l00618"></a>00618         <span class="comment">/* See if we have anything in a pool, and bail out if nothing,</span>
<a name="l00619"></a>00619 <span class="comment">         * in writeout path, where this matters, this is safe to do, because</span>
<a name="l00620"></a>00620 <span class="comment">         * nothing is lost in this case, and when some in-flight requests</span>
<a name="l00621"></a>00621 <span class="comment">         * complete, this code will be called again. */</span>
<a name="l00622"></a>00622         <span class="keywordflow">if</span> (unlikely(list_empty(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66" title="list of ptlrpc_request structs">prp_req_list</a>))) {
<a name="l00623"></a>00623                 spin_unlock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00624"></a>00624                 <span class="keywordflow">return</span> NULL;
<a name="l00625"></a>00625         }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627         request = list_entry(pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66" title="list of ptlrpc_request structs">prp_req_list</a>.next, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00628"></a>00628                              rq_list);
<a name="l00629"></a>00629         list_del_init(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l00630"></a>00630         spin_unlock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632         LASSERT(request-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>);
<a name="l00633"></a>00633         LASSERT(request-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a>);
<a name="l00634"></a>00634 
<a name="l00635"></a>00635         reqbuf = request-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>;
<a name="l00636"></a>00636         memset(request, 0, <span class="keyword">sizeof</span>(*request));
<a name="l00637"></a>00637         request-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> = reqbuf;
<a name="l00638"></a>00638         request-&gt;rq_reqbuf_len = pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a2c2ad0ee0698081b16bf1787e8c1a521" title="Maximum message size that would fit into a rquest from this pool.">prp_rq_size</a>;
<a name="l00639"></a>00639         request-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a> = pool;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641         <span class="keywordflow">return</span> request;
<a name="l00642"></a>00642 }
<a name="l00643"></a>00643 
<a name="l00647"></a>00647 <span class="keyword">static</span> <span class="keywordtype">void</span> __ptlrpc_free_req_to_pool(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request)
<a name="l00648"></a>00648 {
<a name="l00649"></a>00649         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *pool = request-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a>;
<a name="l00650"></a>00650 
<a name="l00651"></a>00651         spin_lock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00652"></a>00652         LASSERT(list_empty(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>));
<a name="l00653"></a>00653         LASSERT(!request-&gt;rq_receiving_reply);
<a name="l00654"></a>00654         list_add_tail(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>, &amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#a4081b8011f70d0684ef1432f28a8fb66" title="list of ptlrpc_request structs">prp_req_list</a>);
<a name="l00655"></a>00655         spin_unlock(&amp;pool-&gt;<a class="code" href="structptlrpc__request__pool.html#ac539e137d9710f61580ba5770b3b40bd" title="Locks the list.">prp_lock</a>);
<a name="l00656"></a>00656 }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 <span class="keywordtype">void</span> ptlrpc_add_unreplied(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a>       *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l00661"></a>00661         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *tmp;
<a name="l00662"></a>00662         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *iter;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         assert_spin_locked(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00665"></a>00665         LASSERT(list_empty(&amp;req-&gt;rq_unreplied_list));
<a name="l00666"></a>00666 
<a name="l00667"></a>00667         <span class="comment">/* unreplied list is sorted by xid in ascending order */</span>
<a name="l00668"></a>00668         list_for_each_prev(tmp, &amp;imp-&gt;<a class="code" href="structobd__import.html#a0ff3d0b8eb357f7d3904ec7732fbd416" title="List of not replied requests.">imp_unreplied_list</a>) {
<a name="l00669"></a>00669                 iter = list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00670"></a>00670                                   rq_unreplied_list);
<a name="l00671"></a>00671 
<a name="l00672"></a>00672                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> != iter-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l00673"></a>00673                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> &lt; iter-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>)
<a name="l00674"></a>00674                         <span class="keywordflow">continue</span>;
<a name="l00675"></a>00675                 list_add(&amp;req-&gt;rq_unreplied_list, &amp;iter-&gt;rq_unreplied_list);
<a name="l00676"></a>00676                 <span class="keywordflow">return</span>;
<a name="l00677"></a>00677         }
<a name="l00678"></a>00678         list_add(&amp;req-&gt;rq_unreplied_list, &amp;imp-&gt;<a class="code" href="structobd__import.html#a0ff3d0b8eb357f7d3904ec7732fbd416" title="List of not replied requests.">imp_unreplied_list</a>);
<a name="l00679"></a>00679 }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 <span class="keywordtype">void</span> ptlrpc_assign_next_xid_nolock(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00682"></a>00682 {
<a name="l00683"></a>00683         req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> = <a class="code" href="group__net.html#gaf2442fe17f822101d45881701da27f40" title="Increase xid and returns resulting new value to the caller.">ptlrpc_next_xid</a>();
<a name="l00684"></a>00684         ptlrpc_add_unreplied(req);
<a name="l00685"></a>00685 }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ptlrpc_assign_next_xid(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00688"></a>00688 {
<a name="l00689"></a>00689         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00690"></a>00690         ptlrpc_assign_next_xid_nolock(req);
<a name="l00691"></a>00691         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="keywordtype">int</span> ptlrpc_request_bufs_pack(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request,
<a name="l00695"></a>00695                              __u32 version, <span class="keywordtype">int</span> opcode, <span class="keywordtype">char</span> **bufs,
<a name="l00696"></a>00696                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00697"></a>00697 {
<a name="l00698"></a>00698         <span class="keywordtype">int</span> count;
<a name="l00699"></a>00699         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp;
<a name="l00700"></a>00700         __u32 *lengths;
<a name="l00701"></a>00701         <span class="keywordtype">int</span> rc;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         ENTRY;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705         count = <a class="code" href="group__req__layout.html#gab0f7a8e2a51867454ce8f87bb48b0f77" title="Fills in any parts of the rc_area of a pill that haven&amp;#39;t been filled in yet.">req_capsule_filled_sizes</a>(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, RCL_CLIENT);
<a name="l00706"></a>00706         imp = request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l00707"></a>00707         lengths = request-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>.rc_area[RCL_CLIENT];
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         <span class="keywordflow">if</span> (ctx != NULL) {
<a name="l00710"></a>00710                 request-&gt;rq_cli_ctx = sptlrpc_cli_ctx_get(ctx);
<a name="l00711"></a>00711         } <span class="keywordflow">else</span> {
<a name="l00712"></a>00712                 rc = <a class="code" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it.">sptlrpc_req_get_ctx</a>(request);
<a name="l00713"></a>00713                 <span class="keywordflow">if</span> (rc)
<a name="l00714"></a>00714                         GOTO(out_free, rc);
<a name="l00715"></a>00715         }
<a name="l00716"></a>00716         <a class="code" href="group__sptlrpc.html#ga701bf20eebf0fd9d03c94918418f3b31" title="Initialize flavor settings for req, according to opcode.">sptlrpc_req_set_flavor</a>(request, opcode);
<a name="l00717"></a>00717 
<a name="l00718"></a>00718         rc = lustre_pack_request(request, imp-&gt;imp_msg_magic, count,
<a name="l00719"></a>00719                                  lengths, bufs);
<a name="l00720"></a>00720         <span class="keywordflow">if</span> (rc)
<a name="l00721"></a>00721                 GOTO(out_ctx, rc);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723         lustre_msg_add_version(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, version);
<a name="l00724"></a>00724         request-&gt;rq_send_state = LUSTRE_IMP_FULL;
<a name="l00725"></a>00725         request-&gt;rq_type = PTL_RPC_MSG_REQUEST;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         request-&gt;rq_req_cbid.cbid_fn  = <a class="code" href="group__net.html#ga888caf60135e2eecdef05fce1b2de9b6" title="These callbacks are invoked by LNet when something happened to underlying buffer...">request_out_callback</a>;
<a name="l00728"></a>00728         request-&gt;rq_req_cbid.cbid_arg = request;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         request-&gt;rq_reply_cbid.cbid_fn  = reply_in_callback;
<a name="l00731"></a>00731         request-&gt;rq_reply_cbid.cbid_arg = request;
<a name="l00732"></a>00732 
<a name="l00733"></a>00733         request-&gt;rq_reply_deadline = 0;
<a name="l00734"></a>00734         request-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> = RQ_PHASE_NEW;
<a name="l00735"></a>00735         request-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a> = RQ_PHASE_UNDEFINED;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737         request-&gt;rq_request_portal = imp-&gt;<a class="code" href="structobd__import.html#af77cd16d5a2cce0fc30b9950937ee940" title="PortalRPC client structure for this import.">imp_client</a>-&gt;<a class="code" href="structptlrpc__client.html#abbeeccfdcf5796b6ee39005f23d2b8c5" title="What lnet portal does this client send messages to by default.">cli_request_portal</a>;
<a name="l00738"></a>00738         request-&gt;rq_reply_portal = imp-&gt;<a class="code" href="structobd__import.html#af77cd16d5a2cce0fc30b9950937ee940" title="PortalRPC client structure for this import.">imp_client</a>-&gt;<a class="code" href="structptlrpc__client.html#a00cb08501a8d056a8620effccaabef95" title="What portal do we expect replies on.">cli_reply_portal</a>;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740         <a class="code" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e.">ptlrpc_at_set_req_timeout</a>(request);
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         lustre_msg_set_opc(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, opcode);
<a name="l00743"></a>00743         ptlrpc_assign_next_xid(request);
<a name="l00744"></a>00744 
<a name="l00745"></a>00745         RETURN(0);
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 out_ctx:
<a name="l00748"></a>00748         LASSERT(!request-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a>);
<a name="l00749"></a>00749         sptlrpc_cli_ctx_put(request-&gt;rq_cli_ctx, 1);
<a name="l00750"></a>00750 out_free:
<a name="l00751"></a>00751         class_import_put(imp);
<a name="l00752"></a>00752 
<a name="l00753"></a>00753         <span class="keywordflow">return</span> rc;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 }
<a name="l00756"></a>00756 EXPORT_SYMBOL(ptlrpc_request_bufs_pack);
<a name="l00757"></a>00757 
<a name="l00762"></a><a class="code" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de">00762</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps...">ptlrpc_request_pack</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request,
<a name="l00763"></a>00763                         __u32 version, <span class="keywordtype">int</span> opcode)
<a name="l00764"></a>00764 {
<a name="l00765"></a>00765         <span class="keywordtype">int</span> rc;
<a name="l00766"></a>00766         rc = ptlrpc_request_bufs_pack(request, version, opcode, NULL, NULL);
<a name="l00767"></a>00767         <span class="keywordflow">if</span> (rc)
<a name="l00768"></a>00768                 <span class="keywordflow">return</span> rc;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770         <span class="comment">/* For some old 1.8 clients (&lt; 1.8.7), they will LASSERT the size of</span>
<a name="l00771"></a>00771 <span class="comment">         * ptlrpc_body sent from server equal to local ptlrpc_body size, so we</span>
<a name="l00772"></a>00772 <span class="comment">         * have to send old ptlrpc_body to keep interoprability with these</span>
<a name="l00773"></a>00773 <span class="comment">         * clients.</span>
<a name="l00774"></a>00774 <span class="comment">         *</span>
<a name="l00775"></a>00775 <span class="comment">         * Only three kinds of server-&gt;client RPCs so far:</span>
<a name="l00776"></a>00776 <span class="comment">         *  - LDLM_BL_CALLBACK</span>
<a name="l00777"></a>00777 <span class="comment">         *  - LDLM_CP_CALLBACK</span>
<a name="l00778"></a>00778 <span class="comment">         *  - LDLM_GL_CALLBACK</span>
<a name="l00779"></a>00779 <span class="comment">         *</span>
<a name="l00780"></a>00780 <span class="comment">         * XXX This should be removed whenever we drop the interoprability with</span>
<a name="l00781"></a>00781 <span class="comment">         *     the these old clients.</span>
<a name="l00782"></a>00782 <span class="comment">         */</span>
<a name="l00783"></a>00783         <span class="keywordflow">if</span> (opcode == LDLM_BL_CALLBACK || opcode == LDLM_CP_CALLBACK ||
<a name="l00784"></a>00784             opcode == LDLM_GL_CALLBACK)
<a name="l00785"></a>00785                 <a class="code" href="group__req__layout.html#gaf42efe506903884592711902e9276e99" title="This function shrinks the size of the _buffer_ of the pill&amp;#39;s PTLRPC request or...">req_capsule_shrink</a>(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_PTLRPC_BODY,
<a name="l00786"></a>00786                                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__body__v2.html">ptlrpc_body_v2</a>), RCL_CLIENT);
<a name="l00787"></a>00787 
<a name="l00788"></a>00788         <span class="keywordflow">return</span> rc;
<a name="l00789"></a>00789 }
<a name="l00790"></a>00790 EXPORT_SYMBOL(<a class="code" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps...">ptlrpc_request_pack</a>);
<a name="l00791"></a>00791 
<a name="l00798"></a>00798 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00799"></a>00799 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *__ptlrpc_request_alloc(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00800"></a>00800                                               <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> *pool)
<a name="l00801"></a>00801 {
<a name="l00802"></a>00802         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request = NULL;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         request = ptlrpc_request_cache_alloc(GFP_NOFS);
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         <span class="keywordflow">if</span> (!request &amp;&amp; pool)
<a name="l00807"></a>00807                 request = ptlrpc_prep_req_from_pool(pool);
<a name="l00808"></a>00808 
<a name="l00809"></a>00809         <span class="keywordflow">if</span> (request) {
<a name="l00810"></a>00810                 ptlrpc_cli_req_init(request);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812                 LASSERTF((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)imp &gt; 0x1000, <span class="stringliteral">&quot;%p&quot;</span>, imp);
<a name="l00813"></a>00813                 LASSERT(imp != LP_POISON);
<a name="l00814"></a>00814                 LASSERTF((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)imp-&gt;<a class="code" href="structobd__import.html#af77cd16d5a2cce0fc30b9950937ee940" title="PortalRPC client structure for this import.">imp_client</a> &gt; 0x1000, <span class="stringliteral">&quot;%p\n&quot;</span>,
<a name="l00815"></a>00815                         imp-&gt;<a class="code" href="structobd__import.html#af77cd16d5a2cce0fc30b9950937ee940" title="PortalRPC client structure for this import.">imp_client</a>);
<a name="l00816"></a>00816                 LASSERT(imp-&gt;<a class="code" href="structobd__import.html#af77cd16d5a2cce0fc30b9950937ee940" title="PortalRPC client structure for this import.">imp_client</a> != LP_POISON);
<a name="l00817"></a>00817 
<a name="l00818"></a>00818                 request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a> = class_import_get(imp);
<a name="l00819"></a>00819         } <span class="keywordflow">else</span> {
<a name="l00820"></a>00820                 CERROR(<span class="stringliteral">&quot;request allocation out of memory\n&quot;</span>);
<a name="l00821"></a>00821         }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823         <span class="keywordflow">return</span> request;
<a name="l00824"></a>00824 }
<a name="l00825"></a>00825 
<a name="l00832"></a>00832 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *
<a name="l00833"></a>00833 ptlrpc_request_alloc_internal(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00834"></a>00834                               <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> * pool,
<a name="l00835"></a>00835                               <span class="keyword">const</span> <span class="keyword">struct</span> req_format *format)
<a name="l00836"></a>00836 {
<a name="l00837"></a>00837         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request;
<a name="l00838"></a>00838 
<a name="l00839"></a>00839         request = __ptlrpc_request_alloc(imp, pool);
<a name="l00840"></a>00840         <span class="keywordflow">if</span> (request == NULL)
<a name="l00841"></a>00841                 <span class="keywordflow">return</span> NULL;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843         <a class="code" href="group__req__layout.html#ga3360e9bd9a1f426afa811cb688d78080" title="Initialize a pill.">req_capsule_init</a>(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, request, RCL_CLIENT);
<a name="l00844"></a>00844         <a class="code" href="group__req__layout.html#gacf7641ae043180a084fac16a18c8fb29" title="Set the format (fmt) of a pill; format changes are not allowed here (see req_capsule_extend())...">req_capsule_set</a>(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, format);
<a name="l00845"></a>00845         <span class="keywordflow">return</span> request;
<a name="l00846"></a>00846 }
<a name="l00847"></a>00847 
<a name="l00852"></a><a class="code" href="group__net.html#ga2bf080a905f488f676248838514e264a">00852</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *<a class="code" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure...">ptlrpc_request_alloc</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00853"></a>00853                                             <span class="keyword">const</span> <span class="keyword">struct</span> req_format *format)
<a name="l00854"></a>00854 {
<a name="l00855"></a>00855         <span class="keywordflow">return</span> ptlrpc_request_alloc_internal(imp, NULL, format);
<a name="l00856"></a>00856 }
<a name="l00857"></a>00857 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure...">ptlrpc_request_alloc</a>);
<a name="l00858"></a>00858 
<a name="l00863"></a><a class="code" href="group__net.html#ga0aa209ecf9cb734df89fec89a61d00a1">00863</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *<a class="code" href="group__net.html#ga0aa209ecf9cb734df89fec89a61d00a1" title="Allocate new request structure for import imp from pool pool and initialize its buffer...">ptlrpc_request_alloc_pool</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00864"></a>00864                                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__pool.html" title="Definition of request pool structure.">ptlrpc_request_pool</a> * pool,
<a name="l00865"></a>00865                                             <span class="keyword">const</span> <span class="keyword">struct</span> req_format *format)
<a name="l00866"></a>00866 {
<a name="l00867"></a>00867         <span class="keywordflow">return</span> ptlrpc_request_alloc_internal(imp, pool, format);
<a name="l00868"></a>00868 }
<a name="l00869"></a>00869 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga0aa209ecf9cb734df89fec89a61d00a1" title="Allocate new request structure for import imp from pool pool and initialize its buffer...">ptlrpc_request_alloc_pool</a>);
<a name="l00870"></a>00870 
<a name="l00875"></a><a class="code" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f">00875</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure.">ptlrpc_request_free</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request)
<a name="l00876"></a>00876 {
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a>)
<a name="l00878"></a>00878                 __ptlrpc_free_req_to_pool(request);
<a name="l00879"></a>00879         <span class="keywordflow">else</span>
<a name="l00880"></a>00880                 ptlrpc_request_cache_free(request);
<a name="l00881"></a>00881 }
<a name="l00882"></a>00882 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure.">ptlrpc_request_free</a>);
<a name="l00883"></a>00883 
<a name="l00891"></a><a class="code" href="group__net.html#gac578ffdc47c9c2141c34c4798a55cce4">00891</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *<a class="code" href="group__net.html#gac578ffdc47c9c2141c34c4798a55cce4" title="Allocate new request for operatione opcode and immediatelly pack it for network transfer...">ptlrpc_request_alloc_pack</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00892"></a>00892                                                 <span class="keyword">const</span> <span class="keyword">struct</span> req_format *format,
<a name="l00893"></a>00893                                                 __u32 version, <span class="keywordtype">int</span> opcode)
<a name="l00894"></a>00894 {
<a name="l00895"></a>00895         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = <a class="code" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure...">ptlrpc_request_alloc</a>(imp, format);
<a name="l00896"></a>00896         <span class="keywordtype">int</span>                    rc;
<a name="l00897"></a>00897 
<a name="l00898"></a>00898         <span class="keywordflow">if</span> (req) {
<a name="l00899"></a>00899                 rc = <a class="code" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps...">ptlrpc_request_pack</a>(req, version, opcode);
<a name="l00900"></a>00900                 <span class="keywordflow">if</span> (rc) {
<a name="l00901"></a>00901                         <a class="code" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure.">ptlrpc_request_free</a>(req);
<a name="l00902"></a>00902                         req = NULL;
<a name="l00903"></a>00903                 }
<a name="l00904"></a>00904         }
<a name="l00905"></a>00905         <span class="keywordflow">return</span> req;
<a name="l00906"></a>00906 }
<a name="l00907"></a>00907 EXPORT_SYMBOL(<a class="code" href="group__net.html#gac578ffdc47c9c2141c34c4798a55cce4" title="Allocate new request for operatione opcode and immediatelly pack it for network transfer...">ptlrpc_request_alloc_pack</a>);
<a name="l00908"></a>00908 
<a name="l00913"></a><a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4">00913</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT.">ptlrpc_prep_set</a>(<span class="keywordtype">void</span>)
<a name="l00914"></a>00914 {
<a name="l00915"></a>00915         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a>       *<span class="keyword">set</span>;
<a name="l00916"></a>00916         <span class="keywordtype">int</span>                             cpt;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918         ENTRY;
<a name="l00919"></a>00919         cpt = cfs_cpt_current(<a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>, 0);
<a name="l00920"></a>00920         OBD_CPT_ALLOC(<span class="keyword">set</span>, <a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>, cpt, <span class="keyword">sizeof</span> *<span class="keyword">set</span>);
<a name="l00921"></a>00921         <span class="keywordflow">if</span> (!<span class="keyword">set</span>)
<a name="l00922"></a>00922                 RETURN(NULL);
<a name="l00923"></a>00923         atomic_set(&amp;set-&gt;set_refcount, 1);
<a name="l00924"></a>00924         INIT_LIST_HEAD(&amp;set-&gt;set_requests);
<a name="l00925"></a>00925         init_waitqueue_head(&amp;set-&gt;set_waitq);
<a name="l00926"></a>00926         atomic_set(&amp;set-&gt;set_new_count, 0);
<a name="l00927"></a>00927         atomic_set(&amp;set-&gt;set_remaining, 0);
<a name="l00928"></a>00928         spin_lock_init(&amp;set-&gt;set_new_req_lock);
<a name="l00929"></a>00929         INIT_LIST_HEAD(&amp;set-&gt;set_new_requests);
<a name="l00930"></a>00930         INIT_LIST_HEAD(&amp;set-&gt;set_cblist);
<a name="l00931"></a>00931         <span class="keyword">set</span>-&gt;set_max_inflight = UINT_MAX;
<a name="l00932"></a>00932         <span class="keyword">set</span>-&gt;set_producer     = NULL;
<a name="l00933"></a>00933         <span class="keyword">set</span>-&gt;set_producer_arg = NULL;
<a name="l00934"></a>00934         <span class="keyword">set</span>-&gt;set_rc           = 0;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936         RETURN(<span class="keyword">set</span>);
<a name="l00937"></a>00937 }
<a name="l00938"></a>00938 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT.">ptlrpc_prep_set</a>);
<a name="l00939"></a>00939 
<a name="l00948"></a><a class="code" href="group__net.html#ga2d9ff5fa185af154f37c364df7b5c4cc">00948</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<a class="code" href="group__net.html#ga2d9ff5fa185af154f37c364df7b5c4cc" title="Allocate and initialize new request set structure with flow control extension.">ptlrpc_prep_fcset</a>(<span class="keywordtype">int</span> max, set_producer_func func,
<a name="l00949"></a>00949                                              <span class="keywordtype">void</span> *arg)
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 {
<a name="l00952"></a>00952         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         <span class="keyword">set</span> = <a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT.">ptlrpc_prep_set</a>();
<a name="l00955"></a>00955         <span class="keywordflow">if</span> (!<span class="keyword">set</span>)
<a name="l00956"></a>00956                 RETURN(NULL);
<a name="l00957"></a>00957 
<a name="l00958"></a>00958         <span class="keyword">set</span>-&gt;set_max_inflight  = max;
<a name="l00959"></a>00959         <span class="keyword">set</span>-&gt;set_producer      = func;
<a name="l00960"></a>00960         <span class="keyword">set</span>-&gt;set_producer_arg  = arg;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962         RETURN(<span class="keyword">set</span>);
<a name="l00963"></a>00963 }
<a name="l00964"></a>00964 
<a name="l00973"></a><a class="code" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8">00973</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set...">ptlrpc_set_destroy</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>)
<a name="l00974"></a>00974 {
<a name="l00975"></a>00975         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *tmp;
<a name="l00976"></a>00976         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *next;
<a name="l00977"></a>00977         <span class="keywordtype">int</span>                      expected_phase;
<a name="l00978"></a>00978         <span class="keywordtype">int</span>                      n = 0;
<a name="l00979"></a>00979         ENTRY;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981         <span class="comment">/* Requests on the set should either all be completed, or all be new */</span>
<a name="l00982"></a>00982         expected_phase = (atomic_read(&amp;set-&gt;set_remaining) == 0) ?
<a name="l00983"></a>00983                          RQ_PHASE_COMPLETE : RQ_PHASE_NEW;
<a name="l00984"></a>00984         list_for_each(tmp, &amp;set-&gt;set_requests) {
<a name="l00985"></a>00985                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l00986"></a>00986                         list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00987"></a>00987                                    rq_set_chain);
<a name="l00988"></a>00988 
<a name="l00989"></a>00989                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == expected_phase);
<a name="l00990"></a>00990                 n++;
<a name="l00991"></a>00991         }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993         LASSERTF(atomic_read(&amp;set-&gt;set_remaining) == 0 ||
<a name="l00994"></a>00994                  atomic_read(&amp;set-&gt;set_remaining) == n, <span class="stringliteral">&quot;%d / %d\n&quot;</span>,
<a name="l00995"></a>00995                  atomic_read(&amp;set-&gt;set_remaining), n);
<a name="l00996"></a>00996 
<a name="l00997"></a>00997         list_for_each_safe(tmp, next, &amp;set-&gt;set_requests) {
<a name="l00998"></a>00998                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l00999"></a>00999                         list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l01000"></a>01000                                    rq_set_chain);
<a name="l01001"></a>01001                 list_del_init(&amp;req-&gt;rq_set_chain);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == expected_phase);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW) {
<a name="l01006"></a>01006                         ptlrpc_req_interpret(NULL, req, -EBADR);
<a name="l01007"></a>01007                         atomic_dec(&amp;set-&gt;set_remaining);
<a name="l01008"></a>01008                 }
<a name="l01009"></a>01009 
<a name="l01010"></a>01010                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01011"></a>01011                 req-&gt;rq_set = NULL;
<a name="l01012"></a>01012                 req-&gt;<a class="code" href="structptlrpc__request.html#a3c7a9c4f0292826fffa36e3ab1cedf47" title="whether the &amp;quot;rq_set&amp;quot; is a valid one">rq_invalid_rqset</a> = 0;
<a name="l01013"></a>01013                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01014"></a>01014 
<a name="l01015"></a>01015                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a> (req);
<a name="l01016"></a>01016         }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018         LASSERT(atomic_read(&amp;set-&gt;set_remaining) == 0);
<a name="l01019"></a>01019 
<a name="l01020"></a>01020         ptlrpc_reqset_put(<span class="keyword">set</span>);
<a name="l01021"></a>01021         EXIT;
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set...">ptlrpc_set_destroy</a>);
<a name="l01024"></a>01024 
<a name="l01030"></a><a class="code" href="group__net.html#gad92b893a7fb440c2f0eed3ce0e79f6af">01030</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#gad92b893a7fb440c2f0eed3ce0e79f6af" title="Add a callback function fn to the set.">ptlrpc_set_add_cb</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>,
<a name="l01031"></a>01031                       set_interpreter_func fn, <span class="keywordtype">void</span> *data)
<a name="l01032"></a>01032 {
<a name="l01033"></a>01033         <span class="keyword">struct </span><a class="code" href="structptlrpc__set__cbdata.html" title="Description of a single ptrlrpc_set callback.">ptlrpc_set_cbdata</a> *cbdata;
<a name="l01034"></a>01034 
<a name="l01035"></a>01035         OBD_ALLOC_PTR(cbdata);
<a name="l01036"></a>01036         <span class="keywordflow">if</span> (cbdata == NULL)
<a name="l01037"></a>01037                 RETURN(-ENOMEM);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039         cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#a7122f5f29318e70ed85129a2195bc247" title="Pointer to interpreting function.">psc_interpret</a> = fn;
<a name="l01040"></a>01040         cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#acf9721671bfcc548e1e5fe4276ba9b5c" title="Opaq argument to pass to the callback.">psc_data</a> = data;
<a name="l01041"></a>01041         list_add_tail(&amp;cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#a72f1ec9f7c8e7a2f8ea2e123bf4c0444" title="List linkage item.">psc_item</a>, &amp;set-&gt;set_cblist);
<a name="l01042"></a>01042 
<a name="l01043"></a>01043         RETURN(0);
<a name="l01044"></a>01044 }
<a name="l01045"></a>01045 
<a name="l01050"></a><a class="code" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8">01050</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set.">ptlrpc_set_add_req</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>,
<a name="l01051"></a>01051                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01052"></a>01052 {
<a name="l01053"></a>01053         LASSERT(list_empty(&amp;req-&gt;rq_set_chain));
<a name="l01054"></a>01054 
<a name="l01055"></a>01055         <span class="keywordflow">if</span> (req-&gt;rq_allow_intr)
<a name="l01056"></a>01056                 <span class="keyword">set</span>-&gt;set_allow_intr = 1;
<a name="l01057"></a>01057 
<a name="l01058"></a>01058         <span class="comment">/* The set takes over the caller&apos;s request reference */</span>
<a name="l01059"></a>01059         list_add_tail(&amp;req-&gt;rq_set_chain, &amp;set-&gt;set_requests);
<a name="l01060"></a>01060         req-&gt;rq_set = <span class="keyword">set</span>;
<a name="l01061"></a>01061         atomic_inc(&amp;set-&gt;set_remaining);
<a name="l01062"></a>01062         req-&gt;rq_queued_time = cfs_time_current();
<a name="l01063"></a>01063 
<a name="l01064"></a>01064         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> != NULL)
<a name="l01065"></a>01065                 lustre_msg_set_jobid(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, NULL);
<a name="l01066"></a>01066 
<a name="l01067"></a>01067         <span class="keywordflow">if</span> (set-&gt;set_producer != NULL)
<a name="l01068"></a>01068                 <span class="comment">/* If the request set has a producer callback, the RPC must be</span>
<a name="l01069"></a>01069 <span class="comment">                 * sent straight away */</span>
<a name="l01070"></a>01070                 ptlrpc_send_new_req(req);
<a name="l01071"></a>01071 }
<a name="l01072"></a>01072 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set.">ptlrpc_set_add_req</a>);
<a name="l01073"></a>01073 
<a name="l01079"></a>01079 <span class="keywordtype">void</span> ptlrpc_set_add_new_req(<span class="keyword">struct</span> <a class="code" href="structptlrpcd__ctl.html" title="Declaration of ptlrpcd control structure.">ptlrpcd_ctl</a> *pc,
<a name="l01080"></a>01080                            <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01081"></a>01081 {
<a name="l01082"></a>01082         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span> = pc-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>;
<a name="l01083"></a>01083         <span class="keywordtype">int</span> count, i;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085         LASSERT(req-&gt;rq_set == NULL);
<a name="l01086"></a>01086         LASSERT(test_bit(<a class="code" href="group__net.html#ggaaa41ab709a4804427e6eb05360ebbed4af770daedef7de3eaf332a0ff9413462c" title="Ptlrpc thread stop flag.">LIOD_STOP</a>, &amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8a71506370675d9c54ae562c716d8b64" title="Ptlrpc thread control flags (LIOD_START, LIOD_STOP, LIOD_FORCE).">pc_flags</a>) == 0);
<a name="l01087"></a>01087 
<a name="l01088"></a>01088         spin_lock(&amp;set-&gt;set_new_req_lock);
<a name="l01089"></a>01089         <span class="comment">/*</span>
<a name="l01090"></a>01090 <span class="comment">         * The set takes over the caller&apos;s request reference.</span>
<a name="l01091"></a>01091 <span class="comment">         */</span>
<a name="l01092"></a>01092         req-&gt;rq_set = <span class="keyword">set</span>;
<a name="l01093"></a>01093         req-&gt;rq_queued_time = cfs_time_current();
<a name="l01094"></a>01094         list_add_tail(&amp;req-&gt;rq_set_chain, &amp;set-&gt;set_new_requests);
<a name="l01095"></a>01095         count = atomic_inc_return(&amp;set-&gt;set_new_count);
<a name="l01096"></a>01096         spin_unlock(&amp;set-&gt;set_new_req_lock);
<a name="l01097"></a>01097 
<a name="l01098"></a>01098         <span class="comment">/* Only need to call wakeup once for the first entry. */</span>
<a name="l01099"></a>01099         <span class="keywordflow">if</span> (count == 1) {
<a name="l01100"></a>01100                 wake_up(&amp;set-&gt;set_waitq);
<a name="l01101"></a>01101 
<a name="l01102"></a>01102                 <span class="comment">/* XXX: It maybe unnecessary to wakeup all the partners. But to</span>
<a name="l01103"></a>01103 <span class="comment">                 *      guarantee the async RPC can be processed ASAP, we have</span>
<a name="l01104"></a>01104 <span class="comment">                 *      no other better choice. It maybe fixed in future. */</span>
<a name="l01105"></a>01105                 <span class="keywordflow">for</span> (i = 0; i &lt; pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a8e322330ead83e87dc67ff507a0a074c" title="Number of the ptlrpcd&amp;#39;s partners.">pc_npartners</a>; i++)
<a name="l01106"></a>01106                         wake_up(&amp;pc-&gt;<a class="code" href="structptlrpcd__ctl.html#a41bc93f6037edc4d97bd58e333b6cc80" title="Pointer to the array of partners&amp;#39; ptlrpcd_ctl structure.">pc_partners</a>[i]-&gt;<a class="code" href="structptlrpcd__ctl.html#abef10c84609f48350a39a8f6b2ddb14c" title="Thread requests set.">pc_set</a>-&gt;<a class="code" href="structptlrpc__request__set.html#afa37e9803cad75f212925a762a9f6d7b" title="wait queue to wait on for request events">set_waitq</a>);
<a name="l01107"></a>01107         }
<a name="l01108"></a>01108 }
<a name="l01109"></a>01109 
<a name="l01120"></a>01120 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpc_import_delay_req(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01121"></a>01121                                    <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> *status)
<a name="l01122"></a>01122 {
<a name="l01123"></a>01123         <span class="keywordtype">int</span> delay = 0;
<a name="l01124"></a>01124         ENTRY;
<a name="l01125"></a>01125 
<a name="l01126"></a>01126         LASSERT (status != NULL);
<a name="l01127"></a>01127         *status = 0;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129         <span class="keywordflow">if</span> (req-&gt;rq_ctx_init || req-&gt;rq_ctx_fini) {
<a name="l01130"></a>01130                 <span class="comment">/* always allow ctx init/fini rpc go through */</span>
<a name="l01131"></a>01131         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_NEW) {
<a name="l01132"></a>01132                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;Uninitialized import.&quot;</span>);
<a name="l01133"></a>01133                 *status = -EIO;
<a name="l01134"></a>01134         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_CLOSED) {
<a name="l01135"></a>01135                 <span class="comment">/* pings may safely race with umount */</span>
<a name="l01136"></a>01136                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(lustre_msg_get_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) == OBD_PING ?
<a name="l01137"></a>01137                           D_HA : D_ERROR, req, <span class="stringliteral">&quot;IMP_CLOSED &quot;</span>);
<a name="l01138"></a>01138                 *status = -EIO;
<a name="l01139"></a>01139         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ptlrpc_send_limit_expired(req)) {
<a name="l01140"></a>01140                 <span class="comment">/* probably doesn&apos;t need to be a D_ERROR after initial testing*/</span>
<a name="l01141"></a>01141                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;send limit expired &quot;</span>);
<a name="l01142"></a>01142                 *status = -ETIMEDOUT;
<a name="l01143"></a>01143         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;rq_send_state == LUSTRE_IMP_CONNECTING &amp;&amp;
<a name="l01144"></a>01144                    imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_CONNECTING) {
<a name="l01145"></a>01145                 <span class="comment">/* allow CONNECT even if import is invalid */</span> ;
<a name="l01146"></a>01146                 <span class="keywordflow">if</span> (atomic_read(&amp;imp-&gt;<a class="code" href="structobd__import.html#a46e3ad7c714327418fb7dc74ae1b84ae" title="Number of currently happening import invalidations.">imp_inval_count</a>) != 0) {
<a name="l01147"></a>01147                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;invalidate in flight&quot;</span>);
<a name="l01148"></a>01148                         *status = -EIO;
<a name="l01149"></a>01149                 }
<a name="l01150"></a>01150         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imp-&gt;imp_invalid || imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_no_recov) {
<a name="l01151"></a>01151                 <span class="keywordflow">if</span> (!imp-&gt;imp_deactive)
<a name="l01152"></a>01152                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_NET, req, <span class="stringliteral">&quot;IMP_INVALID&quot;</span>);
<a name="l01153"></a>01153                 *status = -ESHUTDOWN; <span class="comment">/* bz 12940 */</span>
<a name="l01154"></a>01154         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;rq_import_generation != imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>) {
<a name="l01155"></a>01155                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;req wrong generation:&quot;</span>);
<a name="l01156"></a>01156                 *status = -EIO;
<a name="l01157"></a>01157         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;rq_send_state != imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a>) {
<a name="l01158"></a>01158                 <span class="comment">/* invalidate in progress - any requests should be drop */</span>
<a name="l01159"></a>01159                 <span class="keywordflow">if</span> (atomic_read(&amp;imp-&gt;<a class="code" href="structobd__import.html#a46e3ad7c714327418fb7dc74ae1b84ae" title="Number of currently happening import invalidations.">imp_inval_count</a>) != 0) {
<a name="l01160"></a>01160                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;invalidate in flight&quot;</span>);
<a name="l01161"></a>01161                         *status = -EIO;
<a name="l01162"></a>01162                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imp-&gt;imp_dlm_fake || req-&gt;rq_no_delay) {
<a name="l01163"></a>01163                         *status = -EWOULDBLOCK;
<a name="l01164"></a>01164                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;rq_allow_replay &amp;&amp;
<a name="l01165"></a>01165                           (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_REPLAY ||
<a name="l01166"></a>01166                            imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_REPLAY_LOCKS ||
<a name="l01167"></a>01167                            imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_REPLAY_WAIT ||
<a name="l01168"></a>01168                            imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_RECOVER)) {
<a name="l01169"></a>01169                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;allow during recovery.\n&quot;</span>);
<a name="l01170"></a>01170                 } <span class="keywordflow">else</span> {
<a name="l01171"></a>01171                         delay = 1;
<a name="l01172"></a>01172                 }
<a name="l01173"></a>01173         }
<a name="l01174"></a>01174 
<a name="l01175"></a>01175         RETURN(delay);
<a name="l01176"></a>01176 }
<a name="l01177"></a>01177 
<a name="l01187"></a>01187 <span class="keyword">static</span> <span class="keywordtype">bool</span> ptlrpc_console_allow(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01188"></a>01188 {
<a name="l01189"></a>01189         __u32 opc;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> != NULL);
<a name="l01192"></a>01192         opc = lustre_msg_get_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         <span class="comment">/* Suppress particular reconnect errors which are to be expected. */</span>
<a name="l01195"></a>01195         <span class="keywordflow">if</span> (opc == OST_CONNECT || opc == MDS_CONNECT || opc == MGS_CONNECT) {
<a name="l01196"></a>01196                 <span class="keywordtype">int</span> err;
<a name="l01197"></a>01197 
<a name="l01198"></a>01198                 <span class="comment">/* Suppress timed out reconnect requests */</span>
<a name="l01199"></a>01199                 <span class="keywordflow">if</span> (lustre_handle_is_used(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a0b8bb1da93c9c21f85044d87a7104a4e" title="Remote export handle.">imp_remote_handle</a>) ||
<a name="l01200"></a>01200                     req-&gt;rq_timedout)
<a name="l01201"></a>01201                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01202"></a>01202 
<a name="l01203"></a>01203                 <span class="comment">/* Suppress most unavailable/again reconnect requests, but</span>
<a name="l01204"></a>01204 <span class="comment">                 * print occasionally so it is clear client is trying to</span>
<a name="l01205"></a>01205 <span class="comment">                 * connect to a server where no target is running. */</span>
<a name="l01206"></a>01206                 err = lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l01207"></a>01207                 <span class="keywordflow">if</span> ((err == -ENODEV || err == -EAGAIN) &amp;&amp;
<a name="l01208"></a>01208                     req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#ac3b8409237b9f6fc17e80bdfed39a1d5" title="Incremented every time we send reconnection request.">imp_conn_cnt</a> % 30 != 20)
<a name="l01209"></a>01209                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01210"></a>01210         }
<a name="l01211"></a>01211 
<a name="l01212"></a>01212         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01213"></a>01213 }
<a name="l01214"></a>01214 
<a name="l01219"></a>01219 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpc_check_status(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01220"></a>01220 {
<a name="l01221"></a>01221         <span class="keywordtype">int</span> err;
<a name="l01222"></a>01222         ENTRY;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224         err = lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l01225"></a>01225         <span class="keywordflow">if</span> (lustre_msg_get_type(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) == PTL_RPC_MSG_ERR) {
<a name="l01226"></a>01226                 <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l01227"></a>01227                 <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid = imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>;
<a name="l01228"></a>01228                 __u32 opc = lustre_msg_get_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l01229"></a>01229 
<a name="l01230"></a>01230                 <span class="keywordflow">if</span> (ptlrpc_console_allow(req))
<a name="l01231"></a>01231                         LCONSOLE_ERROR_MSG(0x11, <span class="stringliteral">&quot;%s: operation %s to node %s &quot;</span>
<a name="l01232"></a>01232                                            <span class="stringliteral">&quot;failed: rc = %d\n&quot;</span>,
<a name="l01233"></a>01233                                            imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01234"></a>01234                                            <a class="code" href="group__net.html#gac9b02b599f8ac342b03f25da53bcb168" title="procfs output related functions">ll_opcode2str</a>(opc),
<a name="l01235"></a>01235                                            libcfs_nid2str(nid), err);
<a name="l01236"></a>01236                 RETURN(err &lt; 0 ? err : -EINVAL);
<a name="l01237"></a>01237         }
<a name="l01238"></a>01238 
<a name="l01239"></a>01239         <span class="keywordflow">if</span> (err &lt; 0) {
<a name="l01240"></a>01240                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_INFO, req, <span class="stringliteral">&quot;status is %d&quot;</span>, err);
<a name="l01241"></a>01241         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err &gt; 0) {
<a name="l01242"></a>01242                 <span class="comment">/* XXX: translate this error from net to host */</span>
<a name="l01243"></a>01243                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_INFO, req, <span class="stringliteral">&quot;status is %d&quot;</span>, err);
<a name="l01244"></a>01244         }
<a name="l01245"></a>01245 
<a name="l01246"></a>01246         RETURN(err);
<a name="l01247"></a>01247 }
<a name="l01248"></a>01248 
<a name="l01254"></a>01254 <span class="keyword">static</span> <span class="keywordtype">void</span> ptlrpc_save_versions(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01255"></a>01255 {
<a name="l01256"></a>01256         <span class="keyword">struct </span>lustre_msg *repmsg = req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>;
<a name="l01257"></a>01257         <span class="keyword">struct </span>lustre_msg *reqmsg = req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>;
<a name="l01258"></a>01258         __u64 *versions = lustre_msg_get_versions(repmsg);
<a name="l01259"></a>01259         ENTRY;
<a name="l01260"></a>01260 
<a name="l01261"></a>01261         <span class="keywordflow">if</span> (lustre_msg_get_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; MSG_REPLAY)
<a name="l01262"></a>01262                 <span class="keywordflow">return</span>;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264         LASSERT(versions);
<a name="l01265"></a>01265         lustre_msg_set_versions(reqmsg, versions);
<a name="l01266"></a>01266         CDEBUG(D_INFO, <span class="stringliteral">&quot;Client save versions [&quot;</span>LPX64<span class="stringliteral">&quot;/&quot;</span>LPX64<span class="stringliteral">&quot;]\n&quot;</span>,
<a name="l01267"></a>01267                versions[0], versions[1]);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269         EXIT;
<a name="l01270"></a>01270 }
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 __u64 ptlrpc_known_replied_xid(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l01273"></a>01273 {
<a name="l01274"></a>01274         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l01275"></a>01275 
<a name="l01276"></a>01276         assert_spin_locked(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01277"></a>01277         <span class="keywordflow">if</span> (list_empty(&amp;imp-&gt;<a class="code" href="structobd__import.html#a0ff3d0b8eb357f7d3904ec7732fbd416" title="List of not replied requests.">imp_unreplied_list</a>))
<a name="l01278"></a>01278                 <span class="keywordflow">return</span> 0;
<a name="l01279"></a>01279 
<a name="l01280"></a>01280         req = list_entry(imp-&gt;<a class="code" href="structobd__import.html#a0ff3d0b8eb357f7d3904ec7732fbd416" title="List of not replied requests.">imp_unreplied_list</a>.next, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l01281"></a>01281                          rq_unreplied_list);
<a name="l01282"></a>01282         LASSERTF(req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> &gt;= 1, <span class="stringliteral">&quot;XID:&quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l01283"></a>01283 
<a name="l01284"></a>01284         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#a3581a8b4f15a6d9ba6daad54873cd0eb" title="Known maximal replied XID.">imp_known_replied_xid</a> &lt; req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> - 1)
<a name="l01285"></a>01285                 imp-&gt;<a class="code" href="structobd__import.html#a3581a8b4f15a6d9ba6daad54873cd0eb" title="Known maximal replied XID.">imp_known_replied_xid</a> = req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> - 1;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287         <span class="keywordflow">return</span> req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> - 1;
<a name="l01288"></a>01288 }
<a name="l01289"></a>01289 
<a name="l01297"></a>01297 <span class="keyword">static</span> <span class="keywordtype">int</span> after_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01298"></a>01298 {
<a name="l01299"></a>01299         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l01300"></a>01300         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>;
<a name="l01301"></a>01301         <span class="keywordtype">int</span> rc;
<a name="l01302"></a>01302         <span class="keyword">struct </span>timeval work_start;
<a name="l01303"></a>01303         __u64 committed;
<a name="l01304"></a>01304         <span class="keywordtype">long</span> timediff;
<a name="l01305"></a>01305         ENTRY;
<a name="l01306"></a>01306 
<a name="l01307"></a>01307         LASSERT(obd != NULL);
<a name="l01308"></a>01308         <span class="comment">/* repbuf must be unlinked */</span>
<a name="l01309"></a>01309         LASSERT(!req-&gt;rq_receiving_reply &amp;&amp; req-&gt;rq_reply_unlinked);
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         <span class="keywordflow">if</span> (req-&gt;rq_reply_truncated) {
<a name="l01312"></a>01312                 <span class="keywordflow">if</span> (ptlrpc_no_resend(req)) {
<a name="l01313"></a>01313                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;reply buffer overflow,&quot;</span>
<a name="l01314"></a>01314                                   <span class="stringliteral">&quot; expected: %d, actual size: %d&quot;</span>,
<a name="l01315"></a>01315                                   req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>, req-&gt;rq_repbuf_len);
<a name="l01316"></a>01316                         RETURN(-EOVERFLOW);
<a name="l01317"></a>01317                 }
<a name="l01318"></a>01318 
<a name="l01319"></a>01319                 <a class="code" href="group__sptlrpc.html#ga6cd89bd371e4a81930e260bb1b8c79f8" title="Used by ptlrpc client to free reply buffer of req.">sptlrpc_cli_free_repbuf</a>(req);
<a name="l01320"></a>01320                 <span class="comment">/* Pass the required reply buffer size (include</span>
<a name="l01321"></a>01321 <span class="comment">                 * space for early reply).</span>
<a name="l01322"></a>01322 <span class="comment">                 * NB: no need to roundup because alloc_repbuf</span>
<a name="l01323"></a>01323 <span class="comment">                 * will roundup it */</span>
<a name="l01324"></a>01324                 req-&gt;<a class="code" href="structptlrpc__request.html#aaa9ba7e7b71ad2057d1650469ab15076" title="Reply length.">rq_replen</a>       = req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>;
<a name="l01325"></a>01325                 req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a> = 0;
<a name="l01326"></a>01326                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01327"></a>01327                 req-&gt;rq_resend       = 1;
<a name="l01328"></a>01328                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01329"></a>01329                 RETURN(0);
<a name="l01330"></a>01330         }
<a name="l01331"></a>01331 
<a name="l01332"></a>01332         do_gettimeofday(&amp;work_start);
<a name="l01333"></a>01333         timediff = cfs_timeval_sub(&amp;work_start, &amp;req-&gt;rq_sent_tv, NULL);
<a name="l01334"></a>01334 
<a name="l01335"></a>01335         <span class="comment">/*</span>
<a name="l01336"></a>01336 <span class="comment">         * NB Until this point, the whole of the incoming message,</span>
<a name="l01337"></a>01337 <span class="comment">         * including buflens, status etc is in the sender&apos;s byte order.</span>
<a name="l01338"></a>01338 <span class="comment">         */</span>
<a name="l01339"></a>01339         rc = <a class="code" href="group__sptlrpc.html#ga4e652d7f03a8727b8eb9c290936aec23" title="Used by ptlrpc client, to perform security transformation upon the reply message...">sptlrpc_cli_unwrap_reply</a>(req);
<a name="l01340"></a>01340         <span class="keywordflow">if</span> (rc) {
<a name="l01341"></a>01341                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;unwrap reply failed (%d):&quot;</span>, rc);
<a name="l01342"></a>01342                 RETURN(rc);
<a name="l01343"></a>01343         }
<a name="l01344"></a>01344 
<a name="l01345"></a>01345         <span class="comment">/*</span>
<a name="l01346"></a>01346 <span class="comment">         * Security layer unwrap might ask resend this request.</span>
<a name="l01347"></a>01347 <span class="comment">         */</span>
<a name="l01348"></a>01348         <span class="keywordflow">if</span> (req-&gt;rq_resend)
<a name="l01349"></a>01349                 RETURN(0);
<a name="l01350"></a>01350 
<a name="l01351"></a>01351         rc = unpack_reply(req);
<a name="l01352"></a>01352         <span class="keywordflow">if</span> (rc)
<a name="l01353"></a>01353                 RETURN(rc);
<a name="l01354"></a>01354 
<a name="l01355"></a>01355         <span class="comment">/* retry indefinitely on EINPROGRESS */</span>
<a name="l01356"></a>01356         <span class="keywordflow">if</span> (lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) == -EINPROGRESS &amp;&amp;
<a name="l01357"></a>01357             ptlrpc_no_resend(req) == 0 &amp;&amp; !req-&gt;<a class="code" href="structptlrpc__request.html#ab4a9cc6a2c3c14ca670362db92d56ae0" title="do not resend request on -EINPROGRESS">rq_no_retry_einprogress</a>) {
<a name="l01358"></a>01358                 time_t  now = cfs_time_current_sec();
<a name="l01359"></a>01359 
<a name="l01360"></a>01360                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;Resending request on EINPROGRESS&quot;</span>);
<a name="l01361"></a>01361                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01362"></a>01362                 req-&gt;rq_resend = 1;
<a name="l01363"></a>01363                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01364"></a>01364                 req-&gt;rq_nr_resend++;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366                 <span class="comment">/* Readjust the timeout for current conditions */</span>
<a name="l01367"></a>01367                 <a class="code" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e.">ptlrpc_at_set_req_timeout</a>(req);
<a name="l01368"></a>01368                 <span class="comment">/* delay resend to give a chance to the server to get ready.</span>
<a name="l01369"></a>01369 <span class="comment">                 * The delay is increased by 1s on every resend and is capped to</span>
<a name="l01370"></a>01370 <span class="comment">                 * the current request timeout (i.e. obd_timeout if AT is off,</span>
<a name="l01371"></a>01371 <span class="comment">                 * or AT service time x 125% + 5s, see at_est2timeout) */</span>
<a name="l01372"></a>01372                 <span class="keywordflow">if</span> (req-&gt;rq_nr_resend &gt; req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>)
<a name="l01373"></a>01373                         req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> = now + req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>;
<a name="l01374"></a>01374                 <span class="keywordflow">else</span>
<a name="l01375"></a>01375                         req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> = now + req-&gt;rq_nr_resend;
<a name="l01376"></a>01376 
<a name="l01377"></a>01377                 <span class="comment">/* Resend for EINPROGRESS will use a new XID */</span>
<a name="l01378"></a>01378                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01379"></a>01379                 list_del_init(&amp;req-&gt;rq_unreplied_list);
<a name="l01380"></a>01380                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01381"></a>01381 
<a name="l01382"></a>01382                 RETURN(0);
<a name="l01383"></a>01383         }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385         <span class="keywordflow">if</span> (obd-&gt;obd_svc_stats != NULL) {
<a name="l01386"></a>01386                 lprocfs_counter_add(obd-&gt;obd_svc_stats, PTLRPC_REQWAIT_CNTR,
<a name="l01387"></a>01387                                     timediff);
<a name="l01388"></a>01388                 ptlrpc_lprocfs_rpc_sent(req, timediff);
<a name="l01389"></a>01389         }
<a name="l01390"></a>01390 
<a name="l01391"></a>01391         <span class="keywordflow">if</span> (lustre_msg_get_type(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) != PTL_RPC_MSG_REPLY &amp;&amp;
<a name="l01392"></a>01392             lustre_msg_get_type(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) != PTL_RPC_MSG_ERR) {
<a name="l01393"></a>01393                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;invalid packet received (type=%u)&quot;</span>,
<a name="l01394"></a>01394                           lustre_msg_get_type(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>));
<a name="l01395"></a>01395                 RETURN(-EPROTO);
<a name="l01396"></a>01396         }
<a name="l01397"></a>01397 
<a name="l01398"></a>01398         <span class="keywordflow">if</span> (lustre_msg_get_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) != OBD_PING)
<a name="l01399"></a>01399                 CFS_FAIL_TIMEOUT(OBD_FAIL_PTLRPC_PAUSE_REP, cfs_fail_val);
<a name="l01400"></a>01400         ptlrpc_at_adj_service(req, lustre_msg_get_timeout(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>));
<a name="l01401"></a>01401         ptlrpc_at_adj_net_latency(req,
<a name="l01402"></a>01402                                   lustre_msg_get_service_time(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>));
<a name="l01403"></a>01403 
<a name="l01404"></a>01404         rc = ptlrpc_check_status(req);
<a name="l01405"></a>01405         imp-&gt;imp_connect_error = rc;
<a name="l01406"></a>01406 
<a name="l01407"></a>01407         <span class="keywordflow">if</span> (rc) {
<a name="l01408"></a>01408                 <span class="comment">/*</span>
<a name="l01409"></a>01409 <span class="comment">                 * Either we&apos;ve been evicted, or the server has failed for</span>
<a name="l01410"></a>01410 <span class="comment">                 * some reason. Try to reconnect, and if that fails, punt to</span>
<a name="l01411"></a>01411 <span class="comment">                 * the upcall.</span>
<a name="l01412"></a>01412 <span class="comment">                 */</span>
<a name="l01413"></a>01413                 <span class="keywordflow">if</span> (ptlrpc_recoverable_error(rc)) {
<a name="l01414"></a>01414                         <span class="keywordflow">if</span> (req-&gt;rq_send_state != LUSTRE_IMP_FULL ||
<a name="l01415"></a>01415                             imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_no_recov || imp-&gt;imp_dlm_fake) {
<a name="l01416"></a>01416                                 RETURN(rc);
<a name="l01417"></a>01417                         }
<a name="l01418"></a>01418                         ptlrpc_request_handle_notconn(req);
<a name="l01419"></a>01419                         RETURN(rc);
<a name="l01420"></a>01420                 }
<a name="l01421"></a>01421         } <span class="keywordflow">else</span> {
<a name="l01422"></a>01422                 <span class="comment">/*</span>
<a name="l01423"></a>01423 <span class="comment">                 * Let&apos;s look if server sent slv. Do it only for RPC with</span>
<a name="l01424"></a>01424 <span class="comment">                 * rc == 0.</span>
<a name="l01425"></a>01425 <span class="comment">                 */</span>
<a name="l01426"></a>01426                 <a class="code" href="group__ldlm__cli__api.html#ga83cbdc7f471f1c21e1200fb94d5be170" title="Update client&amp;#39;s OBD pool related fields with new SLV and Limit from req.">ldlm_cli_update_pool</a>(req);
<a name="l01427"></a>01427         }
<a name="l01428"></a>01428 
<a name="l01429"></a>01429         <span class="comment">/*</span>
<a name="l01430"></a>01430 <span class="comment">         * Store transno in reqmsg for replay.</span>
<a name="l01431"></a>01431 <span class="comment">         */</span>
<a name="l01432"></a>01432         <span class="keywordflow">if</span> (!(lustre_msg_get_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; MSG_REPLAY)) {
<a name="l01433"></a>01433                 req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> = lustre_msg_get_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l01434"></a>01434                 lustre_msg_set_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a>);
<a name="l01435"></a>01435         }
<a name="l01436"></a>01436 
<a name="l01437"></a>01437         <span class="keywordflow">if</span> (imp-&gt;imp_replayable) {
<a name="l01438"></a>01438                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01439"></a>01439                 <span class="comment">/*</span>
<a name="l01440"></a>01440 <span class="comment">                 * No point in adding already-committed requests to the replay</span>
<a name="l01441"></a>01441 <span class="comment">                 * list, we will just remove them immediately. b=9829</span>
<a name="l01442"></a>01442 <span class="comment">                 */</span>
<a name="l01443"></a>01443                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> != 0 &amp;&amp;
<a name="l01444"></a>01444                     (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> &gt;
<a name="l01445"></a>01445                      lustre_msg_get_last_committed(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) ||
<a name="l01446"></a>01446                      req-&gt;<a class="code" href="structptlrpc__request.html#ae9b053a81331ff81f4568df30b253bf0" title="when -&amp;gt;rq_replay is set, request is kept by the client even after server commits...">rq_replay</a>)) {
<a name="l01448"></a>01448                         ptlrpc_save_versions(req);
<a name="l01449"></a>01449                         <a class="code" href="group__net.html#ga74e4777d34c1f5305c03de9d365a6268" title="Add a request to import replay_list.">ptlrpc_retain_replayable_request</a>(req, imp);
<a name="l01450"></a>01450                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;rq_commit_cb != NULL &amp;&amp;
<a name="l01451"></a>01451                            list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>)) {
<a name="l01452"></a>01452                         <span class="comment">/* NB: don&apos;t call rq_commit_cb if it&apos;s already on</span>
<a name="l01453"></a>01453 <span class="comment">                         * rq_replay_list, ptlrpc_free_committed() will call</span>
<a name="l01454"></a>01454 <span class="comment">                         * it later, see LU-3618 for details */</span>
<a name="l01455"></a>01455                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01456"></a>01456                         req-&gt;rq_commit_cb(req);
<a name="l01457"></a>01457                         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01458"></a>01458                 }
<a name="l01459"></a>01459 
<a name="l01460"></a>01460                 <span class="comment">/*</span>
<a name="l01461"></a>01461 <span class="comment">                 * Replay-enabled imports return commit-status information.</span>
<a name="l01462"></a>01462 <span class="comment">                 */</span>
<a name="l01463"></a>01463                 committed = lustre_msg_get_last_committed(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l01464"></a>01464                 <span class="keywordflow">if</span> (likely(committed &gt; imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>))
<a name="l01465"></a>01465                         imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a> = committed;
<a name="l01466"></a>01466 
<a name="l01467"></a>01467                 <a class="code" href="group__ha.html#ga1201e450853aba39256bafedcfae7f11" title="Iterates through replay_list on import and prunes all requests have transno smaller...">ptlrpc_free_committed</a>(imp);
<a name="l01468"></a>01468 
<a name="l01469"></a>01469                 <span class="keywordflow">if</span> (!list_empty(&amp;imp-&gt;<a class="code" href="structobd__import.html#ae3f32574c5a9b068001d451c8506ef7b" title="Lists of requests that are retained for replay, waiting for a reply, or waiting for...">imp_replay_list</a>)) {
<a name="l01470"></a>01470                         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *last;
<a name="l01471"></a>01471 
<a name="l01472"></a>01472                         last = list_entry(imp-&gt;<a class="code" href="structobd__import.html#ae3f32574c5a9b068001d451c8506ef7b" title="Lists of requests that are retained for replay, waiting for a reply, or waiting for...">imp_replay_list</a>.prev,
<a name="l01473"></a>01473                                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l01474"></a>01474                                           <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>);
<a name="l01475"></a>01475                         <span class="comment">/*</span>
<a name="l01476"></a>01476 <span class="comment">                         * Requests with rq_replay stay on the list even if no</span>
<a name="l01477"></a>01477 <span class="comment">                         * commit is expected.</span>
<a name="l01478"></a>01478 <span class="comment">                         */</span>
<a name="l01479"></a>01479                         <span class="keywordflow">if</span> (last-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> &gt; imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>)
<a name="l01480"></a>01480                                 ptlrpc_pinger_commit_expected(imp);
<a name="l01481"></a>01481                 }
<a name="l01482"></a>01482 
<a name="l01483"></a>01483                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01484"></a>01484         }
<a name="l01485"></a>01485 
<a name="l01486"></a>01486         RETURN(rc);
<a name="l01487"></a>01487 }
<a name="l01488"></a>01488 
<a name="l01494"></a>01494 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpc_send_new_req(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01495"></a>01495 {
<a name="l01496"></a>01496         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a>     *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l01497"></a>01497         __u64                  min_xid = 0;
<a name="l01498"></a>01498         <span class="keywordtype">int</span> rc;
<a name="l01499"></a>01499         ENTRY;
<a name="l01500"></a>01500 
<a name="l01501"></a>01501         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW);
<a name="l01502"></a>01502 
<a name="l01503"></a>01503         <span class="comment">/* do not try to go further if there is not enough memory in enc_pool */</span>
<a name="l01504"></a>01504         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> &amp;&amp; req-&gt;rq_bulk != NULL)
<a name="l01505"></a>01505                 <span class="keywordflow">if</span> (req-&gt;rq_bulk-&gt;bd_iov_count &gt; get_free_pages_in_pool() &amp;&amp;
<a name="l01506"></a>01506                     pool_is_at_full_capacity())
<a name="l01507"></a>01507                         RETURN(-ENOMEM);
<a name="l01508"></a>01508 
<a name="l01509"></a>01509         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> &amp;&amp; (req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> &gt; cfs_time_current_sec()) &amp;&amp;
<a name="l01510"></a>01510             (!req-&gt;rq_generation_set ||
<a name="l01511"></a>01511              req-&gt;rq_import_generation == imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>))
<a name="l01512"></a>01512                 RETURN (0);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514         ptlrpc_rqphase_move(req, RQ_PHASE_RPC);
<a name="l01515"></a>01515 
<a name="l01516"></a>01516         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01517"></a>01517 
<a name="l01518"></a>01518         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> != 0);
<a name="l01519"></a>01519         LASSERT(!list_empty(&amp;req-&gt;rq_unreplied_list));
<a name="l01520"></a>01520 
<a name="l01521"></a>01521         <span class="keywordflow">if</span> (!req-&gt;rq_generation_set)
<a name="l01522"></a>01522                 req-&gt;rq_import_generation = imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>;
<a name="l01523"></a>01523 
<a name="l01524"></a>01524         <span class="keywordflow">if</span> (ptlrpc_import_delay_req(imp, req, &amp;rc)) {
<a name="l01525"></a>01525                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01526"></a>01526                 req-&gt;rq_waiting = 1;
<a name="l01527"></a>01527                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;req from PID %d waiting for recovery: &quot;</span>
<a name="l01530"></a>01530                           <span class="stringliteral">&quot;(%s != %s)&quot;</span>, lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>),
<a name="l01531"></a>01531                           ptlrpc_import_state_name(req-&gt;rq_send_state),
<a name="l01532"></a>01532                           ptlrpc_import_state_name(imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a>));
<a name="l01533"></a>01533                 LASSERT(list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>));
<a name="l01534"></a>01534                 list_add_tail(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>, &amp;imp-&gt;imp_delayed_list);
<a name="l01535"></a>01535                 atomic_inc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#aece380c78562b6b0ddbfb1b5460fcbb2" title="Number of requests currently in-flight.">imp_inflight</a>);
<a name="l01536"></a>01536                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01537"></a>01537                 RETURN(0);
<a name="l01538"></a>01538         }
<a name="l01539"></a>01539 
<a name="l01540"></a>01540         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01541"></a>01541                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01542"></a>01542                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = rc;
<a name="l01543"></a>01543                 ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01544"></a>01544                 RETURN(rc);
<a name="l01545"></a>01545         }
<a name="l01546"></a>01546 
<a name="l01547"></a>01547         LASSERT(list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>));
<a name="l01548"></a>01548         list_add_tail(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>, &amp;imp-&gt;imp_sending_list);
<a name="l01549"></a>01549         atomic_inc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#aece380c78562b6b0ddbfb1b5460fcbb2" title="Number of requests currently in-flight.">imp_inflight</a>);
<a name="l01550"></a>01550 
<a name="l01551"></a>01551         <span class="comment">/* find the known replied XID from the unreplied list, CONNECT</span>
<a name="l01552"></a>01552 <span class="comment">         * and DISCONNECT requests are skipped to make the sanity check</span>
<a name="l01553"></a>01553 <span class="comment">         * on server side happy. see process_req_last_xid().</span>
<a name="l01554"></a>01554 <span class="comment">         *</span>
<a name="l01555"></a>01555 <span class="comment">         * For CONNECT: Because replay requests have lower XID, it&apos;ll</span>
<a name="l01556"></a>01556 <span class="comment">         * break the sanity check if CONNECT bump the exp_last_xid on</span>
<a name="l01557"></a>01557 <span class="comment">         * server.</span>
<a name="l01558"></a>01558 <span class="comment">         *</span>
<a name="l01559"></a>01559 <span class="comment">         * For DISCONNECT: Since client will abort inflight RPC before</span>
<a name="l01560"></a>01560 <span class="comment">         * sending DISCONNECT, DISCONNECT may carry an XID which higher</span>
<a name="l01561"></a>01561 <span class="comment">         * than the inflight RPC.</span>
<a name="l01562"></a>01562 <span class="comment">         */</span>
<a name="l01563"></a>01563         <span class="keywordflow">if</span> (!ptlrpc_req_is_connect(req) &amp;&amp; !ptlrpc_req_is_disconnect(req))
<a name="l01564"></a>01564                 min_xid = ptlrpc_known_replied_xid(imp);
<a name="l01565"></a>01565         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01566"></a>01566 
<a name="l01567"></a>01567         lustre_msg_set_last_xid(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, min_xid);
<a name="l01568"></a>01568 
<a name="l01569"></a>01569         lustre_msg_set_status(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, current_pid());
<a name="l01570"></a>01570 
<a name="l01571"></a>01571         rc = <a class="code" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&amp;#39;s not up-to-date.">sptlrpc_req_refresh_ctx</a>(req, -1);
<a name="l01572"></a>01572         <span class="keywordflow">if</span> (rc) {
<a name="l01573"></a>01573                 <span class="keywordflow">if</span> (req-&gt;rq_err) {
<a name="l01574"></a>01574                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = rc;
<a name="l01575"></a>01575                         RETURN(1);
<a name="l01576"></a>01576                 } <span class="keywordflow">else</span> {
<a name="l01577"></a>01577                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01578"></a>01578                         req-&gt;rq_wait_ctx = 1;
<a name="l01579"></a>01579                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01580"></a>01580                         RETURN(0);
<a name="l01581"></a>01581                 }
<a name="l01582"></a>01582         }
<a name="l01583"></a>01583 
<a name="l01584"></a>01584         CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;Sending RPC pname:cluuid:pid:xid:nid:opc&quot;</span>
<a name="l01585"></a>01585                <span class="stringliteral">&quot; %s:%s:%d:&quot;</span>LPU64<span class="stringliteral">&quot;:%s:%d\n&quot;</span>, current_comm(),
<a name="l01586"></a>01586                imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_uuid.uuid,
<a name="l01587"></a>01587                lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>), req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>,
<a name="l01588"></a>01588                libcfs_nid2str(imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>),
<a name="l01589"></a>01589                lustre_msg_get_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l01590"></a>01590 
<a name="l01591"></a>01591         rc = <a class="code" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request.">ptl_send_rpc</a>(req, 0);
<a name="l01592"></a>01592         <span class="keywordflow">if</span> (rc == -ENOMEM) {
<a name="l01593"></a>01593                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01594"></a>01594                 <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>)) {
<a name="l01595"></a>01595                         list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l01596"></a>01596                         atomic_dec(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#aece380c78562b6b0ddbfb1b5460fcbb2" title="Number of requests currently in-flight.">imp_inflight</a>);
<a name="l01597"></a>01597                 }
<a name="l01598"></a>01598                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01599"></a>01599                 ptlrpc_rqphase_move(req, RQ_PHASE_NEW);
<a name="l01600"></a>01600                 RETURN(rc);
<a name="l01601"></a>01601         }
<a name="l01602"></a>01602         <span class="keywordflow">if</span> (rc) {
<a name="l01603"></a>01603                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;send failed (%d); expect timeout&quot;</span>, rc);
<a name="l01604"></a>01604                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01605"></a>01605                 req-&gt;rq_net_err = 1;
<a name="l01606"></a>01606                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01607"></a>01607                 RETURN(rc);
<a name="l01608"></a>01608         }
<a name="l01609"></a>01609         RETURN(0);
<a name="l01610"></a>01610 }
<a name="l01611"></a>01611 
<a name="l01612"></a>01612 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ptlrpc_set_producer(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>)
<a name="l01613"></a>01613 {
<a name="l01614"></a>01614         <span class="keywordtype">int</span> remaining, rc;
<a name="l01615"></a>01615         ENTRY;
<a name="l01616"></a>01616 
<a name="l01617"></a>01617         LASSERT(set-&gt;set_producer != NULL);
<a name="l01618"></a>01618 
<a name="l01619"></a>01619         remaining = atomic_read(&amp;set-&gt;set_remaining);
<a name="l01620"></a>01620 
<a name="l01621"></a>01621         <span class="comment">/* populate the -&gt;set_requests list with requests until we</span>
<a name="l01622"></a>01622 <span class="comment">         * reach the maximum number of RPCs in flight for this set */</span>
<a name="l01623"></a>01623         <span class="keywordflow">while</span> (atomic_read(&amp;set-&gt;set_remaining) &lt; set-&gt;set_max_inflight) {
<a name="l01624"></a>01624                 rc = <span class="keyword">set</span>-&gt;set_producer(<span class="keyword">set</span>, set-&gt;set_producer_arg);
<a name="l01625"></a>01625                 <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l01626"></a>01626                         <span class="comment">/* no more RPC to produce */</span>
<a name="l01627"></a>01627                         <span class="keyword">set</span>-&gt;set_producer     = NULL;
<a name="l01628"></a>01628                         <span class="keyword">set</span>-&gt;set_producer_arg = NULL;
<a name="l01629"></a>01629                         RETURN(0);
<a name="l01630"></a>01630                 }
<a name="l01631"></a>01631         }
<a name="l01632"></a>01632 
<a name="l01633"></a>01633         RETURN((atomic_read(&amp;set-&gt;set_remaining) - remaining));
<a name="l01634"></a>01634 }
<a name="l01635"></a>01635 
<a name="l01644"></a><a class="code" href="group__net.html#ga63613680c8953223c8efc4331656b11a">01644</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies...">ptlrpc_check_set</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>)
<a name="l01645"></a>01645 {
<a name="l01646"></a>01646         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp, *next;
<a name="l01647"></a>01647         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>  comp_reqs;
<a name="l01648"></a>01648         <span class="keywordtype">int</span> force_timer_recalc = 0;
<a name="l01649"></a>01649         ENTRY;
<a name="l01650"></a>01650 
<a name="l01651"></a>01651         <span class="keywordflow">if</span> (atomic_read(&amp;set-&gt;set_remaining) == 0)
<a name="l01652"></a>01652                 RETURN(1);
<a name="l01653"></a>01653 
<a name="l01654"></a>01654         INIT_LIST_HEAD(&amp;comp_reqs);
<a name="l01655"></a>01655         list_for_each_safe(tmp, next, &amp;set-&gt;set_requests) {
<a name="l01656"></a>01656                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l01657"></a>01657                         list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l01658"></a>01658                                    rq_set_chain);
<a name="l01659"></a>01659                 <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l01660"></a>01660                 <span class="keywordtype">int</span> unregistered = 0;
<a name="l01661"></a>01661                 <span class="keywordtype">int</span> async = 1;
<a name="l01662"></a>01662                 <span class="keywordtype">int</span> rc = 0;
<a name="l01663"></a>01663 
<a name="l01664"></a>01664                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_COMPLETE) {
<a name="l01665"></a>01665                         list_move_tail(&amp;req-&gt;rq_set_chain, &amp;comp_reqs);
<a name="l01666"></a>01666                         <span class="keywordflow">continue</span>;
<a name="l01667"></a>01667                 }
<a name="l01668"></a>01668 
<a name="l01669"></a>01669                 <span class="comment">/* This schedule point is mainly for the ptlrpcd caller of this</span>
<a name="l01670"></a>01670 <span class="comment">                 * function.  Most ptlrpc sets are not long-lived and unbounded</span>
<a name="l01671"></a>01671 <span class="comment">                 * in length, but at the least the set used by the ptlrpcd is.</span>
<a name="l01672"></a>01672 <span class="comment">                 * Since the processing time is unbounded, we need to insert an</span>
<a name="l01673"></a>01673 <span class="comment">                 * explicit schedule point to make the thread well-behaved.</span>
<a name="l01674"></a>01674 <span class="comment">                 */</span>
<a name="l01675"></a>01675                 cond_resched();
<a name="l01676"></a>01676 
<a name="l01677"></a>01677                 <span class="comment">/* If the caller requires to allow to be interpreted by force</span>
<a name="l01678"></a>01678 <span class="comment">                 * and it has really been interpreted, then move the request</span>
<a name="l01679"></a>01679 <span class="comment">                 * to RQ_PHASE_INTERPRET phase in spite of what the current</span>
<a name="l01680"></a>01680 <span class="comment">                 * phase is. */</span>
<a name="l01681"></a>01681                 <span class="keywordflow">if</span> (unlikely(req-&gt;rq_allow_intr &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#a6d4f6fc90fdcc8e2492f4ab902147970" title="client-side flags are serialized by rq_lock">rq_intr</a>)) {
<a name="l01682"></a>01682                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EINTR;
<a name="l01683"></a>01683                         ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01684"></a>01684 
<a name="l01685"></a>01685                         <span class="comment">/* Since it is interpreted and we have to wait for</span>
<a name="l01686"></a>01686 <span class="comment">                         * the reply to be unlinked, then use sync mode. */</span>
<a name="l01687"></a>01687                         async = 0;
<a name="l01688"></a>01688 
<a name="l01689"></a>01689                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01690"></a>01690                 }
<a name="l01691"></a>01691 
<a name="l01692"></a>01692                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW &amp;&amp; ptlrpc_send_new_req(req))
<a name="l01693"></a>01693                         force_timer_recalc = 1;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695                 <span class="comment">/* delayed send - skip */</span>
<a name="l01696"></a>01696                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a>)
<a name="l01697"></a>01697                         <span class="keywordflow">continue</span>;
<a name="l01698"></a>01698 
<a name="l01699"></a>01699                 <span class="comment">/* delayed resend - skip */</span>
<a name="l01700"></a>01700                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_RPC &amp;&amp; req-&gt;rq_resend &amp;&amp;
<a name="l01701"></a>01701                     req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> &gt; cfs_time_current_sec())
<a name="l01702"></a>01702                         <span class="keywordflow">continue</span>;
<a name="l01703"></a>01703 
<a name="l01704"></a>01704                 <span class="keywordflow">if</span> (!(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_RPC ||
<a name="l01705"></a>01705                       req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_BULK ||
<a name="l01706"></a>01706                       req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_INTERPRET ||
<a name="l01707"></a>01707                       req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_UNREGISTERING)) {
<a name="l01708"></a>01708                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;bad phase %x&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a>);
<a name="l01709"></a>01709                         LBUG();
<a name="l01710"></a>01710                 }
<a name="l01711"></a>01711 
<a name="l01712"></a>01712                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_UNREGISTERING) {
<a name="l01713"></a>01713                         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a> != req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a>);
<a name="l01714"></a>01714                         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a> != RQ_PHASE_UNDEFINED);
<a name="l01715"></a>01715 
<a name="l01716"></a>01716                         <span class="comment">/*</span>
<a name="l01717"></a>01717 <span class="comment">                         * Skip processing until reply is unlinked. We</span>
<a name="l01718"></a>01718 <span class="comment">                         * can&apos;t return to pool before that and we can&apos;t</span>
<a name="l01719"></a>01719 <span class="comment">                         * call interpret before that. We need to make</span>
<a name="l01720"></a>01720 <span class="comment">                         * sure that all rdma transfers finished and will</span>
<a name="l01721"></a>01721 <span class="comment">                         * not corrupt any data.</span>
<a name="l01722"></a>01722 <span class="comment">                         */</span>
<a name="l01723"></a>01723                         <span class="keywordflow">if</span> (ptlrpc_client_recv_or_unlink(req) ||
<a name="l01724"></a>01724                             ptlrpc_client_bulk_active(req))
<a name="l01725"></a>01725                                 <span class="keywordflow">continue</span>;
<a name="l01726"></a>01726 
<a name="l01727"></a>01727                         <span class="comment">/*</span>
<a name="l01728"></a>01728 <span class="comment">                         * Turn fail_loc off to prevent it from looping</span>
<a name="l01729"></a>01729 <span class="comment">                         * forever.</span>
<a name="l01730"></a>01730 <span class="comment">                         */</span>
<a name="l01731"></a>01731                         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK)) {
<a name="l01732"></a>01732                                 OBD_FAIL_CHECK_ORSET(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK,
<a name="l01733"></a>01733                                                      OBD_FAIL_ONCE);
<a name="l01734"></a>01734                         }
<a name="l01735"></a>01735                         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_BULK_UNLINK)) {
<a name="l01736"></a>01736                                 OBD_FAIL_CHECK_ORSET(OBD_FAIL_PTLRPC_LONG_BULK_UNLINK,
<a name="l01737"></a>01737                                                      OBD_FAIL_ONCE);
<a name="l01738"></a>01738                         }
<a name="l01739"></a>01739 
<a name="l01740"></a>01740                         <span class="comment">/*</span>
<a name="l01741"></a>01741 <span class="comment">                         * Move to next phase if reply was successfully</span>
<a name="l01742"></a>01742 <span class="comment">                         * unlinked.</span>
<a name="l01743"></a>01743 <span class="comment">                         */</span>
<a name="l01744"></a>01744                         ptlrpc_rqphase_move(req, req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a>);
<a name="l01745"></a>01745                 }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_INTERPRET)
<a name="l01748"></a>01748                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01749"></a>01749 
<a name="l01750"></a>01750                 <span class="comment">/*</span>
<a name="l01751"></a>01751 <span class="comment">                 * Note that this also will start async reply unlink.</span>
<a name="l01752"></a>01752 <span class="comment">                 */</span>
<a name="l01753"></a>01753                 <span class="keywordflow">if</span> (req-&gt;rq_net_err &amp;&amp; !req-&gt;rq_timedout) {
<a name="l01754"></a>01754                         ptlrpc_expire_one_request(req, 1);
<a name="l01755"></a>01755 
<a name="l01756"></a>01756                         <span class="comment">/*</span>
<a name="l01757"></a>01757 <span class="comment">                         * Check if we still need to wait for unlink.</span>
<a name="l01758"></a>01758 <span class="comment">                         */</span>
<a name="l01759"></a>01759                         <span class="keywordflow">if</span> (ptlrpc_client_recv_or_unlink(req) ||
<a name="l01760"></a>01760                             ptlrpc_client_bulk_active(req))
<a name="l01761"></a>01761                                 <span class="keywordflow">continue</span>;
<a name="l01762"></a>01762                         <span class="comment">/* If there is no need to resend, fail it now. */</span>
<a name="l01763"></a>01763                         <span class="keywordflow">if</span> (req-&gt;rq_no_resend) {
<a name="l01764"></a>01764                                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> == 0)
<a name="l01765"></a>01765                                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l01766"></a>01766                                 ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01767"></a>01767                                 GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01768"></a>01768                         } <span class="keywordflow">else</span> {
<a name="l01769"></a>01769                                 <span class="keywordflow">continue</span>;
<a name="l01770"></a>01770                         }
<a name="l01771"></a>01771                 }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773                 <span class="keywordflow">if</span> (req-&gt;rq_err) {
<a name="l01774"></a>01774                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01775"></a>01775                         req-&gt;rq_replied = 0;
<a name="l01776"></a>01776                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01777"></a>01777                         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> == 0)
<a name="l01778"></a>01778                                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l01779"></a>01779                         ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01780"></a>01780                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01781"></a>01781                 }
<a name="l01782"></a>01782 
<a name="l01783"></a>01783                 <span class="comment">/* ptlrpc_set_wait-&gt;l_wait_event sets lwi_allow_intr</span>
<a name="l01784"></a>01784 <span class="comment">                 * so it sets rq_intr regardless of individual rpc</span>
<a name="l01785"></a>01785 <span class="comment">                 * timeouts. The synchronous IO waiting path sets</span>
<a name="l01786"></a>01786 <span class="comment">                 * rq_intr irrespective of whether ptlrpcd</span>
<a name="l01787"></a>01787 <span class="comment">                 * has seen a timeout.  Our policy is to only interpret</span>
<a name="l01788"></a>01788 <span class="comment">                 * interrupted rpcs after they have timed out, so we</span>
<a name="l01789"></a>01789 <span class="comment">                 * need to enforce that here.</span>
<a name="l01790"></a>01790 <span class="comment">                 */</span>
<a name="l01791"></a>01791 
<a name="l01792"></a>01792                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a6d4f6fc90fdcc8e2492f4ab902147970" title="client-side flags are serialized by rq_lock">rq_intr</a> &amp;&amp; (req-&gt;rq_timedout || req-&gt;rq_waiting ||
<a name="l01793"></a>01793                                      req-&gt;rq_wait_ctx)) {
<a name="l01794"></a>01794                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EINTR;
<a name="l01795"></a>01795                         ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01796"></a>01796                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01797"></a>01797                 }
<a name="l01798"></a>01798 
<a name="l01799"></a>01799                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_RPC) {
<a name="l01800"></a>01800                         <span class="keywordflow">if</span> (req-&gt;rq_timedout || req-&gt;rq_resend ||
<a name="l01801"></a>01801                             req-&gt;rq_waiting || req-&gt;rq_wait_ctx) {
<a name="l01802"></a>01802                                 <span class="keywordtype">int</span> status;
<a name="l01803"></a>01803 
<a name="l01804"></a>01804                                 <span class="keywordflow">if</span> (!ptlrpc_unregister_reply(req, 1)) {
<a name="l01805"></a>01805                                         <a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(req, 1);
<a name="l01806"></a>01806                                         <span class="keywordflow">continue</span>;
<a name="l01807"></a>01807                                 }
<a name="l01808"></a>01808 
<a name="l01809"></a>01809                                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01810"></a>01810                                 <span class="keywordflow">if</span> (ptlrpc_import_delay_req(imp, req, &amp;status)){
<a name="l01811"></a>01811                                         <span class="comment">/* put on delay list - only if we wait</span>
<a name="l01812"></a>01812 <span class="comment">                                         * recovery finished - before send */</span>
<a name="l01813"></a>01813                                         list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l01814"></a>01814                                         list_add_tail(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>,
<a name="l01815"></a>01815                                                           &amp;imp-&gt;
<a name="l01816"></a>01816                                                           imp_delayed_list);
<a name="l01817"></a>01817                                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01818"></a>01818                                         <span class="keywordflow">continue</span>;
<a name="l01819"></a>01819                                 }
<a name="l01820"></a>01820 
<a name="l01821"></a>01821                                 <span class="keywordflow">if</span> (status != 0)  {
<a name="l01822"></a>01822                                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = status;
<a name="l01823"></a>01823                                         ptlrpc_rqphase_move(req,
<a name="l01824"></a>01824                                                 RQ_PHASE_INTERPRET);
<a name="l01825"></a>01825                                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01826"></a>01826                                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01827"></a>01827                                 }
<a name="l01828"></a>01828                                 <span class="keywordflow">if</span> (ptlrpc_no_resend(req) &amp;&amp;
<a name="l01829"></a>01829                                     !req-&gt;rq_wait_ctx) {
<a name="l01830"></a>01830                                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -ENOTCONN;
<a name="l01831"></a>01831                                         ptlrpc_rqphase_move(req,
<a name="l01832"></a>01832                                                             RQ_PHASE_INTERPRET);
<a name="l01833"></a>01833                                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01834"></a>01834                                         GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01835"></a>01835                                 }
<a name="l01836"></a>01836 
<a name="l01837"></a>01837                                 list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l01838"></a>01838                                 list_add_tail(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>,
<a name="l01839"></a>01839                                                   &amp;imp-&gt;imp_sending_list);
<a name="l01840"></a>01840 
<a name="l01841"></a>01841                                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01842"></a>01842 
<a name="l01843"></a>01843                                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01844"></a>01844                                 req-&gt;rq_waiting = 0;
<a name="l01845"></a>01845                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01846"></a>01846 
<a name="l01847"></a>01847                                 <span class="keywordflow">if</span> (req-&gt;rq_timedout || req-&gt;rq_resend) {
<a name="l01848"></a>01848                                         <span class="comment">/* This is re-sending anyways,</span>
<a name="l01849"></a>01849 <span class="comment">                                         * let&apos;s mark req as resend. */</span>
<a name="l01850"></a>01850                                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01851"></a>01851                                         req-&gt;rq_resend = 1;
<a name="l01852"></a>01852                                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01853"></a>01853 
<a name="l01854"></a>01854                                         <span class="keywordflow">if</span> (req-&gt;rq_bulk != NULL &amp;&amp;
<a name="l01855"></a>01855                                             !<a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(req, 1))
<a name="l01856"></a>01856                                                 <span class="keywordflow">continue</span>;
<a name="l01857"></a>01857                                 }
<a name="l01858"></a>01858                                 <span class="comment">/*</span>
<a name="l01859"></a>01859 <span class="comment">                                 * rq_wait_ctx is only touched by ptlrpcd,</span>
<a name="l01860"></a>01860 <span class="comment">                                 * so no lock is needed here.</span>
<a name="l01861"></a>01861 <span class="comment">                                 */</span>
<a name="l01862"></a>01862                                 status = <a class="code" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&amp;#39;s not up-to-date.">sptlrpc_req_refresh_ctx</a>(req, -1);
<a name="l01863"></a>01863                                 <span class="keywordflow">if</span> (status) {
<a name="l01864"></a>01864                                         <span class="keywordflow">if</span> (req-&gt;rq_err) {
<a name="l01865"></a>01865                                                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = status;
<a name="l01866"></a>01866                                                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01867"></a>01867                                                 req-&gt;rq_wait_ctx = 0;
<a name="l01868"></a>01868                                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01869"></a>01869                                                 force_timer_recalc = 1;
<a name="l01870"></a>01870                                         } <span class="keywordflow">else</span> {
<a name="l01871"></a>01871                                                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01872"></a>01872                                                 req-&gt;rq_wait_ctx = 1;
<a name="l01873"></a>01873                                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01874"></a>01874                                         }
<a name="l01875"></a>01875 
<a name="l01876"></a>01876                                         <span class="keywordflow">continue</span>;
<a name="l01877"></a>01877                                 } <span class="keywordflow">else</span> {
<a name="l01878"></a>01878                                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01879"></a>01879                                         req-&gt;rq_wait_ctx = 0;
<a name="l01880"></a>01880                                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01881"></a>01881                                 }
<a name="l01882"></a>01882 
<a name="l01883"></a>01883                                 rc = <a class="code" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request.">ptl_send_rpc</a>(req, 0);
<a name="l01884"></a>01884                                 <span class="keywordflow">if</span> (rc == -ENOMEM) {
<a name="l01885"></a>01885                                         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01886"></a>01886                                         <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>))
<a name="l01887"></a>01887                                                 list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l01888"></a>01888                                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01889"></a>01889                                         ptlrpc_rqphase_move(req, RQ_PHASE_NEW);
<a name="l01890"></a>01890                                         <span class="keywordflow">continue</span>;
<a name="l01891"></a>01891                                 }
<a name="l01892"></a>01892                                 <span class="keywordflow">if</span> (rc) {
<a name="l01893"></a>01893                                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req,
<a name="l01894"></a>01894                                                   <span class="stringliteral">&quot;send failed: rc = %d&quot;</span>, rc);
<a name="l01895"></a>01895                                         force_timer_recalc = 1;
<a name="l01896"></a>01896                                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01897"></a>01897                                         req-&gt;rq_net_err = 1;
<a name="l01898"></a>01898                                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01899"></a>01899                                         <span class="keywordflow">continue</span>;
<a name="l01900"></a>01900                                 }
<a name="l01901"></a>01901                                 <span class="comment">/* need to reset the timeout */</span>
<a name="l01902"></a>01902                                 force_timer_recalc = 1;
<a name="l01903"></a>01903                         }
<a name="l01904"></a>01904 
<a name="l01905"></a>01905                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01906"></a>01906 
<a name="l01907"></a>01907                         <span class="keywordflow">if</span> (ptlrpc_client_early(req)) {
<a name="l01908"></a>01908                                 ptlrpc_at_recv_early_reply(req);
<a name="l01909"></a>01909                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01910"></a>01910                                 <span class="keywordflow">continue</span>;
<a name="l01911"></a>01911                         }
<a name="l01912"></a>01912 
<a name="l01913"></a>01913                         <span class="comment">/* Still waiting for a reply? */</span>
<a name="l01914"></a>01914                         <span class="keywordflow">if</span> (ptlrpc_client_recv(req)) {
<a name="l01915"></a>01915                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01916"></a>01916                                 <span class="keywordflow">continue</span>;
<a name="l01917"></a>01917                         }
<a name="l01918"></a>01918 
<a name="l01919"></a>01919                         <span class="comment">/* Did we actually receive a reply? */</span>
<a name="l01920"></a>01920                         <span class="keywordflow">if</span> (!ptlrpc_client_replied(req)) {
<a name="l01921"></a>01921                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01922"></a>01922                                 <span class="keywordflow">continue</span>;
<a name="l01923"></a>01923                         }
<a name="l01924"></a>01924 
<a name="l01925"></a>01925                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01926"></a>01926 
<a name="l01927"></a>01927                         <span class="comment">/* unlink from net because we are going to</span>
<a name="l01928"></a>01928 <span class="comment">                         * swab in-place of reply buffer */</span>
<a name="l01929"></a>01929                         unregistered = ptlrpc_unregister_reply(req, 1);
<a name="l01930"></a>01930                         <span class="keywordflow">if</span> (!unregistered)
<a name="l01931"></a>01931                                 <span class="keywordflow">continue</span>;
<a name="l01932"></a>01932 
<a name="l01933"></a>01933                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = after_reply(req);
<a name="l01934"></a>01934                         <span class="keywordflow">if</span> (req-&gt;rq_resend)
<a name="l01935"></a>01935                                 <span class="keywordflow">continue</span>;
<a name="l01936"></a>01936 
<a name="l01937"></a>01937                         <span class="comment">/* If there is no bulk associated with this request,</span>
<a name="l01938"></a>01938 <span class="comment">                         * then we&apos;re done and should let the interpreter</span>
<a name="l01939"></a>01939 <span class="comment">                         * process the reply. Similarly if the RPC returned</span>
<a name="l01940"></a>01940 <span class="comment">                         * an error, and therefore the bulk will never arrive.</span>
<a name="l01941"></a>01941 <span class="comment">                         */</span>
<a name="l01942"></a>01942                         <span class="keywordflow">if</span> (req-&gt;rq_bulk == NULL || req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> &lt; 0) {
<a name="l01943"></a>01943                                 ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01944"></a>01944                                 GOTO(interpret, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01945"></a>01945                         }
<a name="l01946"></a>01946 
<a name="l01947"></a>01947                         ptlrpc_rqphase_move(req, RQ_PHASE_BULK);
<a name="l01948"></a>01948                 }
<a name="l01949"></a>01949 
<a name="l01950"></a>01950                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_BULK);
<a name="l01951"></a>01951                 <span class="keywordflow">if</span> (ptlrpc_client_bulk_active(req))
<a name="l01952"></a>01952                         <span class="keywordflow">continue</span>;
<a name="l01953"></a>01953 
<a name="l01954"></a>01954                 <span class="keywordflow">if</span> (req-&gt;rq_bulk-&gt;bd_failure) {
<a name="l01955"></a>01955                         <span class="comment">/* The RPC reply arrived OK, but the bulk screwed</span>
<a name="l01956"></a>01956 <span class="comment">                         * up!  Dead weird since the server told us the RPC</span>
<a name="l01957"></a>01957 <span class="comment">                         * was good after getting the REPLY for her GET or</span>
<a name="l01958"></a>01958 <span class="comment">                         * the ACK for her PUT. */</span>
<a name="l01959"></a>01959                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;bulk transfer failed&quot;</span>);
<a name="l01960"></a>01960                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l01961"></a>01961                 }
<a name="l01962"></a>01962 
<a name="l01963"></a>01963                 ptlrpc_rqphase_move(req, RQ_PHASE_INTERPRET);
<a name="l01964"></a>01964 
<a name="l01965"></a>01965         interpret:
<a name="l01966"></a>01966                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_INTERPRET);
<a name="l01967"></a>01967 
<a name="l01968"></a>01968                 <span class="comment">/* This moves to &quot;unregistering&quot; phase we need to wait for</span>
<a name="l01969"></a>01969 <span class="comment">                 * reply unlink. */</span>
<a name="l01970"></a>01970                 <span class="keywordflow">if</span> (!unregistered &amp;&amp; !ptlrpc_unregister_reply(req, async)) {
<a name="l01971"></a>01971                         <span class="comment">/* start async bulk unlink too */</span>
<a name="l01972"></a>01972                         <a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(req, 1);
<a name="l01973"></a>01973                         <span class="keywordflow">continue</span>;
<a name="l01974"></a>01974                 }
<a name="l01975"></a>01975 
<a name="l01976"></a>01976                 <span class="keywordflow">if</span> (!<a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(req, async))
<a name="l01977"></a>01977                         <span class="keywordflow">continue</span>;
<a name="l01978"></a>01978 
<a name="l01979"></a>01979                 <span class="comment">/* When calling interpret receiving already should be</span>
<a name="l01980"></a>01980 <span class="comment">                 * finished. */</span>
<a name="l01981"></a>01981                 LASSERT(!req-&gt;rq_receiving_reply);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983                 ptlrpc_req_interpret(env, req, req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>);
<a name="l01984"></a>01984 
<a name="l01985"></a>01985                 <span class="keywordflow">if</span> (ptlrpcd_check_work(req)) {
<a name="l01986"></a>01986                         atomic_dec(&amp;set-&gt;set_remaining);
<a name="l01987"></a>01987                         <span class="keywordflow">continue</span>;
<a name="l01988"></a>01988                 }
<a name="l01989"></a>01989                 ptlrpc_rqphase_move(req, RQ_PHASE_COMPLETE);
<a name="l01990"></a>01990 
<a name="l01991"></a>01991                 CDEBUG(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> != NULL ? D_RPCTRACE : 0,
<a name="l01992"></a>01992                         <span class="stringliteral">&quot;Completed RPC pname:cluuid:pid:xid:nid:&quot;</span>
<a name="l01993"></a>01993                         <span class="stringliteral">&quot;opc %s:%s:%d:&quot;</span>LPU64<span class="stringliteral">&quot;:%s:%d\n&quot;</span>,
<a name="l01994"></a>01994                         current_comm(), imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_uuid.uuid,
<a name="l01995"></a>01995                         lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>), req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>,
<a name="l01996"></a>01996                         libcfs_nid2str(imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>),
<a name="l01997"></a>01997                         lustre_msg_get_opc(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l01998"></a>01998 
<a name="l01999"></a>01999                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02000"></a>02000                 <span class="comment">/* Request already may be not on sending or delaying list. This</span>
<a name="l02001"></a>02001 <span class="comment">                 * may happen in the case of marking it erroneous for the case</span>
<a name="l02002"></a>02002 <span class="comment">                 * ptlrpc_import_delay_req(req, status) find it impossible to</span>
<a name="l02003"></a>02003 <span class="comment">                 * allow sending this rpc and returns *status != 0. */</span>
<a name="l02004"></a>02004                 <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>)) {
<a name="l02005"></a>02005                         list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l02006"></a>02006                         atomic_dec(&amp;imp-&gt;<a class="code" href="structobd__import.html#aece380c78562b6b0ddbfb1b5460fcbb2" title="Number of requests currently in-flight.">imp_inflight</a>);
<a name="l02007"></a>02007                 }
<a name="l02008"></a>02008                 list_del_init(&amp;req-&gt;rq_unreplied_list);
<a name="l02009"></a>02009                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02010"></a>02010 
<a name="l02011"></a>02011                 atomic_dec(&amp;set-&gt;set_remaining);
<a name="l02012"></a>02012                 wake_up_all(&amp;imp-&gt;<a class="code" href="structobd__import.html#a43b896a006360181311cd5c246bd7c8b" title="Wait queue for those who need to wait for recovery completion.">imp_recovery_waitq</a>);
<a name="l02013"></a>02013 
<a name="l02014"></a>02014                 <span class="keywordflow">if</span> (set-&gt;set_producer) {
<a name="l02015"></a>02015                         <span class="comment">/* produce a new request if possible */</span>
<a name="l02016"></a>02016                         <span class="keywordflow">if</span> (ptlrpc_set_producer(<span class="keyword">set</span>) &gt; 0)
<a name="l02017"></a>02017                                 force_timer_recalc = 1;
<a name="l02018"></a>02018 
<a name="l02019"></a>02019                         <span class="comment">/* free the request that has just been completed</span>
<a name="l02020"></a>02020 <span class="comment">                         * in order not to pollute set-&gt;set_requests */</span>
<a name="l02021"></a>02021                         list_del_init(&amp;req-&gt;rq_set_chain);
<a name="l02022"></a>02022                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02023"></a>02023                         req-&gt;rq_set = NULL;
<a name="l02024"></a>02024                         req-&gt;<a class="code" href="structptlrpc__request.html#a3c7a9c4f0292826fffa36e3ab1cedf47" title="whether the &amp;quot;rq_set&amp;quot; is a valid one">rq_invalid_rqset</a> = 0;
<a name="l02025"></a>02025                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02026"></a>02026 
<a name="l02027"></a>02027                         <span class="comment">/* record rq_status to compute the final status later */</span>
<a name="l02028"></a>02028                         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != 0)
<a name="l02029"></a>02029                                 <span class="keyword">set</span>-&gt;set_rc = req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>;
<a name="l02030"></a>02030                         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l02031"></a>02031                 } <span class="keywordflow">else</span> {
<a name="l02032"></a>02032                         list_move_tail(&amp;req-&gt;rq_set_chain, &amp;comp_reqs);
<a name="l02033"></a>02033                 }
<a name="l02034"></a>02034         }
<a name="l02035"></a>02035 
<a name="l02036"></a>02036         <span class="comment">/* move completed request at the head of list so it&apos;s easier for</span>
<a name="l02037"></a>02037 <span class="comment">         * caller to find them */</span>
<a name="l02038"></a>02038         list_splice(&amp;comp_reqs, &amp;set-&gt;set_requests);
<a name="l02039"></a>02039 
<a name="l02040"></a>02040         <span class="comment">/* If we hit an error, we want to recover promptly. */</span>
<a name="l02041"></a>02041         RETURN(atomic_read(&amp;set-&gt;set_remaining) == 0 || force_timer_recalc);
<a name="l02042"></a>02042 }
<a name="l02043"></a>02043 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies...">ptlrpc_check_set</a>);
<a name="l02044"></a>02044 
<a name="l02050"></a>02050 <span class="keywordtype">int</span> ptlrpc_expire_one_request(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> async_unlink)
<a name="l02051"></a>02051 {
<a name="l02052"></a>02052         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l02053"></a>02053         <span class="keywordtype">int</span> rc = 0;
<a name="l02054"></a>02054         ENTRY;
<a name="l02055"></a>02055 
<a name="l02056"></a>02056         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02057"></a>02057         req-&gt;rq_timedout = 1;
<a name="l02058"></a>02058         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02059"></a>02059 
<a name="l02060"></a>02060         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_WARNING, req, <span class="stringliteral">&quot;Request sent has %s: [sent &quot;</span>CFS_DURATION_T
<a name="l02061"></a>02061                   <span class="stringliteral">&quot;/real &quot;</span>CFS_DURATION_T<span class="stringliteral">&quot;]&quot;</span>,
<a name="l02062"></a>02062                   req-&gt;rq_net_err ? <span class="stringliteral">&quot;failed due to network error&quot;</span> :
<a name="l02063"></a>02063                      ((req-&gt;rq_real_sent == 0 ||
<a name="l02064"></a>02064                        cfs_time_before(req-&gt;rq_real_sent, req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a>) ||
<a name="l02065"></a>02065                        cfs_time_aftereq(req-&gt;rq_real_sent, req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>)) ?
<a name="l02066"></a>02066                       <span class="stringliteral">&quot;timed out for sent delay&quot;</span> : <span class="stringliteral">&quot;timed out for slow reply&quot;</span>),
<a name="l02067"></a>02067                   req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a>, req-&gt;rq_real_sent);
<a name="l02068"></a>02068 
<a name="l02069"></a>02069         <span class="keywordflow">if</span> (imp != NULL &amp;&amp; obd_debug_peer_on_timeout)
<a name="l02070"></a>02070                 LNetDebugPeer(imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>);
<a name="l02071"></a>02071 
<a name="l02072"></a>02072         ptlrpc_unregister_reply(req, async_unlink);
<a name="l02073"></a>02073         <a class="code" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network.">ptlrpc_unregister_bulk</a>(req, async_unlink);
<a name="l02074"></a>02074 
<a name="l02075"></a>02075         <span class="keywordflow">if</span> (obd_dump_on_timeout)
<a name="l02076"></a>02076                 libcfs_debug_dumplog();
<a name="l02077"></a>02077 
<a name="l02078"></a>02078         <span class="keywordflow">if</span> (imp == NULL) {
<a name="l02079"></a>02079                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;NULL import: already cleaned up?&quot;</span>);
<a name="l02080"></a>02080                 RETURN(1);
<a name="l02081"></a>02081         }
<a name="l02082"></a>02082 
<a name="l02083"></a>02083         atomic_inc(&amp;imp-&gt;<a class="code" href="structobd__import.html#ac85d638b38be23357799a2fc444eb585" title="Numbner of request timeouts.">imp_timeouts</a>);
<a name="l02084"></a>02084 
<a name="l02085"></a>02085         <span class="comment">/* The DLM server doesn&apos;t want recovery run on its imports. */</span>
<a name="l02086"></a>02086         <span class="keywordflow">if</span> (imp-&gt;imp_dlm_fake)
<a name="l02087"></a>02087                 RETURN(1);
<a name="l02088"></a>02088 
<a name="l02089"></a>02089         <span class="comment">/* If this request is for recovery or other primordial tasks,</span>
<a name="l02090"></a>02090 <span class="comment">         * then error it out here. */</span>
<a name="l02091"></a>02091         <span class="keywordflow">if</span> (req-&gt;rq_ctx_init || req-&gt;rq_ctx_fini ||
<a name="l02092"></a>02092             req-&gt;rq_send_state != LUSTRE_IMP_FULL ||
<a name="l02093"></a>02093             imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_no_recov) {
<a name="l02094"></a>02094                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;err -110, sent_state=%s (now=%s)&quot;</span>,
<a name="l02095"></a>02095                           ptlrpc_import_state_name(req-&gt;rq_send_state),
<a name="l02096"></a>02096                           ptlrpc_import_state_name(imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a>));
<a name="l02097"></a>02097                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02098"></a>02098                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -ETIMEDOUT;
<a name="l02099"></a>02099                 req-&gt;rq_err = 1;
<a name="l02100"></a>02100                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02101"></a>02101                 RETURN(1);
<a name="l02102"></a>02102         }
<a name="l02103"></a>02103 
<a name="l02104"></a>02104         <span class="comment">/* if a request can&apos;t be resent we can&apos;t wait for an answer after</span>
<a name="l02105"></a>02105 <span class="comment">           the timeout */</span>
<a name="l02106"></a>02106         <span class="keywordflow">if</span> (ptlrpc_no_resend(req)) {
<a name="l02107"></a>02107                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;TIMEOUT-NORESEND:&quot;</span>);
<a name="l02108"></a>02108                 rc = 1;
<a name="l02109"></a>02109         }
<a name="l02110"></a>02110 
<a name="l02111"></a>02111         ptlrpc_fail_import(imp, lustre_msg_get_conn_cnt(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l02112"></a>02112 
<a name="l02113"></a>02113         RETURN(rc);
<a name="l02114"></a>02114 }
<a name="l02115"></a>02115 
<a name="l02121"></a>02121 <span class="keywordtype">int</span> ptlrpc_expired_set(<span class="keywordtype">void</span> *data)
<a name="l02122"></a>02122 {
<a name="l02123"></a>02123         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a>       *<span class="keyword">set</span> = data;
<a name="l02124"></a>02124         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                *tmp;
<a name="l02125"></a>02125         time_t                          now = cfs_time_current_sec();
<a name="l02126"></a>02126         ENTRY;
<a name="l02127"></a>02127 
<a name="l02128"></a>02128         LASSERT(<span class="keyword">set</span> != NULL);
<a name="l02129"></a>02129 
<a name="l02130"></a>02130         <span class="comment">/*</span>
<a name="l02131"></a>02131 <span class="comment">         * A timeout expired. See which reqs it applies to...</span>
<a name="l02132"></a>02132 <span class="comment">         */</span>
<a name="l02133"></a>02133         list_for_each(tmp, &amp;set-&gt;set_requests) {
<a name="l02134"></a>02134                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l02135"></a>02135                         list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l02136"></a>02136                                    rq_set_chain);
<a name="l02137"></a>02137 
<a name="l02138"></a>02138                 <span class="comment">/* don&apos;t expire request waiting for context */</span>
<a name="l02139"></a>02139                 <span class="keywordflow">if</span> (req-&gt;rq_wait_ctx)
<a name="l02140"></a>02140                         <span class="keywordflow">continue</span>;
<a name="l02141"></a>02141 
<a name="l02142"></a>02142                 <span class="comment">/* Request in-flight? */</span>
<a name="l02143"></a>02143                 <span class="keywordflow">if</span> (!((req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_RPC &amp;&amp;
<a name="l02144"></a>02144                        !req-&gt;rq_waiting &amp;&amp; !req-&gt;rq_resend) ||
<a name="l02145"></a>02145                       (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_BULK)))
<a name="l02146"></a>02146                         <span class="keywordflow">continue</span>;
<a name="l02147"></a>02147 
<a name="l02148"></a>02148                 <span class="keywordflow">if</span> (req-&gt;rq_timedout ||     <span class="comment">/* already dealt with */</span>
<a name="l02149"></a>02149                     req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> &gt; now) <span class="comment">/* not expired */</span>
<a name="l02150"></a>02150                         <span class="keywordflow">continue</span>;
<a name="l02151"></a>02151 
<a name="l02152"></a>02152                 <span class="comment">/* Deal with this guy. Do it asynchronously to not block</span>
<a name="l02153"></a>02153 <span class="comment">                 * ptlrpcd thread. */</span>
<a name="l02154"></a>02154                 ptlrpc_expire_one_request(req, 1);
<a name="l02155"></a>02155         }
<a name="l02156"></a>02156 
<a name="l02157"></a>02157         <span class="comment">/*</span>
<a name="l02158"></a>02158 <span class="comment">         * When waiting for a whole set, we always break out of the</span>
<a name="l02159"></a>02159 <span class="comment">         * sleep so we can recalculate the timeout, or enable interrupts</span>
<a name="l02160"></a>02160 <span class="comment">         * if everyone&apos;s timed out.</span>
<a name="l02161"></a>02161 <span class="comment">         */</span>
<a name="l02162"></a>02162         RETURN(1);
<a name="l02163"></a>02163 }
<a name="l02164"></a>02164 
<a name="l02168"></a><a class="code" href="group__net.html#gaf50ebcc46ea5f7316c23362915fd5ce7">02168</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gaf50ebcc46ea5f7316c23362915fd5ce7" title="Sets rq_intr flag in req under spinlock.">ptlrpc_mark_interrupted</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02169"></a>02169 {
<a name="l02170"></a>02170         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02171"></a>02171         req-&gt;<a class="code" href="structptlrpc__request.html#a6d4f6fc90fdcc8e2492f4ab902147970" title="client-side flags are serialized by rq_lock">rq_intr</a> = 1;
<a name="l02172"></a>02172         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02173"></a>02173 }
<a name="l02174"></a>02174 EXPORT_SYMBOL(<a class="code" href="group__net.html#gaf50ebcc46ea5f7316c23362915fd5ce7" title="Sets rq_intr flag in req under spinlock.">ptlrpc_mark_interrupted</a>);
<a name="l02175"></a>02175 
<a name="l02180"></a>02180 <span class="keyword">static</span> <span class="keywordtype">void</span> ptlrpc_interrupted_set(<span class="keywordtype">void</span> *data)
<a name="l02181"></a>02181 {
<a name="l02182"></a>02182         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span> = data;
<a name="l02183"></a>02183         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp;
<a name="l02184"></a>02184 
<a name="l02185"></a>02185         LASSERT(<span class="keyword">set</span> != NULL);
<a name="l02186"></a>02186         CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;INTERRUPTED SET %p\n&quot;</span>, <span class="keyword">set</span>);
<a name="l02187"></a>02187 
<a name="l02188"></a>02188         list_for_each(tmp, &amp;set-&gt;set_requests) {
<a name="l02189"></a>02189                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l02190"></a>02190                         list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, rq_set_chain);
<a name="l02191"></a>02191 
<a name="l02192"></a>02192                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a6d4f6fc90fdcc8e2492f4ab902147970" title="client-side flags are serialized by rq_lock">rq_intr</a>)
<a name="l02193"></a>02193                         <span class="keywordflow">continue</span>;
<a name="l02194"></a>02194 
<a name="l02195"></a>02195                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> != RQ_PHASE_RPC &amp;&amp;
<a name="l02196"></a>02196                     req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> != RQ_PHASE_UNREGISTERING &amp;&amp;
<a name="l02197"></a>02197                     !req-&gt;rq_allow_intr)
<a name="l02198"></a>02198                         <span class="keywordflow">continue</span>;
<a name="l02199"></a>02199 
<a name="l02200"></a>02200                 <a class="code" href="group__net.html#gaf50ebcc46ea5f7316c23362915fd5ce7" title="Sets rq_intr flag in req under spinlock.">ptlrpc_mark_interrupted</a>(req);
<a name="l02201"></a>02201         }
<a name="l02202"></a>02202 }
<a name="l02203"></a>02203 
<a name="l02207"></a>02207 <span class="keywordtype">int</span> ptlrpc_set_next_timeout(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>)
<a name="l02208"></a>02208 {
<a name="l02209"></a>02209         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *tmp;
<a name="l02210"></a>02210         time_t                   now = cfs_time_current_sec();
<a name="l02211"></a>02211         <span class="keywordtype">int</span>                      timeout = 0;
<a name="l02212"></a>02212         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *req;
<a name="l02213"></a>02213         <span class="keywordtype">int</span>                      deadline;
<a name="l02214"></a>02214         ENTRY;
<a name="l02215"></a>02215 
<a name="l02216"></a>02216         list_for_each(tmp, &amp;set-&gt;set_requests) {
<a name="l02217"></a>02217                 req = list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, rq_set_chain);
<a name="l02218"></a>02218 
<a name="l02219"></a>02219                 <span class="comment">/*</span>
<a name="l02220"></a>02220 <span class="comment">                 * Request in-flight?</span>
<a name="l02221"></a>02221 <span class="comment">                 */</span>
<a name="l02222"></a>02222                 <span class="keywordflow">if</span> (!(((req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_RPC) &amp;&amp; !req-&gt;rq_waiting) ||
<a name="l02223"></a>02223                       (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_BULK) ||
<a name="l02224"></a>02224                       (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW)))
<a name="l02225"></a>02225                         <span class="keywordflow">continue</span>;
<a name="l02226"></a>02226 
<a name="l02227"></a>02227                 <span class="comment">/*</span>
<a name="l02228"></a>02228 <span class="comment">                 * Already timed out.</span>
<a name="l02229"></a>02229 <span class="comment">                 */</span>
<a name="l02230"></a>02230                 <span class="keywordflow">if</span> (req-&gt;rq_timedout)
<a name="l02231"></a>02231                         <span class="keywordflow">continue</span>;
<a name="l02232"></a>02232 
<a name="l02233"></a>02233                 <span class="comment">/*</span>
<a name="l02234"></a>02234 <span class="comment">                 * Waiting for ctx.</span>
<a name="l02235"></a>02235 <span class="comment">                 */</span>
<a name="l02236"></a>02236                 <span class="keywordflow">if</span> (req-&gt;rq_wait_ctx)
<a name="l02237"></a>02237                         <span class="keywordflow">continue</span>;
<a name="l02238"></a>02238 
<a name="l02239"></a>02239                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW)
<a name="l02240"></a>02240                         deadline = req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a>;
<a name="l02241"></a>02241                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_RPC &amp;&amp; req-&gt;rq_resend)
<a name="l02242"></a>02242                         deadline = req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a>;
<a name="l02243"></a>02243                 <span class="keywordflow">else</span>
<a name="l02244"></a>02244                         deadline = req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> + req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>;
<a name="l02245"></a>02245 
<a name="l02246"></a>02246                 <span class="keywordflow">if</span> (deadline &lt;= now)    <span class="comment">/* actually expired already */</span>
<a name="l02247"></a>02247                         timeout = 1;    <span class="comment">/* ASAP */</span>
<a name="l02248"></a>02248                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (timeout == 0 || timeout &gt; deadline - now)
<a name="l02249"></a>02249                         timeout = deadline - now;
<a name="l02250"></a>02250         }
<a name="l02251"></a>02251         RETURN(timeout);
<a name="l02252"></a>02252 }
<a name="l02253"></a>02253 
<a name="l02260"></a><a class="code" href="group__net.html#gac072432ff0e3366be99c8456895e28d1">02260</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set...">ptlrpc_set_wait</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>)
<a name="l02261"></a>02261 {
<a name="l02262"></a>02262         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>            *tmp;
<a name="l02263"></a>02263         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l02264"></a>02264         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>     lwi;
<a name="l02265"></a>02265         <span class="keywordtype">int</span>                    rc, timeout;
<a name="l02266"></a>02266         ENTRY;
<a name="l02267"></a>02267 
<a name="l02268"></a>02268         <span class="keywordflow">if</span> (set-&gt;set_producer)
<a name="l02269"></a>02269                 (void)ptlrpc_set_producer(<span class="keyword">set</span>);
<a name="l02270"></a>02270         <span class="keywordflow">else</span>
<a name="l02271"></a>02271                 list_for_each(tmp, &amp;set-&gt;set_requests) {
<a name="l02272"></a>02272                         req = list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l02273"></a>02273                                          rq_set_chain);
<a name="l02274"></a>02274                         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_NEW)
<a name="l02275"></a>02275                                 (void)ptlrpc_send_new_req(req);
<a name="l02276"></a>02276                 }
<a name="l02277"></a>02277 
<a name="l02278"></a>02278         <span class="keywordflow">if</span> (list_empty(&amp;set-&gt;set_requests))
<a name="l02279"></a>02279                 RETURN(0);
<a name="l02280"></a>02280 
<a name="l02281"></a>02281         <span class="keywordflow">do</span> {
<a name="l02282"></a>02282                 timeout = ptlrpc_set_next_timeout(<span class="keyword">set</span>);
<a name="l02283"></a>02283 
<a name="l02284"></a>02284                 <span class="comment">/* wait until all complete, interrupted, or an in-flight</span>
<a name="l02285"></a>02285 <span class="comment">                 * req times out */</span>
<a name="l02286"></a>02286                 CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;set %p going to sleep for %d seconds\n&quot;</span>,
<a name="l02287"></a>02287                        <span class="keyword">set</span>, timeout);
<a name="l02288"></a>02288 
<a name="l02289"></a>02289                 <span class="keywordflow">if</span> ((timeout == 0 &amp;&amp; !signal_pending(current)) ||
<a name="l02290"></a>02290                     set-&gt;set_allow_intr)
<a name="l02291"></a>02291                         <span class="comment">/* No requests are in-flight (ether timed out</span>
<a name="l02292"></a>02292 <span class="comment">                         * or delayed), so we can allow interrupts.</span>
<a name="l02293"></a>02293 <span class="comment">                         * We still want to block for a limited time,</span>
<a name="l02294"></a>02294 <span class="comment">                         * so we allow interrupts during the timeout. */</span>
<a name="l02295"></a>02295                         lwi = LWI_TIMEOUT_INTR_ALL(
<a name="l02296"></a>02296                                         cfs_time_seconds(timeout ? timeout : 1),
<a name="l02297"></a>02297                                         ptlrpc_expired_set,
<a name="l02298"></a>02298                                         ptlrpc_interrupted_set, <span class="keyword">set</span>);
<a name="l02299"></a>02299                 <span class="keywordflow">else</span>
<a name="l02300"></a>02300                         <span class="comment">/*</span>
<a name="l02301"></a>02301 <span class="comment">                         * At least one request is in flight, so no</span>
<a name="l02302"></a>02302 <span class="comment">                         * interrupts are allowed. Wait until all</span>
<a name="l02303"></a>02303 <span class="comment">                         * complete, or an in-flight req times out.</span>
<a name="l02304"></a>02304 <span class="comment">                         */</span>
<a name="l02305"></a>02305                         lwi = LWI_TIMEOUT(cfs_time_seconds(timeout? timeout : 1),
<a name="l02306"></a>02306                                           ptlrpc_expired_set, <span class="keyword">set</span>);
<a name="l02307"></a>02307 
<a name="l02308"></a>02308                 rc = l_wait_event(set-&gt;set_waitq, <a class="code" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies...">ptlrpc_check_set</a>(NULL, <span class="keyword">set</span>), &amp;lwi);
<a name="l02309"></a>02309 
<a name="l02310"></a>02310                 <span class="comment">/* LU-769 - if we ignored the signal because it was already</span>
<a name="l02311"></a>02311 <span class="comment">                 * pending when we started, we need to handle it now or we risk</span>
<a name="l02312"></a>02312 <span class="comment">                 * it being ignored forever */</span>
<a name="l02313"></a>02313                 <span class="keywordflow">if</span> (rc == -ETIMEDOUT &amp;&amp;
<a name="l02314"></a>02314                     (!lwi.lwi_allow_intr || set-&gt;set_allow_intr) &amp;&amp;
<a name="l02315"></a>02315                     signal_pending(current)) {
<a name="l02316"></a>02316                         sigset_t blocked_sigs =
<a name="l02317"></a>02317                                            cfs_block_sigsinv(LUSTRE_FATAL_SIGS);
<a name="l02318"></a>02318 
<a name="l02319"></a>02319                         <span class="comment">/* In fact we only interrupt for the &quot;fatal&quot; signals</span>
<a name="l02320"></a>02320 <span class="comment">                         * like SIGINT or SIGKILL. We still ignore less</span>
<a name="l02321"></a>02321 <span class="comment">                         * important signals since ptlrpc set is not easily</span>
<a name="l02322"></a>02322 <span class="comment">                         * reentrant from userspace again */</span>
<a name="l02323"></a>02323                         <span class="keywordflow">if</span> (signal_pending(current))
<a name="l02324"></a>02324                                 ptlrpc_interrupted_set(<span class="keyword">set</span>);
<a name="l02325"></a>02325                         cfs_restore_sigs(blocked_sigs);
<a name="l02326"></a>02326                 }
<a name="l02327"></a>02327 
<a name="l02328"></a>02328                 LASSERT(rc == 0 || rc == -EINTR || rc == -ETIMEDOUT);
<a name="l02329"></a>02329 
<a name="l02330"></a>02330                 <span class="comment">/* -EINTR =&gt; all requests have been flagged rq_intr so next</span>
<a name="l02331"></a>02331 <span class="comment">                 * check completes.</span>
<a name="l02332"></a>02332 <span class="comment">                 * -ETIMEDOUT =&gt; someone timed out.  When all reqs have</span>
<a name="l02333"></a>02333 <span class="comment">                 * timed out, signals are enabled allowing completion with</span>
<a name="l02334"></a>02334 <span class="comment">                 * EINTR.</span>
<a name="l02335"></a>02335 <span class="comment">                 * I don&apos;t really care if we go once more round the loop in</span>
<a name="l02336"></a>02336 <span class="comment">                 * the error cases -eeb. */</span>
<a name="l02337"></a>02337                 <span class="keywordflow">if</span> (rc == 0 &amp;&amp; atomic_read(&amp;set-&gt;set_remaining) == 0) {
<a name="l02338"></a>02338                         list_for_each(tmp, &amp;set-&gt;set_requests) {
<a name="l02339"></a>02339                                 req = list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l02340"></a>02340                                                  rq_set_chain);
<a name="l02341"></a>02341                                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02342"></a>02342                                 req-&gt;<a class="code" href="structptlrpc__request.html#a3c7a9c4f0292826fffa36e3ab1cedf47" title="whether the &amp;quot;rq_set&amp;quot; is a valid one">rq_invalid_rqset</a> = 1;
<a name="l02343"></a>02343                                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02344"></a>02344                         }
<a name="l02345"></a>02345                 }
<a name="l02346"></a>02346         } <span class="keywordflow">while</span> (rc != 0 || atomic_read(&amp;set-&gt;set_remaining) != 0);
<a name="l02347"></a>02347 
<a name="l02348"></a>02348         LASSERT(atomic_read(&amp;set-&gt;set_remaining) == 0);
<a name="l02349"></a>02349 
<a name="l02350"></a>02350         rc = <span class="keyword">set</span>-&gt;set_rc; <span class="comment">/* rq_status of already freed requests if any */</span>
<a name="l02351"></a>02351         list_for_each(tmp, &amp;set-&gt;set_requests) {
<a name="l02352"></a>02352                 req = list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, rq_set_chain);
<a name="l02353"></a>02353 
<a name="l02354"></a>02354                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> == RQ_PHASE_COMPLETE);
<a name="l02355"></a>02355                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> != 0)
<a name="l02356"></a>02356                         rc = req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>;
<a name="l02357"></a>02357         }
<a name="l02358"></a>02358 
<a name="l02359"></a>02359         <span class="keywordflow">if</span> (set-&gt;set_interpret != NULL) {
<a name="l02360"></a>02360                 int (*interpreter)(<span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>,<span class="keywordtype">void</span> *,int) =
<a name="l02361"></a>02361                         set-&gt;set_interpret;
<a name="l02362"></a>02362                 rc = interpreter (<span class="keyword">set</span>, set-&gt;set_arg, rc);
<a name="l02363"></a>02363         } <span class="keywordflow">else</span> {
<a name="l02364"></a>02364                 <span class="keyword">struct </span><a class="code" href="structptlrpc__set__cbdata.html" title="Description of a single ptrlrpc_set callback.">ptlrpc_set_cbdata</a> *cbdata, *n;
<a name="l02365"></a>02365                 <span class="keywordtype">int</span> err;
<a name="l02366"></a>02366 
<a name="l02367"></a>02367                 list_for_each_entry_safe(cbdata, n,
<a name="l02368"></a>02368                                          &amp;set-&gt;set_cblist, <a class="code" href="structptlrpc__set__cbdata.html#a72f1ec9f7c8e7a2f8ea2e123bf4c0444" title="List linkage item.">psc_item</a>) {
<a name="l02369"></a>02369                         list_del_init(&amp;cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#a72f1ec9f7c8e7a2f8ea2e123bf4c0444" title="List linkage item.">psc_item</a>);
<a name="l02370"></a>02370                         err = cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#a7122f5f29318e70ed85129a2195bc247" title="Pointer to interpreting function.">psc_interpret</a>(<span class="keyword">set</span>, cbdata-&gt;<a class="code" href="structptlrpc__set__cbdata.html#acf9721671bfcc548e1e5fe4276ba9b5c" title="Opaq argument to pass to the callback.">psc_data</a>, rc);
<a name="l02371"></a>02371                         <span class="keywordflow">if</span> (err &amp;&amp; !rc)
<a name="l02372"></a>02372                                 rc = err;
<a name="l02373"></a>02373                         OBD_FREE_PTR(cbdata);
<a name="l02374"></a>02374                 }
<a name="l02375"></a>02375         }
<a name="l02376"></a>02376 
<a name="l02377"></a>02377         RETURN(rc);
<a name="l02378"></a>02378 }
<a name="l02379"></a>02379 EXPORT_SYMBOL(<a class="code" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set...">ptlrpc_set_wait</a>);
<a name="l02380"></a>02380 
<a name="l02389"></a>02389 <span class="keyword">static</span> <span class="keywordtype">void</span> __ptlrpc_free_req(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request, <span class="keywordtype">int</span> locked)
<a name="l02390"></a>02390 {
<a name="l02391"></a>02391         ENTRY;
<a name="l02392"></a>02392 
<a name="l02393"></a>02393         <span class="keywordflow">if</span> (request == NULL)
<a name="l02394"></a>02394                 RETURN_EXIT;
<a name="l02395"></a>02395 
<a name="l02396"></a>02396         LASSERT(!request-&gt;rq_srv_req);
<a name="l02397"></a>02397         LASSERT(request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> == NULL);
<a name="l02398"></a>02398         LASSERTF(!request-&gt;rq_receiving_reply, <span class="stringliteral">&quot;req %p\n&quot;</span>, request);
<a name="l02399"></a>02399         LASSERTF(list_empty(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>), <span class="stringliteral">&quot;req %p\n&quot;</span>, request);
<a name="l02400"></a>02400         LASSERTF(list_empty(&amp;request-&gt;rq_set_chain), <span class="stringliteral">&quot;req %p\n&quot;</span>, request);
<a name="l02401"></a>02401         LASSERTF(!request-&gt;<a class="code" href="structptlrpc__request.html#ae9b053a81331ff81f4568df30b253bf0" title="when -&amp;gt;rq_replay is set, request is kept by the client even after server commits...">rq_replay</a>, <span class="stringliteral">&quot;req %p\n&quot;</span>, request);
<a name="l02402"></a>02402 
<a name="l02403"></a>02403         req_capsule_fini(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>);
<a name="l02404"></a>02404 
<a name="l02405"></a>02405         <span class="comment">/* We must take it off the imp_replay_list first.  Otherwise, we&apos;ll set</span>
<a name="l02406"></a>02406 <span class="comment">         * request-&gt;rq_reqmsg to NULL while osc_close is dereferencing it. */</span>
<a name="l02407"></a>02407         <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a> != NULL) {
<a name="l02408"></a>02408                 <span class="keywordflow">if</span> (!locked)
<a name="l02409"></a>02409                         spin_lock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02410"></a>02410                 list_del_init(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>);
<a name="l02411"></a>02411                 list_del_init(&amp;request-&gt;rq_unreplied_list);
<a name="l02412"></a>02412                 <span class="keywordflow">if</span> (!locked)
<a name="l02413"></a>02413                         spin_unlock(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02414"></a>02414         }
<a name="l02415"></a>02415         LASSERTF(list_empty(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>), <span class="stringliteral">&quot;req %p\n&quot;</span>, request);
<a name="l02416"></a>02416 
<a name="l02417"></a>02417         <span class="keywordflow">if</span> (atomic_read(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>) != 0) {
<a name="l02418"></a>02418                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, request,
<a name="l02419"></a>02419                           <span class="stringliteral">&quot;freeing request with nonzero refcount&quot;</span>);
<a name="l02420"></a>02420                 LBUG();
<a name="l02421"></a>02421         }
<a name="l02422"></a>02422 
<a name="l02423"></a>02423         <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a> != NULL)
<a name="l02424"></a>02424                 <a class="code" href="group__sptlrpc.html#ga6cd89bd371e4a81930e260bb1b8c79f8" title="Used by ptlrpc client to free reply buffer of req.">sptlrpc_cli_free_repbuf</a>(request);
<a name="l02425"></a>02425 
<a name="l02426"></a>02426         <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a> != NULL) {
<a name="l02427"></a>02427                 class_import_put(request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>);
<a name="l02428"></a>02428                 request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a> = NULL;
<a name="l02429"></a>02429         }
<a name="l02430"></a>02430         <span class="keywordflow">if</span> (request-&gt;rq_bulk != NULL)
<a name="l02431"></a>02431                 ptlrpc_free_bulk(request-&gt;rq_bulk);
<a name="l02432"></a>02432 
<a name="l02433"></a>02433         <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> != NULL || request-&gt;<a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d" title="only in priv mode">rq_clrbuf</a> != NULL)
<a name="l02434"></a>02434                 <a class="code" href="group__sptlrpc.html#ga2f36863ed408b2fc13f7a04eb6280dd4" title="Used by ptlrpc client to free request buffer of req.">sptlrpc_cli_free_reqbuf</a>(request);
<a name="l02435"></a>02435 
<a name="l02436"></a>02436         <span class="keywordflow">if</span> (request-&gt;rq_cli_ctx)
<a name="l02437"></a>02437                 <a class="code" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req.">sptlrpc_req_put_ctx</a>(request, !locked);
<a name="l02438"></a>02438 
<a name="l02439"></a>02439         <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a>)
<a name="l02440"></a>02440                 __ptlrpc_free_req_to_pool(request);
<a name="l02441"></a>02441         <span class="keywordflow">else</span>
<a name="l02442"></a>02442                 ptlrpc_request_cache_free(request);
<a name="l02443"></a>02443         EXIT;
<a name="l02444"></a>02444 }
<a name="l02445"></a>02445 
<a name="l02446"></a>02446 <span class="keyword">static</span> <span class="keywordtype">int</span> __ptlrpc_req_finished(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request, <span class="keywordtype">int</span> locked);
<a name="l02451"></a><a class="code" href="group__net.html#gac030d75f1b39211b69e4974fc328669d">02451</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gac030d75f1b39211b69e4974fc328669d" title="Drop one request reference.">ptlrpc_req_finished_with_imp_lock</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request)
<a name="l02452"></a>02452 {
<a name="l02453"></a>02453         assert_spin_locked(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02454"></a>02454         (void)__ptlrpc_req_finished(request, 1);
<a name="l02455"></a>02455 }
<a name="l02456"></a>02456 
<a name="l02463"></a>02463 <span class="keyword">static</span> <span class="keywordtype">int</span> __ptlrpc_req_finished(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request, <span class="keywordtype">int</span> locked)
<a name="l02464"></a>02464 {
<a name="l02465"></a>02465         ENTRY;
<a name="l02466"></a>02466         <span class="keywordflow">if</span> (request == NULL)
<a name="l02467"></a>02467                 RETURN(1);
<a name="l02468"></a>02468 
<a name="l02469"></a>02469         <span class="keywordflow">if</span> (request == LP_POISON ||
<a name="l02470"></a>02470             request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> == LP_POISON) {
<a name="l02471"></a>02471                 CERROR(<span class="stringliteral">&quot;dereferencing freed request (bug 575)\n&quot;</span>);
<a name="l02472"></a>02472                 LBUG();
<a name="l02473"></a>02473                 RETURN(1);
<a name="l02474"></a>02474         }
<a name="l02475"></a>02475 
<a name="l02476"></a>02476         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_INFO, request, <span class="stringliteral">&quot;refcount now %u&quot;</span>,
<a name="l02477"></a>02477                   atomic_read(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>) - 1);
<a name="l02478"></a>02478 
<a name="l02479"></a>02479         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>)) {
<a name="l02480"></a>02480                 __ptlrpc_free_req(request, locked);
<a name="l02481"></a>02481                 RETURN(1);
<a name="l02482"></a>02482         }
<a name="l02483"></a>02483 
<a name="l02484"></a>02484         RETURN(0);
<a name="l02485"></a>02485 }
<a name="l02486"></a>02486 
<a name="l02490"></a><a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288">02490</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request)
<a name="l02491"></a>02491 {
<a name="l02492"></a>02492         __ptlrpc_req_finished(request, 0);
<a name="l02493"></a>02493 }
<a name="l02494"></a>02494 EXPORT_SYMBOL(<a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>);
<a name="l02495"></a>02495 
<a name="l02499"></a><a class="code" href="group__net.html#ga283d8a396288df3e34efd571d9d30018">02499</a> __u64 <a class="code" href="group__net.html#ga283d8a396288df3e34efd571d9d30018" title="Returns xid of a request.">ptlrpc_req_xid</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request)
<a name="l02500"></a>02500 {
<a name="l02501"></a>02501         <span class="keywordflow">return</span> request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>;
<a name="l02502"></a>02502 }
<a name="l02503"></a>02503 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga283d8a396288df3e34efd571d9d30018" title="Returns xid of a request.">ptlrpc_req_xid</a>);
<a name="l02504"></a>02504 
<a name="l02512"></a>02512 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpc_unregister_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request, <span class="keywordtype">int</span> async)
<a name="l02513"></a>02513 {
<a name="l02514"></a>02514         <span class="keywordtype">int</span>                rc;
<a name="l02515"></a>02515         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi;
<a name="l02516"></a>02516 
<a name="l02517"></a>02517         <span class="comment">/*</span>
<a name="l02518"></a>02518 <span class="comment">         * Might sleep.</span>
<a name="l02519"></a>02519 <span class="comment">         */</span>
<a name="l02520"></a>02520         LASSERT(!in_interrupt());
<a name="l02521"></a>02521 
<a name="l02522"></a>02522         <span class="comment">/*</span>
<a name="l02523"></a>02523 <span class="comment">         * Let&apos;s setup deadline for reply unlink.</span>
<a name="l02524"></a>02524 <span class="comment">         */</span>
<a name="l02525"></a>02525         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK) &amp;&amp;
<a name="l02526"></a>02526             async &amp;&amp; request-&gt;rq_reply_deadline == 0)
<a name="l02527"></a>02527                 request-&gt;rq_reply_deadline = cfs_time_current_sec()+LONG_UNLINK;
<a name="l02528"></a>02528 
<a name="l02529"></a>02529         <span class="comment">/*</span>
<a name="l02530"></a>02530 <span class="comment">         * Nothing left to do.</span>
<a name="l02531"></a>02531 <span class="comment">         */</span>
<a name="l02532"></a>02532         <span class="keywordflow">if</span> (!ptlrpc_client_recv_or_unlink(request))
<a name="l02533"></a>02533                 RETURN(1);
<a name="l02534"></a>02534 
<a name="l02535"></a>02535         <a class="code" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink</a>(request-&gt;rq_reply_md_h);
<a name="l02536"></a>02536 
<a name="l02537"></a>02537         <span class="comment">/*</span>
<a name="l02538"></a>02538 <span class="comment">         * Let&apos;s check it once again.</span>
<a name="l02539"></a>02539 <span class="comment">         */</span>
<a name="l02540"></a>02540         <span class="keywordflow">if</span> (!ptlrpc_client_recv_or_unlink(request))
<a name="l02541"></a>02541                 RETURN(1);
<a name="l02542"></a>02542 
<a name="l02543"></a>02543         <span class="comment">/*</span>
<a name="l02544"></a>02544 <span class="comment">         * Move to &quot;Unregistering&quot; phase as reply was not unlinked yet.</span>
<a name="l02545"></a>02545 <span class="comment">         */</span>
<a name="l02546"></a>02546         ptlrpc_rqphase_move(request, RQ_PHASE_UNREGISTERING);
<a name="l02547"></a>02547 
<a name="l02548"></a>02548         <span class="comment">/*</span>
<a name="l02549"></a>02549 <span class="comment">         * Do not wait for unlink to finish.</span>
<a name="l02550"></a>02550 <span class="comment">         */</span>
<a name="l02551"></a>02551         <span class="keywordflow">if</span> (async)
<a name="l02552"></a>02552                 RETURN(0);
<a name="l02553"></a>02553 
<a name="l02554"></a>02554         <span class="comment">/*</span>
<a name="l02555"></a>02555 <span class="comment">         * We have to l_wait_event() whatever the result, to give liblustre</span>
<a name="l02556"></a>02556 <span class="comment">         * a chance to run reply_in_callback(), and to make sure we&apos;ve</span>
<a name="l02557"></a>02557 <span class="comment">         * unlinked before returning a req to the pool.</span>
<a name="l02558"></a>02558 <span class="comment">         */</span>
<a name="l02559"></a>02559         <span class="keywordflow">for</span> (;;) {
<a name="l02560"></a>02560                 <span class="comment">/* The wq argument is ignored by user-space wait_event macros */</span>
<a name="l02561"></a>02561                 wait_queue_head_t *wq = (request-&gt;rq_set != NULL) ?
<a name="l02562"></a>02562                                         &amp;request-&gt;rq_set-&gt;set_waitq :
<a name="l02563"></a>02563                                         &amp;request-&gt;rq_reply_waitq;
<a name="l02564"></a>02564                 <span class="comment">/* Network access will complete in finite time but the HUGE</span>
<a name="l02565"></a>02565 <span class="comment">                 * timeout lets us CWARN for visibility of sluggish NALs */</span>
<a name="l02566"></a>02566                 lwi = LWI_TIMEOUT_INTERVAL(cfs_time_seconds(LONG_UNLINK),
<a name="l02567"></a>02567                                            cfs_time_seconds(1), NULL, NULL);
<a name="l02568"></a>02568                 rc = l_wait_event(*wq, !ptlrpc_client_recv_or_unlink(request),
<a name="l02569"></a>02569                                   &amp;lwi);
<a name="l02570"></a>02570                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l02571"></a>02571                         ptlrpc_rqphase_move(request, request-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a>);
<a name="l02572"></a>02572                         RETURN(1);
<a name="l02573"></a>02573                 }
<a name="l02574"></a>02574 
<a name="l02575"></a>02575                 LASSERT(rc == -ETIMEDOUT);
<a name="l02576"></a>02576                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_WARNING, request, <span class="stringliteral">&quot;Unexpectedly long timeout &quot;</span>
<a name="l02577"></a>02577                           <span class="stringliteral">&quot;receiving_reply=%d req_ulinked=%d reply_unlinked=%d&quot;</span>,
<a name="l02578"></a>02578                           request-&gt;rq_receiving_reply,
<a name="l02579"></a>02579                           request-&gt;rq_req_unlinked,
<a name="l02580"></a>02580                           request-&gt;rq_reply_unlinked);
<a name="l02581"></a>02581         }
<a name="l02582"></a>02582         RETURN(0);
<a name="l02583"></a>02583 }
<a name="l02584"></a>02584 
<a name="l02585"></a>02585 <span class="keyword">static</span> <span class="keywordtype">void</span> ptlrpc_free_request(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02586"></a>02586 {
<a name="l02587"></a>02587         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02588"></a>02588         req-&gt;<a class="code" href="structptlrpc__request.html#ae9b053a81331ff81f4568df30b253bf0" title="when -&amp;gt;rq_replay is set, request is kept by the client even after server commits...">rq_replay</a> = 0;
<a name="l02589"></a>02589         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02590"></a>02590 
<a name="l02591"></a>02591         <span class="keywordflow">if</span> (req-&gt;rq_commit_cb != NULL)
<a name="l02592"></a>02592                 req-&gt;rq_commit_cb(req);
<a name="l02593"></a>02593         list_del_init(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>);
<a name="l02594"></a>02594 
<a name="l02595"></a>02595         __ptlrpc_req_finished(req, 1);
<a name="l02596"></a>02596 }
<a name="l02597"></a>02597 
<a name="l02601"></a><a class="code" href="group__net.html#gacab48d448ba12ade8093383e054814cc">02601</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gacab48d448ba12ade8093383e054814cc" title="Client-side portals API.">ptlrpc_request_committed</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> force)
<a name="l02602"></a>02602 {
<a name="l02603"></a>02603         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a>       *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l02604"></a>02604 
<a name="l02605"></a>02605         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02606"></a>02606         <span class="keywordflow">if</span> (list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>)) {
<a name="l02607"></a>02607                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02608"></a>02608                 <span class="keywordflow">return</span>;
<a name="l02609"></a>02609         }
<a name="l02610"></a>02610 
<a name="l02611"></a>02611         <span class="keywordflow">if</span> (force || req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> &lt;= imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>)
<a name="l02612"></a>02612                 ptlrpc_free_request(req);
<a name="l02613"></a>02613 
<a name="l02614"></a>02614         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02615"></a>02615 }
<a name="l02616"></a>02616 EXPORT_SYMBOL(<a class="code" href="group__net.html#gacab48d448ba12ade8093383e054814cc" title="Client-side portals API.">ptlrpc_request_committed</a>);
<a name="l02617"></a>02617 
<a name="l02626"></a><a class="code" href="group__ha.html#ga1201e450853aba39256bafedcfae7f11">02626</a> <span class="keywordtype">void</span> <a class="code" href="group__ha.html#ga1201e450853aba39256bafedcfae7f11" title="Iterates through replay_list on import and prunes all requests have transno smaller...">ptlrpc_free_committed</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l02627"></a>02627 {
<a name="l02628"></a>02628         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *req, *saved;
<a name="l02629"></a>02629         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *last_req = NULL; <span class="comment">/* temporary fire escape */</span>
<a name="l02630"></a>02630         <span class="keywordtype">bool</span>                     skip_committed_list = <span class="keyword">true</span>;
<a name="l02631"></a>02631         ENTRY;
<a name="l02632"></a>02632 
<a name="l02633"></a>02633         LASSERT(imp != NULL);
<a name="l02634"></a>02634         assert_spin_locked(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02635"></a>02635 
<a name="l02636"></a>02636         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a> == imp-&gt;<a class="code" href="structobd__import.html#a3211da741142c7d7c6997a88825ab6da">imp_last_transno_checked</a> &amp;&amp;
<a name="l02637"></a>02637             imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a> == imp-&gt;<a class="code" href="structobd__import.html#a53945e09c13c835d35ac9c6a4e4c8b5a">imp_last_generation_checked</a>) {
<a name="l02638"></a>02638                 CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: skip recheck: last_committed &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l02639"></a>02639                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name, imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>);
<a name="l02640"></a>02640                 RETURN_EXIT;
<a name="l02641"></a>02641         }
<a name="l02642"></a>02642         CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;%s: committing for last_committed &quot;</span>LPU64<span class="stringliteral">&quot; gen %d\n&quot;</span>,
<a name="l02643"></a>02643                imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name, imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>,
<a name="l02644"></a>02644                imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>);
<a name="l02645"></a>02645 
<a name="l02646"></a>02646         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a> != imp-&gt;<a class="code" href="structobd__import.html#a53945e09c13c835d35ac9c6a4e4c8b5a">imp_last_generation_checked</a> ||
<a name="l02647"></a>02647             imp-&gt;<a class="code" href="structobd__import.html#a3211da741142c7d7c6997a88825ab6da">imp_last_transno_checked</a> == 0)
<a name="l02648"></a>02648                 skip_committed_list = <span class="keyword">false</span>;
<a name="l02649"></a>02649 
<a name="l02650"></a>02650         imp-&gt;<a class="code" href="structobd__import.html#a3211da741142c7d7c6997a88825ab6da">imp_last_transno_checked</a> = imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>;
<a name="l02651"></a>02651         imp-&gt;<a class="code" href="structobd__import.html#a53945e09c13c835d35ac9c6a4e4c8b5a">imp_last_generation_checked</a> = imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>;
<a name="l02652"></a>02652 
<a name="l02653"></a>02653         list_for_each_entry_safe(req, saved, &amp;imp-&gt;<a class="code" href="structobd__import.html#ae3f32574c5a9b068001d451c8506ef7b" title="Lists of requests that are retained for replay, waiting for a reply, or waiting for...">imp_replay_list</a>,
<a name="l02654"></a>02654                                      <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>) {
<a name="l02655"></a>02655                 <span class="comment">/* XXX ok to remove when 1357 resolved - rread 05/29/03  */</span>
<a name="l02656"></a>02656                 LASSERT(req != last_req);
<a name="l02657"></a>02657                 last_req = req;
<a name="l02658"></a>02658 
<a name="l02659"></a>02659                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> == 0) {
<a name="l02660"></a>02660                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_EMERG, req, <span class="stringliteral">&quot;zero transno during replay&quot;</span>);
<a name="l02661"></a>02661                         LBUG();
<a name="l02662"></a>02662                 }
<a name="l02663"></a>02663                 <span class="keywordflow">if</span> (req-&gt;rq_import_generation &lt; imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>) {
<a name="l02664"></a>02664                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;free request with old gen&quot;</span>);
<a name="l02665"></a>02665                         GOTO(free_req, 0);
<a name="l02666"></a>02666                 }
<a name="l02667"></a>02667 
<a name="l02668"></a>02668                 <span class="comment">/* not yet committed */</span>
<a name="l02669"></a>02669                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> &gt; imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>) {
<a name="l02670"></a>02670                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;stopping search&quot;</span>);
<a name="l02671"></a>02671                         <span class="keywordflow">break</span>;
<a name="l02672"></a>02672                 }
<a name="l02673"></a>02673 
<a name="l02674"></a>02674                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ae9b053a81331ff81f4568df30b253bf0" title="when -&amp;gt;rq_replay is set, request is kept by the client even after server commits...">rq_replay</a>) {
<a name="l02675"></a>02675                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;keeping (FL_REPLAY)&quot;</span>);
<a name="l02676"></a>02676                         list_move_tail(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>,
<a name="l02677"></a>02677                                            &amp;imp-&gt;<a class="code" href="structobd__import.html#a05271cb9def4ce64191d4d7089fa831c" title="List of requests that are retained for committed open replay.">imp_committed_list</a>);
<a name="l02678"></a>02678                         <span class="keywordflow">continue</span>;
<a name="l02679"></a>02679                 }
<a name="l02680"></a>02680 
<a name="l02681"></a>02681                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_INFO, req, <span class="stringliteral">&quot;commit (last_committed &quot;</span>LPU64<span class="stringliteral">&quot;)&quot;</span>,
<a name="l02682"></a>02682                           imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>);
<a name="l02683"></a>02683 free_req:
<a name="l02684"></a>02684                 ptlrpc_free_request(req);
<a name="l02685"></a>02685         }
<a name="l02686"></a>02686 
<a name="l02687"></a>02687         <span class="keywordflow">if</span> (skip_committed_list)
<a name="l02688"></a>02688                 GOTO(out, 0);
<a name="l02689"></a>02689 
<a name="l02690"></a>02690         list_for_each_entry_safe(req, saved, &amp;imp-&gt;<a class="code" href="structobd__import.html#a05271cb9def4ce64191d4d7089fa831c" title="List of requests that are retained for committed open replay.">imp_committed_list</a>,
<a name="l02691"></a>02691                                      <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>) {
<a name="l02692"></a>02692                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> != 0);
<a name="l02693"></a>02693                 <span class="keywordflow">if</span> (req-&gt;rq_import_generation &lt; imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>) {
<a name="l02694"></a>02694                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;free stale open request&quot;</span>);
<a name="l02695"></a>02695                         ptlrpc_free_request(req);
<a name="l02696"></a>02696                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!req-&gt;<a class="code" href="structptlrpc__request.html#ae9b053a81331ff81f4568df30b253bf0" title="when -&amp;gt;rq_replay is set, request is kept by the client even after server commits...">rq_replay</a>) {
<a name="l02697"></a>02697                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;free closed open request&quot;</span>);
<a name="l02698"></a>02698                         ptlrpc_free_request(req);
<a name="l02699"></a>02699                 }
<a name="l02700"></a>02700         }
<a name="l02701"></a>02701 out:
<a name="l02702"></a>02702         EXIT;
<a name="l02703"></a>02703 }
<a name="l02704"></a>02704 
<a name="l02705"></a>02705 <span class="keywordtype">void</span> ptlrpc_cleanup_client(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l02706"></a>02706 {
<a name="l02707"></a>02707         ENTRY;
<a name="l02708"></a>02708         EXIT;
<a name="l02709"></a>02709 }
<a name="l02710"></a>02710 
<a name="l02717"></a>02717 <span class="keywordtype">void</span> ptlrpc_resend_req(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02718"></a>02718 {
<a name="l02719"></a>02719         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;going to resend&quot;</span>);
<a name="l02720"></a>02720         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02721"></a>02721 
<a name="l02722"></a>02722         <span class="comment">/* Request got reply but linked to the import list still.</span>
<a name="l02723"></a>02723 <span class="comment">           Let ptlrpc_check_set() to process it. */</span>
<a name="l02724"></a>02724         <span class="keywordflow">if</span> (ptlrpc_client_replied(req)) {
<a name="l02725"></a>02725                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02726"></a>02726                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;it has reply, so skip it&quot;</span>);
<a name="l02727"></a>02727                 <span class="keywordflow">return</span>;
<a name="l02728"></a>02728         }
<a name="l02729"></a>02729 
<a name="l02730"></a>02730         lustre_msg_set_handle(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, &amp;(<span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a>){ 0 });
<a name="l02731"></a>02731         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EAGAIN;
<a name="l02732"></a>02732 
<a name="l02733"></a>02733         req-&gt;rq_resend = 1;
<a name="l02734"></a>02734         req-&gt;rq_net_err = 0;
<a name="l02735"></a>02735         req-&gt;rq_timedout = 0;
<a name="l02736"></a>02736 
<a name="l02737"></a>02737         ptlrpc_client_wake_req(req);
<a name="l02738"></a>02738         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02739"></a>02739 }
<a name="l02740"></a>02740 
<a name="l02741"></a>02741 <span class="comment">/* XXX: this function and rq_status are currently unused */</span>
<a name="l02742"></a>02742 <span class="keywordtype">void</span> ptlrpc_restart_req(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02743"></a>02743 {
<a name="l02744"></a>02744         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;restarting (possibly-)completed request&quot;</span>);
<a name="l02745"></a>02745         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -ERESTARTSYS;
<a name="l02746"></a>02746 
<a name="l02747"></a>02747         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02748"></a>02748         req-&gt;rq_restart = 1;
<a name="l02749"></a>02749         req-&gt;rq_timedout = 0;
<a name="l02750"></a>02750         ptlrpc_client_wake_req(req);
<a name="l02751"></a>02751         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02752"></a>02752 }
<a name="l02753"></a>02753 
<a name="l02757"></a><a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3">02757</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *<a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02758"></a>02758 {
<a name="l02759"></a>02759         ENTRY;
<a name="l02760"></a>02760         atomic_inc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>);
<a name="l02761"></a>02761         RETURN(req);
<a name="l02762"></a>02762 }
<a name="l02763"></a>02763 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>);
<a name="l02764"></a>02764 
<a name="l02769"></a><a class="code" href="group__net.html#ga74e4777d34c1f5305c03de9d365a6268">02769</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga74e4777d34c1f5305c03de9d365a6268" title="Add a request to import replay_list.">ptlrpc_retain_replayable_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02770"></a>02770                                       <span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l02771"></a>02771 {
<a name="l02772"></a>02772         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp;
<a name="l02773"></a>02773 
<a name="l02774"></a>02774         assert_spin_locked(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02775"></a>02775 
<a name="l02776"></a>02776         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> == 0) {
<a name="l02777"></a>02777                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_EMERG, req, <span class="stringliteral">&quot;saving request with zero transno&quot;</span>);
<a name="l02778"></a>02778                 LBUG();
<a name="l02779"></a>02779         }
<a name="l02780"></a>02780 
<a name="l02781"></a>02781         <span class="comment">/* clear this for new requests that were resent as well</span>
<a name="l02782"></a>02782 <span class="comment">           as resent replayed requests. */</span>
<a name="l02783"></a>02783         lustre_msg_clear_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, MSG_RESENT);
<a name="l02784"></a>02784 
<a name="l02785"></a>02785         <span class="comment">/* don&apos;t re-add requests that have been replayed */</span>
<a name="l02786"></a>02786         <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>))
<a name="l02787"></a>02787                 <span class="keywordflow">return</span>;
<a name="l02788"></a>02788 
<a name="l02789"></a>02789         lustre_msg_add_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, MSG_REPLAY);
<a name="l02790"></a>02790 
<a name="l02791"></a>02791         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02792"></a>02792         req-&gt;rq_resend = 0;
<a name="l02793"></a>02793         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02794"></a>02794 
<a name="l02795"></a>02795         LASSERT(imp-&gt;imp_replayable);
<a name="l02796"></a>02796         <span class="comment">/* Balanced in ptlrpc_free_committed, usually. */</span>
<a name="l02797"></a>02797         <a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>(req);
<a name="l02798"></a>02798         list_for_each_prev(tmp, &amp;imp-&gt;<a class="code" href="structobd__import.html#ae3f32574c5a9b068001d451c8506ef7b" title="Lists of requests that are retained for replay, waiting for a reply, or waiting for...">imp_replay_list</a>) {
<a name="l02799"></a>02799                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *iter = list_entry(tmp,
<a name="l02800"></a>02800                                                          <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l02801"></a>02801                                                          <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>);
<a name="l02802"></a>02802 
<a name="l02803"></a>02803                 <span class="comment">/* We may have duplicate transnos if we create and then</span>
<a name="l02804"></a>02804 <span class="comment">                 * open a file, or for closes retained if to match creating</span>
<a name="l02805"></a>02805 <span class="comment">                 * opens, so use req-&gt;rq_xid as a secondary key.</span>
<a name="l02806"></a>02806 <span class="comment">                 * (See bugs 684, 685, and 428.)</span>
<a name="l02807"></a>02807 <span class="comment">                 * XXX no longer needed, but all opens need transnos!</span>
<a name="l02808"></a>02808 <span class="comment">                 */</span>
<a name="l02809"></a>02809                 <span class="keywordflow">if</span> (iter-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> &gt; req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a>)
<a name="l02810"></a>02810                         <span class="keywordflow">continue</span>;
<a name="l02811"></a>02811 
<a name="l02812"></a>02812                 <span class="keywordflow">if</span> (iter-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> == req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a>) {
<a name="l02813"></a>02813                         LASSERT(iter-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> != req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l02814"></a>02814                         <span class="keywordflow">if</span> (iter-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> &gt; req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>)
<a name="l02815"></a>02815                                 <span class="keywordflow">continue</span>;
<a name="l02816"></a>02816                 }
<a name="l02817"></a>02817 
<a name="l02818"></a>02818                 list_add(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>, &amp;iter-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>);
<a name="l02819"></a>02819                 <span class="keywordflow">return</span>;
<a name="l02820"></a>02820         }
<a name="l02821"></a>02821 
<a name="l02822"></a>02822         list_add(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>, &amp;imp-&gt;<a class="code" href="structobd__import.html#ae3f32574c5a9b068001d451c8506ef7b" title="Lists of requests that are retained for replay, waiting for a reply, or waiting for...">imp_replay_list</a>);
<a name="l02823"></a>02823 }
<a name="l02824"></a>02824 
<a name="l02829"></a><a class="code" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48">02829</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes.">ptlrpc_queue_wait</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02830"></a>02830 {
<a name="l02831"></a>02831         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>;
<a name="l02832"></a>02832         <span class="keywordtype">int</span> rc;
<a name="l02833"></a>02833         ENTRY;
<a name="l02834"></a>02834 
<a name="l02835"></a>02835         LASSERT(req-&gt;rq_set == NULL);
<a name="l02836"></a>02836         LASSERT(!req-&gt;rq_receiving_reply);
<a name="l02837"></a>02837 
<a name="l02838"></a>02838         <span class="keyword">set</span> = <a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT.">ptlrpc_prep_set</a>();
<a name="l02839"></a>02839         <span class="keywordflow">if</span> (<span class="keyword">set</span> == NULL) {
<a name="l02840"></a>02840                 CERROR(<span class="stringliteral">&quot;cannot allocate ptlrpc set: rc = %d\n&quot;</span>, -ENOMEM);
<a name="l02841"></a>02841                 RETURN(-ENOMEM);
<a name="l02842"></a>02842         }
<a name="l02843"></a>02843 
<a name="l02844"></a>02844         <span class="comment">/* for distributed debugging */</span>
<a name="l02845"></a>02845         lustre_msg_set_status(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, current_pid());
<a name="l02846"></a>02846 
<a name="l02847"></a>02847         <span class="comment">/* add a ref for the set (see comment in ptlrpc_set_add_req) */</span>
<a name="l02848"></a>02848         <a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>(req);
<a name="l02849"></a>02849         <a class="code" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set.">ptlrpc_set_add_req</a>(<span class="keyword">set</span>, req);
<a name="l02850"></a>02850         rc = <a class="code" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set...">ptlrpc_set_wait</a>(<span class="keyword">set</span>);
<a name="l02851"></a>02851         <a class="code" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set...">ptlrpc_set_destroy</a>(<span class="keyword">set</span>);
<a name="l02852"></a>02852 
<a name="l02853"></a>02853         RETURN(rc);
<a name="l02854"></a>02854 }
<a name="l02855"></a>02855 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes.">ptlrpc_queue_wait</a>);
<a name="l02856"></a>02856 
<a name="l02862"></a>02862 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpc_replay_interpret(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02863"></a>02863                                    <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02864"></a>02864                                    <span class="keywordtype">void</span> * data, <span class="keywordtype">int</span> rc)
<a name="l02865"></a>02865 {
<a name="l02866"></a>02866         <span class="keyword">struct </span><a class="code" href="structptlrpc__replay__async__args.html">ptlrpc_replay_async_args</a> *aa = data;
<a name="l02867"></a>02867         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l02868"></a>02868 
<a name="l02869"></a>02869         ENTRY;
<a name="l02870"></a>02870         atomic_dec(&amp;imp-&gt;<a class="code" href="structobd__import.html#a128f8537a5590b089f0b0155f80674ab" title="Number of replay requests inflight.">imp_replay_inflight</a>);
<a name="l02871"></a>02871 
<a name="l02872"></a>02872         <span class="comment">/* Note: if it is bulk replay (MDS-MDS replay), then even if</span>
<a name="l02873"></a>02873 <span class="comment">         * server got the request, but bulk transfer timeout, let&apos;s</span>
<a name="l02874"></a>02874 <span class="comment">         * replay the bulk req again */</span>
<a name="l02875"></a>02875         <span class="keywordflow">if</span> (!ptlrpc_client_replied(req) ||
<a name="l02876"></a>02876             (req-&gt;rq_bulk != NULL &amp;&amp;
<a name="l02877"></a>02877              lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) == -ETIMEDOUT)) {
<a name="l02878"></a>02878                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;request replay timed out.\n&quot;</span>);
<a name="l02879"></a>02879                 GOTO(out, rc = -ETIMEDOUT);
<a name="l02880"></a>02880         }
<a name="l02881"></a>02881 
<a name="l02882"></a>02882         <span class="keywordflow">if</span> (lustre_msg_get_type(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) == PTL_RPC_MSG_ERR &amp;&amp;
<a name="l02883"></a>02883             (lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) == -ENOTCONN ||
<a name="l02884"></a>02884              lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) == -ENODEV))
<a name="l02885"></a>02885                 GOTO(out, rc = lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>));
<a name="l02886"></a>02886 
<a name="l02888"></a>02888         <span class="keywordflow">if</span> (lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) == -EOVERFLOW) {
<a name="l02890"></a>02890                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_WARNING, req, <span class="stringliteral">&quot;Version mismatch during replay\n&quot;</span>);
<a name="l02891"></a>02891                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02892"></a>02892                 imp-&gt;imp_vbr_failed = 1;
<a name="l02893"></a>02893                 imp-&gt;imp_no_lock_replay = 1;
<a name="l02894"></a>02894                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02895"></a>02895                 lustre_msg_set_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>, aa-&gt;praa_old_status);
<a name="l02896"></a>02896         } <span class="keywordflow">else</span> {
<a name="l02898"></a>02898                 LASSERTF(lustre_msg_get_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) ==
<a name="l02899"></a>02899                          lustre_msg_get_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) ||
<a name="l02900"></a>02900                          lustre_msg_get_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) == 0,
<a name="l02901"></a>02901                          LPX64<span class="stringliteral">&quot;/&quot;</span>LPX64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l02902"></a>02902                          lustre_msg_get_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>),
<a name="l02903"></a>02903                          lustre_msg_get_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>));
<a name="l02904"></a>02904         }
<a name="l02905"></a>02905 
<a name="l02906"></a>02906         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02908"></a>02908         <span class="keywordflow">if</span> (lustre_msg_get_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) &amp; MSG_VERSION_REPLAY)
<a name="l02909"></a>02909                 imp-&gt;imp_no_lock_replay = 1;
<a name="l02910"></a>02910         imp-&gt;<a class="code" href="structobd__import.html#acd37763bff74f567dfdf875f87b52f13" title="Last tranno we replayed.">imp_last_replay_transno</a> = lustre_msg_get_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l02911"></a>02911         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02912"></a>02912         LASSERT(imp-&gt;<a class="code" href="structobd__import.html#acd37763bff74f567dfdf875f87b52f13" title="Last tranno we replayed.">imp_last_replay_transno</a>);
<a name="l02913"></a>02913 
<a name="l02914"></a>02914         <span class="comment">/* transaction number shouldn&apos;t be bigger than the latest replayed */</span>
<a name="l02915"></a>02915         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> &gt; lustre_msg_get_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>)) {
<a name="l02916"></a>02916                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req,
<a name="l02917"></a>02917                           <span class="stringliteral">&quot;Reported transno &quot;</span>LPU64<span class="stringliteral">&quot; is bigger than the &quot;</span>
<a name="l02918"></a>02918                           <span class="stringliteral">&quot;replayed one: &quot;</span>LPU64, req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a>,
<a name="l02919"></a>02919                           lustre_msg_get_transno(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l02920"></a>02920                 GOTO(out, rc = -EINVAL);
<a name="l02921"></a>02921         }
<a name="l02922"></a>02922 
<a name="l02923"></a>02923         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;got rep&quot;</span>);
<a name="l02924"></a>02924 
<a name="l02925"></a>02925         <span class="comment">/* let the callback do fixups, possibly including in the request */</span>
<a name="l02926"></a>02926         <span class="keywordflow">if</span> (req-&gt;rq_replay_cb)
<a name="l02927"></a>02927                 req-&gt;rq_replay_cb(req);
<a name="l02928"></a>02928 
<a name="l02929"></a>02929         <span class="keywordflow">if</span> (ptlrpc_client_replied(req) &amp;&amp;
<a name="l02930"></a>02930             lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) != aa-&gt;praa_old_status) {
<a name="l02931"></a>02931                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;status %d, old was %d&quot;</span>,
<a name="l02932"></a>02932                           lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>),
<a name="l02933"></a>02933                           aa-&gt;praa_old_status);
<a name="l02934"></a>02934 
<a name="l02935"></a>02935                 <span class="comment">/* Note: If the replay fails for MDT-MDT recovery, let&apos;s</span>
<a name="l02936"></a>02936 <span class="comment">                 * abort all of the following requests in the replay</span>
<a name="l02937"></a>02937 <span class="comment">                 * and sending list, because MDT-MDT update requests</span>
<a name="l02938"></a>02938 <span class="comment">                 * are dependent on each other, see LU-7039 */</span>
<a name="l02939"></a>02939                 <span class="keywordflow">if</span> (imp-&gt;imp_connect_flags_orig &amp; OBD_CONNECT_MDS_MDS) {
<a name="l02940"></a>02940                         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *free_req;
<a name="l02941"></a>02941                         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *tmp;
<a name="l02942"></a>02942 
<a name="l02943"></a>02943                         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02944"></a>02944                         list_for_each_entry_safe(free_req, tmp,
<a name="l02945"></a>02945                                                  &amp;imp-&gt;<a class="code" href="structobd__import.html#ae3f32574c5a9b068001d451c8506ef7b" title="Lists of requests that are retained for replay, waiting for a reply, or waiting for...">imp_replay_list</a>,
<a name="l02946"></a>02946                                                  <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>) {
<a name="l02947"></a>02947                                 ptlrpc_free_request(free_req);
<a name="l02948"></a>02948                         }
<a name="l02949"></a>02949 
<a name="l02950"></a>02950                         list_for_each_entry_safe(free_req, tmp,
<a name="l02951"></a>02951                                                  &amp;imp-&gt;<a class="code" href="structobd__import.html#a05271cb9def4ce64191d4d7089fa831c" title="List of requests that are retained for committed open replay.">imp_committed_list</a>,
<a name="l02952"></a>02952                                                  <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>) {
<a name="l02953"></a>02953                                 ptlrpc_free_request(free_req);
<a name="l02954"></a>02954                         }
<a name="l02955"></a>02955 
<a name="l02956"></a>02956                         list_for_each_entry_safe(free_req, tmp,
<a name="l02957"></a>02957                                                 &amp;imp-&gt;imp_delayed_list,
<a name="l02958"></a>02958                                                 <a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>) {
<a name="l02959"></a>02959                                 spin_lock(&amp;free_req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02960"></a>02960                                 free_req-&gt;rq_err = 1;
<a name="l02961"></a>02961                                 free_req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l02962"></a>02962                                 ptlrpc_client_wake_req(free_req);
<a name="l02963"></a>02963                                 spin_unlock(&amp;free_req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02964"></a>02964                         }
<a name="l02965"></a>02965 
<a name="l02966"></a>02966                         list_for_each_entry_safe(free_req, tmp,
<a name="l02967"></a>02967                                                 &amp;imp-&gt;imp_sending_list,
<a name="l02968"></a>02968                                                 <a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>) {
<a name="l02969"></a>02969                                 spin_lock(&amp;free_req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02970"></a>02970                                 free_req-&gt;rq_err = 1;
<a name="l02971"></a>02971                                 free_req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l02972"></a>02972                                 ptlrpc_client_wake_req(free_req);
<a name="l02973"></a>02973                                 spin_unlock(&amp;free_req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l02974"></a>02974                         }
<a name="l02975"></a>02975                         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02976"></a>02976                 }
<a name="l02977"></a>02977         } <span class="keywordflow">else</span> {
<a name="l02978"></a>02978                 <span class="comment">/* Put it back for re-replay. */</span>
<a name="l02979"></a>02979                 lustre_msg_set_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>, aa-&gt;praa_old_status);
<a name="l02980"></a>02980         }
<a name="l02981"></a>02981 
<a name="l02982"></a>02982         <span class="comment">/*</span>
<a name="l02983"></a>02983 <span class="comment">         * Errors while replay can set transno to 0, but</span>
<a name="l02984"></a>02984 <span class="comment">         * imp_last_replay_transno shouldn&apos;t be set to 0 anyway</span>
<a name="l02985"></a>02985 <span class="comment">         */</span>
<a name="l02986"></a>02986         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> == 0)
<a name="l02987"></a>02987                 CERROR(<span class="stringliteral">&quot;Transno is 0 during replay!\n&quot;</span>);
<a name="l02988"></a>02988 
<a name="l02989"></a>02989         <span class="comment">/* continue with recovery */</span>
<a name="l02990"></a>02990         rc = <a class="code" href="group__net.html#gae24ff0ea3f19794b41cb4da94ffa9ce2" title="This is the state machine for client-side recovery on import.">ptlrpc_import_recovery_state_machine</a>(imp);
<a name="l02991"></a>02991  out:
<a name="l02992"></a>02992         req-&gt;rq_send_state = aa-&gt;praa_old_state;
<a name="l02993"></a>02993 
<a name="l02994"></a>02994         <span class="keywordflow">if</span> (rc != 0)
<a name="l02995"></a>02995                 <span class="comment">/* this replay failed, so restart recovery */</span>
<a name="l02996"></a>02996                 <a class="code" href="group__net.html#gae524031a54066bf23dda2ad572bbcfdf" title="Import API.">ptlrpc_connect_import</a>(imp);
<a name="l02997"></a>02997 
<a name="l02998"></a>02998         RETURN(rc);
<a name="l02999"></a>02999 }
<a name="l03000"></a>03000 
<a name="l03006"></a><a class="code" href="group__net.html#gafd4a53f20e90893d5ae03f1996ecb2fc">03006</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#gafd4a53f20e90893d5ae03f1996ecb2fc" title="Prepares and queues request for replay.">ptlrpc_replay_req</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l03007"></a>03007 {
<a name="l03008"></a>03008         <span class="keyword">struct </span><a class="code" href="structptlrpc__replay__async__args.html">ptlrpc_replay_async_args</a> *aa;
<a name="l03009"></a>03009         ENTRY;
<a name="l03010"></a>03010 
<a name="l03011"></a>03011         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> == LUSTRE_IMP_REPLAY);
<a name="l03012"></a>03012 
<a name="l03013"></a>03013         LASSERT (<span class="keyword">sizeof</span> (*aa) &lt;= <span class="keyword">sizeof</span> (req-&gt;rq_async_args));
<a name="l03014"></a>03014         aa = ptlrpc_req_async_args(req);
<a name="l03015"></a>03015         memset(aa, 0, <span class="keyword">sizeof</span> *aa);
<a name="l03016"></a>03016 
<a name="l03017"></a>03017         <span class="comment">/* Prepare request to be resent with ptlrpcd */</span>
<a name="l03018"></a>03018         aa-&gt;praa_old_state = req-&gt;rq_send_state;
<a name="l03019"></a>03019         req-&gt;rq_send_state = LUSTRE_IMP_REPLAY;
<a name="l03020"></a>03020         req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> = RQ_PHASE_NEW;
<a name="l03021"></a>03021         req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a> = RQ_PHASE_UNDEFINED;
<a name="l03022"></a>03022         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>)
<a name="l03023"></a>03023                 aa-&gt;praa_old_status = lustre_msg_get_status(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l03024"></a>03024         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = 0;
<a name="l03025"></a>03025         req-&gt;rq_interpret_reply = ptlrpc_replay_interpret;
<a name="l03026"></a>03026         <span class="comment">/* Readjust the timeout for current conditions */</span>
<a name="l03027"></a>03027         <a class="code" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e.">ptlrpc_at_set_req_timeout</a>(req);
<a name="l03028"></a>03028 
<a name="l03029"></a>03029         <span class="comment">/* Tell server the net_latency, so the server can calculate how long</span>
<a name="l03030"></a>03030 <span class="comment">         * it should wait for next replay */</span>
<a name="l03031"></a>03031         lustre_msg_set_service_time(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>,
<a name="l03032"></a>03032                                     ptlrpc_at_get_net_latency(req));
<a name="l03033"></a>03033         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_HA, req, <span class="stringliteral">&quot;REPLAY&quot;</span>);
<a name="l03034"></a>03034 
<a name="l03035"></a>03035         atomic_inc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a128f8537a5590b089f0b0155f80674ab" title="Number of replay requests inflight.">imp_replay_inflight</a>);
<a name="l03036"></a>03036         <a class="code" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req.">ptlrpc_request_addref</a>(req);     <span class="comment">/* ptlrpcd needs a ref */</span>
<a name="l03037"></a>03037 
<a name="l03038"></a>03038         <a class="code" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check-&amp;gt;ptlrpc_check_set()...">ptlrpcd_add_req</a>(req);
<a name="l03039"></a>03039         RETURN(0);
<a name="l03040"></a>03040 }
<a name="l03041"></a>03041 
<a name="l03045"></a><a class="code" href="group__net.html#gaebf74d120543fbad3a68316dc1a5c97c">03045</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gaebf74d120543fbad3a68316dc1a5c97c" title="Aborts all in-flight request on import imp sending and delayed lists.">ptlrpc_abort_inflight</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l03046"></a>03046 {
<a name="l03047"></a>03047         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp, *n;
<a name="l03048"></a>03048         ENTRY;
<a name="l03049"></a>03049 
<a name="l03050"></a>03050         <span class="comment">/* Make sure that no new requests get processed for this import.</span>
<a name="l03051"></a>03051 <span class="comment">         * ptlrpc_{queue,set}_wait must (and does) hold imp_lock while testing</span>
<a name="l03052"></a>03052 <span class="comment">         * this flag and then putting requests on sending_list or delayed_list.</span>
<a name="l03053"></a>03053 <span class="comment">         */</span>
<a name="l03054"></a>03054         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l03055"></a>03055 
<a name="l03056"></a>03056         <span class="comment">/* XXX locking?  Maybe we should remove each request with the list</span>
<a name="l03057"></a>03057 <span class="comment">         * locked?  Also, how do we know if the requests on the list are</span>
<a name="l03058"></a>03058 <span class="comment">         * being freed at this time?</span>
<a name="l03059"></a>03059 <span class="comment">         */</span>
<a name="l03060"></a>03060         list_for_each_safe(tmp, n, &amp;imp-&gt;imp_sending_list) {
<a name="l03061"></a>03061                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = list_entry(tmp,
<a name="l03062"></a>03062                                                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l03063"></a>03063                                                         <a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l03064"></a>03064 
<a name="l03065"></a>03065                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;inflight&quot;</span>);
<a name="l03066"></a>03066 
<a name="l03067"></a>03067                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l03068"></a>03068                 <span class="keywordflow">if</span> (req-&gt;rq_import_generation &lt; imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>) {
<a name="l03069"></a>03069                         req-&gt;rq_err = 1;
<a name="l03070"></a>03070                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l03071"></a>03071                         ptlrpc_client_wake_req(req);
<a name="l03072"></a>03072                 }
<a name="l03073"></a>03073                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l03074"></a>03074         }
<a name="l03075"></a>03075 
<a name="l03076"></a>03076         list_for_each_safe(tmp, n, &amp;imp-&gt;imp_delayed_list) {
<a name="l03077"></a>03077                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l03078"></a>03078                         list_entry(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, <a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l03079"></a>03079 
<a name="l03080"></a>03080                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;aborting waiting req&quot;</span>);
<a name="l03081"></a>03081 
<a name="l03082"></a>03082                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l03083"></a>03083                 <span class="keywordflow">if</span> (req-&gt;rq_import_generation &lt; imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>) {
<a name="l03084"></a>03084                         req-&gt;rq_err = 1;
<a name="l03085"></a>03085                         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EIO;
<a name="l03086"></a>03086                         ptlrpc_client_wake_req(req);
<a name="l03087"></a>03087                 }
<a name="l03088"></a>03088                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l03089"></a>03089         }
<a name="l03090"></a>03090 
<a name="l03091"></a>03091         <span class="comment">/* Last chance to free reqs left on the replay list, but we</span>
<a name="l03092"></a>03092 <span class="comment">         * will still leak reqs that haven&apos;t committed.  */</span>
<a name="l03093"></a>03093         <span class="keywordflow">if</span> (imp-&gt;imp_replayable)
<a name="l03094"></a>03094                 <a class="code" href="group__ha.html#ga1201e450853aba39256bafedcfae7f11" title="Iterates through replay_list on import and prunes all requests have transno smaller...">ptlrpc_free_committed</a>(imp);
<a name="l03095"></a>03095 
<a name="l03096"></a>03096         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l03097"></a>03097 
<a name="l03098"></a>03098         EXIT;
<a name="l03099"></a>03099 }
<a name="l03100"></a>03100 
<a name="l03104"></a><a class="code" href="group__net.html#gacf9a01538061117dbbb8787fb7b81b77">03104</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gacf9a01538061117dbbb8787fb7b81b77" title="Abort all uncompleted requests in request set set.">ptlrpc_abort_set</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a> *<span class="keyword">set</span>)
<a name="l03105"></a>03105 {
<a name="l03106"></a>03106         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *tmp, *pos;
<a name="l03107"></a>03107 
<a name="l03108"></a>03108         LASSERT(<span class="keyword">set</span> != NULL);
<a name="l03109"></a>03109 
<a name="l03110"></a>03110         list_for_each_safe(pos, tmp, &amp;set-&gt;set_requests) {
<a name="l03111"></a>03111                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req =
<a name="l03112"></a>03112                         list_entry(pos, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l03113"></a>03113                                    rq_set_chain);
<a name="l03114"></a>03114 
<a name="l03115"></a>03115                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l03116"></a>03116                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a> != RQ_PHASE_RPC) {
<a name="l03117"></a>03117                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l03118"></a>03118                         <span class="keywordflow">continue</span>;
<a name="l03119"></a>03119                 }
<a name="l03120"></a>03120 
<a name="l03121"></a>03121                 req-&gt;rq_err = 1;
<a name="l03122"></a>03122                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = -EINTR;
<a name="l03123"></a>03123                 ptlrpc_client_wake_req(req);
<a name="l03124"></a>03124                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l03125"></a>03125         }
<a name="l03126"></a>03126 }
<a name="l03127"></a>03127 
<a name="l03128"></a>03128 <span class="keyword">static</span> __u64 ptlrpc_last_xid;
<a name="l03129"></a>03129 <span class="keyword">static</span> spinlock_t ptlrpc_last_xid_lock;
<a name="l03130"></a>03130 
<a name="l03146"></a>03146 <span class="preprocessor">#define YEAR_2004 (1ULL &lt;&lt; 30)</span>
<a name="l03147"></a>03147 <span class="preprocessor"></span><span class="keywordtype">void</span> ptlrpc_init_xid(<span class="keywordtype">void</span>)
<a name="l03148"></a>03148 {
<a name="l03149"></a>03149         time_t now = cfs_time_current_sec();
<a name="l03150"></a>03150 
<a name="l03151"></a>03151         spin_lock_init(&amp;ptlrpc_last_xid_lock);
<a name="l03152"></a>03152         <span class="keywordflow">if</span> (now &lt; YEAR_2004) {
<a name="l03153"></a>03153                 cfs_get_random_bytes(&amp;ptlrpc_last_xid, <span class="keyword">sizeof</span>(ptlrpc_last_xid));
<a name="l03154"></a>03154                 ptlrpc_last_xid &gt;&gt;= 2;
<a name="l03155"></a>03155                 ptlrpc_last_xid |= (1ULL &lt;&lt; 61);
<a name="l03156"></a>03156         } <span class="keywordflow">else</span> {
<a name="l03157"></a>03157                 ptlrpc_last_xid = (__u64)now &lt;&lt; 20;
<a name="l03158"></a>03158         }
<a name="l03159"></a>03159 
<a name="l03160"></a>03160         <span class="comment">/* Need to always be aligned to a power-of-two for mutli-bulk BRW */</span>
<a name="l03161"></a>03161         CLASSERT((PTLRPC_BULK_OPS_COUNT &amp; (PTLRPC_BULK_OPS_COUNT - 1)) == 0);
<a name="l03162"></a>03162         ptlrpc_last_xid &amp;= <a class="code" href="group__net.html#ga8b841cf2fb3c1d1c92a9ddcf7068bb4c" title="PTLRPC_BULK_OPS_MASK is for the convenience of the client only, and should not be...">PTLRPC_BULK_OPS_MASK</a>;
<a name="l03163"></a>03163 }
<a name="l03164"></a>03164 
<a name="l03177"></a><a class="code" href="group__net.html#gaf2442fe17f822101d45881701da27f40">03177</a> __u64 <a class="code" href="group__net.html#gaf2442fe17f822101d45881701da27f40" title="Increase xid and returns resulting new value to the caller.">ptlrpc_next_xid</a>(<span class="keywordtype">void</span>)
<a name="l03178"></a>03178 {
<a name="l03179"></a>03179         __u64 next;
<a name="l03180"></a>03180 
<a name="l03181"></a>03181         spin_lock(&amp;ptlrpc_last_xid_lock);
<a name="l03182"></a>03182         next = ptlrpc_last_xid + PTLRPC_BULK_OPS_COUNT;
<a name="l03183"></a>03183         ptlrpc_last_xid = next;
<a name="l03184"></a>03184         spin_unlock(&amp;ptlrpc_last_xid_lock);
<a name="l03185"></a>03185 
<a name="l03186"></a>03186         <span class="keywordflow">return</span> next;
<a name="l03187"></a>03187 }
<a name="l03188"></a>03188 
<a name="l03196"></a>03196 <span class="keywordtype">void</span> ptlrpc_set_bulk_mbits(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l03197"></a>03197 {
<a name="l03198"></a>03198         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *bd = req-&gt;rq_bulk;
<a name="l03199"></a>03199 
<a name="l03200"></a>03200         LASSERT(bd != NULL);
<a name="l03201"></a>03201 
<a name="l03202"></a>03202         <span class="keywordflow">if</span> (!req-&gt;rq_resend) {
<a name="l03203"></a>03203                 <span class="comment">/* this request has a new xid, just use it as bulk matchbits */</span>
<a name="l03204"></a>03204                 req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a> = req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>;
<a name="l03205"></a>03205 
<a name="l03206"></a>03206         } <span class="keywordflow">else</span> { <span class="comment">/* needs to generate a new matchbits for resend */</span>
<a name="l03207"></a>03207                 __u64   old_mbits = req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a>;
<a name="l03208"></a>03208 
<a name="l03209"></a>03209                 <span class="keywordflow">if</span> ((bd-&gt;<a class="code" href="structptlrpc__bulk__desc.html#a972206d14ff09e50c84610ba2c755381" title="Client side - import this bulk was sent on.">bd_import</a>-&gt;imp_connect_data.ocd_connect_flags &amp;
<a name="l03210"></a>03210                     <a class="code" href="group__lustreidl.html#ga456effb777dd41a46a6288fd71193f5c" title="bulk matchbits is sent within ptlrpc_body">OBD_CONNECT_BULK_MBITS</a>) != 0)
<a name="l03211"></a>03211                         req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a> = <a class="code" href="group__net.html#gaf2442fe17f822101d45881701da27f40" title="Increase xid and returns resulting new value to the caller.">ptlrpc_next_xid</a>();
<a name="l03212"></a>03212                 <span class="keywordflow">else</span> <span class="comment">/* old version transfers rq_xid to peer as matchbits */</span>
<a name="l03213"></a>03213                         req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a> = req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> = <a class="code" href="group__net.html#gaf2442fe17f822101d45881701da27f40" title="Increase xid and returns resulting new value to the caller.">ptlrpc_next_xid</a>();
<a name="l03214"></a>03214 
<a name="l03215"></a>03215                 CDEBUG(D_HA, <span class="stringliteral">&quot;resend bulk old x&quot;</span>LPU64<span class="stringliteral">&quot; new x&quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l03216"></a>03216                        old_mbits, req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a>);
<a name="l03217"></a>03217         }
<a name="l03218"></a>03218 
<a name="l03219"></a>03219         <span class="comment">/* For multi-bulk RPCs, rq_mbits is the last mbits needed for bulks so</span>
<a name="l03220"></a>03220 <span class="comment">         * that server can infer the number of bulks that were prepared,</span>
<a name="l03221"></a>03221 <span class="comment">         * see LU-1431 */</span>
<a name="l03222"></a>03222         req-&gt;<a class="code" href="structptlrpc__request.html#a3c496127265e85be0eaa1a645ba17a14" title="bulk match bits">rq_mbits</a> += ((bd-&gt;bd_iov_count + <a class="code" href="group__lnet__md.html#gae5c5481fe02371e7bf253b2b1cf0d030" title="limit on the number of fragments in discontiguous MDs">LNET_MAX_IOV</a> - 1) /
<a name="l03223"></a>03223                           <a class="code" href="group__lnet__md.html#gae5c5481fe02371e7bf253b2b1cf0d030" title="limit on the number of fragments in discontiguous MDs">LNET_MAX_IOV</a>) - 1;
<a name="l03224"></a>03224 }
<a name="l03225"></a>03225 
<a name="l03230"></a><a class="code" href="group__net.html#gac08edd7ffd185c9f01d010fa5da16fd3">03230</a> __u64 <a class="code" href="group__net.html#gac08edd7ffd185c9f01d010fa5da16fd3" title="Get a glimpse at what next xid value might have been.">ptlrpc_sample_next_xid</a>(<span class="keywordtype">void</span>)
<a name="l03231"></a>03231 {
<a name="l03232"></a>03232 <span class="preprocessor">#if BITS_PER_LONG == 32</span>
<a name="l03233"></a>03233 <span class="preprocessor"></span>        <span class="comment">/* need to avoid possible word tearing on 32-bit systems */</span>
<a name="l03234"></a>03234         __u64 next;
<a name="l03235"></a>03235 
<a name="l03236"></a>03236         spin_lock(&amp;ptlrpc_last_xid_lock);
<a name="l03237"></a>03237         next = ptlrpc_last_xid + PTLRPC_BULK_OPS_COUNT;
<a name="l03238"></a>03238         spin_unlock(&amp;ptlrpc_last_xid_lock);
<a name="l03239"></a>03239 
<a name="l03240"></a>03240         <span class="keywordflow">return</span> next;
<a name="l03241"></a>03241 <span class="preprocessor">#else</span>
<a name="l03242"></a>03242 <span class="preprocessor"></span>        <span class="comment">/* No need to lock, since returned value is racy anyways */</span>
<a name="l03243"></a>03243         <span class="keywordflow">return</span> ptlrpc_last_xid + PTLRPC_BULK_OPS_COUNT;
<a name="l03244"></a>03244 <span class="preprocessor">#endif</span>
<a name="l03245"></a>03245 <span class="preprocessor"></span>}
<a name="l03246"></a>03246 EXPORT_SYMBOL(<a class="code" href="group__net.html#gac08edd7ffd185c9f01d010fa5da16fd3" title="Get a glimpse at what next xid value might have been.">ptlrpc_sample_next_xid</a>);
<a name="l03247"></a>03247 
<a name="l03265"></a>03265 <span class="keyword">struct </span>ptlrpc_work_async_args {
<a name="l03266"></a>03266         int   (*cb)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *, <span class="keywordtype">void</span> *);
<a name="l03267"></a>03267         <span class="keywordtype">void</span>   *cbdata;
<a name="l03268"></a>03268 };
<a name="l03269"></a>03269 
<a name="l03270"></a>03270 <span class="keyword">static</span> <span class="keywordtype">void</span> ptlrpcd_add_work_req(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l03271"></a>03271 {
<a name="l03272"></a>03272         <span class="comment">/* re-initialize the req */</span>
<a name="l03273"></a>03273         req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>         = obd_timeout;
<a name="l03274"></a>03274         req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a>            = cfs_time_current_sec();
<a name="l03275"></a>03275         req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>        = req-&gt;<a class="code" href="structptlrpc__request.html#ae75a7950843eebecdc496e560f857517" title="when request/reply sent (secs), or time when request should be sent">rq_sent</a> + req-&gt;<a class="code" href="structptlrpc__request.html#aff075d17aea3ad33a82212cdb98bb460" title="service time estimate (secs) If the request is not served by this time, it is marked...">rq_timeout</a>;
<a name="l03276"></a>03276         req-&gt;rq_reply_deadline  = req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>;
<a name="l03277"></a>03277         req-&gt;<a class="code" href="structptlrpc__request.html#af7d18507b7e947d6072d4519743e834b" title="one of RQ_PHASE_*">rq_phase</a>           = RQ_PHASE_INTERPRET;
<a name="l03278"></a>03278         req-&gt;<a class="code" href="structptlrpc__request.html#a13c5ef45ac6f47ea3998981a476f5b1a" title="one of RQ_PHASE_* to be used next">rq_next_phase</a>      = RQ_PHASE_COMPLETE;
<a name="l03279"></a>03279         req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>             = <a class="code" href="group__net.html#gaf2442fe17f822101d45881701da27f40" title="Increase xid and returns resulting new value to the caller.">ptlrpc_next_xid</a>();
<a name="l03280"></a>03280         req-&gt;rq_import_generation = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>;
<a name="l03281"></a>03281 
<a name="l03282"></a>03282         <a class="code" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check-&amp;gt;ptlrpc_check_set()...">ptlrpcd_add_req</a>(req);
<a name="l03283"></a>03283 }
<a name="l03284"></a>03284 
<a name="l03285"></a>03285 <span class="keyword">static</span> <span class="keywordtype">int</span> work_interpreter(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03286"></a>03286                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> rc)
<a name="l03287"></a>03287 {
<a name="l03288"></a>03288         <span class="keyword">struct </span>ptlrpc_work_async_args *arg = data;
<a name="l03289"></a>03289 
<a name="l03290"></a>03290         LASSERT(ptlrpcd_check_work(req));
<a name="l03291"></a>03291         LASSERT(arg-&gt;cb != NULL);
<a name="l03292"></a>03292 
<a name="l03293"></a>03293         rc = arg-&gt;cb(env, arg-&gt;cbdata);
<a name="l03294"></a>03294 
<a name="l03295"></a>03295         list_del_init(&amp;req-&gt;rq_set_chain);
<a name="l03296"></a>03296         req-&gt;rq_set = NULL;
<a name="l03297"></a>03297 
<a name="l03298"></a>03298         <span class="keywordflow">if</span> (atomic_dec_return(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>) &gt; 1) {
<a name="l03299"></a>03299                 atomic_set(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>, 2);
<a name="l03300"></a>03300                 ptlrpcd_add_work_req(req);
<a name="l03301"></a>03301         }
<a name="l03302"></a>03302         <span class="keywordflow">return</span> rc;
<a name="l03303"></a>03303 }
<a name="l03304"></a>03304 
<a name="l03305"></a>03305 <span class="keyword">static</span> <span class="keywordtype">int</span> worker_format;
<a name="l03306"></a>03306 
<a name="l03307"></a>03307 <span class="keyword">static</span> <span class="keywordtype">int</span> ptlrpcd_check_work(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l03308"></a>03308 {
<a name="l03309"></a>03309         <span class="keywordflow">return</span> req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>.rc_fmt == (<span class="keywordtype">void</span> *)&amp;worker_format;
<a name="l03310"></a>03310 }
<a name="l03311"></a>03311 
<a name="l03315"></a><a class="code" href="group__net.html#ga56ad09ae5c5df58c7555e7299dc02108">03315</a> <span class="keywordtype">void</span> *<a class="code" href="group__net.html#ga56ad09ae5c5df58c7555e7299dc02108" title="Create a work for ptlrpc.">ptlrpcd_alloc_work</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l03316"></a>03316                          <span class="keywordtype">int</span> (*cb)(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *, <span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *cbdata)
<a name="l03317"></a>03317 {
<a name="l03318"></a>03318         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>         *req = NULL;
<a name="l03319"></a>03319         <span class="keyword">struct </span>ptlrpc_work_async_args *args;
<a name="l03320"></a>03320         ENTRY;
<a name="l03321"></a>03321 
<a name="l03322"></a>03322         might_sleep();
<a name="l03323"></a>03323 
<a name="l03324"></a>03324         <span class="keywordflow">if</span> (cb == NULL)
<a name="l03325"></a>03325                 RETURN(ERR_PTR(-EINVAL));
<a name="l03326"></a>03326 
<a name="l03327"></a>03327         <span class="comment">/* copy some code from deprecated fakereq. */</span>
<a name="l03328"></a>03328         req = ptlrpc_request_cache_alloc(GFP_NOFS);
<a name="l03329"></a>03329         <span class="keywordflow">if</span> (req == NULL) {
<a name="l03330"></a>03330                 CERROR(<span class="stringliteral">&quot;ptlrpc: run out of memory!\n&quot;</span>);
<a name="l03331"></a>03331                 RETURN(ERR_PTR(-ENOMEM));
<a name="l03332"></a>03332         }
<a name="l03333"></a>03333 
<a name="l03334"></a>03334         ptlrpc_cli_req_init(req);
<a name="l03335"></a>03335 
<a name="l03336"></a>03336         req-&gt;rq_send_state = LUSTRE_IMP_FULL;
<a name="l03337"></a>03337         req-&gt;rq_type = PTL_RPC_MSG_REQUEST;
<a name="l03338"></a>03338         req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a> = class_import_get(imp);
<a name="l03339"></a>03339         req-&gt;rq_interpret_reply = work_interpreter;
<a name="l03340"></a>03340         <span class="comment">/* don&apos;t want reply */</span>
<a name="l03341"></a>03341         req-&gt;rq_no_delay = req-&gt;rq_no_resend = 1;
<a name="l03342"></a>03342         req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>.rc_fmt = (<span class="keywordtype">void</span> *)&amp;worker_format;
<a name="l03343"></a>03343 
<a name="l03344"></a>03344         CLASSERT (<span class="keyword">sizeof</span>(*args) &lt;= <span class="keyword">sizeof</span>(req-&gt;rq_async_args));
<a name="l03345"></a>03345         args = ptlrpc_req_async_args(req);
<a name="l03346"></a>03346         args-&gt;cb     = cb;
<a name="l03347"></a>03347         args-&gt;cbdata = cbdata;
<a name="l03348"></a>03348 
<a name="l03349"></a>03349         RETURN(req);
<a name="l03350"></a>03350 }
<a name="l03351"></a>03351 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga56ad09ae5c5df58c7555e7299dc02108" title="Create a work for ptlrpc.">ptlrpcd_alloc_work</a>);
<a name="l03352"></a>03352 
<a name="l03353"></a>03353 <span class="keywordtype">void</span> ptlrpcd_destroy_work(<span class="keywordtype">void</span> *handler)
<a name="l03354"></a>03354 {
<a name="l03355"></a>03355         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = handler;
<a name="l03356"></a>03356 
<a name="l03357"></a>03357         <span class="keywordflow">if</span> (req)
<a name="l03358"></a>03358                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l03359"></a>03359 }
<a name="l03360"></a>03360 EXPORT_SYMBOL(ptlrpcd_destroy_work);
<a name="l03361"></a>03361 
<a name="l03362"></a>03362 <span class="keywordtype">int</span> ptlrpcd_queue_work(<span class="keywordtype">void</span> *handler)
<a name="l03363"></a>03363 {
<a name="l03364"></a>03364         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = handler;
<a name="l03365"></a>03365 
<a name="l03366"></a>03366         <span class="comment">/*</span>
<a name="l03367"></a>03367 <span class="comment">         * Check if the req is already being queued.</span>
<a name="l03368"></a>03368 <span class="comment">         *</span>
<a name="l03369"></a>03369 <span class="comment">         * Here comes a trick: it lacks a way of checking if a req is being</span>
<a name="l03370"></a>03370 <span class="comment">         * processed reliably in ptlrpc. Here I have to use refcount of req</span>
<a name="l03371"></a>03371 <span class="comment">         * for this purpose. This is okay because the caller should use this</span>
<a name="l03372"></a>03372 <span class="comment">         * req as opaque data. - Jinshan</span>
<a name="l03373"></a>03373 <span class="comment">         */</span>
<a name="l03374"></a>03374         LASSERT(atomic_read(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>) &gt; 0);
<a name="l03375"></a>03375         <span class="keywordflow">if</span> (atomic_inc_return(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>) == 2)
<a name="l03376"></a>03376                 ptlrpcd_add_work_req(req);
<a name="l03377"></a>03377         <span class="keywordflow">return</span> 0;
<a name="l03378"></a>03378 }
<a name="l03379"></a>03379 EXPORT_SYMBOL(ptlrpcd_queue_work);
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:20 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
