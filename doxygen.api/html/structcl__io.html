<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: cl_io Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cl_io Struct Reference<br/>
<small>
[<a class="el" href="group__cl__io.html">cl_io</a>]</small>
</h1><!-- doxytag: class="cl_io" -->
<p>State for io.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl__object_8h_source.html">cl_object.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for cl_io:</div>
<div class="dynsection">
<div class="center"><img src="structcl__io__coll__graph.png" border="0" usemap="#cl__io_coll__map" alt="Collaboration graph"/></div>
<map name="cl__io_coll__map" id="cl__io_coll__map">
<area shape="rect" id="node136" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables..." alt="" coords="1971,2600,2097,2893"/><area shape="rect" id="node2" href="structlist__head.html" title="{list_head\n|+ next\l+ prev\l|}" alt="" coords="1515,14,1598,117"/><area shape="rect" id="node9" href="structlu__object.html" title="Layer in the layered object." alt="" coords="2575,688,2679,843"/><area shape="rect" id="node16" href="structlu__object__header.html" title="&quot;Compound&quot; object, consisting of multiple layers." alt="" coords="2763,209,2902,415"/><area shape="rect" id="node26" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking." alt="" coords="2639,1789,2765,1995"/><area shape="rect" id="node29" href="structobd__device.html" title="{obd_device\n|+ obd_type\l+ obd_magic\l+ obd_minor\l+ obd_lu_dev\l+ obd_uuid\l+ obd_name\l+ obd_attached\l+ obd_set_up\l+ obd_recovering\l+ obd_abort_recovery\l+ obd_version_recov\l+ obd_replayable\l+ obd_no_transno\l+ obd_no_recov\l+ obd_stopping\l+ obd_starting\l+ obd_force\l+ obd_fail\l+ obd_no_conn\l+ obd_inactive\l+ obd_no_ir\l+ obd_process_conf\l+ obd_uses_nid_stats\l+ obd_recovery_expired\l+ obd_uuid_hash\l+ obd_nid_hash\l+ obd_nid_stats_hash\l+ obd_gen_hash\l+ obd_nid_stats\l+ obd_exports\l+ obd_unlinked_exports\l+ obd_delayed_exports\l+ obd_lwp_list\l+ obd_refcount\l+ obd_num_exports\l+ obd_nid_lock\l+ obd_namespace\l+ obd_ldlm_client\l+ obd_dev_lock\l+ obd_osfs_lock\l+ obd_osfs\l+ obd_osfs_age\l+ obd_last_committed\l+ obd_dev_mutex\l+ obd_lvfs_ctxt\l+ obd_olg\l+ obd_observer\l+ obd_observer_link_sem\l+ obd_upcall\l+ obd_self_export\l+ obd_lwp_export\l+ obd_exports_timed\l+ obd_eviction_timer\l+ obd_max_recoverable_clients\l+ obd_connected_clients\l+ obd_stale_clients\l+ obd_recovery_task_lock\l+ obd_next_recovery_transno\l+ obd_replayed_requests\l+ obd_requests_queued_for_recovery\l+ obd_next_transno_waitq\l+ obd_recovery_timer\l+ obd_recovery_start\l+ obd_recovery_end\l+ obd_recovery_time_hard\l+ obd_recovery_timeout\l+ obd_recovery_ir_factor\l+ obd_replayed_locks\l+ obd_req_replay_clients\l+ obd_lock_replay_clients\l+ obd_recovery_data\l+ obd_req_replay_queue\l+ obd_lock_replay_queue\l+ obd_final_req_queue\l+ cli\l+ echo_client\l+ lov\l+ lmv\l+ u\l+ obd_stats\l+ obd_cntr_base\l+ obd_md_cntr_base\l+ obd_md_stats\l+ obd_proc_entry\l+ obd_proc_exports_entry\l+ obd_svc_procroot\l+ obd_svc_stats\l+ obd_vars\l+ obd_evict_inprogress\l+ obd_evict_inprogress_waitq\l+ obd_evict_list\l+ obd_pool_lock\l+ obd_pool_slv\l+ obd_pool_limit\l+ obd_conn_inprogress\l+ obd_reference\l|}" alt="" coords="1346,4150,1621,5882"/><area shape="rect" id="node31" href="structecho__client__obd.html" title="{echo_client_obd\n|+ ec_exp\l+ ec_lock\l+ ec_objects\l+ ec_locks\l+ ec_unique\l|}" alt="" coords="366,7739,497,7893"/><area shape="rect" id="node34" href="structobd__export.html" title="Export structure." alt="" coords="227,5965,470,7056"/><area shape="rect" id="node40" href="structcfs__workitem.html" title="{cfs_workitem\n|+ wi_list\l+ wi_action\l+ wi_data\l+ wi_running\l+ wi_scheduled\l|}" alt="" coords="1163,440,1289,595"/><area shape="rect" id="node59" href="structobd__type.html" title="{obd_type\n|+ typ_chain\l+ typ_dt_ops\l+ typ_md_ops\l+ typ_procroot\l+ typ_procsym\l+ typ_sym_filter\l+ typ_name\l+ typ_refcnt\l+ typ_lu\l+ obd_type_lock\l|}" alt="" coords="2313,3719,2446,3961"/><area shape="rect" id="node64" href="structlu__device__type.html" title="Type of device." alt="" coords="2550,3176,2675,3365"/><area shape="rect" id="node82" href="structclient__obd.html" title="{client_obd\n|+ cl_sem\l+ cl_target_uuid\l+ cl_import\l+ cl_conn_count\l+ cl_default_mds_easize\l+ cl_max_mds_easize\l+ cl_sp_me\l+ cl_sp_to\l+ cl_flvr_mgc\l+ cl_dirty_pages\l+ cl_dirty_max_pages\l+ cl_dirty_transit\l+ cl_avail_grant\l+ cl_lost_grant\l+ cl_dirty_grant\l+ cl_reserved_grant\l+ cl_cache_waiters\l+ cl_next_shrink_grant\l+ cl_grant_shrink_list\l+ cl_grant_shrink_interval\l+ cl_chunkbits\l+ cl_grant_extent_tax\l+ cl_max_extent_pages\l+ cl_loi_list_lock\l+ cl_loi_ready_list\l+ cl_loi_hp_ready_list\l+ cl_loi_write_list\l+ cl_loi_read_list\l+ cl_r_in_flight\l+ cl_w_in_flight\l+ cl_pending_w_pages\l+ cl_pending_r_pages\l+ cl_max_pages_per_rpc\l+ cl_max_rpcs_in_flight\l+ cl_read_rpc_hist\l+ cl_write_rpc_hist\l+ cl_read_page_hist\l+ cl_write_page_hist\l+ cl_read_offset_hist\l+ cl_write_offset_hist\l+ cl_cache\l+ cl_lru_osc\l+ cl_lru_left\l+ cl_lru_busy\l+ cl_lru_in_list\l+ cl_lru_shrinkers\l+ cl_lru_last_used\l+ cl_lru_reclaim\l+ cl_lru_list\l+ cl_lru_list_lock\l+ cl_unstable_count\l+ cl_shrink_list\l+ cl_destroy_in_flight\l+ cl_destroy_waitq\l+ cl_rpc_lock\l+ cl_mod_rpcs_lock\l+ cl_max_mod_rpcs_in_flight\l+ cl_mod_rpcs_in_flight\l+ cl_close_rpcs_in_flight\l+ cl_mod_rpcs_waitq\l+ cl_mod_tag_bitmap\l+ cl_mod_rpcs_hist\l+ cl_mgc_mutex\l+ cl_mgc_los\l+ cl_mgc_configs_dir\l+ cl_mgc_refcount\l+ cl_mgc_mgsexp\l+ cl_checksum\l+ cl_supp_cksum_types\l+ cl_cksum_type\l+ cl_ar\l+ cl_seq\l+ cl_resends\l+ cl_writeback_work\l+ cl_lru_work\l+ cl_quota_hash\l|}" alt="" coords="530,7123,743,8509"/><area shape="rect" id="node93" href="structldlm__namespace.html" title="LDLM Namespace." alt="" coords="2131,6217,2315,6805"/><area shape="rect" id="node99" href="structlov__obd.html" title="{lov_obd\n|+ desc\l+ lov_tgts\l+ lov_packed\l+ lov_lock\l+ lov_ocd\l+ targets_proc_entry\l+ lov_refcount\l+ lov_death_row\l+ lov_tgt_size\l+ lov_connects\l+ lov_pool_count\l+ lov_pools_hash_body\l+ lov_pool_list\l+ lov_pool_proc_entry\l+ lov_sp_me\l+ lov_cache\l+ lov_notify_lock\l|}" alt="" coords="1853,3659,2026,4021"/><area shape="rect" id="node117" href="structlu__site.html" title="lu_site is a &quot;compartment&quot; within which objects are unique, and LRU discipline..." alt="" coords="2763,7687,2905,7945"/><area shape="rect" id="node132" href="structcl__page__list.html" title="{cl_page_list\n|+ pl_nr\l+ pl_pages\l+ pl_owner\l|}" alt="" coords="1685,252,1783,372"/><area shape="rect" id="node148" href="structcl__lockset.html" title="Lock&#45;set represents a collection of locks, that io needs at a time." alt="" coords="1559,466,1653,569"/><area shape="rect" id="node5" href="structcl__object.html" title="Sub&#45;class of lu_object with methods common for objects on the client stacks." alt="" coords="2023,1116,2138,1236"/><area shape="rect" id="node7" href="structcl__object__operations.html" title="Operations implemented for each cl object layer." alt="" coords="1997,619,2159,912"/><area shape="rect" id="node113" href="structlu__device__operations.html" title="Operations common for data and meta&#45;data devices." alt="" coords="2530,1107,2725,1245"/><area shape="rect" id="node12" href="structlu__object__operations.html" title="Operations specific for particular lu_object." alt="" coords="2569,217,2739,407"/><area shape="rect" id="node14" href="structlu__ref__link.html" title="{lu_ref_link\n||}" alt="" coords="2346,269,2431,355"/><area shape="rect" id="node19" href="structhlist__node.html" title="{hlist_node\n|+ next\l+ pprev\l|}" alt="" coords="689,14,779,117"/><area shape="rect" id="node22" href="structlu__fid.html" title="File IDentifier." alt="" coords="2597,5,2669,125"/><area shape="rect" id="node24" href="structlu__ref.html" title="{lu_ref\n||}" alt="" coords="2918,23,2977,108"/><area shape="rect" id="node68" href="structlu__device__type__operations.html" title="Operations on a device type." alt="" coords="2494,2643,2697,2850"/><area shape="rect" id="node119" href="structlu__target.html" title="{lu_target\n|+ lut_obd\l+ lut_bottom\l+ lut_tdtd\l+ lut_tdtd_commit_thread\l+ lut_slice\l+ lut_reply_fail_id\l+ lut_request_fail_id\l+ lut_sptlrpc_lock\l+ lut_sptlrpc_rset\l+ lut_flags_lock\l+ lut_sec_level\l+ lut_syncjournal\l+ lut_sync_lock_cancel\l+ lut_no_reconstruct\l+ lut_last_rcvd\l+ lut_txn_cb\l+ lut_lsd\l+ lut_last_transno\l+ lut_translock\l+ lut_client_bitmap_lock\l+ lut_client_bitmap\l+ lut_num_clients\l+ lut_client_generation\l+ lut_reply_data\l+ lut_reply_bitmap\l+ lut_sync_count\l|}" alt="" coords="1670,6251,1873,6770"/><area shape="rect" id="node108" href="structlmv__obd.html" title="{lmv_obd\n|+ refcount\l+ lmv_fld\l+ lmv_lock\l+ lmv_placement\l+ desc\l+ cluuid\l+ exp\l+ targets_proc_entry\l+ lmv_init_mutex\l+ connected\l+ max_easize\l+ max_def_easize\l+ tgts_size\l+ tgts\l+ conn_data\l|}" alt="" coords="819,7652,985,7980"/><area shape="rect" id="node126" href="structseq__server__site.html" title="{seq_server_site\n|+ ss_lu\l+ ss_node_id\l+ ss_server_fld\l+ ss_client_fld\l+ ss_server_seq\l+ ss_control_seq\l+ ss_control_exp\l+ ss_client_seq\l|}" alt="" coords="2702,8577,2838,8783"/><area shape="rect" id="node36" href="structcfs__hash.html" title="cfs_hash is a hash&#45;table implementation for general purpose, it can support: ." alt="" coords="1231,3037,1394,3504"/><area shape="rect" id="node38" href="unioncfs__hash__lock.html" title="{cfs_hash_lock\n|+ rw\l+ spin\l|}" alt="" coords="974,1841,1086,1943"/><area shape="rect" id="node43" href="structcfs__hash__bucket.html" title="cfs_hash_bucket is a container of:lock, counter ." alt="" coords="674,2661,807,2833"/><area shape="rect" id="node46" href="structcfs__hash__hlist__ops.html" title="{cfs_hash_hlist_ops\n|+ hop_hhead\l+ hop_hhead_size\l+ hop_hnode_add\l+ hop_hnode_del\l|}" alt="" coords="831,2678,975,2815"/><area shape="rect" id="node48" href="structcfs__hash__lock__ops.html" title="{cfs_hash_lock_ops\n|+ hs_lock\l+ hs_unlock\l+ hs_bkt_lock\l+ hs_bkt_unlock\l|}" alt="" coords="999,2678,1141,2815"/><area shape="rect" id="node50" href="structcfs__hash__ops.html" title="{cfs_hash_ops\n|+ hs_hash\l+ hs_key\l+ hs_keycpy\l+ hs_keycmp\l+ hs_object\l+ hs_get\l+ hs_put\l+ hs_put_locked\l+ hs_exit\l|}" alt="" coords="1262,2635,1393,2859"/><area shape="rect" id="node55" href="structobd__uuid.html" title="{obd_uuid\n|+ uuid\l|}" alt="" coords="521,3797,601,3883"/><area shape="rect" id="node62" href="structmd__ops.html" title="{md_ops\n|+ m_close\l+ m_create\l+ m_enqueue\l+ m_getattr\l+ m_intent_lock\l+ m_link\l+ m_rename\l+ m_setattr\l+ m_fsync\l+ m_read_page\l+ m_unlink\l+ m_setxattr\l+ m_getxattr\l+ m_intent_getattr_async\l+ m_revalidate_lock\l+ m_get_root\l+ m_null_inode\l+ m_getattr_name\l+ m_init_ea_size\l+ m_get_lustre_md\l+ m_free_lustre_md\l+ m_merge_attr\l+ m_set_open_replay_data\l+ m_clear_open_replay_data\l+ m_set_lock_data\l+ m_lock_match\l+ m_cancel_unused\l+ m_get_remote_perm\l+ m_get_fid_from_lsm\l+ m_unpackmd\l|}" alt="" coords="2313,2977,2526,3565"/><area shape="rect" id="node71" href="structlprocfs__stats.html" title="{lprocfs_stats\n|+ ls_num\l+ ls_biggest_alloc_num\l+ ls_flags\l+ ls_lock\l+ ls_cnt_header\l+ ls_percpu\l|}" alt="" coords="2622,3754,2798,3926"/><area shape="rect" id="node73" href="structobd__notify__upcall.html" title="{obd_notify_upcall\n|+ onu_upcall\l+ onu_owner\l|}" alt="" coords="2050,3789,2186,3891"/><area shape="rect" id="node76" href="structptlrpc__client.html" title="Client definition for PortalRPC." alt="" coords="675,3780,830,3900"/><area shape="rect" id="node78" href="structobd__llog__group.html" title="{obd_llog_group\n|+ olg_ctxts\l+ olg_waitq\l+ olg_lock\l+ olg_cat_processing\l|}" alt="" coords="854,3771,1017,3909"/><area shape="rect" id="node80" href="structlprocfs__vars.html" title="{lprocfs_vars\n|+ name\l+ fops\l+ data\l+ proc_mode\l|}" alt="" coords="1041,3771,1150,3909"/><area shape="rect" id="node88" href="structobd__statfs.html" title="{obd_statfs\n|+ os_type\l+ os_blocks\l+ os_bfree\l+ os_bavail\l+ os_files\l+ os_ffree\l+ os_fsid\l+ os_bsize\l+ os_namelen\l+ os_maxbytes\l+ os_state\l+ os_fprecreated\l+ os_spare2\l+ os_spare3\l+ os_spare4\l+ os_spare5\l+ os_spare6\l+ os_spare7\l+ os_spare8\l+ os_spare9\l|}" alt="" coords="1174,3633,1313,4047"/><area shape="rect" id="node103" href="structtarget__recovery__data.html" title="{target_recovery_data\n|+ trd_recovery_handler\l+ trd_processing_task\l+ trd_starting\l+ trd_finishing\l|}" alt="" coords="1517,3771,1695,3909"/><area shape="rect" id="node105" href="structlvfs__run__ctxt.html" title="{lvfs_run_ctxt\n|+ pwdmnt\l+ pwd\l+ fs\l+ umask\l+ dt\l+ magic\l|}" alt="" coords="1719,3754,1829,3926"/><area shape="rect" id="node130" href="structcl__2queue.html" title="A 2&#45;queue of pages." alt="" coords="1730,937,1821,1039"/><area shape="rect" id="node141" href="structcl__sync__io.html" title="Anchor for synchronous transfer." alt="" coords="2153,1815,2265,1969"/><area shape="rect" id="node146" href="structost__lvb.html" title="{ost_lvb\n|+ lvb_size\l+ lvb_mtime\l+ lvb_atime\l+ lvb_ctime\l+ lvb_blocks\l+ lvb_mtime_ns\l+ lvb_atime_ns\l+ lvb_ctime_ns\l+ lvb_padding\l|}" alt="" coords="1610,1064,1738,1288"/><area shape="rect" id="node151" href="structcl__io__rw__common.html" title="{cl_io_rw_common\n|+ crw_pos\l+ crw_count\l+ crw_nonblock\l|}" alt="" coords="1447,1116,1586,1236"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378">cl_io_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50">ci_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">type of this IO.  <a href="#ac02cd7b5e65d1d20d00de68de64d8b50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__cl__io.html#ga31cc6886dbe550ea8576111ded9814f3">cl_io_state</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984">ci_state</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">current state of <a class="el" href="structcl__io.html" title="State for io.">cl_io</a> state machine.  <a href="#a2d9112d04e0c51b82eb5b31eee94e984"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__object.html">cl_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b">ci_obj</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">main object this io is against.  <a href="#ab2758184445778d1acf0282ac0e6687b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#a0848dbd9565e8113af8636a8182f9e1d">ci_parent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upper layer io, of which this io is a part of.  <a href="#a0848dbd9565e8113af8636a8182f9e1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#ab5a63aa434fec58687af4e284ab2392b">ci_layers</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of slices.  <a href="#ab5a63aa434fec58687af4e284ab2392b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__lockset.html">cl_lockset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875">ci_lockset</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list of locks (to be) acquired by this io.  <a href="#a5e4726f4ed7b0cc829ca85342b383875"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__cl__io.html#gac7ff31ceda4789c9101711379ffe824b">cl_io_lock_dmd</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa">ci_lockreq</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock requirements, this is just a help info for sublayers.  <a href="#a245a0c27f43614baa43128f2e82867fa"></a><br/></td></tr>
<tr><td class="memItemLeft" ><a class="anchor" id="a8b561db29f0b79fba4d14b66b9882530"></a><!-- doxytag: member="cl_io::u" ref="a8b561db29f0b79fba4d14b66b9882530" args="" -->
union {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;struct <b>cl_rd_io</b> {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct <a class="el" href="structcl__io__rw__common.html">cl_io_rw_common</a>&nbsp;&nbsp;&nbsp;<b>rd</b></td></tr>
<tr><td class="memItemLeft" valign="top">&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<b>ci_rd</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;struct <b>cl_wr_io</b> {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct <a class="el" href="structcl__io__rw__common.html">cl_io_rw_common</a>&nbsp;&nbsp;&nbsp;<b>wr</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;<b>wr_append</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;<b>wr_sync</b></td></tr>
<tr><td class="memItemLeft" valign="top">&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<b>ci_wr</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;struct <a class="el" href="structcl__io__rw__common.html">cl_io_rw_common</a>&nbsp;&nbsp;&nbsp;<b>ci_rw</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;struct <b>cl_setattr_io</b> {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct <a class="el" href="structost__lvb.html">ost_lvb</a>&nbsp;&nbsp;&nbsp;<b>sa_attr</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int&nbsp;&nbsp;&nbsp;<b>sa_attr_flags</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int&nbsp;&nbsp;&nbsp;<b>sa_valid</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;<b>sa_stripe_index</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct <a class="el" href="structlu__fid.html">lu_fid</a> *&nbsp;&nbsp;&nbsp;<b>sa_parent_fid</b></td></tr>
<tr><td class="memItemLeft" valign="top">&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<b>ci_setattr</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;struct <b>cl_data_version_io</b> {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u64&nbsp;&nbsp;&nbsp;<b>dv_data_version</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;<b>dv_flags</b></td></tr>
<tr><td class="memItemLeft" valign="top">&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<b>ci_data_version</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;struct <b>cl_fault_io</b> {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pgoff_t&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io.html#a6dad5b14bbe77f890d7d4210374cda50">ft_index</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">page index within file.  <a href="#a7f320362e49928096eb59b013fe99b19"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io.html#ac03a89a0a99f8add03531b91539ccf7a">ft_nob</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bytes valid byte on a faulted page.  <a href="#a72a4ccd247d0c011b290561226cf07c9"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io.html#a61a50c5e51a34e75c4b1c368f30c08d6">ft_writable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">writable page? for nopage() only <br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io.html#ab9173b5cfbf86839bd387693460add83">ft_executable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">page of an executable? <br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io.html#a82ed099d6e0b24f256567b88996d3226">ft_mkwrite</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">page_mkwrite() <br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct <a class="el" href="structcl__page.html">cl_page</a> *&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io.html#a99cc27b69b3be1cd7810a5677193b86d">ft_page</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">resulting page <br/></td></tr>
<tr><td class="memItemLeft" valign="top">&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<b>ci_fault</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;struct <b>cl_fsync_io</b> {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loff_t&nbsp;&nbsp;&nbsp;<b>fi_start</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loff_t&nbsp;&nbsp;&nbsp;<b>fi_end</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct <a class="el" href="structlu__fid.html">lu_fid</a> *&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io.html#ab040646a84568983168f1a6286a86d30">fi_fid</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">file system level fid <br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enum <a class="el" href="group__cl__io.html#gabb7d5d07a2e68b82b9b13cac60256a7d">cl_fsync_mode</a>&nbsp;&nbsp;&nbsp;<b>fi_mode</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int&nbsp;&nbsp;&nbsp;<b>fi_nr_written</b></td></tr>
<tr><td class="memItemLeft" valign="top">&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<b>ci_fsync</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;struct <b>cl_ladvise_io</b> {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__u64&nbsp;&nbsp;&nbsp;<b>li_start</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__u64&nbsp;&nbsp;&nbsp;<b>li_end</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct <a class="el" href="structlu__fid.html">lu_fid</a> *&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__io.html#ab832010f18633ae9b640d94f01111649">li_fid</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">file system level fid <br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enum lu_ladvise_type&nbsp;&nbsp;&nbsp;<b>li_advice</b></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__u64&nbsp;&nbsp;&nbsp;<b>li_flags</b></td></tr>
<tr><td class="memItemLeft" valign="top">&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<b>ci_ladvise</b></td></tr>
<tr><td class="memItemLeft" valign="top">}&nbsp;</td><td class="memItemRight" valign="bottom"><b>u</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c8a3389efac1b57226cb034a8224abe"></a><!-- doxytag: member="cl_io::ci_queue" ref="a7c8a3389efac1b57226cb034a8224abe" args="" -->
struct <a class="el" href="structcl__2queue.html">cl_2queue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ci_queue</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3140355ba778fab0264dcbb4baad1583"></a><!-- doxytag: member="cl_io::ci_nob" ref="a3140355ba778fab0264dcbb4baad1583" args="" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>ci_nob</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a341b1b5f80fdf2cc9183fa7f4cec4df6"></a><!-- doxytag: member="cl_io::ci_result" ref="a341b1b5f80fdf2cc9183fa7f4cec4df6" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ci_result</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312266d038e148a30ba93b5d0c261b70"></a><!-- doxytag: member="cl_io::ci_continue" ref="a312266d038e148a30ba93b5d0c261b70" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ci_continue</b>:1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a435468f51ab9aab5145e46b36c669376"></a><!-- doxytag: member="cl_io::ci_no_srvlock" ref="a435468f51ab9aab5145e46b36c669376" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#a435468f51ab9aab5145e46b36c669376">ci_no_srvlock</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This io has held grouplock, to inform sublayers that don't do lockless i/o. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a425b5ecdec17c901b3c8d8e09327d902"></a><!-- doxytag: member="cl_io::ci_need_restart" ref="a425b5ecdec17c901b3c8d8e09327d902" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#a425b5ecdec17c901b3c8d8e09327d902">ci_need_restart</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The whole IO need to be restarted because layout has been changed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d6c1c346a6203b03bf6fb768c6799da"></a><!-- doxytag: member="cl_io::ci_ignore_layout" ref="a5d6c1c346a6203b03bf6fb768c6799da" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#a5d6c1c346a6203b03bf6fb768c6799da">ci_ignore_layout</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">to not refresh layout - the IO issuer knows that the layout won't change(page operations, layout change causes all page to be discarded), or it doesn't matter if it changes(sync). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#ac902e3a2f27fed9590e95769bbf93e71">ci_verify_layout</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if layout changed after the IO finishes.  <a href="#ac902e3a2f27fed9590e95769bbf93e71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc9a415667fd8975f4be9645e816c2e2"></a><!-- doxytag: member="cl_io::ci_restore_needed" ref="acc9a415667fd8975f4be9645e816c2e2" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#acc9a415667fd8975f4be9645e816c2e2">ci_restore_needed</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">file is released, restore has to to be triggered by vvp layer <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a86e6e753e3df915972b23ba399196"></a><!-- doxytag: member="cl_io::ci_noatime" ref="a74a86e6e753e3df915972b23ba399196" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#a74a86e6e753e3df915972b23ba399196">ci_noatime</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">O_NOATIME. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__io.html#ae86c9bd21f8243d5f18f88a1c057909a">ci_owned_nr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of pages owned by this IO.  <a href="#ae86c9bd21f8243d5f18f88a1c057909a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>State for io. </p>
<p>I/O.</p>
<p><a class="el" href="structcl__io.html" title="State for io.">cl_io</a> is shared by all threads participating in this IO (in current implementation only one thread advances IO, but parallel IO design and concurrent copy_*_user() require multiple threads acting on the same IO. It is up to these threads to serialize their activities, including updates to mutable <a class="el" href="structcl__io.html" title="State for io.">cl_io</a> fields.</p>
<p><a class="el" href="structcl__io.html" title="State for io.">cl_io</a> represents a high level I/O activity like read(2)/write(2)/truncate(2) system call, or cancellation of an extent lock.</p>
<p><a class="el" href="structcl__io.html" title="State for io.">cl_io</a> is a layered object, much like cl_{object,page,lock} but with one important distinction. We want to minimize number of calls to the allocator in the fast path, e.g., in the case of read(2) when everything is cached: client already owns the lock over region being read, and data are cached due to read-ahead. To avoid allocation of <a class="el" href="structcl__io.html" title="State for io.">cl_io</a> layers in such situations, per-layer io state is stored in the session, associated with the io, see struct {vvp,lov,osc}_io for example. Sessions allocation is amortized by using free-lists, see <a class="el" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get()</a>.</p>
<p>There is a small predefined number of possible io types, enumerated in enum cl_io_type.</p>
<p><a class="el" href="structcl__io.html" title="State for io.">cl_io</a> is a state machine, that can be advanced concurrently by the multiple threads. It is up to these threads to control the concurrency and, specifically, to detect when io is done, and its state can be safely released.</p>
<p>For read/write io overall execution plan is as following:</p>
<p>(0) initialize io state through all layers;</p>
<p>(1) loop: prepare chunk of work to do</p>
<p>(2) call all layers to collect locks they need to process current chunk</p>
<p>(3) sort all locks to avoid dead-locks, and acquire them</p>
<p>(4) process the chunk: call per-page methods cl_io_operations::cio_prepare_write(), cl_io_operations::cio_commit_write() for write)</p>
<p>(5) release locks</p>
<p>(6) repeat loop.</p>
<p>To implement the "parallel IO mode", lov layer creates sub-io's (lazily to address allocation efficiency issues mentioned above), and returns with the special error condition from per-page method when current sub-io has to block. This causes io loop to be repeated, and lov switches to the next sub-io in its <a class="el" href="structcl__io__operations.html#aeedb0fcc4555583225020c012c5b84e1" title="Prepare io iteration at a given layer.">cl_io_operations::cio_iter_init()</a> implementation. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01746">1746</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ab5a63aa434fec58687af4e284ab2392b"></a><!-- doxytag: member="cl_io::ci_layers" ref="ab5a63aa434fec58687af4e284ab2392b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__head.html">list_head</a> <a class="el" href="structcl__io.html#ab5a63aa434fec58687af4e284ab2392b">cl_io::ci_layers</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of slices. </p>
<p>Immutable after creation. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01759">1759</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00103">cl_io_fini()</a>, and <a class="el" href="cl__io_8c_source.html#l00831">cl_io_slice_add()</a>.</p>

</div>
</div>
<a class="anchor" id="a245a0c27f43614baa43128f2e82867fa"></a><!-- doxytag: member="cl_io::ci_lockreq" ref="a245a0c27f43614baa43128f2e82867fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__io.html#gac7ff31ceda4789c9101711379ffe824b">cl_io_lock_dmd</a> <a class="el" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa">cl_io::ci_lockreq</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lock requirements, this is just a help info for sublayers. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01763">1763</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e4726f4ed7b0cc829ca85342b383875"></a><!-- doxytag: member="cl_io::ci_lockset" ref="a5e4726f4ed7b0cc829ca85342b383875" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__lockset.html">cl_lockset</a> <a class="el" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875">cl_io::ci_lockset</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>list of locks (to be) acquired by this io. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01761">1761</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00363">cl_io_lock()</a>, <a class="el" href="cl__io_8c_source.html#l00516">cl_io_lock_add()</a>, and <a class="el" href="cl__io_8c_source.html#l00395">cl_io_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2758184445778d1acf0282ac0e6687b"></a><!-- doxytag: member="cl_io::ci_obj" ref="ab2758184445778d1acf0282ac0e6687b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__object.html">cl_object</a>* <a class="el" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b">cl_io::ci_obj</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>main object this io is against. </p>
<p>Immutable after creation. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01752">1752</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00229">cl_io_rw_init()</a>, <a class="el" href="cl__page_8c_source.html#l00652">cl_page_assume()</a>, <a class="el" href="cl__page_8c_source.html#l00555">cl_page_is_owned()</a>, and <a class="el" href="osc__page_8c_source.html#l00667">osc_lru_shrink()</a>.</p>

</div>
</div>
<a class="anchor" id="ae86c9bd21f8243d5f18f88a1c057909a"></a><!-- doxytag: member="cl_io::ci_owned_nr" ref="ae86c9bd21f8243d5f18f88a1c057909a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structcl__io.html#ae86c9bd21f8243d5f18f88a1c057909a">cl_io::ci_owned_nr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of pages owned by this IO. </p>
<p>For invariant checking. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01855">1855</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0848dbd9565e8113af8636a8182f9e1d"></a><!-- doxytag: member="cl_io::ci_parent" ref="a0848dbd9565e8113af8636a8182f9e1d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__io.html">cl_io</a>* <a class="el" href="structcl__io.html#a0848dbd9565e8113af8636a8182f9e1d">cl_io::ci_parent</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Upper layer io, of which this io is a part of. </p>
<p>Immutable after creation. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01757">1757</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l01152">cl_io_top()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d9112d04e0c51b82eb5b31eee94e984"></a><!-- doxytag: member="cl_io::ci_state" ref="a2d9112d04e0c51b82eb5b31eee94e984" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__io.html#ga31cc6886dbe550ea8576111ded9814f3">cl_io_state</a> <a class="el" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984">cl_io::ci_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>current state of <a class="el" href="structcl__io.html" title="State for io.">cl_io</a> state machine. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01750">1750</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00593">cl_io_end()</a>, <a class="el" href="cl__io_8c_source.html#l00103">cl_io_fini()</a>, <a class="el" href="cl__io_8c_source.html#l00469">cl_io_iter_fini()</a>, <a class="el" href="cl__io_8c_source.html#l00439">cl_io_iter_init()</a>, <a class="el" href="cl__io_8c_source.html#l00363">cl_io_lock()</a>, <a class="el" href="cl__io_8c_source.html#l00617">cl_io_read_ahead()</a>, <a class="el" href="cl__io_8c_source.html#l00565">cl_io_start()</a>, and <a class="el" href="cl__io_8c_source.html#l00395">cl_io_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ac02cd7b5e65d1d20d00de68de64d8b50"></a><!-- doxytag: member="cl_io::ci_type" ref="ac02cd7b5e65d1d20d00de68de64d8b50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378">cl_io_type</a> <a class="el" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50">cl_io::ci_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>type of this IO. </p>
<p>Immutable after creation. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01748">1748</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00593">cl_io_end()</a>, <a class="el" href="cl__io_8c_source.html#l00103">cl_io_fini()</a>, <a class="el" href="cl__io_8c_source.html#l00469">cl_io_iter_fini()</a>, <a class="el" href="cl__io_8c_source.html#l00439">cl_io_iter_init()</a>, <a class="el" href="cl__io_8c_source.html#l00363">cl_io_lock()</a>, <a class="el" href="cl__io_8c_source.html#l00617">cl_io_read_ahead()</a>, <a class="el" href="cl__io_8c_source.html#l00490">cl_io_rw_advance()</a>, <a class="el" href="cl__io_8c_source.html#l00565">cl_io_start()</a>, and <a class="el" href="cl__io_8c_source.html#l00395">cl_io_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ac902e3a2f27fed9590e95769bbf93e71"></a><!-- doxytag: member="cl_io::ci_verify_layout" ref="ac902e3a2f27fed9590e95769bbf93e71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="structcl__io.html#ac902e3a2f27fed9590e95769bbf93e71">cl_io::ci_verify_layout</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if layout changed after the IO finishes. </p>
<p>Mainly for HSM requirement. If IO occurs to openning files, it doesn't need to verify layout because HSM won't release openning files. Right now, only two opertaions need to verify layout: glimpse and setattr. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01820">1820</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00103">cl_io_fini()</a>.</p>

</div>
</div>
<a class="anchor" id="a6dad5b14bbe77f890d7d4210374cda50"></a><!-- doxytag: member="cl_io::ft_index" ref="a6dad5b14bbe77f890d7d4210374cda50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pgoff_t <a class="el" href="structcl__io.html#a6dad5b14bbe77f890d7d4210374cda50">cl_io::ft_index</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>page index within file. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01787">1787</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac03a89a0a99f8add03531b91539ccf7a"></a><!-- doxytag: member="cl_io::ft_nob" ref="ac03a89a0a99f8add03531b91539ccf7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structcl__io.html#ac03a89a0a99f8add03531b91539ccf7a">cl_io::ft_nob</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>bytes valid byte on a faulted page. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01789">1789</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="cl__object_8h_source.html">cl_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:58 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
