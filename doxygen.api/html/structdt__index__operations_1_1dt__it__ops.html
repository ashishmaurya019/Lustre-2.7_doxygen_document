<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: dt_index_operations::dt_it_ops Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="structdt__index__operations.html">dt_index_operations</a>::<a class="el" href="structdt__index__operations_1_1dt__it__ops.html">dt_it_ops</a>
  </div>
</div>
<div class="contents">
<h1>dt_index_operations::dt_it_ops Struct Reference</h1><!-- doxytag: class="dt_index_operations::dt_it_ops" -->
<p>Iterator interface.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dt__object_8h_source.html">dt_object.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct dt_it *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a74b9db7e1791f6accf99c80a3a0c43e2">init</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, __u32 attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize new iterator.  <a href="#a74b9db7e1791f6accf99c80a3a0c43e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a9bde98040f4ba4fd69f69aa73c606cdd">fini</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct dt_it *di)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release iterator.  <a href="#a9bde98040f4ba4fd69f69aa73c606cdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a6f4864859efe4a643b4597f0fb87f229">get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct dt_it *di, const struct dt_key *<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a426dff3fc53f2cfed2fe22713d990ddc">key</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move position of iterator.  <a href="#a6f4864859efe4a643b4597f0fb87f229"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a0a49bc42af0733f3a82dd0e8c6cbe1e5">put</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct dt_it *di)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release position.  <a href="#a0a49bc42af0733f3a82dd0e8c6cbe1e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#aa41e28336a93af94d1c5e629d9394631">next</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct dt_it *di)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move to next record.  <a href="#aa41e28336a93af94d1c5e629d9394631"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct dt_key *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a426dff3fc53f2cfed2fe22713d990ddc">key</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return key.  <a href="#a426dff3fc53f2cfed2fe22713d990ddc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a0e2180d888668bf163ebf81fd27dc857">key_size</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return key size.  <a href="#a0e2180d888668bf163ebf81fd27dc857"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a1b24018fcd837461771bb59a4d0c0d05">rec</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di, struct dt_rec *<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a1b24018fcd837461771bb59a4d0c0d05">rec</a>, __u32 attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return record.  <a href="#a1b24018fcd837461771bb59a4d0c0d05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a5a85dfb5e79d606a1abba1c1fd9986cc">rec_size</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di, __u32 attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return record size.  <a href="#a5a85dfb5e79d606a1abba1c1fd9986cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__u64(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a2966e2ef5ccc21df92b6a31b7c4a56f5">store</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a cookie (hash).  <a href="#a2966e2ef5ccc21df92b6a31b7c4a56f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a3ca6f6284e09ac4853574a011d4bd649">load</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di, __u64 hash)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize position using cookie/hash.  <a href="#a3ca6f6284e09ac4853574a011d4bd649"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26fde1d3c4f5e818827e667418f6f4ba"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::key_rec" ref="a26fde1d3c4f5e818827e667418f6f4ba" args=")(const struct lu_env *env, const struct dt_it *di, void *key_rec)" -->
int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a26fde1d3c4f5e818827e667418f6f4ba">key_rec</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di, void *<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a26fde1d3c4f5e818827e667418f6f4ba">key_rec</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not used. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Iterator interface. </p>
<p>Methods to iterate over an existing index, list the keys stored and associated values, get key/value size, etc. </p>

<p>Definition at line <a class="el" href="dt__object_8h_source.html#l01493">1493</a> of file <a class="el" href="dt__object_8h_source.html">dt_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a9bde98040f4ba4fd69f69aa73c606cdd"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::fini" ref="a9bde98040f4ba4fd69f69aa73c606cdd" args=")(const struct lu_env *env, struct dt_it *di)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a9bde98040f4ba4fd69f69aa73c606cdd">dt_index_operations::dt_it_ops::fini</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct dt_it *di)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release iterator. </p>
<p>Release the specified iterator and all the resources associated (e.g. the object, index cache, etc).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f4864859efe4a643b4597f0fb87f229"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::get" ref="a6f4864859efe4a643b4597f0fb87f229" args=")(const struct lu_env *env, struct dt_it *di, const struct dt_key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a6f4864859efe4a643b4597f0fb87f229">dt_index_operations::dt_it_ops::get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct dt_it *di, const struct dt_key *<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a426dff3fc53f2cfed2fe22713d990ddc">key</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move position of iterator. </p>
<p>Move the position of the specified iterator to the specified key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key to position to</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if exact key is found </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if at the record with least key not larger than the key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74b9db7e1791f6accf99c80a3a0c43e2"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::init" ref="a74b9db7e1791f6accf99c80a3a0c43e2" args=")(const struct lu_env *env, struct dt_object *dt, __u32 attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dt_it*(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a74b9db7e1791f6accf99c80a3a0c43e2">dt_index_operations::dt_it_ops::init</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, __u32 attr)<code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and initialize new iterator. </p>
<p>The iterator is a handler to be used in the subsequent methods to access index's content. Note the position is not defined at this point and should be initialized with -&gt;<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a6f4864859efe4a643b4597f0fb87f229" title="Move position of iterator.">get()</a> or -&gt;<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a3ca6f6284e09ac4853574a011d4bd649" title="Initialize position using cookie/hash.">load()</a> method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>ask the iterator to return part of the records, see LUDA_* for details</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pointer</em>&nbsp;</td><td>iterator pointer on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ERR_PTR(errno)</em>&nbsp;</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a426dff3fc53f2cfed2fe22713d990ddc"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::key" ref="a426dff3fc53f2cfed2fe22713d990ddc" args=")(const struct lu_env *env, const struct dt_it *di)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dt_key*(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a426dff3fc53f2cfed2fe22713d990ddc">dt_index_operations::dt_it_ops::key</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di)<code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return key. </p>
<p>Returns a pointer to a buffer containing the key of the record at the current position. The pointer is valid and retains data until -&gt;<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a6f4864859efe4a643b4597f0fb87f229" title="Move position of iterator.">get()</a>, -&gt;<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a3ca6f6284e09ac4853574a011d4bd649" title="Initialize position using cookie/hash.">load()</a> and -&gt;<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a9bde98040f4ba4fd69f69aa73c606cdd" title="Release iterator.">fini()</a> methods are called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pointer</em>&nbsp;</td><td>to key on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ERR_PTR(errno)</em>&nbsp;</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e2180d888668bf163ebf81fd27dc857"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::key_size" ref="a0e2180d888668bf163ebf81fd27dc857" args=")(const struct lu_env *env, const struct dt_it *di)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a0e2180d888668bf163ebf81fd27dc857">dt_index_operations::dt_it_ops::key_size</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return key size. </p>
<p>Returns size of the key at the current position.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key's</em>&nbsp;</td><td>size on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ca6f6284e09ac4853574a011d4bd649"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::load" ref="a3ca6f6284e09ac4853574a011d4bd649" args=")(const struct lu_env *env, const struct dt_it *di, __u64 hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a3ca6f6284e09ac4853574a011d4bd649">dt_index_operations::dt_it_ops::load</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di, __u64 hash)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize position using cookie/hash. </p>
<p>Initializes the current position of the iterator to one described by the cookie/hash as returned by -&gt;<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a2966e2ef5ccc21df92b6a31b7c4a56f5" title="Return a cookie (hash).">store()</a> previously.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hash</em>&nbsp;</td><td>cookie/hash value</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>positive</em>&nbsp;</td><td>if current position points to record with least cookie not larger than cookie </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if current position matches cookie </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa41e28336a93af94d1c5e629d9394631"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::next" ref="aa41e28336a93af94d1c5e629d9394631" args=")(const struct lu_env *env, struct dt_it *di)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#aa41e28336a93af94d1c5e629d9394631">dt_index_operations::dt_it_ops::next</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct dt_it *di)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move to next record. </p>
<p>Moves the position of the iterator to a next record</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if no more records </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success, the next record is found </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a49bc42af0733f3a82dd0e8c6cbe1e5"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::put" ref="a0a49bc42af0733f3a82dd0e8c6cbe1e5" args=")(const struct lu_env *env, struct dt_it *di)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a0a49bc42af0733f3a82dd0e8c6cbe1e5">dt_index_operations::dt_it_ops::put</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct dt_it *di)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release position. </p>
<p>Complimentary method for <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a6f4864859efe4a643b4597f0fb87f229" title="Move position of iterator.">dt_it_ops::get()</a> above. Some implementation can increase a reference on the iterator in <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a6f4864859efe4a643b4597f0fb87f229" title="Move position of iterator.">dt_it_ops::get()</a>. So the caller should be able to release with <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a0a49bc42af0733f3a82dd0e8c6cbe1e5" title="Release position.">dt_it_ops::put()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b24018fcd837461771bb59a4d0c0d05"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::rec" ref="a1b24018fcd837461771bb59a4d0c0d05" args=")(const struct lu_env *env, const struct dt_it *di, struct dt_rec *rec, __u32 attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a1b24018fcd837461771bb59a4d0c0d05">dt_index_operations::dt_it_ops::rec</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di, struct dt_rec *<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a1b24018fcd837461771bb59a4d0c0d05">rec</a>, __u32 attr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return record. </p>
<p>Stores the value of the record at the current position. The buffer must be big enough (as negotiated with -&gt;do_index_try() or -&gt;<a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a5a85dfb5e79d606a1abba1c1fd9986cc" title="Return record size.">rec_size()</a>). The caller can specify she is interested only in part of the record, using attr argument (see LUDA_* definitions for the details).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>rec</em>&nbsp;</td><td>buffer to store value in </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>specify part of the value to copy</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a85dfb5e79d606a1abba1c1fd9986cc"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::rec_size" ref="a5a85dfb5e79d606a1abba1c1fd9986cc" args=")(const struct lu_env *env, const struct dt_it *di, __u32 attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a5a85dfb5e79d606a1abba1c1fd9986cc">dt_index_operations::dt_it_ops::rec_size</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di, __u32 attr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return record size. </p>
<p>Returns size of the record at the current position. The <em>attr</em> can be used to specify only the parts of the record needed to be returned. (see LUDA_* definitions for the details).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>part of the record to return</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>record's</em>&nbsp;</td><td>size on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2966e2ef5ccc21df92b6a31b7c4a56f5"></a><!-- doxytag: member="dt_index_operations::dt_it_ops::store" ref="a2966e2ef5ccc21df92b6a31b7c4a56f5" args=")(const struct lu_env *env, const struct dt_it *di)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__u64(* <a class="el" href="structdt__index__operations_1_1dt__it__ops.html#a2966e2ef5ccc21df92b6a31b7c4a56f5">dt_index_operations::dt_it_ops::store</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct dt_it *di)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a cookie (hash). </p>
<p>Returns the cookie (usually hash) of the key at the current position. This allows the caller to resume iteration at this position later. The exact value is specific to implementation and should not be interpreted by the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>di</em>&nbsp;</td><td>iterator</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cookie/hash</em>&nbsp;</td><td>of the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="dt__object_8h_source.html">dt_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:56:51 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
