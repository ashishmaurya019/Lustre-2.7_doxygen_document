<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/obdclass/cl_io.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/obdclass/cl_io.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * Client IO.</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> *   Author: Nikita Danilov &lt;nikita.danilov@sun.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> *   Author: Jinshan Xiong &lt;jinshan.xiong@intel.com&gt;</span>
<a name="l00040"></a>00040 <span class="comment"> */</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_CLASS</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;linux/sched.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;obd_support.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;lustre_fid.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;libcfs/list.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;cl_object.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;cl_internal.h&quot;</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">/*****************************************************************************</span>
<a name="l00053"></a>00053 <span class="comment"> *</span>
<a name="l00054"></a>00054 <span class="comment"> * cl_io interface.</span>
<a name="l00055"></a>00055 <span class="comment"> *</span>
<a name="l00056"></a>00056 <span class="comment"> */</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="preprocessor">#define cl_io_for_each(slice, io) \</span>
<a name="l00059"></a>00059 <span class="preprocessor">        list_for_each_entry((slice), &amp;io-&gt;ci_layers, cis_linkage)</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#define cl_io_for_each_reverse(slice, io)                 \</span>
<a name="l00061"></a>00061 <span class="preprocessor">        list_for_each_entry_reverse((slice), &amp;io-&gt;ci_layers, cis_linkage)</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> cl_io_type_is_valid(<span class="keyword">enum</span> <a class="code" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378" title="IO types.">cl_io_type</a> type)
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065         <span class="keywordflow">return</span> <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a> &lt;= type &amp;&amp; type &lt; CIT_OP_NR;
<a name="l00066"></a>00066 }
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> cl_io_is_loopable(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00069"></a>00069 {
<a name="l00070"></a>00070         <span class="keywordflow">return</span> cl_io_type_is_valid(io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>) &amp;&amp; io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a> != <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ab21ff138f79ef4d41a40950879bf1e3c" title="Miscellaneous io.">CIT_MISC</a>;
<a name="l00071"></a>00071 }
<a name="l00072"></a>00072 
<a name="l00076"></a><a class="code" href="group__cl__io.html#ga2ae08af9fbe1af93e2d82049e7ae7e3c">00076</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#ga2ae08af9fbe1af93e2d82049e7ae7e3c" title="Returns true iff there is an IO ongoing in the given environment.">cl_io_is_going</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l00077"></a>00077 {
<a name="l00078"></a>00078         <span class="keywordflow">return</span> cl_env_info(env)-&gt;<a class="code" href="structcl__thread__info.html#a9483e30eb2d58f1ed5eb6224090af583" title="Pointer to the topmost ongoing IO in this thread.">clt_current_io</a> != NULL;
<a name="l00079"></a>00079 }
<a name="l00080"></a>00080 
<a name="l00085"></a>00085 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_io_invariant(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00086"></a>00086 {
<a name="l00087"></a>00087         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *up;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089         up = io-&gt;<a class="code" href="structcl__io.html#a0848dbd9565e8113af8636a8182f9e1d" title="Upper layer io, of which this io is a part of.">ci_parent</a>;
<a name="l00090"></a>00090         <span class="keywordflow">return</span>
<a name="l00091"></a>00091                 <span class="comment">/*</span>
<a name="l00092"></a>00092 <span class="comment">                 * io can own pages only when it is ongoing. Sub-io might</span>
<a name="l00093"></a>00093 <span class="comment">                 * still be in CIS_LOCKED state when top-io is in</span>
<a name="l00094"></a>00094 <span class="comment">                 * CIS_IO_GOING.</span>
<a name="l00095"></a>00095 <span class="comment">                 */</span>
<a name="l00096"></a>00096                 ergo(io-&gt;<a class="code" href="structcl__io.html#ae86c9bd21f8243d5f18f88a1c057909a" title="Number of pages owned by this IO.">ci_owned_nr</a> &gt; 0, io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3ae890b65a3f8bcb1142724628e71c247a" title="Actual IO is in progress.">CIS_IO_GOING</a> ||
<a name="l00097"></a>00097                      (io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a7aaaa8f4b4ceebebb8004c39f786d2ba" title="Locks taken.">CIS_LOCKED</a> &amp;&amp; up != NULL));
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00103"></a><a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f">00103</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105         <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a>    *slice;
<a name="l00106"></a>00106         <span class="keyword">struct </span><a class="code" href="structcl__thread__info.html" title="Thread local state internal for generic cl-code.">cl_thread_info</a> *info;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108         LINVRNT(cl_io_type_is_valid(io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>));
<a name="l00109"></a>00109         LINVRNT(cl_io_invariant(io));
<a name="l00110"></a>00110         ENTRY;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         <span class="keywordflow">while</span> (!list_empty(&amp;io-&gt;<a class="code" href="structcl__io.html#ab5a63aa434fec58687af4e284ab2392b" title="List of slices.">ci_layers</a>)) {
<a name="l00113"></a>00113                 slice = container_of(io-&gt;<a class="code" href="structcl__io.html#ab5a63aa434fec58687af4e284ab2392b" title="List of slices.">ci_layers</a>.prev, <span class="keyword">struct</span> <a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a>,
<a name="l00114"></a>00114                                      cis_linkage);
<a name="l00115"></a>00115                 list_del_init(&amp;slice-&gt;<a class="code" href="structcl__io__slice.html#a14f89af8e28c08c0c20c1a157e7ec9e9" title="linkage into a list of all slices for a given cl_io, hanging off cl_io::ci_layers...">cis_linkage</a>);
<a name="l00116"></a>00116                 <span class="keywordflow">if</span> (slice-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a09ecbd759c7a3569d67a75e9f201d1ba" title="Called once per io, bottom-to-top to release io resources.">cio_fini</a> != NULL)
<a name="l00117"></a>00117                         slice-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a09ecbd759c7a3569d67a75e9f201d1ba" title="Called once per io, bottom-to-top to release io resources.">cio_fini</a>(env, slice);
<a name="l00118"></a>00118                 <span class="comment">/*</span>
<a name="l00119"></a>00119 <span class="comment">                 * Invalidate slice to catch use after free. This assumes that</span>
<a name="l00120"></a>00120 <span class="comment">                 * slices are allocated within session and can be touched</span>
<a name="l00121"></a>00121 <span class="comment">                 * after -&gt;cio_fini() returns.</span>
<a name="l00122"></a>00122 <span class="comment">                 */</span>
<a name="l00123"></a>00123                 slice-&gt;cis_io = NULL;
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125         io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> = <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3aeb38a1f10d1e0e66044bbfe4f40a20c0" title="cl_io finalized.">CIS_FINI</a>;
<a name="l00126"></a>00126         info = cl_env_info(env);
<a name="l00127"></a>00127         <span class="keywordflow">if</span> (info-&gt;<a class="code" href="structcl__thread__info.html#a9483e30eb2d58f1ed5eb6224090af583" title="Pointer to the topmost ongoing IO in this thread.">clt_current_io</a> == io)
<a name="l00128"></a>00128                 info-&gt;<a class="code" href="structcl__thread__info.html#a9483e30eb2d58f1ed5eb6224090af583" title="Pointer to the topmost ongoing IO in this thread.">clt_current_io</a> = NULL;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130         <span class="comment">/* sanity check for layout change */</span>
<a name="l00131"></a>00131         <span class="keywordflow">switch</span>(io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>) {
<a name="l00132"></a>00132         <span class="keywordflow">case</span> <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a>:
<a name="l00133"></a>00133         <span class="keywordflow">case</span> <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475" title="write system call">CIT_WRITE</a>:
<a name="l00134"></a>00134         <span class="keywordflow">case</span> <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ae0e5d488dc0faa7eca8a7ab4a48cbc25" title="get data version">CIT_DATA_VERSION</a>:
<a name="l00135"></a>00135         <span class="keywordflow">case</span> <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378af6dd7f3f5e03ad52c7f5a42d5fd03322" title="page fault handling">CIT_FAULT</a>:
<a name="l00136"></a>00136                 <span class="keywordflow">break</span>;
<a name="l00137"></a>00137         <span class="keywordflow">case</span> <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a5e5f57a7ae1e41cc45aa7ec77eacf4b3" title="fsync system call handling To write out a range of file">CIT_FSYNC</a>:
<a name="l00138"></a>00138                 LASSERT(!io-&gt;<a class="code" href="structcl__io.html#a425b5ecdec17c901b3c8d8e09327d902" title="The whole IO need to be restarted because layout has been changed.">ci_need_restart</a>);
<a name="l00139"></a>00139                 <span class="keywordflow">break</span>;
<a name="l00140"></a>00140         <span class="keywordflow">case</span> <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a0a7b38271be1f7d7faac2bfc3f8ce3a6" title="truncate, utime system calls">CIT_SETATTR</a>:
<a name="l00141"></a>00141         <span class="keywordflow">case</span> <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ab21ff138f79ef4d41a40950879bf1e3c" title="Miscellaneous io.">CIT_MISC</a>:
<a name="l00142"></a>00142                 <span class="comment">/* Check ignore layout change conf */</span>
<a name="l00143"></a>00143                 LASSERT(ergo(io-&gt;<a class="code" href="structcl__io.html#a5d6c1c346a6203b03bf6fb768c6799da" title="to not refresh layout - the IO issuer knows that the layout won&amp;#39;t change(page...">ci_ignore_layout</a> || !io-&gt;<a class="code" href="structcl__io.html#ac902e3a2f27fed9590e95769bbf93e71" title="Check if layout changed after the IO finishes.">ci_verify_layout</a>,
<a name="l00144"></a>00144                                 !io-&gt;<a class="code" href="structcl__io.html#a425b5ecdec17c901b3c8d8e09327d902" title="The whole IO need to be restarted because layout has been changed.">ci_need_restart</a>));
<a name="l00145"></a>00145                 <span class="keywordflow">break</span>;
<a name="l00146"></a>00146         <span class="keywordflow">case</span> <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ad49f27c1cdc5be6e64ea32bcb4f16e8d" title="ladvise handling To give advice about access of a file">CIT_LADVISE</a>:
<a name="l00147"></a>00147                 <span class="keywordflow">break</span>;
<a name="l00148"></a>00148         <span class="keywordflow">default</span>:
<a name="l00149"></a>00149                 LBUG();
<a name="l00150"></a>00150         }
<a name="l00151"></a>00151         EXIT;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_io_init0(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00156"></a>00156                        <span class="keyword">enum</span> <a class="code" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378" title="IO types.">cl_io_type</a> iot, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj)
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *scan;
<a name="l00159"></a>00159         <span class="keywordtype">int</span> result;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a533479241f38018af1651a483ca85b91" title="Not initialized.">CIS_ZERO</a> || io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3aeb38a1f10d1e0e66044bbfe4f40a20c0" title="cl_io finalized.">CIS_FINI</a>);
<a name="l00162"></a>00162         LINVRNT(cl_io_type_is_valid(iot));
<a name="l00163"></a>00163         LINVRNT(cl_io_invariant(io));
<a name="l00164"></a>00164         ENTRY;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a> = iot;
<a name="l00167"></a>00167         INIT_LIST_HEAD(&amp;io-&gt;<a class="code" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875" title="list of locks (to be) acquired by this io.">ci_lockset</a>.<a class="code" href="structcl__lockset.html#a7d3dd407c134313ebbcd663d9befe670" title="locks to be acquired.">cls_todo</a>);
<a name="l00168"></a>00168         INIT_LIST_HEAD(&amp;io-&gt;<a class="code" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875" title="list of locks (to be) acquired by this io.">ci_lockset</a>.<a class="code" href="structcl__lockset.html#a837f8683638d3e7b3ef9f38ee514c828" title="locks acquired.">cls_done</a>);
<a name="l00169"></a>00169         INIT_LIST_HEAD(&amp;io-&gt;<a class="code" href="structcl__io.html#ab5a63aa434fec58687af4e284ab2392b" title="List of slices.">ci_layers</a>);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171         result = 0;
<a name="l00172"></a>00172         <a class="code" href="group__cl__object.html#ga6477841d5f3bd9c2a2ca05e2aa089ea9" title="Helper macro: iterate over all layers of the object obj, assigning every layer top-to-bottom...">cl_object_for_each</a>(scan, obj) {
<a name="l00173"></a>00173                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__object.html#a84db2d531bbd895d49cc44b795778064" title="per-object-layer operations">co_ops</a>-&gt;<a class="code" href="structcl__object__operations.html#a8b8a7168fdc690b21120ab5d03ae67ce" title="Initialize io state for a given layer.">coo_io_init</a> != NULL) {
<a name="l00174"></a>00174                         result = scan-&gt;<a class="code" href="structcl__object.html#a84db2d531bbd895d49cc44b795778064" title="per-object-layer operations">co_ops</a>-&gt;<a class="code" href="structcl__object__operations.html#a8b8a7168fdc690b21120ab5d03ae67ce" title="Initialize io state for a given layer.">coo_io_init</a>(env, scan, io);
<a name="l00175"></a>00175                         <span class="keywordflow">if</span> (result != 0)
<a name="l00176"></a>00176                                 <span class="keywordflow">break</span>;
<a name="l00177"></a>00177                 }
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179         <span class="keywordflow">if</span> (result == 0)
<a name="l00180"></a>00180                 io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> = <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a009e9e287aa930cf2a8aa288afbbe134" title="Initialized.">CIS_INIT</a>;
<a name="l00181"></a>00181         RETURN(result);
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00189"></a><a class="code" href="group__cl__io.html#ga485aa4a9e93475523519f07aca310bac">00189</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#ga485aa4a9e93475523519f07aca310bac" title="Initialize sub-io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_sub_init</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00190"></a>00190                    <span class="keyword">enum</span> <a class="code" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378" title="IO types.">cl_io_type</a> iot, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj)
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192         <span class="keyword">struct </span><a class="code" href="structcl__thread__info.html" title="Thread local state internal for generic cl-code.">cl_thread_info</a> *info = cl_env_info(env);
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         LASSERT(obj != <a class="code" href="group__cl__object.html#ga00ef0f7240b9a7d773a49a77c667f03a" title="Returns the top-object for a given o.">cl_object_top</a>(obj));
<a name="l00195"></a>00195         <span class="keywordflow">if</span> (info-&gt;<a class="code" href="structcl__thread__info.html#a9483e30eb2d58f1ed5eb6224090af583" title="Pointer to the topmost ongoing IO in this thread.">clt_current_io</a> == NULL)
<a name="l00196"></a>00196                 info-&gt;<a class="code" href="structcl__thread__info.html#a9483e30eb2d58f1ed5eb6224090af583" title="Pointer to the topmost ongoing IO in this thread.">clt_current_io</a> = io;
<a name="l00197"></a>00197         <span class="keywordflow">return</span> cl_io_init0(env, io, iot, obj);
<a name="l00198"></a>00198 }
<a name="l00199"></a>00199 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#ga485aa4a9e93475523519f07aca310bac" title="Initialize sub-io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_sub_init</a>);
<a name="l00200"></a>00200 
<a name="l00211"></a><a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1">00211</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_init</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00212"></a>00212                <span class="keyword">enum</span> <a class="code" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378" title="IO types.">cl_io_type</a> iot, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj)
<a name="l00213"></a>00213 {
<a name="l00214"></a>00214         <span class="keyword">struct </span><a class="code" href="structcl__thread__info.html" title="Thread local state internal for generic cl-code.">cl_thread_info</a> *info = cl_env_info(env);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         LASSERT(obj == <a class="code" href="group__cl__object.html#ga00ef0f7240b9a7d773a49a77c667f03a" title="Returns the top-object for a given o.">cl_object_top</a>(obj));
<a name="l00217"></a>00217         LASSERT(info-&gt;<a class="code" href="structcl__thread__info.html#a9483e30eb2d58f1ed5eb6224090af583" title="Pointer to the topmost ongoing IO in this thread.">clt_current_io</a> == NULL);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         info-&gt;<a class="code" href="structcl__thread__info.html#a9483e30eb2d58f1ed5eb6224090af583" title="Pointer to the topmost ongoing IO in this thread.">clt_current_io</a> = io;
<a name="l00220"></a>00220         <span class="keywordflow">return</span> cl_io_init0(env, io, iot, obj);
<a name="l00221"></a>00221 }
<a name="l00222"></a>00222 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_init</a>);
<a name="l00223"></a>00223 
<a name="l00229"></a><a class="code" href="group__cl__io.html#gacff72463468f75b6af811bf709aefa9d">00229</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#gacff72463468f75b6af811bf709aefa9d" title="Initialize read or write io.">cl_io_rw_init</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00230"></a>00230                   <span class="keyword">enum</span> <a class="code" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378" title="IO types.">cl_io_type</a> iot, loff_t pos, <span class="keywordtype">size_t</span> count)
<a name="l00231"></a>00231 {
<a name="l00232"></a>00232         LINVRNT(iot == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a> || iot == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475" title="write system call">CIT_WRITE</a>);
<a name="l00233"></a>00233         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a> != NULL);
<a name="l00234"></a>00234         ENTRY;
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         <a class="code" href="group__lu.html#gab6811b221fe08d6e5b46ce532fdd1059" title="Print short object description followed by a user-supplied message.">LU_OBJECT_HEADER</a>(D_VFSTRACE, env, &amp;io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a>-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>,
<a name="l00237"></a>00237                          <span class="stringliteral">&quot;io range: %u [&quot;</span>LPU64<span class="stringliteral">&quot;, &quot;</span>LPU64<span class="stringliteral">&quot;) %u %u\n&quot;</span>,
<a name="l00238"></a>00238                          iot, (__u64)pos, (__u64)pos + count,
<a name="l00239"></a>00239                          io-&gt;u.ci_rw.crw_nonblock, io-&gt;u.ci_wr.wr_append);
<a name="l00240"></a>00240         io-&gt;u.ci_rw.crw_pos    = pos;
<a name="l00241"></a>00241         io-&gt;u.ci_rw.crw_count  = count;
<a name="l00242"></a>00242         RETURN(<a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_init</a>(env, io, iot, io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a>));
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#gacff72463468f75b6af811bf709aefa9d" title="Initialize read or write io.">cl_io_rw_init</a>);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_lock_descr_sort(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *d0,
<a name="l00247"></a>00247                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *d1)
<a name="l00248"></a>00248 {
<a name="l00249"></a>00249         <span class="keywordflow">return</span> lu_fid_cmp(lu_object_fid(&amp;d0-&gt;<a class="code" href="structcl__lock__descr.html#a4364f7ff8f5675436ccb006540452752" title="Object this lock is granted for.">cld_obj</a>-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>),
<a name="l00250"></a>00250                           lu_object_fid(&amp;d1-&gt;<a class="code" href="structcl__lock__descr.html#a4364f7ff8f5675436ccb006540452752" title="Object this lock is granted for.">cld_obj</a>-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <span class="comment">/*</span>
<a name="l00254"></a>00254 <span class="comment"> * Sort locks in lexicographical order of their (fid, start-offset) pairs.</span>
<a name="l00255"></a>00255 <span class="comment"> */</span>
<a name="l00256"></a>00256 <span class="keyword">static</span> <span class="keywordtype">void</span> cl_io_locks_sort(<span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00257"></a>00257 {
<a name="l00258"></a>00258         <span class="keywordtype">int</span> done = 0;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260         ENTRY;
<a name="l00261"></a>00261         <span class="comment">/* hidden treasure: bubble sort for now. */</span>
<a name="l00262"></a>00262         <span class="keywordflow">do</span> {
<a name="l00263"></a>00263                 <span class="keyword">struct </span><a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a> *curr;
<a name="l00264"></a>00264                 <span class="keyword">struct </span><a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a> *prev;
<a name="l00265"></a>00265                 <span class="keyword">struct </span><a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a> *temp;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267                 done = 1;
<a name="l00268"></a>00268                 prev = NULL;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270                 list_for_each_entry_safe(curr, temp, &amp;io-&gt;<a class="code" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875" title="list of locks (to be) acquired by this io.">ci_lockset</a>.<a class="code" href="structcl__lockset.html#a7d3dd407c134313ebbcd663d9befe670" title="locks to be acquired.">cls_todo</a>,
<a name="l00271"></a>00271                                          <a class="code" href="structcl__io__lock__link.html#a3df88f5b5efcfe0b936f66774d5a6fed" title="linkage into one of cl_lockset lists.">cill_linkage</a>) {
<a name="l00272"></a>00272                         <span class="keywordflow">if</span> (prev != NULL) {
<a name="l00273"></a>00273                                 <span class="keywordflow">switch</span> (cl_lock_descr_sort(&amp;prev-&gt;cill_descr,
<a name="l00274"></a>00274                                                            &amp;curr-&gt;cill_descr)) {
<a name="l00275"></a>00275                                 <span class="keywordflow">case</span> 0:
<a name="l00276"></a>00276                                         <span class="comment">/*</span>
<a name="l00277"></a>00277 <span class="comment">                                         * IMPOSSIBLE:  Identical locks are</span>
<a name="l00278"></a>00278 <span class="comment">                                         *              already removed at</span>
<a name="l00279"></a>00279 <span class="comment">                                         *              this point.</span>
<a name="l00280"></a>00280 <span class="comment">                                         */</span>
<a name="l00281"></a>00281                                 <span class="keywordflow">default</span>:
<a name="l00282"></a>00282                                         LBUG();
<a name="l00283"></a>00283                                 <span class="keywordflow">case</span> +1:
<a name="l00284"></a>00284                                         list_move_tail(&amp;curr-&gt;<a class="code" href="structcl__io__lock__link.html#a3df88f5b5efcfe0b936f66774d5a6fed" title="linkage into one of cl_lockset lists.">cill_linkage</a>,
<a name="l00285"></a>00285                                                        &amp;prev-&gt;<a class="code" href="structcl__io__lock__link.html#a3df88f5b5efcfe0b936f66774d5a6fed" title="linkage into one of cl_lockset lists.">cill_linkage</a>);
<a name="l00286"></a>00286                                         done = 0;
<a name="l00287"></a>00287                                         <span class="keywordflow">continue</span>; <span class="comment">/* don&apos;t change prev: it&apos;s</span>
<a name="l00288"></a>00288 <span class="comment">                                                   * still &quot;previous&quot; */</span>
<a name="l00289"></a>00289                                 <span class="keywordflow">case</span> -1: <span class="comment">/* already in order */</span>
<a name="l00290"></a>00290                                         <span class="keywordflow">break</span>;
<a name="l00291"></a>00291                                 }
<a name="l00292"></a>00292                         }
<a name="l00293"></a>00293                         prev = curr;
<a name="l00294"></a>00294                 }
<a name="l00295"></a>00295         } <span class="keywordflow">while</span> (!done);
<a name="l00296"></a>00296         EXIT;
<a name="l00297"></a>00297 }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="keyword">static</span> <span class="keywordtype">void</span> cl_lock_descr_merge(<span class="keyword">struct</span> <a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *d0,
<a name="l00300"></a>00300                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *d1)
<a name="l00301"></a>00301 {
<a name="l00302"></a>00302         d0-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a> = min(d0-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a>, d1-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a>);
<a name="l00303"></a>00303         d0-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a> = max(d0-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>, d1-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>);
<a name="l00304"></a>00304 
<a name="l00305"></a>00305         <span class="keywordflow">if</span> (d1-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> == CLM_WRITE &amp;&amp; d0-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> != CLM_WRITE)
<a name="l00306"></a>00306                 d0-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> = CLM_WRITE;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308         <span class="keywordflow">if</span> (d1-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> == CLM_GROUP &amp;&amp; d0-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> != CLM_GROUP)
<a name="l00309"></a>00309                 d0-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> = CLM_GROUP;
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_lockset_merge(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lockset.html" title="Lock-set represents a collection of locks, that io needs at a time.">cl_lockset</a> *<span class="keyword">set</span>,
<a name="l00313"></a>00313                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *need)
<a name="l00314"></a>00314 {
<a name="l00315"></a>00315         <span class="keyword">struct </span><a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a> *scan;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317         ENTRY;
<a name="l00318"></a>00318         list_for_each_entry(scan, &amp;set-&gt;cls_todo, <a class="code" href="structcl__io__lock__link.html#a3df88f5b5efcfe0b936f66774d5a6fed" title="linkage into one of cl_lockset lists.">cill_linkage</a>) {
<a name="l00319"></a>00319                 <span class="keywordflow">if</span> (!cl_object_same(scan-&gt;cill_descr.cld_obj, need-&gt;<a class="code" href="structcl__lock__descr.html#a4364f7ff8f5675436ccb006540452752" title="Object this lock is granted for.">cld_obj</a>))
<a name="l00320"></a>00320                         <span class="keywordflow">continue</span>;
<a name="l00321"></a>00321 
<a name="l00322"></a>00322                 <span class="comment">/* Merge locks for the same object because ldlm lock server</span>
<a name="l00323"></a>00323 <span class="comment">                 * may expand the lock extent, otherwise there is a deadlock</span>
<a name="l00324"></a>00324 <span class="comment">                 * case if two conflicted locks are queueud for the same object</span>
<a name="l00325"></a>00325 <span class="comment">                 * and lock server expands one lock to overlap the another.</span>
<a name="l00326"></a>00326 <span class="comment">                 * The side effect is that it can generate a multi-stripe lock</span>
<a name="l00327"></a>00327 <span class="comment">                 * that may cause casacading problem */</span>
<a name="l00328"></a>00328                 cl_lock_descr_merge(&amp;scan-&gt;cill_descr, need);
<a name="l00329"></a>00329                 CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;lock: %d: [%lu, %lu]\n&quot;</span>,
<a name="l00330"></a>00330                        scan-&gt;cill_descr.cld_mode, scan-&gt;cill_descr.cld_start,
<a name="l00331"></a>00331                        scan-&gt;cill_descr.cld_end);
<a name="l00332"></a>00332                 RETURN(+1);
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334         RETURN(0);
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_lockset_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00338"></a>00338                            <span class="keyword">struct</span> <a class="code" href="structcl__lockset.html" title="Lock-set represents a collection of locks, that io needs at a time.">cl_lockset</a> *<span class="keyword">set</span>)
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340         <span class="keyword">struct </span><a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a> *link;
<a name="l00341"></a>00341         <span class="keyword">struct </span><a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a> *temp;
<a name="l00342"></a>00342         <span class="keywordtype">int</span> result;
<a name="l00343"></a>00343 
<a name="l00344"></a>00344         ENTRY;
<a name="l00345"></a>00345         result = 0;
<a name="l00346"></a>00346         list_for_each_entry_safe(link, temp, &amp;set-&gt;cls_todo, <a class="code" href="structcl__io__lock__link.html#a3df88f5b5efcfe0b936f66774d5a6fed" title="linkage into one of cl_lockset lists.">cill_linkage</a>) {
<a name="l00347"></a>00347                 result = <a class="code" href="group__cl__lock.html#ga4afe671873f4a7343d9c50c574557fd6" title="Main high-level entry point of cl_lock interface that finds existing or enqueues...">cl_lock_request</a>(env, io, &amp;link-&gt;cill_lock);
<a name="l00348"></a>00348                 <span class="keywordflow">if</span> (result &lt; 0)
<a name="l00349"></a>00349                         <span class="keywordflow">break</span>;
<a name="l00350"></a>00350 
<a name="l00351"></a>00351                 list_move(&amp;link-&gt;<a class="code" href="structcl__io__lock__link.html#a3df88f5b5efcfe0b936f66774d5a6fed" title="linkage into one of cl_lockset lists.">cill_linkage</a>, &amp;set-&gt;cls_done);
<a name="l00352"></a>00352         }
<a name="l00353"></a>00353         RETURN(result);
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00363"></a><a class="code" href="group__cl__io.html#ga2229beaa77461f453fa4e1f1e129cbe6">00363</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#ga2229beaa77461f453fa4e1f1e129cbe6" title="Takes locks necessary for the current iteration of io.">cl_io_lock</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00364"></a>00364 {
<a name="l00365"></a>00365         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00366"></a>00366         <span class="keywordtype">int</span> result = 0;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368         LINVRNT(cl_io_is_loopable(io));
<a name="l00369"></a>00369         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3ad8aa8993a7b31bf97b878e8ad84b9154" title="IO iteration started.">CIS_IT_STARTED</a>);
<a name="l00370"></a>00370         LINVRNT(cl_io_invariant(io));
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         ENTRY;
<a name="l00373"></a>00373         cl_io_for_each(scan, io) {
<a name="l00374"></a>00374                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a4211dc9e2bf48da829c2fffd4633b1cf" title="Collect locks for the current iteration of io.">cio_lock</a> == NULL)
<a name="l00375"></a>00375                         <span class="keywordflow">continue</span>;
<a name="l00376"></a>00376                 result = scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a4211dc9e2bf48da829c2fffd4633b1cf" title="Collect locks for the current iteration of io.">cio_lock</a>(env, scan);
<a name="l00377"></a>00377                 <span class="keywordflow">if</span> (result != 0)
<a name="l00378"></a>00378                         <span class="keywordflow">break</span>;
<a name="l00379"></a>00379         }
<a name="l00380"></a>00380         <span class="keywordflow">if</span> (result == 0) {
<a name="l00381"></a>00381                 cl_io_locks_sort(io);
<a name="l00382"></a>00382                 result = cl_lockset_lock(env, io, &amp;io-&gt;<a class="code" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875" title="list of locks (to be) acquired by this io.">ci_lockset</a>);
<a name="l00383"></a>00383         }
<a name="l00384"></a>00384         <span class="keywordflow">if</span> (result != 0)
<a name="l00385"></a>00385                 <a class="code" href="group__cl__io.html#ga0de2f26e31233ef3bf8c7315b412e681" title="Release locks takes by io.">cl_io_unlock</a>(env, io);
<a name="l00386"></a>00386         <span class="keywordflow">else</span>
<a name="l00387"></a>00387                 io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> = <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a7aaaa8f4b4ceebebb8004c39f786d2ba" title="Locks taken.">CIS_LOCKED</a>;
<a name="l00388"></a>00388         RETURN(result);
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#ga2229beaa77461f453fa4e1f1e129cbe6" title="Takes locks necessary for the current iteration of io.">cl_io_lock</a>);
<a name="l00391"></a>00391 
<a name="l00395"></a><a class="code" href="group__cl__io.html#ga0de2f26e31233ef3bf8c7315b412e681">00395</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__io.html#ga0de2f26e31233ef3bf8c7315b412e681" title="Release locks takes by io.">cl_io_unlock</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00396"></a>00396 {
<a name="l00397"></a>00397         <span class="keyword">struct </span><a class="code" href="structcl__lockset.html" title="Lock-set represents a collection of locks, that io needs at a time.">cl_lockset</a>        *<span class="keyword">set</span>;
<a name="l00398"></a>00398         <span class="keyword">struct </span><a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a>   *link;
<a name="l00399"></a>00399         <span class="keyword">struct </span><a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a>   *temp;
<a name="l00400"></a>00400         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402         LASSERT(cl_io_is_loopable(io));
<a name="l00403"></a>00403         LASSERT(CIS_IT_STARTED &lt;= io-&gt;ci_state &amp;&amp; io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> &lt; <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a3d421a3505fbc9098add0227c3e978c5" title="Locks released.">CIS_UNLOCKED</a>);
<a name="l00404"></a>00404         LINVRNT(cl_io_invariant(io));
<a name="l00405"></a>00405 
<a name="l00406"></a>00406         ENTRY;
<a name="l00407"></a>00407         <span class="keyword">set</span> = &amp;io-&gt;<a class="code" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875" title="list of locks (to be) acquired by this io.">ci_lockset</a>;
<a name="l00408"></a>00408 
<a name="l00409"></a>00409         list_for_each_entry_safe(link, temp, &amp;set-&gt;cls_todo, cill_linkage) {
<a name="l00410"></a>00410                 list_del_init(&amp;link-&gt;<a class="code" href="structcl__io__lock__link.html#a3df88f5b5efcfe0b936f66774d5a6fed" title="linkage into one of cl_lockset lists.">cill_linkage</a>);
<a name="l00411"></a>00411                 <span class="keywordflow">if</span> (link-&gt;<a class="code" href="structcl__io__lock__link.html#aab4fd92e8e398d878829036d409df66f" title="optional destructor">cill_fini</a> != NULL)
<a name="l00412"></a>00412                         link-&gt;<a class="code" href="structcl__io__lock__link.html#aab4fd92e8e398d878829036d409df66f" title="optional destructor">cill_fini</a>(env, link);
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415         list_for_each_entry_safe(link, temp, &amp;set-&gt;cls_done, cill_linkage) {
<a name="l00416"></a>00416                 list_del_init(&amp;link-&gt;<a class="code" href="structcl__io__lock__link.html#a3df88f5b5efcfe0b936f66774d5a6fed" title="linkage into one of cl_lockset lists.">cill_linkage</a>);
<a name="l00417"></a>00417                 <a class="code" href="group__cl__lock.html#ga4e8069a400c6a75342649a6fc04fa2c3" title="Releases a hold and a reference on a lock, obtained by cl_lock_hold().">cl_lock_release</a>(env, &amp;link-&gt;cill_lock);
<a name="l00418"></a>00418                 <span class="keywordflow">if</span> (link-&gt;<a class="code" href="structcl__io__lock__link.html#aab4fd92e8e398d878829036d409df66f" title="optional destructor">cill_fini</a> != NULL)
<a name="l00419"></a>00419                         link-&gt;<a class="code" href="structcl__io__lock__link.html#aab4fd92e8e398d878829036d409df66f" title="optional destructor">cill_fini</a>(env, link);
<a name="l00420"></a>00420         }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422         cl_io_for_each_reverse(scan, io) {
<a name="l00423"></a>00423                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a8f4e4c71f42b1acdc2b935826d2a6e90" title="Finalize unlocking.">cio_unlock</a> != NULL)
<a name="l00424"></a>00424                         scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a8f4e4c71f42b1acdc2b935826d2a6e90" title="Finalize unlocking.">cio_unlock</a>(env, scan);
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426         io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> = <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a3d421a3505fbc9098add0227c3e978c5" title="Locks released.">CIS_UNLOCKED</a>;
<a name="l00427"></a>00427         LASSERT(!cl_env_info(env)-&gt;clt_counters[CNL_TOP].ctc_nr_locks_acquired);
<a name="l00428"></a>00428         EXIT;
<a name="l00429"></a>00429 }
<a name="l00430"></a>00430 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#ga0de2f26e31233ef3bf8c7315b412e681" title="Release locks takes by io.">cl_io_unlock</a>);
<a name="l00431"></a>00431 
<a name="l00439"></a><a class="code" href="group__cl__io.html#gac1a8e0e9d4277fcde8a56794f6f41003">00439</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#gac1a8e0e9d4277fcde8a56794f6f41003" title="Prepares next iteration of io.">cl_io_iter_init</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00440"></a>00440 {
<a name="l00441"></a>00441         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00442"></a>00442         <span class="keywordtype">int</span> result;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444         LINVRNT(cl_io_is_loopable(io));
<a name="l00445"></a>00445         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a009e9e287aa930cf2a8aa288afbbe134" title="Initialized.">CIS_INIT</a> || io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a4a452e3aadf68f37073952f26f59ecbe" title="Iteration completed.">CIS_IT_ENDED</a>);
<a name="l00446"></a>00446         LINVRNT(cl_io_invariant(io));
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         ENTRY;
<a name="l00449"></a>00449         result = 0;
<a name="l00450"></a>00450         cl_io_for_each(scan, io) {
<a name="l00451"></a>00451                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#aeedb0fcc4555583225020c012c5b84e1" title="Prepare io iteration at a given layer.">cio_iter_init</a> == NULL)
<a name="l00452"></a>00452                         <span class="keywordflow">continue</span>;
<a name="l00453"></a>00453                 result = scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#aeedb0fcc4555583225020c012c5b84e1" title="Prepare io iteration at a given layer.">cio_iter_init</a>(env,
<a name="l00454"></a>00454                                                                       scan);
<a name="l00455"></a>00455                 <span class="keywordflow">if</span> (result != 0)
<a name="l00456"></a>00456                         <span class="keywordflow">break</span>;
<a name="l00457"></a>00457         }
<a name="l00458"></a>00458         <span class="keywordflow">if</span> (result == 0)
<a name="l00459"></a>00459                 io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> = <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3ad8aa8993a7b31bf97b878e8ad84b9154" title="IO iteration started.">CIS_IT_STARTED</a>;
<a name="l00460"></a>00460         RETURN(result);
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#gac1a8e0e9d4277fcde8a56794f6f41003" title="Prepares next iteration of io.">cl_io_iter_init</a>);
<a name="l00463"></a>00463 
<a name="l00469"></a><a class="code" href="group__cl__io.html#gad8b5d08373d6d963c67c2682e41999ac">00469</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__io.html#gad8b5d08373d6d963c67c2682e41999ac" title="Finalizes io iteration.">cl_io_iter_fini</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00470"></a>00470 {
<a name="l00471"></a>00471         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         LINVRNT(cl_io_is_loopable(io));
<a name="l00474"></a>00474         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a3d421a3505fbc9098add0227c3e978c5" title="Locks released.">CIS_UNLOCKED</a>);
<a name="l00475"></a>00475         LINVRNT(cl_io_invariant(io));
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         ENTRY;
<a name="l00478"></a>00478         cl_io_for_each_reverse(scan, io) {
<a name="l00479"></a>00479                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a2c6f9fa7cecb546bd2b46156d57b10dd" title="Finalize io iteration.">cio_iter_fini</a> != NULL)
<a name="l00480"></a>00480                         scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a2c6f9fa7cecb546bd2b46156d57b10dd" title="Finalize io iteration.">cio_iter_fini</a>(env, scan);
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482         io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> = <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a4a452e3aadf68f37073952f26f59ecbe" title="Iteration completed.">CIS_IT_ENDED</a>;
<a name="l00483"></a>00483         EXIT;
<a name="l00484"></a>00484 }
<a name="l00485"></a>00485 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#gad8b5d08373d6d963c67c2682e41999ac" title="Finalizes io iteration.">cl_io_iter_fini</a>);
<a name="l00486"></a>00486 
<a name="l00490"></a><a class="code" href="group__cl__io.html#ga0e67009a999662295be41a4532bf6f37">00490</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__io.html#ga0e67009a999662295be41a4532bf6f37" title="Records that read or write io progressed nob bytes forward.">cl_io_rw_advance</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keywordtype">size_t</span> nob)
<a name="l00491"></a>00491 {
<a name="l00492"></a>00492         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a> == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a> || io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a> == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475" title="write system call">CIT_WRITE</a> ||
<a name="l00495"></a>00495                 nob == 0);
<a name="l00496"></a>00496         LINVRNT(cl_io_is_loopable(io));
<a name="l00497"></a>00497         LINVRNT(cl_io_invariant(io));
<a name="l00498"></a>00498 
<a name="l00499"></a>00499         ENTRY;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501         io-&gt;u.ci_rw.crw_pos   += nob;
<a name="l00502"></a>00502         io-&gt;u.ci_rw.crw_count -= nob;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504         <span class="comment">/* layers have to be notified. */</span>
<a name="l00505"></a>00505         cl_io_for_each_reverse(scan, io) {
<a name="l00506"></a>00506                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a32c79a8ffbf81724ef4df5c2fd05e263" title="Called bottom-to-top to notify layers that read/write IO iteration finished, with...">cio_advance</a> != NULL)
<a name="l00507"></a>00507                         scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a32c79a8ffbf81724ef4df5c2fd05e263" title="Called bottom-to-top to notify layers that read/write IO iteration finished, with...">cio_advance</a>(env, scan,
<a name="l00508"></a>00508                                                                    nob);
<a name="l00509"></a>00509         }
<a name="l00510"></a>00510         EXIT;
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00516"></a><a class="code" href="group__cl__io.html#ga80fe084e78e83a4a66fceb0e2c605b6e">00516</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#ga80fe084e78e83a4a66fceb0e2c605b6e" title="Adds a lock to a lockset.">cl_io_lock_add</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00517"></a>00517                    <span class="keyword">struct</span> <a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a> *link)
<a name="l00518"></a>00518 {
<a name="l00519"></a>00519         <span class="keywordtype">int</span> result;
<a name="l00520"></a>00520 
<a name="l00521"></a>00521         ENTRY;
<a name="l00522"></a>00522         <span class="keywordflow">if</span> (cl_lockset_merge(&amp;io-&gt;<a class="code" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875" title="list of locks (to be) acquired by this io.">ci_lockset</a>, &amp;link-&gt;cill_descr))
<a name="l00523"></a>00523                 result = +1;
<a name="l00524"></a>00524         <span class="keywordflow">else</span> {
<a name="l00525"></a>00525                 list_add(&amp;link-&gt;<a class="code" href="structcl__io__lock__link.html#a3df88f5b5efcfe0b936f66774d5a6fed" title="linkage into one of cl_lockset lists.">cill_linkage</a>, &amp;io-&gt;<a class="code" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875" title="list of locks (to be) acquired by this io.">ci_lockset</a>.<a class="code" href="structcl__lockset.html#a7d3dd407c134313ebbcd663d9befe670" title="locks to be acquired.">cls_todo</a>);
<a name="l00526"></a>00526                 result = 0;
<a name="l00527"></a>00527         }
<a name="l00528"></a>00528         RETURN(result);
<a name="l00529"></a>00529 }
<a name="l00530"></a>00530 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#ga80fe084e78e83a4a66fceb0e2c605b6e" title="Adds a lock to a lockset.">cl_io_lock_add</a>);
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="keyword">static</span> <span class="keywordtype">void</span> cl_free_io_lock_link(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00533"></a>00533                                  <span class="keyword">struct</span> <a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a> *link)
<a name="l00534"></a>00534 {
<a name="l00535"></a>00535         OBD_FREE_PTR(link);
<a name="l00536"></a>00536 }
<a name="l00537"></a>00537 
<a name="l00541"></a><a class="code" href="group__cl__io.html#ga3ce86bab1ea06d8d2d7ac15f3a0be3f6">00541</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#ga3ce86bab1ea06d8d2d7ac15f3a0be3f6" title="Allocates new lock link, and uses it to add a lock to a lockset.">cl_io_lock_alloc_add</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00542"></a>00542                          <span class="keyword">struct</span> <a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *descr)
<a name="l00543"></a>00543 {
<a name="l00544"></a>00544         <span class="keyword">struct </span><a class="code" href="structcl__io__lock__link.html" title="Link between lock and io.">cl_io_lock_link</a> *link;
<a name="l00545"></a>00545         <span class="keywordtype">int</span> result;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547         ENTRY;
<a name="l00548"></a>00548         OBD_ALLOC_PTR(link);
<a name="l00549"></a>00549         <span class="keywordflow">if</span> (link != NULL) {
<a name="l00550"></a>00550                 link-&gt;cill_descr = *descr;
<a name="l00551"></a>00551                 link-&gt;<a class="code" href="structcl__io__lock__link.html#aab4fd92e8e398d878829036d409df66f" title="optional destructor">cill_fini</a>  = cl_free_io_lock_link;
<a name="l00552"></a>00552                 result = <a class="code" href="group__cl__io.html#ga80fe084e78e83a4a66fceb0e2c605b6e" title="Adds a lock to a lockset.">cl_io_lock_add</a>(env, io, link);
<a name="l00553"></a>00553                 <span class="keywordflow">if</span> (result) <span class="comment">/* lock match */</span>
<a name="l00554"></a>00554                         link-&gt;<a class="code" href="structcl__io__lock__link.html#aab4fd92e8e398d878829036d409df66f" title="optional destructor">cill_fini</a>(env, link);
<a name="l00555"></a>00555         } <span class="keywordflow">else</span>
<a name="l00556"></a>00556                 result = -ENOMEM;
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         RETURN(result);
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#ga3ce86bab1ea06d8d2d7ac15f3a0be3f6" title="Allocates new lock link, and uses it to add a lock to a lockset.">cl_io_lock_alloc_add</a>);
<a name="l00561"></a>00561 
<a name="l00565"></a><a class="code" href="group__cl__io.html#gacf4c2a55f31d42191ff49b8685163008">00565</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#gacf4c2a55f31d42191ff49b8685163008" title="Starts io by calling cl_io_operations::cio_start() top-to-bottom.">cl_io_start</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00566"></a>00566 {
<a name="l00567"></a>00567         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00568"></a>00568         <span class="keywordtype">int</span> result = 0;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         LINVRNT(cl_io_is_loopable(io));
<a name="l00571"></a>00571         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a7aaaa8f4b4ceebebb8004c39f786d2ba" title="Locks taken.">CIS_LOCKED</a>);
<a name="l00572"></a>00572         LINVRNT(cl_io_invariant(io));
<a name="l00573"></a>00573         ENTRY;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> = <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3ae890b65a3f8bcb1142724628e71c247a" title="Actual IO is in progress.">CIS_IO_GOING</a>;
<a name="l00576"></a>00576         cl_io_for_each(scan, io) {
<a name="l00577"></a>00577                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a29bbb031f049b8a1a5e54d575fa88209" title="Start io iteration.">cio_start</a> == NULL)
<a name="l00578"></a>00578                         <span class="keywordflow">continue</span>;
<a name="l00579"></a>00579                 result = scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a29bbb031f049b8a1a5e54d575fa88209" title="Start io iteration.">cio_start</a>(env, scan);
<a name="l00580"></a>00580                 <span class="keywordflow">if</span> (result != 0)
<a name="l00581"></a>00581                         <span class="keywordflow">break</span>;
<a name="l00582"></a>00582         }
<a name="l00583"></a>00583         <span class="keywordflow">if</span> (result &gt;= 0)
<a name="l00584"></a>00584                 result = 0;
<a name="l00585"></a>00585         RETURN(result);
<a name="l00586"></a>00586 }
<a name="l00587"></a>00587 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#gacf4c2a55f31d42191ff49b8685163008" title="Starts io by calling cl_io_operations::cio_start() top-to-bottom.">cl_io_start</a>);
<a name="l00588"></a>00588 
<a name="l00593"></a><a class="code" href="group__cl__io.html#gaffebdf9278fa11f9dbecfeb3f5852fb5">00593</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__io.html#gaffebdf9278fa11f9dbecfeb3f5852fb5" title="Wait until current io iteration is finished by calling cl_io_operations::cio_end()...">cl_io_end</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00594"></a>00594 {
<a name="l00595"></a>00595         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00596"></a>00596 
<a name="l00597"></a>00597         LINVRNT(cl_io_is_loopable(io));
<a name="l00598"></a>00598         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3ae890b65a3f8bcb1142724628e71c247a" title="Actual IO is in progress.">CIS_IO_GOING</a>);
<a name="l00599"></a>00599         LINVRNT(cl_io_invariant(io));
<a name="l00600"></a>00600         ENTRY;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602         cl_io_for_each_reverse(scan, io) {
<a name="l00603"></a>00603                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a4d3dfb49a0fbf1f90b3de60841183d0a" title="Called top-to-bottom at the end of io loop.">cio_end</a> != NULL)
<a name="l00604"></a>00604                         scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a646d5084e9960fc83c6ac20e37640282" title="Vector of io state transition methods for every io type.">op</a>[io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a>].<a class="code" href="structcl__io__operations.html#a4d3dfb49a0fbf1f90b3de60841183d0a" title="Called top-to-bottom at the end of io loop.">cio_end</a>(env, scan);
<a name="l00605"></a>00605                 <span class="comment">/* TODO: error handling. */</span>
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607         io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> = <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a4c41fb95967777c249bd9b835a1e4a8e" title="IO for the current iteration finished.">CIS_IO_FINISHED</a>;
<a name="l00608"></a>00608         EXIT;
<a name="l00609"></a>00609 }
<a name="l00610"></a>00610 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#gaffebdf9278fa11f9dbecfeb3f5852fb5" title="Wait until current io iteration is finished by calling cl_io_operations::cio_end()...">cl_io_end</a>);
<a name="l00611"></a>00611 
<a name="l00617"></a><a class="code" href="group__cl__io.html#gad5b4d2971764744ec2f5d30fe56d9781">00617</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#gad5b4d2971764744ec2f5d30fe56d9781" title="Called by read io, to decide the readahead extent.">cl_io_read_ahead</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00618"></a>00618                      pgoff_t start, <span class="keyword">struct</span> <a class="code" href="structcl__read__ahead.html">cl_read_ahead</a> *ra)
<a name="l00619"></a>00619 {
<a name="l00620"></a>00620         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00621"></a>00621         <span class="keywordtype">int</span>                       result = 0;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a> == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a> || io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a> == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378af6dd7f3f5e03ad52c7f5a42d5fd03322" title="page fault handling">CIT_FAULT</a>);
<a name="l00624"></a>00624         LINVRNT(io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3ae890b65a3f8bcb1142724628e71c247a" title="Actual IO is in progress.">CIS_IO_GOING</a> || io-&gt;<a class="code" href="structcl__io.html#a2d9112d04e0c51b82eb5b31eee94e984" title="current state of cl_io state machine.">ci_state</a> == <a class="code" href="group__cl__io.html#gga31cc6886dbe550ea8576111ded9814f3a7aaaa8f4b4ceebebb8004c39f786d2ba" title="Locks taken.">CIS_LOCKED</a>);
<a name="l00625"></a>00625         LINVRNT(cl_io_invariant(io));
<a name="l00626"></a>00626         ENTRY;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628         cl_io_for_each(scan, io) {
<a name="l00629"></a>00629                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a4a7f6334b0e726f9c7fc52b8064a2613" title="Decide maximum read ahead extent.">cio_read_ahead</a> == NULL)
<a name="l00630"></a>00630                         <span class="keywordflow">continue</span>;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632                 result = scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a4a7f6334b0e726f9c7fc52b8064a2613" title="Decide maximum read ahead extent.">cio_read_ahead</a>(env, scan, start, ra);
<a name="l00633"></a>00633                 <span class="keywordflow">if</span> (result != 0)
<a name="l00634"></a>00634                         <span class="keywordflow">break</span>;
<a name="l00635"></a>00635         }
<a name="l00636"></a>00636         RETURN(result &gt; 0 ? 0 : result);
<a name="l00637"></a>00637 }
<a name="l00638"></a>00638 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#gad5b4d2971764744ec2f5d30fe56d9781" title="Called by read io, to decide the readahead extent.">cl_io_read_ahead</a>);
<a name="l00639"></a>00639 
<a name="l00646"></a><a class="code" href="group__cl__io.html#gac830ac176054e906a54a4db48fbf45bb">00646</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#gac830ac176054e906a54a4db48fbf45bb" title="Commit a list of contiguous pages into writeback cache.">cl_io_commit_async</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00647"></a>00647                         <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *queue, <span class="keywordtype">int</span> from, <span class="keywordtype">int</span> to,
<a name="l00648"></a>00648                         cl_commit_cbt cb)
<a name="l00649"></a>00649 {
<a name="l00650"></a>00650         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00651"></a>00651         <span class="keywordtype">int</span> result = 0;
<a name="l00652"></a>00652         ENTRY;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654         cl_io_for_each(scan, io) {
<a name="l00655"></a>00655                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a1c88c4ec4901b77c0a32b3951f217f8c" title="Queue async page for write.">cio_commit_async</a> == NULL)
<a name="l00656"></a>00656                         <span class="keywordflow">continue</span>;
<a name="l00657"></a>00657                 result = scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a1c88c4ec4901b77c0a32b3951f217f8c" title="Queue async page for write.">cio_commit_async</a>(env, scan, queue,
<a name="l00658"></a>00658                                                          from, to, cb);
<a name="l00659"></a>00659                 <span class="keywordflow">if</span> (result != 0)
<a name="l00660"></a>00660                         <span class="keywordflow">break</span>;
<a name="l00661"></a>00661         }
<a name="l00662"></a>00662         RETURN(result);
<a name="l00663"></a>00663 }
<a name="l00664"></a>00664 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#gac830ac176054e906a54a4db48fbf45bb" title="Commit a list of contiguous pages into writeback cache.">cl_io_commit_async</a>);
<a name="l00665"></a>00665 
<a name="l00676"></a><a class="code" href="group__cl__io.html#gae609957e435aaa7c3044b45cada6b96c">00676</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#gae609957e435aaa7c3044b45cada6b96c" title="Submits a list of pages for immediate io.">cl_io_submit_rw</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00677"></a>00677                     <span class="keyword">enum</span> <a class="code" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02" title="Requested transfer type.">cl_req_type</a> crt, <span class="keyword">struct</span> <a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a> *queue)
<a name="l00678"></a>00678 {
<a name="l00679"></a>00679         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *scan;
<a name="l00680"></a>00680         <span class="keywordtype">int</span> result = 0;
<a name="l00681"></a>00681         ENTRY;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         cl_io_for_each(scan, io) {
<a name="l00684"></a>00684                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a2aa87d92a0f183a26ae076afc9b8b74f" title="Submit pages from queue-&amp;gt;c2_qin for IO, and move successfully submitted pages...">cio_submit</a> == NULL)
<a name="l00685"></a>00685                         <span class="keywordflow">continue</span>;
<a name="l00686"></a>00686                 result = scan-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a>-&gt;<a class="code" href="structcl__io__operations.html#a2aa87d92a0f183a26ae076afc9b8b74f" title="Submit pages from queue-&amp;gt;c2_qin for IO, and move successfully submitted pages...">cio_submit</a>(env, scan, crt, queue);
<a name="l00687"></a>00687                 <span class="keywordflow">if</span> (result != 0)
<a name="l00688"></a>00688                         <span class="keywordflow">break</span>;
<a name="l00689"></a>00689         }
<a name="l00690"></a>00690         <span class="comment">/*</span>
<a name="l00691"></a>00691 <span class="comment">         * If -&gt;cio_submit() failed, no pages were sent.</span>
<a name="l00692"></a>00692 <span class="comment">         */</span>
<a name="l00693"></a>00693         LASSERT(ergo(result != 0, list_empty(&amp;queue-&gt;c2_qout.pl_pages)));
<a name="l00694"></a>00694         RETURN(result);
<a name="l00695"></a>00695 }
<a name="l00696"></a>00696 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#gae609957e435aaa7c3044b45cada6b96c" title="Submits a list of pages for immediate io.">cl_io_submit_rw</a>);
<a name="l00697"></a>00697 
<a name="l00702"></a><a class="code" href="group__cl__io.html#ga575a43e2ec65ba4aa6c926cf5e49fe70">00702</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#ga575a43e2ec65ba4aa6c926cf5e49fe70" title="Submit a sync_io and wait for the IO to be finished, or error happens.">cl_io_submit_sync</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00703"></a>00703                       <span class="keyword">enum</span> <a class="code" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02" title="Requested transfer type.">cl_req_type</a> iot, <span class="keyword">struct</span> <a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a> *queue,
<a name="l00704"></a>00704                       <span class="keywordtype">long</span> timeout)
<a name="l00705"></a>00705 {
<a name="l00706"></a>00706         <span class="keyword">struct </span><a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a> *anchor = &amp;cl_env_info(env)-&gt;<a class="code" href="structcl__thread__info.html#a781696e18feaf78b895a129c01774e1e" title="Used for submitting a sync io.">clt_anchor</a>;
<a name="l00707"></a>00707         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *pg;
<a name="l00708"></a>00708         <span class="keywordtype">int</span> rc;
<a name="l00709"></a>00709 
<a name="l00710"></a>00710         <a class="code" href="group__cl__page__list.html#ga31a6630a381a5667594d699aa7269794" title="Iterate over pages in a page list.">cl_page_list_for_each</a>(pg, &amp;queue-&gt;c2_qin) {
<a name="l00711"></a>00711                 LASSERT(pg-&gt;<a class="code" href="structcl__page.html#a9fee0561b08bf01258f9824f0c2b62d2" title="Assigned if doing a sync_io.">cp_sync_io</a> == NULL);
<a name="l00712"></a>00712                 pg-&gt;<a class="code" href="structcl__page.html#a9fee0561b08bf01258f9824f0c2b62d2" title="Assigned if doing a sync_io.">cp_sync_io</a> = anchor;
<a name="l00713"></a>00713         }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         <a class="code" href="group__cl__sync__io.html#ga9e4705c43e9207a09c6cd8c9fac1c3e5" title="Initialize synchronous io wait anchor.">cl_sync_io_init</a>(anchor, queue-&gt;c2_qin.pl_nr, &amp;cl_sync_io_end);
<a name="l00716"></a>00716         rc = <a class="code" href="group__cl__io.html#gae609957e435aaa7c3044b45cada6b96c" title="Submits a list of pages for immediate io.">cl_io_submit_rw</a>(env, io, iot, queue);
<a name="l00717"></a>00717         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00718"></a>00718                 <span class="comment">/*</span>
<a name="l00719"></a>00719 <span class="comment">                 * If some pages weren&apos;t sent for any reason (e.g.,</span>
<a name="l00720"></a>00720 <span class="comment">                 * read found up-to-date pages in the cache, or write found</span>
<a name="l00721"></a>00721 <span class="comment">                 * clean pages), count them as completed to avoid infinite</span>
<a name="l00722"></a>00722 <span class="comment">                 * wait.</span>
<a name="l00723"></a>00723 <span class="comment">                 */</span>
<a name="l00724"></a>00724                 <a class="code" href="group__cl__page__list.html#ga31a6630a381a5667594d699aa7269794" title="Iterate over pages in a page list.">cl_page_list_for_each</a>(pg, &amp;queue-&gt;c2_qin) {
<a name="l00725"></a>00725                         pg-&gt;<a class="code" href="structcl__page.html#a9fee0561b08bf01258f9824f0c2b62d2" title="Assigned if doing a sync_io.">cp_sync_io</a> = NULL;
<a name="l00726"></a>00726                         <a class="code" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9" title="Indicate that transfer of a single page completed.">cl_sync_io_note</a>(env, anchor, 1);
<a name="l00727"></a>00727                 }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729                 <span class="comment">/* wait for the IO to be finished. */</span>
<a name="l00730"></a>00730                 rc = <a class="code" href="group__cl__sync__io.html#ga92057d29f315080be03e18c0262a1871" title="Wait until all IO completes.">cl_sync_io_wait</a>(env, anchor, timeout);
<a name="l00731"></a>00731                 <a class="code" href="group__cl__page__list.html#ga321527c28a251fead1c4d8e7967da693" title="Assumes all pages in a queue.">cl_page_list_assume</a>(env, io, &amp;queue-&gt;c2_qout);
<a name="l00732"></a>00732         } <span class="keywordflow">else</span> {
<a name="l00733"></a>00733                 LASSERT(list_empty(&amp;queue-&gt;c2_qout.pl_pages));
<a name="l00734"></a>00734                 <a class="code" href="group__cl__page__list.html#ga31a6630a381a5667594d699aa7269794" title="Iterate over pages in a page list.">cl_page_list_for_each</a>(pg, &amp;queue-&gt;c2_qin)
<a name="l00735"></a>00735                         pg-&gt;<a class="code" href="structcl__page.html#a9fee0561b08bf01258f9824f0c2b62d2" title="Assigned if doing a sync_io.">cp_sync_io</a> = NULL;
<a name="l00736"></a>00736         }
<a name="l00737"></a>00737         <span class="keywordflow">return</span> rc;
<a name="l00738"></a>00738 }
<a name="l00739"></a>00739 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#ga575a43e2ec65ba4aa6c926cf5e49fe70" title="Submit a sync_io and wait for the IO to be finished, or error happens.">cl_io_submit_sync</a>);
<a name="l00740"></a>00740 
<a name="l00744"></a><a class="code" href="group__cl__io.html#ga9e1b49d71ec98da5a7f4bd1fba415ad5">00744</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#ga9e1b49d71ec98da5a7f4bd1fba415ad5" title="Cancel an IO which has been submitted by cl_io_submit_rw.">cl_io_cancel</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00745"></a>00745                  <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *queue)
<a name="l00746"></a>00746 {
<a name="l00747"></a>00747         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page;
<a name="l00748"></a>00748         <span class="keywordtype">int</span> result = 0;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         CERROR(<span class="stringliteral">&quot;Canceling ongoing page trasmission\n&quot;</span>);
<a name="l00751"></a>00751         <a class="code" href="group__cl__page__list.html#ga31a6630a381a5667594d699aa7269794" title="Iterate over pages in a page list.">cl_page_list_for_each</a>(page, queue) {
<a name="l00752"></a>00752                 <span class="keywordtype">int</span> rc;
<a name="l00753"></a>00753 
<a name="l00754"></a>00754                 rc = <a class="code" href="group__cl__page.html#ga2b98b954f28349bd90316fec9ebaec83" title="Cancel a page which is still in a transfer.">cl_page_cancel</a>(env, page);
<a name="l00755"></a>00755                 result = result ?: rc;
<a name="l00756"></a>00756         }
<a name="l00757"></a>00757         <span class="keywordflow">return</span> result;
<a name="l00758"></a>00758 }
<a name="l00759"></a>00759 
<a name="l00779"></a><a class="code" href="group__cl__io.html#ga2b13e91188661c45925b56e88b000c6e">00779</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__io.html#ga2b13e91188661c45925b56e88b000c6e" title="Main io loop.">cl_io_loop</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781         <span class="keywordtype">int</span> result   = 0;
<a name="l00782"></a>00782 
<a name="l00783"></a>00783         LINVRNT(cl_io_is_loopable(io));
<a name="l00784"></a>00784         ENTRY;
<a name="l00785"></a>00785 
<a name="l00786"></a>00786         <span class="keywordflow">do</span> {
<a name="l00787"></a>00787                 <span class="keywordtype">size_t</span> nob;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789                 io-&gt;ci_continue = 0;
<a name="l00790"></a>00790                 result = <a class="code" href="group__cl__io.html#gac1a8e0e9d4277fcde8a56794f6f41003" title="Prepares next iteration of io.">cl_io_iter_init</a>(env, io);
<a name="l00791"></a>00791                 <span class="keywordflow">if</span> (result == 0) {
<a name="l00792"></a>00792                         nob    = io-&gt;ci_nob;
<a name="l00793"></a>00793                         result = <a class="code" href="group__cl__io.html#ga2229beaa77461f453fa4e1f1e129cbe6" title="Takes locks necessary for the current iteration of io.">cl_io_lock</a>(env, io);
<a name="l00794"></a>00794                         <span class="keywordflow">if</span> (result == 0) {
<a name="l00795"></a>00795                                 <span class="comment">/*</span>
<a name="l00796"></a>00796 <span class="comment">                                 * Notify layers that locks has been taken,</span>
<a name="l00797"></a>00797 <span class="comment">                                 * and do actual i/o.</span>
<a name="l00798"></a>00798 <span class="comment">                                 *</span>
<a name="l00799"></a>00799 <span class="comment">                                 *   - llite: kms, short read;</span>
<a name="l00800"></a>00800 <span class="comment">                                 *   - llite: generic_file_read();</span>
<a name="l00801"></a>00801 <span class="comment">                                 */</span>
<a name="l00802"></a>00802                                 result = <a class="code" href="group__cl__io.html#gacf4c2a55f31d42191ff49b8685163008" title="Starts io by calling cl_io_operations::cio_start() top-to-bottom.">cl_io_start</a>(env, io);
<a name="l00803"></a>00803                                 <span class="comment">/*</span>
<a name="l00804"></a>00804 <span class="comment">                                 * Send any remaining pending</span>
<a name="l00805"></a>00805 <span class="comment">                                 * io, etc.</span>
<a name="l00806"></a>00806 <span class="comment">                                 *</span>
<a name="l00807"></a>00807 <span class="comment">                                 *   - llite: ll_rw_stats_tally.</span>
<a name="l00808"></a>00808 <span class="comment">                                 */</span>
<a name="l00809"></a>00809                                 <a class="code" href="group__cl__io.html#gaffebdf9278fa11f9dbecfeb3f5852fb5" title="Wait until current io iteration is finished by calling cl_io_operations::cio_end()...">cl_io_end</a>(env, io);
<a name="l00810"></a>00810                                 <a class="code" href="group__cl__io.html#ga0de2f26e31233ef3bf8c7315b412e681" title="Release locks takes by io.">cl_io_unlock</a>(env, io);
<a name="l00811"></a>00811                                 <a class="code" href="group__cl__io.html#ga0e67009a999662295be41a4532bf6f37" title="Records that read or write io progressed nob bytes forward.">cl_io_rw_advance</a>(env, io, io-&gt;ci_nob - nob);
<a name="l00812"></a>00812                         }
<a name="l00813"></a>00813                 }
<a name="l00814"></a>00814                 <a class="code" href="group__cl__io.html#gad8b5d08373d6d963c67c2682e41999ac" title="Finalizes io iteration.">cl_io_iter_fini</a>(env, io);
<a name="l00815"></a>00815         } <span class="keywordflow">while</span> (result == 0 &amp;&amp; io-&gt;ci_continue);
<a name="l00816"></a>00816         <span class="keywordflow">if</span> (result == 0)
<a name="l00817"></a>00817                 result = io-&gt;ci_result;
<a name="l00818"></a>00818         RETURN(result &lt; 0 ? result : 0);
<a name="l00819"></a>00819 }
<a name="l00820"></a>00820 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#ga2b13e91188661c45925b56e88b000c6e" title="Main io loop.">cl_io_loop</a>);
<a name="l00821"></a>00821 
<a name="l00831"></a><a class="code" href="group__clio.html#ga7f11d31070279077648197650a60f10e">00831</a> <span class="keywordtype">void</span> <a class="code" href="group__clio.html#ga7f11d31070279077648197650a60f10e" title="Adds io slice to the cl_io.">cl_io_slice_add</a>(<span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keyword">struct</span> <a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> *slice,
<a name="l00832"></a>00832                      <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00833"></a>00833                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io__operations.html" title="Per-layer io operations.">cl_io_operations</a> *ops)
<a name="l00834"></a>00834 {
<a name="l00835"></a>00835         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *linkage = &amp;slice-&gt;<a class="code" href="structcl__io__slice.html#a14f89af8e28c08c0c20c1a157e7ec9e9" title="linkage into a list of all slices for a given cl_io, hanging off cl_io::ci_layers...">cis_linkage</a>;
<a name="l00836"></a>00836 
<a name="l00837"></a>00837         LASSERT((linkage-&gt;prev == NULL &amp;&amp; linkage-&gt;next == NULL) ||
<a name="l00838"></a>00838                 list_empty(linkage));
<a name="l00839"></a>00839         ENTRY;
<a name="l00840"></a>00840 
<a name="l00841"></a>00841         list_add_tail(linkage, &amp;io-&gt;<a class="code" href="structcl__io.html#ab5a63aa434fec58687af4e284ab2392b" title="List of slices.">ci_layers</a>);
<a name="l00842"></a>00842         slice-&gt;cis_io  = io;
<a name="l00843"></a>00843         slice-&gt;<a class="code" href="structcl__io__slice.html#a9f4d53548c52d6d9639819fd62557008" title="corresponding object slice.">cis_obj</a> = obj;
<a name="l00844"></a>00844         slice-&gt;<a class="code" href="structcl__io__slice.html#a18ddc4d2d844be0a28d5303ca1e79964" title="io operations.">cis_iop</a> = ops;
<a name="l00845"></a>00845         EXIT;
<a name="l00846"></a>00846 }
<a name="l00847"></a>00847 EXPORT_SYMBOL(<a class="code" href="group__clio.html#ga7f11d31070279077648197650a60f10e" title="Adds io slice to the cl_io.">cl_io_slice_add</a>);
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 
<a name="l00853"></a><a class="code" href="group__cl__page__list.html#ga90ce1bc2aafa623ad024e213a05e00f0">00853</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#ga90ce1bc2aafa623ad024e213a05e00f0" title="Initializes page list.">cl_page_list_init</a>(<span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *plist)
<a name="l00854"></a>00854 {
<a name="l00855"></a>00855         ENTRY;
<a name="l00856"></a>00856         plist-&gt;pl_nr = 0;
<a name="l00857"></a>00857         INIT_LIST_HEAD(&amp;plist-&gt;pl_pages);
<a name="l00858"></a>00858         plist-&gt;pl_owner = current;
<a name="l00859"></a>00859         EXIT;
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#ga90ce1bc2aafa623ad024e213a05e00f0" title="Initializes page list.">cl_page_list_init</a>);
<a name="l00862"></a>00862 
<a name="l00866"></a><a class="code" href="group__cl__page__list.html#ga78d782095ec6f5d72e432d0ef0b35b3a">00866</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#ga78d782095ec6f5d72e432d0ef0b35b3a" title="Adds a page to a page list.">cl_page_list_add</a>(<span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *plist, <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page)
<a name="l00867"></a>00867 {
<a name="l00868"></a>00868         ENTRY;
<a name="l00869"></a>00869         <span class="comment">/* it would be better to check that page is owned by &quot;current&quot; io, but</span>
<a name="l00870"></a>00870 <span class="comment">         * it is not passed here. */</span>
<a name="l00871"></a>00871         LASSERT(page-&gt;<a class="code" href="structcl__page.html#aa9fa7162c90de9f32abb3aa306c2112a" title="Owning IO in cl_page_state::CPS_OWNED state.">cp_owner</a> != NULL);
<a name="l00872"></a>00872         LINVRNT(plist-&gt;pl_owner == current);
<a name="l00873"></a>00873 
<a name="l00874"></a>00874         LASSERT(list_empty(&amp;page-&gt;<a class="code" href="structcl__page.html#a728db31646edabc4ff8c8cfc3f30f10f" title="Linkage of pages within group.">cp_batch</a>));
<a name="l00875"></a>00875         list_add_tail(&amp;page-&gt;<a class="code" href="structcl__page.html#a728db31646edabc4ff8c8cfc3f30f10f" title="Linkage of pages within group.">cp_batch</a>, &amp;plist-&gt;pl_pages);
<a name="l00876"></a>00876         ++plist-&gt;pl_nr;
<a name="l00877"></a>00877         lu_ref_add_at(&amp;page-&gt;<a class="code" href="structcl__page.html#a6df94d2c121a8372ded94e0bf00d8c45" title="List of references to this page, for debugging.">cp_reference</a>, &amp;page-&gt;<a class="code" href="structcl__page.html#abfe411a851a9881cc9aca12ac6fcaf94" title="Link to a queue, for debugging.">cp_queue_ref</a>, <span class="stringliteral">&quot;queue&quot;</span>, plist);
<a name="l00878"></a>00878         <a class="code" href="group__cl__page.html#gafc2fc785c3daf1db46bb250244dfde13" title="Acquires an additional reference to a page.">cl_page_get</a>(page);
<a name="l00879"></a>00879         EXIT;
<a name="l00880"></a>00880 }
<a name="l00881"></a>00881 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#ga78d782095ec6f5d72e432d0ef0b35b3a" title="Adds a page to a page list.">cl_page_list_add</a>);
<a name="l00882"></a>00882 
<a name="l00886"></a><a class="code" href="group__cl__page__list.html#ga365b60118b6d1e7cf4ce21d58babf5b9">00886</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#ga365b60118b6d1e7cf4ce21d58babf5b9" title="Removes a page from a page list.">cl_page_list_del</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00887"></a>00887                       <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *plist, <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page)
<a name="l00888"></a>00888 {
<a name="l00889"></a>00889         LASSERT(plist-&gt;pl_nr &gt; 0);
<a name="l00890"></a>00890         LASSERT(<a class="code" href="group__cl__page.html#gaff21e5139bb0af2f15e2cfb9cfb587f3" title="Returns true, iff pg is VM locked in a suitable sense by the calling thread.">cl_page_is_vmlocked</a>(env, page));
<a name="l00891"></a>00891         LINVRNT(plist-&gt;pl_owner == current);
<a name="l00892"></a>00892 
<a name="l00893"></a>00893         ENTRY;
<a name="l00894"></a>00894         list_del_init(&amp;page-&gt;<a class="code" href="structcl__page.html#a728db31646edabc4ff8c8cfc3f30f10f" title="Linkage of pages within group.">cp_batch</a>);
<a name="l00895"></a>00895         --plist-&gt;pl_nr;
<a name="l00896"></a>00896         lu_ref_del_at(&amp;page-&gt;<a class="code" href="structcl__page.html#a6df94d2c121a8372ded94e0bf00d8c45" title="List of references to this page, for debugging.">cp_reference</a>, &amp;page-&gt;<a class="code" href="structcl__page.html#abfe411a851a9881cc9aca12ac6fcaf94" title="Link to a queue, for debugging.">cp_queue_ref</a>, <span class="stringliteral">&quot;queue&quot;</span>, plist);
<a name="l00897"></a>00897         <a class="code" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1" title="Releases a reference to a page.">cl_page_put</a>(env, page);
<a name="l00898"></a>00898         EXIT;
<a name="l00899"></a>00899 }
<a name="l00900"></a>00900 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#ga365b60118b6d1e7cf4ce21d58babf5b9" title="Removes a page from a page list.">cl_page_list_del</a>);
<a name="l00901"></a>00901 
<a name="l00905"></a><a class="code" href="group__cl__page__list.html#gac81a19417ea58bb1b38001636f07cf8c">00905</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#gac81a19417ea58bb1b38001636f07cf8c" title="Moves a page from one page list to another.">cl_page_list_move</a>(<span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *dst, <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *src,
<a name="l00906"></a>00906                        <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page)
<a name="l00907"></a>00907 {
<a name="l00908"></a>00908         LASSERT(src-&gt;pl_nr &gt; 0);
<a name="l00909"></a>00909         LINVRNT(dst-&gt;pl_owner == current);
<a name="l00910"></a>00910         LINVRNT(src-&gt;pl_owner == current);
<a name="l00911"></a>00911 
<a name="l00912"></a>00912         ENTRY;
<a name="l00913"></a>00913         list_move_tail(&amp;page-&gt;<a class="code" href="structcl__page.html#a728db31646edabc4ff8c8cfc3f30f10f" title="Linkage of pages within group.">cp_batch</a>, &amp;dst-&gt;pl_pages);
<a name="l00914"></a>00914         --src-&gt;pl_nr;
<a name="l00915"></a>00915         ++dst-&gt;pl_nr;
<a name="l00916"></a>00916         lu_ref_set_at(&amp;page-&gt;<a class="code" href="structcl__page.html#a6df94d2c121a8372ded94e0bf00d8c45" title="List of references to this page, for debugging.">cp_reference</a>, &amp;page-&gt;<a class="code" href="structcl__page.html#abfe411a851a9881cc9aca12ac6fcaf94" title="Link to a queue, for debugging.">cp_queue_ref</a>, <span class="stringliteral">&quot;queue&quot;</span>,
<a name="l00917"></a>00917                       src, dst);
<a name="l00918"></a>00918         EXIT;
<a name="l00919"></a>00919 }
<a name="l00920"></a>00920 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#gac81a19417ea58bb1b38001636f07cf8c" title="Moves a page from one page list to another.">cl_page_list_move</a>);
<a name="l00921"></a>00921 
<a name="l00925"></a><a class="code" href="group__cl__page__list.html#ga06da834a47d10c42fdd688c728213d8c">00925</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#ga06da834a47d10c42fdd688c728213d8c" title="Moves a page from one page list to the head of another list.">cl_page_list_move_head</a>(<span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *dst, <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *src,
<a name="l00926"></a>00926                             <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page)
<a name="l00927"></a>00927 {
<a name="l00928"></a>00928         LASSERT(src-&gt;pl_nr &gt; 0);
<a name="l00929"></a>00929         LINVRNT(dst-&gt;pl_owner == current);
<a name="l00930"></a>00930         LINVRNT(src-&gt;pl_owner == current);
<a name="l00931"></a>00931 
<a name="l00932"></a>00932         ENTRY;
<a name="l00933"></a>00933         list_move(&amp;page-&gt;<a class="code" href="structcl__page.html#a728db31646edabc4ff8c8cfc3f30f10f" title="Linkage of pages within group.">cp_batch</a>, &amp;dst-&gt;pl_pages);
<a name="l00934"></a>00934         --src-&gt;pl_nr;
<a name="l00935"></a>00935         ++dst-&gt;pl_nr;
<a name="l00936"></a>00936         lu_ref_set_at(&amp;page-&gt;<a class="code" href="structcl__page.html#a6df94d2c121a8372ded94e0bf00d8c45" title="List of references to this page, for debugging.">cp_reference</a>, &amp;page-&gt;<a class="code" href="structcl__page.html#abfe411a851a9881cc9aca12ac6fcaf94" title="Link to a queue, for debugging.">cp_queue_ref</a>, <span class="stringliteral">&quot;queue&quot;</span>,
<a name="l00937"></a>00937                         src, dst);
<a name="l00938"></a>00938         EXIT;
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#ga06da834a47d10c42fdd688c728213d8c" title="Moves a page from one page list to the head of another list.">cl_page_list_move_head</a>);
<a name="l00941"></a>00941 
<a name="l00945"></a><a class="code" href="group__cl__page__list.html#gac4c762cc3608863a8e5a766def8bf1c8">00945</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#gac4c762cc3608863a8e5a766def8bf1c8" title="splice the cl_page_list, just as list head does">cl_page_list_splice</a>(<span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *list, <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *head)
<a name="l00946"></a>00946 {
<a name="l00947"></a>00947         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page;
<a name="l00948"></a>00948         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *tmp;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950         LINVRNT(list-&gt;pl_owner == current);
<a name="l00951"></a>00951         LINVRNT(head-&gt;pl_owner == current);
<a name="l00952"></a>00952 
<a name="l00953"></a>00953         ENTRY;
<a name="l00954"></a>00954         <a class="code" href="group__cl__page__list.html#gae1b447b26c7ca703b2ef0fdfa82ca575" title="Iterate over pages in a page list, taking possible removals into account.">cl_page_list_for_each_safe</a>(page, tmp, list)
<a name="l00955"></a>00955                 <a class="code" href="group__cl__page__list.html#gac81a19417ea58bb1b38001636f07cf8c" title="Moves a page from one page list to another.">cl_page_list_move</a>(head, list, page);
<a name="l00956"></a>00956         EXIT;
<a name="l00957"></a>00957 }
<a name="l00958"></a>00958 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#gac4c762cc3608863a8e5a766def8bf1c8" title="splice the cl_page_list, just as list head does">cl_page_list_splice</a>);
<a name="l00959"></a>00959 
<a name="l00963"></a><a class="code" href="group__cl__page__list.html#ga6775317c52f6e2540b62563f559cfab6">00963</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#ga6775317c52f6e2540b62563f559cfab6" title="Disowns pages in a queue.">cl_page_list_disown</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00964"></a>00964                          <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *plist)
<a name="l00965"></a>00965 {
<a name="l00966"></a>00966         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page;
<a name="l00967"></a>00967         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *temp;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         LINVRNT(plist-&gt;pl_owner == current);
<a name="l00970"></a>00970 
<a name="l00971"></a>00971         ENTRY;
<a name="l00972"></a>00972         <a class="code" href="group__cl__page__list.html#gae1b447b26c7ca703b2ef0fdfa82ca575" title="Iterate over pages in a page list, taking possible removals into account.">cl_page_list_for_each_safe</a>(page, temp, plist) {
<a name="l00973"></a>00973                 LASSERT(plist-&gt;pl_nr &gt; 0);
<a name="l00974"></a>00974 
<a name="l00975"></a>00975                 list_del_init(&amp;page-&gt;<a class="code" href="structcl__page.html#a728db31646edabc4ff8c8cfc3f30f10f" title="Linkage of pages within group.">cp_batch</a>);
<a name="l00976"></a>00976                 --plist-&gt;pl_nr;
<a name="l00977"></a>00977                 <span class="comment">/*</span>
<a name="l00978"></a>00978 <span class="comment">                 * cl_page_disown0 rather than usual cl_page_disown() is used,</span>
<a name="l00979"></a>00979 <span class="comment">                 * because pages are possibly in CPS_FREEING state already due</span>
<a name="l00980"></a>00980 <span class="comment">                 * to the call to cl_page_list_discard().</span>
<a name="l00981"></a>00981 <span class="comment">                 */</span>
<a name="l00982"></a>00982                 <span class="comment">/*</span>
<a name="l00983"></a>00983 <span class="comment">                 * XXX cl_page_disown0() will fail if page is not locked.</span>
<a name="l00984"></a>00984 <span class="comment">                 */</span>
<a name="l00985"></a>00985                 cl_page_disown0(env, io, page);
<a name="l00986"></a>00986                 lu_ref_del_at(&amp;page-&gt;<a class="code" href="structcl__page.html#a6df94d2c121a8372ded94e0bf00d8c45" title="List of references to this page, for debugging.">cp_reference</a>, &amp;page-&gt;<a class="code" href="structcl__page.html#abfe411a851a9881cc9aca12ac6fcaf94" title="Link to a queue, for debugging.">cp_queue_ref</a>, <span class="stringliteral">&quot;queue&quot;</span>,
<a name="l00987"></a>00987                               plist);
<a name="l00988"></a>00988                 <a class="code" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1" title="Releases a reference to a page.">cl_page_put</a>(env, page);
<a name="l00989"></a>00989         }
<a name="l00990"></a>00990         EXIT;
<a name="l00991"></a>00991 }
<a name="l00992"></a>00992 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#ga6775317c52f6e2540b62563f559cfab6" title="Disowns pages in a queue.">cl_page_list_disown</a>);
<a name="l00993"></a>00993 
<a name="l00997"></a><a class="code" href="group__cl__page__list.html#gaf77c34a166e78fa83a75ec296dc0d3fe">00997</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#gaf77c34a166e78fa83a75ec296dc0d3fe" title="Releases pages from queue.">cl_page_list_fini</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *plist)
<a name="l00998"></a>00998 {
<a name="l00999"></a>00999         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page;
<a name="l01000"></a>01000         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *temp;
<a name="l01001"></a>01001 
<a name="l01002"></a>01002         LINVRNT(plist-&gt;pl_owner == current);
<a name="l01003"></a>01003 
<a name="l01004"></a>01004         ENTRY;
<a name="l01005"></a>01005         <a class="code" href="group__cl__page__list.html#gae1b447b26c7ca703b2ef0fdfa82ca575" title="Iterate over pages in a page list, taking possible removals into account.">cl_page_list_for_each_safe</a>(page, temp, plist)
<a name="l01006"></a>01006                 <a class="code" href="group__cl__page__list.html#ga365b60118b6d1e7cf4ce21d58babf5b9" title="Removes a page from a page list.">cl_page_list_del</a>(env, plist, page);
<a name="l01007"></a>01007         LASSERT(plist-&gt;pl_nr == 0);
<a name="l01008"></a>01008         EXIT;
<a name="l01009"></a>01009 }
<a name="l01010"></a>01010 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#gaf77c34a166e78fa83a75ec296dc0d3fe" title="Releases pages from queue.">cl_page_list_fini</a>);
<a name="l01011"></a>01011 
<a name="l01015"></a><a class="code" href="group__cl__page__list.html#gaddbba15e99055d90aba88ec1b282455a">01015</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__page__list.html#gaddbba15e99055d90aba88ec1b282455a" title="Owns all pages in a queue.">cl_page_list_own</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01016"></a>01016                      <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *plist)
<a name="l01017"></a>01017 {
<a name="l01018"></a>01018         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page;
<a name="l01019"></a>01019         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *temp;
<a name="l01020"></a>01020         <span class="keywordtype">int</span> result;
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         LINVRNT(plist-&gt;pl_owner == current);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         ENTRY;
<a name="l01025"></a>01025         result = 0;
<a name="l01026"></a>01026         <a class="code" href="group__cl__page__list.html#gae1b447b26c7ca703b2ef0fdfa82ca575" title="Iterate over pages in a page list, taking possible removals into account.">cl_page_list_for_each_safe</a>(page, temp, plist) {
<a name="l01027"></a>01027                 <span class="keywordflow">if</span> (<a class="code" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own</a>(env, io, page) == 0)
<a name="l01028"></a>01028                         result = result ?: page-&gt;<a class="code" href="structcl__page.html#aaf3ea4b65234c8ef58960233b82172b1" title="Transfer error.">cp_error</a>;
<a name="l01029"></a>01029                 <span class="keywordflow">else</span>
<a name="l01030"></a>01030                         <a class="code" href="group__cl__page__list.html#ga365b60118b6d1e7cf4ce21d58babf5b9" title="Removes a page from a page list.">cl_page_list_del</a>(env, plist, page);
<a name="l01031"></a>01031         }
<a name="l01032"></a>01032         RETURN(result);
<a name="l01033"></a>01033 }
<a name="l01034"></a>01034 
<a name="l01038"></a><a class="code" href="group__cl__page__list.html#ga321527c28a251fead1c4d8e7967da693">01038</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#ga321527c28a251fead1c4d8e7967da693" title="Assumes all pages in a queue.">cl_page_list_assume</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01039"></a>01039                          <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *plist)
<a name="l01040"></a>01040 {
<a name="l01041"></a>01041         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page;
<a name="l01042"></a>01042 
<a name="l01043"></a>01043         LINVRNT(plist-&gt;pl_owner == current);
<a name="l01044"></a>01044 
<a name="l01045"></a>01045         <a class="code" href="group__cl__page__list.html#ga31a6630a381a5667594d699aa7269794" title="Iterate over pages in a page list.">cl_page_list_for_each</a>(page, plist)
<a name="l01046"></a>01046                 <a class="code" href="group__cl__page.html#ga77a2e8592e58cc9c514cb4ac38a9d2f4" title="Assume page ownership.">cl_page_assume</a>(env, io, page);
<a name="l01047"></a>01047 }
<a name="l01048"></a>01048 
<a name="l01052"></a><a class="code" href="group__cl__page__list.html#gabe8fbe4bdda923be3d8ee245549230f8">01052</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#gabe8fbe4bdda923be3d8ee245549230f8" title="Discards all pages in a queue.">cl_page_list_discard</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l01053"></a>01053                           <span class="keyword">struct</span> <a class="code" href="structcl__page__list.html">cl_page_list</a> *plist)
<a name="l01054"></a>01054 {
<a name="l01055"></a>01055         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057         LINVRNT(plist-&gt;pl_owner == current);
<a name="l01058"></a>01058         ENTRY;
<a name="l01059"></a>01059         <a class="code" href="group__cl__page__list.html#ga31a6630a381a5667594d699aa7269794" title="Iterate over pages in a page list.">cl_page_list_for_each</a>(page, plist)
<a name="l01060"></a>01060                 <a class="code" href="group__cl__page.html#ga775efaa18bd22d404f7588fd35f6cd03" title="Called when page is to be removed from the object, e.g., as a result of truncate...">cl_page_discard</a>(env, io, page);
<a name="l01061"></a>01061         EXIT;
<a name="l01062"></a>01062 }
<a name="l01063"></a>01063 
<a name="l01067"></a><a class="code" href="group__cl__page__list.html#ga395aaa5cb5dec21f83d8b07101b2aef0">01067</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#ga395aaa5cb5dec21f83d8b07101b2aef0" title="Initialize dual page queue.">cl_2queue_init</a>(<span class="keyword">struct</span> <a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a> *queue)
<a name="l01068"></a>01068 {
<a name="l01069"></a>01069         ENTRY;
<a name="l01070"></a>01070         <a class="code" href="group__cl__page__list.html#ga90ce1bc2aafa623ad024e213a05e00f0" title="Initializes page list.">cl_page_list_init</a>(&amp;queue-&gt;c2_qin);
<a name="l01071"></a>01071         <a class="code" href="group__cl__page__list.html#ga90ce1bc2aafa623ad024e213a05e00f0" title="Initializes page list.">cl_page_list_init</a>(&amp;queue-&gt;c2_qout);
<a name="l01072"></a>01072         EXIT;
<a name="l01073"></a>01073 }
<a name="l01074"></a>01074 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#ga395aaa5cb5dec21f83d8b07101b2aef0" title="Initialize dual page queue.">cl_2queue_init</a>);
<a name="l01075"></a>01075 
<a name="l01079"></a><a class="code" href="group__cl__page__list.html#ga55b5a5a4118185f0a7212299f2a65fac">01079</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#ga55b5a5a4118185f0a7212299f2a65fac" title="Add a page to the incoming page list of 2-queue.">cl_2queue_add</a>(<span class="keyword">struct</span> <a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a> *queue, <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page)
<a name="l01080"></a>01080 {
<a name="l01081"></a>01081         ENTRY;
<a name="l01082"></a>01082         <a class="code" href="group__cl__page__list.html#ga78d782095ec6f5d72e432d0ef0b35b3a" title="Adds a page to a page list.">cl_page_list_add</a>(&amp;queue-&gt;c2_qin, page);
<a name="l01083"></a>01083         EXIT;
<a name="l01084"></a>01084 }
<a name="l01085"></a>01085 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#ga55b5a5a4118185f0a7212299f2a65fac" title="Add a page to the incoming page list of 2-queue.">cl_2queue_add</a>);
<a name="l01086"></a>01086 
<a name="l01090"></a><a class="code" href="group__cl__page__list.html#ga70c6911b231ec808fedc50b9e27e2699">01090</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#ga70c6911b231ec808fedc50b9e27e2699" title="Disown pages in both lists of a 2-queue.">cl_2queue_disown</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01091"></a>01091                       <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keyword">struct</span> <a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a> *queue)
<a name="l01092"></a>01092 {
<a name="l01093"></a>01093         ENTRY;
<a name="l01094"></a>01094         <a class="code" href="group__cl__page__list.html#ga6775317c52f6e2540b62563f559cfab6" title="Disowns pages in a queue.">cl_page_list_disown</a>(env, io, &amp;queue-&gt;c2_qin);
<a name="l01095"></a>01095         <a class="code" href="group__cl__page__list.html#ga6775317c52f6e2540b62563f559cfab6" title="Disowns pages in a queue.">cl_page_list_disown</a>(env, io, &amp;queue-&gt;c2_qout);
<a name="l01096"></a>01096         EXIT;
<a name="l01097"></a>01097 }
<a name="l01098"></a>01098 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#ga70c6911b231ec808fedc50b9e27e2699" title="Disown pages in both lists of a 2-queue.">cl_2queue_disown</a>);
<a name="l01099"></a>01099 
<a name="l01103"></a><a class="code" href="group__cl__page__list.html#gab47261ab07f2e439b306dccb18a0980e">01103</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#gab47261ab07f2e439b306dccb18a0980e" title="Discard (truncate) pages in both lists of a 2-queue.">cl_2queue_discard</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01104"></a>01104                        <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keyword">struct</span> <a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a> *queue)
<a name="l01105"></a>01105 {
<a name="l01106"></a>01106         ENTRY;
<a name="l01107"></a>01107         <a class="code" href="group__cl__page__list.html#gabe8fbe4bdda923be3d8ee245549230f8" title="Discards all pages in a queue.">cl_page_list_discard</a>(env, io, &amp;queue-&gt;c2_qin);
<a name="l01108"></a>01108         <a class="code" href="group__cl__page__list.html#gabe8fbe4bdda923be3d8ee245549230f8" title="Discards all pages in a queue.">cl_page_list_discard</a>(env, io, &amp;queue-&gt;c2_qout);
<a name="l01109"></a>01109         EXIT;
<a name="l01110"></a>01110 }
<a name="l01111"></a>01111 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#gab47261ab07f2e439b306dccb18a0980e" title="Discard (truncate) pages in both lists of a 2-queue.">cl_2queue_discard</a>);
<a name="l01112"></a>01112 
<a name="l01116"></a><a class="code" href="group__cl__page__list.html#gaf1c12344f300cfdabbaabba9544db1da">01116</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#gaf1c12344f300cfdabbaabba9544db1da" title="Assume to own the pages in cl_2queue.">cl_2queue_assume</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01117"></a>01117                       <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keyword">struct</span> <a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a> *queue)
<a name="l01118"></a>01118 {
<a name="l01119"></a>01119         <a class="code" href="group__cl__page__list.html#ga321527c28a251fead1c4d8e7967da693" title="Assumes all pages in a queue.">cl_page_list_assume</a>(env, io, &amp;queue-&gt;c2_qin);
<a name="l01120"></a>01120         <a class="code" href="group__cl__page__list.html#ga321527c28a251fead1c4d8e7967da693" title="Assumes all pages in a queue.">cl_page_list_assume</a>(env, io, &amp;queue-&gt;c2_qout);
<a name="l01121"></a>01121 }
<a name="l01122"></a>01122 
<a name="l01126"></a><a class="code" href="group__cl__page__list.html#gafce330d7c8aa93047c5716cba8f4f379">01126</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#gafce330d7c8aa93047c5716cba8f4f379" title="Finalize both page lists of a 2-queue.">cl_2queue_fini</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a> *queue)
<a name="l01127"></a>01127 {
<a name="l01128"></a>01128         ENTRY;
<a name="l01129"></a>01129         <a class="code" href="group__cl__page__list.html#gaf77c34a166e78fa83a75ec296dc0d3fe" title="Releases pages from queue.">cl_page_list_fini</a>(env, &amp;queue-&gt;c2_qout);
<a name="l01130"></a>01130         <a class="code" href="group__cl__page__list.html#gaf77c34a166e78fa83a75ec296dc0d3fe" title="Releases pages from queue.">cl_page_list_fini</a>(env, &amp;queue-&gt;c2_qin);
<a name="l01131"></a>01131         EXIT;
<a name="l01132"></a>01132 }
<a name="l01133"></a>01133 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#gafce330d7c8aa93047c5716cba8f4f379" title="Finalize both page lists of a 2-queue.">cl_2queue_fini</a>);
<a name="l01134"></a>01134 
<a name="l01138"></a><a class="code" href="group__cl__page__list.html#gac54e35928bc036fca6e31c480285924c">01138</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__page__list.html#gac54e35928bc036fca6e31c480285924c" title="Initialize a 2-queue to contain page in its incoming page list.">cl_2queue_init_page</a>(<span class="keyword">struct</span> <a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a> *queue, <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page)
<a name="l01139"></a>01139 {
<a name="l01140"></a>01140         ENTRY;
<a name="l01141"></a>01141         <a class="code" href="group__cl__page__list.html#ga395aaa5cb5dec21f83d8b07101b2aef0" title="Initialize dual page queue.">cl_2queue_init</a>(queue);
<a name="l01142"></a>01142         <a class="code" href="group__cl__page__list.html#ga55b5a5a4118185f0a7212299f2a65fac" title="Add a page to the incoming page list of 2-queue.">cl_2queue_add</a>(queue, page);
<a name="l01143"></a>01143         EXIT;
<a name="l01144"></a>01144 }
<a name="l01145"></a>01145 EXPORT_SYMBOL(<a class="code" href="group__cl__page__list.html#gac54e35928bc036fca6e31c480285924c" title="Initialize a 2-queue to contain page in its incoming page list.">cl_2queue_init_page</a>);
<a name="l01146"></a>01146 
<a name="l01152"></a><a class="code" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c">01152</a> <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *<a class="code" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top-level io.">cl_io_top</a>(<span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l01153"></a>01153 {
<a name="l01154"></a>01154         ENTRY;
<a name="l01155"></a>01155         <span class="keywordflow">while</span> (io-&gt;<a class="code" href="structcl__io.html#a0848dbd9565e8113af8636a8182f9e1d" title="Upper layer io, of which this io is a part of.">ci_parent</a> != NULL)
<a name="l01156"></a>01156                 io = io-&gt;<a class="code" href="structcl__io.html#a0848dbd9565e8113af8636a8182f9e1d" title="Upper layer io, of which this io is a part of.">ci_parent</a>;
<a name="l01157"></a>01157         RETURN(io);
<a name="l01158"></a>01158 }
<a name="l01159"></a>01159 EXPORT_SYMBOL(<a class="code" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top-level io.">cl_io_top</a>);
<a name="l01160"></a>01160 
<a name="l01164"></a><a class="code" href="group__cl__io.html#ga56de1ca2cd018d724e180da7eabbcad9">01164</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__io.html#ga56de1ca2cd018d724e180da7eabbcad9" title="Prints human readable representation of io to the f.">cl_io_print</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">void</span> *cookie,
<a name="l01165"></a>01165                  <a class="code" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc" title="Type of &amp;quot;printer&amp;quot; function used by lu_object_operations::loo_object_print()...">lu_printer_t</a> printer, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l01166"></a>01166 {
<a name="l01167"></a>01167 }
<a name="l01168"></a>01168 
<a name="l01174"></a><a class="code" href="group__clio.html#ga596455746e16e88acee9318d8d95339d">01174</a> <span class="keywordtype">void</span> <a class="code" href="group__clio.html#ga596455746e16e88acee9318d8d95339d" title="Fills in attributes that are passed to server together with transfer.">cl_req_attr_set</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l01175"></a>01175                      <span class="keyword">struct</span> <a class="code" href="structcl__req__attr.html" title="Per-transfer attributes.">cl_req_attr</a> *attr)
<a name="l01176"></a>01176 {
<a name="l01177"></a>01177         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *scan;
<a name="l01178"></a>01178         ENTRY;
<a name="l01179"></a>01179 
<a name="l01180"></a>01180         <a class="code" href="group__cl__object.html#ga6477841d5f3bd9c2a2ca05e2aa089ea9" title="Helper macro: iterate over all layers of the object obj, assigning every layer top-to-bottom...">cl_object_for_each</a>(scan, obj) {
<a name="l01181"></a>01181                 <span class="keywordflow">if</span> (scan-&gt;<a class="code" href="structcl__object.html#a84db2d531bbd895d49cc44b795778064" title="per-object-layer operations">co_ops</a>-&gt;<a class="code" href="structcl__object__operations.html#ac4285e5c1c552110704ba50cce4d326c" title="Set request attributes.">coo_req_attr_set</a> != NULL)
<a name="l01182"></a>01182                         scan-&gt;<a class="code" href="structcl__object.html#a84db2d531bbd895d49cc44b795778064" title="per-object-layer operations">co_ops</a>-&gt;<a class="code" href="structcl__object__operations.html#ac4285e5c1c552110704ba50cce4d326c" title="Set request attributes.">coo_req_attr_set</a>(env, scan, attr);
<a name="l01183"></a>01183         }
<a name="l01184"></a>01184         EXIT;
<a name="l01185"></a>01185 }
<a name="l01186"></a>01186 EXPORT_SYMBOL(<a class="code" href="group__clio.html#ga596455746e16e88acee9318d8d95339d" title="Fills in attributes that are passed to server together with transfer.">cl_req_attr_set</a>);
<a name="l01187"></a>01187 
<a name="l01188"></a>01188 <span class="comment">/* cl_sync_io_callback assumes the caller must call cl_sync_io_wait() to</span>
<a name="l01189"></a>01189 <span class="comment"> * wait for the IO to finish. */</span>
<a name="l01190"></a>01190 <span class="keywordtype">void</span> cl_sync_io_end(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a> *anchor)
<a name="l01191"></a>01191 {
<a name="l01192"></a>01192         wake_up_all(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#a591752c0080fbe74e3766b250bb226ef" title="completion to be signaled when transfer is complete.">csi_waitq</a>);
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         <span class="comment">/* it&apos;s safe to nuke or reuse anchor now */</span>
<a name="l01195"></a>01195         atomic_set(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#a12cc89b6e0da8764344db9b5d50ec3b3" title="barrier of destroy this structure">csi_barrier</a>, 0);
<a name="l01196"></a>01196 }
<a name="l01197"></a>01197 EXPORT_SYMBOL(cl_sync_io_end);
<a name="l01198"></a>01198 
<a name="l01202"></a><a class="code" href="group__cl__sync__io.html#ga9e4705c43e9207a09c6cd8c9fac1c3e5">01202</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__sync__io.html#ga9e4705c43e9207a09c6cd8c9fac1c3e5" title="Initialize synchronous io wait anchor.">cl_sync_io_init</a>(<span class="keyword">struct</span> <a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a> *anchor, <span class="keywordtype">int</span> nr,
<a name="l01203"></a>01203                      <span class="keywordtype">void</span> (*end)(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *, <span class="keyword">struct</span> <a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a> *))
<a name="l01204"></a>01204 {
<a name="l01205"></a>01205         ENTRY;
<a name="l01206"></a>01206         memset(anchor, 0, <span class="keyword">sizeof</span>(*anchor));
<a name="l01207"></a>01207         init_waitqueue_head(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#a591752c0080fbe74e3766b250bb226ef" title="completion to be signaled when transfer is complete.">csi_waitq</a>);
<a name="l01208"></a>01208         atomic_set(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#aaf7f7fe203e365e9074f83bb8d5e2298" title="number of pages yet to be transferred.">csi_sync_nr</a>, nr);
<a name="l01209"></a>01209         atomic_set(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#a12cc89b6e0da8764344db9b5d50ec3b3" title="barrier of destroy this structure">csi_barrier</a>, nr &gt; 0);
<a name="l01210"></a>01210         anchor-&gt;<a class="code" href="structcl__sync__io.html#ae23f621796520d3fa33f577b790cbca6" title="error code.">csi_sync_rc</a> = 0;
<a name="l01211"></a>01211         anchor-&gt;<a class="code" href="structcl__sync__io.html#a41e99d40913076c4800d1332ec926474" title="callback to invoke when this IO is finished">csi_end_io</a> = end;
<a name="l01212"></a>01212         LASSERT(end != NULL);
<a name="l01213"></a>01213         EXIT;
<a name="l01214"></a>01214 }
<a name="l01215"></a>01215 EXPORT_SYMBOL(<a class="code" href="group__cl__sync__io.html#ga9e4705c43e9207a09c6cd8c9fac1c3e5" title="Initialize synchronous io wait anchor.">cl_sync_io_init</a>);
<a name="l01216"></a>01216 
<a name="l01221"></a><a class="code" href="group__cl__sync__io.html#ga92057d29f315080be03e18c0262a1871">01221</a> <span class="keywordtype">int</span> <a class="code" href="group__cl__sync__io.html#ga92057d29f315080be03e18c0262a1871" title="Wait until all IO completes.">cl_sync_io_wait</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a> *anchor,
<a name="l01222"></a>01222                     <span class="keywordtype">long</span> timeout)
<a name="l01223"></a>01223 {
<a name="l01224"></a>01224         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi = LWI_TIMEOUT_INTR(cfs_time_seconds(timeout),
<a name="l01225"></a>01225                                                   NULL, NULL, NULL);
<a name="l01226"></a>01226         <span class="keywordtype">int</span> rc;
<a name="l01227"></a>01227         ENTRY;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229         LASSERT(timeout &gt;= 0);
<a name="l01230"></a>01230 
<a name="l01231"></a>01231         rc = l_wait_event(anchor-&gt;<a class="code" href="structcl__sync__io.html#a591752c0080fbe74e3766b250bb226ef" title="completion to be signaled when transfer is complete.">csi_waitq</a>,
<a name="l01232"></a>01232                           atomic_read(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#aaf7f7fe203e365e9074f83bb8d5e2298" title="number of pages yet to be transferred.">csi_sync_nr</a>) == 0,
<a name="l01233"></a>01233                           &amp;lwi);
<a name="l01234"></a>01234         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01235"></a>01235                 CERROR(<span class="stringliteral">&quot;IO failed: %d, still wait for %d remaining entries\n&quot;</span>,
<a name="l01236"></a>01236                        rc, atomic_read(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#aaf7f7fe203e365e9074f83bb8d5e2298" title="number of pages yet to be transferred.">csi_sync_nr</a>));
<a name="l01237"></a>01237 
<a name="l01238"></a>01238                 lwi = (<span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>) { 0 };
<a name="l01239"></a>01239                 (void)l_wait_event(anchor-&gt;<a class="code" href="structcl__sync__io.html#a591752c0080fbe74e3766b250bb226ef" title="completion to be signaled when transfer is complete.">csi_waitq</a>,
<a name="l01240"></a>01240                                    atomic_read(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#aaf7f7fe203e365e9074f83bb8d5e2298" title="number of pages yet to be transferred.">csi_sync_nr</a>) == 0,
<a name="l01241"></a>01241                                    &amp;lwi);
<a name="l01242"></a>01242         } <span class="keywordflow">else</span> {
<a name="l01243"></a>01243                 rc = anchor-&gt;<a class="code" href="structcl__sync__io.html#ae23f621796520d3fa33f577b790cbca6" title="error code.">csi_sync_rc</a>;
<a name="l01244"></a>01244         }
<a name="l01245"></a>01245         LASSERT(atomic_read(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#aaf7f7fe203e365e9074f83bb8d5e2298" title="number of pages yet to be transferred.">csi_sync_nr</a>) == 0);
<a name="l01246"></a>01246 
<a name="l01247"></a>01247         <span class="comment">/* wait until cl_sync_io_note() has done wakeup */</span>
<a name="l01248"></a>01248         <span class="keywordflow">while</span> (unlikely(atomic_read(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#a12cc89b6e0da8764344db9b5d50ec3b3" title="barrier of destroy this structure">csi_barrier</a>) != 0)) {
<a name="l01249"></a>01249                 cpu_relax();
<a name="l01250"></a>01250         }
<a name="l01251"></a>01251         RETURN(rc);
<a name="l01252"></a>01252 }
<a name="l01253"></a>01253 EXPORT_SYMBOL(<a class="code" href="group__cl__sync__io.html#ga92057d29f315080be03e18c0262a1871" title="Wait until all IO completes.">cl_sync_io_wait</a>);
<a name="l01254"></a>01254 
<a name="l01258"></a><a class="code" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9">01258</a> <span class="keywordtype">void</span> <a class="code" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9" title="Indicate that transfer of a single page completed.">cl_sync_io_note</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a> *anchor,
<a name="l01259"></a>01259                      <span class="keywordtype">int</span> ioret)
<a name="l01260"></a>01260 {
<a name="l01261"></a>01261         ENTRY;
<a name="l01262"></a>01262         <span class="keywordflow">if</span> (anchor-&gt;<a class="code" href="structcl__sync__io.html#ae23f621796520d3fa33f577b790cbca6" title="error code.">csi_sync_rc</a> == 0 &amp;&amp; ioret &lt; 0)
<a name="l01263"></a>01263                 anchor-&gt;<a class="code" href="structcl__sync__io.html#ae23f621796520d3fa33f577b790cbca6" title="error code.">csi_sync_rc</a> = ioret;
<a name="l01264"></a>01264         <span class="comment">/*</span>
<a name="l01265"></a>01265 <span class="comment">         * Synchronous IO done without releasing page lock (e.g., as a part of</span>
<a name="l01266"></a>01266 <span class="comment">         * -&gt;{prepare,commit}_write(). Completion is used to signal the end of</span>
<a name="l01267"></a>01267 <span class="comment">         * IO.</span>
<a name="l01268"></a>01268 <span class="comment">         */</span>
<a name="l01269"></a>01269         LASSERT(atomic_read(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#aaf7f7fe203e365e9074f83bb8d5e2298" title="number of pages yet to be transferred.">csi_sync_nr</a>) &gt; 0);
<a name="l01270"></a>01270         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#aaf7f7fe203e365e9074f83bb8d5e2298" title="number of pages yet to be transferred.">csi_sync_nr</a>)) {
<a name="l01271"></a>01271                 LASSERT(anchor-&gt;<a class="code" href="structcl__sync__io.html#a41e99d40913076c4800d1332ec926474" title="callback to invoke when this IO is finished">csi_end_io</a> != NULL);
<a name="l01272"></a>01272                 anchor-&gt;<a class="code" href="structcl__sync__io.html#a41e99d40913076c4800d1332ec926474" title="callback to invoke when this IO is finished">csi_end_io</a>(env, anchor);
<a name="l01273"></a>01273                 <span class="comment">/* Can&apos;t access anchor any more */</span>
<a name="l01274"></a>01274         }
<a name="l01275"></a>01275         EXIT;
<a name="l01276"></a>01276 }
<a name="l01277"></a>01277 EXPORT_SYMBOL(<a class="code" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9" title="Indicate that transfer of a single page completed.">cl_sync_io_note</a>);
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:17 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
