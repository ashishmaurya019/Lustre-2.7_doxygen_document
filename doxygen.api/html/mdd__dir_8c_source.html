<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/mdd/mdd_dir.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/mdd/mdd_dir.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lustre/mdd/mdd_dir.c</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Lustre Metadata Server (mdd) routines</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * Author: Wang Di &lt;wangdi@intel.com&gt;</span>
<a name="l00041"></a>00041 <span class="comment"> */</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_MDS</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;obd_support.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;lustre_mds.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;lustre_fid.h&gt;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;mdd_internal.h&quot;</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> dot[] = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l00053"></a>00053 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> dotdot[] = <span class="stringliteral">&quot;..&quot;</span>;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> lname_dotdot = {
<a name="l00056"></a>00056         (<span class="keywordtype">char</span> *) dotdot,
<a name="l00057"></a>00057         <span class="keyword">sizeof</span>(dotdot) - 1
<a name="l00058"></a>00058 };
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00061"></a>00061 mdd_name_check(<span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *m, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *ln)
<a name="l00062"></a>00062 {
<a name="l00063"></a>00063         <span class="keywordflow">if</span> (!lu_name_is_valid(ln))
<a name="l00064"></a>00064                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00065"></a>00065         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ln-&gt;ln_namelen &gt; m-&gt;mdd_dt_conf.ddp_max_name_len)
<a name="l00066"></a>00066                 <span class="keywordflow">return</span> -ENAMETOOLONG;
<a name="l00067"></a>00067         <span class="keywordflow">else</span>
<a name="l00068"></a>00068                 <span class="keywordflow">return</span> 0;
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="comment">/* Get FID from name and parent */</span>
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00073"></a>00073 __mdd_lookup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *pobj,
<a name="l00074"></a>00074              <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l00075"></a>00075              <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>* fid, <span class="keywordtype">int</span> mask)
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077         <span class="keyword">const</span> <span class="keywordtype">char</span> *name                = lname-&gt;ln_name;
<a name="l00078"></a>00078         <span class="keyword">const</span> <span class="keyword">struct </span>dt_key *key        = (<span class="keyword">const</span> <span class="keyword">struct </span>dt_key *)name;
<a name="l00079"></a>00079         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj      = md2mdd_obj(pobj);
<a name="l00080"></a>00080         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *m            = mdo2mdd(pobj);
<a name="l00081"></a>00081         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *dir           = mdd_object_child(mdd_obj);
<a name="l00082"></a>00082         <span class="keywordtype">int</span> rc;
<a name="l00083"></a>00083         ENTRY;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085         <span class="keywordflow">if</span> (unlikely(mdd_is_dead_obj(mdd_obj)))
<a name="l00086"></a>00086                 RETURN(-ESTALE);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         <span class="keywordflow">if</span> (!mdd_object_exists(mdd_obj))
<a name="l00089"></a>00089                 RETURN(-ESTALE);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         <span class="keywordflow">if</span> (mdd_object_remote(mdd_obj)) {
<a name="l00092"></a>00092                 CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: Object &quot;</span>DFID<span class="stringliteral">&quot; locates on remote server\n&quot;</span>,
<a name="l00093"></a>00093                        mdd2obd_dev(m)-&gt;obd_name, PFID(mdo2fid(mdd_obj)));
<a name="l00094"></a>00094         }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         rc = mdd_permission_internal_locked(env, mdd_obj, pattr, mask,
<a name="l00097"></a>00097                                             MOR_TGT_PARENT);
<a name="l00098"></a>00098         <span class="keywordflow">if</span> (rc)
<a name="l00099"></a>00099                 RETURN(rc);
<a name="l00100"></a>00100 
<a name="l00101"></a>00101         <span class="keywordflow">if</span> (likely(S_ISDIR(mdd_object_type(mdd_obj)) &amp;&amp;
<a name="l00102"></a>00102                    dt_try_as_dir(env, dir)))
<a name="l00103"></a>00103                 rc = dt_lookup(env, dir, (<span class="keyword">struct</span> dt_rec *)fid, key);
<a name="l00104"></a>00104         <span class="keywordflow">else</span>
<a name="l00105"></a>00105                 rc = -ENOTDIR;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         RETURN(rc);
<a name="l00108"></a>00108 }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="keywordtype">int</span> mdd_lookup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00111"></a>00111                <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *pobj, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l00112"></a>00112                <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr = MDD_ENV_VAR(env, pattr);
<a name="l00115"></a>00115         <span class="keywordtype">int</span> rc;
<a name="l00116"></a>00116         ENTRY;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         rc = mdd_la_get(env, md2mdd_obj(pobj), pattr);
<a name="l00119"></a>00119         <span class="keywordflow">if</span> (rc != 0)
<a name="l00120"></a>00120                 RETURN(rc);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         rc = __mdd_lookup(env, pobj, pattr, lname, fid,
<a name="l00123"></a>00123                           (spec != NULL &amp;&amp; spec-&gt;sp_permitted) ? 0 : MAY_EXEC);
<a name="l00124"></a>00124         RETURN(rc);
<a name="l00125"></a>00125 }
<a name="l00126"></a>00126 
<a name="l00141"></a>00141 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> mdd_parent_fid(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00142"></a>00142                                  <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *obj,
<a name="l00143"></a>00143                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l00144"></a>00144                                  <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00145"></a>00145 {
<a name="l00146"></a>00146         <span class="keyword">struct </span><a class="code" href="structmdd__thread__info.html">mdd_thread_info</a>  *info = mdd_env_info(env);
<a name="l00147"></a>00147         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>      ldata = { NULL };
<a name="l00148"></a>00148         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           *buf = &amp;info-&gt;mti_link_buf;
<a name="l00149"></a>00149         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          lname;
<a name="l00150"></a>00150         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00151"></a>00151 
<a name="l00152"></a>00152         ENTRY;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         LASSERT(S_ISDIR(mdd_object_type(obj)));
<a name="l00155"></a>00155 
<a name="l00156"></a>00156         buf = lu_buf_check_and_alloc(buf, PATH_MAX);
<a name="l00157"></a>00157         <span class="keywordflow">if</span> (buf-&gt;lb_buf == NULL)
<a name="l00158"></a>00158                 GOTO(lookup, rc = 0);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> = buf;
<a name="l00161"></a>00161         rc = mdd_links_read(env, obj, &amp;ldata);
<a name="l00162"></a>00162         <span class="keywordflow">if</span> (rc != 0)
<a name="l00163"></a>00163                 GOTO(lookup, rc);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165         LASSERT(ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> != NULL);
<a name="l00166"></a>00166         <span class="comment">/* Directory should only have 1 parent */</span>
<a name="l00167"></a>00167         <span class="keywordflow">if</span> (ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount &gt; 1)
<a name="l00168"></a>00168                 GOTO(lookup, rc);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         ldata.ld_lee = (<span class="keyword">struct </span><a class="code" href="structlink__ea__entry.html" title="Hardlink data is name and parent fid.">link_ea_entry</a> *)(ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> + 1);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172         linkea_entry_unpack(ldata.ld_lee, &amp;ldata.ld_reclen, &amp;lname, fid);
<a name="l00173"></a>00173         <span class="keywordflow">if</span> (likely(fid_is_sane(fid)))
<a name="l00174"></a>00174                 RETURN(0);
<a name="l00175"></a>00175 lookup:
<a name="l00176"></a>00176         rc =  __mdd_lookup(env, &amp;obj-&gt;mod_obj, attr, &amp;lname_dotdot, fid, 0);
<a name="l00177"></a>00177         RETURN(rc);
<a name="l00178"></a>00178 }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="comment">/*</span>
<a name="l00181"></a>00181 <span class="comment"> * For root fid use special function, which does not compare version component</span>
<a name="l00182"></a>00182 <span class="comment"> * of fid. Version component is different for root fids on all MDTs.</span>
<a name="l00183"></a>00183 <span class="comment"> */</span>
<a name="l00184"></a>00184 <span class="keywordtype">int</span> mdd_is_root(<span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186         <span class="keywordflow">return</span> <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(&amp;mdd-&gt;mdd_root_fid) == <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid) &amp;&amp;
<a name="l00187"></a>00187                 fid_oid(&amp;mdd-&gt;mdd_root_fid) == fid_oid(fid);
<a name="l00188"></a>00188 }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="comment">/*</span>
<a name="l00191"></a>00191 <span class="comment"> * return 1: if lf is the fid of the ancestor of p1;</span>
<a name="l00192"></a>00192 <span class="comment"> * return 0: if not;</span>
<a name="l00193"></a>00193 <span class="comment"> *</span>
<a name="l00194"></a>00194 <span class="comment"> * return -EREMOTE: if remote object is found, in this</span>
<a name="l00195"></a>00195 <span class="comment"> * case fid of remote object is saved to @pf;</span>
<a name="l00196"></a>00196 <span class="comment"> *</span>
<a name="l00197"></a>00197 <span class="comment"> * otherwise: values &lt; 0, errors.</span>
<a name="l00198"></a>00198 <span class="comment"> */</span>
<a name="l00199"></a>00199 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_is_parent(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00200"></a>00200                         <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l00201"></a>00201                         <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *p1,
<a name="l00202"></a>00202                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l00203"></a>00203                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *lf,
<a name="l00204"></a>00204                         <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pf)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *parent = NULL;
<a name="l00207"></a>00207         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid;
<a name="l00208"></a>00208         <span class="keywordtype">int</span> rc;
<a name="l00209"></a>00209         ENTRY;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         LASSERT(!lu_fid_eq(mdo2fid(p1), lf));
<a name="l00212"></a>00212         pfid = &amp;mdd_env_info(env)-&gt;mti_fid;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="comment">/* Check for root first. */</span>
<a name="l00215"></a>00215         <span class="keywordflow">if</span> (mdd_is_root(mdd, mdo2fid(p1)))
<a name="l00216"></a>00216                 RETURN(0);
<a name="l00217"></a>00217 
<a name="l00218"></a>00218         <span class="keywordflow">for</span>(;;) {
<a name="l00219"></a>00219                 <span class="comment">/* this is done recursively */</span>
<a name="l00220"></a>00220                 rc = mdd_parent_fid(env, p1, attr, pfid);
<a name="l00221"></a>00221                 <span class="keywordflow">if</span> (rc)
<a name="l00222"></a>00222                         GOTO(out, rc);
<a name="l00223"></a>00223                 <span class="keywordflow">if</span> (mdd_is_root(mdd, pfid))
<a name="l00224"></a>00224                         GOTO(out, rc = 0);
<a name="l00225"></a>00225                 <span class="keywordflow">if</span> (lu_fid_eq(pfid, &amp;mdd-&gt;mdd_local_root_fid))
<a name="l00226"></a>00226                         GOTO(out, rc = 0);
<a name="l00227"></a>00227                 <span class="keywordflow">if</span> (lu_fid_eq(pfid, lf))
<a name="l00228"></a>00228                         GOTO(out, rc = 1);
<a name="l00229"></a>00229                 <span class="keywordflow">if</span> (parent != NULL)
<a name="l00230"></a>00230                         mdd_object_put(env, parent);
<a name="l00231"></a>00231 
<a name="l00232"></a>00232                 parent = mdd_object_find(env, mdd, pfid);
<a name="l00233"></a>00233                 <span class="keywordflow">if</span> (IS_ERR(parent))
<a name="l00234"></a>00234                         GOTO(out, rc = PTR_ERR(parent));
<a name="l00235"></a>00235 
<a name="l00236"></a>00236                 <span class="keywordflow">if</span> (!mdd_object_exists(parent))
<a name="l00237"></a>00237                         GOTO(out, rc = -EINVAL);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239                 p1 = parent;
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241         EXIT;
<a name="l00242"></a>00242 out:
<a name="l00243"></a>00243         <span class="keywordflow">if</span> (parent &amp;&amp; !IS_ERR(parent))
<a name="l00244"></a>00244                 mdd_object_put(env, parent);
<a name="l00245"></a>00245         <span class="keywordflow">return</span> rc;
<a name="l00246"></a>00246 }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">/*</span>
<a name="l00249"></a>00249 <span class="comment"> * No permission check is needed.</span>
<a name="l00250"></a>00250 <span class="comment"> *</span>
<a name="l00251"></a>00251 <span class="comment"> * returns 1: if fid is ancestor of @mo;</span>
<a name="l00252"></a>00252 <span class="comment"> * returns 0: if fid is not an ancestor of @mo;</span>
<a name="l00253"></a>00253 <span class="comment"> *</span>
<a name="l00254"></a>00254 <span class="comment"> * returns EREMOTE if remote object is found, fid of remote object is saved to</span>
<a name="l00255"></a>00255 <span class="comment"> * @fid;</span>
<a name="l00256"></a>00256 <span class="comment"> *</span>
<a name="l00257"></a>00257 <span class="comment"> * returns &lt; 0: if error</span>
<a name="l00258"></a>00258 <span class="comment"> */</span>
<a name="l00259"></a>00259 <span class="keywordtype">int</span> mdd_is_subdir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *mo,
<a name="l00260"></a>00260                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *sfid)
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(mo);
<a name="l00263"></a>00263         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr = MDD_ENV_VAR(env, cattr);
<a name="l00264"></a>00264         <span class="keywordtype">int</span> rc;
<a name="l00265"></a>00265         ENTRY;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267         <span class="keywordflow">if</span> (!S_ISDIR(mdd_object_type(md2mdd_obj(mo))))
<a name="l00268"></a>00268                 RETURN(0);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         rc = mdd_la_get(env, md2mdd_obj(mo), attr);
<a name="l00271"></a>00271         <span class="keywordflow">if</span> (rc != 0)
<a name="l00272"></a>00272                 RETURN(rc);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274         rc = mdd_is_parent(env, mdd, md2mdd_obj(mo), attr, fid, sfid);
<a name="l00275"></a>00275         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00276"></a>00276                 <span class="comment">/* found root */</span>
<a name="l00277"></a>00277                 fid_zero(sfid);
<a name="l00278"></a>00278         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 1) {
<a name="l00279"></a>00279                 <span class="comment">/* found @fid is parent */</span>
<a name="l00280"></a>00280                 *sfid = *fid;
<a name="l00281"></a>00281                 rc = 0;
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283         RETURN(rc);
<a name="l00284"></a>00284 }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 <span class="comment">/*</span>
<a name="l00287"></a>00287 <span class="comment"> * Check that @dir contains no entries except (possibly) dot and dotdot.</span>
<a name="l00288"></a>00288 <span class="comment"> *</span>
<a name="l00289"></a>00289 <span class="comment"> * Returns:</span>
<a name="l00290"></a>00290 <span class="comment"> *</span>
<a name="l00291"></a>00291 <span class="comment"> *             0        empty</span>
<a name="l00292"></a>00292 <span class="comment"> *      -ENOTDIR        not a directory object</span>
<a name="l00293"></a>00293 <span class="comment"> *    -ENOTEMPTY        not empty</span>
<a name="l00294"></a>00294 <span class="comment"> *           -ve        other error</span>
<a name="l00295"></a>00295 <span class="comment"> *</span>
<a name="l00296"></a>00296 <span class="comment"> */</span>
<a name="l00297"></a>00297 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_dir_is_empty(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00298"></a>00298                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *dir)
<a name="l00299"></a>00299 {
<a name="l00300"></a>00300         <span class="keyword">struct </span>dt_it     *it;
<a name="l00301"></a>00301         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *obj;
<a name="l00302"></a>00302         <span class="keyword">const</span> <span class="keyword">struct </span>dt_it_ops *iops;
<a name="l00303"></a>00303         <span class="keywordtype">int</span> result;
<a name="l00304"></a>00304         ENTRY;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306         obj = mdd_object_child(dir);
<a name="l00307"></a>00307         <span class="keywordflow">if</span> (!dt_try_as_dir(env, obj))
<a name="l00308"></a>00308                 RETURN(-ENOTDIR);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310         iops = &amp;obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>;
<a name="l00311"></a>00311         it = iops-&gt;<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a74b9db7e1791f6accf99c80a3a0c43e2" title="Allocate and initialize new iterator.">init</a>(env, obj, LUDA_64BITHASH);
<a name="l00312"></a>00312         <span class="keywordflow">if</span> (!IS_ERR(it)) {
<a name="l00313"></a>00313                 result = iops-&gt;get(env, it, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)<span class="stringliteral">&quot;&quot;</span>);
<a name="l00314"></a>00314                 <span class="keywordflow">if</span> (result &gt; 0) {
<a name="l00315"></a>00315                         <span class="keywordtype">int</span> i;
<a name="l00316"></a>00316                         <span class="keywordflow">for</span> (result = 0, i = 0; result == 0 &amp;&amp; i &lt; 3; ++i)
<a name="l00317"></a>00317                                 result = iops-&gt;next(env, it);
<a name="l00318"></a>00318                         <span class="keywordflow">if</span> (result == 0)
<a name="l00319"></a>00319                                 result = -ENOTEMPTY;
<a name="l00320"></a>00320                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (result == 1)
<a name="l00321"></a>00321                                 result = 0;
<a name="l00322"></a>00322                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (result == 0)
<a name="l00323"></a>00323                         <span class="comment">/*</span>
<a name="l00324"></a>00324 <span class="comment">                         * Huh? Index contains no zero key?</span>
<a name="l00325"></a>00325 <span class="comment">                         */</span>
<a name="l00326"></a>00326                         result = -EIO;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328                 iops-&gt;put(env, it);
<a name="l00329"></a>00329                 iops-&gt;fini(env, it);
<a name="l00330"></a>00330         } <span class="keywordflow">else</span>
<a name="l00331"></a>00331                 result = PTR_ERR(it);
<a name="l00332"></a>00332         RETURN(result);
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00349"></a>00349 <span class="keyword">static</span> <span class="keywordtype">int</span> __mdd_may_link(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *obj,
<a name="l00350"></a>00350                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la)
<a name="l00351"></a>00351 {
<a name="l00352"></a>00352         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *m = mdd_obj2mdd_dev(obj);
<a name="l00353"></a>00353         ENTRY;
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         LASSERT(la != NULL);
<a name="l00356"></a>00356 
<a name="l00357"></a>00357         <span class="comment">/* Subdir count limitation can be broken through</span>
<a name="l00358"></a>00358 <span class="comment">         * (see osd_object_ref_add), so only check non-directory here. */</span>
<a name="l00359"></a>00359         <span class="keywordflow">if</span> (!S_ISDIR(la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) &amp;&amp;
<a name="l00360"></a>00360             la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> &gt;= m-&gt;mdd_dt_conf.ddp_max_nlink)
<a name="l00361"></a>00361                 RETURN(-EMLINK);
<a name="l00362"></a>00362 
<a name="l00363"></a>00363         RETURN(0);
<a name="l00364"></a>00364 }
<a name="l00365"></a>00365 
<a name="l00379"></a>00379 <span class="keywordtype">int</span> mdd_may_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l00380"></a>00380                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *cobj,
<a name="l00381"></a>00381                    <span class="keywordtype">bool</span> check_perm)
<a name="l00382"></a>00382 {
<a name="l00383"></a>00383         <span class="keywordtype">int</span> rc = 0;
<a name="l00384"></a>00384         ENTRY;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         <span class="keywordflow">if</span> (cobj &amp;&amp; mdd_object_exists(cobj))
<a name="l00387"></a>00387                 RETURN(-EEXIST);
<a name="l00388"></a>00388 
<a name="l00389"></a>00389         <span class="keywordflow">if</span> (mdd_is_dead_obj(pobj))
<a name="l00390"></a>00390                 RETURN(-ENOENT);
<a name="l00391"></a>00391 
<a name="l00392"></a>00392         <span class="keywordflow">if</span> (check_perm)
<a name="l00393"></a>00393                 rc = mdd_permission_internal_locked(env, pobj, pattr,
<a name="l00394"></a>00394                                                     MAY_WRITE | MAY_EXEC,
<a name="l00395"></a>00395                                                     MOR_TGT_PARENT);
<a name="l00396"></a>00396         RETURN(rc);
<a name="l00397"></a>00397 }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="comment">/*</span>
<a name="l00400"></a>00400 <span class="comment"> * Check whether can unlink from the pobj in the case of &quot;cobj == NULL&quot;.</span>
<a name="l00401"></a>00401 <span class="comment"> */</span>
<a name="l00402"></a>00402 <span class="keywordtype">int</span> mdd_may_unlink(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l00403"></a>00403                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr)
<a name="l00404"></a>00404 {
<a name="l00405"></a>00405         <span class="keywordtype">int</span> rc;
<a name="l00406"></a>00406         ENTRY;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408         <span class="keywordflow">if</span> (mdd_is_dead_obj(pobj))
<a name="l00409"></a>00409                 RETURN(-ENOENT);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411         <span class="keywordflow">if</span> (attr-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> &amp; (LUSTRE_APPEND_FL | LUSTRE_IMMUTABLE_FL))
<a name="l00412"></a>00412                 RETURN(-EPERM);
<a name="l00413"></a>00413 
<a name="l00414"></a>00414         rc = mdd_permission_internal_locked(env, pobj, pattr,
<a name="l00415"></a>00415                                             MAY_WRITE | MAY_EXEC,
<a name="l00416"></a>00416                                             MOR_TGT_PARENT);
<a name="l00417"></a>00417         <span class="keywordflow">if</span> (rc != 0)
<a name="l00418"></a>00418                 RETURN(rc);
<a name="l00419"></a>00419 
<a name="l00420"></a>00420         <span class="keywordflow">if</span> (pattr-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> &amp; LUSTRE_APPEND_FL)
<a name="l00421"></a>00421                 RETURN(-EPERM);
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         RETURN(rc);
<a name="l00424"></a>00424 }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment">/*</span>
<a name="l00427"></a>00427 <span class="comment"> * pobj == NULL is remote ops case, under such case, pobj&apos;s</span>
<a name="l00428"></a>00428 <span class="comment"> * VTX feature has been checked already, no need check again.</span>
<a name="l00429"></a>00429 <span class="comment"> */</span>
<a name="l00430"></a>00430 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> mdd_is_sticky(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00431"></a>00431                                 <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l00432"></a>00432                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr,
<a name="l00433"></a>00433                                 <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *cobj,
<a name="l00434"></a>00434                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *cattr)
<a name="l00435"></a>00435 {
<a name="l00436"></a>00436         <span class="keyword">struct </span><a class="code" href="structlu__ucred.html">lu_ucred</a> *uc = <a class="code" href="group__md.html#gad24ee97e141a9dd7ccba9f1460cf4438" title="Get ucred key, which must exist and must be properly initialized.">lu_ucred_assert</a>(env);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         <span class="keywordflow">if</span> (pobj != NULL) {
<a name="l00439"></a>00439                 LASSERT(pattr != NULL);
<a name="l00440"></a>00440                 <span class="keywordflow">if</span> (!(pattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> &amp; S_ISVTX) ||
<a name="l00441"></a>00441                     (pattr-&gt;<a class="code" href="structlu__attr.html#ac4208c439ace57a005b662a61000b406" title="owner id">la_uid</a> == uc-&gt;uc_fsuid))
<a name="l00442"></a>00442                         <span class="keywordflow">return</span> 0;
<a name="l00443"></a>00443         }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445         LASSERT(cattr != NULL);
<a name="l00446"></a>00446         <span class="keywordflow">if</span> (cattr-&gt;<a class="code" href="structlu__attr.html#ac4208c439ace57a005b662a61000b406" title="owner id">la_uid</a> == uc-&gt;uc_fsuid)
<a name="l00447"></a>00447                 <span class="keywordflow">return</span> 0;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449         <span class="keywordflow">return</span> !md_capable(uc, CFS_CAP_FOWNER);
<a name="l00450"></a>00450 }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_may_delete_entry(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00453"></a>00453                                 <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l00454"></a>00454                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr,
<a name="l00455"></a>00455                                 <span class="keywordtype">int</span> check_perm)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457         ENTRY;
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         LASSERT(pobj != NULL);
<a name="l00460"></a>00460         <span class="keywordflow">if</span> (!mdd_object_exists(pobj))
<a name="l00461"></a>00461                 RETURN(-ENOENT);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463         <span class="keywordflow">if</span> (mdd_is_dead_obj(pobj))
<a name="l00464"></a>00464                 RETURN(-ENOENT);
<a name="l00465"></a>00465 
<a name="l00466"></a>00466         <span class="keywordflow">if</span> (check_perm) {
<a name="l00467"></a>00467                 <span class="keywordtype">int</span> rc;
<a name="l00468"></a>00468                 rc = mdd_permission_internal_locked(env, pobj, pattr,
<a name="l00469"></a>00469                                             MAY_WRITE | MAY_EXEC,
<a name="l00470"></a>00470                                             MOR_TGT_PARENT);
<a name="l00471"></a>00471                 <span class="keywordflow">if</span> (rc)
<a name="l00472"></a>00472                         RETURN(rc);
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         <span class="keywordflow">if</span> (pattr-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> &amp; LUSTRE_APPEND_FL)
<a name="l00476"></a>00476                 RETURN(-EPERM);
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         RETURN(0);
<a name="l00479"></a>00479 }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="comment">/*</span>
<a name="l00482"></a>00482 <span class="comment"> * Check whether it may delete the cobj from the pobj.</span>
<a name="l00483"></a>00483 <span class="comment"> * pobj maybe NULL</span>
<a name="l00484"></a>00484 <span class="comment"> */</span>
<a name="l00485"></a>00485 <span class="keywordtype">int</span> mdd_may_delete(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *tpobj,
<a name="l00486"></a>00486                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *tpattr, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *tobj,
<a name="l00487"></a>00487                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *tattr, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *cattr,
<a name="l00488"></a>00488                    <span class="keywordtype">int</span> check_perm, <span class="keywordtype">int</span> check_empty)
<a name="l00489"></a>00489 {
<a name="l00490"></a>00490         <span class="keywordtype">int</span> rc = 0;
<a name="l00491"></a>00491         ENTRY;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493         <span class="keywordflow">if</span> (tpobj) {
<a name="l00494"></a>00494                 LASSERT(tpattr != NULL);
<a name="l00495"></a>00495                 rc = mdd_may_delete_entry(env, tpobj, tpattr, check_perm);
<a name="l00496"></a>00496                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00497"></a>00497                         RETURN(rc);
<a name="l00498"></a>00498         }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500         <span class="keywordflow">if</span> (tobj == NULL)
<a name="l00501"></a>00501                 RETURN(0);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503         <span class="keywordflow">if</span> (!mdd_object_exists(tobj))
<a name="l00504"></a>00504                 RETURN(-ENOENT);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506         <span class="keywordflow">if</span> (mdd_is_dead_obj(tobj))
<a name="l00507"></a>00507                 RETURN(-ESTALE);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509         <span class="keywordflow">if</span> (mdd_is_sticky(env, tpobj, tpattr, tobj, tattr))
<a name="l00510"></a>00510                 RETURN(-EPERM);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         <span class="keywordflow">if</span> (tattr-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> &amp; (LUSTRE_APPEND_FL | LUSTRE_IMMUTABLE_FL))
<a name="l00513"></a>00513                 RETURN(-EPERM);
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <span class="comment">/* additional check the rename case */</span>
<a name="l00516"></a>00516         <span class="keywordflow">if</span> (cattr) {
<a name="l00517"></a>00517                 <span class="keywordflow">if</span> (S_ISDIR(cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l00518"></a>00518                         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(&amp;tobj-&gt;mod_obj);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520                         <span class="keywordflow">if</span> (!S_ISDIR(tattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>))
<a name="l00521"></a>00521                                 RETURN(-ENOTDIR);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523                         <span class="keywordflow">if</span> (lu_fid_eq(mdo2fid(tobj), &amp;mdd-&gt;mdd_root_fid))
<a name="l00524"></a>00524                                 RETURN(-EBUSY);
<a name="l00525"></a>00525                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (S_ISDIR(tattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>))
<a name="l00526"></a>00526                         RETURN(-EISDIR);
<a name="l00527"></a>00527         }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529         <span class="keywordflow">if</span> (S_ISDIR(tattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) &amp;&amp; check_empty)
<a name="l00530"></a>00530                 rc = mdd_dir_is_empty(env, tobj);
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         RETURN(rc);
<a name="l00533"></a>00533 }
<a name="l00534"></a>00534 
<a name="l00550"></a>00550 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_link_sanity_check(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00551"></a>00551                                  <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *tgt_obj,
<a name="l00552"></a>00552                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *tattr,
<a name="l00553"></a>00553                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l00554"></a>00554                                  <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *src_obj,
<a name="l00555"></a>00555                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *cattr)
<a name="l00556"></a>00556 {
<a name="l00557"></a>00557         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *m = mdd_obj2mdd_dev(src_obj);
<a name="l00558"></a>00558         <span class="keywordtype">int</span> rc = 0;
<a name="l00559"></a>00559         ENTRY;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         <span class="keywordflow">if</span> (!mdd_object_exists(src_obj))
<a name="l00562"></a>00562                 RETURN(-ENOENT);
<a name="l00563"></a>00563 
<a name="l00564"></a>00564         <span class="keywordflow">if</span> (mdd_is_dead_obj(src_obj))
<a name="l00565"></a>00565                 RETURN(-ESTALE);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567         <span class="comment">/* Local ops, no lookup before link, check filename length here. */</span>
<a name="l00568"></a>00568         rc = mdd_name_check(m, lname);
<a name="l00569"></a>00569         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00570"></a>00570                 RETURN(rc);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         <span class="keywordflow">if</span> (cattr-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> &amp; (LUSTRE_IMMUTABLE_FL | LUSTRE_APPEND_FL))
<a name="l00573"></a>00573                 RETURN(-EPERM);
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         <span class="keywordflow">if</span> (S_ISDIR(mdd_object_type(src_obj)))
<a name="l00576"></a>00576                 RETURN(-EPERM);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         LASSERT(src_obj != tgt_obj);
<a name="l00579"></a>00579         rc = mdd_may_create(env, tgt_obj, tattr, NULL, <span class="keyword">true</span>);
<a name="l00580"></a>00580         <span class="keywordflow">if</span> (rc != 0)
<a name="l00581"></a>00581                 RETURN(rc);
<a name="l00582"></a>00582 
<a name="l00583"></a>00583         rc = __mdd_may_link(env, src_obj, cattr);
<a name="l00584"></a>00584 
<a name="l00585"></a>00585         RETURN(rc);
<a name="l00586"></a>00586 }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="keyword">static</span> <span class="keywordtype">int</span> __mdd_index_delete_only(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l00589"></a>00589                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l00590"></a>00590 {
<a name="l00591"></a>00591         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *next = mdd_object_child(pobj);
<a name="l00592"></a>00592         <span class="keywordtype">int</span> rc;
<a name="l00593"></a>00593         ENTRY;
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (dt_try_as_dir(env, next))
<a name="l00596"></a>00596                 rc = dt_delete(env, next, (<span class="keyword">struct</span> dt_key *)name, handle);
<a name="l00597"></a>00597         <span class="keywordflow">else</span>
<a name="l00598"></a>00598                 rc = -ENOTDIR;
<a name="l00599"></a>00599 
<a name="l00600"></a>00600         RETURN(rc);
<a name="l00601"></a>00601 }
<a name="l00602"></a>00602 
<a name="l00603"></a>00603 <span class="keyword">static</span> <span class="keywordtype">int</span> __mdd_index_insert_only(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00604"></a>00604                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l00605"></a>00605                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *lf, __u32 type,
<a name="l00606"></a>00606                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00607"></a>00607                                    <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l00608"></a>00608 {
<a name="l00609"></a>00609         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *next = mdd_object_child(pobj);
<a name="l00610"></a>00610         <span class="keywordtype">int</span>               rc;
<a name="l00611"></a>00611         ENTRY;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613         <span class="keywordflow">if</span> (dt_try_as_dir(env, next)) {
<a name="l00614"></a>00614                 <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>    *rec = &amp;mdd_env_info(env)-&gt;mti_dt_rec;
<a name="l00615"></a>00615                 <span class="keyword">struct </span><a class="code" href="structlu__ucred.html">lu_ucred</a>         *uc  = <a class="code" href="group__md.html#ga528e600fa476bf04e8cef27f2301483a" title="Get ucred key and check if it is properly initialized.">lu_ucred_check</a>(env);
<a name="l00616"></a>00616                 <span class="keywordtype">int</span>                      ignore_quota;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618                 rec-&gt;rec_fid = lf;
<a name="l00619"></a>00619                 rec-&gt;rec_type = type;
<a name="l00620"></a>00620                 ignore_quota = uc ? uc-&gt;uc_cap &amp; CFS_CAP_SYS_RESOURCE_MASK : 1;
<a name="l00621"></a>00621                 rc = dt_insert(env, next, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l00622"></a>00622                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, handle,
<a name="l00623"></a>00623                                ignore_quota);
<a name="l00624"></a>00624         } <span class="keywordflow">else</span> {
<a name="l00625"></a>00625                 rc = -ENOTDIR;
<a name="l00626"></a>00626         }
<a name="l00627"></a>00627         RETURN(rc);
<a name="l00628"></a>00628 }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="comment">/* insert named index, add reference if isdir */</span>
<a name="l00631"></a>00631 <span class="keyword">static</span> <span class="keywordtype">int</span> __mdd_index_insert(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l00632"></a>00632                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *lf, __u32 type,
<a name="l00633"></a>00633                               <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l00634"></a>00634 {
<a name="l00635"></a>00635         <span class="keywordtype">int</span> rc;
<a name="l00636"></a>00636         ENTRY;
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         rc = __mdd_index_insert_only(env, pobj, lf, type, name, handle);
<a name="l00639"></a>00639         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; S_ISDIR(type)) {
<a name="l00640"></a>00640                 mdd_write_lock(env, pobj, MOR_TGT_PARENT);
<a name="l00641"></a>00641                 mdo_ref_add(env, pobj, handle);
<a name="l00642"></a>00642                 mdd_write_unlock(env, pobj);
<a name="l00643"></a>00643         }
<a name="l00644"></a>00644 
<a name="l00645"></a>00645         RETURN(rc);
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 
<a name="l00648"></a>00648 <span class="comment">/* delete named index, drop reference if isdir */</span>
<a name="l00649"></a>00649 <span class="keyword">static</span> <span class="keywordtype">int</span> __mdd_index_delete(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l00650"></a>00650                               <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> is_dir,
<a name="l00651"></a>00651                               <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l00652"></a>00652 {
<a name="l00653"></a>00653         <span class="keywordtype">int</span>               rc;
<a name="l00654"></a>00654         ENTRY;
<a name="l00655"></a>00655 
<a name="l00656"></a>00656         rc = __mdd_index_delete_only(env, pobj, name, handle);
<a name="l00657"></a>00657         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; is_dir) {
<a name="l00658"></a>00658                 mdd_write_lock(env, pobj, MOR_TGT_PARENT);
<a name="l00659"></a>00659                 mdo_ref_del(env, pobj, handle);
<a name="l00660"></a>00660                 mdd_write_unlock(env, pobj);
<a name="l00661"></a>00661         }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663         RETURN(rc);
<a name="l00664"></a>00664 }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_llog_record_calc_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00667"></a>00667                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *tname,
<a name="l00668"></a>00668                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *sname)
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__ucred.html">lu_ucred</a>   *uc = <a class="code" href="group__md.html#ga891ea36420f73975ab3f7cc8bd1b3802" title="Get ucred key if session exists and ucred key is allocated on it.">lu_ucred</a>(env);
<a name="l00671"></a>00671         <span class="keyword">enum</span> changelog_rec_flags crf = 0;
<a name="l00672"></a>00672         <span class="keywordtype">size_t</span>                   hdr_size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structllog__changelog__rec.html" title="changelog record">llog_changelog_rec</a>) -
<a name="l00673"></a>00673                                             sizeof(struct <a class="code" href="structchangelog__rec.html">changelog_rec</a>);
<a name="l00674"></a>00674 
<a name="l00675"></a>00675         <span class="keywordflow">if</span> (sname != NULL)
<a name="l00676"></a>00676                 crf |= CLF_RENAME;
<a name="l00677"></a>00677 
<a name="l00678"></a>00678         <span class="keywordflow">if</span> (uc != NULL &amp;&amp; uc-&gt;uc_jobid[0] != <span class="charliteral">&apos;\0&apos;</span>)
<a name="l00679"></a>00679                 crf |= CLF_JOBID;
<a name="l00680"></a>00680 
<a name="l00681"></a>00681         <span class="keywordflow">return</span> llog_data_len(hdr_size + changelog_rec_offset(crf) +
<a name="l00682"></a>00682                              (tname != NULL ? tname-&gt;ln_namelen : 0) +
<a name="l00683"></a>00683                              (sname != NULL ? 1 + sname-&gt;ln_namelen : 0));
<a name="l00684"></a>00684 }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 <span class="keywordtype">int</span> mdd_declare_changelog_store(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00687"></a>00687                                 <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l00688"></a>00688                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *tname,
<a name="l00689"></a>00689                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *sname,
<a name="l00690"></a>00690                                 <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l00691"></a>00691 {
<a name="l00692"></a>00692         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a>               *obd = mdd2obd_dev(mdd);
<a name="l00693"></a>00693         <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a>                *ctxt;
<a name="l00694"></a>00694         <span class="keyword">struct </span><a class="code" href="structllog__changelog__rec.html" title="changelog record">llog_changelog_rec</a>       *rec;
<a name="l00695"></a>00695         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                   *buf;
<a name="l00696"></a>00696         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *llog_th;
<a name="l00697"></a>00697         <span class="keywordtype">int</span>                              reclen;
<a name="l00698"></a>00698         <span class="keywordtype">int</span>                              rc;
<a name="l00699"></a>00699 
<a name="l00700"></a>00700         <span class="comment">/* Not recording */</span>
<a name="l00701"></a>00701         <span class="keywordflow">if</span> (!(mdd-&gt;mdd_cl.mc_flags &amp; CLM_ON))
<a name="l00702"></a>00702                 <span class="keywordflow">return</span> 0;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         reclen = mdd_llog_record_calc_size(env, tname, sname);
<a name="l00705"></a>00705         buf = lu_buf_check_and_alloc(&amp;mdd_env_info(env)-&gt;mti_big_buf, reclen);
<a name="l00706"></a>00706         <span class="keywordflow">if</span> (buf-&gt;lb_buf == NULL)
<a name="l00707"></a>00707                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         rec = buf-&gt;lb_buf;
<a name="l00710"></a>00710         rec-&gt;cr_hdr.lrh_len = reclen;
<a name="l00711"></a>00711         rec-&gt;cr_hdr.lrh_type = CHANGELOG_REC;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713         ctxt = llog_get_context(obd, <a class="code" href="group__lustreidl.html#ggaedddc461eb6cbba1f4f39241cabf24f1a41464bd8c4b12353cb8ba20d3909b70c" title="changelog generation on mdd">LLOG_CHANGELOG_ORIG_CTXT</a>);
<a name="l00714"></a>00714         <span class="keywordflow">if</span> (ctxt == NULL)
<a name="l00715"></a>00715                 <span class="keywordflow">return</span> -ENXIO;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         llog_th = thandle_get_sub(env, handle, ctxt-&gt;loc_handle-&gt;lgh_obj);
<a name="l00718"></a>00718         <span class="keywordflow">if</span> (IS_ERR(llog_th))
<a name="l00719"></a>00719                 GOTO(out_put, rc = PTR_ERR(llog_th));
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         rc = llog_declare_add(env, ctxt-&gt;loc_handle, &amp;rec-&gt;cr_hdr, llog_th);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723 out_put:
<a name="l00724"></a>00724         llog_ctxt_put(ctxt);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         <span class="keywordflow">return</span> rc;
<a name="l00727"></a>00727 }
<a name="l00728"></a>00728 
<a name="l00736"></a>00736 <span class="keywordtype">int</span> mdd_changelog_store(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l00737"></a>00737                         <span class="keyword">struct</span> <a class="code" href="structllog__changelog__rec.html" title="changelog record">llog_changelog_rec</a> *rec, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00738"></a>00738 {
<a name="l00739"></a>00739         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a>       *obd = mdd2obd_dev(mdd);
<a name="l00740"></a>00740         <span class="keyword">struct </span><a class="code" href="structllog__ctxt.html">llog_ctxt</a>        *ctxt;
<a name="l00741"></a>00741         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *llog_th;
<a name="l00742"></a>00742         <span class="keywordtype">int</span>                      rc;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744         rec-&gt;cr_hdr.lrh_len = llog_data_len(<span class="keyword">sizeof</span>(*rec) +
<a name="l00745"></a>00745                                             changelog_rec_varsize(&amp;rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>));
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         <span class="comment">/* llog_lvfs_write_rec sets the llog tail len */</span>
<a name="l00748"></a>00748         rec-&gt;cr_hdr.lrh_type = CHANGELOG_REC;
<a name="l00749"></a>00749         rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.cr_time = cl_time();
<a name="l00750"></a>00750 
<a name="l00751"></a>00751         spin_lock(&amp;mdd-&gt;mdd_cl.mc_lock);
<a name="l00752"></a>00752         <span class="comment">/* NB: I suppose it&apos;s possible llog_add adds out of order wrt cr_index,</span>
<a name="l00753"></a>00753 <span class="comment">         * but as long as the MDD transactions are ordered correctly for e.g.</span>
<a name="l00754"></a>00754 <span class="comment">         * rename conflicts, I don&apos;t think this should matter. */</span>
<a name="l00755"></a>00755         rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.<a class="code" href="structchangelog__rec.html#a994d96b9f37ffcc2227e12724a11f471" title="changelog record number">cr_index</a> = ++mdd-&gt;mdd_cl.mc_index;
<a name="l00756"></a>00756         spin_unlock(&amp;mdd-&gt;mdd_cl.mc_lock);
<a name="l00757"></a>00757 
<a name="l00758"></a>00758         ctxt = llog_get_context(obd, <a class="code" href="group__lustreidl.html#ggaedddc461eb6cbba1f4f39241cabf24f1a41464bd8c4b12353cb8ba20d3909b70c" title="changelog generation on mdd">LLOG_CHANGELOG_ORIG_CTXT</a>);
<a name="l00759"></a>00759         <span class="keywordflow">if</span> (ctxt == NULL)
<a name="l00760"></a>00760                 <span class="keywordflow">return</span> -ENXIO;
<a name="l00761"></a>00761 
<a name="l00762"></a>00762         llog_th = thandle_get_sub(env, th, ctxt-&gt;loc_handle-&gt;lgh_obj);
<a name="l00763"></a>00763         <span class="keywordflow">if</span> (IS_ERR(llog_th))
<a name="l00764"></a>00764                 GOTO(out_put, rc = PTR_ERR(llog_th));
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="comment">/* nested journal transaction */</span>
<a name="l00767"></a>00767         rc = llog_add(env, ctxt-&gt;loc_handle, &amp;rec-&gt;cr_hdr, NULL, llog_th);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 out_put:
<a name="l00770"></a>00770         llog_ctxt_put(ctxt);
<a name="l00771"></a>00771         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l00772"></a>00772                 rc = 0;
<a name="l00773"></a>00773         <span class="keywordflow">return</span> rc;
<a name="l00774"></a>00774 }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776 <span class="keyword">static</span> <span class="keywordtype">void</span> mdd_changelog_rec_ext_rename(<span class="keyword">struct</span> <a class="code" href="structchangelog__rec.html">changelog_rec</a> *rec,
<a name="l00777"></a>00777                                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *sfid,
<a name="l00778"></a>00778                                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *spfid,
<a name="l00779"></a>00779                                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *sname)
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781         <span class="keyword">struct </span><a class="code" href="structchangelog__ext__rename.html">changelog_ext_rename</a>     *rnm = changelog_rec_rename(rec);
<a name="l00782"></a>00782         <span class="keywordtype">size_t</span>                           extsize = sname-&gt;ln_namelen + 1;
<a name="l00783"></a>00783 
<a name="l00784"></a>00784         LASSERT(sfid != NULL);
<a name="l00785"></a>00785         LASSERT(spfid != NULL);
<a name="l00786"></a>00786         LASSERT(sname != NULL);
<a name="l00787"></a>00787 
<a name="l00788"></a>00788         rnm-&gt;<a class="code" href="structchangelog__ext__rename.html#a212e465b1e8df1a2106eb6124b4071b7" title="source fid, or zero">cr_sfid</a> = *sfid;
<a name="l00789"></a>00789         rnm-&gt;<a class="code" href="structchangelog__ext__rename.html#a904666467921c86d9577fec04e04fc63" title="source parent fid, or zero">cr_spfid</a> = *spfid;
<a name="l00790"></a>00790 
<a name="l00791"></a>00791         changelog_rec_name(rec)[rec-&gt;cr_namelen] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00792"></a>00792         strlcpy(changelog_rec_sname(rec), sname-&gt;ln_name, extsize);
<a name="l00793"></a>00793         rec-&gt;cr_namelen += extsize;
<a name="l00794"></a>00794 }
<a name="l00795"></a>00795 
<a name="l00796"></a>00796 <span class="keywordtype">void</span> mdd_changelog_rec_ext_jobid(<span class="keyword">struct</span> <a class="code" href="structchangelog__rec.html">changelog_rec</a> *rec, <span class="keyword">const</span> <span class="keywordtype">char</span> *jobid)
<a name="l00797"></a>00797 {
<a name="l00798"></a>00798         <span class="keyword">struct </span><a class="code" href="structchangelog__ext__jobid.html">changelog_ext_jobid</a>      *jid = changelog_rec_jobid(rec);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800         <span class="keywordflow">if</span> (jobid == NULL || jobid[0] == <span class="charliteral">&apos;\0&apos;</span>)
<a name="l00801"></a>00801                 <span class="keywordflow">return</span>;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         strlcpy(jid-&gt;<a class="code" href="structchangelog__ext__jobid.html#ab38a3dd0289d9d20e67dd13688336865" title="zero-terminated string.">cr_jobid</a>, jobid, <span class="keyword">sizeof</span>(jid-&gt;<a class="code" href="structchangelog__ext__jobid.html#ab38a3dd0289d9d20e67dd13688336865" title="zero-terminated string.">cr_jobid</a>));
<a name="l00804"></a>00804 }
<a name="l00805"></a>00805 
<a name="l00817"></a>00817 <span class="keywordtype">int</span> mdd_changelog_ns_store(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00818"></a>00818                            <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l00819"></a>00819                            <span class="keyword">enum</span> <a class="code" href="group__lustreuser.html#ga5aecf326bf672ba1d2483e0a53064d7b" title="Changelog record types.">changelog_rec_type</a> type,
<a name="l00820"></a>00820                            <span class="keyword">enum</span> changelog_rec_flags crf,
<a name="l00821"></a>00821                            <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *target,
<a name="l00822"></a>00822                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *tpfid,
<a name="l00823"></a>00823                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *sfid,
<a name="l00824"></a>00824                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *spfid,
<a name="l00825"></a>00825                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *tname,
<a name="l00826"></a>00826                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *sname,
<a name="l00827"></a>00827                            <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l00828"></a>00828 {
<a name="l00829"></a>00829         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__ucred.html">lu_ucred</a>           *uc = <a class="code" href="group__md.html#ga891ea36420f73975ab3f7cc8bd1b3802" title="Get ucred key if session exists and ucred key is allocated on it.">lu_ucred</a>(env);
<a name="l00830"></a>00830         <span class="keyword">struct </span><a class="code" href="structllog__changelog__rec.html" title="changelog record">llog_changelog_rec</a>       *rec;
<a name="l00831"></a>00831         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                   *buf;
<a name="l00832"></a>00832         <span class="keywordtype">int</span>                              reclen;
<a name="l00833"></a>00833         <span class="keywordtype">int</span>                              rc;
<a name="l00834"></a>00834         ENTRY;
<a name="l00835"></a>00835 
<a name="l00836"></a>00836         <span class="comment">/* Not recording */</span>
<a name="l00837"></a>00837         <span class="keywordflow">if</span> (!(mdd-&gt;mdd_cl.mc_flags &amp; CLM_ON))
<a name="l00838"></a>00838                 RETURN(0);
<a name="l00839"></a>00839 
<a name="l00840"></a>00840         <span class="keywordflow">if</span> ((mdd-&gt;mdd_cl.mc_mask &amp; (1 &lt;&lt; type)) == 0)
<a name="l00841"></a>00841                 RETURN(0);
<a name="l00842"></a>00842 
<a name="l00843"></a>00843         LASSERT(tpfid != NULL);
<a name="l00844"></a>00844         LASSERT(tname != NULL);
<a name="l00845"></a>00845         LASSERT(handle != NULL);
<a name="l00846"></a>00846 
<a name="l00847"></a>00847         reclen = mdd_llog_record_calc_size(env, tname, sname);
<a name="l00848"></a>00848         buf = lu_buf_check_and_alloc(&amp;mdd_env_info(env)-&gt;mti_big_buf, reclen);
<a name="l00849"></a>00849         <span class="keywordflow">if</span> (buf-&gt;lb_buf == NULL)
<a name="l00850"></a>00850                 RETURN(-ENOMEM);
<a name="l00851"></a>00851         rec = buf-&gt;lb_buf;
<a name="l00852"></a>00852 
<a name="l00853"></a>00853         crf &amp;= CLF_FLAGMASK;
<a name="l00854"></a>00854 
<a name="l00855"></a>00855         <span class="keywordflow">if</span> (uc != NULL &amp;&amp; uc-&gt;uc_jobid[0] != <span class="charliteral">&apos;\0&apos;</span>)
<a name="l00856"></a>00856                 crf |= CLF_JOBID;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858         <span class="keywordflow">if</span> (sname != NULL)
<a name="l00859"></a>00859                 crf |= CLF_RENAME;
<a name="l00860"></a>00860         <span class="keywordflow">else</span>
<a name="l00861"></a>00861                 crf |= CLF_VERSION;
<a name="l00862"></a>00862 
<a name="l00863"></a>00863         rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.<a class="code" href="structchangelog__rec.html#a6db5c3d14180f2ce3126468c061736dd" title="changelog_rec_flags ">cr_flags</a> = crf;
<a name="l00864"></a>00864         rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.<a class="code" href="structchangelog__rec.html#a4980ca18959a4a16a9dff3cc012b6c04" title="changelog_rec_type ">cr_type</a> = (__u32)type;
<a name="l00865"></a>00865         rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.<a class="code" href="structchangelog__rec.html#ae352b4a26c780096b07f29321200c15f" title="parent fid">cr_pfid</a> = *tpfid;
<a name="l00866"></a>00866         rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.cr_namelen = tname-&gt;ln_namelen;
<a name="l00867"></a>00867         memcpy(changelog_rec_name(&amp;rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>), tname-&gt;ln_name, tname-&gt;ln_namelen);
<a name="l00868"></a>00868 
<a name="l00869"></a>00869         <span class="keywordflow">if</span> (crf &amp; CLF_RENAME)
<a name="l00870"></a>00870                 mdd_changelog_rec_ext_rename(&amp;rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>, sfid, spfid, sname);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872         <span class="keywordflow">if</span> (crf &amp; CLF_JOBID)
<a name="l00873"></a>00873                 mdd_changelog_rec_ext_jobid(&amp;rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>, uc-&gt;uc_jobid);
<a name="l00874"></a>00874 
<a name="l00875"></a>00875         <span class="keywordflow">if</span> (likely(target != NULL)) {
<a name="l00876"></a>00876                 rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.<a class="code" href="structchangelog__rec.html#a409a3fce57ea09c2f18ce80513abaf27" title="target fid">cr_tfid</a> = *mdo2fid(target);
<a name="l00877"></a>00877                 target-&gt;mod_cltime = cfs_time_current_64();
<a name="l00878"></a>00878         } <span class="keywordflow">else</span> {
<a name="l00879"></a>00879                 fid_zero(&amp;rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.<a class="code" href="structchangelog__rec.html#a409a3fce57ea09c2f18ce80513abaf27" title="target fid">cr_tfid</a>);
<a name="l00880"></a>00880         }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882         rc = mdd_changelog_store(env, mdd, rec, handle);
<a name="l00883"></a>00883         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00884"></a>00884                 CERROR(<span class="stringliteral">&quot;%s: cannot store changelog record: type = %d, &quot;</span>
<a name="l00885"></a>00885                        <span class="stringliteral">&quot;name = &apos;%s&apos;, t = &quot;</span>DFID<span class="stringliteral">&quot;, p = &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l00886"></a>00886                        mdd2obd_dev(mdd)-&gt;obd_name, type, tname-&gt;ln_name,
<a name="l00887"></a>00887                        PFID(&amp;rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.<a class="code" href="structchangelog__rec.html#a409a3fce57ea09c2f18ce80513abaf27" title="target fid">cr_tfid</a>), PFID(&amp;rec-&gt;<a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>.<a class="code" href="structchangelog__rec.html#ae352b4a26c780096b07f29321200c15f" title="parent fid">cr_pfid</a>), rc);
<a name="l00888"></a>00888                 <span class="keywordflow">return</span> -EFAULT;
<a name="l00889"></a>00889         }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891         <span class="keywordflow">return</span> 0;
<a name="l00892"></a>00892 }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894 <span class="keyword">static</span> <span class="keywordtype">int</span> __mdd_links_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00895"></a>00895                            <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj,
<a name="l00896"></a>00896                            <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l00897"></a>00897                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l00898"></a>00898                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l00899"></a>00899                            <span class="keywordtype">int</span> first, <span class="keywordtype">int</span> check)
<a name="l00900"></a>00900 {
<a name="l00901"></a>00901         <span class="keywordtype">int</span> rc;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903         <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> == NULL) {
<a name="l00904"></a>00904                 rc = first ? -ENODATA : mdd_links_read(env, mdd_obj, ldata);
<a name="l00905"></a>00905                 <span class="keywordflow">if</span> (rc) {
<a name="l00906"></a>00906                         <span class="keywordflow">if</span> (rc != -ENODATA)
<a name="l00907"></a>00907                                 <span class="keywordflow">return</span> rc;
<a name="l00908"></a>00908                         rc = linkea_data_new(ldata,
<a name="l00909"></a>00909                                              &amp;mdd_env_info(env)-&gt;mti_link_buf);
<a name="l00910"></a>00910                         <span class="keywordflow">if</span> (rc)
<a name="l00911"></a>00911                                 <span class="keywordflow">return</span> rc;
<a name="l00912"></a>00912                 }
<a name="l00913"></a>00913         }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915         <span class="keywordflow">if</span> (check) {
<a name="l00916"></a>00916                 rc = linkea_links_find(ldata, lname, pfid);
<a name="l00917"></a>00917                 <span class="keywordflow">if</span> (rc &amp;&amp; rc != -ENOENT)
<a name="l00918"></a>00918                         <span class="keywordflow">return</span> rc;
<a name="l00919"></a>00919                 <span class="keywordflow">if</span> (rc == 0)
<a name="l00920"></a>00920                         <span class="keywordflow">return</span> -EEXIST;
<a name="l00921"></a>00921         }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LINKEA_MORE)) {
<a name="l00924"></a>00924                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *tfid = &amp;mdd_env_info(env)-&gt;mti_fid2;
<a name="l00925"></a>00925 
<a name="l00926"></a>00926                 *tfid = *pfid;
<a name="l00927"></a>00927                 tfid-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = ~0;
<a name="l00928"></a>00928                 linkea_add_buf(ldata, lname, tfid);
<a name="l00929"></a>00929         }
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LINKEA_MORE2))
<a name="l00932"></a>00932                 linkea_add_buf(ldata, lname, pfid);
<a name="l00933"></a>00933 
<a name="l00934"></a>00934         <span class="keywordflow">return</span> linkea_add_buf(ldata, lname, pfid);
<a name="l00935"></a>00935 }
<a name="l00936"></a>00936 
<a name="l00937"></a>00937 <span class="keyword">static</span> <span class="keywordtype">int</span> __mdd_links_del(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00938"></a>00938                            <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj,
<a name="l00939"></a>00939                            <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l00940"></a>00940                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l00941"></a>00941                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid)
<a name="l00942"></a>00942 {
<a name="l00943"></a>00943         <span class="keywordtype">int</span> rc;
<a name="l00944"></a>00944 
<a name="l00945"></a>00945         <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> == NULL) {
<a name="l00946"></a>00946                 rc = mdd_links_read(env, mdd_obj, ldata);
<a name="l00947"></a>00947                 <span class="keywordflow">if</span> (rc)
<a name="l00948"></a>00948                         <span class="keywordflow">return</span> rc;
<a name="l00949"></a>00949         }
<a name="l00950"></a>00950 
<a name="l00951"></a>00951         rc = linkea_links_find(ldata, lname, pfid);
<a name="l00952"></a>00952         <span class="keywordflow">if</span> (rc)
<a name="l00953"></a>00953                 <span class="keywordflow">return</span> rc;
<a name="l00954"></a>00954 
<a name="l00955"></a>00955         linkea_del_buf(ldata, lname);
<a name="l00956"></a>00956         <span class="keywordflow">return</span> 0;
<a name="l00957"></a>00957 }
<a name="l00958"></a>00958 
<a name="l00959"></a>00959 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_linkea_prepare(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00960"></a>00960                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj,
<a name="l00961"></a>00961                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *oldpfid,
<a name="l00962"></a>00962                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *oldlname,
<a name="l00963"></a>00963                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *newpfid,
<a name="l00964"></a>00964                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *newlname,
<a name="l00965"></a>00965                               <span class="keywordtype">int</span> first, <span class="keywordtype">int</span> check,
<a name="l00966"></a>00966                               <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata)
<a name="l00967"></a>00967 {
<a name="l00968"></a>00968         <span class="keywordtype">int</span> rc = 0;
<a name="l00969"></a>00969         <span class="keywordtype">int</span> rc2 = 0;
<a name="l00970"></a>00970         ENTRY;
<a name="l00971"></a>00971 
<a name="l00972"></a>00972         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_FID_IGIF))
<a name="l00973"></a>00973                 <span class="keywordflow">return</span> 0;
<a name="l00974"></a>00974 
<a name="l00975"></a>00975         LASSERT(oldpfid != NULL || newpfid != NULL);
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         <span class="keywordflow">if</span> (mdd_obj-&gt;mod_flags &amp; DEAD_OBJ) {
<a name="l00978"></a>00978                 <span class="comment">/* Prevent linkea to be updated which is NOT necessary. */</span>
<a name="l00979"></a>00979                 ldata-&gt;ld_reclen = 0;
<a name="l00980"></a>00980                 <span class="comment">/* No more links, don&apos;t bother */</span>
<a name="l00981"></a>00981                 RETURN(0);
<a name="l00982"></a>00982         }
<a name="l00983"></a>00983 
<a name="l00984"></a>00984         <span class="keywordflow">if</span> (oldpfid != NULL) {
<a name="l00985"></a>00985                 rc = __mdd_links_del(env, mdd_obj, ldata, oldlname, oldpfid);
<a name="l00986"></a>00986                 <span class="keywordflow">if</span> (rc) {
<a name="l00987"></a>00987                         <span class="keywordflow">if</span> ((check == 1) ||
<a name="l00988"></a>00988                             (rc != -ENODATA &amp;&amp; rc != -ENOENT))
<a name="l00989"></a>00989                                 RETURN(rc);
<a name="l00990"></a>00990                         <span class="comment">/* No changes done. */</span>
<a name="l00991"></a>00991                         rc = 0;
<a name="l00992"></a>00992                 }
<a name="l00993"></a>00993         }
<a name="l00994"></a>00994 
<a name="l00995"></a>00995         <span class="comment">/* If renaming, add the new record */</span>
<a name="l00996"></a>00996         <span class="keywordflow">if</span> (newpfid != NULL) {
<a name="l00997"></a>00997                 <span class="comment">/* even if the add fails, we still delete the out-of-date</span>
<a name="l00998"></a>00998 <span class="comment">                 * old link */</span>
<a name="l00999"></a>00999                 rc2 = __mdd_links_add(env, mdd_obj, ldata, newlname, newpfid,
<a name="l01000"></a>01000                                       first, check);
<a name="l01001"></a>01001         }
<a name="l01002"></a>01002 
<a name="l01003"></a>01003         rc = rc != 0 ? rc : rc2;
<a name="l01004"></a>01004 
<a name="l01005"></a>01005         RETURN(rc);
<a name="l01006"></a>01006 }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="keywordtype">int</span> mdd_links_rename(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01009"></a>01009                      <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj,
<a name="l01010"></a>01010                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *oldpfid,
<a name="l01011"></a>01011                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *oldlname,
<a name="l01012"></a>01012                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *newpfid,
<a name="l01013"></a>01013                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *newlname,
<a name="l01014"></a>01014                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle,
<a name="l01015"></a>01015                      <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l01016"></a>01016                      <span class="keywordtype">int</span> first, <span class="keywordtype">int</span> check)
<a name="l01017"></a>01017 {
<a name="l01018"></a>01018         <span class="keywordtype">int</span> rc = 0;
<a name="l01019"></a>01019         ENTRY;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021         <span class="keywordflow">if</span> (ldata == NULL) {
<a name="l01022"></a>01022                 ldata = &amp;mdd_env_info(env)-&gt;mti_link_data;
<a name="l01023"></a>01023                 memset(ldata, 0, <span class="keyword">sizeof</span>(*ldata));
<a name="l01024"></a>01024                 rc = mdd_linkea_prepare(env, mdd_obj, oldpfid, oldlname,
<a name="l01025"></a>01025                                         newpfid, newlname, first, check,
<a name="l01026"></a>01026                                         ldata);
<a name="l01027"></a>01027                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01028"></a>01028                         GOTO(out, rc);
<a name="l01029"></a>01029         }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031         <span class="keywordflow">if</span> (ldata-&gt;ld_reclen != 0)
<a name="l01032"></a>01032                 rc = mdd_links_write(env, mdd_obj, ldata, handle);
<a name="l01033"></a>01033         EXIT;
<a name="l01034"></a>01034 out:
<a name="l01035"></a>01035         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01036"></a>01036                 <span class="keywordtype">int</span> error = 1;
<a name="l01037"></a>01037                 <span class="keywordflow">if</span> (rc == -EOVERFLOW || rc == -ENOSPC)
<a name="l01038"></a>01038                         error = 0;
<a name="l01039"></a>01039                 <span class="keywordflow">if</span> (newlname == NULL)
<a name="l01040"></a>01040                         CDEBUG(error ? D_ERROR : D_OTHER,
<a name="l01041"></a>01041                                <span class="stringliteral">&quot;link_ea add failed %d &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01042"></a>01042                                rc, PFID(mdd_object_fid(mdd_obj)));
<a name="l01043"></a>01043                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oldpfid == NULL)
<a name="l01044"></a>01044                         CDEBUG(error ? D_ERROR : D_OTHER,
<a name="l01045"></a>01045                                <span class="stringliteral">&quot;link_ea add &apos;%.*s&apos; failed %d &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01046"></a>01046                                newlname-&gt;ln_namelen, newlname-&gt;ln_name,
<a name="l01047"></a>01047                                rc, PFID(mdd_object_fid(mdd_obj)));
<a name="l01048"></a>01048                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newpfid == NULL)
<a name="l01049"></a>01049                         CDEBUG(error ? D_ERROR : D_OTHER,
<a name="l01050"></a>01050                                <span class="stringliteral">&quot;link_ea del &apos;%.*s&apos; failed %d &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01051"></a>01051                                oldlname-&gt;ln_namelen, oldlname-&gt;ln_name,
<a name="l01052"></a>01052                                rc, PFID(mdd_object_fid(mdd_obj)));
<a name="l01053"></a>01053                 <span class="keywordflow">else</span>
<a name="l01054"></a>01054                         CDEBUG(error ? D_ERROR : D_OTHER,
<a name="l01055"></a>01055                                <span class="stringliteral">&quot;link_ea rename &apos;%.*s&apos;-&gt;&apos;%.*s&apos; failed %d &quot;</span>
<a name="l01056"></a>01056                                DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01057"></a>01057                                oldlname-&gt;ln_namelen, oldlname-&gt;ln_name,
<a name="l01058"></a>01058                                newlname-&gt;ln_namelen, newlname-&gt;ln_name,
<a name="l01059"></a>01059                                rc, PFID(mdd_object_fid(mdd_obj)));
<a name="l01060"></a>01060         }
<a name="l01061"></a>01061 
<a name="l01062"></a>01062         <span class="keywordflow">if</span> (is_vmalloc_addr(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>))
<a name="l01063"></a>01063                 <span class="comment">/* if we vmalloced a large buffer drop it */</span>
<a name="l01064"></a>01064                 lu_buf_free(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>);
<a name="l01065"></a>01065 
<a name="l01066"></a>01066         <span class="keywordflow">return</span> rc;
<a name="l01067"></a>01067 }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> mdd_links_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01070"></a>01070                                 <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj,
<a name="l01071"></a>01071                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l01072"></a>01072                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l01073"></a>01073                                 <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle,
<a name="l01074"></a>01074                                 <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata, <span class="keywordtype">int</span> first)
<a name="l01075"></a>01075 {
<a name="l01076"></a>01076         <span class="keywordflow">return</span> mdd_links_rename(env, mdd_obj, NULL, NULL,
<a name="l01077"></a>01077                                 pfid, lname, handle, ldata, first, 0);
<a name="l01078"></a>01078 }
<a name="l01079"></a>01079 
<a name="l01080"></a>01080 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> mdd_links_del(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01081"></a>01081                                 <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj,
<a name="l01082"></a>01082                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l01083"></a>01083                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l01084"></a>01084                                 <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l01085"></a>01085 {
<a name="l01086"></a>01086         <span class="keywordflow">return</span> mdd_links_rename(env, mdd_obj, pfid, lname,
<a name="l01087"></a>01087                                 NULL, NULL, handle, NULL, 0, 0);
<a name="l01088"></a>01088 }
<a name="l01089"></a>01089 
<a name="l01096"></a>01096 <span class="keywordtype">int</span> mdd_links_read(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj,
<a name="l01097"></a>01097                    <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata)
<a name="l01098"></a>01098 {
<a name="l01099"></a>01099         <span class="keywordtype">int</span> rc;
<a name="l01100"></a>01100 
<a name="l01101"></a>01101         <span class="keywordflow">if</span> (!mdd_object_exists(mdd_obj))
<a name="l01102"></a>01102                 <span class="keywordflow">return</span> -ENODATA;
<a name="l01103"></a>01103 
<a name="l01104"></a>01104         <span class="comment">/* First try a small buf */</span>
<a name="l01105"></a>01105         LASSERT(env != NULL);
<a name="l01106"></a>01106         ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> = lu_buf_check_and_alloc(&amp;mdd_env_info(env)-&gt;mti_link_buf,
<a name="l01107"></a>01107                                                PAGE_CACHE_SIZE);
<a name="l01108"></a>01108         <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf == NULL)
<a name="l01109"></a>01109                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         rc = mdo_xattr_get(env, mdd_obj, ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>, XATTR_NAME_LINK);
<a name="l01112"></a>01112         <span class="keywordflow">if</span> (rc == -ERANGE) {
<a name="l01113"></a>01113                 <span class="comment">/* Buf was too small, figure out what we need. */</span>
<a name="l01114"></a>01114                 lu_buf_free(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>);
<a name="l01115"></a>01115                 rc = mdo_xattr_get(env, mdd_obj, ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>,
<a name="l01116"></a>01116                                    XATTR_NAME_LINK);
<a name="l01117"></a>01117                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01118"></a>01118                         <span class="keywordflow">return</span> rc;
<a name="l01119"></a>01119                 ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> = lu_buf_check_and_alloc(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>, rc);
<a name="l01120"></a>01120                 <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf == NULL)
<a name="l01121"></a>01121                         <span class="keywordflow">return</span> -ENOMEM;
<a name="l01122"></a>01122                 rc = mdo_xattr_get(env, mdd_obj, ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>,
<a name="l01123"></a>01123                                   XATTR_NAME_LINK);
<a name="l01124"></a>01124         }
<a name="l01125"></a>01125         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01126"></a>01126                 lu_buf_free(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>);
<a name="l01127"></a>01127                 ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> = NULL;
<a name="l01128"></a>01128                 <span class="keywordflow">return</span> rc;
<a name="l01129"></a>01129         }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131         <span class="keywordflow">return</span> linkea_init(ldata);
<a name="l01132"></a>01132 }
<a name="l01133"></a>01133 
<a name="l01139"></a>01139 <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *mdd_links_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01140"></a>01140                              <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj)
<a name="l01141"></a>01141 {
<a name="l01142"></a>01142         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a> ldata = { NULL };
<a name="l01143"></a>01143         <span class="keywordtype">int</span> rc;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145         rc = mdd_links_read(env, mdd_obj, &amp;ldata);
<a name="l01146"></a>01146         <span class="keywordflow">return</span> rc ? ERR_PTR(rc) : ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>;
<a name="l01147"></a>01147 }
<a name="l01148"></a>01148 
<a name="l01149"></a>01149 <span class="keywordtype">int</span> mdd_links_write(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj,
<a name="l01150"></a>01150                     <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l01151"></a>01151 {
<a name="l01152"></a>01152         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf;
<a name="l01153"></a>01153         <span class="keywordtype">int</span>                 rc;
<a name="l01154"></a>01154 
<a name="l01155"></a>01155         <span class="keywordflow">if</span> (ldata == NULL || ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> == NULL ||
<a name="l01156"></a>01156             ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> == NULL)
<a name="l01157"></a>01157                 <span class="keywordflow">return</span> 0;
<a name="l01158"></a>01158 
<a name="l01159"></a>01159         buf = mdd_buf_get_const(env, ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l01160"></a>01160                                 ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l01161"></a>01161         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_NO_LINKEA))
<a name="l01162"></a>01162                 <span class="keywordflow">return</span> 0;
<a name="l01163"></a>01163 
<a name="l01164"></a>01164         rc = mdo_xattr_set(env, mdd_obj, buf, XATTR_NAME_LINK, 0, handle);
<a name="l01165"></a>01165         <span class="keywordflow">if</span> (unlikely(rc == -ENOSPC) &amp;&amp; S_ISREG(mdd_object_type(mdd_obj)) &amp;&amp;
<a name="l01166"></a>01166             mdd_object_remote(mdd_obj) == 0) {
<a name="l01167"></a>01167                 <span class="keyword">struct </span><a class="code" href="structlfsck__request.html">lfsck_request</a> *lr = &amp;mdd_env_info(env)-&gt;mti_lr;
<a name="l01168"></a>01168                 <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>  *sub_th;
<a name="l01169"></a>01169 
<a name="l01170"></a>01170                 <span class="comment">/* XXX: If the linkEA is overflow, then we need to notify the</span>
<a name="l01171"></a>01171 <span class="comment">                 *      namespace LFSCK to skip &quot;nlink&quot; attribute verification</span>
<a name="l01172"></a>01172 <span class="comment">                 *      on this object to avoid the &quot;nlink&quot; to be shrinked by</span>
<a name="l01173"></a>01173 <span class="comment">                 *      wrong. It may be not good an interaction with LFSCK</span>
<a name="l01174"></a>01174 <span class="comment">                 *      like this. We will consider to replace it with other</span>
<a name="l01175"></a>01175 <span class="comment">                 *      mechanism in future. LU-5802. */</span>
<a name="l01176"></a>01176                 lfsck_pack_rfa(lr, mdo2fid(mdd_obj), LE_SKIP_NLINK,
<a name="l01177"></a>01177                                LFSCK_TYPE_NAMESPACE);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179                 sub_th = thandle_get_sub_by_dt(env, handle,
<a name="l01180"></a>01180                                 mdo2mdd(&amp;mdd_obj-&gt;mod_obj)-&gt;mdd_bottom);
<a name="l01181"></a>01181                 lfsck_in_notify(env, mdo2mdd(&amp;mdd_obj-&gt;mod_obj)-&gt;mdd_bottom,
<a name="l01182"></a>01182                                 lr, sub_th);
<a name="l01183"></a>01183         }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185         <span class="keywordflow">return</span> rc;
<a name="l01186"></a>01186 }
<a name="l01187"></a>01187 
<a name="l01188"></a>01188 <span class="keywordtype">int</span> mdd_declare_links_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_obj,
<a name="l01189"></a>01189                           <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle, <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l01190"></a>01190                           <span class="keyword">enum</span> mdd_links_add_overflow overflow)
<a name="l01191"></a>01191 {
<a name="l01192"></a>01192         <span class="keywordtype">int</span>     rc;
<a name="l01193"></a>01193         <span class="keywordtype">int</span>     ea_len;
<a name="l01194"></a>01194         <span class="keywordtype">void</span>    *linkea;
<a name="l01195"></a>01195 
<a name="l01196"></a>01196         <span class="keywordflow">if</span> (ldata != NULL &amp;&amp; ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> != NULL) {
<a name="l01197"></a>01197                 ea_len = ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len;
<a name="l01198"></a>01198                 linkea = ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf;
<a name="l01199"></a>01199         } <span class="keywordflow">else</span> {
<a name="l01200"></a>01200                 ea_len = DEFAULT_LINKEA_SIZE;
<a name="l01201"></a>01201                 linkea = NULL;
<a name="l01202"></a>01202         }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204         <span class="comment">/* XXX: max size? */</span>
<a name="l01205"></a>01205         rc = mdo_declare_xattr_set(env, mdd_obj,
<a name="l01206"></a>01206                                    mdd_buf_get_const(env, linkea, ea_len),
<a name="l01207"></a>01207                                    XATTR_NAME_LINK, 0, handle);
<a name="l01208"></a>01208         <span class="keywordflow">if</span> (rc != 0)
<a name="l01209"></a>01209                 <span class="keywordflow">return</span> rc;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211         <span class="keywordflow">if</span> (mdd_object_remote(mdd_obj) == 0 &amp;&amp; overflow == MLAO_CHECK) {
<a name="l01212"></a>01212                 <span class="keyword">struct </span><a class="code" href="structlfsck__request.html">lfsck_request</a> *lr = &amp;mdd_env_info(env)-&gt;mti_lr;
<a name="l01213"></a>01213                 <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>  *sub_th;
<a name="l01214"></a>01214 
<a name="l01215"></a>01215                 <span class="comment">/* XXX: If the linkEA is overflow, then we need to notify the</span>
<a name="l01216"></a>01216 <span class="comment">                 *      namespace LFSCK to skip &quot;nlink&quot; attribute verification</span>
<a name="l01217"></a>01217 <span class="comment">                 *      on this object to avoid the &quot;nlink&quot; to be shrinked by</span>
<a name="l01218"></a>01218 <span class="comment">                 *      wrong. It may be not good an interaction with LFSCK</span>
<a name="l01219"></a>01219 <span class="comment">                 *      like this. We will consider to replace it with other</span>
<a name="l01220"></a>01220 <span class="comment">                 *      mechanism in future. LU-5802. */</span>
<a name="l01221"></a>01221                 lfsck_pack_rfa(lr, mdo2fid(mdd_obj), LE_SKIP_NLINK_DECLARE,
<a name="l01222"></a>01222                                LFSCK_TYPE_NAMESPACE);
<a name="l01223"></a>01223 
<a name="l01224"></a>01224                 sub_th = thandle_get_sub_by_dt(env, handle,
<a name="l01225"></a>01225                                 mdo2mdd(&amp;mdd_obj-&gt;mod_obj)-&gt;mdd_bottom);
<a name="l01226"></a>01226                 rc = lfsck_in_notify(env,
<a name="l01227"></a>01227                                      mdo2mdd(&amp;mdd_obj-&gt;mod_obj)-&gt;mdd_bottom,
<a name="l01228"></a>01228                                      lr, sub_th);
<a name="l01229"></a>01229         }
<a name="l01230"></a>01230 
<a name="l01231"></a>01231         <span class="keywordflow">return</span> rc;
<a name="l01232"></a>01232 }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> mdd_declare_links_del(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01235"></a>01235                                         <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *c,
<a name="l01236"></a>01236                                         <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238         <span class="keywordtype">int</span> rc = 0;
<a name="l01239"></a>01239 
<a name="l01240"></a>01240         <span class="comment">/* For directory, the linkEA will be removed together</span>
<a name="l01241"></a>01241 <span class="comment">         * with the object. */</span>
<a name="l01242"></a>01242         <span class="keywordflow">if</span> (!S_ISDIR(mdd_object_type(c)))
<a name="l01243"></a>01243                 rc = mdd_declare_links_add(env, c, handle, NULL, MLAO_IGNORE);
<a name="l01244"></a>01244 
<a name="l01245"></a>01245         <span class="keywordflow">return</span> rc;
<a name="l01246"></a>01246 }
<a name="l01247"></a>01247 
<a name="l01248"></a>01248 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_link(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01249"></a>01249                             <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l01250"></a>01250                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *p,
<a name="l01251"></a>01251                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *c,
<a name="l01252"></a>01252                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *name,
<a name="l01253"></a>01253                             <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle,
<a name="l01254"></a>01254                             <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la,
<a name="l01255"></a>01255                             <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *data)
<a name="l01256"></a>01256 {
<a name="l01257"></a>01257         <span class="keywordtype">int</span> rc;
<a name="l01258"></a>01258 
<a name="l01259"></a>01259         rc = mdo_declare_index_insert(env, p, mdo2fid(c), mdd_object_type(c),
<a name="l01260"></a>01260                                       name-&gt;ln_name, handle);
<a name="l01261"></a>01261         <span class="keywordflow">if</span> (rc != 0)
<a name="l01262"></a>01262                 <span class="keywordflow">return</span> rc;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264         rc = mdo_declare_ref_add(env, c, handle);
<a name="l01265"></a>01265         <span class="keywordflow">if</span> (rc != 0)
<a name="l01266"></a>01266                 <span class="keywordflow">return</span> rc;
<a name="l01267"></a>01267 
<a name="l01268"></a>01268         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_MORE_NLINK)) {
<a name="l01269"></a>01269                 rc = mdo_declare_ref_add(env, c, handle);
<a name="l01270"></a>01270                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01271"></a>01271                         <span class="keywordflow">return</span> rc;
<a name="l01272"></a>01272         }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MTIME;
<a name="l01275"></a>01275         rc = mdo_declare_attr_set(env, p, la, handle);
<a name="l01276"></a>01276         <span class="keywordflow">if</span> (rc != 0)
<a name="l01277"></a>01277                 <span class="keywordflow">return</span> rc;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l01280"></a>01280         rc = mdo_declare_attr_set(env, c, la, handle);
<a name="l01281"></a>01281         <span class="keywordflow">if</span> (rc != 0)
<a name="l01282"></a>01282                 <span class="keywordflow">return</span> rc;
<a name="l01283"></a>01283 
<a name="l01284"></a>01284         rc = mdd_declare_links_add(env, c, handle, data,
<a name="l01285"></a>01285                         S_ISREG(mdd_object_type(c)) ? MLAO_CHECK : MLAO_IGNORE);
<a name="l01286"></a>01286         <span class="keywordflow">if</span> (rc != 0)
<a name="l01287"></a>01287                 <span class="keywordflow">return</span> rc;
<a name="l01288"></a>01288 
<a name="l01289"></a>01289         rc = mdd_declare_changelog_store(env, mdd, name, NULL, handle);
<a name="l01290"></a>01290 
<a name="l01291"></a>01291         <span class="keywordflow">return</span> rc;
<a name="l01292"></a>01292 }
<a name="l01293"></a>01293 
<a name="l01294"></a>01294 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_link(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *tgt_obj,
<a name="l01295"></a>01295                     <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *src_obj, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l01296"></a>01296                     <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l01297"></a>01297 {
<a name="l01298"></a>01298         <span class="keyword">const</span> <span class="keywordtype">char</span> *name = lname-&gt;ln_name;
<a name="l01299"></a>01299         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>    *la = &amp;mdd_env_info(env)-&gt;<a class="code" href="structmdd__thread__info.html#a6a4ecb9102dadba2b066f90bd6532268" title="used to set c/mtime">mti_la_for_fix</a>;
<a name="l01300"></a>01300         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj = md2mdd_obj(tgt_obj);
<a name="l01301"></a>01301         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj = md2mdd_obj(src_obj);
<a name="l01302"></a>01302         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>    *cattr = MDD_ENV_VAR(env, cattr);
<a name="l01303"></a>01303         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>    *tattr = MDD_ENV_VAR(env, tattr);
<a name="l01304"></a>01304         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(src_obj);
<a name="l01305"></a>01305         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle;
<a name="l01306"></a>01306         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a> *ldata = &amp;mdd_env_info(env)-&gt;mti_link_data;
<a name="l01307"></a>01307         <span class="keywordtype">int</span> rc;
<a name="l01308"></a>01308         ENTRY;
<a name="l01309"></a>01309 
<a name="l01310"></a>01310         rc = mdd_la_get(env, mdd_sobj, cattr);
<a name="l01311"></a>01311         <span class="keywordflow">if</span> (rc != 0)
<a name="l01312"></a>01312                 RETURN(rc);
<a name="l01313"></a>01313 
<a name="l01314"></a>01314         rc = mdd_la_get(env, mdd_tobj, tattr);
<a name="l01315"></a>01315         <span class="keywordflow">if</span> (rc != 0)
<a name="l01316"></a>01316                 RETURN(rc);
<a name="l01317"></a>01317 
<a name="l01318"></a>01318         handle = mdd_trans_create(env, mdd);
<a name="l01319"></a>01319         <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l01320"></a>01320                 GOTO(out_pending, rc = PTR_ERR(handle));
<a name="l01321"></a>01321 
<a name="l01322"></a>01322         memset(ldata, 0, <span class="keyword">sizeof</span>(*ldata));
<a name="l01323"></a>01323 
<a name="l01324"></a>01324         LASSERT(ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; LA_CTIME);
<a name="l01325"></a>01325         la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = la-&gt;<a class="code" href="structlu__attr.html#a3c9ac90caf353fc11ed871645d4ab1f5" title="modification time in seconds since Epoch">la_mtime</a> = ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a>;
<a name="l01326"></a>01326 
<a name="l01327"></a>01327         rc = mdd_declare_link(env, mdd, mdd_tobj, mdd_sobj, lname, handle,
<a name="l01328"></a>01328                               la, ldata);
<a name="l01329"></a>01329         <span class="keywordflow">if</span> (rc)
<a name="l01330"></a>01330                 GOTO(stop, rc);
<a name="l01331"></a>01331 
<a name="l01332"></a>01332         rc = mdd_trans_start(env, mdd, handle);
<a name="l01333"></a>01333         <span class="keywordflow">if</span> (rc)
<a name="l01334"></a>01334                 GOTO(stop, rc);
<a name="l01335"></a>01335 
<a name="l01336"></a>01336         mdd_write_lock(env, mdd_sobj, MOR_TGT_CHILD);
<a name="l01337"></a>01337         rc = mdd_link_sanity_check(env, mdd_tobj, tattr, lname, mdd_sobj,
<a name="l01338"></a>01338                                    cattr);
<a name="l01339"></a>01339         <span class="keywordflow">if</span> (rc)
<a name="l01340"></a>01340                 GOTO(out_unlock, rc);
<a name="l01341"></a>01341 
<a name="l01342"></a>01342         <span class="keywordflow">if</span> (!OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LESS_NLINK)) {
<a name="l01343"></a>01343                 rc = mdo_ref_add(env, mdd_sobj, handle);
<a name="l01344"></a>01344                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01345"></a>01345                         GOTO(out_unlock, rc);
<a name="l01346"></a>01346         }
<a name="l01347"></a>01347 
<a name="l01348"></a>01348         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_MORE_NLINK)) {
<a name="l01349"></a>01349                 rc = mdo_ref_add(env, mdd_sobj, handle);
<a name="l01350"></a>01350                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01351"></a>01351                         GOTO(out_unlock, rc);
<a name="l01352"></a>01352         }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_DANGLING3)) {
<a name="l01355"></a>01355                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> tfid = *mdo2fid(mdd_sobj);
<a name="l01356"></a>01356 
<a name="l01357"></a>01357                 tfid.f_oid++;
<a name="l01358"></a>01358                 rc = __mdd_index_insert_only(env, mdd_tobj, &amp;tfid,
<a name="l01359"></a>01359                                              mdd_object_type(mdd_sobj),
<a name="l01360"></a>01360                                              name, handle);
<a name="l01361"></a>01361         } <span class="keywordflow">else</span> {
<a name="l01362"></a>01362                 rc = __mdd_index_insert_only(env, mdd_tobj, mdo2fid(mdd_sobj),
<a name="l01363"></a>01363                                              mdd_object_type(mdd_sobj),
<a name="l01364"></a>01364                                              name, handle);
<a name="l01365"></a>01365         }
<a name="l01366"></a>01366 
<a name="l01367"></a>01367         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01368"></a>01368                 mdo_ref_del(env, mdd_sobj, handle);
<a name="l01369"></a>01369                 GOTO(out_unlock, rc);
<a name="l01370"></a>01370         }
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MTIME;
<a name="l01373"></a>01373         rc = mdd_update_time(env, mdd_tobj, tattr, la, handle);
<a name="l01374"></a>01374         <span class="keywordflow">if</span> (rc)
<a name="l01375"></a>01375                 GOTO(out_unlock, rc);
<a name="l01376"></a>01376 
<a name="l01377"></a>01377         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l01378"></a>01378         rc = mdd_update_time(env, mdd_sobj, cattr, la, handle);
<a name="l01379"></a>01379         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01380"></a>01380                 rc = mdd_linkea_prepare(env, mdd_sobj, NULL, NULL,
<a name="l01381"></a>01381                                         mdo2fid(mdd_tobj), lname, 0, 0,
<a name="l01382"></a>01382                                         ldata);
<a name="l01383"></a>01383                 <span class="keywordflow">if</span> (rc == 0)
<a name="l01384"></a>01384                         mdd_links_add(env, mdd_sobj, mdo2fid(mdd_tobj),
<a name="l01385"></a>01385                                       lname, handle, ldata, 0);
<a name="l01386"></a>01386                 <span class="comment">/* The failure of links_add should not cause the link</span>
<a name="l01387"></a>01387 <span class="comment">                 * failure, reset rc here */</span>
<a name="l01388"></a>01388                 rc = 0;
<a name="l01389"></a>01389         }
<a name="l01390"></a>01390         EXIT;
<a name="l01391"></a>01391 out_unlock:
<a name="l01392"></a>01392         mdd_write_unlock(env, mdd_sobj);
<a name="l01393"></a>01393         <span class="keywordflow">if</span> (rc == 0)
<a name="l01394"></a>01394                 rc = mdd_changelog_ns_store(env, mdd, CL_HARDLINK, 0, mdd_sobj,
<a name="l01395"></a>01395                                             mdo2fid(mdd_tobj), NULL, NULL,
<a name="l01396"></a>01396                                             lname, NULL, handle);
<a name="l01397"></a>01397 stop:
<a name="l01398"></a>01398         mdd_trans_stop(env, mdd, rc, handle);
<a name="l01399"></a>01399 
<a name="l01400"></a>01400         <span class="keywordflow">if</span> (is_vmalloc_addr(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>))
<a name="l01401"></a>01401                 <span class="comment">/* if we vmalloced a large buffer drop it */</span>
<a name="l01402"></a>01402                 lu_buf_free(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>);
<a name="l01403"></a>01403 out_pending:
<a name="l01404"></a>01404         <span class="keywordflow">return</span> rc;
<a name="l01405"></a>01405 }
<a name="l01406"></a>01406 
<a name="l01407"></a>01407 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_mark_orphan_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01408"></a>01408                                 <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle,
<a name="l01409"></a>01409                                 <span class="keywordtype">bool</span> declare)
<a name="l01410"></a>01410 {
<a name="l01411"></a>01411         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr = MDD_ENV_VAR(env, la_for_start);
<a name="l01412"></a>01412         <span class="keywordtype">int</span> rc;
<a name="l01413"></a>01413 
<a name="l01414"></a>01414         <span class="keywordflow">if</span> (!S_ISDIR(mdd_object_type(obj)))
<a name="l01415"></a>01415                 <span class="keywordflow">return</span> 0;
<a name="l01416"></a>01416 
<a name="l01417"></a>01417         attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_FLAGS;
<a name="l01418"></a>01418         attr-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> = LUSTRE_ORPHAN_FL;
<a name="l01419"></a>01419 
<a name="l01420"></a>01420         <span class="keywordflow">if</span> (declare)
<a name="l01421"></a>01421                 rc = mdo_declare_attr_set(env, obj, attr, handle);
<a name="l01422"></a>01422         <span class="keywordflow">else</span>
<a name="l01423"></a>01423                 rc = mdo_attr_set(env, obj, attr, handle);
<a name="l01424"></a>01424 
<a name="l01425"></a>01425         <span class="keywordflow">return</span> rc;
<a name="l01426"></a>01426 }
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_finish_unlink(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01429"></a>01429                                      <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *obj,
<a name="l01430"></a>01430                                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l01431"></a>01431 {
<a name="l01432"></a>01432         <span class="keywordtype">int</span>     rc;
<a name="l01433"></a>01433 
<a name="l01434"></a>01434         <span class="comment">/* Sigh, we do not know if the unlink object will become orphan in</span>
<a name="l01435"></a>01435 <span class="comment">         * declare phase, but fortunately the flags here does not matter</span>
<a name="l01436"></a>01436 <span class="comment">         * in current declare implementation */</span>
<a name="l01437"></a>01437         rc = mdd_mark_orphan_object(env, obj, handle, <span class="keyword">true</span>);
<a name="l01438"></a>01438         <span class="keywordflow">if</span> (rc != 0)
<a name="l01439"></a>01439                 <span class="keywordflow">return</span> rc;
<a name="l01440"></a>01440 
<a name="l01441"></a>01441         rc = mdo_declare_destroy(env, obj, handle);
<a name="l01442"></a>01442         <span class="keywordflow">if</span> (rc != 0)
<a name="l01443"></a>01443                 <span class="keywordflow">return</span> rc;
<a name="l01444"></a>01444 
<a name="l01445"></a>01445         rc = orph_declare_index_insert(env, obj, mdd_object_type(obj), handle);
<a name="l01446"></a>01446         <span class="keywordflow">if</span> (rc != 0)
<a name="l01447"></a>01447                 <span class="keywordflow">return</span> rc;
<a name="l01448"></a>01448 
<a name="l01449"></a>01449         <span class="keywordflow">return</span> mdd_declare_links_del(env, obj, handle);
<a name="l01450"></a>01450 }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 <span class="comment">/* caller should take a lock before calling */</span>
<a name="l01453"></a>01453 <span class="keywordtype">int</span> mdd_finish_unlink(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01454"></a>01454                       <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma,
<a name="l01455"></a>01455                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l01456"></a>01456                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l01457"></a>01457                       <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l01458"></a>01458 {
<a name="l01459"></a>01459         <span class="keywordtype">int</span> rc = 0;
<a name="l01460"></a>01460         <span class="keywordtype">int</span> is_dir = S_ISDIR(ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>);
<a name="l01461"></a>01461         ENTRY;
<a name="l01462"></a>01462 
<a name="l01463"></a>01463         LASSERT(mdd_write_locked(env, obj) != 0);
<a name="l01464"></a>01464 
<a name="l01465"></a>01465         <span class="keywordflow">if</span> (ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> == 0 || is_dir) {
<a name="l01466"></a>01466                 <span class="comment">/* add new orphan and the object</span>
<a name="l01467"></a>01467 <span class="comment">                 * will be deleted during mdd_close() */</span>
<a name="l01468"></a>01468                 obj-&gt;mod_flags |= DEAD_OBJ;
<a name="l01469"></a>01469                 <span class="keywordflow">if</span> (obj-&gt;mod_count) {
<a name="l01470"></a>01470                         rc = __mdd_orphan_add(env, obj, th);
<a name="l01471"></a>01471                         <span class="keywordflow">if</span> (rc == 0)
<a name="l01472"></a>01472                                 CDEBUG(D_HA, <span class="stringliteral">&quot;Object &quot;</span>DFID<span class="stringliteral">&quot; is inserted into &quot;</span>
<a name="l01473"></a>01473                                         <span class="stringliteral">&quot;orphan list, open count = %d\n&quot;</span>,
<a name="l01474"></a>01474                                         PFID(mdd_object_fid(obj)),
<a name="l01475"></a>01475                                         obj-&gt;mod_count);
<a name="l01476"></a>01476                         <span class="keywordflow">else</span>
<a name="l01477"></a>01477                                 CERROR(<span class="stringliteral">&quot;Object &quot;</span>DFID<span class="stringliteral">&quot; fail to be an orphan, &quot;</span>
<a name="l01478"></a>01478                                        <span class="stringliteral">&quot;open count = %d, maybe cause failed &quot;</span>
<a name="l01479"></a>01479                                        <span class="stringliteral">&quot;open replay\n&quot;</span>,
<a name="l01480"></a>01480                                         PFID(mdd_object_fid(obj)),
<a name="l01481"></a>01481                                         obj-&gt;mod_count);
<a name="l01482"></a>01482 
<a name="l01483"></a>01483                         <span class="comment">/* mark object as an orphan here, not</span>
<a name="l01484"></a>01484 <span class="comment">                         * before __mdd_orphan_add() as racing</span>
<a name="l01485"></a>01485 <span class="comment">                         * mdd_la_get() may propagate ORPHAN_OBJ</span>
<a name="l01486"></a>01486 <span class="comment">                         * causing the asserition */</span>
<a name="l01487"></a>01487                         rc = mdd_mark_orphan_object(env, obj, th, <span class="keyword">false</span>);
<a name="l01488"></a>01488                 } <span class="keywordflow">else</span> {
<a name="l01489"></a>01489                         rc = mdo_destroy(env, obj, th);
<a name="l01490"></a>01490                 }
<a name="l01491"></a>01491         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!is_dir) {
<a name="l01492"></a>01492                 <span class="comment">/* old files may not have link ea; ignore errors */</span>
<a name="l01493"></a>01493                 mdd_links_del(env, obj, mdo2fid(pobj), lname, th);
<a name="l01494"></a>01494         }
<a name="l01495"></a>01495 
<a name="l01496"></a>01496         RETURN(rc);
<a name="l01497"></a>01497 }
<a name="l01498"></a>01498 
<a name="l01499"></a>01499 <span class="comment">/*</span>
<a name="l01500"></a>01500 <span class="comment"> * pobj maybe NULL</span>
<a name="l01501"></a>01501 <span class="comment"> * has mdd_write_lock on cobj already, but not on pobj yet</span>
<a name="l01502"></a>01502 <span class="comment"> */</span>
<a name="l01503"></a>01503 <span class="keywordtype">int</span> mdd_unlink_sanity_check(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l01504"></a>01504                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr,
<a name="l01505"></a>01505                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *cobj,
<a name="l01506"></a>01506                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *cattr)
<a name="l01507"></a>01507 {
<a name="l01508"></a>01508         <span class="keywordtype">int</span> rc;
<a name="l01509"></a>01509         ENTRY;
<a name="l01510"></a>01510 
<a name="l01511"></a>01511         rc = mdd_may_delete(env, pobj, pattr, cobj, cattr, NULL, 1, 1);
<a name="l01512"></a>01512 
<a name="l01513"></a>01513         RETURN(rc);
<a name="l01514"></a>01514 }
<a name="l01515"></a>01515 
<a name="l01516"></a>01516 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_unlink(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l01517"></a>01517                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *p, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *c,
<a name="l01518"></a>01518                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *name, <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma,
<a name="l01519"></a>01519                               <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle, <span class="keywordtype">int</span> no_name, <span class="keywordtype">int</span> is_dir)
<a name="l01520"></a>01520 {
<a name="l01521"></a>01521         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>  *la = &amp;mdd_env_info(env)-&gt;<a class="code" href="structmdd__thread__info.html#a6a4ecb9102dadba2b066f90bd6532268" title="used to set c/mtime">mti_la_for_fix</a>;
<a name="l01522"></a>01522         <span class="keywordtype">int</span>              rc;
<a name="l01523"></a>01523 
<a name="l01524"></a>01524         <span class="keywordflow">if</span> (!OBD_FAIL_CHECK(OBD_FAIL_LFSCK_DANGLING2)) {
<a name="l01525"></a>01525                 <span class="keywordflow">if</span> (likely(no_name == 0)) {
<a name="l01526"></a>01526                         rc = mdo_declare_index_delete(env, p, name-&gt;ln_name,
<a name="l01527"></a>01527                                                       handle);
<a name="l01528"></a>01528                         <span class="keywordflow">if</span> (rc != 0)
<a name="l01529"></a>01529                                 <span class="keywordflow">return</span> rc;
<a name="l01530"></a>01530                 }
<a name="l01531"></a>01531 
<a name="l01532"></a>01532                 <span class="keywordflow">if</span> (is_dir != 0) {
<a name="l01533"></a>01533                         rc = mdo_declare_ref_del(env, p, handle);
<a name="l01534"></a>01534                         <span class="keywordflow">if</span> (rc != 0)
<a name="l01535"></a>01535                                 <span class="keywordflow">return</span> rc;
<a name="l01536"></a>01536                 }
<a name="l01537"></a>01537         }
<a name="l01538"></a>01538 
<a name="l01539"></a>01539         LASSERT(ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; LA_CTIME);
<a name="l01540"></a>01540         la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = la-&gt;<a class="code" href="structlu__attr.html#a3c9ac90caf353fc11ed871645d4ab1f5" title="modification time in seconds since Epoch">la_mtime</a> = ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a>;
<a name="l01541"></a>01541         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MTIME;
<a name="l01542"></a>01542         rc = mdo_declare_attr_set(env, p, la, handle);
<a name="l01543"></a>01543         <span class="keywordflow">if</span> (rc)
<a name="l01544"></a>01544                 <span class="keywordflow">return</span> rc;
<a name="l01545"></a>01545 
<a name="l01546"></a>01546         <span class="keywordflow">if</span> (c != NULL) {
<a name="l01547"></a>01547                 rc = mdo_declare_ref_del(env, c, handle);
<a name="l01548"></a>01548                 <span class="keywordflow">if</span> (rc)
<a name="l01549"></a>01549                         <span class="keywordflow">return</span> rc;
<a name="l01550"></a>01550 
<a name="l01551"></a>01551                 rc = mdo_declare_ref_del(env, c, handle);
<a name="l01552"></a>01552                 <span class="keywordflow">if</span> (rc)
<a name="l01553"></a>01553                         <span class="keywordflow">return</span> rc;
<a name="l01554"></a>01554 
<a name="l01555"></a>01555                 la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l01556"></a>01556                 rc = mdo_declare_attr_set(env, c, la, handle);
<a name="l01557"></a>01557                 <span class="keywordflow">if</span> (rc)
<a name="l01558"></a>01558                         <span class="keywordflow">return</span> rc;
<a name="l01559"></a>01559 
<a name="l01560"></a>01560                 rc = mdd_declare_finish_unlink(env, c, handle);
<a name="l01561"></a>01561                 <span class="keywordflow">if</span> (rc)
<a name="l01562"></a>01562                         <span class="keywordflow">return</span> rc;
<a name="l01563"></a>01563 
<a name="l01564"></a>01564                 <span class="comment">/* FIXME: need changelog for remove entry */</span>
<a name="l01565"></a>01565                 rc = mdd_declare_changelog_store(env, mdd, name, NULL, handle);
<a name="l01566"></a>01566         }
<a name="l01567"></a>01567 
<a name="l01568"></a>01568         <span class="keywordflow">return</span> rc;
<a name="l01569"></a>01569 }
<a name="l01570"></a>01570 
<a name="l01571"></a>01571 <span class="comment">/*</span>
<a name="l01572"></a>01572 <span class="comment"> * test if a file has an HSM archive</span>
<a name="l01573"></a>01573 <span class="comment"> * if HSM attributes are not found in ma update them from</span>
<a name="l01574"></a>01574 <span class="comment"> * HSM xattr</span>
<a name="l01575"></a>01575 <span class="comment"> */</span>
<a name="l01576"></a>01576 <span class="keyword">static</span> <span class="keywordtype">bool</span> mdd_hsm_archive_exists(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01577"></a>01577                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *obj,
<a name="l01578"></a>01578                                    <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l01579"></a>01579 {
<a name="l01580"></a>01580         ENTRY;
<a name="l01581"></a>01581 
<a name="l01582"></a>01582         <span class="keywordflow">if</span> (!(ma-&gt;ma_valid &amp; MA_HSM)) {
<a name="l01583"></a>01583                 <span class="comment">/* no HSM MD provided, read xattr */</span>
<a name="l01584"></a>01584                 <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>   *hsm_buf;
<a name="l01585"></a>01585                 <span class="keyword">const</span> <span class="keywordtype">size_t</span>     buflen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structhsm__attrs.html" title="HSM on-disk attributes stored in a separate xattr.">hsm_attrs</a>);
<a name="l01586"></a>01586                 <span class="keywordtype">int</span>              rc;
<a name="l01587"></a>01587 
<a name="l01588"></a>01588                 hsm_buf = mdd_buf_get(env, NULL, 0);
<a name="l01589"></a>01589                 lu_buf_alloc(hsm_buf, buflen);
<a name="l01590"></a>01590                 rc = mdo_xattr_get(env, obj, hsm_buf, XATTR_NAME_HSM);
<a name="l01591"></a>01591                 rc = lustre_buf2hsm(hsm_buf-&gt;lb_buf, rc, &amp;ma-&gt;ma_hsm);
<a name="l01592"></a>01592                 lu_buf_free(hsm_buf);
<a name="l01593"></a>01593                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01594"></a>01594                         RETURN(<span class="keyword">false</span>);
<a name="l01595"></a>01595 
<a name="l01596"></a>01596                 ma-&gt;ma_valid |= MA_HSM;
<a name="l01597"></a>01597         }
<a name="l01598"></a>01598         <span class="keywordflow">if</span> (ma-&gt;ma_hsm.mh_flags &amp; HS_EXISTS)
<a name="l01599"></a>01599                 RETURN(<span class="keyword">true</span>);
<a name="l01600"></a>01600         RETURN(<span class="keyword">false</span>);
<a name="l01601"></a>01601 }
<a name="l01602"></a>01602 
<a name="l01612"></a>01612 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_unlink(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *pobj,
<a name="l01613"></a>01613                       <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *cobj, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l01614"></a>01614                       <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma, <span class="keywordtype">int</span> no_name)
<a name="l01615"></a>01615 {
<a name="l01616"></a>01616         <span class="keyword">const</span> <span class="keywordtype">char</span> *name = lname-&gt;ln_name;
<a name="l01617"></a>01617         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr = MDD_ENV_VAR(env, pattr);
<a name="l01618"></a>01618         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *cattr = MDD_ENV_VAR(env, cattr);
<a name="l01619"></a>01619         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la = &amp;mdd_env_info(env)-&gt;<a class="code" href="structmdd__thread__info.html#a6a4ecb9102dadba2b066f90bd6532268" title="used to set c/mtime">mti_la_for_fix</a>;
<a name="l01620"></a>01620         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj = md2mdd_obj(pobj);
<a name="l01621"></a>01621         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_cobj = NULL;
<a name="l01622"></a>01622         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(pobj);
<a name="l01623"></a>01623         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>    *handle;
<a name="l01624"></a>01624         <span class="keywordtype">int</span> rc, is_dir = 0, cl_flags = 0;
<a name="l01625"></a>01625         ENTRY;
<a name="l01626"></a>01626 
<a name="l01627"></a>01627         <span class="comment">/* cobj == NULL means only delete name entry */</span>
<a name="l01628"></a>01628         <span class="keywordflow">if</span> (likely(cobj != NULL)) {
<a name="l01629"></a>01629                 mdd_cobj = md2mdd_obj(cobj);
<a name="l01630"></a>01630                 <span class="keywordflow">if</span> (mdd_object_exists(mdd_cobj) == 0)
<a name="l01631"></a>01631                         RETURN(-ENOENT);
<a name="l01632"></a>01632         }
<a name="l01633"></a>01633 
<a name="l01634"></a>01634         rc = mdd_la_get(env, mdd_pobj, pattr);
<a name="l01635"></a>01635         <span class="keywordflow">if</span> (rc)
<a name="l01636"></a>01636                 RETURN(rc);
<a name="l01637"></a>01637 
<a name="l01638"></a>01638         <span class="keywordflow">if</span> (likely(mdd_cobj != NULL)) {
<a name="l01639"></a>01639                 <span class="comment">/* fetch cattr */</span>
<a name="l01640"></a>01640                 rc = mdd_la_get(env, mdd_cobj, cattr);
<a name="l01641"></a>01641                 <span class="keywordflow">if</span> (rc)
<a name="l01642"></a>01642                         RETURN(rc);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644                 is_dir = S_ISDIR(cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>);
<a name="l01645"></a>01645                 <span class="comment">/* search for an existing archive.</span>
<a name="l01646"></a>01646 <span class="comment">                 * we should check ahead as the object</span>
<a name="l01647"></a>01647 <span class="comment">                 * can be destroyed in this transaction */</span>
<a name="l01648"></a>01648                 <span class="keywordflow">if</span> (mdd_hsm_archive_exists(env, mdd_cobj, ma))
<a name="l01649"></a>01649                         cl_flags |= CLF_UNLINK_HSM_EXISTS;
<a name="l01650"></a>01650         }
<a name="l01651"></a>01651 
<a name="l01652"></a>01652         rc = mdd_unlink_sanity_check(env, mdd_pobj, pattr, mdd_cobj, cattr);
<a name="l01653"></a>01653         <span class="keywordflow">if</span> (rc)
<a name="l01654"></a>01654                 RETURN(rc);
<a name="l01655"></a>01655 
<a name="l01656"></a>01656         handle = mdd_trans_create(env, mdd);
<a name="l01657"></a>01657         <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l01658"></a>01658                 RETURN(PTR_ERR(handle));
<a name="l01659"></a>01659 
<a name="l01660"></a>01660         rc = mdd_declare_unlink(env, mdd, mdd_pobj, mdd_cobj,
<a name="l01661"></a>01661                                 lname, ma, handle, no_name, is_dir);
<a name="l01662"></a>01662         <span class="keywordflow">if</span> (rc)
<a name="l01663"></a>01663                 GOTO(stop, rc);
<a name="l01664"></a>01664 
<a name="l01665"></a>01665         rc = mdd_trans_start(env, mdd, handle);
<a name="l01666"></a>01666         <span class="keywordflow">if</span> (rc)
<a name="l01667"></a>01667                 GOTO(stop, rc);
<a name="l01668"></a>01668 
<a name="l01669"></a>01669         <span class="keywordflow">if</span> (likely(mdd_cobj != NULL))
<a name="l01670"></a>01670                 mdd_write_lock(env, mdd_cobj, MOR_TGT_CHILD);
<a name="l01671"></a>01671 
<a name="l01672"></a>01672         <span class="keywordflow">if</span> (likely(no_name == 0) &amp;&amp; !OBD_FAIL_CHECK(OBD_FAIL_LFSCK_DANGLING2)) {
<a name="l01673"></a>01673                 rc = __mdd_index_delete(env, mdd_pobj, name, is_dir, handle);
<a name="l01674"></a>01674                 <span class="keywordflow">if</span> (rc)
<a name="l01675"></a>01675                         GOTO(cleanup, rc);
<a name="l01676"></a>01676         }
<a name="l01677"></a>01677 
<a name="l01678"></a>01678         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_MUL_REF) ||
<a name="l01679"></a>01679             OBD_FAIL_CHECK(OBD_FAIL_LFSCK_NO_NAMEENTRY))
<a name="l01680"></a>01680                 GOTO(cleanup, rc = 0);
<a name="l01681"></a>01681 
<a name="l01682"></a>01682         <span class="keywordflow">if</span> (likely(mdd_cobj != NULL)) {
<a name="l01683"></a>01683                 rc = mdo_ref_del(env, mdd_cobj, handle);
<a name="l01684"></a>01684                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01685"></a>01685                         __mdd_index_insert_only(env, mdd_pobj,
<a name="l01686"></a>01686                                                 mdo2fid(mdd_cobj),
<a name="l01687"></a>01687                                                 mdd_object_type(mdd_cobj),
<a name="l01688"></a>01688                                                 name, handle);
<a name="l01689"></a>01689                         GOTO(cleanup, rc);
<a name="l01690"></a>01690                 }
<a name="l01691"></a>01691 
<a name="l01692"></a>01692                 <span class="keywordflow">if</span> (is_dir)
<a name="l01693"></a>01693                         <span class="comment">/* unlink dot */</span>
<a name="l01694"></a>01694                         mdo_ref_del(env, mdd_cobj, handle);
<a name="l01695"></a>01695 
<a name="l01696"></a>01696                 <span class="comment">/* fetch updated nlink */</span>
<a name="l01697"></a>01697                 rc = mdd_la_get(env, mdd_cobj, cattr);
<a name="l01698"></a>01698                 <span class="keywordflow">if</span> (rc)
<a name="l01699"></a>01699                         GOTO(cleanup, rc);
<a name="l01700"></a>01700         }
<a name="l01701"></a>01701 
<a name="l01702"></a>01702         LASSERT(ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; LA_CTIME);
<a name="l01703"></a>01703         la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = la-&gt;<a class="code" href="structlu__attr.html#a3c9ac90caf353fc11ed871645d4ab1f5" title="modification time in seconds since Epoch">la_mtime</a> = ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a>;
<a name="l01704"></a>01704 
<a name="l01705"></a>01705         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MTIME;
<a name="l01706"></a>01706         rc = mdd_update_time(env, mdd_pobj, pattr, la, handle);
<a name="l01707"></a>01707         <span class="keywordflow">if</span> (rc)
<a name="l01708"></a>01708                 GOTO(cleanup, rc);
<a name="l01709"></a>01709 
<a name="l01710"></a>01710         <span class="comment">/* Enough for only unlink the entry */</span>
<a name="l01711"></a>01711         <span class="keywordflow">if</span> (unlikely(mdd_cobj == NULL))
<a name="l01712"></a>01712                 GOTO(stop, rc);
<a name="l01713"></a>01713 
<a name="l01714"></a>01714         <span class="keywordflow">if</span> (cattr-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> &gt; 0 || mdd_cobj-&gt;mod_count &gt; 0) {
<a name="l01715"></a>01715                 <span class="comment">/* update ctime of an unlinked file only if it is still</span>
<a name="l01716"></a>01716 <span class="comment">                 * opened or a link still exists */</span>
<a name="l01717"></a>01717                 la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l01718"></a>01718                 rc = mdd_update_time(env, mdd_cobj, cattr, la, handle);
<a name="l01719"></a>01719                 <span class="keywordflow">if</span> (rc)
<a name="l01720"></a>01720                         GOTO(cleanup, rc);
<a name="l01721"></a>01721         }
<a name="l01722"></a>01722 
<a name="l01723"></a>01723         <span class="comment">/* XXX: this transfer to ma will be removed with LOD/OSP */</span>
<a name="l01724"></a>01724         ma-&gt;ma_attr = *cattr;
<a name="l01725"></a>01725         ma-&gt;ma_valid |= MA_INODE;
<a name="l01726"></a>01726         rc = mdd_finish_unlink(env, mdd_cobj, ma, mdd_pobj, lname, handle);
<a name="l01727"></a>01727         <span class="keywordflow">if</span> (rc != 0)
<a name="l01728"></a>01728                 GOTO(cleanup, rc);
<a name="l01729"></a>01729 
<a name="l01730"></a>01730         <span class="comment">/* fetch updated nlink */</span>
<a name="l01731"></a>01731         rc = mdd_la_get(env, mdd_cobj, cattr);
<a name="l01732"></a>01732         <span class="comment">/* if object is removed then we can&apos;t get its attrs,</span>
<a name="l01733"></a>01733 <span class="comment">         * use last get */</span>
<a name="l01734"></a>01734         <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l01735"></a>01735                 cattr-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> = 0;
<a name="l01736"></a>01736                 rc = 0;
<a name="l01737"></a>01737         }
<a name="l01738"></a>01738 
<a name="l01739"></a>01739         <span class="keywordflow">if</span> (cattr-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> == 0) {
<a name="l01740"></a>01740                 ma-&gt;ma_attr = *cattr;
<a name="l01741"></a>01741                 ma-&gt;ma_valid |= MA_INODE;
<a name="l01742"></a>01742         }
<a name="l01743"></a>01743 
<a name="l01744"></a>01744         EXIT;
<a name="l01745"></a>01745 cleanup:
<a name="l01746"></a>01746         <span class="keywordflow">if</span> (likely(mdd_cobj != NULL))
<a name="l01747"></a>01747                 mdd_write_unlock(env, mdd_cobj);
<a name="l01748"></a>01748 
<a name="l01749"></a>01749         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01750"></a>01750                 <span class="keywordflow">if</span> (cattr-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> == 0)
<a name="l01751"></a>01751                         cl_flags |= CLF_UNLINK_LAST;
<a name="l01752"></a>01752                 <span class="keywordflow">else</span>
<a name="l01753"></a>01753                         cl_flags &amp;= ~CLF_UNLINK_HSM_EXISTS;
<a name="l01754"></a>01754 
<a name="l01755"></a>01755                 rc = mdd_changelog_ns_store(env, mdd,
<a name="l01756"></a>01756                         is_dir ? CL_RMDIR : CL_UNLINK, cl_flags,
<a name="l01757"></a>01757                         mdd_cobj, mdo2fid(mdd_pobj), NULL, NULL, lname, NULL,
<a name="l01758"></a>01758                         handle);
<a name="l01759"></a>01759         }
<a name="l01760"></a>01760 
<a name="l01761"></a>01761 stop:
<a name="l01762"></a>01762         mdd_trans_stop(env, mdd, rc, handle);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764         <span class="keywordflow">return</span> rc;
<a name="l01765"></a>01765 }
<a name="l01766"></a>01766 
<a name="l01767"></a>01767 <span class="comment">/*</span>
<a name="l01768"></a>01768 <span class="comment"> * The permission has been checked when obj created, no need check again.</span>
<a name="l01769"></a>01769 <span class="comment"> */</span>
<a name="l01770"></a>01770 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_cd_sanity_check(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01771"></a>01771                                <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *obj)
<a name="l01772"></a>01772 {
<a name="l01773"></a>01773         ENTRY;
<a name="l01774"></a>01774 
<a name="l01775"></a>01775         <span class="comment">/* EEXIST check */</span>
<a name="l01776"></a>01776         <span class="keywordflow">if</span> (!obj || mdd_is_dead_obj(obj))
<a name="l01777"></a>01777                 RETURN(-ENOENT);
<a name="l01778"></a>01778 
<a name="l01779"></a>01779         RETURN(0);
<a name="l01780"></a>01780 }
<a name="l01781"></a>01781 
<a name="l01782"></a>01782 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_create_data(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *pobj,
<a name="l01783"></a>01783                            <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *cobj, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec,
<a name="l01784"></a>01784                            <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l01785"></a>01785 {
<a name="l01786"></a>01786         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(cobj);
<a name="l01787"></a>01787         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj = md2mdd_obj(pobj);
<a name="l01788"></a>01788         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *son = md2mdd_obj(cobj);
<a name="l01789"></a>01789         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>    *handle;
<a name="l01790"></a>01790         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf;
<a name="l01791"></a>01791         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>    *attr = MDD_ENV_VAR(env, cattr);
<a name="l01792"></a>01792         <span class="keyword">struct </span><a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint = &amp;mdd_env_info(env)-&gt;mti_hint;
<a name="l01793"></a>01793         <span class="keywordtype">int</span>                rc;
<a name="l01794"></a>01794         ENTRY;
<a name="l01795"></a>01795 
<a name="l01796"></a>01796         rc = mdd_cd_sanity_check(env, son);
<a name="l01797"></a>01797         <span class="keywordflow">if</span> (rc)
<a name="l01798"></a>01798                 RETURN(rc);
<a name="l01799"></a>01799 
<a name="l01800"></a>01800         <span class="keywordflow">if</span> (!md_should_create(spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a>))
<a name="l01801"></a>01801                 RETURN(0);
<a name="l01802"></a>01802 
<a name="l01803"></a>01803         <span class="comment">/*</span>
<a name="l01804"></a>01804 <span class="comment">         * there are following use cases for this function:</span>
<a name="l01805"></a>01805 <span class="comment">         * 1) late striping - file was created with MDS_OPEN_DELAY_CREATE</span>
<a name="l01806"></a>01806 <span class="comment">         *    striping can be specified or not</span>
<a name="l01807"></a>01807 <span class="comment">         * 2) CMD?</span>
<a name="l01808"></a>01808 <span class="comment">         */</span>
<a name="l01809"></a>01809         rc = mdd_la_get(env, son, attr);
<a name="l01810"></a>01810         <span class="keywordflow">if</span> (rc)
<a name="l01811"></a>01811                 RETURN(rc);
<a name="l01812"></a>01812 
<a name="l01813"></a>01813         <span class="comment">/* calling -&gt;ah_make_hint() is used to transfer information from parent */</span>
<a name="l01814"></a>01814         mdd_object_make_hint(env, mdd_pobj, son, attr, spec, hint);
<a name="l01815"></a>01815 
<a name="l01816"></a>01816         handle = mdd_trans_create(env, mdd);
<a name="l01817"></a>01817         <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l01818"></a>01818                 GOTO(out_free, rc = PTR_ERR(handle));
<a name="l01819"></a>01819 
<a name="l01820"></a>01820         <span class="comment">/*</span>
<a name="l01821"></a>01821 <span class="comment">         * XXX: Setting the lov ea is not locked but setting the attr is locked?</span>
<a name="l01822"></a>01822 <span class="comment">         * Should this be fixed?</span>
<a name="l01823"></a>01823 <span class="comment">         */</span>
<a name="l01824"></a>01824         CDEBUG(D_OTHER, <span class="stringliteral">&quot;ea %p/%u, cr_flags &quot;</span>LPO64<span class="stringliteral">&quot;, no_create %u\n&quot;</span>,
<a name="l01825"></a>01825                spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadata, spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadatalen,
<a name="l01826"></a>01826                spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a>, spec-&gt;<a class="code" href="structmd__op__spec.html#a5514ad7079fdcaf7e84c9e000a0773d4" title="don&amp;#39;t create lov objects or llog cookie - this replay">no_create</a>);
<a name="l01827"></a>01827 
<a name="l01828"></a>01828         <span class="keywordflow">if</span> (spec-&gt;<a class="code" href="structmd__op__spec.html#a5514ad7079fdcaf7e84c9e000a0773d4" title="don&amp;#39;t create lov objects or llog cookie - this replay">no_create</a> || (spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> &amp; MDS_OPEN_HAS_EA)) {
<a name="l01829"></a>01829                 buf = mdd_buf_get_const(env, spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadata,
<a name="l01830"></a>01830                                         spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadatalen);
<a name="l01831"></a>01831         } <span class="keywordflow">else</span> {
<a name="l01832"></a>01832                 buf = &amp;<a class="code" href="group__lu.html#ga3daaf59b14be927dc4227c6fc6635c6d" title="null buffer">LU_BUF_NULL</a>;
<a name="l01833"></a>01833         }
<a name="l01834"></a>01834 
<a name="l01835"></a>01835         rc = dt_declare_xattr_set(env, mdd_object_child(son), buf,
<a name="l01836"></a>01836                                   XATTR_NAME_LOV, 0, handle);
<a name="l01837"></a>01837         <span class="keywordflow">if</span> (rc)
<a name="l01838"></a>01838                 GOTO(stop, rc);
<a name="l01839"></a>01839 
<a name="l01840"></a>01840         rc = mdd_declare_changelog_store(env, mdd, NULL, NULL, handle);
<a name="l01841"></a>01841         <span class="keywordflow">if</span> (rc)
<a name="l01842"></a>01842                 GOTO(stop, rc);
<a name="l01843"></a>01843 
<a name="l01844"></a>01844         rc = mdd_trans_start(env, mdd, handle);
<a name="l01845"></a>01845         <span class="keywordflow">if</span> (rc)
<a name="l01846"></a>01846                 GOTO(stop, rc);
<a name="l01847"></a>01847 
<a name="l01848"></a>01848         rc = dt_xattr_set(env, mdd_object_child(son), buf, XATTR_NAME_LOV,
<a name="l01849"></a>01849                           0, handle);
<a name="l01850"></a>01850 
<a name="l01851"></a>01851         <span class="keywordflow">if</span> (rc)
<a name="l01852"></a>01852                 GOTO(stop, rc);
<a name="l01853"></a>01853 
<a name="l01854"></a>01854         rc = mdd_changelog_data_store(env, mdd, CL_LAYOUT, 0, son, handle);
<a name="l01855"></a>01855 
<a name="l01856"></a>01856 stop:
<a name="l01857"></a>01857         mdd_trans_stop(env, mdd, rc, handle);
<a name="l01858"></a>01858 out_free:
<a name="l01859"></a>01859         RETURN(rc);
<a name="l01860"></a>01860 }
<a name="l01861"></a>01861 
<a name="l01862"></a>01862 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_object_initialize(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01863"></a>01863                                          <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *parent,
<a name="l01864"></a>01864                                          <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *child,
<a name="l01865"></a>01865                                          <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l01866"></a>01866                                          <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l01867"></a>01867 {
<a name="l01868"></a>01868         <span class="keywordtype">int</span> rc;
<a name="l01869"></a>01869         ENTRY;
<a name="l01870"></a>01870 
<a name="l01871"></a>01871         <span class="comment">/*</span>
<a name="l01872"></a>01872 <span class="comment">         * inode mode has been set in creation time, and it&apos;s based on umask,</span>
<a name="l01873"></a>01873 <span class="comment">         * la_mode and acl, don&apos;t set here again! (which will go wrong</span>
<a name="l01874"></a>01874 <span class="comment">         * because below function doesn&apos;t consider umask).</span>
<a name="l01875"></a>01875 <span class="comment">         * I&apos;d suggest set all object attributes in creation time, see above.</span>
<a name="l01876"></a>01876 <span class="comment">         */</span>
<a name="l01877"></a>01877         LASSERT(attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; (LA_MODE | LA_TYPE));
<a name="l01878"></a>01878         attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp;= ~(LA_MODE | LA_TYPE);
<a name="l01879"></a>01879         rc = mdo_declare_attr_set(env, child, attr, handle);
<a name="l01880"></a>01880         attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> |= LA_MODE | LA_TYPE;
<a name="l01881"></a>01881         <span class="keywordflow">if</span> (rc != 0 || !S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>))
<a name="l01882"></a>01882                 RETURN(rc);
<a name="l01883"></a>01883 
<a name="l01884"></a>01884         rc = mdo_declare_index_insert(env, child, mdo2fid(child), S_IFDIR,
<a name="l01885"></a>01885                                       dot, handle);
<a name="l01886"></a>01886         <span class="keywordflow">if</span> (rc != 0)
<a name="l01887"></a>01887                 RETURN(rc);
<a name="l01888"></a>01888 
<a name="l01889"></a>01889         rc = mdo_declare_ref_add(env, child, handle);
<a name="l01890"></a>01890         <span class="keywordflow">if</span> (rc != 0)
<a name="l01891"></a>01891                 RETURN(rc);
<a name="l01892"></a>01892 
<a name="l01893"></a>01893         rc = mdo_declare_index_insert(env, child, mdo2fid(parent), S_IFDIR,
<a name="l01894"></a>01894                                       dotdot, handle);
<a name="l01895"></a>01895 
<a name="l01896"></a>01896         RETURN(rc);
<a name="l01897"></a>01897 }
<a name="l01898"></a>01898 
<a name="l01899"></a>01899 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_object_initialize(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01900"></a>01900                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l01901"></a>01901                                  <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *child,
<a name="l01902"></a>01902                                  <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle,
<a name="l01903"></a>01903                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec)
<a name="l01904"></a>01904 {
<a name="l01905"></a>01905         <span class="keywordtype">int</span> rc = 0;
<a name="l01906"></a>01906         ENTRY;
<a name="l01907"></a>01907 
<a name="l01908"></a>01908         <span class="keywordflow">if</span> (S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l01909"></a>01909                 <span class="comment">/* Add &quot;.&quot; and &quot;..&quot; for newly created dir */</span>
<a name="l01910"></a>01910                 mdo_ref_add(env, child, handle);
<a name="l01911"></a>01911                 rc = __mdd_index_insert_only(env, child, mdo2fid(child),
<a name="l01912"></a>01912                                              S_IFDIR, dot, handle);
<a name="l01913"></a>01913                 <span class="keywordflow">if</span> (rc == 0)
<a name="l01914"></a>01914                         rc = __mdd_index_insert_only(env, child, pfid, S_IFDIR,
<a name="l01915"></a>01915                                                      dotdot, handle);
<a name="l01916"></a>01916                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01917"></a>01917                         mdo_ref_del(env, child, handle);
<a name="l01918"></a>01918         }
<a name="l01919"></a>01919 
<a name="l01920"></a>01920         RETURN(rc);
<a name="l01921"></a>01921 }
<a name="l01922"></a>01922 
<a name="l01940"></a>01940 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_create_sanity_check(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01941"></a>01941                                    <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *pobj,
<a name="l01942"></a>01942                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr,
<a name="l01943"></a>01943                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l01944"></a>01944                                    <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *cattr,
<a name="l01945"></a>01945                                    <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec)
<a name="l01946"></a>01946 {
<a name="l01947"></a>01947         <span class="keyword">struct </span><a class="code" href="structmdd__thread__info.html">mdd_thread_info</a> *info = mdd_env_info(env);
<a name="l01948"></a>01948         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>     *fid       = &amp;info-&gt;mti_fid;
<a name="l01949"></a>01949         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *obj       = md2mdd_obj(pobj);
<a name="l01950"></a>01950         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *m         = mdo2mdd(pobj);
<a name="l01951"></a>01951         <span class="keywordtype">bool</span>            check_perm = <span class="keyword">true</span>;
<a name="l01952"></a>01952         <span class="keywordtype">int</span> rc;
<a name="l01953"></a>01953         ENTRY;
<a name="l01954"></a>01954 
<a name="l01955"></a>01955         <span class="comment">/* EEXIST check */</span>
<a name="l01956"></a>01956         <span class="keywordflow">if</span> (mdd_is_dead_obj(obj))
<a name="l01957"></a>01957                 RETURN(-ENOENT);
<a name="l01958"></a>01958 
<a name="l01959"></a>01959         <span class="comment">/*</span>
<a name="l01960"></a>01960 <span class="comment">         * In some cases this lookup is not needed - we know before if name</span>
<a name="l01961"></a>01961 <span class="comment">         * exists or not because MDT performs lookup for it.</span>
<a name="l01962"></a>01962 <span class="comment">         * name length check is done in lookup.</span>
<a name="l01963"></a>01963 <span class="comment">         */</span>
<a name="l01964"></a>01964         <span class="keywordflow">if</span> (spec-&gt;sp_cr_lookup) {
<a name="l01965"></a>01965                 <span class="comment">/*</span>
<a name="l01966"></a>01966 <span class="comment">                 * Check if the name already exist, though it will be checked in</span>
<a name="l01967"></a>01967 <span class="comment">                 * _index_insert also, for avoiding rolling back if exists</span>
<a name="l01968"></a>01968 <span class="comment">                 * _index_insert.</span>
<a name="l01969"></a>01969 <span class="comment">                 */</span>
<a name="l01970"></a>01970                 rc = __mdd_lookup(env, pobj, pattr, lname, fid,
<a name="l01971"></a>01971                                   MAY_WRITE | MAY_EXEC);
<a name="l01972"></a>01972                 <span class="keywordflow">if</span> (rc != -ENOENT)
<a name="l01973"></a>01973                         RETURN(rc ? : -EEXIST);
<a name="l01974"></a>01974 
<a name="l01975"></a>01975                 <span class="comment">/* Permission is already being checked in mdd_lookup */</span>
<a name="l01976"></a>01976                 check_perm = <span class="keyword">false</span>;
<a name="l01977"></a>01977         }
<a name="l01978"></a>01978 
<a name="l01979"></a>01979         rc = mdd_may_create(env, obj, pattr, NULL, check_perm);
<a name="l01980"></a>01980         <span class="keywordflow">if</span> (rc != 0)
<a name="l01981"></a>01981                 RETURN(rc);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983         <span class="comment">/* sgid check */</span>
<a name="l01984"></a>01984         <span class="keywordflow">if</span> (pattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> &amp; S_ISGID) {
<a name="l01985"></a>01985                 cattr-&gt;<a class="code" href="structlu__attr.html#a95d12598de784988bf5b17986c4ac6c9" title="group id">la_gid</a> = pattr-&gt;<a class="code" href="structlu__attr.html#a95d12598de784988bf5b17986c4ac6c9" title="group id">la_gid</a>;
<a name="l01986"></a>01986                 <span class="keywordflow">if</span> (S_ISDIR(cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l01987"></a>01987                         cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> |= S_ISGID;
<a name="l01988"></a>01988                         cattr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> |= LA_MODE;
<a name="l01989"></a>01989                 }
<a name="l01990"></a>01990         }
<a name="l01991"></a>01991 
<a name="l01992"></a>01992         rc = mdd_name_check(m, lname);
<a name="l01993"></a>01993         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01994"></a>01994                 RETURN(rc);
<a name="l01995"></a>01995 
<a name="l01996"></a>01996         <span class="keywordflow">switch</span> (cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> &amp; S_IFMT) {
<a name="l01997"></a>01997         <span class="keywordflow">case</span> S_IFLNK: {
<a name="l01998"></a>01998                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> symlen = strlen(spec-&gt;u.<a class="code" href="structmd__op__spec.html#a5688bea4024906b5b54ba910399ee1d1" title="symlink target">sp_symname</a>) + 1;
<a name="l01999"></a>01999 
<a name="l02000"></a>02000                 <span class="keywordflow">if</span> (symlen &gt; m-&gt;mdd_dt_conf.ddp_symlink_max)
<a name="l02001"></a>02001                         RETURN(-ENAMETOOLONG);
<a name="l02002"></a>02002                 <span class="keywordflow">else</span>
<a name="l02003"></a>02003                         RETURN(0);
<a name="l02004"></a>02004         }
<a name="l02005"></a>02005         <span class="keywordflow">case</span> S_IFDIR:
<a name="l02006"></a>02006         <span class="keywordflow">case</span> S_IFREG:
<a name="l02007"></a>02007         <span class="keywordflow">case</span> S_IFCHR:
<a name="l02008"></a>02008         <span class="keywordflow">case</span> S_IFBLK:
<a name="l02009"></a>02009         <span class="keywordflow">case</span> S_IFIFO:
<a name="l02010"></a>02010         <span class="keywordflow">case</span> S_IFSOCK:
<a name="l02011"></a>02011                 rc = 0;
<a name="l02012"></a>02012                 <span class="keywordflow">break</span>;
<a name="l02013"></a>02013         <span class="keywordflow">default</span>:
<a name="l02014"></a>02014                 rc = -EINVAL;
<a name="l02015"></a>02015                 <span class="keywordflow">break</span>;
<a name="l02016"></a>02016         }
<a name="l02017"></a>02017         RETURN(rc);
<a name="l02018"></a>02018 }
<a name="l02019"></a>02019 
<a name="l02020"></a>02020 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_object_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02021"></a>02021                                      <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l02022"></a>02022                                      <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *p, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *c,
<a name="l02023"></a>02023                                      <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l02024"></a>02024                                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle,
<a name="l02025"></a>02025                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec,
<a name="l02026"></a>02026                                      <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *def_acl_buf,
<a name="l02027"></a>02027                                      <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *acl_buf,
<a name="l02028"></a>02028                                      <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint)
<a name="l02029"></a>02029 {
<a name="l02030"></a>02030         <span class="keywordtype">int</span> rc;
<a name="l02031"></a>02031 
<a name="l02032"></a>02032         rc = mdd_declare_object_create_internal(env, p, c, attr, handle, spec,
<a name="l02033"></a>02033                                                 hint);
<a name="l02034"></a>02034         <span class="keywordflow">if</span> (rc)
<a name="l02035"></a>02035                 GOTO(out, rc);
<a name="l02036"></a>02036 
<a name="l02037"></a>02037 <span class="preprocessor">#ifdef CONFIG_FS_POSIX_ACL</span>
<a name="l02038"></a>02038 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (def_acl_buf-&gt;lb_len &gt; 0 &amp;&amp; S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02039"></a>02039                 <span class="comment">/* if dir, then can inherit default ACl */</span>
<a name="l02040"></a>02040                 rc = mdo_declare_xattr_set(env, c, def_acl_buf,
<a name="l02041"></a>02041                                            XATTR_NAME_ACL_DEFAULT,
<a name="l02042"></a>02042                                            0, handle);
<a name="l02043"></a>02043                 <span class="keywordflow">if</span> (rc)
<a name="l02044"></a>02044                         GOTO(out, rc);
<a name="l02045"></a>02045         }
<a name="l02046"></a>02046 
<a name="l02047"></a>02047         <span class="keywordflow">if</span> (acl_buf-&gt;lb_len &gt; 0) {
<a name="l02048"></a>02048                 rc = mdo_declare_attr_set(env, c, attr, handle);
<a name="l02049"></a>02049                 <span class="keywordflow">if</span> (rc)
<a name="l02050"></a>02050                         GOTO(out, rc);
<a name="l02051"></a>02051 
<a name="l02052"></a>02052                 rc = mdo_declare_xattr_set(env, c, acl_buf,
<a name="l02053"></a>02053                                            XATTR_NAME_ACL_ACCESS, 0, handle);
<a name="l02054"></a>02054                 <span class="keywordflow">if</span> (rc)
<a name="l02055"></a>02055                         GOTO(out, rc);
<a name="l02056"></a>02056         }
<a name="l02057"></a>02057 <span class="preprocessor">#endif</span>
<a name="l02058"></a>02058 <span class="preprocessor"></span>        rc = mdd_declare_object_initialize(env, p, c, attr, handle);
<a name="l02059"></a>02059         <span class="keywordflow">if</span> (rc)
<a name="l02060"></a>02060                 GOTO(out, rc);
<a name="l02061"></a>02061 
<a name="l02062"></a>02062         <span class="comment">/* replay case, create LOV EA from client data */</span>
<a name="l02063"></a>02063         <span class="keywordflow">if</span> (spec-&gt;<a class="code" href="structmd__op__spec.html#a5514ad7079fdcaf7e84c9e000a0773d4" title="don&amp;#39;t create lov objects or llog cookie - this replay">no_create</a> ||
<a name="l02064"></a>02064             (spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> &amp; MDS_OPEN_HAS_EA &amp;&amp; S_ISREG(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>))) {
<a name="l02065"></a>02065                 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf;
<a name="l02066"></a>02066 
<a name="l02067"></a>02067                 buf = mdd_buf_get_const(env, spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadata,
<a name="l02068"></a>02068                                         spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadatalen);
<a name="l02069"></a>02069                 rc = mdo_declare_xattr_set(env, c, buf, XATTR_NAME_LOV, 0,
<a name="l02070"></a>02070                                            handle);
<a name="l02071"></a>02071                 <span class="keywordflow">if</span> (rc)
<a name="l02072"></a>02072                         GOTO(out, rc);
<a name="l02073"></a>02073         }
<a name="l02074"></a>02074 
<a name="l02075"></a>02075         <span class="keywordflow">if</span> (S_ISLNK(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02076"></a>02076                 <span class="keyword">const</span> <span class="keywordtype">char</span> *target_name = spec-&gt;u.<a class="code" href="structmd__op__spec.html#a5688bea4024906b5b54ba910399ee1d1" title="symlink target">sp_symname</a>;
<a name="l02077"></a>02077                 <span class="keywordtype">int</span> sym_len = strlen(target_name);
<a name="l02078"></a>02078                 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf;
<a name="l02079"></a>02079 
<a name="l02080"></a>02080                 buf = mdd_buf_get_const(env, target_name, sym_len);
<a name="l02081"></a>02081                 rc = dt_declare_record_write(env, mdd_object_child(c),
<a name="l02082"></a>02082                                              buf, 0, handle);
<a name="l02083"></a>02083                 <span class="keywordflow">if</span> (rc)
<a name="l02084"></a>02084                         GOTO(out, rc);
<a name="l02085"></a>02085         }
<a name="l02086"></a>02086 out:
<a name="l02087"></a>02087         <span class="keywordflow">return</span> rc;
<a name="l02088"></a>02088 }
<a name="l02089"></a>02089 
<a name="l02090"></a>02090 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l02091"></a>02091                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *p, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *c,
<a name="l02092"></a>02092                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *name,
<a name="l02093"></a>02093                               <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l02094"></a>02094                               <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle,
<a name="l02095"></a>02095                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec,
<a name="l02096"></a>02096                               <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l02097"></a>02097                               <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *def_acl_buf,
<a name="l02098"></a>02098                               <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *acl_buf,
<a name="l02099"></a>02099                               <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint)
<a name="l02100"></a>02100 {
<a name="l02101"></a>02101         <span class="keywordtype">int</span> rc;
<a name="l02102"></a>02102 
<a name="l02103"></a>02103         rc = mdd_declare_object_create(env, mdd, p, c, attr, handle, spec,
<a name="l02104"></a>02104                                        def_acl_buf, acl_buf, hint);
<a name="l02105"></a>02105         <span class="keywordflow">if</span> (rc)
<a name="l02106"></a>02106                 GOTO(out, rc);
<a name="l02107"></a>02107 
<a name="l02108"></a>02108         <span class="keywordflow">if</span> (S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02109"></a>02109                 rc = mdo_declare_ref_add(env, p, handle);
<a name="l02110"></a>02110                 <span class="keywordflow">if</span> (rc)
<a name="l02111"></a>02111                         GOTO(out, rc);
<a name="l02112"></a>02112         }
<a name="l02113"></a>02113 
<a name="l02114"></a>02114         <span class="keywordflow">if</span> (unlikely(spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> &amp; MDS_OPEN_VOLATILE)) {
<a name="l02115"></a>02115                 rc = orph_declare_index_insert(env, c, attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>, handle);
<a name="l02116"></a>02116                 <span class="keywordflow">if</span> (rc)
<a name="l02117"></a>02117                         GOTO(out, rc);
<a name="l02118"></a>02118         } <span class="keywordflow">else</span> {
<a name="l02119"></a>02119                 <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>  *la = &amp;mdd_env_info(env)-&gt;<a class="code" href="structmdd__thread__info.html#a6a4ecb9102dadba2b066f90bd6532268" title="used to set c/mtime">mti_la_for_fix</a>;
<a name="l02120"></a>02120 
<a name="l02121"></a>02121                 rc = mdo_declare_index_insert(env, p, mdo2fid(c), attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>,
<a name="l02122"></a>02122                                               name-&gt;ln_name, handle);
<a name="l02123"></a>02123                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02124"></a>02124                         <span class="keywordflow">return</span> rc;
<a name="l02125"></a>02125 
<a name="l02126"></a>02126                 rc = mdd_declare_links_add(env, c, handle, ldata, MLAO_IGNORE);
<a name="l02127"></a>02127                 <span class="keywordflow">if</span> (rc)
<a name="l02128"></a>02128                         <span class="keywordflow">return</span> rc;
<a name="l02129"></a>02129 
<a name="l02130"></a>02130                 *la = *attr;
<a name="l02131"></a>02131                 la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MTIME;
<a name="l02132"></a>02132                 rc = mdo_declare_attr_set(env, p, la, handle);
<a name="l02133"></a>02133                 <span class="keywordflow">if</span> (rc)
<a name="l02134"></a>02134                         <span class="keywordflow">return</span> rc;
<a name="l02135"></a>02135 
<a name="l02136"></a>02136                 rc = mdd_declare_changelog_store(env, mdd, name, NULL, handle);
<a name="l02137"></a>02137                 <span class="keywordflow">if</span> (rc)
<a name="l02138"></a>02138                         <span class="keywordflow">return</span> rc;
<a name="l02139"></a>02139         }
<a name="l02140"></a>02140 out:
<a name="l02141"></a>02141         <span class="keywordflow">return</span> rc;
<a name="l02142"></a>02142 }
<a name="l02143"></a>02143 
<a name="l02144"></a>02144 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_acl_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l02145"></a>02145                         <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la, <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *def_acl_buf,
<a name="l02146"></a>02146                         <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *acl_buf)
<a name="l02147"></a>02147 {
<a name="l02148"></a>02148         <span class="keywordtype">int</span>     rc;
<a name="l02149"></a>02149         ENTRY;
<a name="l02150"></a>02150 
<a name="l02151"></a>02151         <span class="keywordflow">if</span> (S_ISLNK(la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02152"></a>02152                 acl_buf-&gt;lb_len = 0;
<a name="l02153"></a>02153                 def_acl_buf-&gt;lb_len = 0;
<a name="l02154"></a>02154                 RETURN(0);
<a name="l02155"></a>02155         }
<a name="l02156"></a>02156 
<a name="l02157"></a>02157         mdd_read_lock(env, pobj, MOR_TGT_PARENT);
<a name="l02158"></a>02158         rc = mdo_xattr_get(env, pobj, def_acl_buf,
<a name="l02159"></a>02159                            XATTR_NAME_ACL_DEFAULT);
<a name="l02160"></a>02160         mdd_read_unlock(env, pobj);
<a name="l02161"></a>02161         <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l02162"></a>02162                 <span class="comment">/* If there are default ACL, fix mode/ACL by default ACL */</span>
<a name="l02163"></a>02163                 def_acl_buf-&gt;lb_len = rc;
<a name="l02164"></a>02164                 LASSERT(def_acl_buf-&gt;lb_len &lt;= acl_buf-&gt;lb_len);
<a name="l02165"></a>02165                 memcpy(acl_buf-&gt;lb_buf, def_acl_buf-&gt;lb_buf, rc);
<a name="l02166"></a>02166                 acl_buf-&gt;lb_len = rc;
<a name="l02167"></a>02167                 rc = __mdd_fix_mode_acl(env, acl_buf, &amp;la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>);
<a name="l02168"></a>02168                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02169"></a>02169                         RETURN(rc);
<a name="l02170"></a>02170         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == -ENODATA || rc == -EOPNOTSUPP) {
<a name="l02171"></a>02171                 <span class="comment">/* If there are no default ACL, fix mode by mask */</span>
<a name="l02172"></a>02172                 <span class="keyword">struct </span><a class="code" href="structlu__ucred.html">lu_ucred</a> *uc = <a class="code" href="group__md.html#ga891ea36420f73975ab3f7cc8bd1b3802" title="Get ucred key if session exists and ucred key is allocated on it.">lu_ucred</a>(env);
<a name="l02173"></a>02173 
<a name="l02174"></a>02174                 <span class="comment">/* The create triggered by MDT internal events, such as</span>
<a name="l02175"></a>02175 <span class="comment">                 * LFSCK reset, will not contain valid &quot;uc&quot;. */</span>
<a name="l02176"></a>02176                 <span class="keywordflow">if</span> (unlikely(uc != NULL))
<a name="l02177"></a>02177                         la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> &amp;= ~uc-&gt;uc_umask;
<a name="l02178"></a>02178                 rc = 0;
<a name="l02179"></a>02179                 acl_buf-&gt;lb_len = 0;
<a name="l02180"></a>02180                 def_acl_buf-&gt;lb_len = 0;
<a name="l02181"></a>02181         }
<a name="l02182"></a>02182 
<a name="l02183"></a>02183         RETURN(rc);
<a name="l02184"></a>02184 }
<a name="l02185"></a>02185 
<a name="l02189"></a>02189 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_object_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l02190"></a>02190                              <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *son, <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l02191"></a>02191                              <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec, <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *acl_buf,
<a name="l02192"></a>02192                              <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *def_acl_buf,
<a name="l02193"></a>02193                              <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint,
<a name="l02194"></a>02194                              <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l02195"></a>02195 {
<a name="l02196"></a>02196         <span class="keywordtype">int</span>                     rc;
<a name="l02197"></a>02197 
<a name="l02198"></a>02198         mdd_write_lock(env, son, MOR_TGT_CHILD);
<a name="l02199"></a>02199         rc = mdd_object_create_internal(env, NULL, son, attr, handle, spec,
<a name="l02200"></a>02200                                         hint);
<a name="l02201"></a>02201         <span class="keywordflow">if</span> (rc)
<a name="l02202"></a>02202                 GOTO(unlock, rc);
<a name="l02203"></a>02203 
<a name="l02204"></a>02204         <span class="comment">/* Note: In DNE phase I, for striped dir, though sub-stripes will be</span>
<a name="l02205"></a>02205 <span class="comment">         * created in declare phase, they also needs to be added to master</span>
<a name="l02206"></a>02206 <span class="comment">         * object as sub-directory entry. So it has to initialize the master</span>
<a name="l02207"></a>02207 <span class="comment">         * object, then set dir striped EA.(in mdo_xattr_set) */</span>
<a name="l02208"></a>02208         rc = mdd_object_initialize(env, mdo2fid(pobj), son, attr, handle,
<a name="l02209"></a>02209                                    spec);
<a name="l02210"></a>02210         <span class="keywordflow">if</span> (rc != 0)
<a name="l02211"></a>02211                 GOTO(err_destroy, rc);
<a name="l02212"></a>02212 
<a name="l02213"></a>02213         <span class="comment">/*</span>
<a name="l02214"></a>02214 <span class="comment">         * in case of replay we just set LOVEA provided by the client</span>
<a name="l02215"></a>02215 <span class="comment">         * XXX: I think it would be interesting to try &quot;old&quot; way where</span>
<a name="l02216"></a>02216 <span class="comment">         *      MDT calls this xattr_set(LOV) in a different transaction.</span>
<a name="l02217"></a>02217 <span class="comment">         *      probably this way we code can be made better.</span>
<a name="l02218"></a>02218 <span class="comment">         */</span>
<a name="l02219"></a>02219 
<a name="l02220"></a>02220         <span class="comment">/* During creation, there are only a few cases we need do xattr_set to</span>
<a name="l02221"></a>02221 <span class="comment">         * create stripes.</span>
<a name="l02222"></a>02222 <span class="comment">         * 1. regular file: see comments above.</span>
<a name="l02223"></a>02223 <span class="comment">         * 2. dir: inherit default striping or pool settings from parent.</span>
<a name="l02224"></a>02224 <span class="comment">         * 3. create striped directory with provided stripeEA.</span>
<a name="l02225"></a>02225 <span class="comment">         * 4. create striped directory because inherit default layout from the</span>
<a name="l02226"></a>02226 <span class="comment">         * parent.</span>
<a name="l02227"></a>02227 <span class="comment">         */</span>
<a name="l02228"></a>02228         <span class="keywordflow">if</span> (spec-&gt;<a class="code" href="structmd__op__spec.html#a5514ad7079fdcaf7e84c9e000a0773d4" title="don&amp;#39;t create lov objects or llog cookie - this replay">no_create</a> ||
<a name="l02229"></a>02229             (S_ISREG(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) &amp;&amp; spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> &amp; MDS_OPEN_HAS_EA) ||
<a name="l02230"></a>02230             S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02231"></a>02231                 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf;
<a name="l02232"></a>02232 
<a name="l02233"></a>02233                 buf = mdd_buf_get_const(env, spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadata,
<a name="l02234"></a>02234                                         spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadatalen);
<a name="l02235"></a>02235                 rc = mdo_xattr_set(env, son, buf,
<a name="l02236"></a>02236                                    S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) ? XATTR_NAME_LMV :
<a name="l02237"></a>02237                                                             XATTR_NAME_LOV, 0,
<a name="l02238"></a>02238                                    handle);
<a name="l02239"></a>02239                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02240"></a>02240                         GOTO(err_destroy, rc);
<a name="l02241"></a>02241         }
<a name="l02242"></a>02242 
<a name="l02243"></a>02243 <span class="preprocessor">#ifdef CONFIG_FS_POSIX_ACL</span>
<a name="l02244"></a>02244 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (def_acl_buf != NULL &amp;&amp; def_acl_buf-&gt;lb_len &gt; 0 &amp;&amp;
<a name="l02245"></a>02245             S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02246"></a>02246                 <span class="comment">/* set default acl */</span>
<a name="l02247"></a>02247                 rc = mdo_xattr_set(env, son, def_acl_buf,
<a name="l02248"></a>02248                                    XATTR_NAME_ACL_DEFAULT, 0,
<a name="l02249"></a>02249                                    handle);
<a name="l02250"></a>02250                 <span class="keywordflow">if</span> (rc)
<a name="l02251"></a>02251                         GOTO(err_destroy, rc);
<a name="l02252"></a>02252         }
<a name="l02253"></a>02253         <span class="comment">/* set its own acl */</span>
<a name="l02254"></a>02254         <span class="keywordflow">if</span> (acl_buf != NULL &amp;&amp; acl_buf-&gt;lb_len &gt; 0) {
<a name="l02255"></a>02255                 rc = mdo_xattr_set(env, son, acl_buf,
<a name="l02256"></a>02256                                    XATTR_NAME_ACL_ACCESS,
<a name="l02257"></a>02257                                    0, handle);
<a name="l02258"></a>02258                 <span class="keywordflow">if</span> (rc)
<a name="l02259"></a>02259                         GOTO(err_destroy, rc);
<a name="l02260"></a>02260         }
<a name="l02261"></a>02261 <span class="preprocessor">#endif</span>
<a name="l02262"></a>02262 <span class="preprocessor"></span>
<a name="l02263"></a>02263         <span class="keywordflow">if</span> (S_ISLNK(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02264"></a>02264                 <span class="keyword">struct </span><a class="code" href="structlu__ucred.html">lu_ucred</a>  *uc = <a class="code" href="group__md.html#gad24ee97e141a9dd7ccba9f1460cf4438" title="Get ucred key, which must exist and must be properly initialized.">lu_ucred_assert</a>(env);
<a name="l02265"></a>02265                 <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *dt = mdd_object_child(son);
<a name="l02266"></a>02266                 <span class="keyword">const</span> <span class="keywordtype">char</span> *target_name = spec-&gt;u.<a class="code" href="structmd__op__spec.html#a5688bea4024906b5b54ba910399ee1d1" title="symlink target">sp_symname</a>;
<a name="l02267"></a>02267                 <span class="keywordtype">int</span> sym_len = strlen(target_name);
<a name="l02268"></a>02268                 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf;
<a name="l02269"></a>02269                 loff_t pos = 0;
<a name="l02270"></a>02270 
<a name="l02271"></a>02271                 buf = mdd_buf_get_const(env, target_name, sym_len);
<a name="l02272"></a>02272                 rc = dt-&gt;do_body_ops-&gt;<a class="code" href="structdt__body__operations.html#a1d14bb3445892ab680cd8885645334bb" title="Write unstructured data to regular existing object.">dbo_write</a>(env, dt, buf, &amp;pos, handle,
<a name="l02273"></a>02273                                                 uc-&gt;uc_cap &amp;
<a name="l02274"></a>02274                                                 CFS_CAP_SYS_RESOURCE_MASK);
<a name="l02275"></a>02275 
<a name="l02276"></a>02276                 <span class="keywordflow">if</span> (rc == sym_len)
<a name="l02277"></a>02277                         rc = 0;
<a name="l02278"></a>02278                 <span class="keywordflow">else</span>
<a name="l02279"></a>02279                         GOTO(err_initlized, rc = -EFAULT);
<a name="l02280"></a>02280         }
<a name="l02281"></a>02281 
<a name="l02282"></a>02282 err_initlized:
<a name="l02283"></a>02283         <span class="keywordflow">if</span> (unlikely(rc != 0)) {
<a name="l02284"></a>02284                 <span class="keywordtype">int</span> rc2;
<a name="l02285"></a>02285                 <span class="keywordflow">if</span> (S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02286"></a>02286                         <span class="comment">/* Drop the reference, no need to delete &quot;.&quot;/&quot;..&quot;,</span>
<a name="l02287"></a>02287 <span class="comment">                         * because the object to be destroied directly. */</span>
<a name="l02288"></a>02288                         rc2 = mdo_ref_del(env, son, handle);
<a name="l02289"></a>02289                         <span class="keywordflow">if</span> (rc2 != 0)
<a name="l02290"></a>02290                                 GOTO(unlock, rc);
<a name="l02291"></a>02291                 }
<a name="l02292"></a>02292                 rc2 = mdo_ref_del(env, son, handle);
<a name="l02293"></a>02293                 <span class="keywordflow">if</span> (rc2 != 0)
<a name="l02294"></a>02294                         GOTO(unlock, rc);
<a name="l02295"></a>02295 err_destroy:
<a name="l02296"></a>02296                 mdo_destroy(env, son, handle);
<a name="l02297"></a>02297         }
<a name="l02298"></a>02298 unlock:
<a name="l02299"></a>02299         mdd_write_unlock(env, son);
<a name="l02300"></a>02300         RETURN(rc);
<a name="l02301"></a>02301 }
<a name="l02302"></a>02302 
<a name="l02303"></a>02303 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_index_delete(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02304"></a>02304                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj,
<a name="l02305"></a>02305                             <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *cattr,
<a name="l02306"></a>02306                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname)
<a name="l02307"></a>02307 {
<a name="l02308"></a>02308         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(&amp;mdd_pobj-&gt;mod_obj);
<a name="l02309"></a>02309         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle;
<a name="l02310"></a>02310         <span class="keywordtype">int</span> rc;
<a name="l02311"></a>02311         ENTRY;
<a name="l02312"></a>02312 
<a name="l02313"></a>02313         handle = mdd_trans_create(env, mdd);
<a name="l02314"></a>02314         <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l02315"></a>02315                 RETURN(PTR_ERR(handle));
<a name="l02316"></a>02316 
<a name="l02317"></a>02317         rc = mdo_declare_index_delete(env, mdd_pobj, lname-&gt;ln_name,
<a name="l02318"></a>02318                                       handle);
<a name="l02319"></a>02319         <span class="keywordflow">if</span> (rc != 0)
<a name="l02320"></a>02320                 GOTO(stop, rc);
<a name="l02321"></a>02321 
<a name="l02322"></a>02322         <span class="keywordflow">if</span> (S_ISDIR(cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02323"></a>02323                 rc = mdo_declare_ref_del(env, mdd_pobj, handle);
<a name="l02324"></a>02324                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02325"></a>02325                         GOTO(stop, rc);
<a name="l02326"></a>02326         }
<a name="l02327"></a>02327 
<a name="l02328"></a>02328         <span class="comment">/* Since this will only be used in the error handler path,</span>
<a name="l02329"></a>02329 <span class="comment">         * Let&apos;s set the thandle to be local and not mess the transno */</span>
<a name="l02330"></a>02330         handle-&gt;th_local = 1;
<a name="l02331"></a>02331         rc = mdd_trans_start(env, mdd, handle);
<a name="l02332"></a>02332         <span class="keywordflow">if</span> (rc)
<a name="l02333"></a>02333                 GOTO(stop, rc);
<a name="l02334"></a>02334 
<a name="l02335"></a>02335         rc = __mdd_index_delete(env, mdd_pobj, lname-&gt;ln_name,
<a name="l02336"></a>02336                                 S_ISDIR(cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>), handle);
<a name="l02337"></a>02337         <span class="keywordflow">if</span> (rc)
<a name="l02338"></a>02338                 GOTO(stop, rc);
<a name="l02339"></a>02339 stop:
<a name="l02340"></a>02340         mdd_trans_stop(env, mdd, rc, handle);
<a name="l02341"></a>02341         RETURN(rc);
<a name="l02342"></a>02342 }
<a name="l02343"></a>02343 
<a name="l02344"></a>02344 <span class="comment">/*</span>
<a name="l02345"></a>02345 <span class="comment"> * Create object and insert it into namespace.</span>
<a name="l02346"></a>02346 <span class="comment"> */</span>
<a name="l02347"></a>02347 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *pobj,
<a name="l02348"></a>02348                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *child,
<a name="l02349"></a>02349                       <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec, <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a>* ma)
<a name="l02350"></a>02350 {
<a name="l02351"></a>02351         <span class="keyword">struct </span><a class="code" href="structmdd__thread__info.html">mdd_thread_info</a>  *info = mdd_env_info(env);
<a name="l02352"></a>02352         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *la = &amp;info-&gt;<a class="code" href="structmdd__thread__info.html#a6a4ecb9102dadba2b066f90bd6532268" title="used to set c/mtime">mti_la_for_fix</a>;
<a name="l02353"></a>02353         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a>       *mdd_pobj = md2mdd_obj(pobj);
<a name="l02354"></a>02354         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a>       *son = md2mdd_obj(child);
<a name="l02355"></a>02355         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a>       *mdd = mdo2mdd(pobj);
<a name="l02356"></a>02356         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *attr = &amp;ma-&gt;ma_attr;
<a name="l02357"></a>02357         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *handle;
<a name="l02358"></a>02358         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *pattr = &amp;info-&gt;<a class="code" href="structmdd__thread__info.html#a994770071f2f0cd8277ded0ad2c9c2d8" title="only be used by MDD interfaces, can be passed into local MDD APIs.">mti_pattr</a>;
<a name="l02359"></a>02359         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           acl_buf;
<a name="l02360"></a>02360         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           def_acl_buf;
<a name="l02361"></a>02361         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>      *ldata = &amp;info-&gt;mti_link_data;
<a name="l02362"></a>02362         <span class="keyword">const</span> <span class="keywordtype">char</span>              *name = lname-&gt;ln_name;
<a name="l02363"></a>02363         <span class="keyword">struct </span><a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint = &amp;mdd_env_info(env)-&gt;mti_hint;
<a name="l02364"></a>02364         <span class="keywordtype">int</span>                      rc;
<a name="l02365"></a>02365         <span class="keywordtype">int</span>                      rc2;
<a name="l02366"></a>02366         ENTRY;
<a name="l02367"></a>02367 
<a name="l02368"></a>02368         <span class="comment">/*</span>
<a name="l02369"></a>02369 <span class="comment">         * Two operations have to be performed:</span>
<a name="l02370"></a>02370 <span class="comment">         *</span>
<a name="l02371"></a>02371 <span class="comment">         *  - an allocation of a new object (-&gt;do_create()), and</span>
<a name="l02372"></a>02372 <span class="comment">         *</span>
<a name="l02373"></a>02373 <span class="comment">         *  - an insertion into a parent index (-&gt;dio_insert()).</span>
<a name="l02374"></a>02374 <span class="comment">         *</span>
<a name="l02375"></a>02375 <span class="comment">         * Due to locking, operation order is not important, when both are</span>
<a name="l02376"></a>02376 <span class="comment">         * successful, *but* error handling cases are quite different:</span>
<a name="l02377"></a>02377 <span class="comment">         *</span>
<a name="l02378"></a>02378 <span class="comment">         *  - if insertion is done first, and following object creation fails,</span>
<a name="l02379"></a>02379 <span class="comment">         *  insertion has to be rolled back, but this operation might fail</span>
<a name="l02380"></a>02380 <span class="comment">         *  also leaving us with dangling index entry.</span>
<a name="l02381"></a>02381 <span class="comment">         *</span>
<a name="l02382"></a>02382 <span class="comment">         *  - if creation is done first, is has to be undone if insertion</span>
<a name="l02383"></a>02383 <span class="comment">         *  fails, leaving us with leaked space, which is neither good, nor</span>
<a name="l02384"></a>02384 <span class="comment">         *  fatal.</span>
<a name="l02385"></a>02385 <span class="comment">         *</span>
<a name="l02386"></a>02386 <span class="comment">         * It seems that creation-first is simplest solution, but it is</span>
<a name="l02387"></a>02387 <span class="comment">         * sub-optimal in the frequent</span>
<a name="l02388"></a>02388 <span class="comment">         *</span>
<a name="l02389"></a>02389 <span class="comment">         *         $ mkdir foo</span>
<a name="l02390"></a>02390 <span class="comment">         *         $ mkdir foo</span>
<a name="l02391"></a>02391 <span class="comment">         *</span>
<a name="l02392"></a>02392 <span class="comment">         * case, because second mkdir is bound to create object, only to</span>
<a name="l02393"></a>02393 <span class="comment">         * destroy it immediately.</span>
<a name="l02394"></a>02394 <span class="comment">         *</span>
<a name="l02395"></a>02395 <span class="comment">         * To avoid this follow local file systems that do double lookup:</span>
<a name="l02396"></a>02396 <span class="comment">         *</span>
<a name="l02397"></a>02397 <span class="comment">         *     0. lookup -&gt; -EEXIST (mdd_create_sanity_check())</span>
<a name="l02398"></a>02398 <span class="comment">         *</span>
<a name="l02399"></a>02399 <span class="comment">         *     1. create            (mdd_object_create_internal())</span>
<a name="l02400"></a>02400 <span class="comment">         *</span>
<a name="l02401"></a>02401 <span class="comment">         *     2. insert            (__mdd_index_insert(), lookup again)</span>
<a name="l02402"></a>02402 <span class="comment">         */</span>
<a name="l02403"></a>02403 
<a name="l02404"></a>02404         rc = mdd_la_get(env, mdd_pobj, pattr);
<a name="l02405"></a>02405         <span class="keywordflow">if</span> (rc != 0)
<a name="l02406"></a>02406                 RETURN(rc);
<a name="l02407"></a>02407 
<a name="l02408"></a>02408         <span class="comment">/* Sanity checks before big job. */</span>
<a name="l02409"></a>02409         rc = mdd_create_sanity_check(env, pobj, pattr, lname, attr, spec);
<a name="l02410"></a>02410         <span class="keywordflow">if</span> (rc)
<a name="l02411"></a>02411                 RETURN(rc);
<a name="l02412"></a>02412 
<a name="l02413"></a>02413         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_MDS_DQACQ_NET))
<a name="l02414"></a>02414                 GOTO(out_free, rc = -EINPROGRESS);
<a name="l02415"></a>02415 
<a name="l02416"></a>02416         handle = mdd_trans_create(env, mdd);
<a name="l02417"></a>02417         <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l02418"></a>02418                 GOTO(out_free, rc = PTR_ERR(handle));
<a name="l02419"></a>02419 
<a name="l02420"></a>02420         acl_buf.lb_buf = info-&gt;mti_xattr_buf;
<a name="l02421"></a>02421         acl_buf.lb_len = <span class="keyword">sizeof</span>(info-&gt;mti_xattr_buf);
<a name="l02422"></a>02422         def_acl_buf.lb_buf = info-&gt;mti_key;
<a name="l02423"></a>02423         def_acl_buf.lb_len = <span class="keyword">sizeof</span>(info-&gt;mti_key);
<a name="l02424"></a>02424         rc = mdd_acl_init(env, mdd_pobj, attr, &amp;def_acl_buf, &amp;acl_buf);
<a name="l02425"></a>02425         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02426"></a>02426                 GOTO(out_stop, rc);
<a name="l02427"></a>02427 
<a name="l02428"></a>02428         mdd_object_make_hint(env, mdd_pobj, son, attr, spec, hint);
<a name="l02429"></a>02429 
<a name="l02430"></a>02430         memset(ldata, 0, <span class="keyword">sizeof</span>(*ldata));
<a name="l02431"></a>02431         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_BAD_PARENT)) {
<a name="l02432"></a>02432                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> tfid = *mdd_object_fid(mdd_pobj);
<a name="l02433"></a>02433 
<a name="l02434"></a>02434                 tfid.f_oid--;
<a name="l02435"></a>02435                 rc = mdd_linkea_prepare(env, son, NULL, NULL,
<a name="l02436"></a>02436                                         &amp;tfid, lname, 1, 0, ldata);
<a name="l02437"></a>02437         } <span class="keywordflow">else</span> {
<a name="l02438"></a>02438                 rc = mdd_linkea_prepare(env, son, NULL, NULL,
<a name="l02439"></a>02439                                         mdd_object_fid(mdd_pobj),
<a name="l02440"></a>02440                                         lname, 1, 0, ldata);
<a name="l02441"></a>02441         }
<a name="l02442"></a>02442 
<a name="l02443"></a>02443         rc = mdd_declare_create(env, mdd, mdd_pobj, son, lname, attr,
<a name="l02444"></a>02444                                 handle, spec, ldata, &amp;def_acl_buf, &amp;acl_buf,
<a name="l02445"></a>02445                                 hint);
<a name="l02446"></a>02446         <span class="keywordflow">if</span> (rc)
<a name="l02447"></a>02447                 GOTO(out_stop, rc);
<a name="l02448"></a>02448 
<a name="l02449"></a>02449         rc = mdd_trans_start(env, mdd, handle);
<a name="l02450"></a>02450         <span class="keywordflow">if</span> (rc)
<a name="l02451"></a>02451                 GOTO(out_stop, rc);
<a name="l02452"></a>02452 
<a name="l02453"></a>02453         rc = mdd_object_create(env, mdd_pobj, son, attr, spec, &amp;acl_buf,
<a name="l02454"></a>02454                                &amp;def_acl_buf, hint, handle);
<a name="l02455"></a>02455         <span class="keywordflow">if</span> (rc != 0)
<a name="l02456"></a>02456                 GOTO(out_stop, rc);
<a name="l02457"></a>02457 
<a name="l02458"></a>02458         <span class="keywordflow">if</span> (unlikely(spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> &amp; MDS_OPEN_VOLATILE)) {
<a name="l02459"></a>02459                 mdd_write_lock(env, son, MOR_TGT_CHILD);
<a name="l02460"></a>02460                 rc = __mdd_orphan_add(env, son, handle);
<a name="l02461"></a>02461                 GOTO(out_volatile, rc);
<a name="l02462"></a>02462         } <span class="keywordflow">else</span> {
<a name="l02463"></a>02463                 rc = __mdd_index_insert(env, mdd_pobj, mdo2fid(son),
<a name="l02464"></a>02464                                         attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>, name, handle);
<a name="l02465"></a>02465                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02466"></a>02466                         GOTO(err_created, rc);
<a name="l02467"></a>02467 
<a name="l02468"></a>02468                 mdd_links_add(env, son, mdo2fid(mdd_pobj), lname, handle,
<a name="l02469"></a>02469                               ldata, 1);
<a name="l02470"></a>02470 
<a name="l02471"></a>02471                 <span class="comment">/* update parent directory mtime/ctime */</span>
<a name="l02472"></a>02472                 *la = *attr;
<a name="l02473"></a>02473                 la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MTIME;
<a name="l02474"></a>02474                 rc = mdd_update_time(env, mdd_pobj, pattr, la, handle);
<a name="l02475"></a>02475                 <span class="keywordflow">if</span> (rc)
<a name="l02476"></a>02476                         GOTO(err_insert, rc);
<a name="l02477"></a>02477         }
<a name="l02478"></a>02478 
<a name="l02479"></a>02479         EXIT;
<a name="l02480"></a>02480 err_insert:
<a name="l02481"></a>02481         <span class="keywordflow">if</span> (rc != 0) {
<a name="l02482"></a>02482                 <span class="keywordtype">int</span> rc2;
<a name="l02483"></a>02483 
<a name="l02484"></a>02484                 <span class="keywordflow">if</span> (spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> &amp; MDS_OPEN_VOLATILE)
<a name="l02485"></a>02485                         rc2 = __mdd_orphan_del(env, son, handle);
<a name="l02486"></a>02486                 <span class="keywordflow">else</span>
<a name="l02487"></a>02487                         rc2 = __mdd_index_delete(env, mdd_pobj, name,
<a name="l02488"></a>02488                                                  S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>),
<a name="l02489"></a>02489                                                  handle);
<a name="l02490"></a>02490                 <span class="keywordflow">if</span> (rc2 != 0)
<a name="l02491"></a>02491                         <span class="keywordflow">goto</span> out_stop;
<a name="l02492"></a>02492 
<a name="l02493"></a>02493 err_created:
<a name="l02494"></a>02494                 mdd_write_lock(env, son, MOR_TGT_CHILD);
<a name="l02495"></a>02495                 <span class="keywordflow">if</span> (S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l02496"></a>02496                         <span class="comment">/* Drop the reference, no need to delete &quot;.&quot;/&quot;..&quot;,</span>
<a name="l02497"></a>02497 <span class="comment">                         * because the object is to be destroyed directly. */</span>
<a name="l02498"></a>02498                         rc2 = mdo_ref_del(env, son, handle);
<a name="l02499"></a>02499                         <span class="keywordflow">if</span> (rc2 != 0) {
<a name="l02500"></a>02500                                 mdd_write_unlock(env, son);
<a name="l02501"></a>02501                                 <span class="keywordflow">goto</span> out_stop;
<a name="l02502"></a>02502                         }
<a name="l02503"></a>02503                 }
<a name="l02504"></a>02504 out_volatile:
<a name="l02505"></a>02505                 <span class="comment">/* For volatile files drop one link immediately, since there is</span>
<a name="l02506"></a>02506 <span class="comment">                 * no filename in the namespace, and save any error returned. */</span>
<a name="l02507"></a>02507                 rc2 = mdo_ref_del(env, son, handle);
<a name="l02508"></a>02508                 <span class="keywordflow">if</span> (rc2 != 0) {
<a name="l02509"></a>02509                         mdd_write_unlock(env, son);
<a name="l02510"></a>02510                         <span class="keywordflow">if</span> (unlikely(rc == 0))
<a name="l02511"></a>02511                                 rc = rc2;
<a name="l02512"></a>02512                         <span class="keywordflow">goto</span> out_stop;
<a name="l02513"></a>02513                 }
<a name="l02514"></a>02514 
<a name="l02515"></a>02515                 <span class="comment">/* Don&apos;t destroy the volatile object on success */</span>
<a name="l02516"></a>02516                 <span class="keywordflow">if</span> (likely(rc != 0))
<a name="l02517"></a>02517                         mdo_destroy(env, son, handle);
<a name="l02518"></a>02518                 mdd_write_unlock(env, son);
<a name="l02519"></a>02519         }
<a name="l02520"></a>02520 
<a name="l02521"></a>02521         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; fid_is_namespace_visible(mdo2fid(son)) &amp;&amp;
<a name="l02522"></a>02522             likely((spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> &amp; MDS_OPEN_VOLATILE) == 0))
<a name="l02523"></a>02523                 rc = mdd_changelog_ns_store(env, mdd,
<a name="l02524"></a>02524                                 S_ISDIR(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) ? CL_MKDIR :
<a name="l02525"></a>02525                                 S_ISREG(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) ? CL_CREATE :
<a name="l02526"></a>02526                                 S_ISLNK(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) ? CL_SOFTLINK : CL_MKNOD,
<a name="l02527"></a>02527                                 0, son, mdo2fid(mdd_pobj), NULL, NULL, lname,
<a name="l02528"></a>02528                                 NULL, handle);
<a name="l02529"></a>02529 out_stop:
<a name="l02530"></a>02530         rc2 = mdd_trans_stop(env, mdd, rc, handle);
<a name="l02531"></a>02531         <span class="keywordflow">if</span> (rc == 0) {
<a name="l02532"></a>02532                 <span class="comment">/* If creation fails, it is most likely due to the remote update</span>
<a name="l02533"></a>02533 <span class="comment">                 * failure, because local transaction will mostly succeed at</span>
<a name="l02534"></a>02534 <span class="comment">                 * this stage. There is no easy way to rollback all of previous</span>
<a name="l02535"></a>02535 <span class="comment">                 * updates, so let&apos;s remove the object from namespace, and</span>
<a name="l02536"></a>02536 <span class="comment">                 * LFSCK should handle the orphan object. */</span>
<a name="l02537"></a>02537                 <span class="keywordflow">if</span> (rc2 &lt; 0 &amp;&amp; !mdd_object_remote(mdd_pobj))
<a name="l02538"></a>02538                         mdd_index_delete(env, mdd_pobj, attr, lname);
<a name="l02539"></a>02539                 rc = rc2;
<a name="l02540"></a>02540         }
<a name="l02541"></a>02541 out_free:
<a name="l02542"></a>02542         <span class="keywordflow">if</span> (is_vmalloc_addr(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>))
<a name="l02543"></a>02543                 <span class="comment">/* if we vmalloced a large buffer drop it */</span>
<a name="l02544"></a>02544                 lu_buf_free(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>);
<a name="l02545"></a>02545 
<a name="l02546"></a>02546         <span class="comment">/* The child object shouldn&apos;t be cached anymore */</span>
<a name="l02547"></a>02547         <span class="keywordflow">if</span> (rc)
<a name="l02548"></a>02548                 set_bit(<a class="code" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985aca9a04f530d5436e7996a1ff142d01d0" title="Don&amp;#39;t keep this object in cache.">LU_OBJECT_HEARD_BANSHEE</a>,
<a name="l02549"></a>02549                         &amp;child-&gt;mo_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#a85952a1c723e48ffa0bb7024438ac08f" title="Object flags from enum lu_object_header_flags.">loh_flags</a>);
<a name="l02550"></a>02550         <span class="keywordflow">return</span> rc;
<a name="l02551"></a>02551 }
<a name="l02552"></a>02552 
<a name="l02553"></a>02553 <span class="comment">/*</span>
<a name="l02554"></a>02554 <span class="comment"> * Get locks on parents in proper order</span>
<a name="l02555"></a>02555 <span class="comment"> * RETURN: &lt; 0 - error, rename_order if successful</span>
<a name="l02556"></a>02556 <span class="comment"> */</span>
<a name="l02557"></a>02557 <span class="keyword">enum</span> rename_order {
<a name="l02558"></a>02558         MDD_RN_SAME,
<a name="l02559"></a>02559         MDD_RN_SRCTGT,
<a name="l02560"></a>02560         MDD_RN_TGTSRC
<a name="l02561"></a>02561 };
<a name="l02562"></a>02562 
<a name="l02563"></a>02563 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_rename_order(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02564"></a>02564                             <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l02565"></a>02565                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *src_pobj,
<a name="l02566"></a>02566                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr,
<a name="l02567"></a>02567                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *tgt_pobj)
<a name="l02568"></a>02568 {
<a name="l02569"></a>02569         <span class="comment">/* order of locking, 1 - tgt-src, 0 - src-tgt*/</span>
<a name="l02570"></a>02570         <span class="keywordtype">int</span> rc;
<a name="l02571"></a>02571         ENTRY;
<a name="l02572"></a>02572 
<a name="l02573"></a>02573         <span class="keywordflow">if</span> (src_pobj == tgt_pobj)
<a name="l02574"></a>02574                 RETURN(MDD_RN_SAME);
<a name="l02575"></a>02575 
<a name="l02576"></a>02576         <span class="comment">/* compared the parent child relationship of src_p&amp;tgt_p */</span>
<a name="l02577"></a>02577         <span class="keywordflow">if</span> (lu_fid_eq(&amp;mdd-&gt;mdd_root_fid, mdo2fid(src_pobj))){
<a name="l02578"></a>02578                 rc = MDD_RN_SRCTGT;
<a name="l02579"></a>02579         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lu_fid_eq(&amp;mdd-&gt;mdd_root_fid, mdo2fid(tgt_pobj))) {
<a name="l02580"></a>02580                 rc = MDD_RN_TGTSRC;
<a name="l02581"></a>02581         } <span class="keywordflow">else</span> {
<a name="l02582"></a>02582                 rc = mdd_is_parent(env, mdd, src_pobj, pattr, mdo2fid(tgt_pobj),
<a name="l02583"></a>02583                                    NULL);
<a name="l02584"></a>02584                 <span class="keywordflow">if</span> (rc == -EREMOTE)
<a name="l02585"></a>02585                         rc = 0;
<a name="l02586"></a>02586 
<a name="l02587"></a>02587                 <span class="keywordflow">if</span> (rc == 1)
<a name="l02588"></a>02588                         rc = MDD_RN_TGTSRC;
<a name="l02589"></a>02589                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 0)
<a name="l02590"></a>02590                         rc = MDD_RN_SRCTGT;
<a name="l02591"></a>02591         }
<a name="l02592"></a>02592 
<a name="l02593"></a>02593         RETURN(rc);
<a name="l02594"></a>02594 }
<a name="l02595"></a>02595 
<a name="l02596"></a>02596 <span class="comment">/* has not mdd_write{read}_lock on any obj yet. */</span>
<a name="l02597"></a>02597 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_rename_sanity_check(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02598"></a>02598                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *src_pobj,
<a name="l02599"></a>02599                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr,
<a name="l02600"></a>02600                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *tgt_pobj,
<a name="l02601"></a>02601                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *tpattr,
<a name="l02602"></a>02602                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *sobj,
<a name="l02603"></a>02603                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *cattr,
<a name="l02604"></a>02604                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *tobj,
<a name="l02605"></a>02605                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *tattr)
<a name="l02606"></a>02606 {
<a name="l02607"></a>02607         <span class="keywordtype">int</span> rc = 0;
<a name="l02608"></a>02608         ENTRY;
<a name="l02609"></a>02609 
<a name="l02610"></a>02610         <span class="comment">/* XXX: when get here, sobj must NOT be NULL,</span>
<a name="l02611"></a>02611 <span class="comment">         * the other case has been processed in cld_rename</span>
<a name="l02612"></a>02612 <span class="comment">         * before mdd_rename and enable MDS_PERM_BYPASS. */</span>
<a name="l02613"></a>02613         LASSERT(sobj);
<a name="l02614"></a>02614 
<a name="l02615"></a>02615         rc = mdd_may_delete(env, src_pobj, pattr, sobj, cattr, NULL, 1, 0);
<a name="l02616"></a>02616         <span class="keywordflow">if</span> (rc)
<a name="l02617"></a>02617                 RETURN(rc);
<a name="l02618"></a>02618 
<a name="l02619"></a>02619         <span class="comment">/* XXX: when get here, &quot;tobj == NULL&quot; means tobj must</span>
<a name="l02620"></a>02620 <span class="comment">         * NOT exist (neither on remote MDS, such case has been</span>
<a name="l02621"></a>02621 <span class="comment">         * processed in cld_rename before mdd_rename and enable</span>
<a name="l02622"></a>02622 <span class="comment">         * MDS_PERM_BYPASS).</span>
<a name="l02623"></a>02623 <span class="comment">         * So check may_create, but not check may_unlink. */</span>
<a name="l02624"></a>02624         <span class="keywordflow">if</span> (tobj == NULL)
<a name="l02625"></a>02625                 rc = mdd_may_create(env, tgt_pobj, tpattr, NULL,
<a name="l02626"></a>02626                                     (src_pobj != tgt_pobj));
<a name="l02627"></a>02627         <span class="keywordflow">else</span>
<a name="l02628"></a>02628                 rc = mdd_may_delete(env, tgt_pobj, tpattr, tobj, tattr, cattr,
<a name="l02629"></a>02629                                     (src_pobj != tgt_pobj), 1);
<a name="l02630"></a>02630 
<a name="l02631"></a>02631         <span class="keywordflow">if</span> (!rc &amp;&amp; !tobj &amp;&amp; (src_pobj != tgt_pobj) &amp;&amp; S_ISDIR(cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>))
<a name="l02632"></a>02632                 rc = __mdd_may_link(env, tgt_pobj, tpattr);
<a name="l02633"></a>02633 
<a name="l02634"></a>02634         RETURN(rc);
<a name="l02635"></a>02635 }
<a name="l02636"></a>02636 
<a name="l02637"></a>02637 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_rename(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02638"></a>02638                               <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l02639"></a>02639                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_spobj,
<a name="l02640"></a>02640                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tpobj,
<a name="l02641"></a>02641                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l02642"></a>02642                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj,
<a name="l02643"></a>02643                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *sname,
<a name="l02644"></a>02644                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *tname,
<a name="l02645"></a>02645                               <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma,
<a name="l02646"></a>02646                               <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l02647"></a>02647                               <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l02648"></a>02648 {
<a name="l02649"></a>02649         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>    *la = &amp;mdd_env_info(env)-&gt;<a class="code" href="structmdd__thread__info.html#a6a4ecb9102dadba2b066f90bd6532268" title="used to set c/mtime">mti_la_for_fix</a>;
<a name="l02650"></a>02650         <span class="keywordtype">int</span> rc;
<a name="l02651"></a>02651 
<a name="l02652"></a>02652         LASSERT(ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; LA_CTIME);
<a name="l02653"></a>02653         la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = la-&gt;<a class="code" href="structlu__attr.html#a3c9ac90caf353fc11ed871645d4ab1f5" title="modification time in seconds since Epoch">la_mtime</a> = ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a>;
<a name="l02654"></a>02654 
<a name="l02655"></a>02655         LASSERT(mdd_spobj);
<a name="l02656"></a>02656         LASSERT(mdd_tpobj);
<a name="l02657"></a>02657         LASSERT(mdd_sobj);
<a name="l02658"></a>02658 
<a name="l02659"></a>02659         <span class="comment">/* name from source dir */</span>
<a name="l02660"></a>02660         rc = mdo_declare_index_delete(env, mdd_spobj, sname-&gt;ln_name, handle);
<a name="l02661"></a>02661         <span class="keywordflow">if</span> (rc)
<a name="l02662"></a>02662                 <span class="keywordflow">return</span> rc;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664         <span class="comment">/* .. from source child */</span>
<a name="l02665"></a>02665         <span class="keywordflow">if</span> (S_ISDIR(mdd_object_type(mdd_sobj))) {
<a name="l02666"></a>02666                 <span class="comment">/* source child can be directory,</span>
<a name="l02667"></a>02667 <span class="comment">                 * counted by source dir&apos;s nlink */</span>
<a name="l02668"></a>02668                 rc = mdo_declare_ref_del(env, mdd_spobj, handle);
<a name="l02669"></a>02669                 <span class="keywordflow">if</span> (rc)
<a name="l02670"></a>02670                         <span class="keywordflow">return</span> rc;
<a name="l02671"></a>02671                 <span class="keywordflow">if</span> (mdd_spobj != mdd_tpobj) {
<a name="l02672"></a>02672                         rc = mdo_declare_index_delete(env, mdd_sobj, dotdot,
<a name="l02673"></a>02673                                                       handle);
<a name="l02674"></a>02674                         <span class="keywordflow">if</span> (rc != 0)
<a name="l02675"></a>02675                                 <span class="keywordflow">return</span> rc;
<a name="l02676"></a>02676 
<a name="l02677"></a>02677                         rc = mdo_declare_index_insert(env, mdd_sobj,
<a name="l02678"></a>02678                                                       mdo2fid(mdd_tpobj),
<a name="l02679"></a>02679                                                       S_IFDIR, dotdot, handle);
<a name="l02680"></a>02680                         <span class="keywordflow">if</span> (rc != 0)
<a name="l02681"></a>02681                                 <span class="keywordflow">return</span> rc;
<a name="l02682"></a>02682                 }
<a name="l02683"></a>02683 
<a name="l02684"></a>02684                 <span class="comment">/* new target child can be directory,</span>
<a name="l02685"></a>02685 <span class="comment">                 * counted by target dir&apos;s nlink */</span>
<a name="l02686"></a>02686                 rc = mdo_declare_ref_add(env, mdd_tpobj, handle);
<a name="l02687"></a>02687                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02688"></a>02688                         <span class="keywordflow">return</span> rc;
<a name="l02689"></a>02689         }
<a name="l02690"></a>02690 
<a name="l02691"></a>02691         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MTIME;
<a name="l02692"></a>02692         rc = mdo_declare_attr_set(env, mdd_spobj, la, handle);
<a name="l02693"></a>02693         <span class="keywordflow">if</span> (rc != 0)
<a name="l02694"></a>02694                 <span class="keywordflow">return</span> rc;
<a name="l02695"></a>02695 
<a name="l02696"></a>02696         rc = mdo_declare_attr_set(env, mdd_tpobj, la, handle);
<a name="l02697"></a>02697         <span class="keywordflow">if</span> (rc != 0)
<a name="l02698"></a>02698                 <span class="keywordflow">return</span> rc;
<a name="l02699"></a>02699 
<a name="l02700"></a>02700         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l02701"></a>02701         rc = mdo_declare_attr_set(env, mdd_sobj, la, handle);
<a name="l02702"></a>02702         <span class="keywordflow">if</span> (rc)
<a name="l02703"></a>02703                 <span class="keywordflow">return</span> rc;
<a name="l02704"></a>02704 
<a name="l02705"></a>02705         rc = mdd_declare_links_add(env, mdd_sobj, handle, ldata,
<a name="l02706"></a>02706                 S_ISREG(mdd_object_type(mdd_sobj)) ? MLAO_CHECK : MLAO_IGNORE);
<a name="l02707"></a>02707         <span class="keywordflow">if</span> (rc)
<a name="l02708"></a>02708                 <span class="keywordflow">return</span> rc;
<a name="l02709"></a>02709 
<a name="l02710"></a>02710         <span class="comment">/* new name */</span>
<a name="l02711"></a>02711         rc = mdo_declare_index_insert(env, mdd_tpobj, mdo2fid(mdd_sobj),
<a name="l02712"></a>02712                                       mdd_object_type(mdd_sobj),
<a name="l02713"></a>02713                                       tname-&gt;ln_name, handle);
<a name="l02714"></a>02714         <span class="keywordflow">if</span> (rc != 0)
<a name="l02715"></a>02715                 <span class="keywordflow">return</span> rc;
<a name="l02716"></a>02716 
<a name="l02717"></a>02717         <span class="keywordflow">if</span> (mdd_tobj &amp;&amp; mdd_object_exists(mdd_tobj)) {
<a name="l02718"></a>02718                 <span class="comment">/* delete target child in target parent directory */</span>
<a name="l02719"></a>02719                 rc = mdo_declare_index_delete(env, mdd_tpobj, tname-&gt;ln_name,
<a name="l02720"></a>02720                                               handle);
<a name="l02721"></a>02721                 <span class="keywordflow">if</span> (rc)
<a name="l02722"></a>02722                         <span class="keywordflow">return</span> rc;
<a name="l02723"></a>02723 
<a name="l02724"></a>02724                 rc = mdo_declare_ref_del(env, mdd_tobj, handle);
<a name="l02725"></a>02725                 <span class="keywordflow">if</span> (rc)
<a name="l02726"></a>02726                         <span class="keywordflow">return</span> rc;
<a name="l02727"></a>02727 
<a name="l02728"></a>02728                 <span class="keywordflow">if</span> (S_ISDIR(mdd_object_type(mdd_tobj))) {
<a name="l02729"></a>02729                         <span class="comment">/* target child can be directory,</span>
<a name="l02730"></a>02730 <span class="comment">                         * delete &quot;.&quot; reference in target child directory */</span>
<a name="l02731"></a>02731                         rc = mdo_declare_ref_del(env, mdd_tobj, handle);
<a name="l02732"></a>02732                         <span class="keywordflow">if</span> (rc)
<a name="l02733"></a>02733                                 <span class="keywordflow">return</span> rc;
<a name="l02734"></a>02734 
<a name="l02735"></a>02735                         <span class="comment">/* delete &quot;..&quot; reference in target parent directory */</span>
<a name="l02736"></a>02736                         rc = mdo_declare_ref_del(env, mdd_tpobj, handle);
<a name="l02737"></a>02737                         <span class="keywordflow">if</span> (rc)
<a name="l02738"></a>02738                                 <span class="keywordflow">return</span> rc;
<a name="l02739"></a>02739                 }
<a name="l02740"></a>02740 
<a name="l02741"></a>02741                 la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l02742"></a>02742                 rc = mdo_declare_attr_set(env, mdd_tobj, la, handle);
<a name="l02743"></a>02743                 <span class="keywordflow">if</span> (rc)
<a name="l02744"></a>02744                         <span class="keywordflow">return</span> rc;
<a name="l02745"></a>02745 
<a name="l02746"></a>02746                 rc = mdd_declare_finish_unlink(env, mdd_tobj, handle);
<a name="l02747"></a>02747                 <span class="keywordflow">if</span> (rc)
<a name="l02748"></a>02748                         <span class="keywordflow">return</span> rc;
<a name="l02749"></a>02749         }
<a name="l02750"></a>02750 
<a name="l02751"></a>02751         rc = mdd_declare_changelog_store(env, mdd, tname, sname, handle);
<a name="l02752"></a>02752         <span class="keywordflow">if</span> (rc)
<a name="l02753"></a>02753                 <span class="keywordflow">return</span> rc;
<a name="l02754"></a>02754 
<a name="l02755"></a>02755         <span class="keywordflow">return</span> rc;
<a name="l02756"></a>02756 }
<a name="l02757"></a>02757 
<a name="l02758"></a>02758 <span class="comment">/* src object can be remote that is why we use only fid and type of object */</span>
<a name="l02759"></a>02759 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_rename(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02760"></a>02760                       <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *src_pobj, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *tgt_pobj,
<a name="l02761"></a>02761                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *lf, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lsname,
<a name="l02762"></a>02762                       <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *tobj, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *ltname,
<a name="l02763"></a>02763                       <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l02764"></a>02764 {
<a name="l02765"></a>02765         <span class="keyword">const</span> <span class="keywordtype">char</span> *sname = lsname-&gt;ln_name;
<a name="l02766"></a>02766         <span class="keyword">const</span> <span class="keywordtype">char</span> *tname = ltname-&gt;ln_name;
<a name="l02767"></a>02767         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>    *la = &amp;mdd_env_info(env)-&gt;<a class="code" href="structmdd__thread__info.html#a6a4ecb9102dadba2b066f90bd6532268" title="used to set c/mtime">mti_la_for_fix</a>;
<a name="l02768"></a>02768         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_spobj = md2mdd_obj(src_pobj); <span class="comment">/* source parent */</span>
<a name="l02769"></a>02769         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tpobj = md2mdd_obj(tgt_pobj);
<a name="l02770"></a>02770         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(src_pobj);
<a name="l02771"></a>02771         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj = NULL;                  <span class="comment">/* source object */</span>
<a name="l02772"></a>02772         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj = NULL;
<a name="l02773"></a>02773         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *cattr = MDD_ENV_VAR(env, cattr);
<a name="l02774"></a>02774         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr = MDD_ENV_VAR(env, pattr);
<a name="l02775"></a>02775         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *tattr = MDD_ENV_VAR(env, tattr);
<a name="l02776"></a>02776         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *tpattr = MDD_ENV_VAR(env, tpattr);
<a name="l02777"></a>02777         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle;
<a name="l02778"></a>02778         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>  *ldata = &amp;mdd_env_info(env)-&gt;mti_link_data;
<a name="l02779"></a>02779         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *tpobj_fid = mdo2fid(mdd_tpobj);
<a name="l02780"></a>02780         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *spobj_fid = mdo2fid(mdd_spobj);
<a name="l02781"></a>02781         <span class="keywordtype">bool</span> is_dir;
<a name="l02782"></a>02782         <span class="keywordtype">bool</span> tobj_ref = 0;
<a name="l02783"></a>02783         <span class="keywordtype">bool</span> tobj_locked = 0;
<a name="l02784"></a>02784         <span class="keywordtype">unsigned</span> cl_flags = 0;
<a name="l02785"></a>02785         <span class="keywordtype">int</span> rc, rc2;
<a name="l02786"></a>02786         ENTRY;
<a name="l02787"></a>02787 
<a name="l02788"></a>02788         <span class="keywordflow">if</span> (tobj)
<a name="l02789"></a>02789                 mdd_tobj = md2mdd_obj(tobj);
<a name="l02790"></a>02790 
<a name="l02791"></a>02791         mdd_sobj = mdd_object_find(env, mdd, lf);
<a name="l02792"></a>02792         <span class="keywordflow">if</span> (IS_ERR(mdd_sobj))
<a name="l02793"></a>02793                 RETURN(PTR_ERR(mdd_sobj));
<a name="l02794"></a>02794 
<a name="l02795"></a>02795         rc = mdd_la_get(env, mdd_sobj, cattr);
<a name="l02796"></a>02796         <span class="keywordflow">if</span> (rc)
<a name="l02797"></a>02797                 GOTO(out_pending, rc);
<a name="l02798"></a>02798 
<a name="l02799"></a>02799         rc = mdd_la_get(env, mdd_spobj, pattr);
<a name="l02800"></a>02800         <span class="keywordflow">if</span> (rc)
<a name="l02801"></a>02801                 GOTO(out_pending, rc);
<a name="l02802"></a>02802 
<a name="l02803"></a>02803         <span class="keywordflow">if</span> (mdd_tobj) {
<a name="l02804"></a>02804                 rc = mdd_la_get(env, mdd_tobj, tattr);
<a name="l02805"></a>02805                 <span class="keywordflow">if</span> (rc)
<a name="l02806"></a>02806                         GOTO(out_pending, rc);
<a name="l02807"></a>02807                 <span class="comment">/* search for an existing archive.</span>
<a name="l02808"></a>02808 <span class="comment">                 * we should check ahead as the object</span>
<a name="l02809"></a>02809 <span class="comment">                 * can be destroyed in this transaction */</span>
<a name="l02810"></a>02810                 <span class="keywordflow">if</span> (mdd_hsm_archive_exists(env, mdd_tobj, ma))
<a name="l02811"></a>02811                         cl_flags |= CLF_RENAME_LAST_EXISTS;
<a name="l02812"></a>02812         }
<a name="l02813"></a>02813 
<a name="l02814"></a>02814         rc = mdd_la_get(env, mdd_tpobj, tpattr);
<a name="l02815"></a>02815         <span class="keywordflow">if</span> (rc)
<a name="l02816"></a>02816                 GOTO(out_pending, rc);
<a name="l02817"></a>02817 
<a name="l02818"></a>02818         rc = mdd_rename_sanity_check(env, mdd_spobj, pattr, mdd_tpobj, tpattr,
<a name="l02819"></a>02819                                      mdd_sobj, cattr, mdd_tobj, tattr);
<a name="l02820"></a>02820         <span class="keywordflow">if</span> (rc)
<a name="l02821"></a>02821                 GOTO(out_pending, rc);
<a name="l02822"></a>02822 
<a name="l02823"></a>02823         rc = mdd_name_check(mdd, ltname);
<a name="l02824"></a>02824         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02825"></a>02825                 GOTO(out_pending, rc);
<a name="l02826"></a>02826 
<a name="l02827"></a>02827         <span class="comment">/* FIXME: Should consider tobj and sobj too in rename_lock. */</span>
<a name="l02828"></a>02828         rc = mdd_rename_order(env, mdd, mdd_spobj, pattr, mdd_tpobj);
<a name="l02829"></a>02829         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02830"></a>02830                 GOTO(out_pending, rc);
<a name="l02831"></a>02831 
<a name="l02832"></a>02832         handle = mdd_trans_create(env, mdd);
<a name="l02833"></a>02833         <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l02834"></a>02834                 GOTO(out_pending, rc = PTR_ERR(handle));
<a name="l02835"></a>02835 
<a name="l02836"></a>02836         memset(ldata, 0, <span class="keyword">sizeof</span>(*ldata));
<a name="l02837"></a>02837         mdd_linkea_prepare(env, mdd_sobj, mdd_object_fid(mdd_spobj), lsname,
<a name="l02838"></a>02838                            mdd_object_fid(mdd_tpobj), ltname, 1, 0, ldata);
<a name="l02839"></a>02839         rc = mdd_declare_rename(env, mdd, mdd_spobj, mdd_tpobj, mdd_sobj,
<a name="l02840"></a>02840                                 mdd_tobj, lsname, ltname, ma, ldata, handle);
<a name="l02841"></a>02841         <span class="keywordflow">if</span> (rc)
<a name="l02842"></a>02842                 GOTO(stop, rc);
<a name="l02843"></a>02843 
<a name="l02844"></a>02844         rc = mdd_trans_start(env, mdd, handle);
<a name="l02845"></a>02845         <span class="keywordflow">if</span> (rc)
<a name="l02846"></a>02846                 GOTO(stop, rc);
<a name="l02847"></a>02847 
<a name="l02848"></a>02848         is_dir = S_ISDIR(cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>);
<a name="l02849"></a>02849 
<a name="l02850"></a>02850         <span class="comment">/* Remove source name from source directory */</span>
<a name="l02851"></a>02851         rc = __mdd_index_delete(env, mdd_spobj, sname, is_dir, handle);
<a name="l02852"></a>02852         <span class="keywordflow">if</span> (rc != 0)
<a name="l02853"></a>02853                 GOTO(stop, rc);
<a name="l02854"></a>02854 
<a name="l02855"></a>02855         <span class="comment">/* &quot;mv dir1 dir2&quot; needs &quot;dir1/..&quot; link update */</span>
<a name="l02856"></a>02856         <span class="keywordflow">if</span> (is_dir &amp;&amp; !lu_fid_eq(spobj_fid, tpobj_fid)) {
<a name="l02857"></a>02857                 rc = __mdd_index_delete_only(env, mdd_sobj, dotdot, handle);
<a name="l02858"></a>02858                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02859"></a>02859                         GOTO(fixup_spobj2, rc);
<a name="l02860"></a>02860 
<a name="l02861"></a>02861                 rc = __mdd_index_insert_only(env, mdd_sobj, tpobj_fid, S_IFDIR,
<a name="l02862"></a>02862                                              dotdot, handle);
<a name="l02863"></a>02863                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02864"></a>02864                         GOTO(fixup_spobj, rc);
<a name="l02865"></a>02865         }
<a name="l02866"></a>02866 
<a name="l02867"></a>02867         <span class="keywordflow">if</span> (mdd_tobj != NULL &amp;&amp; mdd_object_exists(mdd_tobj)) {
<a name="l02868"></a>02868                 rc = __mdd_index_delete(env, mdd_tpobj, tname, is_dir, handle);
<a name="l02869"></a>02869                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02870"></a>02870                         <span class="comment">/* tname might been renamed to something else */</span>
<a name="l02871"></a>02871                         GOTO(fixup_spobj, rc);
<a name="l02872"></a>02872         }
<a name="l02873"></a>02873 
<a name="l02874"></a>02874         <span class="comment">/* Insert new fid with target name into target dir */</span>
<a name="l02875"></a>02875         rc = __mdd_index_insert(env, mdd_tpobj, lf, cattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>,
<a name="l02876"></a>02876                                 tname, handle);
<a name="l02877"></a>02877         <span class="keywordflow">if</span> (rc != 0)
<a name="l02878"></a>02878                 GOTO(fixup_tpobj, rc);
<a name="l02879"></a>02879 
<a name="l02880"></a>02880         LASSERT(ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; LA_CTIME);
<a name="l02881"></a>02881         la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = la-&gt;<a class="code" href="structlu__attr.html#a3c9ac90caf353fc11ed871645d4ab1f5" title="modification time in seconds since Epoch">la_mtime</a> = ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a>;
<a name="l02882"></a>02882 
<a name="l02883"></a>02883         <span class="comment">/* XXX: mdd_sobj must be local one if it is NOT NULL. */</span>
<a name="l02884"></a>02884         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l02885"></a>02885         rc = mdd_update_time(env, mdd_sobj, cattr, la, handle);
<a name="l02886"></a>02886         <span class="keywordflow">if</span> (rc)
<a name="l02887"></a>02887                 GOTO(fixup_tpobj, rc);
<a name="l02888"></a>02888 
<a name="l02889"></a>02889         <span class="comment">/* Update the linkEA for the source object */</span>
<a name="l02890"></a>02890         mdd_write_lock(env, mdd_sobj, MOR_SRC_CHILD);
<a name="l02891"></a>02891         rc = mdd_links_rename(env, mdd_sobj, mdo2fid(mdd_spobj), lsname,
<a name="l02892"></a>02892                               mdo2fid(mdd_tpobj), ltname, handle, ldata,
<a name="l02893"></a>02893                               0, 0);
<a name="l02894"></a>02894         <span class="keywordflow">if</span> (rc == -ENOENT)
<a name="l02895"></a>02895                 <span class="comment">/* Old files might not have EA entry */</span>
<a name="l02896"></a>02896                 mdd_links_add(env, mdd_sobj, mdo2fid(mdd_spobj),
<a name="l02897"></a>02897                               lsname, handle, NULL, 0);
<a name="l02898"></a>02898         mdd_write_unlock(env, mdd_sobj);
<a name="l02899"></a>02899         <span class="comment">/* We don&apos;t fail the transaction if the link ea can&apos;t be</span>
<a name="l02900"></a>02900 <span class="comment">           updated -- fid2path will use alternate lookup method. */</span>
<a name="l02901"></a>02901         rc = 0;
<a name="l02902"></a>02902 
<a name="l02903"></a>02903         <span class="comment">/* Remove old target object</span>
<a name="l02904"></a>02904 <span class="comment">         * For tobj is remote case cmm layer has processed</span>
<a name="l02905"></a>02905 <span class="comment">         * and set tobj to NULL then. So when tobj is NOT NULL,</span>
<a name="l02906"></a>02906 <span class="comment">         * it must be local one.</span>
<a name="l02907"></a>02907 <span class="comment">         */</span>
<a name="l02908"></a>02908         <span class="keywordflow">if</span> (tobj &amp;&amp; mdd_object_exists(mdd_tobj)) {
<a name="l02909"></a>02909                 mdd_write_lock(env, mdd_tobj, MOR_TGT_CHILD);
<a name="l02910"></a>02910                 tobj_locked = 1;
<a name="l02911"></a>02911                 <span class="keywordflow">if</span> (mdd_is_dead_obj(mdd_tobj)) {
<a name="l02912"></a>02912                         <span class="comment">/* shld not be dead, something is wrong */</span>
<a name="l02913"></a>02913                         CERROR(<span class="stringliteral">&quot;tobj is dead, something is wrong\n&quot;</span>);
<a name="l02914"></a>02914                         rc = -EINVAL;
<a name="l02915"></a>02915                         <span class="keywordflow">goto</span> cleanup;
<a name="l02916"></a>02916                 }
<a name="l02917"></a>02917                 mdo_ref_del(env, mdd_tobj, handle);
<a name="l02918"></a>02918 
<a name="l02919"></a>02919                 <span class="comment">/* Remove dot reference. */</span>
<a name="l02920"></a>02920                 <span class="keywordflow">if</span> (S_ISDIR(tattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>))
<a name="l02921"></a>02921                         mdo_ref_del(env, mdd_tobj, handle);
<a name="l02922"></a>02922                 tobj_ref = 1;
<a name="l02923"></a>02923 
<a name="l02924"></a>02924                 <span class="comment">/* fetch updated nlink */</span>
<a name="l02925"></a>02925                 rc = mdd_la_get(env, mdd_tobj, tattr);
<a name="l02926"></a>02926                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l02927"></a>02927                         CERROR(<span class="stringliteral">&quot;%s: Failed to get nlink for tobj &quot;</span>
<a name="l02928"></a>02928                                 DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l02929"></a>02929                                 mdd2obd_dev(mdd)-&gt;obd_name,
<a name="l02930"></a>02930                                 PFID(tpobj_fid), rc);
<a name="l02931"></a>02931                         GOTO(fixup_tpobj, rc);
<a name="l02932"></a>02932                 }
<a name="l02933"></a>02933 
<a name="l02934"></a>02934                 la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l02935"></a>02935                 rc = mdd_update_time(env, mdd_tobj, tattr, la, handle);
<a name="l02936"></a>02936                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l02937"></a>02937                         CERROR(<span class="stringliteral">&quot;%s: Failed to set ctime for tobj &quot;</span>
<a name="l02938"></a>02938                                 DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l02939"></a>02939                                 mdd2obd_dev(mdd)-&gt;obd_name,
<a name="l02940"></a>02940                                 PFID(tpobj_fid), rc);
<a name="l02941"></a>02941                         GOTO(fixup_tpobj, rc);
<a name="l02942"></a>02942                 }
<a name="l02943"></a>02943 
<a name="l02944"></a>02944                 <span class="comment">/* XXX: this transfer to ma will be removed with LOD/OSP */</span>
<a name="l02945"></a>02945                 ma-&gt;ma_attr = *tattr;
<a name="l02946"></a>02946                 ma-&gt;ma_valid |= MA_INODE;
<a name="l02947"></a>02947                 rc = mdd_finish_unlink(env, mdd_tobj, ma, mdd_tpobj, ltname,
<a name="l02948"></a>02948                                        handle);
<a name="l02949"></a>02949                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l02950"></a>02950                         CERROR(<span class="stringliteral">&quot;%s: Failed to unlink tobj &quot;</span>
<a name="l02951"></a>02951                                 DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l02952"></a>02952                                 mdd2obd_dev(mdd)-&gt;obd_name,
<a name="l02953"></a>02953                                 PFID(tpobj_fid), rc);
<a name="l02954"></a>02954                         GOTO(fixup_tpobj, rc);
<a name="l02955"></a>02955                 }
<a name="l02956"></a>02956 
<a name="l02957"></a>02957                 <span class="comment">/* fetch updated nlink */</span>
<a name="l02958"></a>02958                 rc = mdd_la_get(env, mdd_tobj, tattr);
<a name="l02959"></a>02959                 <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l02960"></a>02960                         <span class="comment">/* the object got removed, let&apos;s</span>
<a name="l02961"></a>02961 <span class="comment">                         * return the latest known attributes */</span>
<a name="l02962"></a>02962                         tattr-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> = 0;
<a name="l02963"></a>02963                         rc = 0;
<a name="l02964"></a>02964                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != 0) {
<a name="l02965"></a>02965                         CERROR(<span class="stringliteral">&quot;%s: Failed to get nlink for tobj &quot;</span>
<a name="l02966"></a>02966                                 DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l02967"></a>02967                                 mdd2obd_dev(mdd)-&gt;obd_name,
<a name="l02968"></a>02968                                 PFID(tpobj_fid), rc);
<a name="l02969"></a>02969                         GOTO(fixup_tpobj, rc);
<a name="l02970"></a>02970                 }
<a name="l02971"></a>02971                 <span class="comment">/* XXX: this transfer to ma will be removed with LOD/OSP */</span>
<a name="l02972"></a>02972                 ma-&gt;ma_attr = *tattr;
<a name="l02973"></a>02973                 ma-&gt;ma_valid |= MA_INODE;
<a name="l02974"></a>02974 
<a name="l02975"></a>02975                 <span class="keywordflow">if</span> (tattr-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> == 0)
<a name="l02976"></a>02976                         cl_flags |= CLF_RENAME_LAST;
<a name="l02977"></a>02977                 <span class="keywordflow">else</span>
<a name="l02978"></a>02978                         cl_flags &amp;= ~CLF_RENAME_LAST_EXISTS;
<a name="l02979"></a>02979         }
<a name="l02980"></a>02980 
<a name="l02981"></a>02981         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MTIME;
<a name="l02982"></a>02982         rc = mdd_update_time(env, mdd_spobj, pattr, la, handle);
<a name="l02983"></a>02983         <span class="keywordflow">if</span> (rc)
<a name="l02984"></a>02984                 GOTO(fixup_tpobj, rc);
<a name="l02985"></a>02985 
<a name="l02986"></a>02986         <span class="keywordflow">if</span> (mdd_spobj != mdd_tpobj) {
<a name="l02987"></a>02987                 la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MTIME;
<a name="l02988"></a>02988                 rc = mdd_update_time(env, mdd_tpobj, tpattr, la, handle);
<a name="l02989"></a>02989                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02990"></a>02990                         GOTO(fixup_tpobj, rc);
<a name="l02991"></a>02991         }
<a name="l02992"></a>02992 
<a name="l02993"></a>02993         EXIT;
<a name="l02994"></a>02994 
<a name="l02995"></a>02995 fixup_tpobj:
<a name="l02996"></a>02996         <span class="keywordflow">if</span> (rc) {
<a name="l02997"></a>02997                 rc2 = __mdd_index_delete(env, mdd_tpobj, tname, is_dir, handle);
<a name="l02998"></a>02998                 <span class="keywordflow">if</span> (rc2)
<a name="l02999"></a>02999                         CWARN(<span class="stringliteral">&quot;tp obj fix error %d\n&quot;</span>,rc2);
<a name="l03000"></a>03000 
<a name="l03001"></a>03001                 <span class="keywordflow">if</span> (mdd_tobj &amp;&amp; mdd_object_exists(mdd_tobj) &amp;&amp;
<a name="l03002"></a>03002                     !mdd_is_dead_obj(mdd_tobj)) {
<a name="l03003"></a>03003                         <span class="keywordflow">if</span> (tobj_ref) {
<a name="l03004"></a>03004                                 mdo_ref_add(env, mdd_tobj, handle);
<a name="l03005"></a>03005                                 <span class="keywordflow">if</span> (is_dir)
<a name="l03006"></a>03006                                         mdo_ref_add(env, mdd_tobj, handle);
<a name="l03007"></a>03007                         }
<a name="l03008"></a>03008 
<a name="l03009"></a>03009                         rc2 = __mdd_index_insert(env, mdd_tpobj,
<a name="l03010"></a>03010                                                   mdo2fid(mdd_tobj),
<a name="l03011"></a>03011                                                   mdd_object_type(mdd_tobj),
<a name="l03012"></a>03012                                                   tname, handle);
<a name="l03013"></a>03013                         <span class="keywordflow">if</span> (rc2 != 0)
<a name="l03014"></a>03014                                 CWARN(<span class="stringliteral">&quot;tp obj fix error: rc = %d\n&quot;</span>, rc2);
<a name="l03015"></a>03015                 }
<a name="l03016"></a>03016         }
<a name="l03017"></a>03017 
<a name="l03018"></a>03018 fixup_spobj:
<a name="l03019"></a>03019         <span class="keywordflow">if</span> (rc &amp;&amp; is_dir &amp;&amp; mdd_sobj &amp;&amp; mdd_spobj != mdd_tpobj) {
<a name="l03020"></a>03020                 rc2 = __mdd_index_delete_only(env, mdd_sobj, dotdot, handle);
<a name="l03021"></a>03021                 <span class="keywordflow">if</span> (rc2)
<a name="l03022"></a>03022                         CWARN(<span class="stringliteral">&quot;%s: sp obj dotdot delete error: rc = %d\n&quot;</span>,
<a name="l03023"></a>03023                                mdd2obd_dev(mdd)-&gt;obd_name, rc2);
<a name="l03024"></a>03024 
<a name="l03025"></a>03025 
<a name="l03026"></a>03026                 rc2 = __mdd_index_insert_only(env, mdd_sobj, spobj_fid, S_IFDIR,
<a name="l03027"></a>03027                                               dotdot, handle);
<a name="l03028"></a>03028                 <span class="keywordflow">if</span> (rc2 != 0)
<a name="l03029"></a>03029                         CWARN(<span class="stringliteral">&quot;%s: sp obj dotdot insert error: rc = %d\n&quot;</span>,
<a name="l03030"></a>03030                               mdd2obd_dev(mdd)-&gt;obd_name, rc2);
<a name="l03031"></a>03031         }
<a name="l03032"></a>03032 
<a name="l03033"></a>03033 fixup_spobj2:
<a name="l03034"></a>03034         <span class="keywordflow">if</span> (rc != 0) {
<a name="l03035"></a>03035                 rc2 = __mdd_index_insert(env, mdd_spobj, lf,
<a name="l03036"></a>03036                                          mdd_object_type(mdd_sobj), sname,
<a name="l03037"></a>03037                                          handle);
<a name="l03038"></a>03038                 <span class="keywordflow">if</span> (rc2 != 0)
<a name="l03039"></a>03039                         CWARN(<span class="stringliteral">&quot;sp obj fix error: rc = %d\n&quot;</span>, rc2);
<a name="l03040"></a>03040         }
<a name="l03041"></a>03041 
<a name="l03042"></a>03042 cleanup:
<a name="l03043"></a>03043         <span class="keywordflow">if</span> (tobj_locked)
<a name="l03044"></a>03044                 mdd_write_unlock(env, mdd_tobj);
<a name="l03045"></a>03045 
<a name="l03046"></a>03046         <span class="keywordflow">if</span> (rc == 0)
<a name="l03047"></a>03047                 rc = mdd_changelog_ns_store(env, mdd, CL_RENAME, cl_flags,
<a name="l03048"></a>03048                                             mdd_tobj, tpobj_fid, lf, spobj_fid,
<a name="l03049"></a>03049                                             ltname, lsname, handle);
<a name="l03050"></a>03050 
<a name="l03051"></a>03051 stop:
<a name="l03052"></a>03052         mdd_trans_stop(env, mdd, rc, handle);
<a name="l03053"></a>03053 
<a name="l03054"></a>03054 out_pending:
<a name="l03055"></a>03055         mdd_object_put(env, mdd_sobj);
<a name="l03056"></a>03056         <span class="keywordflow">return</span> rc;
<a name="l03057"></a>03057 }
<a name="l03058"></a>03058 
<a name="l03063"></a>03063 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_linkea_update_child_internal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03064"></a>03064                                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *parent,
<a name="l03065"></a>03065                                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *newparent,
<a name="l03066"></a>03066                                             <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *child,
<a name="l03067"></a>03067                                             <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> namelen,
<a name="l03068"></a>03068                                             <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle,
<a name="l03069"></a>03069                                             <span class="keywordtype">bool</span> declare)
<a name="l03070"></a>03070 {
<a name="l03071"></a>03071         <span class="keyword">struct </span><a class="code" href="structmdd__thread__info.html">mdd_thread_info</a>  *info = mdd_env_info(env);
<a name="l03072"></a>03072         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>      ldata = { NULL };
<a name="l03073"></a>03073         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           *buf = &amp;info-&gt;mti_link_buf;
<a name="l03074"></a>03074         <span class="keywordtype">int</span>                     count;
<a name="l03075"></a>03075         <span class="keywordtype">int</span>                     rc = 0;
<a name="l03076"></a>03076 
<a name="l03077"></a>03077         ENTRY;
<a name="l03078"></a>03078 
<a name="l03079"></a>03079         buf = lu_buf_check_and_alloc(buf, PATH_MAX);
<a name="l03080"></a>03080         <span class="keywordflow">if</span> (buf-&gt;lb_buf == NULL)
<a name="l03081"></a>03081                 RETURN(-ENOMEM);
<a name="l03082"></a>03082 
<a name="l03083"></a>03083         ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> = buf;
<a name="l03084"></a>03084         rc = mdd_links_read(env, child, &amp;ldata);
<a name="l03085"></a>03085         <span class="keywordflow">if</span> (rc != 0) {
<a name="l03086"></a>03086                 <span class="keywordflow">if</span> (rc == -ENOENT || rc == -ENODATA)
<a name="l03087"></a>03087                         rc = 0;
<a name="l03088"></a>03088                 RETURN(rc);
<a name="l03089"></a>03089         }
<a name="l03090"></a>03090 
<a name="l03091"></a>03091         LASSERT(ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> != NULL);
<a name="l03092"></a>03092         ldata.ld_lee = (<span class="keyword">struct </span><a class="code" href="structlink__ea__entry.html" title="Hardlink data is name and parent fid.">link_ea_entry</a> *)(ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> + 1);
<a name="l03093"></a>03093         <span class="keywordflow">for</span> (count = 0; count &lt; ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount; count++) {
<a name="l03094"></a>03094                 <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(&amp;child-&gt;mod_obj);
<a name="l03095"></a>03095                 <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> lname;
<a name="l03096"></a>03096                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>  fid;
<a name="l03097"></a>03097 
<a name="l03098"></a>03098                 linkea_entry_unpack(ldata.ld_lee, &amp;ldata.ld_reclen,
<a name="l03099"></a>03099                                     &amp;lname, &amp;fid);
<a name="l03100"></a>03100 
<a name="l03101"></a>03101                 <span class="keywordflow">if</span> (strncmp(lname.ln_name, name, namelen) != 0 ||
<a name="l03102"></a>03102                     !lu_fid_eq(&amp;fid, mdd_object_fid(parent))) {
<a name="l03103"></a>03103                         ldata.ld_lee = (<span class="keyword">struct </span><a class="code" href="structlink__ea__entry.html" title="Hardlink data is name and parent fid.">link_ea_entry</a> *)
<a name="l03104"></a>03104                                        ((<span class="keywordtype">char</span> *)ldata.ld_lee +
<a name="l03105"></a>03105                                         ldata.ld_reclen);
<a name="l03106"></a>03106                         <span class="keywordflow">continue</span>;
<a name="l03107"></a>03107                 }
<a name="l03108"></a>03108 
<a name="l03109"></a>03109                 CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: update &quot;</span>DFID<span class="stringliteral">&quot; with %.*s:&quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l03110"></a>03110                        mdd2obd_dev(mdd)-&gt;obd_name, PFID(mdd_object_fid(child)),
<a name="l03111"></a>03111                        lname.ln_namelen, lname.ln_name,
<a name="l03112"></a>03112                        PFID(mdd_object_fid(newparent)));
<a name="l03113"></a>03113                 <span class="comment">/* update to the new parent fid */</span>
<a name="l03114"></a>03114                 linkea_entry_pack(ldata.ld_lee, &amp;lname,
<a name="l03115"></a>03115                                   mdd_object_fid(newparent));
<a name="l03116"></a>03116                 <span class="keywordflow">if</span> (declare)
<a name="l03117"></a>03117                         rc = mdd_declare_links_add(env, child, handle, &amp;ldata,
<a name="l03118"></a>03118                                                    MLAO_IGNORE);
<a name="l03119"></a>03119                 <span class="keywordflow">else</span>
<a name="l03120"></a>03120                         rc = mdd_links_write(env, child, &amp;ldata, handle);
<a name="l03121"></a>03121                 <span class="keywordflow">break</span>;
<a name="l03122"></a>03122         }
<a name="l03123"></a>03123         RETURN(rc);
<a name="l03124"></a>03124 }
<a name="l03125"></a>03125 
<a name="l03126"></a>03126 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_linkea_declare_update_child(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03127"></a>03127                                            <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *parent,
<a name="l03128"></a>03128                                            <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *newparent,
<a name="l03129"></a>03129                                            <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *child,
<a name="l03130"></a>03130                                            <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> namelen,
<a name="l03131"></a>03131                                            <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l03132"></a>03132 {
<a name="l03133"></a>03133         <span class="keywordflow">return</span> mdd_linkea_update_child_internal(env, parent, newparent,
<a name="l03134"></a>03134                                                 child, name,
<a name="l03135"></a>03135                                                 namelen, handle, <span class="keyword">true</span>);
<a name="l03136"></a>03136 }
<a name="l03137"></a>03137 
<a name="l03138"></a>03138 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_linkea_update_child(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03139"></a>03139                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *parent,
<a name="l03140"></a>03140                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *newparent,
<a name="l03141"></a>03141                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *child,
<a name="l03142"></a>03142                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> namelen,
<a name="l03143"></a>03143                                    <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l03144"></a>03144 {
<a name="l03145"></a>03145         <span class="keywordflow">return</span> mdd_linkea_update_child_internal(env, parent, newparent,
<a name="l03146"></a>03146                                                 child, name,
<a name="l03147"></a>03147                                                 namelen, handle, <span class="keyword">false</span>);
<a name="l03148"></a>03148 }
<a name="l03149"></a>03149 
<a name="l03150"></a>03150 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_update_linkea_internal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03151"></a>03151                                       <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj,
<a name="l03152"></a>03152                                       <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l03153"></a>03153                                       <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj,
<a name="l03154"></a>03154                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *child_name,
<a name="l03155"></a>03155                                       <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l03156"></a>03156                                       <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle,
<a name="l03157"></a>03157                                       <span class="keywordtype">int</span> declare)
<a name="l03158"></a>03158 {
<a name="l03159"></a>03159         <span class="keyword">struct </span><a class="code" href="structmdd__thread__info.html">mdd_thread_info</a>  *info = mdd_env_info(env);
<a name="l03160"></a>03160         <span class="keywordtype">int</span>                     count;
<a name="l03161"></a>03161         <span class="keywordtype">int</span>                     rc = 0;
<a name="l03162"></a>03162         ENTRY;
<a name="l03163"></a>03163 
<a name="l03164"></a>03164         LASSERT(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> != NULL);
<a name="l03165"></a>03165 
<a name="l03166"></a>03166 again:
<a name="l03167"></a>03167         <span class="comment">/* If it is mulitple links file, we need update the name entry for</span>
<a name="l03168"></a>03168 <span class="comment">         * all parent */</span>
<a name="l03169"></a>03169         LASSERT(ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> != NULL);
<a name="l03170"></a>03170         ldata-&gt;ld_lee = (<span class="keyword">struct </span><a class="code" href="structlink__ea__entry.html" title="Hardlink data is name and parent fid.">link_ea_entry</a> *)(ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> + 1);
<a name="l03171"></a>03171         <span class="keywordflow">for</span> (count = 0; count &lt; ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount; count++) {
<a name="l03172"></a>03172                 <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a>       *mdd = mdo2mdd(&amp;mdd_sobj-&gt;mod_obj);
<a name="l03173"></a>03173                 <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a>       *pobj;
<a name="l03174"></a>03174                 <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          lname;
<a name="l03175"></a>03175                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           fid;
<a name="l03176"></a>03176 
<a name="l03177"></a>03177                 linkea_entry_unpack(ldata-&gt;ld_lee, &amp;ldata-&gt;ld_reclen,
<a name="l03178"></a>03178                                     &amp;lname, &amp;fid);
<a name="l03179"></a>03179                 pobj = mdd_object_find(env, mdd, &amp;fid);
<a name="l03180"></a>03180                 <span class="keywordflow">if</span> (IS_ERR(pobj)) {
<a name="l03181"></a>03181                         CWARN(<span class="stringliteral">&quot;%s: cannot find obj &quot;</span>DFID<span class="stringliteral">&quot;: rc = %ld\n&quot;</span>,
<a name="l03182"></a>03182                               mdd2obd_dev(mdd)-&gt;obd_name, PFID(&amp;fid),
<a name="l03183"></a>03183                               PTR_ERR(pobj));
<a name="l03184"></a>03184                         linkea_del_buf(ldata, &amp;lname);
<a name="l03185"></a>03185                         <span class="keywordflow">goto</span> again;
<a name="l03186"></a>03186                 }
<a name="l03187"></a>03187 
<a name="l03188"></a>03188                 <span class="keywordflow">if</span> (!mdd_object_exists(pobj)) {
<a name="l03189"></a>03189                         CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: obj &quot;</span>DFID<span class="stringliteral">&quot; does not exist\n&quot;</span>,
<a name="l03190"></a>03190                               mdd2obd_dev(mdd)-&gt;obd_name, PFID(&amp;fid));
<a name="l03191"></a>03191                         linkea_del_buf(ldata, &amp;lname);
<a name="l03192"></a>03192                         mdd_object_put(env, pobj);
<a name="l03193"></a>03193                         <span class="keywordflow">goto</span> again;
<a name="l03194"></a>03194                 }
<a name="l03195"></a>03195 
<a name="l03196"></a>03196                 <span class="keywordflow">if</span> (pobj == mdd_pobj &amp;&amp;
<a name="l03197"></a>03197                     lname.ln_namelen == child_name-&gt;ln_namelen &amp;&amp;
<a name="l03198"></a>03198                     strncmp(lname.ln_name, child_name-&gt;ln_name,
<a name="l03199"></a>03199                             lname.ln_namelen) == 0) {
<a name="l03200"></a>03200                         CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: skip its own %s: &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l03201"></a>03201                               mdd2obd_dev(mdd)-&gt;obd_name, child_name-&gt;ln_name,
<a name="l03202"></a>03202                               PFID(&amp;fid));
<a name="l03203"></a>03203                         linkea_del_buf(ldata, &amp;lname);
<a name="l03204"></a>03204                         mdd_object_put(env, pobj);
<a name="l03205"></a>03205                         <span class="keywordflow">goto</span> again;
<a name="l03206"></a>03206                 }
<a name="l03207"></a>03207 
<a name="l03208"></a>03208                 CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: update &quot;</span>DFID<span class="stringliteral">&quot; with &quot;</span>DNAME<span class="stringliteral">&quot;:&quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l03209"></a>03209                        mdd2obd_dev(mdd)-&gt;obd_name, PFID(mdd_object_fid(pobj)),
<a name="l03210"></a>03210                        PNAME(&amp;lname), PFID(mdd_object_fid(mdd_tobj)));
<a name="l03211"></a>03211 
<a name="l03212"></a>03212                 <span class="keywordflow">if</span> (declare) {
<a name="l03213"></a>03213                         <span class="comment">/* Remove source name from source directory */</span>
<a name="l03214"></a>03214                         <span class="comment">/* Insert new fid with target name into target dir */</span>
<a name="l03215"></a>03215                         rc = mdo_declare_index_delete(env, pobj, lname.ln_name,
<a name="l03216"></a>03216                                                       handle);
<a name="l03217"></a>03217                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03218"></a>03218                                 GOTO(next_put, rc);
<a name="l03219"></a>03219 
<a name="l03220"></a>03220                         rc = mdo_declare_index_insert(env, pobj,
<a name="l03221"></a>03221                                         mdd_object_fid(mdd_tobj),
<a name="l03222"></a>03222                                         mdd_object_type(mdd_tobj),
<a name="l03223"></a>03223                                         lname.ln_name, handle);
<a name="l03224"></a>03224                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03225"></a>03225                                 GOTO(next_put, rc);
<a name="l03226"></a>03226 
<a name="l03227"></a>03227                         rc = mdo_declare_ref_add(env, mdd_tobj, handle);
<a name="l03228"></a>03228                         <span class="keywordflow">if</span> (rc)
<a name="l03229"></a>03229                                 GOTO(next_put, rc);
<a name="l03230"></a>03230 
<a name="l03231"></a>03231                         rc = mdo_declare_ref_del(env, mdd_sobj, handle);
<a name="l03232"></a>03232                         <span class="keywordflow">if</span> (rc)
<a name="l03233"></a>03233                                 GOTO(next_put, rc);
<a name="l03234"></a>03234                 } <span class="keywordflow">else</span> {
<a name="l03235"></a>03235                         <span class="keywordtype">char</span> *tmp_name = info-&gt;mti_key;
<a name="l03236"></a>03236 
<a name="l03237"></a>03237                         <span class="keywordflow">if</span> (lname.ln_namelen &gt;= <span class="keyword">sizeof</span>(info-&gt;mti_key)) {
<a name="l03238"></a>03238                                 <span class="comment">/* lnamelen is too big(&gt; NAME_MAX + 16),</span>
<a name="l03239"></a>03239 <span class="comment">                                 * something wrong about this linkea, let&apos;s</span>
<a name="l03240"></a>03240 <span class="comment">                                 * skip it */</span>
<a name="l03241"></a>03241                                 linkea_del_buf(ldata, &amp;lname);
<a name="l03242"></a>03242                                 mdd_object_put(env, pobj);
<a name="l03243"></a>03243                                 <span class="keywordflow">goto</span> again;
<a name="l03244"></a>03244                         }
<a name="l03245"></a>03245 
<a name="l03246"></a>03246                         <span class="comment">/* Note: lname might be without \0 at the end, see</span>
<a name="l03247"></a>03247 <span class="comment">                         * linkea_entry_unpack(), let&apos;s add extra \0 by</span>
<a name="l03248"></a>03248 <span class="comment">                         * snprintf */</span>
<a name="l03249"></a>03249                         snprintf(tmp_name, <span class="keyword">sizeof</span>(info-&gt;mti_key), <span class="stringliteral">&quot;%.*s&quot;</span>,
<a name="l03250"></a>03250                                  lname.ln_namelen, lname.ln_name);
<a name="l03251"></a>03251                         lname.ln_name = tmp_name;
<a name="l03252"></a>03252 
<a name="l03253"></a>03253                         <span class="comment">/* Let&apos;s check if this linkEA still valid, before</span>
<a name="l03254"></a>03254 <span class="comment">                         * it might be packed into the RPC buffer. */</span>
<a name="l03255"></a>03255                         rc = mdd_lookup(env, &amp;pobj-&gt;mod_obj, &amp;lname,
<a name="l03256"></a>03256                                         &amp;info-&gt;mti_fid, NULL);
<a name="l03257"></a>03257                         <span class="keywordflow">if</span> (rc &lt; 0 ||
<a name="l03258"></a>03258                             !lu_fid_eq(&amp;info-&gt;mti_fid,
<a name="l03259"></a>03259                                         mdd_object_fid(mdd_sobj))) {
<a name="l03260"></a>03260                                 <span class="comment">/* skip invalid linkea entry */</span>
<a name="l03261"></a>03261                                 linkea_del_buf(ldata, &amp;lname);
<a name="l03262"></a>03262                                 mdd_object_put(env, pobj);
<a name="l03263"></a>03263                                 <span class="keywordflow">goto</span> again;
<a name="l03264"></a>03264                         }
<a name="l03265"></a>03265 
<a name="l03266"></a>03266                         rc = __mdd_index_delete(env, pobj, tmp_name, 0, handle);
<a name="l03267"></a>03267                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03268"></a>03268                                 GOTO(next_put, rc);
<a name="l03269"></a>03269 
<a name="l03270"></a>03270                         rc = __mdd_index_insert(env, pobj,
<a name="l03271"></a>03271                                         mdd_object_fid(mdd_tobj),
<a name="l03272"></a>03272                                         mdd_object_type(mdd_tobj),
<a name="l03273"></a>03273                                         tmp_name, handle);
<a name="l03274"></a>03274                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03275"></a>03275                                 GOTO(next_put, rc);
<a name="l03276"></a>03276 
<a name="l03277"></a>03277                         mdd_write_lock(env, mdd_tobj, MOR_SRC_CHILD);
<a name="l03278"></a>03278                         rc = mdo_ref_add(env, mdd_tobj, handle);
<a name="l03279"></a>03279                         mdd_write_unlock(env, mdd_tobj);
<a name="l03280"></a>03280                         <span class="keywordflow">if</span> (rc)
<a name="l03281"></a>03281                                 GOTO(next_put, rc);
<a name="l03282"></a>03282 
<a name="l03283"></a>03283                         mdd_write_lock(env, mdd_sobj, MOR_TGT_CHILD);
<a name="l03284"></a>03284                         mdo_ref_del(env, mdd_sobj, handle);
<a name="l03285"></a>03285                         mdd_write_unlock(env, mdd_sobj);
<a name="l03286"></a>03286                 }
<a name="l03287"></a>03287 next_put:
<a name="l03288"></a>03288                 mdd_object_put(env, pobj);
<a name="l03289"></a>03289                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03290"></a>03290                         <span class="keywordflow">break</span>;
<a name="l03291"></a>03291 
<a name="l03292"></a>03292                 ldata-&gt;ld_lee = (<span class="keyword">struct </span><a class="code" href="structlink__ea__entry.html" title="Hardlink data is name and parent fid.">link_ea_entry</a> *)((<span class="keywordtype">char</span> *)ldata-&gt;ld_lee +
<a name="l03293"></a>03293                                                          ldata-&gt;ld_reclen);
<a name="l03294"></a>03294         }
<a name="l03295"></a>03295 
<a name="l03296"></a>03296         RETURN(rc);
<a name="l03297"></a>03297 }
<a name="l03298"></a>03298 
<a name="l03299"></a>03299 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_migrate_xattrs(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03300"></a>03300                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l03301"></a>03301                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj)
<a name="l03302"></a>03302 {
<a name="l03303"></a>03303         <span class="keyword">struct </span><a class="code" href="structmdd__thread__info.html">mdd_thread_info</a>  *info = mdd_env_info(env);
<a name="l03304"></a>03304         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a>       *mdd = mdo2mdd(&amp;mdd_sobj-&gt;mod_obj);
<a name="l03305"></a>03305         <span class="keywordtype">char</span>                    *xname;
<a name="l03306"></a>03306         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *handle;
<a name="l03307"></a>03307         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           xbuf;
<a name="l03308"></a>03308         <span class="keywordtype">int</span>                     xlen;
<a name="l03309"></a>03309         <span class="keywordtype">int</span>                     rem;
<a name="l03310"></a>03310         <span class="keywordtype">int</span>                     xsize;
<a name="l03311"></a>03311         <span class="keywordtype">int</span>                     list_xsize;
<a name="l03312"></a>03312         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           list_xbuf;
<a name="l03313"></a>03313         <span class="keywordtype">int</span>                     rc;
<a name="l03314"></a>03314         <span class="keywordtype">int</span>                     rc1;
<a name="l03315"></a>03315 
<a name="l03316"></a>03316         <span class="comment">/* retrieve xattr list from the old object */</span>
<a name="l03317"></a>03317         list_xsize = mdo_xattr_list(env, mdd_sobj, &amp;<a class="code" href="group__lu.html#ga3daaf59b14be927dc4227c6fc6635c6d" title="null buffer">LU_BUF_NULL</a>);
<a name="l03318"></a>03318         <span class="keywordflow">if</span> (list_xsize == -ENODATA)
<a name="l03319"></a>03319                 <span class="keywordflow">return</span> 0;
<a name="l03320"></a>03320 
<a name="l03321"></a>03321         <span class="keywordflow">if</span> (list_xsize &lt; 0)
<a name="l03322"></a>03322                 <span class="keywordflow">return</span> list_xsize;
<a name="l03323"></a>03323 
<a name="l03324"></a>03324         lu_buf_check_and_alloc(&amp;info-&gt;mti_big_buf, list_xsize);
<a name="l03325"></a>03325         <span class="keywordflow">if</span> (info-&gt;mti_big_buf.lb_buf == NULL)
<a name="l03326"></a>03326                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l03327"></a>03327 
<a name="l03328"></a>03328         list_xbuf.lb_buf = info-&gt;mti_big_buf.lb_buf;
<a name="l03329"></a>03329         list_xbuf.lb_len = list_xsize;
<a name="l03330"></a>03330         rc = mdo_xattr_list(env, mdd_sobj, &amp;list_xbuf);
<a name="l03331"></a>03331         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03332"></a>03332                 <span class="keywordflow">return</span> rc;
<a name="l03333"></a>03333         rc = 0;
<a name="l03334"></a>03334         rem = list_xsize;
<a name="l03335"></a>03335         xname = list_xbuf.lb_buf;
<a name="l03336"></a>03336         <span class="keywordflow">while</span> (rem &gt; 0) {
<a name="l03337"></a>03337                 xlen = strnlen(xname, rem - 1) + 1;
<a name="l03338"></a>03338                 <span class="keywordflow">if</span> (strcmp(XATTR_NAME_LINK, xname) == 0 ||
<a name="l03339"></a>03339                     strcmp(XATTR_NAME_LMA, xname) == 0 ||
<a name="l03340"></a>03340                     strcmp(XATTR_NAME_LMV, xname) == 0)
<a name="l03341"></a>03341                         <span class="keywordflow">goto</span> next;
<a name="l03342"></a>03342 
<a name="l03343"></a>03343                 <span class="comment">/* For directory, if there are default layout, migrate here */</span>
<a name="l03344"></a>03344                 <span class="keywordflow">if</span> (strcmp(XATTR_NAME_LOV, xname) == 0 &amp;&amp;
<a name="l03345"></a>03345                     !S_ISDIR(lu_object_attr(&amp;mdd_sobj-&gt;mod_obj.mo_lu)))
<a name="l03346"></a>03346                         <span class="keywordflow">goto</span> next;
<a name="l03347"></a>03347 
<a name="l03348"></a>03348                 xsize = mdo_xattr_get(env, mdd_sobj, &amp;<a class="code" href="group__lu.html#ga3daaf59b14be927dc4227c6fc6635c6d" title="null buffer">LU_BUF_NULL</a>, xname);
<a name="l03349"></a>03349                 <span class="keywordflow">if</span> (xsize == -ENODATA)
<a name="l03350"></a>03350                         <span class="keywordflow">goto</span> next;
<a name="l03351"></a>03351                 <span class="keywordflow">if</span> (xsize &lt; 0)
<a name="l03352"></a>03352                         GOTO(out, rc);
<a name="l03353"></a>03353 
<a name="l03354"></a>03354                 lu_buf_check_and_alloc(&amp;info-&gt;mti_link_buf, xsize);
<a name="l03355"></a>03355                 <span class="keywordflow">if</span> (info-&gt;mti_link_buf.lb_buf == NULL)
<a name="l03356"></a>03356                         GOTO(out, rc = -ENOMEM);
<a name="l03357"></a>03357 
<a name="l03358"></a>03358                 xbuf.lb_len = xsize;
<a name="l03359"></a>03359                 xbuf.lb_buf = info-&gt;mti_link_buf.lb_buf;
<a name="l03360"></a>03360                 rc = mdo_xattr_get(env, mdd_sobj, &amp;xbuf, xname);
<a name="l03361"></a>03361                 <span class="keywordflow">if</span> (rc == -ENODATA)
<a name="l03362"></a>03362                         <span class="keywordflow">goto</span> next;
<a name="l03363"></a>03363                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03364"></a>03364                         GOTO(out, rc);
<a name="l03365"></a>03365 
<a name="l03366"></a>03366                 handle = mdd_trans_create(env, mdd);
<a name="l03367"></a>03367                 <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l03368"></a>03368                         GOTO(out, rc = PTR_ERR(handle));
<a name="l03369"></a>03369 
<a name="l03370"></a>03370                 rc = mdo_declare_xattr_set(env, mdd_tobj, &amp;xbuf, xname, 0,
<a name="l03371"></a>03371                                            handle);
<a name="l03372"></a>03372                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03373"></a>03373                         GOTO(stop_trans, rc);
<a name="l03374"></a>03374                 <span class="comment">/* Note: this transaction is part of migration, and it is not</span>
<a name="l03375"></a>03375 <span class="comment">                 * the last step of migration, so we set th_local = 1 to avoid</span>
<a name="l03376"></a>03376 <span class="comment">                 * update last rcvd for this transaction */</span>
<a name="l03377"></a>03377                 handle-&gt;th_local = 1;
<a name="l03378"></a>03378                 rc = mdd_trans_start(env, mdd, handle);
<a name="l03379"></a>03379                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03380"></a>03380                         GOTO(stop_trans, rc);
<a name="l03381"></a>03381 
<a name="l03382"></a>03382                 rc = mdo_xattr_set(env, mdd_tobj, &amp;xbuf, xname, 0, handle);
<a name="l03383"></a>03383                 <span class="keywordflow">if</span> (rc == -EEXIST)
<a name="l03384"></a>03384                         GOTO(stop_trans, rc = 0);
<a name="l03385"></a>03385 
<a name="l03386"></a>03386                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03387"></a>03387                         GOTO(stop_trans, rc);
<a name="l03388"></a>03388 stop_trans:
<a name="l03389"></a>03389                 rc1 = mdd_trans_stop(env, mdd, rc, handle);
<a name="l03390"></a>03390                 <span class="keywordflow">if</span> (rc == 0)
<a name="l03391"></a>03391                         rc = rc1;
<a name="l03392"></a>03392                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03393"></a>03393                         GOTO(out, rc);
<a name="l03394"></a>03394 next:
<a name="l03395"></a>03395                 rem -= xlen;
<a name="l03396"></a>03396                 memmove(xname, xname + xlen, rem);
<a name="l03397"></a>03397         }
<a name="l03398"></a>03398 out:
<a name="l03399"></a>03399         <span class="keywordflow">return</span> rc;
<a name="l03400"></a>03400 }
<a name="l03401"></a>03401 
<a name="l03402"></a>03402 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_migrate_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03403"></a>03403                                       <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj,
<a name="l03404"></a>03404                                       <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l03405"></a>03405                                       <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj,
<a name="l03406"></a>03406                                       <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec,
<a name="l03407"></a>03407                                       <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la,
<a name="l03408"></a>03408                                       <span class="keyword">union</span> <a class="code" href="unionlmv__mds__md.html">lmv_mds_md</a> *mgr_ea,
<a name="l03409"></a>03409                                       <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l03410"></a>03410                                       <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l03411"></a>03411 {
<a name="l03412"></a>03412         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *la_flag = MDD_ENV_VAR(env, la_for_fix);
<a name="l03413"></a>03413         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>     *buf;
<a name="l03414"></a>03414         <span class="keywordtype">int</span>                     rc;
<a name="l03415"></a>03415         <span class="keywordtype">int</span>                     mgr_easize;
<a name="l03416"></a>03416 
<a name="l03417"></a>03417         rc = mdd_declare_object_create_internal(env, mdd_pobj, mdd_tobj, la,
<a name="l03418"></a>03418                                                 handle, spec, NULL);
<a name="l03419"></a>03419         <span class="keywordflow">if</span> (rc != 0)
<a name="l03420"></a>03420                 <span class="keywordflow">return</span> rc;
<a name="l03421"></a>03421 
<a name="l03422"></a>03422         rc = mdd_declare_object_initialize(env, mdd_pobj, mdd_tobj, la,
<a name="l03423"></a>03423                                            handle);
<a name="l03424"></a>03424         <span class="keywordflow">if</span> (rc != 0)
<a name="l03425"></a>03425                 <span class="keywordflow">return</span> rc;
<a name="l03426"></a>03426 
<a name="l03427"></a>03427         <span class="keywordflow">if</span> (S_ISLNK(la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l03428"></a>03428                 <span class="keyword">const</span> <span class="keywordtype">char</span> *target_name = spec-&gt;u.<a class="code" href="structmd__op__spec.html#a5688bea4024906b5b54ba910399ee1d1" title="symlink target">sp_symname</a>;
<a name="l03429"></a>03429                 <span class="keywordtype">int</span> sym_len = strlen(target_name);
<a name="l03430"></a>03430                 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf;
<a name="l03431"></a>03431 
<a name="l03432"></a>03432                 buf = mdd_buf_get_const(env, target_name, sym_len);
<a name="l03433"></a>03433                 rc = dt_declare_record_write(env, mdd_object_child(mdd_tobj),
<a name="l03434"></a>03434                                              buf, 0, handle);
<a name="l03435"></a>03435                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03436"></a>03436                         <span class="keywordflow">return</span> rc;
<a name="l03437"></a>03437         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (S_ISDIR(la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) &amp;&amp; ldata != NULL) {
<a name="l03438"></a>03438                 rc = mdd_declare_links_add(env, mdd_tobj, handle, ldata,
<a name="l03439"></a>03439                                            MLAO_IGNORE);
<a name="l03440"></a>03440                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03441"></a>03441                         <span class="keywordflow">return</span> rc;
<a name="l03442"></a>03442         }
<a name="l03443"></a>03443 
<a name="l03444"></a>03444         <span class="keywordflow">if</span> (spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadata != NULL &amp;&amp; spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadatalen != 0) {
<a name="l03445"></a>03445                 buf = mdd_buf_get_const(env, spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadata,
<a name="l03446"></a>03446                                         spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadatalen);
<a name="l03447"></a>03447                 rc = mdo_declare_xattr_set(env, mdd_tobj, buf, XATTR_NAME_LOV,
<a name="l03448"></a>03448                                            0, handle);
<a name="l03449"></a>03449                 <span class="keywordflow">if</span> (rc)
<a name="l03450"></a>03450                         <span class="keywordflow">return</span> rc;
<a name="l03451"></a>03451         }
<a name="l03452"></a>03452 
<a name="l03453"></a>03453         mgr_easize = lmv_mds_md_size(2, LMV_MAGIC_V1);
<a name="l03454"></a>03454         buf = mdd_buf_get_const(env, mgr_ea, mgr_easize);
<a name="l03455"></a>03455         rc = mdo_declare_xattr_set(env, mdd_sobj, buf, XATTR_NAME_LMV,
<a name="l03456"></a>03456                                    0, handle);
<a name="l03457"></a>03457         <span class="keywordflow">if</span> (rc)
<a name="l03458"></a>03458                 <span class="keywordflow">return</span> rc;
<a name="l03459"></a>03459 
<a name="l03460"></a>03460         la_flag-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_FLAGS;
<a name="l03461"></a>03461         la_flag-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> = la-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> | LUSTRE_IMMUTABLE_FL;
<a name="l03462"></a>03462         rc = mdo_declare_attr_set(env, mdd_sobj, la_flag, handle);
<a name="l03463"></a>03463 
<a name="l03464"></a>03464         <span class="keywordflow">return</span> rc;
<a name="l03465"></a>03465 }
<a name="l03466"></a>03466 
<a name="l03467"></a>03467 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_migrate_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03468"></a>03468                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj,
<a name="l03469"></a>03469                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l03470"></a>03470                               <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj,
<a name="l03471"></a>03471                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l03472"></a>03472                               <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la)
<a name="l03473"></a>03473 {
<a name="l03474"></a>03474         <span class="keyword">struct </span><a class="code" href="structmdd__thread__info.html">mdd_thread_info</a>  *info = mdd_env_info(env);
<a name="l03475"></a>03475         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a>       *mdd = mdo2mdd(&amp;mdd_sobj-&gt;mod_obj);
<a name="l03476"></a>03476         <span class="keyword">struct </span><a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a>       *spec = &amp;info-&gt;mti_spec;
<a name="l03477"></a>03477         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           lmm_buf = { NULL };
<a name="l03478"></a>03478         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           link_buf = { NULL };
<a name="l03479"></a>03479         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>     *buf;
<a name="l03480"></a>03480         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *handle;
<a name="l03481"></a>03481         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>    *mgr_ea;
<a name="l03482"></a>03482         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *la_flag = MDD_ENV_VAR(env, la_for_fix);
<a name="l03483"></a>03483         <span class="keyword">struct </span><a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint = &amp;mdd_env_info(env)-&gt;mti_hint;
<a name="l03484"></a>03484         <span class="keywordtype">int</span>                     mgr_easize;
<a name="l03485"></a>03485         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>      *ldata = &amp;mdd_env_info(env)-&gt;mti_link_data;
<a name="l03486"></a>03486         <span class="keywordtype">int</span>                     rc;
<a name="l03487"></a>03487         ENTRY;
<a name="l03488"></a>03488 
<a name="l03489"></a>03489         <span class="comment">/* prepare spec for create */</span>
<a name="l03490"></a>03490         memset(spec, 0, <span class="keyword">sizeof</span>(*spec));
<a name="l03491"></a>03491         spec-&gt;sp_cr_lookup = 0;
<a name="l03492"></a>03492         spec-&gt;<a class="code" href="structmd__op__spec.html#a184527ee4494f98a7ccaad101c72d2da" title="to create directory">sp_feat</a> = &amp;<a class="code" href="group__dt.html#ga7c4fc0f51c05675af9609faa67c6cdea" title="Features, required from index to support file system directories (mapping names to...">dt_directory_features</a>;
<a name="l03493"></a>03493         <span class="keywordflow">if</span> (S_ISLNK(la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l03494"></a>03494                 buf = lu_buf_check_and_alloc(
<a name="l03495"></a>03495                                 &amp;mdd_env_info(env)-&gt;mti_big_buf,
<a name="l03496"></a>03496                                 la-&gt;<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a> + 1);
<a name="l03497"></a>03497                 link_buf = *buf;
<a name="l03498"></a>03498                 link_buf.lb_len = la-&gt;<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a> + 1;
<a name="l03499"></a>03499                 memset(link_buf.lb_buf, 0, link_buf.lb_len);
<a name="l03500"></a>03500                 rc = mdd_readlink(env, &amp;mdd_sobj-&gt;mod_obj, &amp;link_buf);
<a name="l03501"></a>03501                 <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l03502"></a>03502                         rc = rc != 0 ? rc : -EFAULT;
<a name="l03503"></a>03503                         CERROR(<span class="stringliteral">&quot;%s: &quot;</span>DFID<span class="stringliteral">&quot; readlink failed: rc = %d\n&quot;</span>,
<a name="l03504"></a>03504                                mdd2obd_dev(mdd)-&gt;obd_name,
<a name="l03505"></a>03505                                PFID(mdd_object_fid(mdd_sobj)), rc);
<a name="l03506"></a>03506                         RETURN(rc);
<a name="l03507"></a>03507                 }
<a name="l03508"></a>03508                 spec-&gt;u.<a class="code" href="structmd__op__spec.html#a5688bea4024906b5b54ba910399ee1d1" title="symlink target">sp_symname</a> = link_buf.lb_buf;
<a name="l03509"></a>03509         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (S_ISREG(la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l03510"></a>03510                 <span class="comment">/* retrieve lov of the old object */</span>
<a name="l03511"></a>03511                 rc = mdd_get_lov_ea(env, mdd_sobj, &amp;lmm_buf);
<a name="l03512"></a>03512                 <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -ENODATA)
<a name="l03513"></a>03513                         RETURN(rc);
<a name="l03514"></a>03514                 <span class="keywordflow">if</span> (lmm_buf.lb_buf != NULL &amp;&amp; lmm_buf.lb_len != 0) {
<a name="l03515"></a>03515                         spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadata = lmm_buf.lb_buf;
<a name="l03516"></a>03516                         spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadatalen = lmm_buf.lb_len;
<a name="l03517"></a>03517                         spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> |= MDS_OPEN_HAS_EA;
<a name="l03518"></a>03518                 }
<a name="l03519"></a>03519         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (S_ISDIR(la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l03520"></a>03520                 rc = mdd_links_read(env, mdd_sobj, ldata);
<a name="l03521"></a>03521                 <span class="keywordflow">if</span> (rc == -ENODATA) {
<a name="l03522"></a>03522                         <span class="comment">/* ignore the non-linkEA error */</span>
<a name="l03523"></a>03523                         ldata = NULL;
<a name="l03524"></a>03524                         rc = 0;
<a name="l03525"></a>03525                 }
<a name="l03526"></a>03526                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03527"></a>03527                         RETURN(rc);
<a name="l03528"></a>03528         }
<a name="l03529"></a>03529 
<a name="l03530"></a>03530         mgr_ea = (<span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a> *)info-&gt;mti_xattr_buf;
<a name="l03531"></a>03531         memset(mgr_ea, 0, <span class="keyword">sizeof</span>(*mgr_ea));
<a name="l03532"></a>03532         mgr_ea-&gt;lmv_magic = cpu_to_le32(LMV_MAGIC_V1);
<a name="l03533"></a>03533         mgr_ea-&gt;lmv_stripe_count = cpu_to_le32(2);
<a name="l03534"></a>03534         mgr_ea-&gt;lmv_master_mdt_index = mdd_seq_site(mdd)-&gt;ss_node_id;
<a name="l03535"></a>03535         mgr_ea-&gt;lmv_hash_type = cpu_to_le32(LMV_HASH_FLAG_MIGRATION);
<a name="l03536"></a>03536         fid_cpu_to_le(&amp;mgr_ea-&gt;lmv_stripe_fids[0], mdd_object_fid(mdd_sobj));
<a name="l03537"></a>03537         fid_cpu_to_le(&amp;mgr_ea-&gt;lmv_stripe_fids[1], mdd_object_fid(mdd_tobj));
<a name="l03538"></a>03538 
<a name="l03539"></a>03539         mdd_object_make_hint(env, mdd_pobj, mdd_tobj, la, spec, hint);
<a name="l03540"></a>03540 
<a name="l03541"></a>03541         handle = mdd_trans_create(env, mdd);
<a name="l03542"></a>03542         <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l03543"></a>03543                 GOTO(out_free, rc = PTR_ERR(handle));
<a name="l03544"></a>03544 
<a name="l03545"></a>03545         <span class="comment">/* Note: this transaction is part of migration, and it is not</span>
<a name="l03546"></a>03546 <span class="comment">         * the last step of migration, so we set th_local = 1 to avoid</span>
<a name="l03547"></a>03547 <span class="comment">         * update last rcvd for this transaction */</span>
<a name="l03548"></a>03548         handle-&gt;th_local = 1;
<a name="l03549"></a>03549         rc = mdd_declare_migrate_create(env, mdd_pobj, mdd_sobj, mdd_tobj,
<a name="l03550"></a>03550                                         spec, la,
<a name="l03551"></a>03551                                         (<span class="keyword">union</span> <a class="code" href="unionlmv__mds__md.html">lmv_mds_md</a> *)info-&gt;mti_xattr_buf,
<a name="l03552"></a>03552                                         ldata, handle);
<a name="l03553"></a>03553         <span class="keywordflow">if</span> (rc != 0)
<a name="l03554"></a>03554                 GOTO(stop_trans, rc);
<a name="l03555"></a>03555 
<a name="l03556"></a>03556         rc = mdd_trans_start(env, mdd, handle);
<a name="l03557"></a>03557         <span class="keywordflow">if</span> (rc != 0)
<a name="l03558"></a>03558                 GOTO(stop_trans, rc);
<a name="l03559"></a>03559 
<a name="l03560"></a>03560         <span class="comment">/* don&apos;t set nlink from the original object */</span>
<a name="l03561"></a>03561         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp;= ~LA_NLINK;
<a name="l03562"></a>03562 
<a name="l03563"></a>03563         <span class="comment">/* create the target object */</span>
<a name="l03564"></a>03564         rc = mdd_object_create(env, mdd_pobj, mdd_tobj, la, spec, NULL, NULL,
<a name="l03565"></a>03565                                hint, handle);
<a name="l03566"></a>03566         <span class="keywordflow">if</span> (rc != 0)
<a name="l03567"></a>03567                 GOTO(stop_trans, rc);
<a name="l03568"></a>03568 
<a name="l03569"></a>03569         <span class="keywordflow">if</span> (S_ISDIR(la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) &amp;&amp; ldata != NULL) {
<a name="l03570"></a>03570                 rc = mdd_links_write(env, mdd_tobj, ldata, handle);
<a name="l03571"></a>03571                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03572"></a>03572                         GOTO(stop_trans, rc);
<a name="l03573"></a>03573         }
<a name="l03574"></a>03574 
<a name="l03575"></a>03575         <span class="comment">/* Set MIGRATE EA on the source inode, so once the migration needs</span>
<a name="l03576"></a>03576 <span class="comment">         * to be re-done during failover, the re-do process can locate the</span>
<a name="l03577"></a>03577 <span class="comment">         * target object which is already being created. */</span>
<a name="l03578"></a>03578         mgr_easize = lmv_mds_md_size(2, LMV_MAGIC_V1);
<a name="l03579"></a>03579         buf = mdd_buf_get_const(env, mgr_ea, mgr_easize);
<a name="l03580"></a>03580         rc = mdo_xattr_set(env, mdd_sobj, buf, XATTR_NAME_LMV, 0, handle);
<a name="l03581"></a>03581         <span class="keywordflow">if</span> (rc != 0)
<a name="l03582"></a>03582                 GOTO(stop_trans, rc);
<a name="l03583"></a>03583 
<a name="l03584"></a>03584         <span class="comment">/* Set immutable flag, so any modification is disabled until</span>
<a name="l03585"></a>03585 <span class="comment">         * the migration is done. Once the migration is interrupted,</span>
<a name="l03586"></a>03586 <span class="comment">         * if the resume process find the migrating object has both</span>
<a name="l03587"></a>03587 <span class="comment">         * IMMUTALBE flag and MIGRATE EA, it need to clear IMMUTABLE</span>
<a name="l03588"></a>03588 <span class="comment">         * flag and approve the migration */</span>
<a name="l03589"></a>03589         la_flag-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_FLAGS;
<a name="l03590"></a>03590         la_flag-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> = la-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> | LUSTRE_IMMUTABLE_FL;
<a name="l03591"></a>03591         rc = mdo_attr_set(env, mdd_sobj, la_flag, handle);
<a name="l03592"></a>03592 stop_trans:
<a name="l03593"></a>03593         <span class="keywordflow">if</span> (handle != NULL) {
<a name="l03594"></a>03594                 <span class="keywordtype">int</span> rc1;
<a name="l03595"></a>03595 
<a name="l03596"></a>03596                 rc1 = mdd_trans_stop(env, mdd, rc, handle);
<a name="l03597"></a>03597                 <span class="keywordflow">if</span> (rc == 0)
<a name="l03598"></a>03598                         rc = rc1;
<a name="l03599"></a>03599         }
<a name="l03600"></a>03600 out_free:
<a name="l03601"></a>03601         <span class="keywordflow">if</span> (lmm_buf.lb_buf != NULL)
<a name="l03602"></a>03602                 OBD_FREE(lmm_buf.lb_buf, lmm_buf.lb_len);
<a name="l03603"></a>03603         RETURN(rc);
<a name="l03604"></a>03604 }
<a name="l03605"></a>03605 
<a name="l03606"></a>03606 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_migrate_entries(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03607"></a>03607                                <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l03608"></a>03608                                <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj)
<a name="l03609"></a>03609 {
<a name="l03610"></a>03610         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = mdd_object_child(mdd_sobj);
<a name="l03611"></a>03611         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a>       *mdd = mdo2mdd(&amp;mdd_sobj-&gt;mod_obj);
<a name="l03612"></a>03612         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *dt_tobj = mdd_object_child(mdd_tobj);
<a name="l03613"></a>03613         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *handle;
<a name="l03614"></a>03614         <span class="keyword">struct </span>dt_it            *it;
<a name="l03615"></a>03615         <span class="keyword">const</span> <span class="keyword">struct </span>dt_it_ops  *iops;
<a name="l03616"></a>03616         <span class="keywordtype">int</span>                      rc;
<a name="l03617"></a>03617         <span class="keywordtype">int</span>                      result;
<a name="l03618"></a>03618         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>        *ent;
<a name="l03619"></a>03619         ENTRY;
<a name="l03620"></a>03620 
<a name="l03621"></a>03621         OBD_ALLOC(ent, NAME_MAX + <span class="keyword">sizeof</span>(*ent) + 1);
<a name="l03622"></a>03622         <span class="keywordflow">if</span> (ent == NULL)
<a name="l03623"></a>03623                 RETURN(-ENOMEM);
<a name="l03624"></a>03624 
<a name="l03625"></a>03625         <span class="keywordflow">if</span> (!dt_try_as_dir(env, next))
<a name="l03626"></a>03626                 GOTO(out_ent, rc = -ENOTDIR);
<a name="l03627"></a>03627         <span class="comment">/*</span>
<a name="l03628"></a>03628 <span class="comment">         * iterate directories</span>
<a name="l03629"></a>03629 <span class="comment">         */</span>
<a name="l03630"></a>03630         iops = &amp;next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>;
<a name="l03631"></a>03631         it = iops-&gt;<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a74b9db7e1791f6accf99c80a3a0c43e2" title="Allocate and initialize new iterator.">init</a>(env, next, LUDA_FID | LUDA_TYPE);
<a name="l03632"></a>03632         <span class="keywordflow">if</span> (IS_ERR(it))
<a name="l03633"></a>03633                 GOTO(out_ent, rc = PTR_ERR(it));
<a name="l03634"></a>03634 
<a name="l03635"></a>03635         rc = iops-&gt;load(env, it, 0);
<a name="l03636"></a>03636         <span class="keywordflow">if</span> (rc == 0)
<a name="l03637"></a>03637                 rc = iops-&gt;next(env, it);
<a name="l03638"></a>03638         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l03639"></a>03639                 rc = 0;
<a name="l03640"></a>03640         <span class="comment">/*</span>
<a name="l03641"></a>03641 <span class="comment">         * At this point and across for-loop:</span>
<a name="l03642"></a>03642 <span class="comment">         *</span>
<a name="l03643"></a>03643 <span class="comment">         *  rc == 0 -&gt; ok, proceed.</span>
<a name="l03644"></a>03644 <span class="comment">         *  rc &gt;  0 -&gt; end of directory.</span>
<a name="l03645"></a>03645 <span class="comment">         *  rc &lt;  0 -&gt; error.</span>
<a name="l03646"></a>03646 <span class="comment">         */</span>
<a name="l03647"></a>03647         <span class="keywordflow">do</span> {
<a name="l03648"></a>03648                 <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a>       *child;
<a name="l03649"></a>03649                 <span class="keywordtype">char</span>                    *name = mdd_env_info(env)-&gt;mti_key;
<a name="l03650"></a>03650                 <span class="keywordtype">int</span>                     len;
<a name="l03651"></a>03651                 <span class="keywordtype">int</span>                     recsize;
<a name="l03652"></a>03652                 <span class="keywordtype">int</span>                     is_dir;
<a name="l03653"></a>03653                 <span class="keywordtype">bool</span>                    target_exist = <span class="keyword">false</span>;
<a name="l03654"></a>03654                 <span class="keywordtype">int</span>                     rc1;
<a name="l03655"></a>03655 
<a name="l03656"></a>03656                 len = iops-&gt;key_size(env, it);
<a name="l03657"></a>03657                 <span class="keywordflow">if</span> (len == 0)
<a name="l03658"></a>03658                         <span class="keywordflow">goto</span> next;
<a name="l03659"></a>03659 
<a name="l03660"></a>03660                 result = iops-&gt;rec(env, it, (<span class="keyword">struct</span> dt_rec *)ent,
<a name="l03661"></a>03661                                    LUDA_FID | LUDA_TYPE);
<a name="l03662"></a>03662                 <span class="keywordflow">if</span> (result == -ESTALE)
<a name="l03663"></a>03663                         <span class="keywordflow">goto</span> next;
<a name="l03664"></a>03664                 <span class="keywordflow">if</span> (result != 0) {
<a name="l03665"></a>03665                         rc = result;
<a name="l03666"></a>03666                         <span class="keywordflow">goto</span> out;
<a name="l03667"></a>03667                 }
<a name="l03668"></a>03668 
<a name="l03669"></a>03669                 fid_le_to_cpu(&amp;ent-&gt;lde_fid, &amp;ent-&gt;lde_fid);
<a name="l03670"></a>03670                 recsize = le16_to_cpu(ent-&gt;lde_reclen);
<a name="l03671"></a>03671 
<a name="l03672"></a>03672                 <span class="comment">/* Insert new fid with target name into target dir */</span>
<a name="l03673"></a>03673                 <span class="keywordflow">if</span> ((ent-&gt;lde_namelen == 1 &amp;&amp; ent-&gt;lde_name[0] == <span class="charliteral">&apos;.&apos;</span>) ||
<a name="l03674"></a>03674                     (ent-&gt;lde_namelen == 2 &amp;&amp; ent-&gt;lde_name[0] == <span class="charliteral">&apos;.&apos;</span> &amp;&amp;
<a name="l03675"></a>03675                      ent-&gt;lde_name[1] == <span class="charliteral">&apos;.&apos;</span>))
<a name="l03676"></a>03676                         <span class="keywordflow">goto</span> next;
<a name="l03677"></a>03677 
<a name="l03678"></a>03678                 child = mdd_object_find(env, mdd, &amp;ent-&gt;lde_fid);
<a name="l03679"></a>03679                 <span class="keywordflow">if</span> (IS_ERR(child))
<a name="l03680"></a>03680                         GOTO(out, rc = PTR_ERR(child));
<a name="l03681"></a>03681 
<a name="l03682"></a>03682                 mdd_write_lock(env, child, MOR_SRC_CHILD);
<a name="l03683"></a>03683                 is_dir = S_ISDIR(mdd_object_type(child));
<a name="l03684"></a>03684 
<a name="l03685"></a>03685                 snprintf(name, ent-&gt;lde_namelen + 1, <span class="stringliteral">&quot;%s&quot;</span>, ent-&gt;lde_name);
<a name="l03686"></a>03686 
<a name="l03687"></a>03687                 <span class="comment">/* Check whether the name has been inserted to the target */</span>
<a name="l03688"></a>03688                 <span class="keywordflow">if</span> (dt_try_as_dir(env, dt_tobj)) {
<a name="l03689"></a>03689                         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid = &amp;mdd_env_info(env)-&gt;mti_fid2;
<a name="l03690"></a>03690 
<a name="l03691"></a>03691                         rc = dt_lookup(env, dt_tobj, (<span class="keyword">struct</span> dt_rec *)fid,
<a name="l03692"></a>03692                                        (<span class="keyword">struct</span> dt_key *)name);
<a name="l03693"></a>03693                         <span class="keywordflow">if</span> (unlikely(rc == 0))
<a name="l03694"></a>03694                                 target_exist = <span class="keyword">true</span>;
<a name="l03695"></a>03695                 }
<a name="l03696"></a>03696 
<a name="l03697"></a>03697                 handle = mdd_trans_create(env, mdd);
<a name="l03698"></a>03698                 <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l03699"></a>03699                         GOTO(out_put, rc = PTR_ERR(handle));
<a name="l03700"></a>03700 
<a name="l03701"></a>03701                 <span class="comment">/* Note: this transaction is part of migration, and it is not</span>
<a name="l03702"></a>03702 <span class="comment">                 * the last step of migration, so we set th_local = 1 to avoid</span>
<a name="l03703"></a>03703 <span class="comment">                 * updating last rcvd for this transaction */</span>
<a name="l03704"></a>03704                 handle-&gt;th_local = 1;
<a name="l03705"></a>03705                 <span class="keywordflow">if</span> (likely(!target_exist)) {
<a name="l03706"></a>03706                         rc = mdo_declare_index_insert(env, mdd_tobj,
<a name="l03707"></a>03707                                                       &amp;ent-&gt;lde_fid,
<a name="l03708"></a>03708                                                       mdd_object_type(child),
<a name="l03709"></a>03709                                                       name, handle);
<a name="l03710"></a>03710                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03711"></a>03711                                 GOTO(out_put, rc);
<a name="l03712"></a>03712 
<a name="l03713"></a>03713                         <span class="keywordflow">if</span> (is_dir) {
<a name="l03714"></a>03714                                 rc = mdo_declare_ref_add(env, mdd_tobj, handle);
<a name="l03715"></a>03715                                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03716"></a>03716                                         GOTO(out_put, rc);
<a name="l03717"></a>03717                         }
<a name="l03718"></a>03718                 }
<a name="l03719"></a>03719 
<a name="l03720"></a>03720                 rc = mdo_declare_index_delete(env, mdd_sobj, name, handle);
<a name="l03721"></a>03721                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03722"></a>03722                         GOTO(out_put, rc);
<a name="l03723"></a>03723 
<a name="l03724"></a>03724                 <span class="keywordflow">if</span> (is_dir) {
<a name="l03725"></a>03725                         rc = mdo_declare_ref_del(env, mdd_sobj, handle);
<a name="l03726"></a>03726                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03727"></a>03727                                 GOTO(out_put, rc);
<a name="l03728"></a>03728 
<a name="l03729"></a>03729                         <span class="comment">/* Update .. for child */</span>
<a name="l03730"></a>03730                         rc = mdo_declare_index_delete(env, child, dotdot,
<a name="l03731"></a>03731                                                       handle);
<a name="l03732"></a>03732                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03733"></a>03733                                 GOTO(out_put, rc);
<a name="l03734"></a>03734 
<a name="l03735"></a>03735                         rc = mdo_declare_index_insert(env, child,
<a name="l03736"></a>03736                                                       mdd_object_fid(mdd_tobj),
<a name="l03737"></a>03737                                                       S_IFDIR, dotdot, handle);
<a name="l03738"></a>03738                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03739"></a>03739                                 GOTO(out_put, rc);
<a name="l03740"></a>03740                 }
<a name="l03741"></a>03741 
<a name="l03742"></a>03742                 rc = mdd_linkea_declare_update_child(env, mdd_sobj,mdd_tobj,
<a name="l03743"></a>03743                                                      child, name,
<a name="l03744"></a>03744                                                      strlen(name),
<a name="l03745"></a>03745                                                      handle);
<a name="l03746"></a>03746                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03747"></a>03747                         GOTO(out_put, rc);
<a name="l03748"></a>03748 
<a name="l03749"></a>03749                 rc = mdd_trans_start(env, mdd, handle);
<a name="l03750"></a>03750                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l03751"></a>03751                         CERROR(<span class="stringliteral">&quot;%s: transaction start failed: rc = %d\n&quot;</span>,
<a name="l03752"></a>03752                                mdd2obd_dev(mdd)-&gt;obd_name, rc);
<a name="l03753"></a>03753                         GOTO(out_put, rc);
<a name="l03754"></a>03754                 }
<a name="l03755"></a>03755 
<a name="l03756"></a>03756                 <span class="keywordflow">if</span> (likely(!target_exist)) {
<a name="l03757"></a>03757                         rc = __mdd_index_insert(env, mdd_tobj, &amp;ent-&gt;lde_fid,
<a name="l03758"></a>03758                                                 mdd_object_type(child),
<a name="l03759"></a>03759                                                 name, handle);
<a name="l03760"></a>03760                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03761"></a>03761                                 GOTO(out_put, rc);
<a name="l03762"></a>03762                 }
<a name="l03763"></a>03763 
<a name="l03764"></a>03764                 rc = __mdd_index_delete(env, mdd_sobj, name, is_dir, handle);
<a name="l03765"></a>03765                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03766"></a>03766                         GOTO(out_put, rc);
<a name="l03767"></a>03767 
<a name="l03768"></a>03768                 <span class="keywordflow">if</span> (is_dir) {
<a name="l03769"></a>03769                         rc = __mdd_index_delete_only(env, child, dotdot,
<a name="l03770"></a>03770                                                      handle);
<a name="l03771"></a>03771                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03772"></a>03772                                 GOTO(out_put, rc);
<a name="l03773"></a>03773 
<a name="l03774"></a>03774                         rc = __mdd_index_insert_only(env, child,
<a name="l03775"></a>03775                                          mdd_object_fid(mdd_tobj), S_IFDIR,
<a name="l03776"></a>03776                                          dotdot, handle);
<a name="l03777"></a>03777                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03778"></a>03778                                 GOTO(out_put, rc);
<a name="l03779"></a>03779                 }
<a name="l03780"></a>03780 
<a name="l03781"></a>03781                 rc = mdd_linkea_update_child(env, mdd_sobj, mdd_tobj,
<a name="l03782"></a>03782                                              child, name,
<a name="l03783"></a>03783                                              strlen(name), handle);
<a name="l03784"></a>03784 
<a name="l03785"></a>03785 out_put:
<a name="l03786"></a>03786                 mdd_write_unlock(env, child);
<a name="l03787"></a>03787                 mdd_object_put(env, child);
<a name="l03788"></a>03788                 rc1 = mdd_trans_stop(env, mdd, rc, handle);
<a name="l03789"></a>03789                 <span class="keywordflow">if</span> (rc == 0)
<a name="l03790"></a>03790                         rc = rc1;
<a name="l03791"></a>03791 
<a name="l03792"></a>03792                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03793"></a>03793                         GOTO(out, rc);
<a name="l03794"></a>03794 next:
<a name="l03795"></a>03795                 result = iops-&gt;next(env, it);
<a name="l03796"></a>03796                 <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_MIGRATE_ENTRIES))
<a name="l03797"></a>03797                         GOTO(out, rc = -EINTR);
<a name="l03798"></a>03798 
<a name="l03799"></a>03799                 <span class="keywordflow">if</span> (result == -ESTALE)
<a name="l03800"></a>03800                         <span class="keywordflow">goto</span> next;
<a name="l03801"></a>03801         } <span class="keywordflow">while</span> (result == 0);
<a name="l03802"></a>03802 out:
<a name="l03803"></a>03803         iops-&gt;put(env, it);
<a name="l03804"></a>03804         iops-&gt;fini(env, it);
<a name="l03805"></a>03805 out_ent:
<a name="l03806"></a>03806         OBD_FREE(ent, NAME_MAX + <span class="keyword">sizeof</span>(*ent) + 1);
<a name="l03807"></a>03807         RETURN(rc);
<a name="l03808"></a>03808 }
<a name="l03809"></a>03809 
<a name="l03810"></a>03810 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_update_linkea(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03811"></a>03811                                      <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj,
<a name="l03812"></a>03812                                      <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l03813"></a>03813                                      <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj,
<a name="l03814"></a>03814                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *child_name,
<a name="l03815"></a>03815                                      <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l03816"></a>03816                                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l03817"></a>03817 {
<a name="l03818"></a>03818         <span class="keywordflow">return</span> mdd_update_linkea_internal(env, mdd_pobj, mdd_sobj, mdd_tobj,
<a name="l03819"></a>03819                                           child_name, ldata, handle, 1);
<a name="l03820"></a>03820 }
<a name="l03821"></a>03821 
<a name="l03822"></a>03822 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_update_linkea(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03823"></a>03823                              <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj,
<a name="l03824"></a>03824                              <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l03825"></a>03825                              <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj,
<a name="l03826"></a>03826                              <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *child_name,
<a name="l03827"></a>03827                              <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l03828"></a>03828                              <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l03829"></a>03829 {
<a name="l03830"></a>03830         <span class="keywordflow">return</span> mdd_update_linkea_internal(env, mdd_pobj, mdd_sobj, mdd_tobj,
<a name="l03831"></a>03831                                           child_name, ldata, handle, 0);
<a name="l03832"></a>03832 }
<a name="l03833"></a>03833 
<a name="l03834"></a>03834 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_declare_migrate_update_name(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03835"></a>03835                                            <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj,
<a name="l03836"></a>03836                                            <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l03837"></a>03837                                            <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj,
<a name="l03838"></a>03838                                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l03839"></a>03839                                            <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la,
<a name="l03840"></a>03840                                            <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *parent_la,
<a name="l03841"></a>03841                                            <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l03842"></a>03842                                            <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l03843"></a>03843 {
<a name="l03844"></a>03844         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(&amp;mdd_sobj-&gt;mod_obj);
<a name="l03845"></a>03845         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la_flag = MDD_ENV_VAR(env, tattr);
<a name="l03846"></a>03846         <span class="keywordtype">int</span> rc;
<a name="l03847"></a>03847 
<a name="l03848"></a>03848         <span class="comment">/* Revert IMMUTABLE flag */</span>
<a name="l03849"></a>03849         la_flag-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_FLAGS;
<a name="l03850"></a>03850         la_flag-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> = la-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> &amp; ~LUSTRE_IMMUTABLE_FL;
<a name="l03851"></a>03851         rc = mdo_declare_attr_set(env, mdd_sobj, la_flag, handle);
<a name="l03852"></a>03852         <span class="keywordflow">if</span> (rc != 0)
<a name="l03853"></a>03853                 <span class="keywordflow">return</span> rc;
<a name="l03854"></a>03854 
<a name="l03855"></a>03855         <span class="comment">/* delete entry from source dir */</span>
<a name="l03856"></a>03856         rc = mdo_declare_index_delete(env, mdd_pobj, lname-&gt;ln_name, handle);
<a name="l03857"></a>03857         <span class="keywordflow">if</span> (rc != 0)
<a name="l03858"></a>03858                 <span class="keywordflow">return</span> rc;
<a name="l03859"></a>03859 
<a name="l03860"></a>03860         <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> != NULL) {
<a name="l03861"></a>03861                 rc = mdd_declare_update_linkea(env, mdd_pobj, mdd_sobj,
<a name="l03862"></a>03862                                                mdd_tobj, lname, ldata, handle);
<a name="l03863"></a>03863                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03864"></a>03864                         <span class="keywordflow">return</span> rc;
<a name="l03865"></a>03865         }
<a name="l03866"></a>03866 
<a name="l03867"></a>03867         <span class="keywordflow">if</span> (S_ISREG(mdd_object_type(mdd_sobj))) {
<a name="l03868"></a>03868                 rc = mdo_declare_xattr_del(env, mdd_sobj, XATTR_NAME_LOV,
<a name="l03869"></a>03869                                            handle);
<a name="l03870"></a>03870                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03871"></a>03871                         <span class="keywordflow">return</span> rc;
<a name="l03872"></a>03872 
<a name="l03873"></a>03873                 handle-&gt;th_complex = 1;
<a name="l03874"></a>03874                 rc = mdo_declare_xattr_set(env, mdd_tobj, NULL,
<a name="l03875"></a>03875                                            XATTR_NAME_FID,
<a name="l03876"></a>03876                                            LU_XATTR_REPLACE, handle);
<a name="l03877"></a>03877                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03878"></a>03878                         <span class="keywordflow">return</span> rc;
<a name="l03879"></a>03879         }
<a name="l03880"></a>03880 
<a name="l03881"></a>03881         <span class="keywordflow">if</span> (S_ISDIR(mdd_object_type(mdd_sobj))) {
<a name="l03882"></a>03882                 rc = mdo_declare_ref_del(env, mdd_pobj, handle);
<a name="l03883"></a>03883                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03884"></a>03884                         <span class="keywordflow">return</span> rc;
<a name="l03885"></a>03885         }
<a name="l03886"></a>03886 
<a name="l03887"></a>03887         <span class="comment">/* new name */</span>
<a name="l03888"></a>03888         rc = mdo_declare_index_insert(env, mdd_pobj, mdo2fid(mdd_tobj),
<a name="l03889"></a>03889                                       mdd_object_type(mdd_tobj),
<a name="l03890"></a>03890                                       lname-&gt;ln_name, handle);
<a name="l03891"></a>03891         <span class="keywordflow">if</span> (rc != 0)
<a name="l03892"></a>03892                 <span class="keywordflow">return</span> rc;
<a name="l03893"></a>03893 
<a name="l03894"></a>03894         rc = mdd_declare_links_add(env, mdd_tobj, handle, NULL, MLAO_IGNORE);
<a name="l03895"></a>03895         <span class="keywordflow">if</span> (rc != 0)
<a name="l03896"></a>03896                 <span class="keywordflow">return</span> rc;
<a name="l03897"></a>03897 
<a name="l03898"></a>03898         <span class="keywordflow">if</span> (S_ISDIR(mdd_object_type(mdd_sobj))) {
<a name="l03899"></a>03899                 rc = mdo_declare_ref_add(env, mdd_pobj, handle);
<a name="l03900"></a>03900                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03901"></a>03901                         <span class="keywordflow">return</span> rc;
<a name="l03902"></a>03902         }
<a name="l03903"></a>03903 
<a name="l03904"></a>03904         <span class="comment">/* delete old object */</span>
<a name="l03905"></a>03905         rc = mdo_declare_ref_del(env, mdd_sobj, handle);
<a name="l03906"></a>03906         <span class="keywordflow">if</span> (rc != 0)
<a name="l03907"></a>03907                 <span class="keywordflow">return</span> rc;
<a name="l03908"></a>03908 
<a name="l03909"></a>03909         <span class="keywordflow">if</span> (S_ISDIR(mdd_object_type(mdd_sobj))) {
<a name="l03910"></a>03910                 <span class="comment">/* delete old object */</span>
<a name="l03911"></a>03911                 rc = mdo_declare_ref_del(env, mdd_sobj, handle);
<a name="l03912"></a>03912                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03913"></a>03913                         <span class="keywordflow">return</span> rc;
<a name="l03914"></a>03914                 <span class="comment">/* set nlink to 0 */</span>
<a name="l03915"></a>03915                 rc = mdo_declare_attr_set(env, mdd_sobj, la, handle);
<a name="l03916"></a>03916                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03917"></a>03917                         <span class="keywordflow">return</span> rc;
<a name="l03918"></a>03918         }
<a name="l03919"></a>03919 
<a name="l03920"></a>03920         rc = mdd_declare_finish_unlink(env, mdd_sobj, handle);
<a name="l03921"></a>03921         <span class="keywordflow">if</span> (rc)
<a name="l03922"></a>03922                 <span class="keywordflow">return</span> rc;
<a name="l03923"></a>03923 
<a name="l03924"></a>03924         rc = mdo_declare_attr_set(env, mdd_pobj, parent_la, handle);
<a name="l03925"></a>03925         <span class="keywordflow">if</span> (rc != 0)
<a name="l03926"></a>03926                 <span class="keywordflow">return</span> rc;
<a name="l03927"></a>03927 
<a name="l03928"></a>03928         rc = mdd_declare_changelog_store(env, mdd, lname, NULL, handle);
<a name="l03929"></a>03929 
<a name="l03930"></a>03930         <span class="keywordflow">return</span> rc;
<a name="l03931"></a>03931 }
<a name="l03932"></a>03932 
<a name="l03933"></a>03933 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_migrate_update_name(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03934"></a>03934                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_pobj,
<a name="l03935"></a>03935                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_sobj,
<a name="l03936"></a>03936                                    <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *mdd_tobj,
<a name="l03937"></a>03937                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l03938"></a>03938                                    <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l03939"></a>03939 {
<a name="l03940"></a>03940         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *p_la = MDD_ENV_VAR(env, la_for_fix);
<a name="l03941"></a>03941         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *so_attr = MDD_ENV_VAR(env, cattr);
<a name="l03942"></a>03942         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *la_flag = MDD_ENV_VAR(env, tattr);
<a name="l03943"></a>03943         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a>       *mdd = mdo2mdd(&amp;mdd_sobj-&gt;mod_obj);
<a name="l03944"></a>03944         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>      *ldata = &amp;mdd_env_info(env)-&gt;mti_link_data;
<a name="l03945"></a>03945         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *handle;
<a name="l03946"></a>03946         <span class="keywordtype">int</span>                     is_dir = S_ISDIR(mdd_object_type(mdd_sobj));
<a name="l03947"></a>03947         <span class="keyword">const</span> <span class="keywordtype">char</span>              *name = lname-&gt;ln_name;
<a name="l03948"></a>03948         <span class="keywordtype">int</span>                     rc;
<a name="l03949"></a>03949         ENTRY;
<a name="l03950"></a>03950 
<a name="l03951"></a>03951         <span class="comment">/* update time for parent */</span>
<a name="l03952"></a>03952         LASSERT(ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; LA_CTIME);
<a name="l03953"></a>03953         p_la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = p_la-&gt;<a class="code" href="structlu__attr.html#a3c9ac90caf353fc11ed871645d4ab1f5" title="modification time in seconds since Epoch">la_mtime</a> = ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a>;
<a name="l03954"></a>03954         p_la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l03955"></a>03955 
<a name="l03956"></a>03956         rc = mdd_la_get(env, mdd_sobj, so_attr);
<a name="l03957"></a>03957         <span class="keywordflow">if</span> (rc != 0)
<a name="l03958"></a>03958                 RETURN(rc);
<a name="l03959"></a>03959 
<a name="l03960"></a>03960         ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> = NULL;
<a name="l03961"></a>03961         rc = mdd_links_read(env, mdd_sobj, ldata);
<a name="l03962"></a>03962         <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -ENOENT &amp;&amp; rc != -ENODATA)
<a name="l03963"></a>03963                 RETURN(rc);
<a name="l03964"></a>03964 
<a name="l03965"></a>03965         handle = mdd_trans_create(env, mdd);
<a name="l03966"></a>03966         <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l03967"></a>03967                 RETURN(PTR_ERR(handle));
<a name="l03968"></a>03968 
<a name="l03969"></a>03969         rc = mdd_declare_migrate_update_name(env, mdd_pobj, mdd_sobj, mdd_tobj,
<a name="l03970"></a>03970                                              lname, so_attr, p_la, ldata,
<a name="l03971"></a>03971                                              handle);
<a name="l03972"></a>03972         <span class="keywordflow">if</span> (rc != 0) {
<a name="l03973"></a>03973                 <span class="comment">/* If the migration can not be fit in one transaction, just</span>
<a name="l03974"></a>03974 <span class="comment">                 * leave it in the original MDT */</span>
<a name="l03975"></a>03975                 <span class="keywordflow">if</span> (rc == -E2BIG)
<a name="l03976"></a>03976                         GOTO(stop_trans, rc = 0);
<a name="l03977"></a>03977                 <span class="keywordflow">else</span>
<a name="l03978"></a>03978                         GOTO(stop_trans, rc);
<a name="l03979"></a>03979         }
<a name="l03980"></a>03980 
<a name="l03981"></a>03981         CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: update &quot;</span>DFID<span class="stringliteral">&quot;/&quot;</span>DFID<span class="stringliteral">&quot; with %s:&quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l03982"></a>03982                mdd2obd_dev(mdd)-&gt;obd_name, PFID(mdd_object_fid(mdd_pobj)),
<a name="l03983"></a>03983                PFID(mdd_object_fid(mdd_sobj)), lname-&gt;ln_name,
<a name="l03984"></a>03984                PFID(mdd_object_fid(mdd_tobj)));
<a name="l03985"></a>03985 
<a name="l03986"></a>03986         rc = mdd_trans_start(env, mdd, handle);
<a name="l03987"></a>03987         <span class="keywordflow">if</span> (rc != 0)
<a name="l03988"></a>03988                 GOTO(stop_trans, rc);
<a name="l03989"></a>03989 
<a name="l03990"></a>03990         <span class="comment">/* Revert IMMUTABLE flag */</span>
<a name="l03991"></a>03991         la_flag-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_FLAGS;
<a name="l03992"></a>03992         la_flag-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> = so_attr-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> &amp; ~LUSTRE_IMMUTABLE_FL;
<a name="l03993"></a>03993         rc = mdo_attr_set(env, mdd_sobj, la_flag, handle);
<a name="l03994"></a>03994         <span class="keywordflow">if</span> (rc != 0)
<a name="l03995"></a>03995                 GOTO(stop_trans, rc);
<a name="l03996"></a>03996 
<a name="l03997"></a>03997         <span class="comment">/* Remove source name from source directory */</span>
<a name="l03998"></a>03998         rc = __mdd_index_delete(env, mdd_pobj, name, is_dir, handle);
<a name="l03999"></a>03999         <span class="keywordflow">if</span> (rc != 0)
<a name="l04000"></a>04000                 GOTO(stop_trans, rc);
<a name="l04001"></a>04001 
<a name="l04002"></a>04002         <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a> != NULL) {
<a name="l04003"></a>04003                 rc = mdd_update_linkea(env, mdd_pobj, mdd_sobj, mdd_tobj,
<a name="l04004"></a>04004                                        lname, ldata, handle);
<a name="l04005"></a>04005                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04006"></a>04006                         GOTO(stop_trans, rc);
<a name="l04007"></a>04007 
<a name="l04008"></a>04008                 <span class="comment">/*  linkea update might decrease the source object</span>
<a name="l04009"></a>04009 <span class="comment">                 *  nlink, let&apos;s get the attr again after ref_del */</span>
<a name="l04010"></a>04010                 rc = mdd_la_get(env, mdd_sobj, so_attr);
<a name="l04011"></a>04011                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04012"></a>04012                         GOTO(stop_trans, rc);
<a name="l04013"></a>04013         }
<a name="l04014"></a>04014 
<a name="l04015"></a>04015         <span class="keywordflow">if</span> (S_ISREG(so_attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l04016"></a>04016                 <span class="keywordflow">if</span> (so_attr-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> == 1) {
<a name="l04017"></a>04017                         rc = mdo_xattr_del(env, mdd_sobj, XATTR_NAME_LOV,
<a name="l04018"></a>04018                                            handle);
<a name="l04019"></a>04019                         <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -ENODATA)
<a name="l04020"></a>04020                                 GOTO(stop_trans, rc);
<a name="l04021"></a>04021 
<a name="l04022"></a>04022                         rc = mdo_xattr_set(env, mdd_tobj, NULL,
<a name="l04023"></a>04023                                            XATTR_NAME_FID,
<a name="l04024"></a>04024                                            LU_XATTR_REPLACE, handle);
<a name="l04025"></a>04025                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l04026"></a>04026                                 GOTO(stop_trans, rc);
<a name="l04027"></a>04027                 }
<a name="l04028"></a>04028         }
<a name="l04029"></a>04029 
<a name="l04030"></a>04030         <span class="comment">/* Insert new fid with target name into target dir */</span>
<a name="l04031"></a>04031         rc = __mdd_index_insert(env, mdd_pobj, mdd_object_fid(mdd_tobj),
<a name="l04032"></a>04032                                 mdd_object_type(mdd_tobj), name, handle);
<a name="l04033"></a>04033         <span class="keywordflow">if</span> (rc != 0)
<a name="l04034"></a>04034                 GOTO(stop_trans, rc);
<a name="l04035"></a>04035 
<a name="l04036"></a>04036         linkea_add_buf(ldata, lname, mdd_object_fid(mdd_pobj));
<a name="l04037"></a>04037         rc = mdd_links_add(env, mdd_tobj, mdo2fid(mdd_pobj), lname, handle,
<a name="l04038"></a>04038                            ldata, 1);
<a name="l04039"></a>04039         <span class="keywordflow">if</span> (rc != 0)
<a name="l04040"></a>04040                 GOTO(stop_trans, rc);
<a name="l04041"></a>04041 
<a name="l04042"></a>04042         mdd_write_lock(env, mdd_sobj, MOR_TGT_CHILD);
<a name="l04043"></a>04043 
<a name="l04044"></a>04044         mdd_sobj-&gt;mod_flags |= DEAD_OBJ;
<a name="l04045"></a>04045         rc = mdd_mark_orphan_object(env, mdd_sobj, handle, <span class="keyword">false</span>);
<a name="l04046"></a>04046         <span class="keywordflow">if</span> (rc != 0)
<a name="l04047"></a>04047                 GOTO(out_unlock, rc);
<a name="l04048"></a>04048 
<a name="l04049"></a>04049         rc = __mdd_orphan_add(env, mdd_sobj, handle);
<a name="l04050"></a>04050         <span class="keywordflow">if</span> (rc != 0)
<a name="l04051"></a>04051                 GOTO(out_unlock, rc);
<a name="l04052"></a>04052 
<a name="l04053"></a>04053         mdo_ref_del(env, mdd_sobj, handle);
<a name="l04054"></a>04054         <span class="keywordflow">if</span> (is_dir)
<a name="l04055"></a>04055                 mdo_ref_del(env, mdd_sobj, handle);
<a name="l04056"></a>04056 
<a name="l04057"></a>04057         <span class="comment">/* Get the attr again after ref_del */</span>
<a name="l04058"></a>04058         rc = mdd_la_get(env, mdd_sobj, so_attr);
<a name="l04059"></a>04059         <span class="keywordflow">if</span> (rc != 0)
<a name="l04060"></a>04060                 GOTO(out_unlock, rc);
<a name="l04061"></a>04061 
<a name="l04062"></a>04062         ma-&gt;ma_attr = *so_attr;
<a name="l04063"></a>04063         ma-&gt;ma_valid |= MA_INODE;
<a name="l04064"></a>04064 
<a name="l04065"></a>04065         rc = mdd_attr_set_internal(env, mdd_pobj, p_la, handle, 0);
<a name="l04066"></a>04066         <span class="keywordflow">if</span> (rc != 0)
<a name="l04067"></a>04067                 GOTO(out_unlock, rc);
<a name="l04068"></a>04068 
<a name="l04069"></a>04069         rc = mdd_changelog_ns_store(env, mdd, CL_MIGRATE, 0, mdd_tobj,
<a name="l04070"></a>04070                                mdo2fid(mdd_pobj), mdo2fid(mdd_sobj),
<a name="l04071"></a>04071                                mdo2fid(mdd_pobj), lname, lname, handle);
<a name="l04072"></a>04072         <span class="keywordflow">if</span> (rc != 0) {
<a name="l04073"></a>04073                 CWARN(<span class="stringliteral">&quot;%s: changelog for migrate %s &quot;</span>DFID
<a name="l04074"></a>04074                       <span class="stringliteral">&quot;under &quot;</span>DFID<span class="stringliteral">&quot; failed: rc = %d\n&quot;</span>,
<a name="l04075"></a>04075                       mdd2obd_dev(mdd)-&gt;obd_name, lname-&gt;ln_name,
<a name="l04076"></a>04076                       PFID(mdd_object_fid(mdd_sobj)),
<a name="l04077"></a>04077                       PFID(mdd_object_fid(mdd_pobj)), rc);
<a name="l04078"></a>04078                 <span class="comment">/* Sigh, there are no easy way to migrate back the object, so</span>
<a name="l04079"></a>04079 <span class="comment">                 * let&apos;s reset the result to 0 for now XXX */</span>
<a name="l04080"></a>04080                 rc = 0;
<a name="l04081"></a>04081         }
<a name="l04082"></a>04082 out_unlock:
<a name="l04083"></a>04083         mdd_write_unlock(env, mdd_sobj);
<a name="l04084"></a>04084 
<a name="l04085"></a>04085 stop_trans:
<a name="l04086"></a>04086         mdd_trans_stop(env, mdd, rc, handle);
<a name="l04087"></a>04087 
<a name="l04088"></a>04088         RETURN(rc);
<a name="l04089"></a>04089 }
<a name="l04090"></a>04090 
<a name="l04091"></a>04091 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_fld_lookup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmdd__device.html">mdd_device</a> *mdd,
<a name="l04092"></a>04092                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, __u32 *mdt_index)
<a name="l04093"></a>04093 {
<a name="l04094"></a>04094         <span class="keyword">struct </span><a class="code" href="structlu__seq__range.html" title="Describes a range of sequence, lsr_start is included but lsr_end is not in the range...">lu_seq_range</a> *range = &amp;mdd_env_info(env)-&gt;mti_range;
<a name="l04095"></a>04095         <span class="keyword">struct </span><a class="code" href="structseq__server__site.html">seq_server_site</a> *ss;
<a name="l04096"></a>04096         <span class="keywordtype">int</span> rc;
<a name="l04097"></a>04097 
<a name="l04098"></a>04098         ss = mdd-&gt;mdd_md_dev.md_lu_dev.<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>-&gt;<a class="code" href="structlu__site.html#ae7ef4565e0e4634a56ca97fbb552d271" title="XXX: a hack! fld has to find md_site via site, remove when possible.">ld_seq_site</a>;
<a name="l04099"></a>04099 
<a name="l04100"></a>04100         range-&gt;lsr_flags = LU_SEQ_RANGE_MDT;
<a name="l04101"></a>04101         rc = <a class="code" href="group__fld.html#ga564c5cfc33e401f8dd9c4ede0bd8cd62" title="Lookup MDT/OST by seq, returns a range for given seq.">fld_server_lookup</a>(env, ss-&gt;<a class="code" href="structseq__server__site.html#a325bd7c1845a266e8f54469450152cb8" title="Fid location database.">ss_server_fld</a>, fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a>, range);
<a name="l04102"></a>04102         <span class="keywordflow">if</span> (rc != 0)
<a name="l04103"></a>04103                 <span class="keywordflow">return</span> rc;
<a name="l04104"></a>04104 
<a name="l04105"></a>04105         *mdt_index = range-&gt;lsr_index;
<a name="l04106"></a>04106 
<a name="l04107"></a>04107         <span class="keywordflow">return</span> 0;
<a name="l04108"></a>04108 }
<a name="l04117"></a>04117 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_migrate_sanity_check(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04118"></a>04118                                     <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *pobj,
<a name="l04119"></a>04119                                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *pattr,
<a name="l04120"></a>04120                                     <span class="keyword">struct</span> <a class="code" href="structmdd__object.html">mdd_object</a> *sobj,
<a name="l04121"></a>04121                                     <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *sattr)
<a name="l04122"></a>04122 {
<a name="l04123"></a>04123         <span class="keyword">struct </span><a class="code" href="structmdd__thread__info.html">mdd_thread_info</a>  *info = mdd_env_info(env);
<a name="l04124"></a>04124         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>      *ldata = &amp;info-&gt;mti_link_data;
<a name="l04125"></a>04125         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a>       *mdd = mdo2mdd(&amp;pobj-&gt;mod_obj);
<a name="l04126"></a>04126         <span class="keywordtype">int</span>                     mgr_easize;
<a name="l04127"></a>04127         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           *mgr_buf;
<a name="l04128"></a>04128         <span class="keywordtype">int</span>                     count;
<a name="l04129"></a>04129         <span class="keywordtype">int</span>                     rc;
<a name="l04130"></a>04130         __u64 mdt_index;
<a name="l04131"></a>04131         ENTRY;
<a name="l04132"></a>04132 
<a name="l04133"></a>04133         mgr_easize = lmv_mds_md_size(2, LMV_MAGIC_V1);
<a name="l04134"></a>04134         mgr_buf = lu_buf_check_and_alloc(&amp;info-&gt;mti_big_buf, mgr_easize);
<a name="l04135"></a>04135         <span class="keywordflow">if</span> (mgr_buf-&gt;lb_buf == NULL)
<a name="l04136"></a>04136                 RETURN(-ENOMEM);
<a name="l04137"></a>04137 
<a name="l04138"></a>04138         rc = mdo_xattr_get(env, sobj, mgr_buf, XATTR_NAME_LMV);
<a name="l04139"></a>04139         <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l04140"></a>04140                 <span class="keyword">union </span><a class="code" href="unionlmv__mds__md.html">lmv_mds_md</a> *lmm = mgr_buf-&gt;lb_buf;
<a name="l04141"></a>04141 
<a name="l04142"></a>04142                 <span class="comment">/* If the object has migrateEA, it means IMMUTE flag</span>
<a name="l04143"></a>04143 <span class="comment">                 * is being set by previous migration process, so it</span>
<a name="l04144"></a>04144 <span class="comment">                 * needs to override the IMMUTE flag, otherwise the</span>
<a name="l04145"></a>04145 <span class="comment">                 * following sanity check will fail */</span>
<a name="l04146"></a>04146                 <span class="keywordflow">if</span> (le32_to_cpu(lmm-&gt;lmv_md_v1.lmv_hash_type) &amp;
<a name="l04147"></a>04147                                                 LMV_HASH_FLAG_MIGRATION) {
<a name="l04148"></a>04148                         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a> *mdd = mdo2mdd(&amp;sobj-&gt;mod_obj);
<a name="l04149"></a>04149 
<a name="l04150"></a>04150                         sattr-&gt;<a class="code" href="structlu__attr.html#a60e4106c79368150711ff8b247b4d339" title="object flags">la_flags</a> &amp;= ~LUSTRE_IMMUTABLE_FL;
<a name="l04151"></a>04151                         CDEBUG(D_HA, <span class="stringliteral">&quot;%s: &quot;</span>DFID<span class="stringliteral">&quot; override IMMUTE FLAG\n&quot;</span>,
<a name="l04152"></a>04152                                mdd2obd_dev(mdd)-&gt;obd_name,
<a name="l04153"></a>04153                                PFID(mdd_object_fid(sobj)));
<a name="l04154"></a>04154                 }
<a name="l04155"></a>04155         }
<a name="l04156"></a>04156 
<a name="l04157"></a>04157         rc = mdd_rename_sanity_check(env, pobj, pattr, pobj, pattr,
<a name="l04158"></a>04158                                      sobj, sattr, NULL, NULL);
<a name="l04159"></a>04159         <span class="keywordflow">if</span> (rc != 0)
<a name="l04160"></a>04160                 RETURN(rc);
<a name="l04161"></a>04161 
<a name="l04162"></a>04162         <span class="comment">/* Then it will check if the file should be migrated. If the file</span>
<a name="l04163"></a>04163 <span class="comment">         * has mulitple links, we only need migrate the file if all of its</span>
<a name="l04164"></a>04164 <span class="comment">         * entries has been migrated to the remote MDT */</span>
<a name="l04165"></a>04165         <span class="keywordflow">if</span> (!S_ISREG(sattr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>) || sattr-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> &lt; 2)
<a name="l04166"></a>04166                 RETURN(0);
<a name="l04167"></a>04167 
<a name="l04168"></a>04168         rc = mdd_links_read(env, sobj, ldata);
<a name="l04169"></a>04169         <span class="keywordflow">if</span> (rc != 0) {
<a name="l04170"></a>04170                 <span class="comment">/* For multiple links files, if there are no linkEA data at all,</span>
<a name="l04171"></a>04171 <span class="comment">                 * means the file might be created before linkEA is enabled, and</span>
<a name="l04172"></a>04172 <span class="comment">                 * all of its links should not be migrated yet, otherwise it</span>
<a name="l04173"></a>04173 <span class="comment">                 * should have some linkEA there */</span>
<a name="l04174"></a>04174                 <span class="keywordflow">if</span> (rc == -ENOENT || rc == -ENODATA)
<a name="l04175"></a>04175                         RETURN(1);
<a name="l04176"></a>04176                 RETURN(rc);
<a name="l04177"></a>04177         }
<a name="l04178"></a>04178 
<a name="l04179"></a>04179         mdt_index = mdd-&gt;mdd_md_dev.md_lu_dev.<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>-&gt;<a class="code" href="structlu__site.html#ae7ef4565e0e4634a56ca97fbb552d271" title="XXX: a hack! fld has to find md_site via site, remove when possible.">ld_seq_site</a>-&gt;<a class="code" href="structseq__server__site.html#ac6ed0968d534f1eda5c11d36b6b9539f" title="mds number of this site.">ss_node_id</a>;
<a name="l04180"></a>04180         <span class="comment">/* If there are still links locally, then the file will not be</span>
<a name="l04181"></a>04181 <span class="comment">         * migrated. */</span>
<a name="l04182"></a>04182         LASSERT(ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> != NULL);
<a name="l04183"></a>04183         ldata-&gt;ld_lee = (<span class="keyword">struct </span><a class="code" href="structlink__ea__entry.html" title="Hardlink data is name and parent fid.">link_ea_entry</a> *)(ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> + 1);
<a name="l04184"></a>04184         <span class="keywordflow">for</span> (count = 0; count &lt; ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount; count++) {
<a name="l04185"></a>04185                 <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          lname;
<a name="l04186"></a>04186                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           fid;
<a name="l04187"></a>04187                 __u32                   parent_mdt_index;
<a name="l04188"></a>04188 
<a name="l04189"></a>04189                 linkea_entry_unpack(ldata-&gt;ld_lee, &amp;ldata-&gt;ld_reclen,
<a name="l04190"></a>04190                                     &amp;lname, &amp;fid);
<a name="l04191"></a>04191                 ldata-&gt;ld_lee = (<span class="keyword">struct </span><a class="code" href="structlink__ea__entry.html" title="Hardlink data is name and parent fid.">link_ea_entry</a> *)((<span class="keywordtype">char</span> *)ldata-&gt;ld_lee +
<a name="l04192"></a>04192                                                          ldata-&gt;ld_reclen);
<a name="l04193"></a>04193 
<a name="l04194"></a>04194                 rc = mdd_fld_lookup(env, mdd, &amp;fid, &amp;parent_mdt_index);
<a name="l04195"></a>04195                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04196"></a>04196                         RETURN(rc);
<a name="l04197"></a>04197 
<a name="l04198"></a>04198                 <span class="comment">/* Migrate the object only if none of its parents are on the</span>
<a name="l04199"></a>04199 <span class="comment">                 * current MDT. */</span>
<a name="l04200"></a>04200                 <span class="keywordflow">if</span> (parent_mdt_index != mdt_index)
<a name="l04201"></a>04201                         <span class="keywordflow">continue</span>;
<a name="l04202"></a>04202 
<a name="l04203"></a>04203                 CDEBUG(D_INFO, DFID<span class="stringliteral">&quot;still has local entry %.*s &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l04204"></a>04204                        PFID(mdd_object_fid(sobj)), lname.ln_namelen,
<a name="l04205"></a>04205                        lname.ln_name, PFID(&amp;fid));
<a name="l04206"></a>04206                 rc = 1;
<a name="l04207"></a>04207                 <span class="keywordflow">break</span>;
<a name="l04208"></a>04208         }
<a name="l04209"></a>04209 
<a name="l04210"></a>04210         RETURN(rc);
<a name="l04211"></a>04211 }
<a name="l04212"></a>04212 
<a name="l04213"></a>04213 <span class="keyword">static</span> <span class="keywordtype">int</span> mdd_migrate(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *pobj,
<a name="l04214"></a>04214                        <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *sobj, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l04215"></a>04215                        <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *tobj, <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l04216"></a>04216 {
<a name="l04217"></a>04217         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a>       *mdd_pobj = md2mdd_obj(pobj);
<a name="l04218"></a>04218         <span class="keyword">struct </span><a class="code" href="structmdd__device.html">mdd_device</a>       *mdd = mdo2mdd(pobj);
<a name="l04219"></a>04219         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a>       *mdd_sobj = md2mdd_obj(sobj);
<a name="l04220"></a>04220         <span class="keyword">struct </span><a class="code" href="structmdd__object.html">mdd_object</a>       *mdd_tobj = md2mdd_obj(tobj);
<a name="l04221"></a>04221         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *so_attr = MDD_ENV_VAR(env, cattr);
<a name="l04222"></a>04222         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *pattr = MDD_ENV_VAR(env, pattr);
<a name="l04223"></a>04223         <span class="keywordtype">int</span>                     rc;
<a name="l04224"></a>04224 
<a name="l04225"></a>04225         ENTRY;
<a name="l04226"></a>04226         <span class="comment">/* If the file will being migrated, it will check whether</span>
<a name="l04227"></a>04227 <span class="comment">         * the file is being opened by someone else right now */</span>
<a name="l04228"></a>04228         mdd_read_lock(env, mdd_sobj, MOR_SRC_CHILD);
<a name="l04229"></a>04229         <span class="keywordflow">if</span> (mdd_sobj-&gt;mod_count &gt; 0) {
<a name="l04230"></a>04230                 CERROR(<span class="stringliteral">&quot;%s: &quot;</span>DFID<span class="stringliteral">&quot;%s is already opened count %d: rc = %d\n&quot;</span>,
<a name="l04231"></a>04231                        mdd2obd_dev(mdd)-&gt;obd_name,
<a name="l04232"></a>04232                        PFID(mdd_object_fid(mdd_sobj)), lname-&gt;ln_name,
<a name="l04233"></a>04233                        mdd_sobj-&gt;mod_count, -EBUSY);
<a name="l04234"></a>04234                 mdd_read_unlock(env, mdd_sobj);
<a name="l04235"></a>04235                 GOTO(put, rc = -EBUSY);
<a name="l04236"></a>04236         }
<a name="l04237"></a>04237         mdd_read_unlock(env, mdd_sobj);
<a name="l04238"></a>04238 
<a name="l04239"></a>04239         rc = mdd_la_get(env, mdd_sobj, so_attr);
<a name="l04240"></a>04240         <span class="keywordflow">if</span> (rc != 0)
<a name="l04241"></a>04241                 GOTO(put, rc);
<a name="l04242"></a>04242 
<a name="l04243"></a>04243         rc = mdd_la_get(env, mdd_pobj, pattr);
<a name="l04244"></a>04244         <span class="keywordflow">if</span> (rc != 0)
<a name="l04245"></a>04245                 GOTO(put, rc);
<a name="l04246"></a>04246 
<a name="l04247"></a>04247         rc = mdd_migrate_sanity_check(env, mdd_pobj, pattr, mdd_sobj, so_attr);
<a name="l04248"></a>04248         <span class="keywordflow">if</span> (rc != 0) {
<a name="l04249"></a>04249                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l04250"></a>04250                         rc = 0;
<a name="l04251"></a>04251                 GOTO(put, rc);
<a name="l04252"></a>04252         }
<a name="l04253"></a>04253 
<a name="l04254"></a>04254         <span class="comment">/* Sigh, it is impossible to finish all of migration in a single</span>
<a name="l04255"></a>04255 <span class="comment">         * transaction, for example migrating big directory entries to the</span>
<a name="l04256"></a>04256 <span class="comment">         * new MDT, it needs insert all of name entries of children in the</span>
<a name="l04257"></a>04257 <span class="comment">         * new directory.</span>
<a name="l04258"></a>04258 <span class="comment">         *</span>
<a name="l04259"></a>04259 <span class="comment">         * So migration will be done in multiple steps and transactions.</span>
<a name="l04260"></a>04260 <span class="comment">         *</span>
<a name="l04261"></a>04261 <span class="comment">         * 1. create an orphan object on the remote MDT in one transaction.</span>
<a name="l04262"></a>04262 <span class="comment">         * 2. migrate extend attributes to the new target file/directory.</span>
<a name="l04263"></a>04263 <span class="comment">         * 3. For directory, migrate the entries to the new MDT and update</span>
<a name="l04264"></a>04264 <span class="comment">         * linkEA of each children. Because we can not migrate all entries</span>
<a name="l04265"></a>04265 <span class="comment">         * in a single transaction, so the migrating directory will become</span>
<a name="l04266"></a>04266 <span class="comment">         * a striped directory during migration, so once the process is</span>
<a name="l04267"></a>04267 <span class="comment">         * interrupted, the directory is still accessible. (During lookup,</span>
<a name="l04268"></a>04268 <span class="comment">         * client will locate the name by searching both original and target</span>
<a name="l04269"></a>04269 <span class="comment">         * object).</span>
<a name="l04270"></a>04270 <span class="comment">         * 4. Finally, update the name/FID to point to the new file/directory</span>
<a name="l04271"></a>04271 <span class="comment">         * in a separate transaction.</span>
<a name="l04272"></a>04272 <span class="comment">         */</span>
<a name="l04273"></a>04273 
<a name="l04274"></a>04274         <span class="comment">/* step 1: Check whether the orphan object has been created, and create</span>
<a name="l04275"></a>04275 <span class="comment">         * orphan object on the remote MDT if needed */</span>
<a name="l04276"></a>04276         <span class="keywordflow">if</span> (!mdd_object_exists(mdd_tobj)) {
<a name="l04277"></a>04277                 rc = mdd_migrate_create(env, mdd_pobj, mdd_sobj, mdd_tobj,
<a name="l04278"></a>04278                                         lname, so_attr);
<a name="l04279"></a>04279                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04280"></a>04280                         GOTO(put, rc);
<a name="l04281"></a>04281         }
<a name="l04282"></a>04282 
<a name="l04283"></a>04283         LASSERT(mdd_object_exists(mdd_tobj));
<a name="l04284"></a>04284         <span class="comment">/* step 2: migrate xattr */</span>
<a name="l04285"></a>04285         rc = mdd_migrate_xattrs(env, mdd_sobj, mdd_tobj);
<a name="l04286"></a>04286         <span class="keywordflow">if</span> (rc != 0)
<a name="l04287"></a>04287                 GOTO(put, rc);
<a name="l04288"></a>04288 
<a name="l04289"></a>04289         <span class="comment">/* step 3: migrate name entries to the orphan object */</span>
<a name="l04290"></a>04290         <span class="keywordflow">if</span> (S_ISDIR(lu_object_attr(&amp;mdd_sobj-&gt;mod_obj.mo_lu))) {
<a name="l04291"></a>04291                 rc = mdd_migrate_entries(env, mdd_sobj, mdd_tobj);
<a name="l04292"></a>04292                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04293"></a>04293                         GOTO(put, rc);
<a name="l04294"></a>04294                 <span class="keywordflow">if</span> (unlikely(OBD_FAIL_CHECK_RESET(OBD_FAIL_MIGRATE_NET_REP,
<a name="l04295"></a>04295                                                   OBD_FAIL_MDS_REINT_NET_REP)))
<a name="l04296"></a>04296                         GOTO(put, rc = 0);
<a name="l04297"></a>04297         } <span class="keywordflow">else</span> {
<a name="l04298"></a>04298                 OBD_FAIL_TIMEOUT(OBD_FAIL_MIGRATE_DELAY, cfs_fail_val);
<a name="l04299"></a>04299         }
<a name="l04300"></a>04300 
<a name="l04301"></a>04301         LASSERT(mdd_object_exists(mdd_tobj));
<a name="l04302"></a>04302         <span class="comment">/* step 4: update name entry to the new object */</span>
<a name="l04303"></a>04303         rc = mdd_migrate_update_name(env, mdd_pobj, mdd_sobj, mdd_tobj, lname,
<a name="l04304"></a>04304                                      ma);
<a name="l04305"></a>04305         <span class="keywordflow">if</span> (rc != 0)
<a name="l04306"></a>04306                 GOTO(put, rc);
<a name="l04307"></a>04307 put:
<a name="l04308"></a>04308         RETURN(rc);
<a name="l04309"></a>04309 }
<a name="l04310"></a>04310 
<a name="l04311"></a>04311 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structmd__dir__operations.html" title="Operations implemented for each directory object.">md_dir_operations</a> mdd_dir_ops = {
<a name="l04312"></a>04312         .mdo_is_subdir     = mdd_is_subdir,
<a name="l04313"></a>04313         .mdo_lookup        = mdd_lookup,
<a name="l04314"></a>04314         .mdo_create        = mdd_create,
<a name="l04315"></a>04315         .mdo_rename        = mdd_rename,
<a name="l04316"></a>04316         .mdo_link          = mdd_link,
<a name="l04317"></a>04317         .mdo_unlink        = mdd_unlink,
<a name="l04318"></a>04318         .mdo_create_data   = mdd_create_data,
<a name="l04319"></a>04319         .mdo_migrate       = mdd_migrate,
<a name="l04320"></a>04320 };
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:16 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
