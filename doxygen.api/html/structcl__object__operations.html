<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: cl_object_operations Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cl_object_operations Struct Reference<br/>
<small>
[<a class="el" href="group__cl__object.html">cl_object</a>]</small>
</h1><!-- doxytag: class="cl_object_operations" -->
<p>Operations implemented for each cl object layer.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl__object_8h_source.html">cl_object.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#a86e603bbbf4c6b1625b8dece6cbb5f32">coo_page_init</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__page.html">cl_page</a> *page, pgoff_t index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize page slice for this layer.  <a href="#a86e603bbbf4c6b1625b8dece6cbb5f32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#a636de14a3118ef9d708121f95a1330e4">coo_lock_init</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize lock slice for this layer.  <a href="#a636de14a3118ef9d708121f95a1330e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#a8b8a7168fdc690b21120ab5d03ae67ce">coo_io_init</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize io state for a given layer.  <a href="#a8b8a7168fdc690b21120ab5d03ae67ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#a63cabd646365a83d06c0e8eae0fe633f">coo_attr_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__attr.html">cl_attr</a> *attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill portion of <em>attr</em> that this layer controls.  <a href="#a63cabd646365a83d06c0e8eae0fe633f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#add30d6bf56d89a425b3980a1184558ab">coo_attr_update</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, const struct <a class="el" href="structcl__attr.html">cl_attr</a> *attr, unsigned valid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update attributes.  <a href="#add30d6bf56d89a425b3980a1184558ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#a88bd54845a2e896ffd7cc9c057572923">coo_conf_set</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, const struct <a class="el" href="structcl__object__conf.html">cl_object_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update object configuration.  <a href="#a88bd54845a2e896ffd7cc9c057572923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#a1cacda5692e51d04da73eed3fdbf37c6">coo_glimpse</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structost__lvb.html">ost_lvb</a> *lvb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Glimpse ast.  <a href="#a1cacda5692e51d04da73eed3fdbf37c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#ae9470df7237ccbd5dec57b38ceb67015">coo_prune</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object prune method.  <a href="#ae9470df7237ccbd5dec57b38ceb67015"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b8dec58886703a63ae318cf4e34137f"></a><!-- doxytag: member="cl_object_operations::coo_getstripe" ref="a2b8dec58886703a63ae318cf4e34137f" args=")(const struct lu_env *env, struct cl_object *obj, struct lov_user_md __user *lum)" -->
int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#a2b8dec58886703a63ae318cf4e34137f">coo_getstripe</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct lov_user_md __user *lum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object getstripe method. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2deed25a532503a0b8a2b5ba9e48479"></a><!-- doxytag: member="cl_object_operations::coo_fiemap" ref="ab2deed25a532503a0b8a2b5ba9e48479" args=")(const struct lu_env *env, struct cl_object *obj, struct ll_fiemap_info_key *fmkey, struct fiemap *fiemap, size_t *buflen)" -->
int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#ab2deed25a532503a0b8a2b5ba9e48479">coo_fiemap</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structll__fiemap__info__key.html">ll_fiemap_info_key</a> *fmkey, struct fiemap *fiemap, size_t *buflen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get FIEMAP mapping from the object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a286454405198270e0675386b806a10"></a><!-- doxytag: member="cl_object_operations::coo_layout_get" ref="a4a286454405198270e0675386b806a10" args=")(const struct lu_env *env, struct cl_object *obj, struct cl_layout *layout)" -->
int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#a4a286454405198270e0675386b806a10">coo_layout_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__layout.html">cl_layout</a> *layout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get layout and generation of the object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8023e91e539a9a2661fd0744df80997"></a><!-- doxytag: member="cl_object_operations::coo_maxbytes" ref="ab8023e91e539a9a2661fd0744df80997" args=")(struct cl_object *obj)" -->
loff_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#ab8023e91e539a9a2661fd0744df80997">coo_maxbytes</a> )(struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get maximum size of the object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4285e5c1c552110704ba50cce4d326c"></a><!-- doxytag: member="cl_object_operations::coo_req_attr_set" ref="ac4285e5c1c552110704ba50cce4d326c" args=")(const struct lu_env *env, struct cl_object *obj, struct cl_req_attr *attr)" -->
void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__object__operations.html#ac4285e5c1c552110704ba50cce4d326c">coo_req_attr_set</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__req__attr.html">cl_req_attr</a> *attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set request attributes. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Operations implemented for each cl object layer. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>vvp_ops, lov_ops, lovsub_ops, osc_ops </dd></dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00298">298</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a63cabd646365a83d06c0e8eae0fe633f"></a><!-- doxytag: member="cl_object_operations::coo_attr_get" ref="a63cabd646365a83d06c0e8eae0fe633f" args=")(const struct lu_env *env, struct cl_object *obj, struct cl_attr *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__object__operations.html#a63cabd646365a83d06c0e8eae0fe633f">cl_object_operations::coo_attr_get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__attr.html">cl_attr</a> *attr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill portion of <em>attr</em> that this layer controls. </p>
<p>This method is called top-to-bottom through all object layers.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="structcl__object__header.html#a1d5bd74f8a1c9232bd97a3e5a6ded72a" title="Protects consistency between cl_attr of parent object and attributes of sub-objects...">cl_object_header::coh_attr_guard</a> of the top-object is locked.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0: to continue </dd>
<dd>
+ve: to stop iterating through layers (but 0 is returned from enclosing <a class="el" href="group__cl__object.html#gadfa2c03f781edcc53976843d94c18b48" title="Returns data-attributes of an object obj.">cl_object_attr_get()</a>) </dd>
<dd>
-ve: to signal error </dd></dl>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l00204">cl_object_attr_get()</a>.</p>

</div>
</div>
<a class="anchor" id="add30d6bf56d89a425b3980a1184558ab"></a><!-- doxytag: member="cl_object_operations::coo_attr_update" ref="add30d6bf56d89a425b3980a1184558ab" args=")(const struct lu_env *env, struct cl_object *obj, const struct cl_attr *attr, unsigned valid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__object__operations.html#add30d6bf56d89a425b3980a1184558ab">cl_object_operations::coo_attr_update</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, const struct <a class="el" href="structcl__attr.html">cl_attr</a> *attr, unsigned valid)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update attributes. </p>
<p><em>valid</em> is a bitmask composed from enum <a class="el" href="group__cl__object.html#ga48fd4da7a215ef4bcc31582adceb8b83" title="Fields in cl_attr that are being set.">cl_attr_valid</a>, and indicating what attributes are to be set.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="structcl__object__header.html#a1d5bd74f8a1c9232bd97a3e5a6ded72a" title="Protects consistency between cl_attr of parent object and attributes of sub-objects...">cl_object_header::coh_attr_guard</a> of the top-object is locked.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the same convention as for <a class="el" href="structcl__object__operations.html#a63cabd646365a83d06c0e8eae0fe633f" title="Fill portion of attr that this layer controls.">cl_object_operations::coo_attr_get()</a> is used. </dd></dl>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l00236">cl_object_attr_update()</a>.</p>

</div>
</div>
<a class="anchor" id="a88bd54845a2e896ffd7cc9c057572923"></a><!-- doxytag: member="cl_object_operations::coo_conf_set" ref="a88bd54845a2e896ffd7cc9c057572923" args=")(const struct lu_env *env, struct cl_object *obj, const struct cl_object_conf *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__object__operations.html#a88bd54845a2e896ffd7cc9c057572923">cl_object_operations::coo_conf_set</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, const struct <a class="el" href="structcl__object__conf.html">cl_object_conf</a> *conf)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update object configuration. </p>
<p>Called top-to-bottom to modify object configuration.</p>
<p>XXX error conditions and handling. </p>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l00298">cl_conf_set()</a>.</p>

</div>
</div>
<a class="anchor" id="a1cacda5692e51d04da73eed3fdbf37c6"></a><!-- doxytag: member="cl_object_operations::coo_glimpse" ref="a1cacda5692e51d04da73eed3fdbf37c6" args=")(const struct lu_env *env, const struct cl_object *obj, struct ost_lvb *lvb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__object__operations.html#a1cacda5692e51d04da73eed3fdbf37c6">cl_object_operations::coo_glimpse</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structost__lvb.html">ost_lvb</a> *lvb)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Glimpse ast. </p>
<p>Executed when glimpse ast arrives for a lock on this object. Layers are supposed to fill parts of <em>lvb</em> that will be shipped to the glimpse originator as a glimpse result.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>vvp_object_glimpse(), lovsub_object_glimpse(), </dd>
<dd>
osc_object_glimpse() </dd></dl>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l00270">cl_object_glimpse()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b8a7168fdc690b21120ab5d03ae67ce"></a><!-- doxytag: member="cl_object_operations::coo_io_init" ref="a8b8a7168fdc690b21120ab5d03ae67ce" args=")(const struct lu_env *env, struct cl_object *obj, struct cl_io *io)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__object__operations.html#a8b8a7168fdc690b21120ab5d03ae67ce">cl_object_operations::coo_io_init</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize io state for a given layer. </p>
<p>called top-to-bottom once per io existence to initialize io state. If layer wants to keep some state for this type of io, it has to embed struct <a class="el" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> in <a class="el" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&quot;Session&quot; context for per-request data.">lu_env::le_ses</a>, and register slice with <a class="el" href="group__clio.html#ga7f11d31070279077648197650a60f10e" title="Adds io slice to the cl_io.">cl_io_slice_add()</a>. It is guaranteed that all threads participating in this io share the same session. </p>

</div>
</div>
<a class="anchor" id="a636de14a3118ef9d708121f95a1330e4"></a><!-- doxytag: member="cl_object_operations::coo_lock_init" ref="a636de14a3118ef9d708121f95a1330e4" args=")(const struct lu_env *env, struct cl_object *obj, struct cl_lock *lock, const struct cl_io *io)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__object__operations.html#a636de14a3118ef9d708121f95a1330e4">cl_object_operations::coo_lock_init</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize lock slice for this layer. </p>
<p>Called top-to-bottom through every object layer when a new <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> is instantiated. Layer keeping private per-lock data, or requiring its own lock operations vector should allocate these data here, and attach then to the lock by calling <a class="el" href="group__clio.html#ga9c2fdf8ae73a6f36bc8df4249459da93" title="Adds lock slice to the compound lock.">cl_lock_slice_add()</a>. Mandatory. </p>

</div>
</div>
<a class="anchor" id="a86e603bbbf4c6b1625b8dece6cbb5f32"></a><!-- doxytag: member="cl_object_operations::coo_page_init" ref="a86e603bbbf4c6b1625b8dece6cbb5f32" args=")(const struct lu_env *env, struct cl_object *obj, struct cl_page *page, pgoff_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__object__operations.html#a86e603bbbf4c6b1625b8dece6cbb5f32">cl_object_operations::coo_page_init</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__page.html">cl_page</a> *page, pgoff_t index)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize page slice for this layer. </p>
<p>Called top-to-bottom through every object layer when a new <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> is instantiated. Layer keeping private per-page data, or requiring its own page operations vector should allocate these data here, and attach then to the page by calling <a class="el" href="group__clio.html#gaf9c2b2723494e52efc66d52fe2d0b93f" title="Adds page slice to the compound page.">cl_page_slice_add()</a>. <em>vmpage</em> is locked (in the VM sense). Optional.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>success.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ERR_PTR(errno)</em>&nbsp;</td><td>failure code.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valid-pointer</em>&nbsp;</td><td>pointer to already existing referenced page to be used instead of newly created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9470df7237ccbd5dec57b38ceb67015"></a><!-- doxytag: member="cl_object_operations::coo_prune" ref="ae9470df7237ccbd5dec57b38ceb67015" args=")(const struct lu_env *env, struct cl_object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__object__operations.html#ae9470df7237ccbd5dec57b38ceb67015">cl_object_operations::coo_prune</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Object prune method. </p>
<p>Called when the layout is going to change on this object, therefore each layer has to clean up their cache, mainly pages and locks. </p>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l00321">cl_object_prune()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="cl__object_8h_source.html">cl_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:56:16 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
