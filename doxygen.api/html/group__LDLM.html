<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: Lustre Distributed Lock Manager</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Lustre Distributed Lock Manager</h1>
<p>Lustre DLM is based on VAX DLM.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Lustre Distributed Lock Manager:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__LDLM.png" border="0" alt="" usemap="#group____LDLM_map"/>
<map name="group____LDLM_map" id="group____LDLM">
<area shape="rect" id="node1" href="group__ldlm__local__ast.html" title="These AST handlers are typically used for server&#45;side local locks and are also used..." alt="" coords="343,5,596,35"/><area shape="rect" id="node3" href="group__ldlm__pools.html" title="There are not used outside of ldlm." alt="" coords="339,59,600,88"/><area shape="rect" id="node4" href="group__ldlm__cli__api.html" title="These are typically used by client and server (*_local versions) to obtain and release..." alt="" coords="296,112,643,141"/><area shape="rect" id="node5" href="group__ldlm__iterator.html" title="LDLM provides for a way to iterate through every lock on a resource or namespace..." alt="" coords="412,165,527,195"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__pool__ops.html">ldlm_pool_ops</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operations on LDLM pools.  <a href="structldlm__pool__ops.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__pool.html">ldlm_pool</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LDLM pool structure to track granted locks.  <a href="structldlm__pool.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__valblock__ops.html">ldlm_valblock_ops</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LVB operations.  <a href="structldlm__valblock__ops.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__ns__bucket.html">ldlm_ns_bucket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__namespace.html">ldlm_namespace</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LDLM Namespace.  <a href="structldlm__namespace.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__glimpse__work.html">ldlm_glimpse_work</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Work list for sending GL ASTs to multiple locks.  <a href="structldlm__glimpse__work.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__interval.html">ldlm_interval</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interval node data for each LDLM_EXTENT lock.  <a href="structldlm__interval.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__interval__tree.html">ldlm_interval_tree</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interval tree for extent locks.  <a href="structldlm__interval__tree.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__flock.html">ldlm_flock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__lock.html">ldlm_lock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LDLM lock structure.  <a href="structldlm__lock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__resource.html">ldlm_resource</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LDLM resource description.  <a href="structldlm__resource.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__ast__work.html">ldlm_ast_work</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common ldlm_enqueue parameters.  <a href="structldlm__enqueue__info.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__callback__suite.html">ldlm_callback_suite</a></td></tr>
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__iterator.html">Lock iterators</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>LDLM provides for a way to iterate through every lock on a resource or namespace or every resource in a namespace. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html">Default AST handlers for local locks</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>These AST handlers are typically used for server-side local locks and are also used by client-side lock handlers to perform minimum level base processing. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html">API to operate on locks from actual LDLM users.</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>These are typically used by client and server (*_local versions) to obtain and release locks. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__pools.html">Various LDLM pool related functions</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>There are not used outside of ldlm. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga281358eddc378923c68a44476ad434ae"></a><!-- doxytag: member="LDLM::OBD_LDLM_DEVICENAME" ref="ga281358eddc378923c68a44476ad434ae" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBD_LDLM_DEVICENAME</b>&nbsp;&nbsp;&nbsp;&quot;ldlm&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac60d99ba1ee452e88e798028c77a6ee2"></a><!-- doxytag: member="LDLM::LDLM_DEFAULT_LRU_SIZE" ref="gac60d99ba1ee452e88e798028c77a6ee2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_DEFAULT_LRU_SIZE</b>&nbsp;&nbsp;&nbsp;(100 * num_online_cpus())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9aa31582e16bd5db20efd0ad4ba2922e"></a><!-- doxytag: member="LDLM::LDLM_DEFAULT_MAX_ALIVE" ref="ga9aa31582e16bd5db20efd0ad4ba2922e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_DEFAULT_MAX_ALIVE</b>&nbsp;&nbsp;&nbsp;(cfs_time_seconds(3900))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad0d5691a254c18afb27cbe41e96e18dc"></a><!-- doxytag: member="LDLM::LDLM_CTIME_AGE_LIMIT" ref="gad0d5691a254c18afb27cbe41e96e18dc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_CTIME_AGE_LIMIT</b>&nbsp;&nbsp;&nbsp;(10)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a89bf73dae43048239ae31f0f4f776f"></a><!-- doxytag: member="LDLM::LDLM_DEFAULT_PARALLEL_AST_LIMIT" ref="ga8a89bf73dae43048239ae31f0f4f776f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_DEFAULT_PARALLEL_AST_LIMIT</b>&nbsp;&nbsp;&nbsp;1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gac91b29eaa6987e07656d85e9e139ca3f">LDLM_CB_BLOCKING</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The blocking callback is overloaded to perform two functions.  <a href="#gac91b29eaa6987e07656d85e9e139ca3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5d94274920487243f51d4942f163b947"></a><!-- doxytag: member="LDLM::LDLM_CB_CANCELING" ref="ga5d94274920487243f51d4942f163b947" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_CB_CANCELING</b>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga051e68d1bff6a791da6164eda988c466"></a><!-- doxytag: member="LDLM::DLM_OST_NAMESPACE" ref="ga051e68d1bff6a791da6164eda988c466" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DLM_OST_NAMESPACE</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae53cad77171aae681bc27e8cf30fda42"></a><!-- doxytag: member="LDLM::DLM_MDS_NAMESPACE" ref="gae53cad77171aae681bc27e8cf30fda42" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DLM_MDS_NAMESPACE</b>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gadbb6d2680a2d2d7ab15623b03f058edc">LDLM_POOLS_THREAD_PERIOD</a>&nbsp;&nbsp;&nbsp;(1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One second for pools thread check interval.  <a href="#gadbb6d2680a2d2d7ab15623b03f058edc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga7712344fc932485bff52275c2193484a">LDLM_POOLS_MODEST_MARGIN_SHIFT</a>&nbsp;&nbsp;&nbsp;(4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">~6% margin for modest pools.  <a href="#ga7712344fc932485bff52275c2193484a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga41802548f309704722be627a3d83e310">LDLM_POOL_SRV_DEF_RECALC_PERIOD</a>&nbsp;&nbsp;&nbsp;(1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default recalc period for server side pools in sec.  <a href="#ga41802548f309704722be627a3d83e310"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga032adcd4a0ffd13b0425ae6dc9fb4033">LDLM_POOL_CLI_DEF_RECALC_PERIOD</a>&nbsp;&nbsp;&nbsp;(10)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default recalc period for client side pools in sec.  <a href="#ga032adcd4a0ffd13b0425ae6dc9fb4033"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79f569c8af2bddcadd03bb0f5252c5a5"></a><!-- doxytag: member="LDLM::NS_DEFAULT_MAX_NOLOCK_BYTES" ref="ga79f569c8af2bddcadd03bb0f5252c5a5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga79f569c8af2bddcadd03bb0f5252c5a5">NS_DEFAULT_MAX_NOLOCK_BYTES</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default values for the "max_nolock_size", "contention_time" and "contended_locks" namespace tunables. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga222ec4eb7473a27407d03b6219387330"></a><!-- doxytag: member="LDLM::NS_DEFAULT_CONTENTION_SECONDS" ref="ga222ec4eb7473a27407d03b6219387330" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>NS_DEFAULT_CONTENTION_SECONDS</b>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04cc41bb0ea0cb2dbb2b743ddef676d3"></a><!-- doxytag: member="LDLM::NS_DEFAULT_CONTENDED_LOCKS" ref="ga04cc41bb0ea0cb2dbb2b743ddef676d3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>NS_DEFAULT_CONTENDED_LOCKS</b>&nbsp;&nbsp;&nbsp;32</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga003105401547ae27f8ae4d9b4c232f27">LDLM_GL_WORK_NOFREE</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structldlm__glimpse__work.html" title="Work list for sending GL ASTs to multiple locks.">ldlm_glimpse_work</a> is allocated on the stack and should not be freed.  <a href="#ga003105401547ae27f8ae4d9b4c232f27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae83cd198e77c1f09846f131fd1b76dee"></a><!-- doxytag: member="LDLM::to_ldlm_interval" ref="gae83cd198e77c1f09846f131fd1b76dee" args="(n)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>to_ldlm_interval</b>(n)&nbsp;&nbsp;&nbsp;container_of(n, struct <a class="el" href="structldlm__interval.html">ldlm_interval</a>, li_node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga5eaa516285c80b8a6bb5f879fa3191b9">LUSTRE_TRACKS_LOCK_EXP_REFS</a>&nbsp;&nbsp;&nbsp;(0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether to track references to exports by LDLM locks.  <a href="#ga5eaa516285c80b8a6bb5f879fa3191b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga23d29567f6cc8a2df9416fe89a728b0e"></a><!-- doxytag: member="LDLM::LDLM_GID_ANY" ref="ga23d29567f6cc8a2df9416fe89a728b0e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga23d29567f6cc8a2df9416fe89a728b0e">LDLM_GID_ANY</a>&nbsp;&nbsp;&nbsp;((__u64)-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LDLM_GID_ANY is used to match any group id in <a class="el" href="group__LDLM.html#ga1373811e4c4edbb039f1da1ca7947b03" title="Attempt to find a lock with specified properties.">ldlm_lock_match()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5d4a0edfc41ee022966d492b8fa6bf0d"></a><!-- doxytag: member="LDLM::l_transno" ref="ga5d4a0edfc41ee022966d492b8fa6bf0d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga5d4a0edfc41ee022966d492b8fa6bf0d">l_transno</a>&nbsp;&nbsp;&nbsp;l_client_cookie</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For uncommitted cross-MDT lock, store transno this lock belongs to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga23707c2e0c762c2638ee3bfa714f74de">l_slc_link</a>&nbsp;&nbsp;&nbsp;l_rk_ast</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For uncommitted cross-MDT lock, which is client lock, share with l_rk_ast which is for server.  <a href="#ga23707c2e0c762c2638ee3bfa714f74de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc5fbacf11637d2acac3440b4dbe56f6"></a><!-- doxytag: member="LDLM::ei_res_id" ref="gacc5fbacf11637d2acac3440b4dbe56f6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ei_res_id</b>&nbsp;&nbsp;&nbsp;ei_cb_gl</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gae27210c0d51e6f38e3b5f2ff08793f97">LDLM_DEBUG_NOLOCK</a>(format, a...)&nbsp;&nbsp;&nbsp;CDEBUG(D_DLMTRACE, &quot;### &quot; format &quot;\n&quot; , ##a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Just a fancy CDEBUG call with log level preset to LDLM_DEBUG.  <a href="#gae27210c0d51e6f38e3b5f2ff08793f97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga1e2b479743aab3ba4119e5c751a6f188">LDLM_DEBUG_LIMIT</a>(mask, lock, fmt, a...)&nbsp;&nbsp;&nbsp;((void)0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Support function for lock information printing into debug logs.  <a href="#ga1e2b479743aab3ba4119e5c751a6f188"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8d04218a1ba26d32ea36a1f5aebc505"></a><!-- doxytag: member="LDLM::LDLM_DEBUG" ref="gad8d04218a1ba26d32ea36a1f5aebc505" args="(lock, fmt, a...)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_DEBUG</b>(lock, fmt, a...)&nbsp;&nbsp;&nbsp;((void)0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga658466373582d350c15ffa570d598c35"></a><!-- doxytag: member="LDLM::LDLM_ERROR" ref="ga658466373582d350c15ffa570d598c35" args="(lock, fmt, a...)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_ERROR</b>(lock, fmt, a...)&nbsp;&nbsp;&nbsp;((void)0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gae6f33fb4095ce2a0e694892623aee022">LDLM_ITER_CONTINUE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return values for lock iterators.  <a href="#gae6f33fb4095ce2a0e694892623aee022"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7232aeca0a992a2e812f6d639de7ea6b"></a><!-- doxytag: member="LDLM::LDLM_ITER_STOP" ref="ga7232aeca0a992a2e812f6d639de7ea6b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_ITER_STOP</b>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga597fb61624bdd33a92ba76a5a67679d4"></a><!-- doxytag: member="LDLM::LDLM_LOCK_REF_DEL" ref="ga597fb61624bdd33a92ba76a5a67679d4" args="(lock)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_LOCK_REF_DEL</b>(lock)&nbsp;&nbsp;&nbsp;lu_ref_del(&amp;lock-&gt;l_reference, &quot;handle&quot;, current)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f">LDLM_LOCK_PUT</a>(lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a temporary lock reference obtained by ldlm_handle2lock() or <a class="el" href="group__LDLM.html#gabac2ce09f8215c4f05a3a8113fa72545" title="Obtain a lock reference by handle.">__ldlm_handle2lock()</a>.  <a href="#ga5945b4d89a157c2e0fb6d955b3bf0c3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaf3357d35be5378aa299677e298c5a625">LDLM_LOCK_RELEASE</a>(lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a lock reference obtained by some other means (see <a class="el" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT()</a>).  <a href="#gaf3357d35be5378aa299677e298c5a625"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_LOCK_GET</b>(lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_lock_list_put</b>(head, member, count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_RESOURCE_ADDREF</b>(res)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LDLM_RESOURCE_DELREF</b>(res)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07447890235da125e60400b2dee48626"></a><!-- doxytag: member="LDLM::ldlm_res_policy" ref="ga07447890235da125e60400b2dee48626" args=")(struct ldlm_namespace *, struct ldlm_lock **, void *req_cookie, enum ldlm_mode mode, __u64 flags, void *data)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_res_policy</b> )(struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> **, void *req_cookie, enum ldlm_mode mode, __u64 flags, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab397db2317d35a64df513cd6072de20c"></a><!-- doxytag: member="LDLM::ldlm_cancel_cbt" ref="gab397db2317d35a64df513cd6072de20c" args=")(struct ldlm_lock *lock)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_cancel_cbt</b> )(struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gac111233b56bdf7a4767dcd7a2f15b378">ldlm_blocking_callback</a> )(struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, struct <a class="el" href="structldlm__lock__desc.html">ldlm_lock_desc</a> *new, void *data, int flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for blocking callback function of a lock.  <a href="#gac111233b56bdf7a4767dcd7a2f15b378"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gac03b996dc38f767ddd9b2f5ae779b257">ldlm_completion_callback</a> )(struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, __u64 flags, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for completion callback function of a lock.  <a href="#gac03b996dc38f767ddd9b2f5ae779b257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga6e5c291246d5e6fb302d99a6111cb03d">ldlm_glimpse_callback</a> )(struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for glimpse callback function of a lock.  <a href="#ga6e5c291246d5e6fb302d99a6111cb03d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b5fe8de6c014f23ce08ae949daef596"></a><!-- doxytag: member="LDLM::ldlm_processing_policy" ref="ga4b5fe8de6c014f23ce08ae949daef596" args=")(struct ldlm_lock *lock, __u64 *flags, int first_enq, enum ldlm_error *err, struct list_head *work_list)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_processing_policy</b> )(struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, __u64 *flags, int first_enq, enum <a class="el" href="group__LDLM.html#gaa2fbd012972eb2b2d0653c8df02964f7">ldlm_error</a> *err, struct <a class="el" href="structlist__head.html">list_head</a> *work_list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga755fb40aeaf77f3a7d1591645ce49ce3"></a><!-- doxytag: member="LDLM::ldlm_iterator_t" ref="ga755fb40aeaf77f3a7d1591645ce49ce3" args=")(struct ldlm_lock *, void *)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_iterator_t</b> )(struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc68d2afc94858f99c2d2306f8285273"></a><!-- doxytag: member="LDLM::ldlm_res_iterator_t" ref="gadc68d2afc94858f99c2d2306f8285273" args=")(struct ldlm_resource *, void *)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_res_iterator_t</b> )(struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *, void *)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaa2fbd012972eb2b2d0653c8df02964f7">ldlm_error</a> { <br/>
&nbsp;&nbsp;<b>ELDLM_OK</b> =  0, 
<b>ELDLM_LOCK_MATCHED</b> =  1, 
<b>ELDLM_LOCK_CHANGED</b> =  300, 
<b>ELDLM_LOCK_ABORTED</b> =  301, 
<br/>
&nbsp;&nbsp;<b>ELDLM_LOCK_REPLACED</b> =  302, 
<b>ELDLM_NO_LOCK_DATA</b> =  303, 
<b>ELDLM_LOCK_WOULDBLOCK</b> =  304, 
<b>ELDLM_NAMESPACE_EXISTS</b> =  400, 
<br/>
&nbsp;&nbsp;<b>ELDLM_BAD_NAMESPACE</b> =  401
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>LDLM non-error return states. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gac4b4584603b76e6cc86c82a64f59defd">ldlm_side</a> { <b>LDLM_NAMESPACE_SERVER</b> =  0x01, 
<b>LDLM_NAMESPACE_CLIENT</b> =  0x02
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>LDLM namespace type. </p>
 <a href="group__LDLM.html#gac4b4584603b76e6cc86c82a64f59defd">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gafcd8eee315d3a7e1313596efd678d77e">ldlm_appetite</a> { <b>LDLM_NAMESPACE_GREEDY</b> =  1 &lt;&lt; 0, 
<b>LDLM_NAMESPACE_MODEST</b> =  1 &lt;&lt; 1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>LDLM pools related, type of lock pool in the namespace. </p>
 <a href="group__LDLM.html#gafcd8eee315d3a7e1313596efd678d77e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__LDLM.html#ggae8a3b6a5d0d3244ed73924ab2421a0d0ac9ce485ce53eddc4df436c8df18871e4">LDLM_NSS_LOCKS</a> =  0, 
<b>LDLM_NSS_LAST</b>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga516147f10f1ca82e556a7f8c3ee5d6ff">ldlm_ns_type</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffaf5e8bcf861bcd7b236cb287da70a974e">LDLM_NS_TYPE_UNKNOWN</a> =  0, 
<a class="el" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffaabe8a36130ca1ffe942ad581cc3b7d50">LDLM_NS_TYPE_MDC</a>, 
<a class="el" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffa6f51895209e33fae55026bc462d17ed1">LDLM_NS_TYPE_MDT</a>, 
<a class="el" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffab42df29b6de6da3b65b3db2496efe009">LDLM_NS_TYPE_OSC</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffabaac77dbb962ddbffeb7d4092d38c141">LDLM_NS_TYPE_OST</a>, 
<a class="el" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffabdcaf331de52005bd3c5c67979a44601">LDLM_NS_TYPE_MGC</a>, 
<a class="el" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffa8fcb201d020caf855369cdcb8796ec9b">LDLM_NS_TYPE_MGT</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> { <b>LCF_ASYNC</b> =  0x1, 
<b>LCF_LOCAL</b> =  0x2, 
<b>LCF_BL_AST</b> =  0x4
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Cancel flags. </p>
 <a href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>lvb_type</b> { <b>LVB_T_NONE</b> =  0, 
<b>LVB_T_OST</b> =  1, 
<b>LVB_T_LQUOTA</b> =  2, 
<b>LVB_T_LAYOUT</b> =  3
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gade643efde1936c79a28d8a944592c5c0">lock_res_type</a> { <b>LRT_NORMAL</b>, 
<b>LRT_NEW</b>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>"Modes" of acquiring lock_res, necessary to tell lockdep that taking more than one lock_res is dead-lock safe. </p>
<br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82466f1300e6e9395e768b7336c0ac46"></a><!-- doxytag: member="LDLM::ldlm_convert_policy_to_wire" ref="ga82466f1300e6e9395e768b7336c0ac46" args="(enum ldlm_type type, const union ldlm_policy_data *lpolicy, union ldlm_wire_policy_data *wpolicy)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga82466f1300e6e9395e768b7336c0ac46">ldlm_convert_policy_to_wire</a> (enum ldlm_type type, const union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *lpolicy, union <a class="el" href="unionldlm__wire__policy__data.html">ldlm_wire_policy_data</a> *wpolicy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts lock policy from local format to on the wire lock_desc format. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0f272b273065dc0d916fcb5c6b61d656"></a><!-- doxytag: member="LDLM::ldlm_convert_policy_to_local" ref="ga0f272b273065dc0d916fcb5c6b61d656" args="(struct obd_export *exp, enum ldlm_type type, const union ldlm_wire_policy_data *wpolicy, union ldlm_policy_data *lpolicy)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga0f272b273065dc0d916fcb5c6b61d656">ldlm_convert_policy_to_local</a> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp, enum ldlm_type type, const union <a class="el" href="unionldlm__wire__policy__data.html">ldlm_wire_policy_data</a> *wpolicy, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *lpolicy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts lock policy from on the wire lock_desc format to local format. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3450a8071d042dd92be8f2a9177e112"></a><!-- doxytag: member="LDLM::ldlm_it2str" ref="gad3450a8071d042dd92be8f2a9177e112" args="(enum ldlm_intent_flags it)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_it2str</b> (enum ldlm_intent_flags it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga878ffb8d1a87e3787eb2bb6170fed457"></a><!-- doxytag: member="LDLM::ldlm_replay_locks" ref="ga878ffb8d1a87e3787eb2bb6170fed457" args="(struct obd_import *imp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_replay_locks</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga921f8d85541cbe1fa330b9a12080103f">ldlm_flock_completion_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, __u64 flags, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flock completion callback function.  <a href="#ga921f8d85541cbe1fa330b9a12080103f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa9bd1ddd8fa94d5bb36d9ab2499148f3"></a><!-- doxytag: member="LDLM::ldlm_extent_shift_kms" ref="gaa9bd1ddd8fa94d5bb36d9ab2499148f3" args="(struct ldlm_lock *lock, __u64 old_kms)" -->
__u64&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_extent_shift_kms</b> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, __u64 old_kms)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2efedea3f32b10e36e3bcf7dc9aa44d2"></a><!-- doxytag: member="LDLM::ldlm_del_waiting_lock" ref="ga2efedea3f32b10e36e3bcf7dc9aa44d2" args="(struct ldlm_lock *lock)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_del_waiting_lock</b> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3d835ffc8ea5737e46381b9772cc224"></a><!-- doxytag: member="LDLM::ldlm_refresh_waiting_lock" ref="gad3d835ffc8ea5737e46381b9772cc224" args="(struct ldlm_lock *lock, int timeout)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_refresh_waiting_lock</b> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2582912f032081101820c56da0dbfb76"></a><!-- doxytag: member="LDLM::ldlm_get_ref" ref="ga2582912f032081101820c56da0dbfb76" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_get_ref</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabab5acbe0d24c0a37be4893ae6e00dcf"></a><!-- doxytag: member="LDLM::ldlm_put_ref" ref="gabab5acbe0d24c0a37be4893ae6e00dcf" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_put_ref</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1ae45d9f2b5213f12d150a3806e03b4"></a><!-- doxytag: member="LDLM::ldlm_init_export" ref="gaa1ae45d9f2b5213f12d150a3806e03b4" args="(struct obd_export *exp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_init_export</b> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga20871b8557c0afe94cb45c2d64cbd31f"></a><!-- doxytag: member="LDLM::ldlm_destroy_export" ref="ga20871b8557c0afe94cb45c2d64cbd31f" args="(struct obd_export *exp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_destroy_export</b> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad7430abbe52b72b069536f6f99336d94"></a><!-- doxytag: member="LDLM::ldlm_request_lock" ref="gad7430abbe52b72b069536f6f99336d94" args="(struct ptlrpc_request *req)" -->
struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_request_lock</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70d54ed9384416cd5e19fc593dac071f"></a><!-- doxytag: member="LDLM::ldlm_register_intent" ref="ga70d54ed9384416cd5e19fc593dac071f" args="(struct ldlm_namespace *ns, ldlm_res_policy arg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_register_intent</b> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, ldlm_res_policy arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35362f3605ec8dec52464f153c932c85"></a><!-- doxytag: member="LDLM::ldlm_lock2handle" ref="ga35362f3605ec8dec52464f153c932c85" args="(const struct ldlm_lock *lock, struct lustre_handle *lockh)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga35362f3605ec8dec52464f153c932c85">ldlm_lock2handle</a> (const struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills in handle for LDLM lock <em>lock</em> into supplied <em>lockh</em> Does not take any references. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gabac2ce09f8215c4f05a3a8113fa72545">__ldlm_handle2lock</a> (const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *, __u64 flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a lock reference by handle.  <a href="#gabac2ce09f8215c4f05a3a8113fa72545"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0a466989372b56e3cde1edae472be066"></a><!-- doxytag: member="LDLM::ldlm_cancel_callback" ref="ga0a466989372b56e3cde1edae472be066" args="(struct ldlm_lock *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga0a466989372b56e3cde1edae472be066">ldlm_cancel_callback</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to call blocking AST for LDLM lock <em>lock</em> in a "cancelling" mode. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f23553f0695eacc8686c25985aa564d"></a><!-- doxytag: member="LDLM::ldlm_lock_remove_from_lru" ref="ga7f23553f0695eacc8686c25985aa564d" args="(struct ldlm_lock *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_lock_remove_from_lru</b> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga098ec9c63984ffbe25f17174b376b1a0"></a><!-- doxytag: member="LDLM::ldlm_lock_set_data" ref="ga098ec9c63984ffbe25f17174b376b1a0" args="(const struct lustre_handle *lockh, void *data)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga098ec9c63984ffbe25f17174b376b1a0">ldlm_lock_set_data</a> (const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set opaque data into the lock that only makes sense to upper layer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga7dac0446d813ef65c24c0831b6d1a519">ldlm_error2errno</a> (enum <a class="el" href="group__LDLM.html#gaa2fbd012972eb2b2d0653c8df02964f7">ldlm_error</a> error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rather arbitrary mapping from LDLM error codes to errno values.  <a href="#ga7dac0446d813ef65c24c0831b6d1a519"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9d483fecb156d6db20dc2bfc1d6f11be"></a><!-- doxytag: member="LDLM::ldlm_errno2error" ref="ga9d483fecb156d6db20dc2bfc1d6f11be" args="(int err_no)" -->
enum <a class="el" href="group__LDLM.html#gaa2fbd012972eb2b2d0653c8df02964f7">ldlm_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga9d483fecb156d6db20dc2bfc1d6f11be">ldlm_errno2error</a> (int err_no)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dual to <a class="el" href="group__LDLM.html#ga7dac0446d813ef65c24c0831b6d1a519" title="Rather arbitrary mapping from LDLM error codes to errno values.">ldlm_error2errno()</a>: maps errno values back to enum ldlm_error. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gac526504450a40715c8e25fbab715689e">ldlm_lock_get</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference on a lock.  <a href="#gac526504450a40715c8e25fbab715689e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga5e363707438fb69f9253f2ab8bf4c5e6">ldlm_lock_put</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release lock reference.  <a href="#ga5e363707438fb69f9253f2ab8bf4c5e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga833125f7d72f8e77cb16c031c56dd2a0">ldlm_lock_destroy</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a LDLM lock <em>lock</em>.  <a href="#ga833125f7d72f8e77cb16c031c56dd2a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7b4cfac056355ba992b1b7d9bfbaa25b"></a><!-- doxytag: member="LDLM::ldlm_lock2desc" ref="ga7b4cfac056355ba992b1b7d9bfbaa25b" args="(struct ldlm_lock *lock, struct ldlm_lock_desc *desc)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga7b4cfac056355ba992b1b7d9bfbaa25b">ldlm_lock2desc</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, struct <a class="el" href="structldlm__lock__desc.html">ldlm_lock_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill in "on the wire" representation for given LDLM lock into supplied lock descriptor <em>desc</em> structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga2d77135057c3b9123a3ae5704752c946">ldlm_lock_addref</a> (const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, enum ldlm_mode mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add specified reader/writer reference to LDLM lock with handle <em>lockh</em>.  <a href="#ga2d77135057c3b9123a3ae5704752c946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga580d951cff91ebd5c1d2a7588d4c2ea3">ldlm_lock_addref_try</a> (const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, enum ldlm_mode mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to add reader/writer reference to a lock with handle <em>lockh</em>, and fails if lock is already LDLM_FL_CBPENDING or destroyed.  <a href="#ga580d951cff91ebd5c1d2a7588d4c2ea3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82ed1d0d1d2788cad8813e69df77d625"></a><!-- doxytag: member="LDLM::ldlm_lock_decref" ref="ga82ed1d0d1d2788cad8813e69df77d625" args="(const struct lustre_handle *lockh, enum ldlm_mode mode)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625">ldlm_lock_decref</a> (const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, enum ldlm_mode mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease reader/writer refcount for LDLM lock with handle <em>lockh</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad236a9af5f0845e1046060a55419914b"></a><!-- doxytag: member="LDLM::ldlm_lock_decref_and_cancel" ref="gad236a9af5f0845e1046060a55419914b" args="(const struct lustre_handle *lockh, enum ldlm_mode mode)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gad236a9af5f0845e1046060a55419914b">ldlm_lock_decref_and_cancel</a> (const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, enum ldlm_mode mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease reader/writer refcount for LDLM lock with handle <em>lockh</em> and mark it for subsequent cancellation once r/w refcount drops to zero instead of putting into LRU. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f34c3286a49d3d2f1e4b16029647a5b"></a><!-- doxytag: member="LDLM::ldlm_lock_fail_match_locked" ref="ga3f34c3286a49d3d2f1e4b16029647a5b" args="(struct ldlm_lock *lock)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_lock_fail_match_locked</b> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae911593eccfe0aa5995935808b646d2a"></a><!-- doxytag: member="LDLM::ldlm_lock_fail_match" ref="gae911593eccfe0aa5995935808b646d2a" args="(struct ldlm_lock *lock)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_lock_fail_match</b> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga9e8b401ed51dda94f553670e73872135">ldlm_lock_allow_match</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark lock as "matchable" by OST.  <a href="#ga9e8b401ed51dda94f553670e73872135"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gab9c1d858901b9d9a4db13ffbad095fb6">ldlm_lock_allow_match_locked</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark lock as "matchable" by OST.  <a href="#gab9c1d858901b9d9a4db13ffbad095fb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum ldlm_mode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga1373811e4c4edbb039f1da1ca7947b03">ldlm_lock_match</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, __u64 flags, const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *, enum ldlm_type type, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *, enum ldlm_mode mode, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *, int unref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to find a lock with specified properties.  <a href="#ga1373811e4c4edbb039f1da1ca7947b03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga396833924edeb2118df4fdff47aa7489"></a><!-- doxytag: member="LDLM::ldlm_revalidate_lock_handle" ref="ga396833924edeb2118df4fdff47aa7489" args="(const struct lustre_handle *lockh, __u64 *bits)" -->
enum ldlm_mode&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_revalidate_lock_handle</b> (const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, __u64 *bits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaeeab5a5dbe0a5b966d52f388b69eed3f">ldlm_lock_convert</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, enum ldlm_mode new_mode, __u32 *flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to convert already granted lock to a different mode.  <a href="#gaeeab5a5dbe0a5b966d52f388b69eed3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga1ae32c9c745cefc485fd39cf0054e2ef">ldlm_lock_downgrade</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, enum ldlm_mode new_mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Downgrade an exclusive lock.  <a href="#ga1ae32c9c745cefc485fd39cf0054e2ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadec8a773eb3b13c995cf35a4d013393b"></a><!-- doxytag: member="LDLM::ldlm_lock_cancel" ref="gadec8a773eb3b13c995cf35a4d013393b" args="(struct ldlm_lock *lock)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gadec8a773eb3b13c995cf35a4d013393b">ldlm_lock_cancel</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to cancel LDLM lock <em>lock</em> that has no reader/writer references. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga6fea368fc4ea7002b0dcd068bbe8771a">ldlm_reprocess_all</a> (struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *res)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to grant all waiting locks on a resource.  <a href="#ga6fea368fc4ea7002b0dcd068bbe8771a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a893da5c75236bb6f573e2484d4eecc"></a><!-- doxytag: member="LDLM::ldlm_reprocess_all_ns" ref="ga6a893da5c75236bb6f573e2484d4eecc" args="(struct ldlm_namespace *ns)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga6a893da5c75236bb6f573e2484d4eecc">ldlm_reprocess_all_ns</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate through all resources on a namespace attempting to grant waiting locks. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga5f3ca6b2c348db5cd17b45c0e2b99ba8">ldlm_lock_dump_handle</a> (int level, const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print lock with lock handle <em>lockh</em> description into debug log.  <a href="#ga5f3ca6b2c348db5cd17b45c0e2b99ba8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaff973b12d9e531ff04c69b478d6750cb"></a><!-- doxytag: member="LDLM::ldlm_unlink_lock_skiplist" ref="gaff973b12d9e531ff04c69b478d6750cb" args="(struct ldlm_lock *req)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaff973b12d9e531ff04c69b478d6750cb">ldlm_unlink_lock_skiplist</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove skiplist-enabled LDLM lock <em>req</em> from granted list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b345e88ea06fc28c099254650b75c38"></a><!-- doxytag: member="LDLM::ldlm_namespace_new" ref="ga4b345e88ea06fc28c099254650b75c38" args="(struct obd_device *obd, char *name, enum ldlm_side client, enum ldlm_appetite apt, enum ldlm_ns_type ns_type)" -->
struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga4b345e88ea06fc28c099254650b75c38">ldlm_namespace_new</a> (struct <a class="el" href="structobd__device.html">obd_device</a> *obd, char *name, enum <a class="el" href="group__LDLM.html#gac4b4584603b76e6cc86c82a64f59defd">ldlm_side</a> client, enum <a class="el" href="group__LDLM.html#gafcd8eee315d3a7e1313596efd678d77e">ldlm_appetite</a> apt, enum <a class="el" href="group__LDLM.html#ga516147f10f1ca82e556a7f8c3ee5d6ff">ldlm_ns_type</a> ns_type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialize new empty namespace. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gacfe66a2d51a46f0bf611952a83119bbc">ldlm_namespace_cleanup</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, __u64 flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel and destroy all locks in the namespace.  <a href="#gacfe66a2d51a46f0bf611952a83119bbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaa7271dfc42956d8d75b2435a22c83832">ldlm_namespace_free_prior</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structobd__import.html">obd_import</a> *imp, int force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs various cleanups for passed <em>ns</em> to make it drop refc and be ready for freeing.  <a href="#gaa7271dfc42956d8d75b2435a22c83832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga10faf90111f6da7206f8b140b8d98fed">ldlm_namespace_free_post</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs freeing memory structures related to <em>ns</em>.  <a href="#ga10faf90111f6da7206f8b140b8d98fed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga9f9b87f84a794b96c043799f3840765c">ldlm_namespace_free</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structobd__import.html">obd_import</a> *imp, int force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleanup the resource, and free namespace.  <a href="#ga9f9b87f84a794b96c043799f3840765c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1403410a2012b2c625b74126ffcb2089"></a><!-- doxytag: member="LDLM::ldlm_namespace_register" ref="ga1403410a2012b2c625b74126ffcb2089" args="(struct ldlm_namespace *ns, enum ldlm_side client)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga1403410a2012b2c625b74126ffcb2089">ldlm_namespace_register</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, enum <a class="el" href="group__LDLM.html#gac4b4584603b76e6cc86c82a64f59defd">ldlm_side</a> client)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register <em>ns</em> in the list of namespaces. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaf842bf901a93420ecbc2365d778b3a4b">ldlm_namespace_unregister</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, enum <a class="el" href="group__LDLM.html#gac4b4584603b76e6cc86c82a64f59defd">ldlm_side</a> client)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister <em>ns</em> from the list of namespaces.  <a href="#gaf842bf901a93420ecbc2365d778b3a4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1399afd082a31b5066cefa9093eec736"></a><!-- doxytag: member="LDLM::ldlm_namespace_get" ref="ga1399afd082a31b5066cefa9093eec736" args="(struct ldlm_namespace *ns)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_namespace_get</b> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2418ea6dcbcd76ad54666a106b23b891"></a><!-- doxytag: member="LDLM::ldlm_namespace_put" ref="ga2418ea6dcbcd76ad54666a106b23b891" args="(struct ldlm_namespace *ns)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_namespace_put</b> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8047d7cda49f6bf14c41a5105c55a378"></a><!-- doxytag: member="LDLM::ldlm_proc_setup" ref="ga8047d7cda49f6bf14c41a5105c55a378" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_proc_setup</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga083fb1ea92619c4b2e526633c3a486fb">ldlm_resource_get</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *parent, const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *, enum ldlm_type type, int create)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to resource with given name, creating it if necessary.  <a href="#ga083fb1ea92619c4b2e526633c3a486fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41b0bd74d466ccd76abb0adfcc3fbe8a"></a><!-- doxytag: member="LDLM::ldlm_resource_getref" ref="ga41b0bd74d466ccd76abb0adfcc3fbe8a" args="(struct ldlm_resource *res)" -->
struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_resource_getref</b> (struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *res)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9ba8220d356d680f204b8882db1c50c9"></a><!-- doxytag: member="LDLM::ldlm_resource_putref" ref="ga9ba8220d356d680f204b8882db1c50c9" args="(struct ldlm_resource *res)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_resource_putref</b> (struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *res)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee0426408b282c2c2606c218f79dcd9a"></a><!-- doxytag: member="LDLM::ldlm_resource_add_lock" ref="gaee0426408b282c2c2606c218f79dcd9a" args="(struct ldlm_resource *res, struct list_head *head, struct ldlm_lock *lock)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaee0426408b282c2c2606c218f79dcd9a">ldlm_resource_add_lock</a> (struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *res, struct <a class="el" href="structlist__head.html">list_head</a> *head, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a lock into a given resource into specified lock list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga12496ecd5cca95892b66801ab8428b97"></a><!-- doxytag: member="LDLM::ldlm_resource_unlink_lock" ref="ga12496ecd5cca95892b66801ab8428b97" args="(struct ldlm_lock *lock)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_resource_unlink_lock</b> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb1efc6cf4a9e128dd2a25c78685f2de"></a><!-- doxytag: member="LDLM::ldlm_res2desc" ref="gadb1efc6cf4a9e128dd2a25c78685f2de" args="(struct ldlm_resource *res, struct ldlm_resource_desc *desc)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_res2desc</b> (struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *res, struct <a class="el" href="structldlm__resource__desc.html">ldlm_resource_desc</a> *desc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70a63f0359188ff0526655c7c664ef1d"></a><!-- doxytag: member="LDLM::ldlm_dump_all_namespaces" ref="ga70a63f0359188ff0526655c7c664ef1d" args="(enum ldlm_side client, int level)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga70a63f0359188ff0526655c7c664ef1d">ldlm_dump_all_namespaces</a> (enum <a class="el" href="group__LDLM.html#gac4b4584603b76e6cc86c82a64f59defd">ldlm_side</a> client, int level)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print information about all locks in all namespaces on this node to debug log. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72eedaa0c612fbc5daad8d622e0502f1"></a><!-- doxytag: member="LDLM::ldlm_namespace_dump" ref="ga72eedaa0c612fbc5daad8d622e0502f1" args="(int level, struct ldlm_namespace *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga72eedaa0c612fbc5daad8d622e0502f1">ldlm_namespace_dump</a> (int level, struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print information about all locks in this namespace on this node to debug log. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6abb0daf1a4f9af18526f4a14c5fbf0c"></a><!-- doxytag: member="LDLM::ldlm_resource_dump" ref="ga6abb0daf1a4f9af18526f4a14c5fbf0c" args="(int level, struct ldlm_resource *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga6abb0daf1a4f9af18526f4a14c5fbf0c">ldlm_resource_dump</a> (int level, struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print information about all locks in this resource to debug log. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gafd6a07a826f7d2789696e472dd81adc2">ldlm_lock_change_resource</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *, const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves LDLM lock <em>lock</em> to another resource.  <a href="#gafd6a07a826f7d2789696e472dd81adc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc8dcde45df7d4bea889736aca442600"></a><!-- doxytag: member="LDLM::ldlm_expired_completion_wait" ref="gadc8dcde45df7d4bea889736aca442600" args="(void *data)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_expired_completion_wait</b> (void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga372b1e5c9e8be8bd6bbd2c3e279ec146"></a><!-- doxytag: member="LDLM::intent_disposition" ref="ga372b1e5c9e8be8bd6bbd2c3e279ec146" args="(struct ldlm_reply *rep, int flag)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>intent_disposition</b> (struct <a class="el" href="structldlm__reply.html">ldlm_reply</a> *rep, int flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b01cf0ee883cc9a25d74ca83032a529"></a><!-- doxytag: member="LDLM::intent_set_disposition" ref="ga3b01cf0ee883cc9a25d74ca83032a529" args="(struct ldlm_reply *rep, int flag)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>intent_set_disposition</b> (struct <a class="el" href="structldlm__reply.html">ldlm_reply</a> *rep, int flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9">lock_res_and_lock</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a lock and its resource.  <a href="#ga7ea7aa073d254d8500c07d2664cbecf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf9b19facd1a8bb3cdfcac5047159f15e"></a><!-- doxytag: member="LDLM::unlock_res_and_lock" ref="gaf9b19facd1a8bb3cdfcac5047159f15e" args="(struct ldlm_lock *lock)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e">unlock_res_and_lock</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a lock and its resource previously locked with lock_res_and_lock. <br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3cf0131341b6663da454ede83009988b"></a><!-- doxytag: member="LDLM::lck_compat_array" ref="ga3cf0131341b6663da454ede83009988b" args="[]" -->
enum ldlm_mode&nbsp;</td><td class="memItemRight" valign="bottom"><b>lck_compat_array</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga84fad911c326a86839530f221c86f7e7"></a><!-- doxytag: member="LDLM::ldlm_obd_ops" ref="ga84fad911c326a86839530f221c86f7e7" args="" -->
struct <a class="el" href="structobd__ops.html">obd_ops</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_obd_ops</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaacf06e33756d242222391e67857d6e14"></a><!-- doxytag: member="LDLM::ldlm_lockname" ref="gaacf06e33756d242222391e67857d6e14" args="[]" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_lockname</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ec36144688c37580c1c66f547ba3c08"></a><!-- doxytag: member="LDLM::ldlm_typename" ref="ga0ec36144688c37580c1c66f547ba3c08" args="[]" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_typename</b> []</td></tr>
<tr><td colspan="2"><h2>Lock Compatibility Matrix.</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpde75a3e2d89e27903c98ccee5d444afa"></a>A lock has both a type (extent, flock, inode bits, or plain) and a mode.</p>
<p>Lock types are described in their respective implementation files: ldlm_{extent,flock,inodebits,plain}.c.</p>
<p>There are six lock modes along with a compatibility matrix to indicate if two locks are compatible.</p>
<ul>
<li>EX: Exclusive mode. Before a new file is created, MDS requests EX lock on the parent.</li>
<li>PW: Protective Write (normal write) mode. When a client requests a write lock from an OST, a lock with PW mode will be issued.</li>
<li>PR: Protective Read (normal read) mode. When a client requests a read from an OST, a lock with PR mode will be issued. Also, if the client opens a file for execution, it is granted a lock with PR mode.</li>
<li>CW: Concurrent Write mode. The type of lock that the MDS grants if a client requests a write lock during a file open operation.</li>
<li>CR Concurrent Read mode. When a client performs a path lookup, MDS grants an inodebit lock with the CR mode on the intermediate path component.</li>
<li>NL Null mode.</li>
</ul>
<pre>
       NL  CR  CW  PR  PW  EX
  NL    1   1   1   1   1   1
  CR    1   1   1   1   1   0
  CW    1   1   1   0   0   0
  PR    1   1   0   1   0   0
  PW    1   1   0   0   0   0
  EX    1   0   0   0   0   0
 </pre> <br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga646c49fc0ba78c1d5b30d7ef0b6fcc64">LCK_COMPAT_EX</a>&nbsp;&nbsp;&nbsp;LCK_NL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0770471a8652e45673670fea9548e43b"></a><!-- doxytag: member="LDLM::LCK_COMPAT_PW" ref="ga0770471a8652e45673670fea9548e43b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LCK_COMPAT_PW</b>&nbsp;&nbsp;&nbsp;(LCK_COMPAT_EX | LCK_CR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74166fe3a7e2cf51787984249cffe774"></a><!-- doxytag: member="LDLM::LCK_COMPAT_PR" ref="ga74166fe3a7e2cf51787984249cffe774" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LCK_COMPAT_PR</b>&nbsp;&nbsp;&nbsp;(LCK_COMPAT_PW | LCK_PR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga972ad785641586babf8f2b9c07db438f"></a><!-- doxytag: member="LDLM::LCK_COMPAT_CW" ref="ga972ad785641586babf8f2b9c07db438f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LCK_COMPAT_CW</b>&nbsp;&nbsp;&nbsp;(LCK_COMPAT_PW | LCK_CW)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d0f660e4e3edea1831b6216c617b3a7"></a><!-- doxytag: member="LDLM::LCK_COMPAT_CR" ref="ga0d0f660e4e3edea1831b6216c617b3a7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LCK_COMPAT_CR</b>&nbsp;&nbsp;&nbsp;(LCK_COMPAT_CW | LCK_PR | LCK_PW)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga47b10c6ee643a2e1c1710814e425008f"></a><!-- doxytag: member="LDLM::LCK_COMPAT_NL" ref="ga47b10c6ee643a2e1c1710814e425008f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LCK_COMPAT_NL</b>&nbsp;&nbsp;&nbsp;(LCK_COMPAT_CR | LCK_EX | LCK_GROUP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24e6e4b3c28390e97d02f7852d804297"></a><!-- doxytag: member="LDLM::LCK_COMPAT_GROUP" ref="ga24e6e4b3c28390e97d02f7852d804297" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LCK_COMPAT_GROUP</b>&nbsp;&nbsp;&nbsp;(LCK_GROUP | LCK_NL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac19878e62234fb5258f7c8761a3e4d61"></a><!-- doxytag: member="LDLM::LCK_COMPAT_COS" ref="gac19878e62234fb5258f7c8761a3e4d61" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LCK_COMPAT_COS</b>&nbsp;&nbsp;&nbsp;(LCK_COS)</td></tr>
<tr><td colspan="2"><h2>flags</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp4e5868d676cb634aa75b125a0f741abf"></a>The flags and collections of flags (masks) for</p>
<dl class="see"><dt><b>See also:</b></dt><dd>struct <a class="el" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a>. </dd></dl>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4c476a01ccda6b86755b0ea2825d7d4"></a><!-- doxytag: member="LDLM::LDLM_FL_ALL_FLAGS_MASK" ref="gad4c476a01ccda6b86755b0ea2825d7d4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gad4c476a01ccda6b86755b0ea2825d7d4">LDLM_FL_ALL_FLAGS_MASK</a>&nbsp;&nbsp;&nbsp;0x00FFFFFFC08F932FULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">l_flags bits marked as "all_flags" bits <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79f84ccf0096f82e1153bb5646c4a4d6"></a><!-- doxytag: member="LDLM::LDLM_FL_LOCK_CHANGED" ref="ga79f84ccf0096f82e1153bb5646c4a4d6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga79f84ccf0096f82e1153bb5646c4a4d6">LDLM_FL_LOCK_CHANGED</a>&nbsp;&nbsp;&nbsp;0x0000000000000001ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">extent, mode, or resource changed <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaff23b1afc481fda943d8487fac8eb047"></a><!-- doxytag: member="LDLM::ldlm_is_lock_changed" ref="gaff23b1afc481fda943d8487fac8eb047" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_lock_changed</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt;  0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82d504378e8b1d65a835a79152748f53"></a><!-- doxytag: member="LDLM::ldlm_set_lock_changed" ref="ga82d504378e8b1d65a835a79152748f53" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_lock_changed</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt;  0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga649010d0b83059be3940476ce896f464"></a><!-- doxytag: member="LDLM::ldlm_clear_lock_changed" ref="ga649010d0b83059be3940476ce896f464" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_lock_changed</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt;  0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2">LDLM_FL_BLOCK_GRANTED</a>&nbsp;&nbsp;&nbsp;0x0000000000000002ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Server placed lock on granted list, or a recovering client wants the lock added to the granted list, no questions asked.  <a href="#ga2c6bbb5a5fb8a17d596ecaba494aa7d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9c47b874204dac128040e1657cf8d91b"></a><!-- doxytag: member="LDLM::ldlm_is_block_granted" ref="ga9c47b874204dac128040e1657cf8d91b" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_block_granted</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt;  1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga779c8f83ccfcd61abea9771b55ad8a56"></a><!-- doxytag: member="LDLM::ldlm_set_block_granted" ref="ga779c8f83ccfcd61abea9771b55ad8a56" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_block_granted</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt;  1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2cc2fe0b9eb806ceaf0b9eb35442d9f6"></a><!-- doxytag: member="LDLM::ldlm_clear_block_granted" ref="ga2cc2fe0b9eb806ceaf0b9eb35442d9f6" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_block_granted</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt;  1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga912be807748854a27fde8d99ab122dc2">LDLM_FL_BLOCK_CONV</a>&nbsp;&nbsp;&nbsp;0x0000000000000004ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Server placed lock on conv list, or a recovering client wants the lock added to the conv list, no questions asked.  <a href="#ga912be807748854a27fde8d99ab122dc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabc904a075732b018f974ba7a5295f8f"></a><!-- doxytag: member="LDLM::ldlm_is_block_conv" ref="gaabc904a075732b018f974ba7a5295f8f" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_block_conv</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt;  2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7691070837359cb8e8e16ee3dad6e353"></a><!-- doxytag: member="LDLM::ldlm_set_block_conv" ref="ga7691070837359cb8e8e16ee3dad6e353" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_block_conv</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt;  2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa4e6f906aec77ce6071712f1f98b8c1"></a><!-- doxytag: member="LDLM::ldlm_clear_block_conv" ref="gaaa4e6f906aec77ce6071712f1f98b8c1" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_block_conv</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt;  2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaf787c22790fe3d611cd92199be25dd19">LDLM_FL_BLOCK_WAIT</a>&nbsp;&nbsp;&nbsp;0x0000000000000008ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Server placed lock on wait list, or a recovering client wants the lock added to the wait list, no questions asked.  <a href="#gaf787c22790fe3d611cd92199be25dd19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga973b7c56eaf5f397ac45f27853e7e79f"></a><!-- doxytag: member="LDLM::ldlm_is_block_wait" ref="ga973b7c56eaf5f397ac45f27853e7e79f" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_block_wait</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt;  3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2158f1c3045fa2970d6feb793314995a"></a><!-- doxytag: member="LDLM::ldlm_set_block_wait" ref="ga2158f1c3045fa2970d6feb793314995a" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_block_wait</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt;  3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8df760dc9316ae28f4fa66dab92c1f60"></a><!-- doxytag: member="LDLM::ldlm_clear_block_wait" ref="ga8df760dc9316ae28f4fa66dab92c1f60" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_block_wait</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt;  3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga3fb0e46d8dcf09f83494412e8cb5d588">LDLM_FL_AST_SENT</a>&nbsp;&nbsp;&nbsp;0x0000000000000020ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">blocking or cancel packet was queued for sending.  <a href="#ga3fb0e46d8dcf09f83494412e8cb5d588"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab62f7929418e41f69892278ca2a2bba0"></a><!-- doxytag: member="LDLM::ldlm_is_ast_sent" ref="gab62f7929418e41f69892278ca2a2bba0" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_ast_sent</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt;  5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4459ec2a203f7d86097155ded2b55ee6"></a><!-- doxytag: member="LDLM::ldlm_set_ast_sent" ref="ga4459ec2a203f7d86097155ded2b55ee6" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_ast_sent</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt;  5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a881944ad35592fb4ee3c29a433d6ae"></a><!-- doxytag: member="LDLM::ldlm_clear_ast_sent" ref="ga9a881944ad35592fb4ee3c29a433d6ae" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_ast_sent</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt;  5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga4210c27164df8fc68b15a5c6f88d3063">LDLM_FL_REPLAY</a>&nbsp;&nbsp;&nbsp;0x0000000000000100ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock is being replayed.  <a href="#ga4210c27164df8fc68b15a5c6f88d3063"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7c664dab7f5faa023093942b65ab6b23"></a><!-- doxytag: member="LDLM::ldlm_is_replay" ref="ga7c664dab7f5faa023093942b65ab6b23" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_replay</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt;  8)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8cc9ba6a0568a0fa36cf0d0669185dd"></a><!-- doxytag: member="LDLM::ldlm_set_replay" ref="gaa8cc9ba6a0568a0fa36cf0d0669185dd" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_replay</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt;  8)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5e16d6fd3f10a9fd5335bf7c1596c16"></a><!-- doxytag: member="LDLM::ldlm_clear_replay" ref="gac5e16d6fd3f10a9fd5335bf7c1596c16" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_replay</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt;  8)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga423c3fc60972417ed98ea9124cdae163">LDLM_FL_INTENT_ONLY</a>&nbsp;&nbsp;&nbsp;0x0000000000000200ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Don't grant lock, just do intent.  <a href="#ga423c3fc60972417ed98ea9124cdae163"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad86120436504cad63e6a672234011b21"></a><!-- doxytag: member="LDLM::ldlm_is_intent_only" ref="gad86120436504cad63e6a672234011b21" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_intent_only</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt;  9)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5522f52af5b1f744f66e1bcdc55ad2c"></a><!-- doxytag: member="LDLM::ldlm_set_intent_only" ref="gad5522f52af5b1f744f66e1bcdc55ad2c" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_intent_only</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt;  9)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf0dd7c3c1fd21cd8314f0cc4ac2a139"></a><!-- doxytag: member="LDLM::ldlm_clear_intent_only" ref="gabf0dd7c3c1fd21cd8314f0cc4ac2a139" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_intent_only</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt;  9)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71a692568def3030f14e3a56f51eacc2"></a><!-- doxytag: member="LDLM::LDLM_FL_HAS_INTENT" ref="ga71a692568def3030f14e3a56f51eacc2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga71a692568def3030f14e3a56f51eacc2">LDLM_FL_HAS_INTENT</a>&nbsp;&nbsp;&nbsp;0x0000000000001000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock request has intent <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0614281afd9fd8d52b1397d93ca0ce2a"></a><!-- doxytag: member="LDLM::ldlm_is_has_intent" ref="ga0614281afd9fd8d52b1397d93ca0ce2a" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_has_intent</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 12)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadcd131921eac33013ad7c34c37444557"></a><!-- doxytag: member="LDLM::ldlm_set_has_intent" ref="gadcd131921eac33013ad7c34c37444557" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_has_intent</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 12)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6bf94fc518423d69a91c37577e575f86"></a><!-- doxytag: member="LDLM::ldlm_clear_has_intent" ref="ga6bf94fc518423d69a91c37577e575f86" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_has_intent</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 12)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga563e13b57ba8a8c2cf4801660334d35d"></a><!-- doxytag: member="LDLM::LDLM_FL_FLOCK_DEADLOCK" ref="ga563e13b57ba8a8c2cf4801660334d35d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga563e13b57ba8a8c2cf4801660334d35d">LDLM_FL_FLOCK_DEADLOCK</a>&nbsp;&nbsp;&nbsp;0x0000000000008000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">flock deadlock detected <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7b0e5fbe0e62ecda174187118d2c9ce2"></a><!-- doxytag: member="LDLM::ldlm_is_flock_deadlock" ref="ga7b0e5fbe0e62ecda174187118d2c9ce2" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_flock_deadlock</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 15)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82dffd503bdf56054744254c54345ab8"></a><!-- doxytag: member="LDLM::ldlm_set_flock_deadlock" ref="ga82dffd503bdf56054744254c54345ab8" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_flock_deadlock</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 15)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac74982ddc5a69206df4fbb85f7c72e86"></a><!-- doxytag: member="LDLM::ldlm_clear_flock_deadlock" ref="gac74982ddc5a69206df4fbb85f7c72e86" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_flock_deadlock</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 15)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae90502de9395d7874082193d36611053"></a><!-- doxytag: member="LDLM::LDLM_FL_DISCARD_DATA" ref="gae90502de9395d7874082193d36611053" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gae90502de9395d7874082193d36611053">LDLM_FL_DISCARD_DATA</a>&nbsp;&nbsp;&nbsp;0x0000000000010000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">discard (no writeback) on cancel <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7fcf88e1d975071d9eebf367aa9c6d5c"></a><!-- doxytag: member="LDLM::ldlm_is_discard_data" ref="ga7fcf88e1d975071d9eebf367aa9c6d5c" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_discard_data</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 16)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1fcda5e154caa22af1ad60fdf2e0b06"></a><!-- doxytag: member="LDLM::ldlm_set_discard_data" ref="gab1fcda5e154caa22af1ad60fdf2e0b06" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_discard_data</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 16)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb8161d30da91eb1a4970e7682440cdb"></a><!-- doxytag: member="LDLM::ldlm_clear_discard_data" ref="gabb8161d30da91eb1a4970e7682440cdb" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_discard_data</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 16)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4df4a9b0f96c19fcdbd88c767b92cfe3"></a><!-- doxytag: member="LDLM::LDLM_FL_NO_TIMEOUT" ref="ga4df4a9b0f96c19fcdbd88c767b92cfe3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga4df4a9b0f96c19fcdbd88c767b92cfe3">LDLM_FL_NO_TIMEOUT</a>&nbsp;&nbsp;&nbsp;0x0000000000020000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Blocked by group lock - wait indefinitely. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga578593a6a1c0707427c231f7ce413faf"></a><!-- doxytag: member="LDLM::ldlm_is_no_timeout" ref="ga578593a6a1c0707427c231f7ce413faf" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_no_timeout</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 17)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga140b6c4b5684017ae84afed9324fde44"></a><!-- doxytag: member="LDLM::ldlm_set_no_timeout" ref="ga140b6c4b5684017ae84afed9324fde44" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_no_timeout</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 17)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8ec923ef49ec233445dc18a64448bf57"></a><!-- doxytag: member="LDLM::ldlm_clear_no_timeout" ref="ga8ec923ef49ec233445dc18a64448bf57" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_no_timeout</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 17)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga34a11c94b46a7cd00e464a9063ff3879">LDLM_FL_BLOCK_NOWAIT</a>&nbsp;&nbsp;&nbsp;0x0000000000040000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Server told not to wait if blocked.  <a href="#ga34a11c94b46a7cd00e464a9063ff3879"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga18742375606df585379a379ab9ddae83"></a><!-- doxytag: member="LDLM::ldlm_is_block_nowait" ref="ga18742375606df585379a379ab9ddae83" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_block_nowait</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 18)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacee4620434ad52c895a506b803b3f149"></a><!-- doxytag: member="LDLM::ldlm_set_block_nowait" ref="gacee4620434ad52c895a506b803b3f149" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_block_nowait</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 18)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa59d400b2c912384c2c531419eef1ffb"></a><!-- doxytag: member="LDLM::ldlm_clear_block_nowait" ref="gaa59d400b2c912384c2c531419eef1ffb" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_block_nowait</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 18)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58e627c7337b75f31e5879803c02d7f5"></a><!-- doxytag: member="LDLM::LDLM_FL_TEST_LOCK" ref="ga58e627c7337b75f31e5879803c02d7f5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5">LDLM_FL_TEST_LOCK</a>&nbsp;&nbsp;&nbsp;0x0000000000080000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return blocking lock <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6248a5aef4f62ab807060a21f7fb9f92"></a><!-- doxytag: member="LDLM::ldlm_is_test_lock" ref="ga6248a5aef4f62ab807060a21f7fb9f92" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_test_lock</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 19)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad450843c02c2370e1552213d971a466d"></a><!-- doxytag: member="LDLM::ldlm_set_test_lock" ref="gad450843c02c2370e1552213d971a466d" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_test_lock</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 19)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga31a6e824141572d0a64f228988ae36d0"></a><!-- doxytag: member="LDLM::ldlm_clear_test_lock" ref="ga31a6e824141572d0a64f228988ae36d0" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_test_lock</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 19)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ac6aa7bab27701ec8d953219626df95"></a><!-- doxytag: member="LDLM::LDLM_FL_MATCH_LOCK" ref="ga6ac6aa7bab27701ec8d953219626df95" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga6ac6aa7bab27701ec8d953219626df95">LDLM_FL_MATCH_LOCK</a>&nbsp;&nbsp;&nbsp;0x0000000000100000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">match lock only <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga71cf8c345c175dcb2f9b8713e8b2bf00">LDLM_FL_CANCEL_ON_BLOCK</a>&nbsp;&nbsp;&nbsp;0x0000000000800000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Immediatelly cancel such locks when they block some other locks.  <a href="#ga71cf8c345c175dcb2f9b8713e8b2bf00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73119e9c11597e56dbb17bb8202f0707"></a><!-- doxytag: member="LDLM::ldlm_is_cancel_on_block" ref="ga73119e9c11597e56dbb17bb8202f0707" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_cancel_on_block</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 23)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8860e90a297fa3f61b43725e1342a47b"></a><!-- doxytag: member="LDLM::ldlm_set_cancel_on_block" ref="ga8860e90a297fa3f61b43725e1342a47b" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_cancel_on_block</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 23)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf923c2d29e2d294f8d9e6d1ed19d0eb0"></a><!-- doxytag: member="LDLM::ldlm_clear_cancel_on_block" ref="gaf923c2d29e2d294f8d9e6d1ed19d0eb0" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_cancel_on_block</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 23)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga0b1ea8608da80462dc9948160ebe5cdc">LDLM_FL_COS_INCOMPAT</a>&nbsp;&nbsp;&nbsp;0x0000000001000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag whether a lock is enqueued from a distributed transaction, and the requesting lock mode is PW/EX, if so, it will check compatibility with COS locks, and different from original COS semantic, transactions from the same client is also treated as lock conflict.  <a href="#ga0b1ea8608da80462dc9948160ebe5cdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1443982a9767db12a97505d177434c90"></a><!-- doxytag: member="LDLM::ldlm_is_cos_incompat" ref="ga1443982a9767db12a97505d177434c90" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_cos_incompat</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG((_l), 1ULL &lt;&lt; 24)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga95f858294d4e46e79a669cb0ace58663"></a><!-- doxytag: member="LDLM::ldlm_set_cos_incompat" ref="ga95f858294d4e46e79a669cb0ace58663" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_cos_incompat</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((_l), 1ULL &lt;&lt; 24)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6dfa5f908f7f3776efcea79d0f29d762"></a><!-- doxytag: member="LDLM::ldlm_clear_cos_incompat" ref="ga6dfa5f908f7f3776efcea79d0f29d762" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_cos_incompat</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 24)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38083448d90777d7741c673dbcf70a94"></a><!-- doxytag: member="LDLM::LDLM_FL_DENY_ON_CONTENTION" ref="ga38083448d90777d7741c673dbcf70a94" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga38083448d90777d7741c673dbcf70a94">LDLM_FL_DENY_ON_CONTENTION</a>&nbsp;&nbsp;&nbsp;0x0000000040000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">measure lock contention and return -EUSERS if locking contention is high <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac6147e3315d99418b2d6b3b3b630f2ac"></a><!-- doxytag: member="LDLM::ldlm_is_deny_on_contention" ref="gac6147e3315d99418b2d6b3b3b630f2ac" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_deny_on_contention</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 30)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85029d0b6047061906198d0c51015991"></a><!-- doxytag: member="LDLM::ldlm_set_deny_on_contention" ref="ga85029d0b6047061906198d0c51015991" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_deny_on_contention</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 30)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f57a763161f4a4f8716c703fc5441d5"></a><!-- doxytag: member="LDLM::ldlm_clear_deny_on_contention" ref="ga9f57a763161f4a4f8716c703fc5441d5" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_deny_on_contention</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 30)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga28476345c80ee86025d566e9e7c432b9"></a><!-- doxytag: member="LDLM::LDLM_FL_AST_DISCARD_DATA" ref="ga28476345c80ee86025d566e9e7c432b9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga28476345c80ee86025d566e9e7c432b9">LDLM_FL_AST_DISCARD_DATA</a>&nbsp;&nbsp;&nbsp;0x0000000080000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These are flags that are mapped into the flags and ASTs of blocking locks Add FL_DISCARD to blocking ASTs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7bfe9401ff4041d82224f7d9fd5a8482"></a><!-- doxytag: member="LDLM::ldlm_is_ast_discard_data" ref="ga7bfe9401ff4041d82224f7d9fd5a8482" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_ast_discard_data</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 31)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe1cc46d9650a5e6d82c06a29c159e26"></a><!-- doxytag: member="LDLM::ldlm_set_ast_discard_data" ref="gafe1cc46d9650a5e6d82c06a29c159e26" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_ast_discard_data</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 31)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeef5a5406be3d635276f1dd9630ce559"></a><!-- doxytag: member="LDLM::ldlm_clear_ast_discard_data" ref="gaeef5a5406be3d635276f1dd9630ce559" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_ast_discard_data</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 31)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga6fc806ac2146cf3505a29a50fd6b75a9">LDLM_FL_FAIL_LOC</a>&nbsp;&nbsp;&nbsp;0x0000000100000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for marking lock as a target for -EINTR while cp_ast sleep emulation + race with upcoming bl_ast.  <a href="#ga6fc806ac2146cf3505a29a50fd6b75a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83cf5bbfe33014e79f316460af990d0f"></a><!-- doxytag: member="LDLM::ldlm_is_fail_loc" ref="ga83cf5bbfe33014e79f316460af990d0f" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_fail_loc</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 32)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9959f1bf5959d4735edf1126fb3ec9ea"></a><!-- doxytag: member="LDLM::ldlm_set_fail_loc" ref="ga9959f1bf5959d4735edf1126fb3ec9ea" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_fail_loc</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 32)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2459c6cc4da5cf0f7e7ca7f2260b2b44"></a><!-- doxytag: member="LDLM::ldlm_clear_fail_loc" ref="ga2459c6cc4da5cf0f7e7ca7f2260b2b44" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_fail_loc</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 32)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga09f2515df973bc9c1733ac4cec99eebb">LDLM_FL_SKIPPED</a>&nbsp;&nbsp;&nbsp;0x0000000200000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used while processing the unused list to know that we have already handled this lock and decided to skip it.  <a href="#ga09f2515df973bc9c1733ac4cec99eebb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga09b9e8e58911eac14982b28b2f55c44b"></a><!-- doxytag: member="LDLM::ldlm_is_skipped" ref="ga09b9e8e58911eac14982b28b2f55c44b" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_skipped</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 33)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga10634512888c4b543623f6822cf0b598"></a><!-- doxytag: member="LDLM::ldlm_set_skipped" ref="ga10634512888c4b543623f6822cf0b598" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_skipped</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 33)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4deb5f953bb86cc42ef265cdf32bf003"></a><!-- doxytag: member="LDLM::ldlm_clear_skipped" ref="ga4deb5f953bb86cc42ef265cdf32bf003" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_skipped</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 33)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3845b64e7040a6d03323e5289bd71adc"></a><!-- doxytag: member="LDLM::LDLM_FL_CBPENDING" ref="ga3845b64e7040a6d03323e5289bd71adc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga3845b64e7040a6d03323e5289bd71adc">LDLM_FL_CBPENDING</a>&nbsp;&nbsp;&nbsp;0x0000000400000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this lock is being destroyed <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43193bfc763430ef2aa1cf62ab70fb53"></a><!-- doxytag: member="LDLM::ldlm_is_cbpending" ref="ga43193bfc763430ef2aa1cf62ab70fb53" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_cbpending</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 34)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga027fc0a527a829ee53067e2dc1f726e0"></a><!-- doxytag: member="LDLM::ldlm_set_cbpending" ref="ga027fc0a527a829ee53067e2dc1f726e0" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_cbpending</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 34)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29713ca290c3e6a4982dbf101ef5c48b"></a><!-- doxytag: member="LDLM::ldlm_clear_cbpending" ref="ga29713ca290c3e6a4982dbf101ef5c48b" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_cbpending</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 34)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae36b9cddb3e68705d21f384ad3a3e1e6"></a><!-- doxytag: member="LDLM::LDLM_FL_WAIT_NOREPROC" ref="gae36b9cddb3e68705d21f384ad3a3e1e6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gae36b9cddb3e68705d21f384ad3a3e1e6">LDLM_FL_WAIT_NOREPROC</a>&nbsp;&nbsp;&nbsp;0x0000000800000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">not a real flag, not saved in lock <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac93e17f7ef1c3bcbdc6eb964b2fbd4d"></a><!-- doxytag: member="LDLM::ldlm_is_wait_noreproc" ref="gaac93e17f7ef1c3bcbdc6eb964b2fbd4d" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_wait_noreproc</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 35)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0eb44893de7ec7beef6d5dc5c40cc2a"></a><!-- doxytag: member="LDLM::ldlm_set_wait_noreproc" ref="gaf0eb44893de7ec7beef6d5dc5c40cc2a" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_wait_noreproc</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 35)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7debc0a316f795e18ca7f7acf491e508"></a><!-- doxytag: member="LDLM::ldlm_clear_wait_noreproc" ref="ga7debc0a316f795e18ca7f7acf491e508" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_wait_noreproc</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 35)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4572b427a57d005afd5bb1d6998966b1"></a><!-- doxytag: member="LDLM::LDLM_FL_CANCEL" ref="ga4572b427a57d005afd5bb1d6998966b1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga4572b427a57d005afd5bb1d6998966b1">LDLM_FL_CANCEL</a>&nbsp;&nbsp;&nbsp;0x0000001000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cancellation callback already run <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e254e67c9d5e30dcdebed85a929317b"></a><!-- doxytag: member="LDLM::ldlm_is_cancel" ref="ga8e254e67c9d5e30dcdebed85a929317b" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_cancel</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 36)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1455f1e0a776204e58a9ba541ef1df4a"></a><!-- doxytag: member="LDLM::ldlm_set_cancel" ref="ga1455f1e0a776204e58a9ba541ef1df4a" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_cancel</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 36)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab37fb493f16ceb215a65c0c1c1d6a641"></a><!-- doxytag: member="LDLM::ldlm_clear_cancel" ref="gab37fb493f16ceb215a65c0c1c1d6a641" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_cancel</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 36)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa938e2a5e2f72e996711b5c4ba8dd9fc"></a><!-- doxytag: member="LDLM::LDLM_FL_LOCAL_ONLY" ref="gaa938e2a5e2f72e996711b5c4ba8dd9fc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaa938e2a5e2f72e996711b5c4ba8dd9fc">LDLM_FL_LOCAL_ONLY</a>&nbsp;&nbsp;&nbsp;0x0000002000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">whatever it might mean -- never transmitted? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59d7f1e4366c08874123b7ff01fec2e4"></a><!-- doxytag: member="LDLM::ldlm_is_local_only" ref="ga59d7f1e4366c08874123b7ff01fec2e4" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_local_only</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 37)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9ff50503a54dc02b071cac02c759ebe"></a><!-- doxytag: member="LDLM::ldlm_set_local_only" ref="gab9ff50503a54dc02b071cac02c759ebe" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_local_only</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 37)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5bdb815fb3ce9a4ed869c61ad4a1c8f3"></a><!-- doxytag: member="LDLM::ldlm_clear_local_only" ref="ga5bdb815fb3ce9a4ed869c61ad4a1c8f3" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_local_only</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 37)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga932d0cd6d35eceab182f01ec135eef3f"></a><!-- doxytag: member="LDLM::LDLM_FL_FAILED" ref="ga932d0cd6d35eceab182f01ec135eef3f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga932d0cd6d35eceab182f01ec135eef3f">LDLM_FL_FAILED</a>&nbsp;&nbsp;&nbsp;0x0000004000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">don't run the cancel callback under ldlm_cli_cancel_unused <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga134eadd13e54392d473877fa17a99480"></a><!-- doxytag: member="LDLM::ldlm_is_failed" ref="ga134eadd13e54392d473877fa17a99480" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_failed</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 38)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b8a5b390db02bd12e40b4ed36128b3a"></a><!-- doxytag: member="LDLM::ldlm_set_failed" ref="ga3b8a5b390db02bd12e40b4ed36128b3a" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_failed</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 38)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7bffcf04b76de167e0ccd125ac8a8dc2"></a><!-- doxytag: member="LDLM::ldlm_clear_failed" ref="ga7bffcf04b76de167e0ccd125ac8a8dc2" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_failed</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 38)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2dfca50053d3cc6f54e5a980c4c76082"></a><!-- doxytag: member="LDLM::LDLM_FL_CANCELING" ref="ga2dfca50053d3cc6f54e5a980c4c76082" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga2dfca50053d3cc6f54e5a980c4c76082">LDLM_FL_CANCELING</a>&nbsp;&nbsp;&nbsp;0x0000008000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock cancel has already been sent <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81096d9ba93553f9b5cde134be5877e2"></a><!-- doxytag: member="LDLM::ldlm_is_canceling" ref="ga81096d9ba93553f9b5cde134be5877e2" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_canceling</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 39)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1bb6795e0e56604996d55b697f494459"></a><!-- doxytag: member="LDLM::ldlm_set_canceling" ref="ga1bb6795e0e56604996d55b697f494459" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_canceling</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 39)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f40de1f083b653ce0e2ee2437b1e1c4"></a><!-- doxytag: member="LDLM::ldlm_clear_canceling" ref="ga6f40de1f083b653ce0e2ee2437b1e1c4" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_canceling</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 39)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4346ef6efe6b430b0bc38976491fc84"></a><!-- doxytag: member="LDLM::LDLM_FL_LOCAL" ref="gad4346ef6efe6b430b0bc38976491fc84" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gad4346ef6efe6b430b0bc38976491fc84">LDLM_FL_LOCAL</a>&nbsp;&nbsp;&nbsp;0x0000010000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">local lock (ie, no srv/cli split) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc15d0f5e765ee7b4bafe289bb993c9f"></a><!-- doxytag: member="LDLM::ldlm_is_local" ref="gacc15d0f5e765ee7b4bafe289bb993c9f" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_local</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 40)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga736ca9f23df632e681be02324d6c0930"></a><!-- doxytag: member="LDLM::ldlm_set_local" ref="ga736ca9f23df632e681be02324d6c0930" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_local</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 40)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4083f16184de18d7b605b3c94f9e302"></a><!-- doxytag: member="LDLM::ldlm_clear_local" ref="gaf4083f16184de18d7b605b3c94f9e302" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_local</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 40)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga3af51d9e1097e0aeaacd1c3cc88fec62">LDLM_FL_LVB_READY</a>&nbsp;&nbsp;&nbsp;0x0000020000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XXX FIXME: This is being added to b_size as a low-risk fix to the fact that the LVB filling happens _after_ the lock has been granted, so another thread can match it before the LVB has been updated.  <a href="#ga3af51d9e1097e0aeaacd1c3cc88fec62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed5bff466beca77dbeade6f4c5726704"></a><!-- doxytag: member="LDLM::ldlm_is_lvb_ready" ref="gaed5bff466beca77dbeade6f4c5726704" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_lvb_ready</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 41)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ce6ecb0916ab03eb35c3f8edab8b329"></a><!-- doxytag: member="LDLM::ldlm_set_lvb_ready" ref="ga4ce6ecb0916ab03eb35c3f8edab8b329" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_lvb_ready</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 41)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd7c6970649184c616f396b4531a91ee"></a><!-- doxytag: member="LDLM::ldlm_clear_lvb_ready" ref="gacd7c6970649184c616f396b4531a91ee" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_lvb_ready</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 41)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaafdd093df952018e6f7acbbf8cad985b">LDLM_FL_KMS_IGNORE</a>&nbsp;&nbsp;&nbsp;0x0000040000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A lock contributes to the known minimum size (KMS) calculation until it has finished the part of its cancelation that performs write back on its dirty pages.  <a href="#gaafdd093df952018e6f7acbbf8cad985b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3ef14e4e8c865fd02181c0082c475dc"></a><!-- doxytag: member="LDLM::ldlm_is_kms_ignore" ref="gaf3ef14e4e8c865fd02181c0082c475dc" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_kms_ignore</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 42)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0e60a57328a2460fd4bb8e22f852ad78"></a><!-- doxytag: member="LDLM::ldlm_set_kms_ignore" ref="ga0e60a57328a2460fd4bb8e22f852ad78" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_kms_ignore</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 42)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a64c5397b30cfcc732e069003e6daf5"></a><!-- doxytag: member="LDLM::ldlm_clear_kms_ignore" ref="ga1a64c5397b30cfcc732e069003e6daf5" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_kms_ignore</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 42)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7259a0a7fa4504cb1b275d17f60e9641"></a><!-- doxytag: member="LDLM::LDLM_FL_CP_REQD" ref="ga7259a0a7fa4504cb1b275d17f60e9641" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga7259a0a7fa4504cb1b275d17f60e9641">LDLM_FL_CP_REQD</a>&nbsp;&nbsp;&nbsp;0x0000080000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">completion AST to be executed <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf785d0cee97d42a28f2868918830c6fb"></a><!-- doxytag: member="LDLM::ldlm_is_cp_reqd" ref="gaf785d0cee97d42a28f2868918830c6fb" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_cp_reqd</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 43)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6bfa8f5643c8d7d52675bc11afb2501e"></a><!-- doxytag: member="LDLM::ldlm_set_cp_reqd" ref="ga6bfa8f5643c8d7d52675bc11afb2501e" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_cp_reqd</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 43)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9cc599ed974d9b794332e9b39d6273af"></a><!-- doxytag: member="LDLM::ldlm_clear_cp_reqd" ref="ga9cc599ed974d9b794332e9b39d6273af" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_cp_reqd</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 43)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b38820179446c103f27d0da2a94c028"></a><!-- doxytag: member="LDLM::LDLM_FL_CLEANED" ref="ga5b38820179446c103f27d0da2a94c028" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga5b38820179446c103f27d0da2a94c028">LDLM_FL_CLEANED</a>&nbsp;&nbsp;&nbsp;0x0000100000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cleanup_resource has already handled the lock <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e7ea6cd9a438a76fdb3f4e64fe6b7ab"></a><!-- doxytag: member="LDLM::ldlm_is_cleaned" ref="ga8e7ea6cd9a438a76fdb3f4e64fe6b7ab" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_cleaned</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 44)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05f04ea5b9a6e868bba1a518b9dbe116"></a><!-- doxytag: member="LDLM::ldlm_set_cleaned" ref="ga05f04ea5b9a6e868bba1a518b9dbe116" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_cleaned</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 44)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga624fc38460b964fc708ddfac76db95d6"></a><!-- doxytag: member="LDLM::ldlm_clear_cleaned" ref="ga624fc38460b964fc708ddfac76db95d6" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_cleaned</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 44)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaf5ca91a80dd3fc578d5a9fc7fb815b74">LDLM_FL_ATOMIC_CB</a>&nbsp;&nbsp;&nbsp;0x0000200000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">optimization hint: LDLM can run blocking callback from current context w/o involving separate thread.  <a href="#gaf5ca91a80dd3fc578d5a9fc7fb815b74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae29299151b2559f1b361e60629217ad"></a><!-- doxytag: member="LDLM::ldlm_is_atomic_cb" ref="gaae29299151b2559f1b361e60629217ad" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_atomic_cb</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 45)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga585f9ffdbdb997584971f65cc5a2cf42"></a><!-- doxytag: member="LDLM::ldlm_set_atomic_cb" ref="ga585f9ffdbdb997584971f65cc5a2cf42" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_atomic_cb</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 45)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab62c1e6231ef2a0547518303f684509e"></a><!-- doxytag: member="LDLM::ldlm_clear_atomic_cb" ref="gab62c1e6231ef2a0547518303f684509e" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_atomic_cb</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 45)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga043b49bb5e4be85bb6a3937bb241aab1">LDLM_FL_BL_AST</a>&nbsp;&nbsp;&nbsp;0x0000400000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">It may happen that a client initiates two operations, e.g.  <a href="#ga043b49bb5e4be85bb6a3937bb241aab1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab40aaa76d1d92290eab3d4e9f9b013ce"></a><!-- doxytag: member="LDLM::ldlm_is_bl_ast" ref="gab40aaa76d1d92290eab3d4e9f9b013ce" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_bl_ast</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 46)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga709cdcdf17c6cf36bb25699a92edf8c9"></a><!-- doxytag: member="LDLM::ldlm_set_bl_ast" ref="ga709cdcdf17c6cf36bb25699a92edf8c9" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_bl_ast</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 46)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd6578ae29904b313f9b419980304181"></a><!-- doxytag: member="LDLM::ldlm_clear_bl_ast" ref="gafd6578ae29904b313f9b419980304181" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_bl_ast</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 46)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaef583898e5ca87d62c007b0a797f1f70">LDLM_FL_BL_DONE</a>&nbsp;&nbsp;&nbsp;0x0000800000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set by <a class="el" href="group__LDLM.html#ga0a466989372b56e3cde1edae472be066" title="Helper function to call blocking AST for LDLM lock lock in a &quot;cancelling&quot;...">ldlm_cancel_callback()</a> when lock cache is dropped to let ldlm_callback_handler() return EINVAL to the server.  <a href="#gaef583898e5ca87d62c007b0a797f1f70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7abc8519b7d186988adc9d7ae97f1741"></a><!-- doxytag: member="LDLM::ldlm_is_bl_done" ref="ga7abc8519b7d186988adc9d7ae97f1741" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_bl_done</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 47)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65a2c69bab1a1910e7aaec262d102828"></a><!-- doxytag: member="LDLM::ldlm_set_bl_done" ref="ga65a2c69bab1a1910e7aaec262d102828" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_bl_done</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 47)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0007fdaa295898e0192aa22d925afda1"></a><!-- doxytag: member="LDLM::ldlm_clear_bl_done" ref="ga0007fdaa295898e0192aa22d925afda1" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_bl_done</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 47)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga628bde1454443ba6f69043120c61acb9">LDLM_FL_NO_LRU</a>&nbsp;&nbsp;&nbsp;0x0001000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Don't put lock into the LRU list, so that it is not canceled due to aging.  <a href="#ga628bde1454443ba6f69043120c61acb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad81285aa9c1da0efc00da7a222975806"></a><!-- doxytag: member="LDLM::ldlm_is_no_lru" ref="gad81285aa9c1da0efc00da7a222975806" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_no_lru</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 48)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga950bb24d826f69faf0428634cd6c391c"></a><!-- doxytag: member="LDLM::ldlm_set_no_lru" ref="ga950bb24d826f69faf0428634cd6c391c" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_no_lru</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 48)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac13b65b4a0c6e897e36ed67a4e2e2097"></a><!-- doxytag: member="LDLM::ldlm_clear_no_lru" ref="gac13b65b4a0c6e897e36ed67a4e2e2097" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_no_lru</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 48)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga958240fb760018d3be665a8f0730b9c4">LDLM_FL_FAIL_NOTIFIED</a>&nbsp;&nbsp;&nbsp;0x0002000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set for locks that failed and where the server has been notified.  <a href="#ga958240fb760018d3be665a8f0730b9c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe3d376b307f7e3fe634dda3ea682131"></a><!-- doxytag: member="LDLM::ldlm_is_fail_notified" ref="gabe3d376b307f7e3fe634dda3ea682131" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_fail_notified</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 49)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c912c9c53a0937fa3f84b251025e245"></a><!-- doxytag: member="LDLM::ldlm_set_fail_notified" ref="ga4c912c9c53a0937fa3f84b251025e245" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_fail_notified</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 49)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a581e63032fc853a77eb0bf64a8ac4a"></a><!-- doxytag: member="LDLM::ldlm_clear_fail_notified" ref="ga7a581e63032fc853a77eb0bf64a8ac4a" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_fail_notified</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 49)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gaf74d13556ae1283f30228d20c497cfa8">LDLM_FL_DESTROYED</a>&nbsp;&nbsp;&nbsp;0x0004000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set for locks that were removed from class hash table and will be destroyed when last reference to them is released.  <a href="#gaf74d13556ae1283f30228d20c497cfa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa42d6481767a1729beb6c8e23dad96ea"></a><!-- doxytag: member="LDLM::ldlm_is_destroyed" ref="gaa42d6481767a1729beb6c8e23dad96ea" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_destroyed</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 50)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2d57af4742b5f8e68ff0962881ec391"></a><!-- doxytag: member="LDLM::ldlm_set_destroyed" ref="gac2d57af4742b5f8e68ff0962881ec391" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_destroyed</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 50)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga399a230cadef0a280fc699b93fcc6452"></a><!-- doxytag: member="LDLM::ldlm_clear_destroyed" ref="ga399a230cadef0a280fc699b93fcc6452" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_destroyed</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 50)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f201720943af861e6cfe2d0ef5a0ecf"></a><!-- doxytag: member="LDLM::LDLM_FL_SERVER_LOCK" ref="ga4f201720943af861e6cfe2d0ef5a0ecf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga4f201720943af861e6cfe2d0ef5a0ecf">LDLM_FL_SERVER_LOCK</a>&nbsp;&nbsp;&nbsp;0x0008000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">flag whether this is a server namespace lock <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaefed8e4293c5cbf21341e5d3b6af482e"></a><!-- doxytag: member="LDLM::ldlm_is_server_lock" ref="gaefed8e4293c5cbf21341e5d3b6af482e" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_server_lock</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 51)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga62001bc2dfedff189ccb0b575cbae129"></a><!-- doxytag: member="LDLM::ldlm_set_server_lock" ref="ga62001bc2dfedff189ccb0b575cbae129" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_server_lock</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 51)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga432487b59e9007c35b5219f6005920f1"></a><!-- doxytag: member="LDLM::ldlm_clear_server_lock" ref="ga432487b59e9007c35b5219f6005920f1" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_server_lock</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 51)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga080ded1bdce4915f2fd693eaf027f73f">LDLM_FL_RES_LOCKED</a>&nbsp;&nbsp;&nbsp;0x0010000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">It's set in <a class="el" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock()</a> and unset in <a class="el" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock()</a>.  <a href="#ga080ded1bdce4915f2fd693eaf027f73f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga90bc0fd0c6d2467778dd66329a070e5f"></a><!-- doxytag: member="LDLM::ldlm_is_res_locked" ref="ga90bc0fd0c6d2467778dd66329a070e5f" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_res_locked</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 52)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadcbced8b4756867913762470edd5a315"></a><!-- doxytag: member="LDLM::ldlm_set_res_locked" ref="gadcbced8b4756867913762470edd5a315" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_res_locked</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 52)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafdbd97aab8e1229a2c5ad8d5fc4ca5ed"></a><!-- doxytag: member="LDLM::ldlm_clear_res_locked" ref="gafdbd97aab8e1229a2c5ad8d5fc4ca5ed" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_res_locked</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 52)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga68ed1455a628dbdd814b21b50e455923">LDLM_FL_WAITED</a>&nbsp;&nbsp;&nbsp;0x0020000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">It's set once we call ldlm_add_waiting_lock_res_locked() to start the lock-timeout timer and it will never be reset.  <a href="#ga68ed1455a628dbdd814b21b50e455923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad0bc7d2f9026b7113847e8d2caa39562"></a><!-- doxytag: member="LDLM::ldlm_is_waited" ref="gad0bc7d2f9026b7113847e8d2caa39562" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_waited</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 53)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a43222f9825622a304f7bc5049a3b70"></a><!-- doxytag: member="LDLM::ldlm_set_waited" ref="ga1a43222f9825622a304f7bc5049a3b70" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_waited</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 53)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9802f5a74d47be01de0da224c633eb6"></a><!-- doxytag: member="LDLM::ldlm_clear_waited" ref="gad9802f5a74d47be01de0da224c633eb6" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_waited</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 53)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gacddab05dc5721dad535a55534eeb9234">LDLM_FL_NS_SRV</a>&nbsp;&nbsp;&nbsp;0x0040000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag whether this is a server namespace lock.  <a href="#gacddab05dc5721dad535a55534eeb9234"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga953f5fcbd58ad14fb6fbd150d8eacfc8"></a><!-- doxytag: member="LDLM::ldlm_is_ns_srv" ref="ga953f5fcbd58ad14fb6fbd150d8eacfc8" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_ns_srv</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 54)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4716ec80fd743545a4632ad220f795db"></a><!-- doxytag: member="LDLM::ldlm_set_ns_srv" ref="ga4716ec80fd743545a4632ad220f795db" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_ns_srv</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 54)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadfd41a6a0097fba092197478947dd99e"></a><!-- doxytag: member="LDLM::ldlm_clear_ns_srv" ref="gadfd41a6a0097fba092197478947dd99e" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_ns_srv</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 54)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga353cf18a1a7c41ccaf72d5c8bf71a129">LDLM_FL_EXCL</a>&nbsp;&nbsp;&nbsp;0x0080000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag whether this lock can be reused.  <a href="#ga353cf18a1a7c41ccaf72d5c8bf71a129"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a64f245838f42950fc52eff18dce5e7"></a><!-- doxytag: member="LDLM::ldlm_is_excl" ref="ga9a64f245838f42950fc52eff18dce5e7" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_excl</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG(( _l), 1ULL &lt;&lt; 55)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5bba3d22c5ba6c45a8319f75b42fddca"></a><!-- doxytag: member="LDLM::ldlm_set_excl" ref="ga5bba3d22c5ba6c45a8319f75b42fddca" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_excl</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((  _l), 1ULL &lt;&lt; 55)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7c105f3f44caa5b904252ff20c3e509a"></a><!-- doxytag: member="LDLM::ldlm_clear_excl" ref="ga7c105f3f44caa5b904252ff20c3e509a" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_clear_excl</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_CLEAR_FLAG((_l), 1ULL &lt;&lt; 55)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga6f5efeebb55b0f19c9403ae53405b424">LDLM_FL_RESENT</a>&nbsp;&nbsp;&nbsp;0x0100000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag whether a lock is found on server for re-sent RPC.  <a href="#ga6f5efeebb55b0f19c9403ae53405b424"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gac07f3063e5cf037bcfd71c86da494518">LDLM_FL_COS_ENABLED</a>&nbsp;&nbsp;&nbsp;0x0200000000000000ULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag whether Commit-on-Sharing is enabled, if LDLM_FL_COS_INCOMPAT is set this flag may not be set because once the former is set this flag won't be checked, and for cross-MDT lock COS_INCOMPAT is always set but ast handle is in ldlm context which doesn't know whether COS is enabled or not.  <a href="#gac07f3063e5cf037bcfd71c86da494518"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2fedc3f645ac443888603c0d55c17620"></a><!-- doxytag: member="LDLM::ldlm_is_cos_enabled" ref="ga2fedc3f645ac443888603c0d55c17620" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_is_cos_enabled</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_TEST_FLAG((_l), 1ULL &lt;&lt; 57)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e392ecba11d0501bfaa09d9da572c31"></a><!-- doxytag: member="LDLM::ldlm_set_cos_enabled" ref="ga8e392ecba11d0501bfaa09d9da572c31" args="(_l)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ldlm_set_cos_enabled</b>(_l)&nbsp;&nbsp;&nbsp;LDLM_SET_FLAG((_l), 1ULL &lt;&lt; 57)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga1321f3908418c02cb06351a16e1f2109">LDLM_FL_AST_MASK</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">l_flags bits marked as "ast" bits  <a href="#ga1321f3908418c02cb06351a16e1f2109"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga6316c2ca1fd038c2cc96402b744d16c9">LDLM_FL_BLOCKED_MASK</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">l_flags bits marked as "blocked" bits  <a href="#ga6316c2ca1fd038c2cc96402b744d16c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gadfabf01b5433e46225676763fd9b3611">LDLM_FL_GONE_MASK</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">l_flags bits marked as "gone" bits  <a href="#gadfabf01b5433e46225676763fd9b3611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga1a53232f696448d6586b6d66e973b9c6">LDLM_FL_INHERIT_MASK</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">l_flags bits marked as "inherit" bits  <a href="#ga1a53232f696448d6586b6d66e973b9c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga100f8e004856a4aa214a829dd7e3b42c">LDLM_FL_SRV_ENQ_MASK</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">flags returned in  parameter on ldlm_lock_enqueue, to be re-constructed on re-send  <a href="#ga100f8e004856a4aa214a829dd7e3b42c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a5e0653974bf9d9f69eafa8a1e1daa8"></a><!-- doxytag: member="LDLM::LDLM_TEST_FLAG" ref="ga2a5e0653974bf9d9f69eafa8a1e1daa8" args="(_l, _b)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga2a5e0653974bf9d9f69eafa8a1e1daa8">LDLM_TEST_FLAG</a>(_l, _b)&nbsp;&nbsp;&nbsp;(((_l)-&gt;l_flags &amp; (_b)) != 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">test for <a class="el" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> flag bit set <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga062ca8745e6e880e11a83540c17ff81c"></a><!-- doxytag: member="LDLM::LDLM_HAVE_MASK" ref="ga062ca8745e6e880e11a83540c17ff81c" args="(_l, _m)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga062ca8745e6e880e11a83540c17ff81c">LDLM_HAVE_MASK</a>(_l, _m)&nbsp;&nbsp;&nbsp;(((_l)-&gt;l_flags &amp; LDLM_FL_##_m##_MASK) != 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">multi-bit test: are any of mask bits set? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ded8bccac20ba7892e7733ceb7cdcb5"></a><!-- doxytag: member="LDLM::LDLM_SET_FLAG" ref="ga2ded8bccac20ba7892e7733ceb7cdcb5" args="(_l, _b)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga2ded8bccac20ba7892e7733ceb7cdcb5">LDLM_SET_FLAG</a>(_l, _b)&nbsp;&nbsp;&nbsp;((_l)-&gt;l_flags |= (_b))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set a <a class="el" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> flag bit <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3abf079d3e6069d3c0bc4334da16f2e1"></a><!-- doxytag: member="LDLM::LDLM_CLEAR_FLAG" ref="ga3abf079d3e6069d3c0bc4334da16f2e1" args="(_l, _b)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga3abf079d3e6069d3c0bc4334da16f2e1">LDLM_CLEAR_FLAG</a>(_l, _b)&nbsp;&nbsp;&nbsp;((_l)-&gt;l_flags &amp;= ~(_b))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clear a <a class="el" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> flag bit <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Lustre DLM is based on VAX DLM. </p>
<p>Its two main roles are:</p>
<ul>
<li>To provide locking assuring consistency of data on all Lustre nodes.</li>
<li>To allow clients to cache state protected by a lock by holding the lock until a conflicting lock is requested or it is expired by the LRU. </li>
</ul>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga23707c2e0c762c2638ee3bfa714f74de"></a><!-- doxytag: member="lustre_dlm.h::l_slc_link" ref="ga23707c2e0c762c2638ee3bfa714f74de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define l_slc_link&nbsp;&nbsp;&nbsp;l_rk_ast</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For uncommitted cross-MDT lock, which is client lock, share with l_rk_ast which is for server. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00909">909</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga646c49fc0ba78c1d5b30d7ef0b6fcc64"></a><!-- doxytag: member="lustre_dlm.h::LCK_COMPAT_EX" ref="ga646c49fc0ba78c1d5b30d7ef0b6fcc64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LCK_COMPAT_EX&nbsp;&nbsp;&nbsp;LCK_NL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00140">140</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac91b29eaa6987e07656d85e9e139ca3f"></a><!-- doxytag: member="lustre_dlm.h::LDLM_CB_BLOCKING" ref="gac91b29eaa6987e07656d85e9e139ca3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_CB_BLOCKING&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The blocking callback is overloaded to perform two functions. </p>
<p>These flags indicate which operation should be performed. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00103">103</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e2b479743aab3ba4119e5c751a6f188"></a><!-- doxytag: member="lustre_dlm.h::LDLM_DEBUG_LIMIT" ref="ga1e2b479743aab3ba4119e5c751a6f188" args="(mask, lock, fmt, a...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_DEBUG_LIMIT</td>
          <td>(</td>
          <td class="paramtype">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lock, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a...&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((void)0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Support function for lock information printing into debug logs. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>LDLM_DEBUG </dd></dl>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l01167">1167</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l02586">ldlm_lock_dump_handle()</a>, and <a class="el" href="ldlm__resource_8c_source.html#l01448">ldlm_resource_dump()</a>.</p>

</div>
</div>
<a class="anchor" id="gae27210c0d51e6f38e3b5f2ff08793f97"></a><!-- doxytag: member="lustre_dlm.h::LDLM_DEBUG_NOLOCK" ref="gae27210c0d51e6f38e3b5f2ff08793f97" args="(format, a...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_DEBUG_NOLOCK</td>
          <td>(</td>
          <td class="paramtype">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a...&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;CDEBUG(D_DLMTRACE, &quot;### &quot; format &quot;\n&quot; , ##a)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Just a fancy CDEBUG call with log level preset to LDLM_DEBUG. </p>
<p>For the cases where we do not have actual lock to print along with a debugging message that is ldlm-related </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l01122">1122</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01345">ldlm_cli_cancel()</a>, and <a class="el" href="ldlm__lock_8c_source.html#l01370">ldlm_lock_match()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1321f3908418c02cb06351a16e1f2109"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_AST_MASK" ref="ga1321f3908418c02cb06351a16e1f2109" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_AST_MASK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="group__LDLM.html#ga563e13b57ba8a8c2cf4801660334d35d" title="flock deadlock detected">LDLM_FL_FLOCK_DEADLOCK</a>         |\
                                         <a class="code" href="group__LDLM.html#ga28476345c80ee86025d566e9e7c432b9" title="These are flags that are mapped into the flags and ASTs of blocking locks Add FL_DISCARD...">LDLM_FL_AST_DISCARD_DATA</a>)
</pre></div>
<p>l_flags bits marked as "ast" bits </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00366">366</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3fb0e46d8dcf09f83494412e8cb5d588"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_AST_SENT" ref="ga3fb0e46d8dcf09f83494412e8cb5d588" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_AST_SENT&nbsp;&nbsp;&nbsp;0x0000000000000020ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>blocking or cancel packet was queued for sending. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00062">62</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00541">ldlm_cli_enqueue_fini()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf5ca91a80dd3fc578d5a9fc7fb815b74"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_ATOMIC_CB" ref="gaf5ca91a80dd3fc578d5a9fc7fb815b74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_ATOMIC_CB&nbsp;&nbsp;&nbsp;0x0000200000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>optimization hint: LDLM can run blocking callback from current context w/o involving separate thread. </p>
<p>in order to decrease cs rate </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00258">258</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00415">ldlm_cli_enqueue_local()</a>.</p>

</div>
</div>
<a class="anchor" id="ga043b49bb5e4be85bb6a3937bb241aab1"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_BL_AST" ref="ga043b49bb5e4be85bb6a3937bb241aab1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_BL_AST&nbsp;&nbsp;&nbsp;0x0000400000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>It may happen that a client initiates two operations, e.g. </p>
<p>unlink and mkdir, such that the server sends a blocking AST for conflicting locks to this client for the first operation, whereas the second operation has canceled this lock and is waiting for rpc_lock which is taken by the first operation. LDLM_FL_BL_AST is set by ldlm_callback_handler() in the lock to prevent the Early Lock Cancel (ELC) code from cancelling it. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00270">270</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01407">ldlm_cli_cancel_list_local()</a>, and <a class="el" href="ldlm__request_8c_source.html#l00541">ldlm_cli_enqueue_fini()</a>.</p>

</div>
</div>
<a class="anchor" id="gaef583898e5ca87d62c007b0a797f1f70"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_BL_DONE" ref="gaef583898e5ca87d62c007b0a797f1f70" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_BL_DONE&nbsp;&nbsp;&nbsp;0x0000800000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set by <a class="el" href="group__LDLM.html#ga0a466989372b56e3cde1edae472be066" title="Helper function to call blocking AST for LDLM lock lock in a &quot;cancelling&quot;...">ldlm_cancel_callback()</a> when lock cache is dropped to let ldlm_callback_handler() return EINVAL to the server. </p>
<p>It is used when ELC RPC is already prepared and is waiting for rpc_lock, too late to send a separate CANCEL RPC. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00280">280</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga912be807748854a27fde8d99ab122dc2"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_BLOCK_CONV" ref="ga912be807748854a27fde8d99ab122dc2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_BLOCK_CONV&nbsp;&nbsp;&nbsp;0x0000000000000004ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Server placed lock on conv list, or a recovering client wants the lock added to the conv list, no questions asked. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00048">48</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c6bbb5a5fb8a17d596ecaba494aa7d2"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_BLOCK_GRANTED" ref="ga2c6bbb5a5fb8a17d596ecaba494aa7d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_BLOCK_GRANTED&nbsp;&nbsp;&nbsp;0x0000000000000002ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Server placed lock on granted list, or a recovering client wants the lock added to the granted list, no questions asked. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00040">40</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l02459">ldlm_lock_convert()</a>, <a class="el" href="ldlm__lock_8c_source.html#l01370">ldlm_lock_match()</a>, and <a class="el" href="osc__lock_8c_source.html#l01210">osc_dlmlock_at_pgoff()</a>.</p>

</div>
</div>
<a class="anchor" id="ga34a11c94b46a7cd00e464a9063ff3879"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_BLOCK_NOWAIT" ref="ga34a11c94b46a7cd00e464a9063ff3879" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_BLOCK_NOWAIT&nbsp;&nbsp;&nbsp;0x0000000000040000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Server told not to wait if blocked. </p>
<p>For AGL, OST will not send glimpse callback. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00108">108</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf787c22790fe3d611cd92199be25dd19"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_BLOCK_WAIT" ref="gaf787c22790fe3d611cd92199be25dd19" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_BLOCK_WAIT&nbsp;&nbsp;&nbsp;0x0000000000000008ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Server placed lock on wait list, or a recovering client wants the lock added to the wait list, no questions asked. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00056">56</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6316c2ca1fd038c2cc96402b744d16c9"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_BLOCKED_MASK" ref="ga6316c2ca1fd038c2cc96402b744d16c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_BLOCKED_MASK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a>          |\
                                         <a class="code" href="group__LDLM.html#ga912be807748854a27fde8d99ab122dc2" title="Server placed lock on conv list, or a recovering client wants the lock added to the...">LDLM_FL_BLOCK_CONV</a>             |\
                                         <a class="code" href="group__LDLM.html#gaf787c22790fe3d611cd92199be25dd19" title="Server placed lock on wait list, or a recovering client wants the lock added to the...">LDLM_FL_BLOCK_WAIT</a>)
</pre></div>
<p>l_flags bits marked as "blocked" bits </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00370">370</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00230">ldlm_completion_ast()</a>, <a class="el" href="ldlm__request_8c_source.html#l00188">ldlm_completion_ast_async()</a>, and <a class="el" href="ldlm__flock_8c_source.html#l00662">ldlm_flock_completion_ast()</a>.</p>

</div>
</div>
<a class="anchor" id="ga71cf8c345c175dcb2f9b8713e8b2bf00"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_CANCEL_ON_BLOCK" ref="ga71cf8c345c175dcb2f9b8713e8b2bf00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_CANCEL_ON_BLOCK&nbsp;&nbsp;&nbsp;0x0000000000800000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Immediatelly cancel such locks when they block some other locks. </p>
<p>Send cancel notification to original lock holder, but expect no reply. This is for clients (like liblustre) that cannot be expected to reliably response to blocking AST. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00127">127</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac07f3063e5cf037bcfd71c86da494518"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_COS_ENABLED" ref="gac07f3063e5cf037bcfd71c86da494518" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_COS_ENABLED&nbsp;&nbsp;&nbsp;0x0200000000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag whether Commit-on-Sharing is enabled, if LDLM_FL_COS_INCOMPAT is set this flag may not be set because once the former is set this flag won't be checked, and for cross-MDT lock COS_INCOMPAT is always set but ast handle is in ldlm context which doesn't know whether COS is enabled or not. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00361">361</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b1ea8608da80462dc9948160ebe5cdc"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_COS_INCOMPAT" ref="ga0b1ea8608da80462dc9948160ebe5cdc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_COS_INCOMPAT&nbsp;&nbsp;&nbsp;0x0000000001000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag whether a lock is enqueued from a distributed transaction, and the requesting lock mode is PW/EX, if so, it will check compatibility with COS locks, and different from original COS semantic, transactions from the same client is also treated as lock conflict. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00136">136</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf74d13556ae1283f30228d20c497cfa8"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_DESTROYED" ref="gaf74d13556ae1283f30228d20c497cfa8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_DESTROYED&nbsp;&nbsp;&nbsp;0x0004000000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set for locks that were removed from class hash table and will be destroyed when last reference to them is released. </p>
<p>Set by ldlm_lock_destroy_internal().</p>
<p>Protected by lock and resource locks. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00309">309</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l01370">ldlm_lock_match()</a>.</p>

</div>
</div>
<a class="anchor" id="ga353cf18a1a7c41ccaf72d5c8bf71a129"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_EXCL" ref="ga353cf18a1a7c41ccaf72d5c8bf71a129" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_EXCL&nbsp;&nbsp;&nbsp;0x0080000000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag whether this lock can be reused. </p>
<p>Used by exclusive open. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00349">349</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00869">ldlm_cli_enqueue()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6fc806ac2146cf3505a29a50fd6b75a9"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_FAIL_LOC" ref="ga6fc806ac2146cf3505a29a50fd6b75a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_FAIL_LOC&nbsp;&nbsp;&nbsp;0x0000000100000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used for marking lock as a target for -EINTR while cp_ast sleep emulation + race with upcoming bl_ast. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00159">159</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__flock_8c_source.html#l00662">ldlm_flock_completion_ast()</a>.</p>

</div>
</div>
<a class="anchor" id="ga958240fb760018d3be665a8f0730b9c4"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_FAIL_NOTIFIED" ref="ga958240fb760018d3be665a8f0730b9c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_FAIL_NOTIFIED&nbsp;&nbsp;&nbsp;0x0002000000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set for locks that failed and where the server has been notified. </p>
<p>Protected by lock and resource locks. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00298">298</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l01370">ldlm_lock_match()</a>.</p>

</div>
</div>
<a class="anchor" id="gadfabf01b5433e46225676763fd9b3611"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_GONE_MASK" ref="gadfabf01b5433e46225676763fd9b3611" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_GONE_MASK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="group__LDLM.html#gaf74d13556ae1283f30228d20c497cfa8" title="Set for locks that were removed from class hash table and will be destroyed when...">LDLM_FL_DESTROYED</a>              |\
                                         <a class="code" href="group__LDLM.html#ga932d0cd6d35eceab182f01ec135eef3f" title="don&amp;#39;t run the cancel callback under ldlm_cli_cancel_unused">LDLM_FL_FAILED</a>)
</pre></div>
<p>l_flags bits marked as "gone" bits </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00375">375</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1a53232f696448d6586b6d66e973b9c6"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_INHERIT_MASK" ref="ga1a53232f696448d6586b6d66e973b9c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_INHERIT_MASK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="group__LDLM.html#ga71cf8c345c175dcb2f9b8713e8b2bf00" title="Immediatelly cancel such locks when they block some other locks.">LDLM_FL_CANCEL_ON_BLOCK</a>        |\
                                         <a class="code" href="group__LDLM.html#ga4df4a9b0f96c19fcdbd88c767b92cfe3" title="Blocked by group lock - wait indefinitely.">LDLM_FL_NO_TIMEOUT</a>             |\
                                         <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>)
</pre></div>
<p>l_flags bits marked as "inherit" bits </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00382">382</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00541">ldlm_cli_enqueue_fini()</a>.</p>

</div>
</div>
<a class="anchor" id="ga423c3fc60972417ed98ea9124cdae163"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_INTENT_ONLY" ref="ga423c3fc60972417ed98ea9124cdae163" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_INTENT_ONLY&nbsp;&nbsp;&nbsp;0x0000000000000200ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Don't grant lock, just do intent. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00076">76</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaafdd093df952018e6f7acbbf8cad985b"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_KMS_IGNORE" ref="gaafdd093df952018e6f7acbbf8cad985b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_KMS_IGNORE&nbsp;&nbsp;&nbsp;0x0000040000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A lock contributes to the known minimum size (KMS) calculation until it has finished the part of its cancelation that performs write back on its dirty pages. </p>
<p>It can remain on the granted list during this whole time. Threads racing to update the KMS after performing their writeback need to know to exclude each other's locks from the calculation as they walk the granted list. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00238">238</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3af51d9e1097e0aeaacd1c3cc88fec62"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_LVB_READY" ref="ga3af51d9e1097e0aeaacd1c3cc88fec62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_LVB_READY&nbsp;&nbsp;&nbsp;0x0000020000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>XXX FIXME: This is being added to b_size as a low-risk fix to the fact that the LVB filling happens _after_ the lock has been granted, so another thread can match it before the LVB has been updated. </p>
<p>As a dirty hack, we set LDLM_FL_LVB_READY only after we've done the LVB poop. this is only needed on LOV/OSC now, where LVB is actually used and callers must set it in input flags.</p>
<p>The proper fix is to do the granting inside of the completion AST, which can be replaced with a LVB-aware wrapping function for OSC locks. That change is pretty high-risk, though, and would need a lot more testing. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00226">226</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l01370">ldlm_lock_match()</a>.</p>

</div>
</div>
<a class="anchor" id="ga628bde1454443ba6f69043120c61acb9"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_NO_LRU" ref="ga628bde1454443ba6f69043120c61acb9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_NO_LRU&nbsp;&nbsp;&nbsp;0x0001000000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Don't put lock into the LRU list, so that it is not canceled due to aging. </p>
<p>Used by MGC locks, they are cancelled only at unmount or by callback. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00289">289</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00869">ldlm_cli_enqueue()</a>.</p>

</div>
</div>
<a class="anchor" id="gacddab05dc5721dad535a55534eeb9234"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_NS_SRV" ref="gacddab05dc5721dad535a55534eeb9234" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_NS_SRV&nbsp;&nbsp;&nbsp;0x0040000000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag whether this is a server namespace lock. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00343">343</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4210c27164df8fc68b15a5c6f88d3063"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_REPLAY" ref="ga4210c27164df8fc68b15a5c6f88d3063" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_REPLAY&nbsp;&nbsp;&nbsp;0x0000000000000100ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock is being replayed. </p>
<p>This could probably be implied by the fact that one of BLOCK_{GRANTED,CONV,WAIT} is set, but that is pretty dangerous. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00070">70</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00869">ldlm_cli_enqueue()</a>, <a class="el" href="ldlm__request_8c_source.html#l00541">ldlm_cli_enqueue_fini()</a>, and <a class="el" href="ldlm__request_8c_source.html#l00415">ldlm_cli_enqueue_local()</a>.</p>

</div>
</div>
<a class="anchor" id="ga080ded1bdce4915f2fd693eaf027f73f"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_RES_LOCKED" ref="ga080ded1bdce4915f2fd693eaf027f73f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_RES_LOCKED&nbsp;&nbsp;&nbsp;0x0010000000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>It's set in <a class="el" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock()</a> and unset in <a class="el" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock()</a>. </p>
<p>NB: compared with check_res_locked(), checking this bit is cheaper. Also, spin_is_locked() is deprecated for kernel code; one reason is because it works only for SMP so user needs to add extra macros like LASSERT_SPIN_LOCKED for uniprocessor kernels. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00327">327</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f5efeebb55b0f19c9403ae53405b424"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_RESENT" ref="ga6f5efeebb55b0f19c9403ae53405b424" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_RESENT&nbsp;&nbsp;&nbsp;0x0100000000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag whether a lock is found on server for re-sent RPC. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00355">355</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga09f2515df973bc9c1733ac4cec99eebb"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_SKIPPED" ref="ga09f2515df973bc9c1733ac4cec99eebb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_SKIPPED&nbsp;&nbsp;&nbsp;0x0000000200000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used while processing the unused list to know that we have already handled this lock and decided to skip it. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00167">167</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga100f8e004856a4aa214a829dd7e3b42c"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_SRV_ENQ_MASK" ref="ga100f8e004856a4aa214a829dd7e3b42c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_SRV_ENQ_MASK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="group__LDLM.html#ga79f84ccf0096f82e1153bb5646c4a4d6" title="extent, mode, or resource changed">LDLM_FL_LOCK_CHANGED</a>           |\
                                 <a class="code" href="group__LDLM.html#ga6316c2ca1fd038c2cc96402b744d16c9" title="l_flags bits marked as &amp;quot;blocked&amp;quot; bits">LDLM_FL_BLOCKED_MASK</a>           |\
                                 <a class="code" href="group__LDLM.html#ga4df4a9b0f96c19fcdbd88c767b92cfe3" title="Blocked by group lock - wait indefinitely.">LDLM_FL_NO_TIMEOUT</a>)
</pre></div>
<p>flags returned in  parameter on ldlm_lock_enqueue, to be re-constructed on re-send </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00388">388</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga68ed1455a628dbdd814b21b50e455923"></a><!-- doxytag: member="lustre_dlm_flags.h::LDLM_FL_WAITED" ref="ga68ed1455a628dbdd814b21b50e455923" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_FL_WAITED&nbsp;&nbsp;&nbsp;0x0020000000000000ULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>It's set once we call ldlm_add_waiting_lock_res_locked() to start the lock-timeout timer and it will never be reset. </p>
<p>Protected by lock and resource locks. </p>

<p>Definition at line <a class="el" href="lustre__dlm__flags_8h_source.html#l00337">337</a> of file <a class="el" href="lustre__dlm__flags_8h_source.html">lustre_dlm_flags.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga003105401547ae27f8ae4d9b4c232f27"></a><!-- doxytag: member="lustre_dlm.h::LDLM_GL_WORK_NOFREE" ref="ga003105401547ae27f8ae4d9b4c232f27" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_GL_WORK_NOFREE&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="structldlm__glimpse__work.html" title="Work list for sending GL ASTs to multiple locks.">ldlm_glimpse_work</a> is allocated on the stack and should not be freed. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00588">588</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae6f33fb4095ce2a0e694892623aee022"></a><!-- doxytag: member="lustre_dlm.h::LDLM_ITER_CONTINUE" ref="gae6f33fb4095ce2a0e694892623aee022" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_ITER_CONTINUE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return values for lock iterators. </p>
<p>Also used during deciding of lock grants and cancellations. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l01180">1180</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l02147">ldlm_reprocess_all()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c871836dbef822ef90080b3d6569c5f"></a><!-- doxytag: member="lustre_dlm.h::LDLM_LOCK_GET" ref="ga9c871836dbef822ef90080b3d6569c5f" args="(lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_LOCK_GET</td>
          <td>(</td>
          <td class="paramtype">lock&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                              \
        <a class="code" href="group__LDLM.html#gac526504450a40715c8e25fbab715689e" title="Get a reference on a lock.">ldlm_lock_get</a>(lock);                    \
        <span class="comment">/*LDLM_DEBUG((lock), &quot;get&quot;);*/</span>          \
        lock;                                   \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l01344">1344</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaec77446f52676c0679185593ce8e58e3"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_list_put" ref="gaec77446f52676c0679185593ce8e58e3" args="(head, member, count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ldlm_lock_list_put</td>
          <td>(</td>
          <td class="paramtype">head, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">member, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">count&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                                              \
        <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *_lock, *_next;                        \
        <span class="keywordtype">int</span> c = count;                                          \
        list_for_each_entry_safe(_lock, _next, head, member) {  \
                <span class="keywordflow">if</span> (c-- == 0)                                   \
                        <span class="keywordflow">break</span>;                                  \
                list_del_init(&amp;_lock-&gt;member);                  \
                <a class="code" href="group__LDLM.html#gaf3357d35be5378aa299677e298c5a625" title="Release a lock reference obtained by some other means (see LDLM_LOCK_PUT()).">LDLM_LOCK_RELEASE</a>(_lock);                       \
        }                                                       \
        LASSERT(c &lt;= 0);                                        \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l01351">1351</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5945b4d89a157c2e0fb6d955b3bf0c3f"></a><!-- doxytag: member="lustre_dlm.h::LDLM_LOCK_PUT" ref="ga5945b4d89a157c2e0fb6d955b3bf0c3f" args="(lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_LOCK_PUT</td>
          <td>(</td>
          <td class="paramtype">lock&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                            \
        LDLM_LOCK_REF_DEL(lock);                \
        <span class="comment">/*LDLM_DEBUG((lock), &quot;put&quot;);*/</span>          \
        <a class="code" href="group__LDLM.html#ga5e363707438fb69f9253f2ab8bf4c5e6" title="Release lock reference.">ldlm_lock_put</a>(lock);                    \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Release a temporary lock reference obtained by ldlm_handle2lock() or <a class="el" href="group__LDLM.html#gabac2ce09f8215c4f05a3a8113fa72545" title="Obtain a lock reference by handle.">__ldlm_handle2lock()</a>. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l01327">1327</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l00594">__ldlm_handle2lock()</a>, <a class="el" href="ldlm__request_8c_source.html#l00541">ldlm_cli_enqueue_fini()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00717">ldlm_lock_addref()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00760">ldlm_lock_addref_try()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00903">ldlm_lock_decref()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00918">ldlm_lock_decref_and_cancel()</a>, <a class="el" href="ldlm__lock_8c_source.html#l02586">ldlm_lock_dump_handle()</a>, <a class="el" href="ldlm__lock_8c_source.html#l01370">ldlm_lock_match()</a>, and <a class="el" href="ldlm__lock_8c_source.html#l02293">ldlm_lock_set_data()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf3357d35be5378aa299677e298c5a625"></a><!-- doxytag: member="lustre_dlm.h::LDLM_LOCK_RELEASE" ref="gaf3357d35be5378aa299677e298c5a625" args="(lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_LOCK_RELEASE</td>
          <td>(</td>
          <td class="paramtype">lock&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                            \
        <span class="comment">/*LDLM_DEBUG((lock), &quot;put&quot;);*/</span>          \
        <a class="code" href="group__LDLM.html#ga5e363707438fb69f9253f2ab8bf4c5e6" title="Release lock reference.">ldlm_lock_put</a>(lock);                    \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Release a lock reference obtained by some other means (see <a class="el" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT()</a>). </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l01338">1338</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01345">ldlm_cli_cancel()</a>, <a class="el" href="ldlm__request_8c_source.html#l01407">ldlm_cli_cancel_list_local()</a>, <a class="el" href="ldlm__request_8c_source.html#l00869">ldlm_cli_enqueue()</a>, <a class="el" href="ldlm__request_8c_source.html#l00541">ldlm_cli_enqueue_fini()</a>, <a class="el" href="ldlm__request_8c_source.html#l00415">ldlm_cli_enqueue_local()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00403">ldlm_lock_destroy()</a>, and <a class="el" href="ldlm__lock_8c_source.html#l01370">ldlm_lock_match()</a>.</p>

</div>
</div>
<a class="anchor" id="ga032adcd4a0ffd13b0425ae6dc9fb4033"></a><!-- doxytag: member="lustre_dlm.h::LDLM_POOL_CLI_DEF_RECALC_PERIOD" ref="ga032adcd4a0ffd13b0425ae6dc9fb4033" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_POOL_CLI_DEF_RECALC_PERIOD&nbsp;&nbsp;&nbsp;(10)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default recalc period for client side pools in sec. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00228">228</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga41802548f309704722be627a3d83e310"></a><!-- doxytag: member="lustre_dlm.h::LDLM_POOL_SRV_DEF_RECALC_PERIOD" ref="ga41802548f309704722be627a3d83e310" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_POOL_SRV_DEF_RECALC_PERIOD&nbsp;&nbsp;&nbsp;(1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default recalc period for server side pools in sec. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00225">225</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7712344fc932485bff52275c2193484a"></a><!-- doxytag: member="lustre_dlm.h::LDLM_POOLS_MODEST_MARGIN_SHIFT" ref="ga7712344fc932485bff52275c2193484a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_POOLS_MODEST_MARGIN_SHIFT&nbsp;&nbsp;&nbsp;(4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>~6% margin for modest pools. </p>
<p>See <a class="el" href="ldlm__pool_8c_source.html">ldlm_pool.c</a> for details. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00222">222</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadbb6d2680a2d2d7ab15623b03f058edc"></a><!-- doxytag: member="lustre_dlm.h::LDLM_POOLS_THREAD_PERIOD" ref="gadbb6d2680a2d2d7ab15623b03f058edc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_POOLS_THREAD_PERIOD&nbsp;&nbsp;&nbsp;(1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>One second for pools thread check interval. </p>
<p>Each pool has own period. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00219">219</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga605a491c960028a1b607ba7d2477eca1"></a><!-- doxytag: member="lustre_dlm.h::LDLM_RESOURCE_ADDREF" ref="ga605a491c960028a1b607ba7d2477eca1" args="(res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_RESOURCE_ADDREF</td>
          <td>(</td>
          <td class="paramtype">res&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                  \
        lu_ref_add_atomic(&amp;(res)-&gt;lr_reference, __FUNCTION__, current);  \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l01435">1435</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabcad3c4dc7bec07ec9942a817293935a"></a><!-- doxytag: member="lustre_dlm.h::LDLM_RESOURCE_DELREF" ref="gabcad3c4dc7bec07ec9942a817293935a" args="(res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDLM_RESOURCE_DELREF</td>
          <td>(</td>
          <td class="paramtype">res&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                  \
        lu_ref_del(&amp;(res)-&gt;lr_reference, __FUNCTION__, current);  \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l01439">1439</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5eaa516285c80b8a6bb5f879fa3191b9"></a><!-- doxytag: member="lustre_dlm.h::LUSTRE_TRACKS_LOCK_EXP_REFS" ref="ga5eaa516285c80b8a6bb5f879fa3191b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LUSTRE_TRACKS_LOCK_EXP_REFS&nbsp;&nbsp;&nbsp;(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether to track references to exports by LDLM locks. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00612">612</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gac111233b56bdf7a4767dcd7a2f15b378"></a><!-- doxytag: member="lustre_dlm.h::ldlm_blocking_callback" ref="gac111233b56bdf7a4767dcd7a2f15b378" args=")(struct ldlm_lock *lock, struct ldlm_lock_desc *new, void *data, int flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__LDLM.html#gac111233b56bdf7a4767dcd7a2f15b378">ldlm_blocking_callback</a>)(struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, struct <a class="el" href="structldlm__lock__desc.html">ldlm_lock_desc</a> *new, void *data, int flag)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type for blocking callback function of a lock. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00569">569</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac03b996dc38f767ddd9b2f5ae779b257"></a><!-- doxytag: member="lustre_dlm.h::ldlm_completion_callback" ref="gac03b996dc38f767ddd9b2f5ae779b257" args=")(struct ldlm_lock *lock, __u64 flags, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__LDLM.html#gac03b996dc38f767ddd9b2f5ae779b257">ldlm_completion_callback</a>)(struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, __u64 flags, void *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type for completion callback function of a lock. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00573">573</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e5c291246d5e6fb302d99a6111cb03d"></a><!-- doxytag: member="lustre_dlm.h::ldlm_glimpse_callback" ref="ga6e5c291246d5e6fb302d99a6111cb03d" args=")(struct ldlm_lock *lock, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__LDLM.html#ga6e5c291246d5e6fb302d99a6111cb03d">ldlm_glimpse_callback</a>)(struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, void *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type for glimpse callback function of a lock. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00576">576</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gae8a3b6a5d0d3244ed73924ab2421a0d0"></a><!-- doxytag: member="lustre_dlm.h::@48" ref="gae8a3b6a5d0d3244ed73924ab2421a0d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae8a3b6a5d0d3244ed73924ab2421a0d0ac9ce485ce53eddc4df436c8df18871e4"></a><!-- doxytag: member="LDLM_NSS_LOCKS" ref="ggae8a3b6a5d0d3244ed73924ab2421a0d0ac9ce485ce53eddc4df436c8df18871e4" args="" -->LDLM_NSS_LOCKS</em>&nbsp;</td><td>
<p>LDLM namespace lock stats. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00332">332</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00332"></a>00332      {
<a name="l00334"></a>00334         <a class="code" href="group__LDLM.html#ggae8a3b6a5d0d3244ed73924ab2421a0d0ac9ce485ce53eddc4df436c8df18871e4" title="LDLM namespace lock stats.">LDLM_NSS_LOCKS</a>          = 0,
<a name="l00335"></a>00335         LDLM_NSS_LAST
<a name="l00336"></a>00336 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="gafcd8eee315d3a7e1313596efd678d77e"></a><!-- doxytag: member="lustre_dlm.h::ldlm_appetite" ref="gafcd8eee315d3a7e1313596efd678d77e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__LDLM.html#gafcd8eee315d3a7e1313596efd678d77e">ldlm_appetite</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LDLM pools related, type of lock pool in the namespace. </p>
<p>Greedy means release cached locks aggressively </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00304">304</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00304"></a>00304                    {
<a name="l00305"></a>00305         LDLM_NAMESPACE_GREEDY = 1 &lt;&lt; 0,
<a name="l00306"></a>00306         LDLM_NAMESPACE_MODEST = 1 &lt;&lt; 1
<a name="l00307"></a>00307 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0b718c2d27bc15f43205e50e4da16ec9"></a><!-- doxytag: member="lustre_dlm.h::ldlm_cancel_flags" ref="ga0b718c2d27bc15f43205e50e4da16ec9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel flags. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00615">615</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00615"></a>00615                        {
<a name="l00616"></a>00616         LCF_ASYNC       = 0x1, <span class="comment">/* Cancel locks asynchronously. */</span>
<a name="l00617"></a>00617         LCF_LOCAL       = 0x2, <span class="comment">/* Cancel locks locally, not notifing server */</span>
<a name="l00618"></a>00618         LCF_BL_AST      = 0x4, <span class="comment">/* Cancel LDLM_FL_BL_AST locks in the same RPC */</span>
<a name="l00619"></a>00619 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga516147f10f1ca82e556a7f8c3ee5d6ff"></a><!-- doxytag: member="lustre_dlm.h::ldlm_ns_type" ref="ga516147f10f1ca82e556a7f8c3ee5d6ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__LDLM.html#ga516147f10f1ca82e556a7f8c3ee5d6ff">ldlm_ns_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga516147f10f1ca82e556a7f8c3ee5d6ffaf5e8bcf861bcd7b236cb287da70a974e"></a><!-- doxytag: member="LDLM_NS_TYPE_UNKNOWN" ref="gga516147f10f1ca82e556a7f8c3ee5d6ffaf5e8bcf861bcd7b236cb287da70a974e" args="" -->LDLM_NS_TYPE_UNKNOWN</em>&nbsp;</td><td>
<p>invalid type </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga516147f10f1ca82e556a7f8c3ee5d6ffaabe8a36130ca1ffe942ad581cc3b7d50"></a><!-- doxytag: member="LDLM_NS_TYPE_MDC" ref="gga516147f10f1ca82e556a7f8c3ee5d6ffaabe8a36130ca1ffe942ad581cc3b7d50" args="" -->LDLM_NS_TYPE_MDC</em>&nbsp;</td><td>
<p>MDC namespace. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga516147f10f1ca82e556a7f8c3ee5d6ffa6f51895209e33fae55026bc462d17ed1"></a><!-- doxytag: member="LDLM_NS_TYPE_MDT" ref="gga516147f10f1ca82e556a7f8c3ee5d6ffa6f51895209e33fae55026bc462d17ed1" args="" -->LDLM_NS_TYPE_MDT</em>&nbsp;</td><td>
<p>MDT namespace. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga516147f10f1ca82e556a7f8c3ee5d6ffab42df29b6de6da3b65b3db2496efe009"></a><!-- doxytag: member="LDLM_NS_TYPE_OSC" ref="gga516147f10f1ca82e556a7f8c3ee5d6ffab42df29b6de6da3b65b3db2496efe009" args="" -->LDLM_NS_TYPE_OSC</em>&nbsp;</td><td>
<p>OSC namespace. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga516147f10f1ca82e556a7f8c3ee5d6ffabaac77dbb962ddbffeb7d4092d38c141"></a><!-- doxytag: member="LDLM_NS_TYPE_OST" ref="gga516147f10f1ca82e556a7f8c3ee5d6ffabaac77dbb962ddbffeb7d4092d38c141" args="" -->LDLM_NS_TYPE_OST</em>&nbsp;</td><td>
<p>OST namespace. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga516147f10f1ca82e556a7f8c3ee5d6ffabdcaf331de52005bd3c5c67979a44601"></a><!-- doxytag: member="LDLM_NS_TYPE_MGC" ref="gga516147f10f1ca82e556a7f8c3ee5d6ffabdcaf331de52005bd3c5c67979a44601" args="" -->LDLM_NS_TYPE_MGC</em>&nbsp;</td><td>
<p>MGC namespace. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga516147f10f1ca82e556a7f8c3ee5d6ffa8fcb201d020caf855369cdcb8796ec9b"></a><!-- doxytag: member="LDLM_NS_TYPE_MGT" ref="gga516147f10f1ca82e556a7f8c3ee5d6ffa8fcb201d020caf855369cdcb8796ec9b" args="" -->LDLM_NS_TYPE_MGT</em>&nbsp;</td><td>
<p>MGT namespace. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00338">338</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00338"></a>00338                   {
<a name="l00339"></a>00339         <a class="code" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffaf5e8bcf861bcd7b236cb287da70a974e" title="invalid type">LDLM_NS_TYPE_UNKNOWN</a> = 0,       
<a name="l00340"></a>00340         <a class="code" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffaabe8a36130ca1ffe942ad581cc3b7d50" title="MDC namespace.">LDLM_NS_TYPE_MDC</a>,               
<a name="l00341"></a>00341         <a class="code" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffa6f51895209e33fae55026bc462d17ed1" title="MDT namespace.">LDLM_NS_TYPE_MDT</a>,               
<a name="l00342"></a>00342         <a class="code" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffab42df29b6de6da3b65b3db2496efe009" title="OSC namespace.">LDLM_NS_TYPE_OSC</a>,               
<a name="l00343"></a>00343         <a class="code" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffabaac77dbb962ddbffeb7d4092d38c141" title="OST namespace.">LDLM_NS_TYPE_OST</a>,               
<a name="l00344"></a>00344         <a class="code" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffabdcaf331de52005bd3c5c67979a44601" title="MGC namespace.">LDLM_NS_TYPE_MGC</a>,               
<a name="l00345"></a>00345         <a class="code" href="group__LDLM.html#gga516147f10f1ca82e556a7f8c3ee5d6ffa8fcb201d020caf855369cdcb8796ec9b" title="MGT namespace.">LDLM_NS_TYPE_MGT</a>,               
<a name="l00346"></a>00346 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac4b4584603b76e6cc86c82a64f59defd"></a><!-- doxytag: member="lustre_dlm.h::ldlm_side" ref="gac4b4584603b76e6cc86c82a64f59defd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__LDLM.html#gac4b4584603b76e6cc86c82a64f59defd">ldlm_side</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LDLM namespace type. </p>
<p>The "client" type is actually an indication that this is a narrow local view into complete namespace on the server. Such namespaces cannot make any decisions about lack of conflicts or do any autonomous lock granting without first speaking to a server. </p>

<p>Definition at line <a class="el" href="lustre__dlm_8h_source.html#l00094">94</a> of file <a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00094"></a>00094                {
<a name="l00095"></a>00095         LDLM_NAMESPACE_SERVER = 0x01,
<a name="l00096"></a>00096         LDLM_NAMESPACE_CLIENT = 0x02
<a name="l00097"></a>00097 };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabac2ce09f8215c4f05a3a8113fa72545"></a><!-- doxytag: member="lustre_dlm.h::__ldlm_handle2lock" ref="gabac2ce09f8215c4f05a3a8113fa72545" args="(const struct lustre_handle *, __u64 flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a>* __ldlm_handle2lock </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a lock reference by handle. </p>
<p>if <em>flags:</em> atomically get the lock and set the flags. Return NULL if flag already set </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l00594">594</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00778">ldlm_lock::l_flags</a>, <a class="el" href="lustre__dlm_8h_source.html#l00885">ldlm_lock::l_reference</a>, <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>, <a class="el" href="lustre__dlm_8h_source.html#l01327">LDLM_LOCK_PUT</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l00903">ldlm_lock_decref()</a>, and <a class="el" href="ldlm__lock_8c_source.html#l00918">ldlm_lock_decref_and_cancel()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00596"></a>00596 {
<a name="l00597"></a>00597         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock;
<a name="l00598"></a>00598         ENTRY;
<a name="l00599"></a>00599 
<a name="l00600"></a>00600         LASSERT(handle);
<a name="l00601"></a>00601 
<a name="l00602"></a>00602         lock = class_handle2object(handle-&gt;cookie, NULL);
<a name="l00603"></a>00603         <span class="keywordflow">if</span> (lock == NULL)
<a name="l00604"></a>00604                 RETURN(NULL);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606         <span class="comment">/* It&apos;s unlikely but possible that someone marked the lock as</span>
<a name="l00607"></a>00607 <span class="comment">         * destroyed after we did handle2object on it */</span>
<a name="l00608"></a>00608         <span class="keywordflow">if</span> ((flags == 0) &amp;&amp; !ldlm_is_destroyed(lock)) {
<a name="l00609"></a>00609                 lu_ref_add(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a2cc84a3989e5b197caffa7a0fe014f27" title="Reference tracking structure to debug leaked locks.">l_reference</a>, <span class="stringliteral">&quot;handle&quot;</span>, current);
<a name="l00610"></a>00610                 RETURN(lock);
<a name="l00611"></a>00611         }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615         LASSERT(lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a> != NULL);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617         lu_ref_add_atomic(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a2cc84a3989e5b197caffa7a0fe014f27" title="Reference tracking structure to debug leaked locks.">l_reference</a>, <span class="stringliteral">&quot;handle&quot;</span>, current);
<a name="l00618"></a>00618         <span class="keywordflow">if</span> (unlikely(ldlm_is_destroyed(lock))) {
<a name="l00619"></a>00619                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00620"></a>00620                 CDEBUG(D_INFO, <span class="stringliteral">&quot;lock already destroyed: lock %p\n&quot;</span>, lock);
<a name="l00621"></a>00621                 <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l00622"></a>00622                 RETURN(NULL);
<a name="l00623"></a>00623         }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625         <span class="comment">/* If we&apos;re setting flags, make sure none of them are already set. */</span>
<a name="l00626"></a>00626         <span class="keywordflow">if</span> (flags != 0) {
<a name="l00627"></a>00627                 <span class="keywordflow">if</span> ((lock-&gt;<a class="code" href="structldlm__lock.html#a52cb4e433ee43b7326bfbb652c3d0598" title="Lock state flags.">l_flags</a> &amp; flags) != 0) {
<a name="l00628"></a>00628                         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00629"></a>00629                         <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l00630"></a>00630                         RETURN(NULL);
<a name="l00631"></a>00631                 }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633                 lock-&gt;<a class="code" href="structldlm__lock.html#a52cb4e433ee43b7326bfbb652c3d0598" title="Lock state flags.">l_flags</a> |= flags;
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00637"></a>00637         RETURN(lock);
<a name="l00638"></a>00638 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gabac2ce09f8215c4f05a3a8113fa72545_cgraph.png" border="0" usemap="#group__LDLM_gabac2ce09f8215c4f05a3a8113fa72545_cgraph_map" alt=""></div>
<map name="group__LDLM_gabac2ce09f8215c4f05a3a8113fa72545_cgraph_map" id="group__LDLM_gabac2ce09f8215c4f05a3a8113fa72545_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="212,5,351,35"/><area shape="rect" id="node5" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="204,59,359,88"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gabac2ce09f8215c4f05a3a8113fa72545_icgraph.png" border="0" usemap="#group__LDLM_gabac2ce09f8215c4f05a3a8113fa72545_icgraph_map" alt=""></div>
<map name="group__LDLM_gabac2ce09f8215c4f05a3a8113fa72545_icgraph_map" id="group__LDLM_gabac2ce09f8215c4f05a3a8113fa72545_icgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh." alt="" coords="244,5,377,35"/><area shape="rect" id="node7" href="group__LDLM.html#gad236a9af5f0845e1046060a55419914b" title="Decrease reader/writer refcount for LDLM lock with handle lockh and mark it for subsequent..." alt="" coords="204,59,417,88"/><area shape="rect" id="node5" href="group__net.html#ga686ce1d3f4b5ce9b59e59136cb6b265c" title="Part of Rep&#45;Ack logic." alt="" coords="467,5,600,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7dac0446d813ef65c24c0831b6d1a519"></a><!-- doxytag: member="lustre_dlm.h::ldlm_error2errno" ref="ga7dac0446d813ef65c24c0831b6d1a519" args="(enum ldlm_error error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_error2errno </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__LDLM.html#gaa2fbd012972eb2b2d0653c8df02964f7">ldlm_error</a>&nbsp;</td>
          <td class="paramname"> <em>error</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rather arbitrary mapping from LDLM error codes to errno values. </p>
<p>This should not escape to the user level. </p>

<p>Definition at line <a class="el" href="ldlm__lib_8c_source.html#l02967">2967</a> of file <a class="el" href="ldlm__lib_8c_source.html">ldlm_lib.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02968"></a>02968 {
<a name="l02969"></a>02969         <span class="keywordtype">int</span> result;
<a name="l02970"></a>02970 
<a name="l02971"></a>02971         <span class="keywordflow">switch</span> (error) {
<a name="l02972"></a>02972         <span class="keywordflow">case</span> ELDLM_OK:
<a name="l02973"></a>02973         <span class="keywordflow">case</span> ELDLM_LOCK_MATCHED:
<a name="l02974"></a>02974                 result = 0;
<a name="l02975"></a>02975                 <span class="keywordflow">break</span>;
<a name="l02976"></a>02976         <span class="keywordflow">case</span> ELDLM_LOCK_CHANGED:
<a name="l02977"></a>02977                 result = -ESTALE;
<a name="l02978"></a>02978                 <span class="keywordflow">break</span>;
<a name="l02979"></a>02979         <span class="keywordflow">case</span> ELDLM_LOCK_ABORTED:
<a name="l02980"></a>02980                 result = -ENAVAIL;
<a name="l02981"></a>02981                 <span class="keywordflow">break</span>;
<a name="l02982"></a>02982         <span class="keywordflow">case</span> ELDLM_LOCK_REPLACED:
<a name="l02983"></a>02983                 result = -ESRCH;
<a name="l02984"></a>02984                 <span class="keywordflow">break</span>;
<a name="l02985"></a>02985         <span class="keywordflow">case</span> ELDLM_NO_LOCK_DATA:
<a name="l02986"></a>02986                 result = -ENOENT;
<a name="l02987"></a>02987                 <span class="keywordflow">break</span>;
<a name="l02988"></a>02988         <span class="keywordflow">case</span> ELDLM_NAMESPACE_EXISTS:
<a name="l02989"></a>02989                 result = -EEXIST;
<a name="l02990"></a>02990                 <span class="keywordflow">break</span>;
<a name="l02991"></a>02991         <span class="keywordflow">case</span> ELDLM_BAD_NAMESPACE:
<a name="l02992"></a>02992                 result = -EBADF;
<a name="l02993"></a>02993                 <span class="keywordflow">break</span>;
<a name="l02994"></a>02994         <span class="keywordflow">default</span>:
<a name="l02995"></a>02995                 <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>)error) &lt; 0) { <span class="comment">/* cast to signed type */</span>
<a name="l02996"></a>02996                         result = error; <span class="comment">/* as ldlm_error can be unsigned */</span>
<a name="l02997"></a>02997                 } <span class="keywordflow">else</span> {
<a name="l02998"></a>02998                         CERROR(<span class="stringliteral">&quot;Invalid DLM result code: %d\n&quot;</span>, error);
<a name="l02999"></a>02999                         result = -EPROTO;
<a name="l03000"></a>03000                 }
<a name="l03001"></a>03001         }
<a name="l03002"></a>03002         <span class="keywordflow">return</span> result;
<a name="l03003"></a>03003 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga921f8d85541cbe1fa330b9a12080103f"></a><!-- doxytag: member="lustre_dlm.h::ldlm_flock_completion_ast" ref="ga921f8d85541cbe1fa330b9a12080103f" args="(struct ldlm_lock *lock, __u64 flags, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_flock_completion_ast </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flock completion callback function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>[in,out]: A lock to be handled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>[in]: flags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*data</em>&nbsp;</td><td>[in]: ldlm_work_cp_ast_lock() will use <a class="el" href="structldlm__cb__set__arg.html">ldlm_cb_set_arg</a></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>: success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&lt;0</em>&nbsp;</td><td>: failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__flock_8c_source.html#l00662">662</a> of file <a class="el" href="ldlm__flock_8c_source.html">ldlm_flock.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00237">obd_import::imp_generation</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__dlm_8h_source.html#l00822">ldlm_lock::l_ast_data</a>, <a class="el" href="lustre__dlm_8h_source.html#l00759">ldlm_lock::l_conn_export</a>, <a class="el" href="lustre__dlm_8h_source.html#l00778">ldlm_lock::l_flags</a>, <a class="el" href="lustre__dlm_8h_source.html#l00728">ldlm_lock::l_granted_mode</a>, <a class="el" href="lustre__dlm_8h_source.html#l00772">ldlm_lock::l_policy_data</a>, <a class="el" href="lustre__dlm_8h_source.html#l00791">ldlm_lock::l_waitq</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00370">LDLM_FL_BLOCKED_MASK</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00173">LDLM_FL_CBPENDING</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00159">LDLM_FL_FAIL_LOC</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00197">LDLM_FL_FAILED</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00088">LDLM_FL_FLOCK_DEADLOCK</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00179">LDLM_FL_WAIT_NOREPROC</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00663"></a>00663 {
<a name="l00664"></a>00664         <span class="keyword">struct </span>file_lock *getlk = lock-&gt;<a class="code" href="structldlm__lock.html#acb54919a43db8f99a336c67e0988fdb8" title="Private storage for lock user.">l_ast_data</a>;
<a name="l00665"></a>00665         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd;
<a name="l00666"></a>00666         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = NULL;
<a name="l00667"></a>00667         <span class="keyword">struct </span>ldlm_flock_wait_data fwd;
<a name="l00668"></a>00668         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi;
<a name="l00669"></a>00669         <span class="keyword">enum</span> <a class="code" href="group__LDLM.html#gaa2fbd012972eb2b2d0653c8df02964f7" title="LDLM non-error return states.">ldlm_error</a> err;
<a name="l00670"></a>00670         <span class="keywordtype">int</span> rc = 0;
<a name="l00671"></a>00671         ENTRY;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673         OBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT2, 4);
<a name="l00674"></a>00674         <span class="keywordflow">if</span> (OBD_FAIL_PRECHECK(OBD_FAIL_LDLM_CP_CB_WAIT3)) {
<a name="l00675"></a>00675                 <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00676"></a>00676                 lock-&gt;<a class="code" href="structldlm__lock.html#a52cb4e433ee43b7326bfbb652c3d0598" title="Lock state flags.">l_flags</a> |= <a class="code" href="group__LDLM.html#ga6fc806ac2146cf3505a29a50fd6b75a9" title="Used for marking lock as a target for -EINTR while cp_ast sleep emulation + race...">LDLM_FL_FAIL_LOC</a>;
<a name="l00677"></a>00677                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00678"></a>00678                 OBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT3, 4);
<a name="l00679"></a>00679         }
<a name="l00680"></a>00680         CDEBUG(D_DLMTRACE, <span class="stringliteral">&quot;flags: &quot;</span>LPX64<span class="stringliteral">&quot; data: %p getlk: %p\n&quot;</span>,
<a name="l00681"></a>00681                flags, data, getlk);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         LASSERT(flags != <a class="code" href="group__LDLM.html#gae36b9cddb3e68705d21f384ad3a3e1e6" title="not a real flag, not saved in lock">LDLM_FL_WAIT_NOREPROC</a>);
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__LDLM.html#ga932d0cd6d35eceab182f01ec135eef3f" title="don&amp;#39;t run the cancel callback under ldlm_cli_cancel_unused">LDLM_FL_FAILED</a>)
<a name="l00686"></a>00686                 <span class="keywordflow">goto</span> granted;
<a name="l00687"></a>00687 
<a name="l00688"></a>00688         <span class="keywordflow">if</span> (!(flags &amp; <a class="code" href="group__LDLM.html#ga6316c2ca1fd038c2cc96402b744d16c9" title="l_flags bits marked as &amp;quot;blocked&amp;quot; bits">LDLM_FL_BLOCKED_MASK</a>)) {
<a name="l00689"></a>00689                 <span class="keywordflow">if</span> (NULL == data)
<a name="l00690"></a>00690                         <span class="comment">/* mds granted the lock in the reply */</span>
<a name="l00691"></a>00691                         <span class="keywordflow">goto</span> granted;
<a name="l00692"></a>00692                 <span class="comment">/* CP AST RPC: lock get granted, wake it up */</span>
<a name="l00693"></a>00693                 wake_up(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a0ca58a0480ef9503c3548499e27c2e43" title="If the lock is granted, a process sleeps on this waitq to learn when it&amp;#39;s no...">l_waitq</a>);
<a name="l00694"></a>00694                 RETURN(0);
<a name="l00695"></a>00695         }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697         LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue returned a blocked lock, &quot;</span>
<a name="l00698"></a>00698                    <span class="stringliteral">&quot;sleeping&quot;</span>);
<a name="l00699"></a>00699         fwd.fwd_lock = lock;
<a name="l00700"></a>00700         obd = class_exp2obd(lock-&gt;<a class="code" href="structldlm__lock.html#ae11dfeaaf68f7217bc5defa97b58b1b1" title="Lock connection export.">l_conn_export</a>);
<a name="l00701"></a>00701 
<a name="l00702"></a>00702         <span class="comment">/* if this is a local lock, there is no import */</span>
<a name="l00703"></a>00703         <span class="keywordflow">if</span> (NULL != obd)
<a name="l00704"></a>00704                 imp = obd-&gt;u.cli.cl_import;
<a name="l00705"></a>00705 
<a name="l00706"></a>00706         <span class="keywordflow">if</span> (NULL != imp) {
<a name="l00707"></a>00707                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00708"></a>00708                 fwd.fwd_generation = imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>;
<a name="l00709"></a>00709                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00710"></a>00710         }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         lwi = LWI_TIMEOUT_INTR(0, NULL, ldlm_flock_interrupted_wait, &amp;fwd);
<a name="l00713"></a>00713 
<a name="l00714"></a>00714         <span class="comment">/* Go to sleep until the lock is granted. */</span>
<a name="l00715"></a>00715         rc = l_wait_event(lock-&gt;<a class="code" href="structldlm__lock.html#a0ca58a0480ef9503c3548499e27c2e43" title="If the lock is granted, a process sleeps on this waitq to learn when it&amp;#39;s no...">l_waitq</a>, is_granted_or_cancelled(lock), &amp;lwi);
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         <span class="keywordflow">if</span> (rc) {
<a name="l00718"></a>00718                 LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue waking up: failed (%d)&quot;</span>,
<a name="l00719"></a>00719                            rc);
<a name="l00720"></a>00720                 RETURN(rc);
<a name="l00721"></a>00721         }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723 granted:
<a name="l00724"></a>00724         OBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT, 10);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         <span class="keywordflow">if</span> (OBD_FAIL_PRECHECK(OBD_FAIL_LDLM_CP_CB_WAIT4)) {
<a name="l00727"></a>00727                 <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00728"></a>00728                 <span class="comment">/* DEADLOCK is always set with CBPENDING */</span>
<a name="l00729"></a>00729                 lock-&gt;<a class="code" href="structldlm__lock.html#a52cb4e433ee43b7326bfbb652c3d0598" title="Lock state flags.">l_flags</a> |= <a class="code" href="group__LDLM.html#ga563e13b57ba8a8c2cf4801660334d35d" title="flock deadlock detected">LDLM_FL_FLOCK_DEADLOCK</a> | <a class="code" href="group__LDLM.html#ga3845b64e7040a6d03323e5289bd71adc" title="this lock is being destroyed">LDLM_FL_CBPENDING</a>;
<a name="l00730"></a>00730                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00731"></a>00731                 OBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT4, 4);
<a name="l00732"></a>00732         }
<a name="l00733"></a>00733         <span class="keywordflow">if</span> (OBD_FAIL_PRECHECK(OBD_FAIL_LDLM_CP_CB_WAIT5)) {
<a name="l00734"></a>00734                 <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00735"></a>00735                 <span class="comment">/* DEADLOCK is always set with CBPENDING */</span>
<a name="l00736"></a>00736                 lock-&gt;<a class="code" href="structldlm__lock.html#a52cb4e433ee43b7326bfbb652c3d0598" title="Lock state flags.">l_flags</a> |= <a class="code" href="group__LDLM.html#ga6fc806ac2146cf3505a29a50fd6b75a9" title="Used for marking lock as a target for -EINTR while cp_ast sleep emulation + race...">LDLM_FL_FAIL_LOC</a> |
<a name="l00737"></a>00737                                  <a class="code" href="group__LDLM.html#ga563e13b57ba8a8c2cf4801660334d35d" title="flock deadlock detected">LDLM_FL_FLOCK_DEADLOCK</a> | <a class="code" href="group__LDLM.html#ga3845b64e7040a6d03323e5289bd71adc" title="this lock is being destroyed">LDLM_FL_CBPENDING</a>;
<a name="l00738"></a>00738                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00739"></a>00739                 OBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT5, 4);
<a name="l00740"></a>00740         }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 
<a name="l00745"></a>00745         <span class="comment">/* Protect against race where lock could have been just destroyed</span>
<a name="l00746"></a>00746 <span class="comment">         * due to overlap in ldlm_process_flock_lock().</span>
<a name="l00747"></a>00747 <span class="comment">         */</span>
<a name="l00748"></a>00748         <span class="keywordflow">if</span> (ldlm_is_destroyed(lock)) {
<a name="l00749"></a>00749                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00750"></a>00750                 LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue waking up: destroyed&quot;</span>);
<a name="l00751"></a>00751 
<a name="l00752"></a>00752                 <span class="comment">/* An error is still to be returned, to propagate it up to</span>
<a name="l00753"></a>00753 <span class="comment">                 * ldlm_cli_enqueue_fini() caller. */</span>
<a name="l00754"></a>00754                 RETURN(-EIO);
<a name="l00755"></a>00755         }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         <span class="comment">/* ldlm_lock_enqueue() has already placed lock on the granted list. */</span>
<a name="l00758"></a>00758         ldlm_resource_unlink_lock(lock);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         <span class="comment">/* Import invalidation. We need to actually release the lock</span>
<a name="l00761"></a>00761 <span class="comment">         * references being held, so that it can go away. No point in</span>
<a name="l00762"></a>00762 <span class="comment">         * holding the lock even if app still believes it has it, since</span>
<a name="l00763"></a>00763 <span class="comment">         * server already dropped it anyway. Only for granted locks too. */</span>
<a name="l00764"></a>00764         <span class="comment">/* Do the same for DEADLOCK&apos;ed locks. */</span>
<a name="l00765"></a>00765         <span class="keywordflow">if</span> (ldlm_is_failed(lock) || ldlm_is_flock_deadlock(lock)) {
<a name="l00766"></a>00766                 <span class="keywordtype">int</span> mode;
<a name="l00767"></a>00767 
<a name="l00768"></a>00768                 <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>)
<a name="l00769"></a>00769                         LASSERT(ldlm_is_test_lock(lock));
<a name="l00770"></a>00770 
<a name="l00771"></a>00771                 <span class="keywordflow">if</span> (ldlm_is_test_lock(lock) || ldlm_is_flock_deadlock(lock))
<a name="l00772"></a>00772                         mode = flock_type(getlk);
<a name="l00773"></a>00773                 <span class="keywordflow">else</span>
<a name="l00774"></a>00774                         mode = lock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a>;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776                 <span class="keywordflow">if</span> (ldlm_is_flock_deadlock(lock)) {
<a name="l00777"></a>00777                         LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue deadlock &quot;</span>
<a name="l00778"></a>00778                                    <span class="stringliteral">&quot;received&quot;</span>);
<a name="l00779"></a>00779                         rc = -EDEADLK;
<a name="l00780"></a>00780                 }
<a name="l00781"></a>00781                 ldlm_flock_destroy(lock, mode, <a class="code" href="group__LDLM.html#gae36b9cddb3e68705d21f384ad3a3e1e6" title="not a real flag, not saved in lock">LDLM_FL_WAIT_NOREPROC</a>);
<a name="l00782"></a>00782                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00783"></a>00783 
<a name="l00784"></a>00784                 <span class="comment">/* Need to wake up the waiter if we were evicted */</span>
<a name="l00785"></a>00785                 wake_up(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a0ca58a0480ef9503c3548499e27c2e43" title="If the lock is granted, a process sleeps on this waitq to learn when it&amp;#39;s no...">l_waitq</a>);
<a name="l00786"></a>00786 
<a name="l00787"></a>00787                 <span class="comment">/* An error is still to be returned, to propagate it up to</span>
<a name="l00788"></a>00788 <span class="comment">                 * ldlm_cli_enqueue_fini() caller. */</span>
<a name="l00789"></a>00789                 RETURN(rc ? : -EIO);
<a name="l00790"></a>00790         }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue granted&quot;</span>);
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         <span class="keywordflow">if</span> (flags &amp; LDLM_FL_TEST_LOCK) {
<a name="l00795"></a>00795                 <span class="comment">/* fcntl(F_GETLK) request */</span>
<a name="l00796"></a>00796                 <span class="comment">/* The old mode was saved in getlk-&gt;fl_type so that if the mode</span>
<a name="l00797"></a>00797 <span class="comment">                 * in the lock changes we can decref the appropriate refcount.*/</span>
<a name="l00798"></a>00798                 LASSERT(ldlm_is_test_lock(lock));
<a name="l00799"></a>00799                 ldlm_flock_destroy(lock, flock_type(getlk),
<a name="l00800"></a>00800                                    <a class="code" href="group__LDLM.html#gae36b9cddb3e68705d21f384ad3a3e1e6" title="not a real flag, not saved in lock">LDLM_FL_WAIT_NOREPROC</a>);
<a name="l00801"></a>00801                 <span class="keywordflow">switch</span> (lock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a>) {
<a name="l00802"></a>00802                 <span class="keywordflow">case</span> LCK_PR:
<a name="l00803"></a>00803                         flock_set_type(getlk, F_RDLCK);
<a name="l00804"></a>00804                         <span class="keywordflow">break</span>;
<a name="l00805"></a>00805                 <span class="keywordflow">case</span> LCK_PW:
<a name="l00806"></a>00806                         flock_set_type(getlk, F_WRLCK);
<a name="l00807"></a>00807                         <span class="keywordflow">break</span>;
<a name="l00808"></a>00808                 <span class="keywordflow">default</span>:
<a name="l00809"></a>00809                         flock_set_type(getlk, F_UNLCK);
<a name="l00810"></a>00810                 }
<a name="l00811"></a>00811                 flock_set_pid(getlk, (pid_t)lock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.l_flock.pid);
<a name="l00812"></a>00812                 flock_set_start(getlk,
<a name="l00813"></a>00813                                 (loff_t)lock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.l_flock.start);
<a name="l00814"></a>00814                 flock_set_end(getlk,
<a name="l00815"></a>00815                               (loff_t)lock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.l_flock.end);
<a name="l00816"></a>00816         } <span class="keywordflow">else</span> {
<a name="l00817"></a>00817                 __u64 noreproc = <a class="code" href="group__LDLM.html#gae36b9cddb3e68705d21f384ad3a3e1e6" title="not a real flag, not saved in lock">LDLM_FL_WAIT_NOREPROC</a>;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819                 <span class="comment">/* We need to reprocess the lock to do merges or splits</span>
<a name="l00820"></a>00820 <span class="comment">                 * with existing locks owned by this process. */</span>
<a name="l00821"></a>00821                 ldlm_process_flock_lock(lock, &amp;noreproc, 1, &amp;err, NULL);
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00824"></a>00824         RETURN(rc);
<a name="l00825"></a>00825 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga921f8d85541cbe1fa330b9a12080103f_cgraph.png" border="0" usemap="#group__LDLM_ga921f8d85541cbe1fa330b9a12080103f_cgraph_map" alt=""></div>
<map name="group__LDLM_ga921f8d85541cbe1fa330b9a12080103f_cgraph_map" id="group__LDLM_ga921f8d85541cbe1fa330b9a12080103f_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="263,5,401,35"/><area shape="rect" id="node5" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="255,59,409,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga2d77135057c3b9123a3ae5704752c946"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_addref" ref="ga2d77135057c3b9123a3ae5704752c946" args="(const struct lustre_handle *lockh, enum ldlm_mode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_lock_addref </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *&nbsp;</td>
          <td class="paramname"> <em>lockh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ldlm_mode&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add specified reader/writer reference to LDLM lock with handle <em>lockh</em>. </p>
<p>r/w reference type is determined by <em>mode</em> Calls ldlm_lock_addref_internal. </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l00717">717</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l01327">LDLM_LOCK_PUT</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00718"></a>00718 {
<a name="l00719"></a>00719         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock;
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         lock = ldlm_handle2lock(lockh);
<a name="l00722"></a>00722         LASSERTF(lock != NULL, <span class="stringliteral">&quot;Non-existing lock: &quot;</span>LPX64<span class="stringliteral">&quot;\n&quot;</span>, lockh-&gt;cookie);
<a name="l00723"></a>00723         ldlm_lock_addref_internal(lock, mode);
<a name="l00724"></a>00724         <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l00725"></a>00725 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga580d951cff91ebd5c1d2a7588d4c2ea3"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_addref_try" ref="ga580d951cff91ebd5c1d2a7588d4c2ea3" args="(const struct lustre_handle *lockh, enum ldlm_mode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_lock_addref_try </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *&nbsp;</td>
          <td class="paramname"> <em>lockh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ldlm_mode&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to add reader/writer reference to a lock with handle <em>lockh</em>, and fails if lock is already LDLM_FL_CBPENDING or destroyed. </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success, lock was addref-ed</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EAGAIN</em>&nbsp;</td><td>lock is being canceled. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l00760">760</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00784">ldlm_lock::l_readers</a>, <a class="el" href="lustre__dlm_8h_source.html#l01327">LDLM_LOCK_PUT</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00761"></a>00761 {
<a name="l00762"></a>00762         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock;
<a name="l00763"></a>00763         <span class="keywordtype">int</span>               result;
<a name="l00764"></a>00764 
<a name="l00765"></a>00765         result = -EAGAIN;
<a name="l00766"></a>00766         lock = ldlm_handle2lock(lockh);
<a name="l00767"></a>00767         <span class="keywordflow">if</span> (lock != NULL) {
<a name="l00768"></a>00768                 <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00769"></a>00769                 <span class="keywordflow">if</span> (lock-&gt;<a class="code" href="structldlm__lock.html#abb8a2696003a5ba2a21c2365ecc2d275" title="Lock r/w usage counters.">l_readers</a> != 0 || lock-&gt;l_writers != 0 ||
<a name="l00770"></a>00770                     !ldlm_is_cbpending(lock)) {
<a name="l00771"></a>00771                         ldlm_lock_addref_internal_nolock(lock, mode);
<a name="l00772"></a>00772                         result = 0;
<a name="l00773"></a>00773                 }
<a name="l00774"></a>00774                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00775"></a>00775                 <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l00776"></a>00776         }
<a name="l00777"></a>00777         <span class="keywordflow">return</span> result;
<a name="l00778"></a>00778 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga580d951cff91ebd5c1d2a7588d4c2ea3_cgraph.png" border="0" usemap="#group__LDLM_ga580d951cff91ebd5c1d2a7588d4c2ea3_cgraph_map" alt=""></div>
<map name="group__LDLM_ga580d951cff91ebd5c1d2a7588d4c2ea3_cgraph_map" id="group__LDLM_ga580d951cff91ebd5c1d2a7588d4c2ea3_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="223,5,361,35"/><area shape="rect" id="node5" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="215,59,369,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9e8b401ed51dda94f553670e73872135"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_allow_match" ref="ga9e8b401ed51dda94f553670e73872135" args="(struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_lock_allow_match </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark lock as "matchable" by OST. </p>
<p>Locks the lock and then </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__LDLM.html#gab9c1d858901b9d9a4db13ffbad095fb6" title="Mark lock as &quot;matchable&quot; by OST.">ldlm_lock_allow_match_locked</a> </dd></dl>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l01332">1332</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="ldlm__lock_8c_source.html#l01321">ldlm_lock_allow_match_locked()</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01333"></a>01333 {
<a name="l01334"></a>01334         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l01335"></a>01335         <a class="code" href="group__LDLM.html#gab9c1d858901b9d9a4db13ffbad095fb6" title="Mark lock as &amp;quot;matchable&amp;quot; by OST.">ldlm_lock_allow_match_locked</a>(lock);
<a name="l01336"></a>01336         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l01337"></a>01337 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga9e8b401ed51dda94f553670e73872135_cgraph.png" border="0" usemap="#group__LDLM_ga9e8b401ed51dda94f553670e73872135_cgraph_map" alt=""></div>
<map name="group__LDLM_ga9e8b401ed51dda94f553670e73872135_cgraph_map" id="group__LDLM_ga9e8b401ed51dda94f553670e73872135_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#gab9c1d858901b9d9a4db13ffbad095fb6" title="Mark lock as &quot;matchable&quot; by OST." alt="" coords="228,5,449,35"/><area shape="rect" id="node5" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="269,59,408,88"/><area shape="rect" id="node7" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="261,112,416,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gab9c1d858901b9d9a4db13ffbad095fb6"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_allow_match_locked" ref="gab9c1d858901b9d9a4db13ffbad095fb6" args="(struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_lock_allow_match_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark lock as "matchable" by OST. </p>
<p>Used to prevent certain races in LOV/OSC where the lock is granted, but LVB is not yet valid. Assumes LDLM lock is already locked. </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l01321">1321</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00791">ldlm_lock::l_waitq</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l01332">ldlm_lock_allow_match()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01322"></a>01322 {
<a name="l01323"></a>01323         ldlm_set_lvb_ready(lock);
<a name="l01324"></a>01324         wake_up_all(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a0ca58a0480ef9503c3548499e27c2e43" title="If the lock is granted, a process sleeps on this waitq to learn when it&amp;#39;s no...">l_waitq</a>);
<a name="l01325"></a>01325 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gab9c1d858901b9d9a4db13ffbad095fb6_icgraph.png" border="0" usemap="#group__LDLM_gab9c1d858901b9d9a4db13ffbad095fb6_icgraph_map" alt=""></div>
<map name="group__LDLM_gab9c1d858901b9d9a4db13ffbad095fb6_icgraph_map" id="group__LDLM_gab9c1d858901b9d9a4db13ffbad095fb6_icgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga9e8b401ed51dda94f553670e73872135" title="Mark lock as &quot;matchable&quot; by OST." alt="" coords="277,5,451,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gafd6a07a826f7d2789696e472dd81adc2"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_change_resource" ref="gafd6a07a826f7d2789696e472dd81adc2" args="(struct ldlm_namespace *, struct ldlm_lock *, const struct ldlm_res_id *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_lock_change_resource </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *&nbsp;</td>
          <td class="paramname"> <em>new_resid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves LDLM lock <em>lock</em> to another resource. </p>
<p>This is used on client when server returns some other lock than requested (typically as a result of intent operation) </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l00514">514</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00689">ldlm_lock::l_lock</a>, <a class="el" href="lustre__dlm_8h_source.html#l00705">ldlm_lock::l_res_link</a>, <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>, <a class="el" href="ldlm__resource_8c_source.html#l01179">ldlm_resource_get()</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00951">ldlm_resource::lr_name</a>, <a class="el" href="lustre__dlm_8h_source.html#l00984">ldlm_resource::lr_reference</a>, <a class="el" href="lustre__dlm_8h_source.html#l00970">ldlm_resource::lr_type</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00541">ldlm_cli_enqueue_fini()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00516"></a>00516 {
<a name="l00517"></a>00517         <span class="keyword">struct </span><a class="code" href="structldlm__resource.html" title="LDLM resource description.">ldlm_resource</a> *oldres = lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>;
<a name="l00518"></a>00518         <span class="keyword">struct </span><a class="code" href="structldlm__resource.html" title="LDLM resource description.">ldlm_resource</a> *newres;
<a name="l00519"></a>00519         <span class="keywordtype">int</span> type;
<a name="l00520"></a>00520         ENTRY;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522         LASSERT(ns_is_client(ns));
<a name="l00523"></a>00523 
<a name="l00524"></a>00524         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00525"></a>00525         <span class="keywordflow">if</span> (memcmp(new_resid, &amp;lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>-&gt;<a class="code" href="structldlm__resource.html#aa749561d4248b6066c028d44def461dc" title="Resource name.">lr_name</a>,
<a name="l00526"></a>00526                    <span class="keyword">sizeof</span>(lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>-&gt;<a class="code" href="structldlm__resource.html#aa749561d4248b6066c028d44def461dc" title="Resource name.">lr_name</a>)) == 0) {
<a name="l00527"></a>00527                 <span class="comment">/* Nothing to do */</span>
<a name="l00528"></a>00528                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00529"></a>00529                 RETURN(0);
<a name="l00530"></a>00530         }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         LASSERT(new_resid-&gt;name[0] != 0);
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         <span class="comment">/* This function assumes that the lock isn&apos;t on any lists */</span>
<a name="l00535"></a>00535         LASSERT(list_empty(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a64ad5a636aec3f0825f1eea9df1a5734" title="Linkage to resource&amp;#39;s lock queues according to current lock state.">l_res_link</a>));
<a name="l00536"></a>00536 
<a name="l00537"></a>00537         type = oldres-&gt;<a class="code" href="structldlm__resource.html#a49b3d8776d2a7ff57e963c988d1de5cf" title="Type of locks this resource can hold.">lr_type</a>;
<a name="l00538"></a>00538         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00539"></a>00539 
<a name="l00540"></a>00540         newres = <a class="code" href="group__LDLM.html#ga083fb1ea92619c4b2e526633c3a486fb" title="Return a reference to resource with given name, creating it if necessary.">ldlm_resource_get</a>(ns, NULL, new_resid, type, 1);
<a name="l00541"></a>00541         <span class="keywordflow">if</span> (IS_ERR(newres))
<a name="l00542"></a>00542                 RETURN(PTR_ERR(newres));
<a name="l00543"></a>00543 
<a name="l00544"></a>00544         lu_ref_add(&amp;newres-&gt;<a class="code" href="structldlm__resource.html#a5313c4407b408d5d1a9e183559eb85e2" title="List of references to this resource.">lr_reference</a>, <span class="stringliteral">&quot;lock&quot;</span>, lock);
<a name="l00545"></a>00545         <span class="comment">/*</span>
<a name="l00546"></a>00546 <span class="comment">         * To flip the lock from the old to the new resource, lock, oldres and</span>
<a name="l00547"></a>00547 <span class="comment">         * newres have to be locked. Resource spin-locks are nested within</span>
<a name="l00548"></a>00548 <span class="comment">         * lock-&gt;l_lock, and are taken in the memory address order to avoid</span>
<a name="l00549"></a>00549 <span class="comment">         * dead-locks.</span>
<a name="l00550"></a>00550 <span class="comment">         */</span>
<a name="l00551"></a>00551         spin_lock(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#ab7ff3f52f4765c133758c21e0d224a8b" title="Internal spinlock protects l_resource.">l_lock</a>);
<a name="l00552"></a>00552         oldres = lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>;
<a name="l00553"></a>00553         <span class="keywordflow">if</span> (oldres &lt; newres) {
<a name="l00554"></a>00554                 lock_res(oldres);
<a name="l00555"></a>00555                 lock_res_nested(newres, LRT_NEW);
<a name="l00556"></a>00556         } <span class="keywordflow">else</span> {
<a name="l00557"></a>00557                 lock_res(newres);
<a name="l00558"></a>00558                 lock_res_nested(oldres, LRT_NEW);
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560         LASSERT(memcmp(new_resid, &amp;oldres-&gt;<a class="code" href="structldlm__resource.html#aa749561d4248b6066c028d44def461dc" title="Resource name.">lr_name</a>,
<a name="l00561"></a>00561                        <span class="keyword">sizeof</span> oldres-&gt;<a class="code" href="structldlm__resource.html#aa749561d4248b6066c028d44def461dc" title="Resource name.">lr_name</a>) != 0);
<a name="l00562"></a>00562         lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a> = newres;
<a name="l00563"></a>00563         unlock_res(oldres);
<a name="l00564"></a>00564         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00565"></a>00565 
<a name="l00566"></a>00566         <span class="comment">/* ...and the flowers are still standing! */</span>
<a name="l00567"></a>00567         lu_ref_del(&amp;oldres-&gt;<a class="code" href="structldlm__resource.html#a5313c4407b408d5d1a9e183559eb85e2" title="List of references to this resource.">lr_reference</a>, <span class="stringliteral">&quot;lock&quot;</span>, lock);
<a name="l00568"></a>00568         ldlm_resource_putref(oldres);
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         RETURN(0);
<a name="l00571"></a>00571 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gafd6a07a826f7d2789696e472dd81adc2_cgraph.png" border="0" usemap="#group__LDLM_gafd6a07a826f7d2789696e472dd81adc2_cgraph_map" alt=""></div>
<map name="group__LDLM_gafd6a07a826f7d2789696e472dd81adc2_cgraph_map" id="group__LDLM_gafd6a07a826f7d2789696e472dd81adc2_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga083fb1ea92619c4b2e526633c3a486fb" title="Return a reference to resource with given name, creating it if necessary." alt="" coords="264,5,411,35"/><area shape="rect" id="node5" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="268,59,407,88"/><area shape="rect" id="node7" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="260,112,415,141"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gafd6a07a826f7d2789696e472dd81adc2_icgraph.png" border="0" usemap="#group__LDLM_gafd6a07a826f7d2789696e472dd81adc2_icgraph_map" alt=""></div>
<map name="group__LDLM_gafd6a07a826f7d2789696e472dd81adc2_icgraph_map" id="group__LDLM_gafd6a07a826f7d2789696e472dd81adc2_icgraph">
<area shape="rect" id="node3" href="group__ldlm__cli__api.html#gac421005283912bb5186b035013aa58c0" title="Finishing portion of client lock enqueue code." alt="" coords="259,5,421,35"/><area shape="rect" id="node5" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="469,5,605,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaeeab5a5dbe0a5b966d52f388b69eed3f"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_convert" ref="gaeeab5a5dbe0a5b966d52f388b69eed3f" args="(struct ldlm_lock *lock, enum ldlm_mode new_mode, __u32 *flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structldlm__resource.html">ldlm_resource</a>* ldlm_lock_convert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ldlm_mode&nbsp;</td>
          <td class="paramname"> <em>new_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32 *&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to convert already granted lock to a different mode. </p>
<p>While lock conversion is not currently used, future client-side optimizations could take advantage of it to avoid discarding cached pages on a file. </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l02459">2459</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00730">ldlm_lock::l_completion_ast</a>, <a class="el" href="lustre__dlm_8h_source.html#l00728">ldlm_lock::l_granted_mode</a>, <a class="el" href="lustre__dlm_8h_source.html#l00724">ldlm_lock::l_req_mode</a>, <a class="el" href="lustre__dlm_8h_source.html#l00705">ldlm_lock::l_res_link</a>, <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>, <a class="el" href="lustre__dlm_8h_source.html#l00881">ldlm_lock::l_sl_mode</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00040">LDLM_FL_BLOCK_GRANTED</a>, <a class="el" href="ldlm__resource_8c_source.html#l01323">ldlm_resource_add_lock()</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00943">ldlm_resource::lr_converting</a>, <a class="el" href="lustre__dlm_8h_source.html#l00970">ldlm_resource::lr_type</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00466">ldlm_namespace::ns_pool</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02461"></a>02461 {
<a name="l02462"></a>02462         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> rpc_list;
<a name="l02463"></a>02463         <span class="keyword">struct </span><a class="code" href="structldlm__resource.html" title="LDLM resource description.">ldlm_resource</a> *res;
<a name="l02464"></a>02464         <span class="keyword">struct </span><a class="code" href="structldlm__namespace.html" title="LDLM Namespace.">ldlm_namespace</a> *ns;
<a name="l02465"></a>02465         <span class="keywordtype">int</span> granted = 0;
<a name="l02466"></a>02466 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02467"></a>02467 <span class="preprocessor"></span>        <span class="keywordtype">int</span> old_mode;
<a name="l02468"></a>02468         <span class="keyword">struct </span>sl_insert_point prev;
<a name="l02469"></a>02469 <span class="preprocessor">#endif</span>
<a name="l02470"></a>02470 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structldlm__interval.html" title="Interval node data for each LDLM_EXTENT lock.">ldlm_interval</a> *node;
<a name="l02471"></a>02471         ENTRY;
<a name="l02472"></a>02472 
<a name="l02473"></a>02473         INIT_LIST_HEAD(&amp;rpc_list);
<a name="l02474"></a>02474         <span class="comment">/* Just return if mode is unchanged. */</span>
<a name="l02475"></a>02475         <span class="keywordflow">if</span> (new_mode == lock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a>) {
<a name="l02476"></a>02476                 *flags |= <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a>;
<a name="l02477"></a>02477                 RETURN(lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>);
<a name="l02478"></a>02478         }
<a name="l02479"></a>02479 
<a name="l02480"></a>02480         <span class="comment">/* I can&apos;t check the type of lock here because the bitlock of lock</span>
<a name="l02481"></a>02481 <span class="comment">         * is not held here, so do the allocation blindly. -jay */</span>
<a name="l02482"></a>02482         OBD_SLAB_ALLOC_PTR_GFP(node, ldlm_interval_slab, GFP_NOFS);
<a name="l02483"></a>02483         <span class="keywordflow">if</span> (node == NULL)  <span class="comment">/* Actually, this causes EDEADLOCK to be returned */</span>
<a name="l02484"></a>02484                 RETURN(NULL);
<a name="l02485"></a>02485 
<a name="l02486"></a>02486         LASSERTF((new_mode == LCK_PW &amp;&amp; lock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a> == LCK_PR),
<a name="l02487"></a>02487                  <span class="stringliteral">&quot;new_mode %u, granted %u\n&quot;</span>, new_mode, lock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a>);
<a name="l02488"></a>02488 
<a name="l02489"></a>02489         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l02490"></a>02490 
<a name="l02491"></a>02491         res = lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>;
<a name="l02492"></a>02492         ns  = ldlm_res_to_ns(res);
<a name="l02493"></a>02493 
<a name="l02494"></a>02494 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02495"></a>02495 <span class="preprocessor"></span>        old_mode = lock-&gt;<a class="code" href="structldlm__lock.html#a4c3ab4e1a3ec7f022d954251e6eafa67" title="Requested mode.">l_req_mode</a>;
<a name="l02496"></a>02496 <span class="preprocessor">#endif</span>
<a name="l02497"></a>02497 <span class="preprocessor"></span>        lock-&gt;<a class="code" href="structldlm__lock.html#a4c3ab4e1a3ec7f022d954251e6eafa67" title="Requested mode.">l_req_mode</a> = new_mode;
<a name="l02498"></a>02498         <span class="keywordflow">if</span> (res-&gt;<a class="code" href="structldlm__resource.html#a49b3d8776d2a7ff57e963c988d1de5cf" title="Type of locks this resource can hold.">lr_type</a> == LDLM_PLAIN || res-&gt;<a class="code" href="structldlm__resource.html#a49b3d8776d2a7ff57e963c988d1de5cf" title="Type of locks this resource can hold.">lr_type</a> == LDLM_IBITS) {
<a name="l02499"></a>02499 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02500"></a>02500 <span class="preprocessor"></span>                <span class="comment">/* remember the lock position where the lock might be</span>
<a name="l02501"></a>02501 <span class="comment">                 * added back to the granted list later and also</span>
<a name="l02502"></a>02502 <span class="comment">                 * remember the join mode for skiplist fixing. */</span>
<a name="l02503"></a>02503                 prev.res_link = lock-&gt;<a class="code" href="structldlm__lock.html#a64ad5a636aec3f0825f1eea9df1a5734" title="Linkage to resource&amp;#39;s lock queues according to current lock state.">l_res_link</a>.prev;
<a name="l02504"></a>02504                 prev.mode_link = lock-&gt;<a class="code" href="structldlm__lock.html#aa26a328bc8c2e6eff25c62c2d6e8c9ee" title="Protected by lr_lock, linkages to &amp;quot;skip lists&amp;quot;.">l_sl_mode</a>.prev;
<a name="l02505"></a>02505                 prev.policy_link = lock-&gt;l_sl_policy.prev;
<a name="l02506"></a>02506 <span class="preprocessor">#endif</span>
<a name="l02507"></a>02507 <span class="preprocessor"></span>                ldlm_resource_unlink_lock(lock);
<a name="l02508"></a>02508         } <span class="keywordflow">else</span> {
<a name="l02509"></a>02509                 ldlm_resource_unlink_lock(lock);
<a name="l02510"></a>02510                 <span class="keywordflow">if</span> (res-&gt;<a class="code" href="structldlm__resource.html#a49b3d8776d2a7ff57e963c988d1de5cf" title="Type of locks this resource can hold.">lr_type</a> == LDLM_EXTENT) {
<a name="l02511"></a>02511                         <span class="comment">/* FIXME: ugly code, I have to attach the lock to a</span>
<a name="l02512"></a>02512 <span class="comment">                         * interval node again since perhaps it will be granted</span>
<a name="l02513"></a>02513 <span class="comment">                         * soon */</span>
<a name="l02514"></a>02514                         INIT_LIST_HEAD(&amp;node-&gt;li_group);
<a name="l02515"></a>02515                         ldlm_interval_attach(node, lock);
<a name="l02516"></a>02516                         node = NULL;
<a name="l02517"></a>02517                 }
<a name="l02518"></a>02518         }
<a name="l02519"></a>02519 
<a name="l02520"></a>02520         <span class="comment">/*</span>
<a name="l02521"></a>02521 <span class="comment">         * Remove old lock from the pool before adding the lock with new</span>
<a name="l02522"></a>02522 <span class="comment">         * mode below in -&gt;policy()</span>
<a name="l02523"></a>02523 <span class="comment">         */</span>
<a name="l02524"></a>02524         ldlm_pool_del(&amp;ns-&gt;<a class="code" href="structldlm__namespace.html#aa7af6cd55b6e2bfa2b4cfc6134bb51e3" title="LDLM pool structure for this namespace.">ns_pool</a>, lock);
<a name="l02525"></a>02525 
<a name="l02526"></a>02526         <span class="comment">/* If this is a local resource, put it on the appropriate list. */</span>
<a name="l02527"></a>02527         <span class="keywordflow">if</span> (ns_is_client(ldlm_res_to_ns(res))) {
<a name="l02528"></a>02528                 <span class="keywordflow">if</span> (*flags &amp; (<a class="code" href="group__LDLM.html#ga912be807748854a27fde8d99ab122dc2" title="Server placed lock on conv list, or a recovering client wants the lock added to the...">LDLM_FL_BLOCK_CONV</a> | <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a>)) {
<a name="l02529"></a>02529                         <a class="code" href="group__LDLM.html#gaee0426408b282c2c2606c218f79dcd9a" title="Add a lock into a given resource into specified lock list.">ldlm_resource_add_lock</a>(res, &amp;res-&gt;<a class="code" href="structldlm__resource.html#a29e2572837238205fc2e5180618d1fd5" title="List of locks waiting to change their granted mode (converted).">lr_converting</a>, lock);
<a name="l02530"></a>02530                 } <span class="keywordflow">else</span> {
<a name="l02531"></a>02531                         <span class="comment">/* This should never happen, because of the way the</span>
<a name="l02532"></a>02532 <span class="comment">                         * server handles conversions. */</span>
<a name="l02533"></a>02533                         LDLM_ERROR(lock, <span class="stringliteral">&quot;Erroneous flags %x on local lock\n&quot;</span>,
<a name="l02534"></a>02534                                    *flags);
<a name="l02535"></a>02535                         LBUG();
<a name="l02536"></a>02536 
<a name="l02537"></a>02537                         ldlm_grant_lock(lock, &amp;rpc_list);
<a name="l02538"></a>02538                         granted = 1;
<a name="l02539"></a>02539                         <span class="comment">/* FIXME: completion handling not with lr_lock held ! */</span>
<a name="l02540"></a>02540                         <span class="keywordflow">if</span> (lock-&gt;<a class="code" href="structldlm__lock.html#aa8070acdaa6bb825842083d710f8a935" title="Lock completion handler pointer.">l_completion_ast</a>)
<a name="l02541"></a>02541                                 lock-&gt;<a class="code" href="structldlm__lock.html#aa8070acdaa6bb825842083d710f8a935" title="Lock completion handler pointer.">l_completion_ast</a>(lock, 0, NULL);
<a name="l02542"></a>02542                 }
<a name="l02543"></a>02543 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02544"></a>02544 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
<a name="l02545"></a>02545                 <span class="keywordtype">int</span> rc;
<a name="l02546"></a>02546                 <span class="keyword">enum</span> <a class="code" href="group__LDLM.html#gaa2fbd012972eb2b2d0653c8df02964f7" title="LDLM non-error return states.">ldlm_error</a> err;
<a name="l02547"></a>02547                 __u64 pflags = 0;
<a name="l02548"></a>02548                 ldlm_processing_policy policy;
<a name="l02549"></a>02549 
<a name="l02550"></a>02550                 policy = ldlm_processing_policy_table[res-&gt;<a class="code" href="structldlm__resource.html#a49b3d8776d2a7ff57e963c988d1de5cf" title="Type of locks this resource can hold.">lr_type</a>];
<a name="l02551"></a>02551                 rc = policy(lock, &amp;pflags, 0, &amp;err, &amp;rpc_list);
<a name="l02552"></a>02552                 <span class="keywordflow">if</span> (rc == LDLM_ITER_STOP) {
<a name="l02553"></a>02553                         lock-&gt;<a class="code" href="structldlm__lock.html#a4c3ab4e1a3ec7f022d954251e6eafa67" title="Requested mode.">l_req_mode</a> = old_mode;
<a name="l02554"></a>02554                         <span class="keywordflow">if</span> (res-&gt;<a class="code" href="structldlm__resource.html#a49b3d8776d2a7ff57e963c988d1de5cf" title="Type of locks this resource can hold.">lr_type</a> == LDLM_EXTENT)
<a name="l02555"></a>02555                                 ldlm_extent_add_lock(res, lock);
<a name="l02556"></a>02556                         <span class="keywordflow">else</span>
<a name="l02557"></a>02557                                 ldlm_granted_list_add_lock(lock, &amp;prev);
<a name="l02558"></a>02558 
<a name="l02559"></a>02559                         res = NULL;
<a name="l02560"></a>02560                 } <span class="keywordflow">else</span> {
<a name="l02561"></a>02561                         *flags |= <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a>;
<a name="l02562"></a>02562                         granted = 1;
<a name="l02563"></a>02563                 }
<a name="l02564"></a>02564         }
<a name="l02565"></a>02565 <span class="preprocessor">#else</span>
<a name="l02566"></a>02566 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
<a name="l02567"></a>02567                 CERROR(<span class="stringliteral">&quot;This is client-side-only module, cannot handle &quot;</span>
<a name="l02568"></a>02568                        <span class="stringliteral">&quot;LDLM_NAMESPACE_SERVER resource type lock.\n&quot;</span>);
<a name="l02569"></a>02569                 LBUG();
<a name="l02570"></a>02570         }
<a name="l02571"></a>02571 <span class="preprocessor">#endif</span>
<a name="l02572"></a>02572 <span class="preprocessor"></span>        <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l02573"></a>02573 
<a name="l02574"></a>02574         <span class="keywordflow">if</span> (granted)
<a name="l02575"></a>02575                 ldlm_run_ast_work(ns, &amp;rpc_list, LDLM_WORK_CP_AST);
<a name="l02576"></a>02576         <span class="keywordflow">if</span> (node)
<a name="l02577"></a>02577                 OBD_SLAB_FREE(node, ldlm_interval_slab, <span class="keyword">sizeof</span>(*node));
<a name="l02578"></a>02578         RETURN(res);
<a name="l02579"></a>02579 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gaeeab5a5dbe0a5b966d52f388b69eed3f_cgraph.png" border="0" usemap="#group__LDLM_gaeeab5a5dbe0a5b966d52f388b69eed3f_cgraph_map" alt=""></div>
<map name="group__LDLM_gaeeab5a5dbe0a5b966d52f388b69eed3f_cgraph_map" id="group__LDLM_gaeeab5a5dbe0a5b966d52f388b69eed3f_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#gaee0426408b282c2c2606c218f79dcd9a" title="Add a lock into a given resource into specified lock list." alt="" coords="197,5,376,35"/><area shape="rect" id="node5" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="217,59,356,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga833125f7d72f8e77cb16c031c56dd2a0"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_destroy" ref="ga833125f7d72f8e77cb16c031c56dd2a0" args="(struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_lock_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys a LDLM lock <em>lock</em>. </p>
<p>Performs necessary locking first. </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l00403">403</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00885">ldlm_lock::l_reference</a>, <a class="el" href="lustre__dlm_8h_source.html#l01338">LDLM_LOCK_RELEASE</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00404"></a>00404 {
<a name="l00405"></a>00405         <span class="keywordtype">int</span> first;
<a name="l00406"></a>00406         ENTRY;
<a name="l00407"></a>00407         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00408"></a>00408         first = ldlm_lock_destroy_internal(lock);
<a name="l00409"></a>00409         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411         <span class="comment">/* drop reference from hashtable only for first destroy */</span>
<a name="l00412"></a>00412         <span class="keywordflow">if</span> (first) {
<a name="l00413"></a>00413                 lu_ref_del(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a2cc84a3989e5b197caffa7a0fe014f27" title="Reference tracking structure to debug leaked locks.">l_reference</a>, <span class="stringliteral">&quot;hash&quot;</span>, lock);
<a name="l00414"></a>00414                 <a class="code" href="group__LDLM.html#gaf3357d35be5378aa299677e298c5a625" title="Release a lock reference obtained by some other means (see LDLM_LOCK_PUT()).">LDLM_LOCK_RELEASE</a>(lock);
<a name="l00415"></a>00415         }
<a name="l00416"></a>00416         EXIT;
<a name="l00417"></a>00417 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga833125f7d72f8e77cb16c031c56dd2a0_cgraph.png" border="0" usemap="#group__LDLM_ga833125f7d72f8e77cb16c031c56dd2a0_cgraph_map" alt=""></div>
<map name="group__LDLM_ga833125f7d72f8e77cb16c031c56dd2a0_cgraph_map" id="group__LDLM_ga833125f7d72f8e77cb16c031c56dd2a0_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="204,5,343,35"/><area shape="rect" id="node5" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="196,59,351,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga1ae32c9c745cefc485fd39cf0054e2ef"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_downgrade" ref="ga1ae32c9c745cefc485fd39cf0054e2ef" args="(struct ldlm_lock *lock, enum ldlm_mode new_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_lock_downgrade </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ldlm_mode&nbsp;</td>
          <td class="paramname"> <em>new_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Downgrade an exclusive lock. </p>
<p>A fast variant of ldlm_lock_convert for convertion of exclusive locks. The convertion is always successful. Used by Commit on Sharing (COS) code.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>A lock to convert </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_mode</em>&nbsp;</td><td>new lock mode </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l02428">2428</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00728">ldlm_lock::l_granted_mode</a>, <a class="el" href="lustre__dlm_8h_source.html#l00724">ldlm_lock::l_req_mode</a>, <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>, <a class="el" href="ldlm__lock_8c_source.html#l02147">ldlm_reprocess_all()</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02429"></a>02429 {
<a name="l02430"></a>02430         ENTRY;
<a name="l02431"></a>02431 
<a name="l02432"></a>02432         LASSERT(lock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a> &amp; (LCK_PW | LCK_EX));
<a name="l02433"></a>02433         LASSERT(new_mode == LCK_COS);
<a name="l02434"></a>02434 
<a name="l02435"></a>02435         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l02436"></a>02436         ldlm_resource_unlink_lock(lock);
<a name="l02437"></a>02437         <span class="comment">/*</span>
<a name="l02438"></a>02438 <span class="comment">         * Remove the lock from pool as it will be added again in</span>
<a name="l02439"></a>02439 <span class="comment">         * ldlm_grant_lock() called below.</span>
<a name="l02440"></a>02440 <span class="comment">         */</span>
<a name="l02441"></a>02441         ldlm_pool_del(&amp;ldlm_lock_to_ns(lock)-&gt;ns_pool, lock);
<a name="l02442"></a>02442 
<a name="l02443"></a>02443         lock-&gt;<a class="code" href="structldlm__lock.html#a4c3ab4e1a3ec7f022d954251e6eafa67" title="Requested mode.">l_req_mode</a> = new_mode;
<a name="l02444"></a>02444         ldlm_grant_lock(lock, NULL);
<a name="l02445"></a>02445         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l02446"></a>02446         <a class="code" href="group__LDLM.html#ga6fea368fc4ea7002b0dcd068bbe8771a" title="Try to grant all waiting locks on a resource.">ldlm_reprocess_all</a>(lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>);
<a name="l02447"></a>02447 
<a name="l02448"></a>02448         EXIT;
<a name="l02449"></a>02449 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga1ae32c9c745cefc485fd39cf0054e2ef_cgraph.png" border="0" usemap="#group__LDLM_ga1ae32c9c745cefc485fd39cf0054e2ef_cgraph_map" alt=""></div>
<map name="group__LDLM_ga1ae32c9c745cefc485fd39cf0054e2ef_cgraph_map" id="group__LDLM_ga1ae32c9c745cefc485fd39cf0054e2ef_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga6fea368fc4ea7002b0dcd068bbe8771a" title="Try to grant all waiting locks on a resource." alt="" coords="224,5,365,35"/><area shape="rect" id="node5" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="225,59,364,88"/><area shape="rect" id="node7" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="217,112,372,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga5f3ca6b2c348db5cd17b45c0e2b99ba8"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_dump_handle" ref="ga5f3ca6b2c348db5cd17b45c0e2b99ba8" args="(int level, const struct lustre_handle *lockh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_lock_dump_handle </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *&nbsp;</td>
          <td class="paramname"> <em>lockh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print lock with lock handle <em>lockh</em> description into debug log. </p>
<p>Used when printing all locks on a resource for debug purposes. </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l02586">2586</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l01167">LDLM_DEBUG_LIMIT</a>, and <a class="el" href="lustre__dlm_8h_source.html#l01327">LDLM_LOCK_PUT</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02587"></a>02587 {
<a name="l02588"></a>02588         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock;
<a name="l02589"></a>02589 
<a name="l02590"></a>02590         <span class="keywordflow">if</span> (!((libcfs_debug | D_ERROR) &amp; level))
<a name="l02591"></a>02591                 <span class="keywordflow">return</span>;
<a name="l02592"></a>02592 
<a name="l02593"></a>02593         lock = ldlm_handle2lock(lockh);
<a name="l02594"></a>02594         <span class="keywordflow">if</span> (lock == NULL)
<a name="l02595"></a>02595                 <span class="keywordflow">return</span>;
<a name="l02596"></a>02596 
<a name="l02597"></a>02597         <a class="code" href="group__LDLM.html#ga1e2b479743aab3ba4119e5c751a6f188" title="Support function for lock information printing into debug logs.">LDLM_DEBUG_LIMIT</a>(level, lock, <span class="stringliteral">&quot;###&quot;</span>);
<a name="l02598"></a>02598 
<a name="l02599"></a>02599         <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l02600"></a>02600 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac526504450a40715c8e25fbab715689e"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_get" ref="gac526504450a40715c8e25fbab715689e" args="(struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a>* ldlm_lock_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference on a lock. </p>
<p>Lock refcounts, during creation:</p>
<ul>
<li>one special one for allocation, dec'd only once in destroy</li>
<li>one for being a lock that's in-use</li>
<li>one for the addref associated with a new lock </li>
</ul>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l00178">178</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00179"></a>00179 {
<a name="l00180"></a>00180         atomic_inc(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#acd61f904bdcdfee7845701368db6003d" title="Lock reference count.">l_refc</a>);
<a name="l00181"></a>00181         <span class="keywordflow">return</span> lock;
<a name="l00182"></a>00182 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga1373811e4c4edbb039f1da1ca7947b03"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_match" ref="ga1373811e4c4edbb039f1da1ca7947b03" args="(struct ldlm_namespace *ns, __u64 flags, const struct ldlm_res_id *, enum ldlm_type type, union ldlm_policy_data *, enum ldlm_mode mode, struct lustre_handle *, int unref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum ldlm_mode ldlm_lock_match </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *&nbsp;</td>
          <td class="paramname"> <em>res_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ldlm_type&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ldlm_mode&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *&nbsp;</td>
          <td class="paramname"> <em>lockh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>unref</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to find a lock with specified properties. </p>
<p>Typically returns a reference to matched lock unless LDLM_FL_TEST_LOCK is set in <em>flags</em> </p>
<p>Can be called in two ways:</p>
<p>If 'ns' is NULL, then lockh describes an existing lock that we want to look for a duplicate of.</p>
<p>Otherwise, all of the fields must be filled in, to match against.</p>
<p>If 'flags' contains LDLM_FL_LOCAL_ONLY, then only match local locks on the server (ie, connh is NULL) If 'flags' contains LDLM_FL_BLOCK_GRANTED, then only locks on the granted list will be considered If 'flags' contains LDLM_FL_CBPENDING, then locks that have been marked to be canceled can still be matched as long as they still have reader or writer refernces If 'flags' contains LDLM_FL_TEST_LOCK, then don't actually reference a lock, just tell us if we would have matched.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if it finds an already-existing lock that is compatible; in this case, lockh is filled in with a addref()ed lock</td></tr>
  </table>
  </dd>
</dl>
<p>We also check security context, and if that fails we simply return 0 (to keep caller code unchanged), the context failure will be discovered by caller sometime later. </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l01370">1370</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00730">ldlm_lock::l_completion_ast</a>, <a class="el" href="lustre__dlm_8h_source.html#l00759">ldlm_lock::l_conn_export</a>, <a class="el" href="lustre__dlm_8h_source.html#l00778">ldlm_lock::l_flags</a>, <a class="el" href="lustre__dlm_8h_source.html#l00791">ldlm_lock::l_waitq</a>, <a class="el" href="lustre__dlm_8h_source.html#l01122">LDLM_DEBUG_NOLOCK</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00040">LDLM_FL_BLOCK_GRANTED</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00309">LDLM_FL_DESTROYED</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00298">LDLM_FL_FAIL_NOTIFIED</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00226">LDLM_FL_LVB_READY</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00114">LDLM_FL_TEST_LOCK</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00179">LDLM_FL_WAIT_NOREPROC</a>, <a class="el" href="ldlm__lock_8c_source.html#l00582">ldlm_lock2handle()</a>, <a class="el" href="lustre__dlm_8h_source.html#l01327">LDLM_LOCK_PUT</a>, <a class="el" href="lustre__dlm_8h_source.html#l01338">LDLM_LOCK_RELEASE</a>, <a class="el" href="ldlm__resource_8c_source.html#l01179">ldlm_resource_get()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00943">ldlm_resource::lr_converting</a>, <a class="el" href="lustre__dlm_8h_source.html#l00941">ldlm_resource::lr_granted</a>, <a class="el" href="lustre__dlm_8h_source.html#l00970">ldlm_resource::lr_type</a>, <a class="el" href="lustre__dlm_8h_source.html#l00947">ldlm_resource::lr_waiting</a>, and <a class="el" href="sec_8c_source.html#l00926">sptlrpc_import_check_ctx()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01376"></a>01376 {
<a name="l01377"></a>01377         <span class="keyword">struct </span>lock_match_data data = {
<a name="l01378"></a>01378                 .lmd_old        = NULL,
<a name="l01379"></a>01379                 .lmd_lock       = NULL,
<a name="l01380"></a>01380                 .lmd_mode       = &amp;mode,
<a name="l01381"></a>01381                 .lmd_policy     = policy,
<a name="l01382"></a>01382                 .lmd_flags      = flags,
<a name="l01383"></a>01383                 .lmd_unref      = unref,
<a name="l01384"></a>01384         };
<a name="l01385"></a>01385         <span class="keyword">struct </span><a class="code" href="structldlm__resource.html" title="LDLM resource description.">ldlm_resource</a> *res;
<a name="l01386"></a>01386         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock;
<a name="l01387"></a>01387         <span class="keywordtype">int</span> rc = 0;
<a name="l01388"></a>01388         ENTRY;
<a name="l01389"></a>01389 
<a name="l01390"></a>01390         <span class="keywordflow">if</span> (ns == NULL) {
<a name="l01391"></a>01391                 data.lmd_old = ldlm_handle2lock(lockh);
<a name="l01392"></a>01392                 LASSERT(data.lmd_old != NULL);
<a name="l01393"></a>01393 
<a name="l01394"></a>01394                 ns = ldlm_lock_to_ns(data.lmd_old);
<a name="l01395"></a>01395                 res_id = &amp;data.lmd_old-&gt;l_resource-&gt;lr_name;
<a name="l01396"></a>01396                 type = data.lmd_old-&gt;l_resource-&gt;lr_type;
<a name="l01397"></a>01397                 *data.lmd_mode = data.lmd_old-&gt;l_req_mode;
<a name="l01398"></a>01398         }
<a name="l01399"></a>01399 
<a name="l01400"></a>01400         res = <a class="code" href="group__LDLM.html#ga083fb1ea92619c4b2e526633c3a486fb" title="Return a reference to resource with given name, creating it if necessary.">ldlm_resource_get</a>(ns, NULL, res_id, type, 0);
<a name="l01401"></a>01401         <span class="keywordflow">if</span> (IS_ERR(res)) {
<a name="l01402"></a>01402                 LASSERT(data.lmd_old == NULL);
<a name="l01403"></a>01403                 RETURN(0);
<a name="l01404"></a>01404         }
<a name="l01405"></a>01405 
<a name="l01406"></a>01406         LDLM_RESOURCE_ADDREF(res);
<a name="l01407"></a>01407         lock_res(res);
<a name="l01408"></a>01408 
<a name="l01409"></a>01409         <span class="keywordflow">if</span> (res-&gt;<a class="code" href="structldlm__resource.html#a49b3d8776d2a7ff57e963c988d1de5cf" title="Type of locks this resource can hold.">lr_type</a> == LDLM_EXTENT)
<a name="l01410"></a>01410                 lock = search_itree(res, &amp;data);
<a name="l01411"></a>01411         <span class="keywordflow">else</span>
<a name="l01412"></a>01412                 lock = search_queue(&amp;res-&gt;<a class="code" href="structldlm__resource.html#aeb092453fc0c7d4db2ae7cd3dddd593a" title="protected by lr_lock">lr_granted</a>, &amp;data);
<a name="l01413"></a>01413         <span class="keywordflow">if</span> (lock != NULL)
<a name="l01414"></a>01414                 GOTO(out, rc = 1);
<a name="l01415"></a>01415         <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a>)
<a name="l01416"></a>01416                 GOTO(out, rc = 0);
<a name="l01417"></a>01417         lock = search_queue(&amp;res-&gt;<a class="code" href="structldlm__resource.html#a29e2572837238205fc2e5180618d1fd5" title="List of locks waiting to change their granted mode (converted).">lr_converting</a>, &amp;data);
<a name="l01418"></a>01418         <span class="keywordflow">if</span> (lock != NULL)
<a name="l01419"></a>01419                 GOTO(out, rc = 1);
<a name="l01420"></a>01420         lock = search_queue(&amp;res-&gt;<a class="code" href="structldlm__resource.html#af6bf768c2b52a0303d2118ce6a5190b6" title="List of locks that could not be granted due to conflicts and that are waiting for...">lr_waiting</a>, &amp;data);
<a name="l01421"></a>01421         <span class="keywordflow">if</span> (lock != NULL)
<a name="l01422"></a>01422                 GOTO(out, rc = 1);
<a name="l01423"></a>01423 
<a name="l01424"></a>01424         EXIT;
<a name="l01425"></a>01425  out:
<a name="l01426"></a>01426         unlock_res(res);
<a name="l01427"></a>01427         LDLM_RESOURCE_DELREF(res);
<a name="l01428"></a>01428         ldlm_resource_putref(res);
<a name="l01429"></a>01429 
<a name="l01430"></a>01430         <span class="keywordflow">if</span> (lock) {
<a name="l01431"></a>01431                 <a class="code" href="group__LDLM.html#ga35362f3605ec8dec52464f153c932c85" title="Fills in handle for LDLM lock lock into supplied lockh Does not take any references...">ldlm_lock2handle</a>(lock, lockh);
<a name="l01432"></a>01432                 <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="group__LDLM.html#ga3af51d9e1097e0aeaacd1c3cc88fec62" title="XXX FIXME: This is being added to b_size as a low-risk fix to the fact that the LVB...">LDLM_FL_LVB_READY</a>) &amp;&amp;
<a name="l01433"></a>01433                     (!ldlm_is_lvb_ready(lock))) {
<a name="l01434"></a>01434                         __u64 wait_flags = LDLM_FL_LVB_READY |
<a name="l01435"></a>01435                                 <a class="code" href="group__LDLM.html#gaf74d13556ae1283f30228d20c497cfa8" title="Set for locks that were removed from class hash table and will be destroyed when...">LDLM_FL_DESTROYED</a> | <a class="code" href="group__LDLM.html#ga958240fb760018d3be665a8f0730b9c4" title="Set for locks that failed and where the server has been notified.">LDLM_FL_FAIL_NOTIFIED</a>;
<a name="l01436"></a>01436                         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi;
<a name="l01437"></a>01437                         <span class="keywordflow">if</span> (lock-&gt;<a class="code" href="structldlm__lock.html#aa8070acdaa6bb825842083d710f8a935" title="Lock completion handler pointer.">l_completion_ast</a>) {
<a name="l01438"></a>01438                                 <span class="keywordtype">int</span> err = lock-&gt;<a class="code" href="structldlm__lock.html#aa8070acdaa6bb825842083d710f8a935" title="Lock completion handler pointer.">l_completion_ast</a>(lock,
<a name="l01439"></a>01439                                                           <a class="code" href="group__LDLM.html#gae36b9cddb3e68705d21f384ad3a3e1e6" title="not a real flag, not saved in lock">LDLM_FL_WAIT_NOREPROC</a>,
<a name="l01440"></a>01440                                                                  NULL);
<a name="l01441"></a>01441                                 <span class="keywordflow">if</span> (err) {
<a name="l01442"></a>01442                                         <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>)
<a name="l01443"></a>01443                                                 <a class="code" href="group__LDLM.html#gaf3357d35be5378aa299677e298c5a625" title="Release a lock reference obtained by some other means (see LDLM_LOCK_PUT()).">LDLM_LOCK_RELEASE</a>(lock);
<a name="l01444"></a>01444                                         <span class="keywordflow">else</span>
<a name="l01445"></a>01445                                                 ldlm_lock_decref_internal(lock,
<a name="l01446"></a>01446                                                                           mode);
<a name="l01447"></a>01447                                         rc = 0;
<a name="l01448"></a>01448                                         <span class="keywordflow">goto</span> out2;
<a name="l01449"></a>01449                                 }
<a name="l01450"></a>01450                         }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452                         lwi = LWI_TIMEOUT_INTR(cfs_time_seconds(obd_timeout),
<a name="l01453"></a>01453                                                NULL, LWI_ON_SIGNAL_NOOP, NULL);
<a name="l01454"></a>01454 
<a name="l01455"></a>01455                         <span class="comment">/* XXX FIXME see comment on CAN_MATCH in lustre_dlm.h */</span>
<a name="l01456"></a>01456                         l_wait_event(lock-&gt;<a class="code" href="structldlm__lock.html#a0ca58a0480ef9503c3548499e27c2e43" title="If the lock is granted, a process sleeps on this waitq to learn when it&amp;#39;s no...">l_waitq</a>,
<a name="l01457"></a>01457                                      lock-&gt;<a class="code" href="structldlm__lock.html#a52cb4e433ee43b7326bfbb652c3d0598" title="Lock state flags.">l_flags</a> &amp; wait_flags,
<a name="l01458"></a>01458                                      &amp;lwi);
<a name="l01459"></a>01459                         <span class="keywordflow">if</span> (!ldlm_is_lvb_ready(lock)) {
<a name="l01460"></a>01460                                 <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>)
<a name="l01461"></a>01461                                         <a class="code" href="group__LDLM.html#gaf3357d35be5378aa299677e298c5a625" title="Release a lock reference obtained by some other means (see LDLM_LOCK_PUT()).">LDLM_LOCK_RELEASE</a>(lock);
<a name="l01462"></a>01462                                 <span class="keywordflow">else</span>
<a name="l01463"></a>01463                                         ldlm_lock_decref_internal(lock, mode);
<a name="l01464"></a>01464                                 rc = 0;
<a name="l01465"></a>01465                         }
<a name="l01466"></a>01466                 }
<a name="l01467"></a>01467         }
<a name="l01468"></a>01468  out2:
<a name="l01469"></a>01469         <span class="keywordflow">if</span> (rc) {
<a name="l01470"></a>01470                 LDLM_DEBUG(lock, <span class="stringliteral">&quot;matched (&quot;</span>LPU64<span class="stringliteral">&quot; &quot;</span>LPU64<span class="stringliteral">&quot;)&quot;</span>,
<a name="l01471"></a>01471                            (type == LDLM_PLAIN || type == LDLM_IBITS) ?
<a name="l01472"></a>01472                                 res_id-&gt;name[2] : policy-&gt;l_extent.start,
<a name="l01473"></a>01473                            (type == LDLM_PLAIN || type == LDLM_IBITS) ?
<a name="l01474"></a>01474                                 res_id-&gt;name[3] : policy-&gt;l_extent.end);
<a name="l01475"></a>01475 
<a name="l01476"></a>01476                 <span class="comment">/* check user&apos;s security context */</span>
<a name="l01477"></a>01477                 <span class="keywordflow">if</span> (lock-&gt;<a class="code" href="structldlm__lock.html#ae11dfeaaf68f7217bc5defa97b58b1b1" title="Lock connection export.">l_conn_export</a> &amp;&amp;
<a name="l01478"></a>01478                     <a class="code" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5" title="Given an import imp, check whether current user has a valid context or not.">sptlrpc_import_check_ctx</a>(
<a name="l01479"></a>01479                                 class_exp2cliimp(lock-&gt;<a class="code" href="structldlm__lock.html#ae11dfeaaf68f7217bc5defa97b58b1b1" title="Lock connection export.">l_conn_export</a>))) {
<a name="l01480"></a>01480                         <span class="keywordflow">if</span> (!(flags &amp; <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>))
<a name="l01481"></a>01481                                 ldlm_lock_decref_internal(lock, mode);
<a name="l01482"></a>01482                         rc = 0;
<a name="l01483"></a>01483                 }
<a name="l01484"></a>01484 
<a name="l01485"></a>01485                 <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>)
<a name="l01486"></a>01486                         <a class="code" href="group__LDLM.html#gaf3357d35be5378aa299677e298c5a625" title="Release a lock reference obtained by some other means (see LDLM_LOCK_PUT()).">LDLM_LOCK_RELEASE</a>(lock);
<a name="l01487"></a>01487 
<a name="l01488"></a>01488         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(flags &amp; <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>)) {<span class="comment">/*less verbose for test-only*/</span>
<a name="l01489"></a>01489                 <a class="code" href="group__LDLM.html#gae27210c0d51e6f38e3b5f2ff08793f97" title="Just a fancy CDEBUG call with log level preset to LDLM_DEBUG.">LDLM_DEBUG_NOLOCK</a>(<span class="stringliteral">&quot;not matched ns %p type %u mode %u res &quot;</span>
<a name="l01490"></a>01490                                   LPU64<span class="stringliteral">&quot;/&quot;</span>LPU64<span class="stringliteral">&quot; (&quot;</span>LPU64<span class="stringliteral">&quot; &quot;</span>LPU64<span class="stringliteral">&quot;)&quot;</span>, ns,
<a name="l01491"></a>01491                                   type, mode, res_id-&gt;name[0], res_id-&gt;name[1],
<a name="l01492"></a>01492                                   (type == LDLM_PLAIN || type == LDLM_IBITS) ?
<a name="l01493"></a>01493                                         res_id-&gt;name[2] :policy-&gt;l_extent.start,
<a name="l01494"></a>01494                                   (type == LDLM_PLAIN || type == LDLM_IBITS) ?
<a name="l01495"></a>01495                                         res_id-&gt;name[3] : policy-&gt;l_extent.end);
<a name="l01496"></a>01496         }
<a name="l01497"></a>01497         <span class="keywordflow">if</span> (data.lmd_old != NULL)
<a name="l01498"></a>01498                 <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(data.lmd_old);
<a name="l01499"></a>01499 
<a name="l01500"></a>01500         <span class="keywordflow">return</span> rc ? mode : 0;
<a name="l01501"></a>01501 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga1373811e4c4edbb039f1da1ca7947b03_cgraph.png" border="0" usemap="#group__LDLM_ga1373811e4c4edbb039f1da1ca7947b03_cgraph_map" alt=""></div>
<map name="group__LDLM_ga1373811e4c4edbb039f1da1ca7947b03_cgraph_map" id="group__LDLM_ga1373811e4c4edbb039f1da1ca7947b03_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga35362f3605ec8dec52464f153c932c85" title="Fills in handle for LDLM lock lock into supplied lockh Does not take any references..." alt="" coords="219,5,352,35"/><area shape="rect" id="node5" href="group__LDLM.html#ga083fb1ea92619c4b2e526633c3a486fb" title="Return a reference to resource with given name, creating it if necessary." alt="" coords="212,59,359,88"/><area shape="rect" id="node7" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5" title="Given an import imp, check whether current user has a valid context or not." alt="" coords="188,112,383,141"/><area shape="rect" id="node9" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="433,112,615,141"/><area shape="rect" id="node11" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="664,112,888,141"/><area shape="rect" id="node13" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="937,85,1095,115"/><area shape="rect" id="node15" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="937,139,1095,168"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga5e363707438fb69f9253f2ab8bf4c5e6"></a><!-- doxytag: member="lustre_dlm.h::ldlm_lock_put" ref="ga5e363707438fb69f9253f2ab8bf4c5e6" args="(struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_lock_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release lock reference. </p>
<p>Also frees the lock if it was last reference. </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l00190">190</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00901">ldlm_lock::l_exp_list</a>, <a class="el" href="lustre__dlm_8h_source.html#l00754">ldlm_lock::l_export</a>, <a class="el" href="lustre__dlm_8h_source.html#l00678">ldlm_lock::l_handle</a>, <a class="el" href="lustre__dlm_8h_source.html#l00818">ldlm_lock::l_lvb_len</a>, <a class="el" href="lustre__dlm_8h_source.html#l00843">ldlm_lock::l_pending_chain</a>, <a class="el" href="lustre__dlm_8h_source.html#l00684">ldlm_lock::l_refc</a>, <a class="el" href="lustre__dlm_8h_source.html#l00885">ldlm_lock::l_reference</a>, <a class="el" href="lustre__dlm_8h_source.html#l00705">ldlm_lock::l_res_link</a>, <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>, <a class="el" href="lustre__dlm_8h_source.html#l00334">LDLM_NSS_LOCKS</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00984">ldlm_resource::lr_reference</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00191"></a>00191 {
<a name="l00192"></a>00192         ENTRY;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         LASSERT(lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a> != LP_POISON);
<a name="l00195"></a>00195         LASSERT(atomic_read(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#acd61f904bdcdfee7845701368db6003d" title="Lock reference count.">l_refc</a>) &gt; 0);
<a name="l00196"></a>00196         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#acd61f904bdcdfee7845701368db6003d" title="Lock reference count.">l_refc</a>)) {
<a name="l00197"></a>00197                 <span class="keyword">struct </span><a class="code" href="structldlm__resource.html" title="LDLM resource description.">ldlm_resource</a> *res;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199                 LDLM_DEBUG(lock,
<a name="l00200"></a>00200                            <span class="stringliteral">&quot;final lock_put on destroyed lock, freeing it.&quot;</span>);
<a name="l00201"></a>00201 
<a name="l00202"></a>00202                 res = lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>;
<a name="l00203"></a>00203                 LASSERT(ldlm_is_destroyed(lock));
<a name="l00204"></a>00204                 LASSERT(list_empty(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#adb27b96d85f21b4b27ca59159d8316ec" title="export blocking dlm lock list, protected by l_export-&amp;gt;exp_bl_list_lock.">l_exp_list</a>));
<a name="l00205"></a>00205                 LASSERT(list_empty(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a64ad5a636aec3f0825f1eea9df1a5734" title="Linkage to resource&amp;#39;s lock queues according to current lock state.">l_res_link</a>));
<a name="l00206"></a>00206                 LASSERT(list_empty(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a464e73d6b8dbeeb1f94f4235cc71b02a" title="List item for locks waiting for cancellation from clients.">l_pending_chain</a>));
<a name="l00207"></a>00207 
<a name="l00208"></a>00208                 lprocfs_counter_decr(ldlm_res_to_ns(res)-&gt;ns_stats,
<a name="l00209"></a>00209                                      <a class="code" href="group__LDLM.html#ggae8a3b6a5d0d3244ed73924ab2421a0d0ac9ce485ce53eddc4df436c8df18871e4" title="LDLM namespace lock stats.">LDLM_NSS_LOCKS</a>);
<a name="l00210"></a>00210                 lu_ref_del(&amp;res-&gt;<a class="code" href="structldlm__resource.html#a5313c4407b408d5d1a9e183559eb85e2" title="List of references to this resource.">lr_reference</a>, <span class="stringliteral">&quot;lock&quot;</span>, lock);
<a name="l00211"></a>00211                 ldlm_resource_putref(res);
<a name="l00212"></a>00212                 lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a> = NULL;
<a name="l00213"></a>00213                 <span class="keywordflow">if</span> (lock-&gt;<a class="code" href="structldlm__lock.html#a60b23d06e26065065d0bac47ace905b0" title="Lock export.">l_export</a>) {
<a name="l00214"></a>00214                         class_export_lock_put(lock-&gt;<a class="code" href="structldlm__lock.html#a60b23d06e26065065d0bac47ace905b0" title="Lock export.">l_export</a>, lock);
<a name="l00215"></a>00215                         lock-&gt;<a class="code" href="structldlm__lock.html#a60b23d06e26065065d0bac47ace905b0" title="Lock export.">l_export</a> = NULL;
<a name="l00216"></a>00216                 }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218                 <span class="keywordflow">if</span> (lock-&gt;l_lvb_data != NULL)
<a name="l00219"></a>00219                         OBD_FREE_LARGE(lock-&gt;l_lvb_data, lock-&gt;<a class="code" href="structldlm__lock.html#af9af59e08968100a683ab5f5d595a495" title="Temporary storage for a LVB received during an enqueue operation.">l_lvb_len</a>);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221                 ldlm_interval_free(ldlm_interval_detach(lock));
<a name="l00222"></a>00222                 lu_ref_fini(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a2cc84a3989e5b197caffa7a0fe014f27" title="Reference tracking structure to debug leaked locks.">l_reference</a>);
<a name="l00223"></a>00223                 OBD_FREE_RCU(lock, <span class="keyword">sizeof</span>(*lock), &amp;lock-&gt;<a class="code" href="structldlm__lock.html#af6bfe0ab210b608d0fa59ee6e95841ec" title="Local lock handle.">l_handle</a>);
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226         EXIT;
<a name="l00227"></a>00227 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gacfe66a2d51a46f0bf611952a83119bbc"></a><!-- doxytag: member="lustre_dlm.h::ldlm_namespace_cleanup" ref="gacfe66a2d51a46f0bf611952a83119bbc" args="(struct ldlm_namespace *ns, __u64 flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_namespace_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel and destroy all locks in the namespace. </p>
<p>Typically used during evictions when server notified client that it was evicted and all of its state needs to be destroyed. Also used during shutdown. </p>

<p>Definition at line <a class="el" href="ldlm__resource_8c_source.html#l00892">892</a> of file <a class="el" href="ldlm__resource_8c_source.html">ldlm_resource.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00377">ldlm_namespace::ns_rs_hash</a>.</p>

<p>Referenced by <a class="el" href="ldlm__resource_8c_source.html#l00661">ldlm_namespace_new()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00893"></a>00893 {
<a name="l00894"></a>00894         <span class="keywordflow">if</span> (ns == NULL) {
<a name="l00895"></a>00895                 CDEBUG(D_INFO, <span class="stringliteral">&quot;NULL ns, skipping cleanup\n&quot;</span>);
<a name="l00896"></a>00896                 <span class="keywordflow">return</span> ELDLM_OK;
<a name="l00897"></a>00897         }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899         cfs_hash_for_each_nolock(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, ldlm_resource_clean,
<a name="l00900"></a>00900                                  &amp;flags, 0);
<a name="l00901"></a>00901         cfs_hash_for_each_nolock(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, ldlm_resource_complain,
<a name="l00902"></a>00902                                  NULL, 0);
<a name="l00903"></a>00903         <span class="keywordflow">return</span> ELDLM_OK;
<a name="l00904"></a>00904 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gacfe66a2d51a46f0bf611952a83119bbc_icgraph.png" border="0" usemap="#group__LDLM_gacfe66a2d51a46f0bf611952a83119bbc_icgraph_map" alt=""></div>
<map name="group__LDLM_gacfe66a2d51a46f0bf611952a83119bbc_icgraph_map" id="group__LDLM_gacfe66a2d51a46f0bf611952a83119bbc_icgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga4b345e88ea06fc28c099254650b75c38" title="Create and initialize new empty namespace." alt="" coords="249,5,417,35"/><area shape="rect" id="node5" href="group__net.html#gabcdaa31fdbdb87a69a06d19c43bbcda0" title="Target client logic." alt="" coords="468,5,604,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9f9b87f84a794b96c043799f3840765c"></a><!-- doxytag: member="lustre_dlm.h::ldlm_namespace_free" ref="ga9f9b87f84a794b96c043799f3840765c" args="(struct ldlm_namespace *ns, struct obd_import *imp, int force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_namespace_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>force</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleanup the resource, and free namespace. </p>
<p>bug 12864: Deadlock issue: proc1: destroy import class_disconnect_export(grab cl_sem) -&gt; -&gt; ldlm_namespace_free -&gt; -&gt; lprocfs_remove(grab _lprocfs_lock). proc2: read proc info lprocfs_fops_read(grab _lprocfs_lock) -&gt; -&gt; osc_rd_active, etc(grab cl_sem).</p>
<p>So that I have to split the ldlm_namespace_free into two parts - the first part ldlm_namespace_free_prior is used to cleanup the resource which is being used; the 2nd part ldlm_namespace_free_post is used to unregister the lprocfs entries, and then free memory. It will be called w/o cli-&gt;cl_sem held. </p>

<p>Definition at line <a class="el" href="ldlm__resource_8c_source.html#l01052">1052</a> of file <a class="el" href="ldlm__resource_8c_source.html">ldlm_resource.c</a>.</p>

<p>References <a class="el" href="ldlm__resource_8c_source.html#l01007">ldlm_namespace_free_post()</a>, and <a class="el" href="ldlm__resource_8c_source.html#l00966">ldlm_namespace_free_prior()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01055"></a>01055 {
<a name="l01056"></a>01056         <a class="code" href="group__LDLM.html#gaa7271dfc42956d8d75b2435a22c83832" title="Performs various cleanups for passed ns to make it drop refc and be ready for freeing...">ldlm_namespace_free_prior</a>(ns, imp, force);
<a name="l01057"></a>01057         <a class="code" href="group__LDLM.html#ga10faf90111f6da7206f8b140b8d98fed" title="Performs freeing memory structures related to ns.">ldlm_namespace_free_post</a>(ns);
<a name="l01058"></a>01058 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga9f9b87f84a794b96c043799f3840765c_cgraph.png" border="0" usemap="#group__LDLM_ga9f9b87f84a794b96c043799f3840765c_cgraph_map" alt=""></div>
<map name="group__LDLM_ga9f9b87f84a794b96c043799f3840765c_cgraph_map" id="group__LDLM_ga9f9b87f84a794b96c043799f3840765c_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga10faf90111f6da7206f8b140b8d98fed" title="Performs freeing memory structures related to ns." alt="" coords="225,5,431,35"/><area shape="rect" id="node7" href="group__LDLM.html#gaa7271dfc42956d8d75b2435a22c83832" title="Performs various cleanups for passed ns to make it drop refc and be ready for freeing..." alt="" coords="225,59,431,88"/><area shape="rect" id="node5" href="group__LDLM.html#gaf842bf901a93420ecbc2365d778b3a4b" title="Unregister ns from the list of namespaces." alt="" coords="480,5,691,35"/><area shape="rect" id="node9" href="group__ha.html#ga5301cdfd160cb1e18f119fbc8fac3252" title="This function will invalidate the import, if necessary, then block for all the RPC..." alt="" coords="493,59,677,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga10faf90111f6da7206f8b140b8d98fed"></a><!-- doxytag: member="lustre_dlm.h::ldlm_namespace_free_post" ref="ga10faf90111f6da7206f8b140b8d98fed" args="(struct ldlm_namespace *ns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_namespace_free_post </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs freeing memory structures related to <em>ns</em>. </p>
<p>This is only done when ldlm_namespce_free_prior() successfully removed all resources referencing <em>ns</em> and its refc == 0. </p>

<p>Definition at line <a class="el" href="ldlm__resource_8c_source.html#l01007">1007</a> of file <a class="el" href="ldlm__resource_8c_source.html">ldlm_resource.c</a>.</p>

<p>References <a class="el" href="ldlm__resource_8c_source.html#l01091">ldlm_namespace_unregister()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00374">ldlm_namespace::ns_client</a>, <a class="el" href="lustre__dlm_8h_source.html#l00401">ldlm_namespace::ns_list_chain</a>, <a class="el" href="lustre__dlm_8h_source.html#l00466">ldlm_namespace::ns_pool</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00377">ldlm_namespace::ns_rs_hash</a>.</p>

<p>Referenced by <a class="el" href="ldlm__resource_8c_source.html#l01052">ldlm_namespace_free()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01008"></a>01008 {
<a name="l01009"></a>01009         ENTRY;
<a name="l01010"></a>01010         <span class="keywordflow">if</span> (!ns) {
<a name="l01011"></a>01011                 EXIT;
<a name="l01012"></a>01012                 <span class="keywordflow">return</span>;
<a name="l01013"></a>01013         }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015         <span class="comment">/* Make sure that nobody can find this ns in its list. */</span>
<a name="l01016"></a>01016         <a class="code" href="group__LDLM.html#gaf842bf901a93420ecbc2365d778b3a4b" title="Unregister ns from the list of namespaces.">ldlm_namespace_unregister</a>(ns, ns-&gt;<a class="code" href="structldlm__namespace.html#aca43e10db23e506ba81318223e2fe0f1" title="Flag indicating if namespace is on client instead of server.">ns_client</a>);
<a name="l01017"></a>01017         <span class="comment">/* Fini pool _before_ parent proc dir is removed. This is important as</span>
<a name="l01018"></a>01018 <span class="comment">         * ldlm_pool_fini() removes own proc dir which is child to @dir.</span>
<a name="l01019"></a>01019 <span class="comment">         * Removing it after @dir may cause oops. */</span>
<a name="l01020"></a>01020         ldlm_pool_fini(&amp;ns-&gt;<a class="code" href="structldlm__namespace.html#aa7af6cd55b6e2bfa2b4cfc6134bb51e3" title="LDLM pool structure for this namespace.">ns_pool</a>);
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         ldlm_namespace_proc_unregister(ns);
<a name="l01023"></a>01023         cfs_hash_putref(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>);
<a name="l01024"></a>01024         <span class="comment">/* Namespace \a ns should be not on list at this time, otherwise</span>
<a name="l01025"></a>01025 <span class="comment">         * this will cause issues related to using freed \a ns in poold</span>
<a name="l01026"></a>01026 <span class="comment">         * thread. */</span>
<a name="l01027"></a>01027         LASSERT(list_empty(&amp;ns-&gt;<a class="code" href="structldlm__namespace.html#a8c57114258d97d4cf01886c70d7d783e" title="Position in global namespace list linking all namespaces on the node.">ns_list_chain</a>));
<a name="l01028"></a>01028         OBD_FREE_PTR(ns);
<a name="l01029"></a>01029         ldlm_put_ref();
<a name="l01030"></a>01030         EXIT;
<a name="l01031"></a>01031 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga10faf90111f6da7206f8b140b8d98fed_cgraph.png" border="0" usemap="#group__LDLM_ga10faf90111f6da7206f8b140b8d98fed_cgraph_map" alt=""></div>
<map name="group__LDLM_ga10faf90111f6da7206f8b140b8d98fed_cgraph_map" id="group__LDLM_ga10faf90111f6da7206f8b140b8d98fed_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#gaf842bf901a93420ecbc2365d778b3a4b" title="Unregister ns from the list of namespaces." alt="" coords="261,5,472,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga10faf90111f6da7206f8b140b8d98fed_icgraph.png" border="0" usemap="#group__LDLM_ga10faf90111f6da7206f8b140b8d98fed_icgraph_map" alt=""></div>
<map name="group__LDLM_ga10faf90111f6da7206f8b140b8d98fed_icgraph_map" id="group__LDLM_ga10faf90111f6da7206f8b140b8d98fed_icgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga9f9b87f84a794b96c043799f3840765c" title="Cleanup the resource, and free namespace." alt="" coords="263,5,431,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa7271dfc42956d8d75b2435a22c83832"></a><!-- doxytag: member="lustre_dlm.h::ldlm_namespace_free_prior" ref="gaa7271dfc42956d8d75b2435a22c83832" args="(struct ldlm_namespace *ns, struct obd_import *imp, int force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_namespace_free_prior </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>force</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs various cleanups for passed <em>ns</em> to make it drop refc and be ready for freeing. </p>
<p>Waits for refc == 0.</p>
<p>The following is done: (0) Unregister <em>ns</em> from its list to make inaccessible for potential users like pools thread and others; (1) Clear all locks in <em>ns</em>. </p>

<p>Definition at line <a class="el" href="ldlm__resource_8c_source.html#l00966">966</a> of file <a class="el" href="ldlm__resource_8c_source.html">ldlm_resource.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00380">ldlm_namespace::ns_lock</a>, <a class="el" href="lustre__dlm_8h_source.html#l00507">ldlm_namespace::ns_stopping</a>, and <a class="el" href="import_8c_source.html#l00286">ptlrpc_invalidate_import()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__resource_8c_source.html#l01052">ldlm_namespace_free()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00969"></a>00969 {
<a name="l00970"></a>00970         <span class="keywordtype">int</span> rc;
<a name="l00971"></a>00971         ENTRY;
<a name="l00972"></a>00972         <span class="keywordflow">if</span> (!ns) {
<a name="l00973"></a>00973                 EXIT;
<a name="l00974"></a>00974                 <span class="keywordflow">return</span>;
<a name="l00975"></a>00975         }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         spin_lock(&amp;ns-&gt;<a class="code" href="structldlm__namespace.html#a034ee07f43b36accc62bc6675f482775" title="serialize">ns_lock</a>);
<a name="l00978"></a>00978         ns-&gt;<a class="code" href="structldlm__namespace.html#ab8fdfb8d21e09d1eb92b6efd68e5420e" title="Flag to indicate namespace is being freed.">ns_stopping</a> = 1;
<a name="l00979"></a>00979         spin_unlock(&amp;ns-&gt;<a class="code" href="structldlm__namespace.html#a034ee07f43b36accc62bc6675f482775" title="serialize">ns_lock</a>);
<a name="l00980"></a>00980 
<a name="l00981"></a>00981         <span class="comment">/*</span>
<a name="l00982"></a>00982 <span class="comment">         * Can fail with -EINTR when force == 0 in which case try harder.</span>
<a name="l00983"></a>00983 <span class="comment">         */</span>
<a name="l00984"></a>00984         rc = __ldlm_namespace_free(ns, force);
<a name="l00985"></a>00985         <span class="keywordflow">if</span> (rc != ELDLM_OK) {
<a name="l00986"></a>00986                 <span class="keywordflow">if</span> (imp) {
<a name="l00987"></a>00987                         ptlrpc_disconnect_import(imp, 0);
<a name="l00988"></a>00988                         <a class="code" href="group__ha.html#ga5301cdfd160cb1e18f119fbc8fac3252" title="This function will invalidate the import, if necessary, then block for all the RPC...">ptlrpc_invalidate_import</a>(imp);
<a name="l00989"></a>00989                 }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991                 <span class="comment">/*</span>
<a name="l00992"></a>00992 <span class="comment">                 * With all requests dropped and the import inactive</span>
<a name="l00993"></a>00993 <span class="comment">                 * we are gaurenteed all reference will be dropped.</span>
<a name="l00994"></a>00994 <span class="comment">                 */</span>
<a name="l00995"></a>00995                 rc = __ldlm_namespace_free(ns, 1);
<a name="l00996"></a>00996                 LASSERT(rc == 0);
<a name="l00997"></a>00997         }
<a name="l00998"></a>00998         EXIT;
<a name="l00999"></a>00999 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gaa7271dfc42956d8d75b2435a22c83832_cgraph.png" border="0" usemap="#group__LDLM_gaa7271dfc42956d8d75b2435a22c83832_cgraph_map" alt=""></div>
<map name="group__LDLM_gaa7271dfc42956d8d75b2435a22c83832_cgraph_map" id="group__LDLM_gaa7271dfc42956d8d75b2435a22c83832_cgraph">
<area shape="rect" id="node3" href="group__ha.html#ga5301cdfd160cb1e18f119fbc8fac3252" title="This function will invalidate the import, if necessary, then block for all the RPC..." alt="" coords="259,5,443,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gaa7271dfc42956d8d75b2435a22c83832_icgraph.png" border="0" usemap="#group__LDLM_gaa7271dfc42956d8d75b2435a22c83832_icgraph_map" alt=""></div>
<map name="group__LDLM_gaa7271dfc42956d8d75b2435a22c83832_icgraph_map" id="group__LDLM_gaa7271dfc42956d8d75b2435a22c83832_icgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga9f9b87f84a794b96c043799f3840765c" title="Cleanup the resource, and free namespace." alt="" coords="260,5,428,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf842bf901a93420ecbc2365d778b3a4b"></a><!-- doxytag: member="lustre_dlm.h::ldlm_namespace_unregister" ref="gaf842bf901a93420ecbc2365d778b3a4b" args="(struct ldlm_namespace *ns, enum ldlm_side client)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_namespace_unregister </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__LDLM.html#gac4b4584603b76e6cc86c82a64f59defd">ldlm_side</a>&nbsp;</td>
          <td class="paramname"> <em>client</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregister <em>ns</em> from the list of namespaces. </p>

<p>Definition at line <a class="el" href="ldlm__resource_8c_source.html#l01091">1091</a> of file <a class="el" href="ldlm__resource_8c_source.html">ldlm_resource.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00401">ldlm_namespace::ns_list_chain</a>.</p>

<p>Referenced by <a class="el" href="ldlm__resource_8c_source.html#l01007">ldlm_namespace_free_post()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01092"></a>01092 {
<a name="l01093"></a>01093         mutex_lock(ldlm_namespace_lock(client));
<a name="l01094"></a>01094         LASSERT(!list_empty(&amp;ns-&gt;<a class="code" href="structldlm__namespace.html#a8c57114258d97d4cf01886c70d7d783e" title="Position in global namespace list linking all namespaces on the node.">ns_list_chain</a>));
<a name="l01095"></a>01095         <span class="comment">/* Some asserts and possibly other parts of the code are still</span>
<a name="l01096"></a>01096 <span class="comment">         * using list_empty(&amp;ns-&gt;ns_list_chain). This is why it is</span>
<a name="l01097"></a>01097 <span class="comment">         * important to use list_del_init() here. */</span>
<a name="l01098"></a>01098         list_del_init(&amp;ns-&gt;<a class="code" href="structldlm__namespace.html#a8c57114258d97d4cf01886c70d7d783e" title="Position in global namespace list linking all namespaces on the node.">ns_list_chain</a>);
<a name="l01099"></a>01099         ldlm_namespace_nr_dec(client);
<a name="l01100"></a>01100         mutex_unlock(ldlm_namespace_lock(client));
<a name="l01101"></a>01101 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_gaf842bf901a93420ecbc2365d778b3a4b_icgraph.png" border="0" usemap="#group__LDLM_gaf842bf901a93420ecbc2365d778b3a4b_icgraph_map" alt=""></div>
<map name="group__LDLM_gaf842bf901a93420ecbc2365d778b3a4b_icgraph_map" id="group__LDLM_gaf842bf901a93420ecbc2365d778b3a4b_icgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga10faf90111f6da7206f8b140b8d98fed" title="Performs freeing memory structures related to ns." alt="" coords="265,5,471,35"/><area shape="rect" id="node5" href="group__LDLM.html#ga9f9b87f84a794b96c043799f3840765c" title="Cleanup the resource, and free namespace." alt="" coords="521,5,689,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga6fea368fc4ea7002b0dcd068bbe8771a"></a><!-- doxytag: member="lustre_dlm.h::ldlm_reprocess_all" ref="ga6fea368fc4ea7002b0dcd068bbe8771a" args="(struct ldlm_resource *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ldlm_reprocess_all </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to grant all waiting locks on a resource. </p>
<p>Calls ldlm_reprocess_queue on converting and waiting queues.</p>
<p>Typically called after some resource locks are cancelled to see if anything could be granted as a result of the cancellation. </p>

<p>Definition at line <a class="el" href="ldlm__lock_8c_source.html#l02147">2147</a> of file <a class="el" href="ldlm__lock_8c_source.html">ldlm_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l01180">LDLM_ITER_CONTINUE</a>, <a class="el" href="lustre__dlm_8h_source.html#l00943">ldlm_resource::lr_converting</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00947">ldlm_resource::lr_waiting</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00188">ldlm_completion_ast_async()</a>, and <a class="el" href="ldlm__lock_8c_source.html#l02428">ldlm_lock_downgrade()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02148"></a>02148 {
<a name="l02149"></a>02149         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> rpc_list;
<a name="l02150"></a>02150 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02151"></a>02151 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc;
<a name="l02152"></a>02152         ENTRY;
<a name="l02153"></a>02153 
<a name="l02154"></a>02154         INIT_LIST_HEAD(&amp;rpc_list);
<a name="l02155"></a>02155         <span class="comment">/* Local lock trees don&apos;t get reprocessed. */</span>
<a name="l02156"></a>02156         <span class="keywordflow">if</span> (ns_is_client(ldlm_res_to_ns(res))) {
<a name="l02157"></a>02157                 EXIT;
<a name="l02158"></a>02158                 <span class="keywordflow">return</span>;
<a name="l02159"></a>02159         }
<a name="l02160"></a>02160 
<a name="l02161"></a>02161 restart:
<a name="l02162"></a>02162         lock_res(res);
<a name="l02163"></a>02163         rc = ldlm_reprocess_queue(res, &amp;res-&gt;<a class="code" href="structldlm__resource.html#a29e2572837238205fc2e5180618d1fd5" title="List of locks waiting to change their granted mode (converted).">lr_converting</a>, &amp;rpc_list);
<a name="l02164"></a>02164         <span class="keywordflow">if</span> (rc == <a class="code" href="group__LDLM.html#gae6f33fb4095ce2a0e694892623aee022" title="Return values for lock iterators.">LDLM_ITER_CONTINUE</a>)
<a name="l02165"></a>02165                 ldlm_reprocess_queue(res, &amp;res-&gt;<a class="code" href="structldlm__resource.html#af6bf768c2b52a0303d2118ce6a5190b6" title="List of locks that could not be granted due to conflicts and that are waiting for...">lr_waiting</a>, &amp;rpc_list);
<a name="l02166"></a>02166         unlock_res(res);
<a name="l02167"></a>02167 
<a name="l02168"></a>02168         rc = ldlm_run_ast_work(ldlm_res_to_ns(res), &amp;rpc_list,
<a name="l02169"></a>02169                                LDLM_WORK_CP_AST);
<a name="l02170"></a>02170         <span class="keywordflow">if</span> (rc == -ERESTART) {
<a name="l02171"></a>02171                 LASSERT(list_empty(&amp;rpc_list));
<a name="l02172"></a>02172                 <span class="keywordflow">goto</span> restart;
<a name="l02173"></a>02173         }
<a name="l02174"></a>02174 <span class="preprocessor">#else</span>
<a name="l02175"></a>02175 <span class="preprocessor"></span>        ENTRY;
<a name="l02176"></a>02176 
<a name="l02177"></a>02177         INIT_LIST_HEAD(&amp;rpc_list);
<a name="l02178"></a>02178         <span class="keywordflow">if</span> (!ns_is_client(ldlm_res_to_ns(res))) {
<a name="l02179"></a>02179                 CERROR(<span class="stringliteral">&quot;This is client-side-only module, cannot handle &quot;</span>
<a name="l02180"></a>02180                        <span class="stringliteral">&quot;LDLM_NAMESPACE_SERVER resource type lock.\n&quot;</span>);
<a name="l02181"></a>02181                 LBUG();
<a name="l02182"></a>02182         }
<a name="l02183"></a>02183 <span class="preprocessor">#endif</span>
<a name="l02184"></a>02184 <span class="preprocessor"></span>        EXIT;
<a name="l02185"></a>02185 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga6fea368fc4ea7002b0dcd068bbe8771a_icgraph.png" border="0" usemap="#group__LDLM_ga6fea368fc4ea7002b0dcd068bbe8771a_icgraph_map" alt=""></div>
<map name="group__LDLM_ga6fea368fc4ea7002b0dcd068bbe8771a_icgraph_map" id="group__LDLM_ga6fea368fc4ea7002b0dcd068bbe8771a_icgraph">
<area shape="rect" id="node3" href="group__ldlm__local__ast.html#ga44a28deab27f79e7a1ab7e77c7a59208" title="Implementation of &#45;&gt;l_completion_ast() for a client, that doesn&#39;t wait until..." alt="" coords="199,5,404,35"/><area shape="rect" id="node5" href="group__LDLM.html#ga1ae32c9c745cefc485fd39cf0054e2ef" title="Downgrade an exclusive lock." alt="" coords="220,59,383,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga083fb1ea92619c4b2e526633c3a486fb"></a><!-- doxytag: member="lustre_dlm.h::ldlm_resource_get" ref="ga083fb1ea92619c4b2e526633c3a486fb" args="(struct ldlm_namespace *ns, struct ldlm_resource *parent, const struct ldlm_res_id *, enum ldlm_type type, int create)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structldlm__resource.html">ldlm_resource</a>* ldlm_resource_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ldlm_type&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>create</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to resource with given name, creating it if necessary. </p>
<p>Args: namespace with ns_lock unlocked Locks: takes and releases NS hash-lock and res-&gt;lr_lock Returns: referenced, unlocked <a class="el" href="structldlm__resource.html" title="LDLM resource description.">ldlm_resource</a> or NULL </p>

<p>Definition at line <a class="el" href="ldlm__resource_8c_source.html#l01179">1179</a> of file <a class="el" href="ldlm__resource_8c_source.html">ldlm_resource.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00929">ldlm_resource::lr_hash</a>, <a class="el" href="lustre__dlm_8h_source.html#l00956">ldlm_resource::lr_itree</a>, <a class="el" href="lustre__dlm_8h_source.html#l00951">ldlm_resource::lr_name</a>, <a class="el" href="lustre__dlm_8h_source.html#l00984">ldlm_resource::lr_reference</a>, <a class="el" href="lustre__dlm_8h_source.html#l00970">ldlm_resource::lr_type</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00377">ldlm_namespace::ns_rs_hash</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01971">ldlm_cli_cancel_unused_resource()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00514">ldlm_lock_change_resource()</a>, and <a class="el" href="ldlm__lock_8c_source.html#l01370">ldlm_lock_match()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01182"></a>01182 {
<a name="l01183"></a>01183         <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>       *hnode;
<a name="l01184"></a>01184         <span class="keyword">struct </span><a class="code" href="structldlm__resource.html" title="LDLM resource description.">ldlm_resource</a>    *res = NULL;
<a name="l01185"></a>01185         <span class="keyword">struct </span><a class="code" href="structcfs__hash__bd.html" title="cfs_hash bucket descriptor, it&amp;#39;s normally in stack of caller">cfs_hash_bd</a>              bd;
<a name="l01186"></a>01186         __u64                   version;
<a name="l01187"></a>01187         <span class="keywordtype">int</span>                     ns_refcount = 0;
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         LASSERT(ns != NULL);
<a name="l01190"></a>01190         LASSERT(parent == NULL);
<a name="l01191"></a>01191         LASSERT(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a> != NULL);
<a name="l01192"></a>01192         LASSERT(name-&gt;name[0] != 0);
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         cfs_hash_bd_get_and_lock(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, (<span class="keywordtype">void</span> *)name, &amp;bd, 0);
<a name="l01195"></a>01195         hnode = cfs_hash_bd_lookup_locked(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, &amp;bd, (<span class="keywordtype">void</span> *)name);
<a name="l01196"></a>01196         <span class="keywordflow">if</span> (hnode != NULL) {
<a name="l01197"></a>01197                 cfs_hash_bd_unlock(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, &amp;bd, 0);
<a name="l01198"></a>01198                 GOTO(found, res);
<a name="l01199"></a>01199         }
<a name="l01200"></a>01200 
<a name="l01201"></a>01201         version = cfs_hash_bd_version_get(&amp;bd);
<a name="l01202"></a>01202         cfs_hash_bd_unlock(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, &amp;bd, 0);
<a name="l01203"></a>01203 
<a name="l01204"></a>01204         <span class="keywordflow">if</span> (create == 0)
<a name="l01205"></a>01205                 <span class="keywordflow">return</span> ERR_PTR(-ENOENT);
<a name="l01206"></a>01206 
<a name="l01207"></a>01207         LASSERTF(type &gt;= LDLM_MIN_TYPE &amp;&amp; type &lt; LDLM_MAX_TYPE,
<a name="l01208"></a>01208                  <span class="stringliteral">&quot;type: %d\n&quot;</span>, type);
<a name="l01209"></a>01209         res = ldlm_resource_new(type);
<a name="l01210"></a>01210         <span class="keywordflow">if</span> (res == NULL)
<a name="l01211"></a>01211                 <span class="keywordflow">return</span> ERR_PTR(-ENOMEM);
<a name="l01212"></a>01212 
<a name="l01213"></a>01213         res-&gt;lr_ns_bucket = cfs_hash_bd_extra_get(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, &amp;bd);
<a name="l01214"></a>01214         res-&gt;<a class="code" href="structldlm__resource.html#aa749561d4248b6066c028d44def461dc" title="Resource name.">lr_name</a> = *name;
<a name="l01215"></a>01215         res-&gt;<a class="code" href="structldlm__resource.html#a49b3d8776d2a7ff57e963c988d1de5cf" title="Type of locks this resource can hold.">lr_type</a> = type;
<a name="l01216"></a>01216 
<a name="l01217"></a>01217         cfs_hash_bd_lock(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, &amp;bd, 1);
<a name="l01218"></a>01218         hnode = (version == cfs_hash_bd_version_get(&amp;bd)) ? NULL :
<a name="l01219"></a>01219                 cfs_hash_bd_lookup_locked(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, &amp;bd, (<span class="keywordtype">void</span> *)name);
<a name="l01220"></a>01220 
<a name="l01221"></a>01221         <span class="keywordflow">if</span> (hnode != NULL) {
<a name="l01222"></a>01222                 <span class="comment">/* Someone won the race and already added the resource. */</span>
<a name="l01223"></a>01223                 cfs_hash_bd_unlock(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, &amp;bd, 1);
<a name="l01224"></a>01224                 <span class="comment">/* Clean lu_ref for failed resource. */</span>
<a name="l01225"></a>01225                 lu_ref_fini(&amp;res-&gt;<a class="code" href="structldlm__resource.html#a5313c4407b408d5d1a9e183559eb85e2" title="List of references to this resource.">lr_reference</a>);
<a name="l01226"></a>01226                 <span class="keywordflow">if</span> (res-&gt;<a class="code" href="structldlm__resource.html#a177993de61d12f737e4652ce8490b4d1" title="Interval trees (only for extent locks) for all modes of this resource.">lr_itree</a> != NULL)
<a name="l01227"></a>01227                         OBD_SLAB_FREE(res-&gt;<a class="code" href="structldlm__resource.html#a177993de61d12f737e4652ce8490b4d1" title="Interval trees (only for extent locks) for all modes of this resource.">lr_itree</a>, ldlm_interval_tree_slab,
<a name="l01228"></a>01228                                       <span class="keyword">sizeof</span>(*res-&gt;<a class="code" href="structldlm__resource.html#a177993de61d12f737e4652ce8490b4d1" title="Interval trees (only for extent locks) for all modes of this resource.">lr_itree</a>) * LCK_MODE_NUM);
<a name="l01229"></a>01229                 OBD_SLAB_FREE(res, ldlm_resource_slab, <span class="keyword">sizeof</span> *res);
<a name="l01230"></a>01230 found:
<a name="l01231"></a>01231                 res = hlist_entry(hnode, <span class="keyword">struct</span> <a class="code" href="structldlm__resource.html" title="LDLM resource description.">ldlm_resource</a>, lr_hash);
<a name="l01232"></a>01232                 <span class="keywordflow">return</span> res;
<a name="l01233"></a>01233         }
<a name="l01234"></a>01234         <span class="comment">/* We won! Let&apos;s add the resource. */</span>
<a name="l01235"></a>01235         cfs_hash_bd_add_locked(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, &amp;bd, &amp;res-&gt;<a class="code" href="structldlm__resource.html#a36fa46d26cd7396ca5fb4984ab93ebed" title="List item for list in namespace hash.">lr_hash</a>);
<a name="l01236"></a>01236         <span class="keywordflow">if</span> (cfs_hash_bd_count_get(&amp;bd) == 1)
<a name="l01237"></a>01237                 ns_refcount = ldlm_namespace_get_return(ns);
<a name="l01238"></a>01238 
<a name="l01239"></a>01239         cfs_hash_bd_unlock(ns-&gt;<a class="code" href="structldlm__namespace.html#ab98b19e574d298fcacdc25f5badb919d" title="Resource hash table for namespace.">ns_rs_hash</a>, &amp;bd, 1);
<a name="l01240"></a>01240 
<a name="l01241"></a>01241         OBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CREATE_RESOURCE, 2);
<a name="l01242"></a>01242 
<a name="l01243"></a>01243         <span class="comment">/* Let&apos;s see if we happened to be the very first resource in this</span>
<a name="l01244"></a>01244 <span class="comment">         * namespace. If so, and this is a client namespace, we need to move</span>
<a name="l01245"></a>01245 <span class="comment">         * the namespace into the active namespaces list to be patrolled by</span>
<a name="l01246"></a>01246 <span class="comment">         * the ldlm_poold. */</span>
<a name="l01247"></a>01247         <span class="keywordflow">if</span> (ns_is_client(ns) &amp;&amp; ns_refcount == 1) {
<a name="l01248"></a>01248                 mutex_lock(ldlm_namespace_lock(LDLM_NAMESPACE_CLIENT));
<a name="l01249"></a>01249                 ldlm_namespace_move_to_active_locked(ns, LDLM_NAMESPACE_CLIENT);
<a name="l01250"></a>01250                 mutex_unlock(ldlm_namespace_lock(LDLM_NAMESPACE_CLIENT));
<a name="l01251"></a>01251         }
<a name="l01252"></a>01252 
<a name="l01253"></a>01253         <span class="keywordflow">return</span> res;
<a name="l01254"></a>01254 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga083fb1ea92619c4b2e526633c3a486fb_icgraph.png" border="0" usemap="#group__LDLM_ga083fb1ea92619c4b2e526633c3a486fb_icgraph_map" alt=""></div>
<map name="group__LDLM_ga083fb1ea92619c4b2e526633c3a486fb_icgraph_map" id="group__LDLM_ga083fb1ea92619c4b2e526633c3a486fb_icgraph">
<area shape="rect" id="node3" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="200,5,443,35"/><area shape="rect" id="node7" href="group__LDLM.html#gafd6a07a826f7d2789696e472dd81adc2" title="Moves LDLM lock lock to another resource." alt="" coords="220,59,423,88"/><area shape="rect" id="node13" href="group__LDLM.html#ga1373811e4c4edbb039f1da1ca7947b03" title="Attempt to find a lock with specified properties." alt="" coords="255,112,388,141"/><area shape="rect" id="node5" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="491,5,667,35"/><area shape="rect" id="node9" href="group__ldlm__cli__api.html#gac421005283912bb5186b035013aa58c0" title="Finishing portion of client lock enqueue code." alt="" coords="497,59,660,88"/><area shape="rect" id="node11" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="715,59,851,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7ea7aa073d254d8500c07d2664cbecf9"></a><!-- doxytag: member="lustre_dlm.h::lock_res_and_lock" ref="ga7ea7aa073d254d8500c07d2664cbecf9" args="(struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structldlm__resource.html">ldlm_resource</a>* lock_res_and_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock a lock and its resource. </p>
<p>LDLM locking uses resource to serialize access to locks but there is a case when we change resource of lock upon enqueue reply. We rely on lock-&gt;l_resource = new_res being an atomic operation. </p>

<p>Definition at line <a class="el" href="l__lock_8c_source.html#l00051">51</a> of file <a class="el" href="l__lock_8c_source.html">l_lock.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00689">ldlm_lock::l_lock</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l00594">__ldlm_handle2lock()</a>, <a class="el" href="ldlm__request_8c_source.html#l00354">ldlm_blocking_ast()</a>, <a class="el" href="ldlm__lock_8c_source.html#l02205">ldlm_cancel_callback()</a>, <a class="el" href="ldlm__request_8c_source.html#l01345">ldlm_cli_cancel()</a>, <a class="el" href="ldlm__request_8c_source.html#l00541">ldlm_cli_enqueue_fini()</a>, <a class="el" href="ldlm__flock_8c_source.html#l00662">ldlm_flock_completion_ast()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00760">ldlm_lock_addref_try()</a>, <a class="el" href="ldlm__lock_8c_source.html#l01332">ldlm_lock_allow_match()</a>, <a class="el" href="ldlm__lock_8c_source.html#l02249">ldlm_lock_cancel()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00514">ldlm_lock_change_resource()</a>, <a class="el" href="ldlm__lock_8c_source.html#l02459">ldlm_lock_convert()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00918">ldlm_lock_decref_and_cancel()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00403">ldlm_lock_destroy()</a>, and <a class="el" href="ldlm__lock_8c_source.html#l02428">ldlm_lock_downgrade()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00052"></a>00052 {
<a name="l00053"></a>00053         <span class="comment">/* on server-side resource of lock doesn&apos;t change */</span>
<a name="l00054"></a>00054         <span class="keywordflow">if</span> (!ldlm_is_ns_srv(lock))
<a name="l00055"></a>00055                 spin_lock(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#ab7ff3f52f4765c133758c21e0d224a8b" title="Internal spinlock protects l_resource.">l_lock</a>);
<a name="l00056"></a>00056 
<a name="l00057"></a>00057         lock_res(lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>);
<a name="l00058"></a>00058 
<a name="l00059"></a>00059         ldlm_set_res_locked(lock);
<a name="l00060"></a>00060         <span class="keywordflow">return</span> lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>;
<a name="l00061"></a>00061 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LDLM_ga7ea7aa073d254d8500c07d2664cbecf9_icgraph.png" border="0" usemap="#group__LDLM_ga7ea7aa073d254d8500c07d2664cbecf9_icgraph_map" alt=""></div>
<map name="group__LDLM_ga7ea7aa073d254d8500c07d2664cbecf9_icgraph_map" id="group__LDLM_ga7ea7aa073d254d8500c07d2664cbecf9_icgraph">
<area shape="rect" id="node3" href="group__ldlm__handles.html#ga79665fefb3834e7ea72e9d8aacdad4d2" title="Obtain a lock reference by handle." alt="" coords="224,8,371,37"/><area shape="rect" id="node9" href="group__LDLM.html#gad236a9af5f0845e1046060a55419914b" title="Decrease reader/writer refcount for LDLM lock with handle lockh and mark it for subsequent..." alt="" coords="449,59,663,88"/><area shape="rect" id="node11" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="736,136,875,165"/><area shape="rect" id="node14" href="group__LDLM.html#ga0a466989372b56e3cde1edae472be066" title="Helper function to call blocking AST for LDLM lock lock in a &quot;cancelling&quot;..." alt="" coords="217,267,377,296"/><area shape="rect" id="node16" href="group__LDLM.html#gadec8a773eb3b13c995cf35a4d013393b" title="Attempts to cancel LDLM lock lock that has no reader/writer references." alt="" coords="489,241,623,271"/><area shape="rect" id="node26" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="237,163,357,192"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#gac421005283912bb5186b035013aa58c0" title="Finishing portion of client lock enqueue code." alt="" coords="475,400,637,429"/><area shape="rect" id="node35" href="group__LDLM.html#ga921f8d85541cbe1fa330b9a12080103f" title="Flock completion callback function." alt="" coords="199,371,396,400"/><area shape="rect" id="node37" href="group__LDLM.html#ga580d951cff91ebd5c1d2a7588d4c2ea3" title="Attempts to add reader/writer reference to a lock with handle lockh, and fails if..." alt="" coords="219,424,376,453"/><area shape="rect" id="node39" href="group__LDLM.html#ga9e8b401ed51dda94f553670e73872135" title="Mark lock as &quot;matchable&quot; by OST." alt="" coords="211,477,384,507"/><area shape="rect" id="node42" href="group__LDLM.html#gafd6a07a826f7d2789696e472dd81adc2" title="Moves LDLM lock lock to another resource." alt="" coords="196,531,399,560"/><area shape="rect" id="node45" href="group__LDLM.html#gaeeab5a5dbe0a5b966d52f388b69eed3f" title="Attempt to convert already granted lock to a different mode." alt="" coords="227,584,368,613"/><area shape="rect" id="node48" href="group__LDLM.html#ga833125f7d72f8e77cb16c031c56dd2a0" title="Destroys a LDLM lock lock." alt="" coords="227,637,368,667"/><area shape="rect" id="node50" href="group__LDLM.html#ga1ae32c9c745cefc485fd39cf0054e2ef" title="Downgrade an exclusive lock." alt="" coords="216,691,379,720"/><area shape="rect" id="node5" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh." alt="" coords="489,5,623,35"/><area shape="rect" id="node7" href="group__net.html#ga686ce1d3f4b5ce9b59e59136cb6b265c" title="Part of Rep&#45;Ack logic." alt="" coords="739,5,872,35"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="713,241,897,271"/><area shape="rect" id="node20" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="947,241,1149,271"/><area shape="rect" id="node22" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1197,241,1440,271"/><area shape="rect" id="node24" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="1488,241,1664,271"/><area shape="rect" id="node28" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="456,163,656,192"/><area shape="rect" id="node33" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="737,400,873,429"/></map>
</div>
</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:40 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
