<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lnet/selftest/framework.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lnet/selftest/framework.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2012, 2014, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lnet/selftest/framework.c</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Author: Isaac Huang &lt;isaac@clusterfs.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> * Author: Liang Zhen  &lt;liangzhen@clusterfs.com&gt;</span>
<a name="l00040"></a>00040 <span class="comment"> */</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_LNET</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;selftest.h&quot;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <a class="code" href="structlst__sid__t.html">lst_sid_t</a> LST_INVALID_SID = {<a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, -1};
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">static</span> <span class="keywordtype">int</span> session_timeout = 100;
<a name="l00049"></a>00049 module_param(session_timeout, <span class="keywordtype">int</span>, 0444);
<a name="l00050"></a>00050 MODULE_PARM_DESC(session_timeout, <span class="stringliteral">&quot;test session timeout in seconds (100 by default, 0 == never)&quot;</span>);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="keyword">static</span> <span class="keywordtype">int</span> rpc_timeout = 64;
<a name="l00053"></a>00053 module_param(rpc_timeout, <span class="keywordtype">int</span>, 0644);
<a name="l00054"></a>00054 MODULE_PARM_DESC(rpc_timeout, <span class="stringliteral">&quot;rpc timeout in seconds (64 by default, 0 == never)&quot;</span>);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="preprocessor">#define sfw_unpack_id(id)               \</span>
<a name="l00057"></a>00057 <span class="preprocessor">do {                                    \</span>
<a name="l00058"></a>00058 <span class="preprocessor">        __swab64s(&amp;(id).nid);           \</span>
<a name="l00059"></a>00059 <span class="preprocessor">        __swab32s(&amp;(id).pid);           \</span>
<a name="l00060"></a>00060 <span class="preprocessor">} while (0)</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span>
<a name="l00062"></a>00062 <span class="preprocessor">#define sfw_unpack_sid(sid)             \</span>
<a name="l00063"></a>00063 <span class="preprocessor">do {                                    \</span>
<a name="l00064"></a>00064 <span class="preprocessor">        __swab64s(&amp;(sid).ses_nid);      \</span>
<a name="l00065"></a>00065 <span class="preprocessor">        __swab64s(&amp;(sid).ses_stamp);    \</span>
<a name="l00066"></a>00066 <span class="preprocessor">} while (0)</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a>00068 <span class="preprocessor">#define sfw_unpack_fw_counters(fc)        \</span>
<a name="l00069"></a>00069 <span class="preprocessor">do {                                      \</span>
<a name="l00070"></a>00070 <span class="preprocessor">        __swab32s(&amp;(fc).running_ms);      \</span>
<a name="l00071"></a>00071 <span class="preprocessor">        __swab32s(&amp;(fc).active_batches);  \</span>
<a name="l00072"></a>00072 <span class="preprocessor">        __swab32s(&amp;(fc).zombie_sessions); \</span>
<a name="l00073"></a>00073 <span class="preprocessor">        __swab32s(&amp;(fc).brw_errors);      \</span>
<a name="l00074"></a>00074 <span class="preprocessor">        __swab32s(&amp;(fc).ping_errors);     \</span>
<a name="l00075"></a>00075 <span class="preprocessor">} while (0)</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span>
<a name="l00077"></a>00077 <span class="preprocessor">#define sfw_unpack_rpc_counters(rc)     \</span>
<a name="l00078"></a>00078 <span class="preprocessor">do {                                    \</span>
<a name="l00079"></a>00079 <span class="preprocessor">        __swab32s(&amp;(rc).errors);        \</span>
<a name="l00080"></a>00080 <span class="preprocessor">        __swab32s(&amp;(rc).rpcs_sent);     \</span>
<a name="l00081"></a>00081 <span class="preprocessor">        __swab32s(&amp;(rc).rpcs_rcvd);     \</span>
<a name="l00082"></a>00082 <span class="preprocessor">        __swab32s(&amp;(rc).rpcs_dropped);  \</span>
<a name="l00083"></a>00083 <span class="preprocessor">        __swab32s(&amp;(rc).rpcs_expired);  \</span>
<a name="l00084"></a>00084 <span class="preprocessor">        __swab64s(&amp;(rc).bulk_get);      \</span>
<a name="l00085"></a>00085 <span class="preprocessor">        __swab64s(&amp;(rc).bulk_put);      \</span>
<a name="l00086"></a>00086 <span class="preprocessor">} while (0)</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a>00088 <span class="preprocessor">#define sfw_unpack_lnet_counters(lc)    \</span>
<a name="l00089"></a>00089 <span class="preprocessor">do {                                    \</span>
<a name="l00090"></a>00090 <span class="preprocessor">        __swab32s(&amp;(lc).errors);        \</span>
<a name="l00091"></a>00091 <span class="preprocessor">        __swab32s(&amp;(lc).msgs_max);      \</span>
<a name="l00092"></a>00092 <span class="preprocessor">        __swab32s(&amp;(lc).msgs_alloc);    \</span>
<a name="l00093"></a>00093 <span class="preprocessor">        __swab32s(&amp;(lc).send_count);    \</span>
<a name="l00094"></a>00094 <span class="preprocessor">        __swab32s(&amp;(lc).recv_count);    \</span>
<a name="l00095"></a>00095 <span class="preprocessor">        __swab32s(&amp;(lc).drop_count);    \</span>
<a name="l00096"></a>00096 <span class="preprocessor">        __swab32s(&amp;(lc).route_count);   \</span>
<a name="l00097"></a>00097 <span class="preprocessor">        __swab64s(&amp;(lc).send_length);   \</span>
<a name="l00098"></a>00098 <span class="preprocessor">        __swab64s(&amp;(lc).recv_length);   \</span>
<a name="l00099"></a>00099 <span class="preprocessor">        __swab64s(&amp;(lc).drop_length);   \</span>
<a name="l00100"></a>00100 <span class="preprocessor">        __swab64s(&amp;(lc).route_length);  \</span>
<a name="l00101"></a>00101 <span class="preprocessor">} while (0)</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>
<a name="l00103"></a>00103 <span class="preprocessor">#define sfw_test_active(t)      (atomic_read(&amp;(t)-&gt;tsi_nactive) != 0)</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#define sfw_batch_active(b)     (atomic_read(&amp;(b)-&gt;bat_nactive) != 0)</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span>
<a name="l00106"></a>00106 <span class="keyword">static</span> <span class="keyword">struct </span>smoketest_framework {
<a name="l00107"></a>00107         <span class="comment">/* RPCs to be recycled */</span>
<a name="l00108"></a>00108         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        fw_zombie_rpcs;
<a name="l00109"></a>00109         <span class="comment">/* stopping sessions */</span>
<a name="l00110"></a>00110         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        fw_zombie_sessions;
<a name="l00111"></a>00111         <span class="comment">/* registered test cases */</span>
<a name="l00112"></a>00112         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        fw_tests;
<a name="l00113"></a>00113         <span class="comment">/* # zombie sessions */</span>
<a name="l00114"></a>00114         atomic_t                fw_nzombies;
<a name="l00115"></a>00115         <span class="comment">/* serialise */</span>
<a name="l00116"></a>00116         spinlock_t              fw_lock;
<a name="l00117"></a>00117         <span class="comment">/* _the_ session */</span>
<a name="l00118"></a>00118         <a class="code" href="structsfw__session__t.html">sfw_session_t</a>           *fw_session;
<a name="l00119"></a>00119         <span class="comment">/* shutdown in progress */</span>
<a name="l00120"></a>00120         <span class="keywordtype">int</span>                     fw_shuttingdown;
<a name="l00121"></a>00121         <span class="comment">/* running RPC */</span>
<a name="l00122"></a>00122         <a class="code" href="structsrpc__server__rpc.html">srpc_server_rpc_t</a>       *fw_active_srpc;
<a name="l00123"></a>00123 } sfw_data;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">/* forward ref&apos;s */</span>
<a name="l00126"></a>00126 <span class="keywordtype">int</span> sfw_stop_batch (<a class="code" href="structsfw__batch__t.html">sfw_batch_t</a> *tsb, <span class="keywordtype">int</span> force);
<a name="l00127"></a>00127 <span class="keywordtype">void</span> sfw_destroy_session (<a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="structsfw__test__case.html">sfw_test_case_t</a> *
<a name="l00130"></a>00130 sfw_find_test_case(<span class="keywordtype">int</span> <span class="keywordtype">id</span>)
<a name="l00131"></a>00131 {
<a name="l00132"></a>00132         <a class="code" href="structsfw__test__case.html">sfw_test_case_t</a> *tsc;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         LASSERT(<span class="keywordtype">id</span> &lt;= SRPC_SERVICE_MAX_ID);
<a name="l00135"></a>00135         LASSERT(<span class="keywordtype">id</span> &gt; SRPC_FRAMEWORK_SERVICE_MAX_ID);
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         list_for_each_entry(tsc, &amp;sfw_data.fw_tests, tsc_list) {
<a name="l00138"></a>00138                 <span class="keywordflow">if</span> (tsc-&gt;tsc_srv_service-&gt;sv_id == <span class="keywordtype">id</span>)
<a name="l00139"></a>00139                         <span class="keywordflow">return</span> tsc;
<a name="l00140"></a>00140         }
<a name="l00141"></a>00141 
<a name="l00142"></a>00142         <span class="keywordflow">return</span> NULL;
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00146"></a>00146 sfw_register_test (<a class="code" href="structsrpc__service.html">srpc_service_t</a> *service, <a class="code" href="structsfw__test__client__ops__t.html">sfw_test_client_ops_t</a> *cliops)
<a name="l00147"></a>00147 {
<a name="l00148"></a>00148         <a class="code" href="structsfw__test__case.html">sfw_test_case_t</a> *tsc;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150         <span class="keywordflow">if</span> (sfw_find_test_case(service-&gt;sv_id) != NULL) {
<a name="l00151"></a>00151                 CERROR (<span class="stringliteral">&quot;Failed to register test %s (%d)\n&quot;</span>,
<a name="l00152"></a>00152                         service-&gt;sv_name, service-&gt;sv_id);
<a name="l00153"></a>00153                 <span class="keywordflow">return</span> -EEXIST;
<a name="l00154"></a>00154         }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156         LIBCFS_ALLOC(tsc, <span class="keyword">sizeof</span>(<a class="code" href="structsfw__test__case.html">sfw_test_case_t</a>));
<a name="l00157"></a>00157         <span class="keywordflow">if</span> (tsc == NULL)
<a name="l00158"></a>00158                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         tsc-&gt;tsc_cli_ops     = cliops;
<a name="l00161"></a>00161         tsc-&gt;tsc_srv_service = service;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163         list_add_tail(&amp;tsc-&gt;tsc_list, &amp;sfw_data.fw_tests);
<a name="l00164"></a>00164         <span class="keywordflow">return</span> 0;
<a name="l00165"></a>00165 }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00168"></a>00168 sfw_add_session_timer (<span class="keywordtype">void</span>)
<a name="l00169"></a>00169 {
<a name="l00170"></a>00170         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l00171"></a>00171         <a class="code" href="structstt__timer__t.html">stt_timer_t</a>   *timer = &amp;sn-&gt;sn_timer;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         LASSERT (!sfw_data.fw_shuttingdown);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175         <span class="keywordflow">if</span> (sn == NULL || sn-&gt;sn_timeout == 0)
<a name="l00176"></a>00176                 <span class="keywordflow">return</span>;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178         LASSERT (!sn-&gt;sn_timer_active);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180         sn-&gt;sn_timer_active = 1;
<a name="l00181"></a>00181         timer-&gt;stt_expires = cfs_time_add(sn-&gt;sn_timeout,
<a name="l00182"></a>00182                                           cfs_time_current_sec());
<a name="l00183"></a>00183         stt_add_timer(timer);
<a name="l00184"></a>00184         <span class="keywordflow">return</span>;
<a name="l00185"></a>00185 }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00188"></a>00188 sfw_del_session_timer (<span class="keywordtype">void</span>)
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         <span class="keywordflow">if</span> (sn == NULL || !sn-&gt;sn_timer_active)
<a name="l00193"></a>00193                 <span class="keywordflow">return</span> 0;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         LASSERT (sn-&gt;sn_timeout != 0);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         <span class="keywordflow">if</span> (stt_del_timer(&amp;sn-&gt;sn_timer)) { <span class="comment">/* timer defused */</span>
<a name="l00198"></a>00198                 sn-&gt;sn_timer_active = 0;
<a name="l00199"></a>00199                 <span class="keywordflow">return</span> 0;
<a name="l00200"></a>00200         }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="keywordflow">return</span> EBUSY; <span class="comment">/* racing with sfw_session_expired() */</span>
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="comment">/* called with sfw_data.fw_lock held */</span>
<a name="l00206"></a>00206 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00207"></a>00207 sfw_deactivate_session (<span class="keywordtype">void</span>)
<a name="l00208"></a>00208 __must_hold(&amp;sfw_data.fw_lock)
<a name="l00209"></a>00209 {
<a name="l00210"></a>00210         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l00211"></a>00211         <span class="keywordtype">int</span>            nactive = 0;
<a name="l00212"></a>00212         <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>   *tsb;
<a name="l00213"></a>00213         <a class="code" href="structsfw__test__case.html">sfw_test_case_t</a> *tsc;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         <span class="keywordflow">if</span> (sn == NULL) <span class="keywordflow">return</span>;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         LASSERT(!sn-&gt;sn_timer_active);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         sfw_data.fw_session = NULL;
<a name="l00220"></a>00220         atomic_inc(&amp;sfw_data.fw_nzombies);
<a name="l00221"></a>00221         list_add(&amp;sn-&gt;sn_list, &amp;sfw_data.fw_zombie_sessions);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         list_for_each_entry(tsc, &amp;sfw_data.fw_tests, tsc_list) {
<a name="l00226"></a>00226                 srpc_abort_service(tsc-&gt;tsc_srv_service);
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         spin_lock(&amp;sfw_data.fw_lock);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231         list_for_each_entry(tsb, &amp;sn-&gt;sn_batches, bat_list) {
<a name="l00232"></a>00232                 <span class="keywordflow">if</span> (sfw_batch_active(tsb)) {
<a name="l00233"></a>00233                         nactive++;
<a name="l00234"></a>00234                         sfw_stop_batch(tsb, 1);
<a name="l00235"></a>00235                 }
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         <span class="keywordflow">if</span> (nactive != 0)
<a name="l00239"></a>00239                 <span class="keywordflow">return</span>; <span class="comment">/* wait for active batches to stop */</span>
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         list_del_init(&amp;sn-&gt;sn_list);
<a name="l00242"></a>00242         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l00243"></a>00243 
<a name="l00244"></a>00244         sfw_destroy_session(sn);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246         spin_lock(&amp;sfw_data.fw_lock);
<a name="l00247"></a>00247 }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00251"></a>00251 sfw_session_expired (<span class="keywordtype">void</span> *data)
<a name="l00252"></a>00252 {
<a name="l00253"></a>00253         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = data;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255         spin_lock(&amp;sfw_data.fw_lock);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257         LASSERT (sn-&gt;sn_timer_active);
<a name="l00258"></a>00258         LASSERT (sn == sfw_data.fw_session);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260         CWARN (<span class="stringliteral">&quot;Session expired! sid: %s-&quot;</span>LPU64<span class="stringliteral">&quot;, name: %s\n&quot;</span>,
<a name="l00261"></a>00261                libcfs_nid2str(sn-&gt;sn_id.ses_nid),
<a name="l00262"></a>00262                sn-&gt;sn_id.ses_stamp, &amp;sn-&gt;sn_name[0]);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264         sn-&gt;sn_timer_active = 0;
<a name="l00265"></a>00265         sfw_deactivate_session();
<a name="l00266"></a>00266 
<a name="l00267"></a>00267         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00271"></a>00271 sfw_init_session(<a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn, <a class="code" href="structlst__sid__t.html">lst_sid_t</a> sid,
<a name="l00272"></a>00272                  <span class="keywordtype">unsigned</span> features, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l00273"></a>00273 {
<a name="l00274"></a>00274         <a class="code" href="structstt__timer__t.html">stt_timer_t</a> *timer = &amp;sn-&gt;sn_timer;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276         memset(sn, 0, <span class="keyword">sizeof</span>(<a class="code" href="structsfw__session__t.html">sfw_session_t</a>));
<a name="l00277"></a>00277         INIT_LIST_HEAD(&amp;sn-&gt;sn_list);
<a name="l00278"></a>00278         INIT_LIST_HEAD(&amp;sn-&gt;sn_batches);
<a name="l00279"></a>00279         atomic_set(&amp;sn-&gt;sn_refcount, 1);        <span class="comment">/* +1 for caller */</span>
<a name="l00280"></a>00280         atomic_set(&amp;sn-&gt;sn_brw_errors, 0);
<a name="l00281"></a>00281         atomic_set(&amp;sn-&gt;sn_ping_errors, 0);
<a name="l00282"></a>00282         strlcpy(&amp;sn-&gt;sn_name[0], name, <span class="keyword">sizeof</span>(sn-&gt;sn_name));
<a name="l00283"></a>00283 
<a name="l00284"></a>00284         sn-&gt;sn_timer_active = 0;
<a name="l00285"></a>00285         sn-&gt;sn_id           = sid;
<a name="l00286"></a>00286         sn-&gt;sn_features     = features;
<a name="l00287"></a>00287         sn-&gt;sn_timeout      = session_timeout;
<a name="l00288"></a>00288         sn-&gt;sn_started      = cfs_time_current();
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         timer-&gt;stt_data = sn;
<a name="l00291"></a>00291         timer-&gt;stt_func = sfw_session_expired;
<a name="l00292"></a>00292         INIT_LIST_HEAD(&amp;timer-&gt;stt_list);
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="comment">/* completion handler for incoming framework RPCs */</span>
<a name="l00296"></a>00296 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00297"></a>00297 sfw_server_rpc_done(<span class="keyword">struct</span> <a class="code" href="structsrpc__server__rpc.html">srpc_server_rpc</a> *rpc)
<a name="l00298"></a>00298 {
<a name="l00299"></a>00299         <span class="keyword">struct </span><a class="code" href="structsrpc__service.html">srpc_service</a>     *sv     = rpc-&gt;srpc_scd-&gt;<a class="code" href="structsrpc__service__cd.html#a67031f3a1bac63fc1462c7986c858640" title="backref to service">scd_svc</a>;
<a name="l00300"></a>00300         <span class="keywordtype">int</span>                     status  = rpc-&gt;srpc_status;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302         CDEBUG (D_NET,
<a name="l00303"></a>00303                 <span class="stringliteral">&quot;Incoming framework RPC done: &quot;</span>
<a name="l00304"></a>00304                 <span class="stringliteral">&quot;service %s, peer %s, status %s:%d\n&quot;</span>,
<a name="l00305"></a>00305                 sv-&gt;sv_name, libcfs_id2str(rpc-&gt;srpc_peer),
<a name="l00306"></a>00306                 swi_state2str(rpc-&gt;srpc_wi.swi_state),
<a name="l00307"></a>00307                 status);
<a name="l00308"></a>00308 
<a name="l00309"></a>00309         <span class="keywordflow">if</span> (rpc-&gt;srpc_bulk != NULL)
<a name="l00310"></a>00310                 sfw_free_pages(rpc);
<a name="l00311"></a>00311         <span class="keywordflow">return</span>;
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00315"></a>00315 sfw_client_rpc_fini (<a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *rpc)
<a name="l00316"></a>00316 {
<a name="l00317"></a>00317         LASSERT(rpc-&gt;crpc_bulk.bk_niov == 0);
<a name="l00318"></a>00318         LASSERT(list_empty(&amp;rpc-&gt;crpc_list));
<a name="l00319"></a>00319         LASSERT(atomic_read(&amp;rpc-&gt;crpc_refcount) == 0);
<a name="l00320"></a>00320 
<a name="l00321"></a>00321         CDEBUG(D_NET, <span class="stringliteral">&quot;Outgoing framework RPC done: &quot;</span>
<a name="l00322"></a>00322                <span class="stringliteral">&quot;service %d, peer %s, status %s:%d:%d\n&quot;</span>,
<a name="l00323"></a>00323                rpc-&gt;crpc_service, libcfs_id2str(rpc-&gt;crpc_dest),
<a name="l00324"></a>00324                swi_state2str(rpc-&gt;crpc_wi.swi_state),
<a name="l00325"></a>00325                rpc-&gt;crpc_aborted, rpc-&gt;crpc_status);
<a name="l00326"></a>00326 
<a name="l00327"></a>00327         spin_lock(&amp;sfw_data.fw_lock);
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         <span class="comment">/* my callers must finish all RPCs before shutting me down */</span>
<a name="l00330"></a>00330         LASSERT(!sfw_data.fw_shuttingdown);
<a name="l00331"></a>00331         list_add(&amp;rpc-&gt;crpc_list, &amp;sfw_data.fw_zombie_rpcs);
<a name="l00332"></a>00332 
<a name="l00333"></a>00333         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l00334"></a>00334 }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 <span class="keyword">static</span> <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a> *
<a name="l00337"></a>00337 sfw_find_batch (<a class="code" href="structlst__bid__t.html">lst_bid_t</a> bid)
<a name="l00338"></a>00338 {
<a name="l00339"></a>00339         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l00340"></a>00340         <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>   *bat;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342         LASSERT(sn != NULL);
<a name="l00343"></a>00343 
<a name="l00344"></a>00344         list_for_each_entry(bat, &amp;sn-&gt;sn_batches, bat_list) {
<a name="l00345"></a>00345                 <span class="keywordflow">if</span> (bat-&gt;bat_id.bat_id == bid.bat_id)
<a name="l00346"></a>00346                         <span class="keywordflow">return</span> bat;
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349         <span class="keywordflow">return</span> NULL;
<a name="l00350"></a>00350 }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <span class="keyword">static</span> <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a> *
<a name="l00353"></a>00353 sfw_bid2batch (<a class="code" href="structlst__bid__t.html">lst_bid_t</a> bid)
<a name="l00354"></a>00354 {
<a name="l00355"></a>00355         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l00356"></a>00356         <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>   *bat;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         LASSERT (sn != NULL);
<a name="l00359"></a>00359 
<a name="l00360"></a>00360         bat = sfw_find_batch(bid);
<a name="l00361"></a>00361         <span class="keywordflow">if</span> (bat != NULL)
<a name="l00362"></a>00362                 <span class="keywordflow">return</span> bat;
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         LIBCFS_ALLOC(bat, <span class="keyword">sizeof</span>(<a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>));
<a name="l00365"></a>00365         <span class="keywordflow">if</span> (bat == NULL)
<a name="l00366"></a>00366                 <span class="keywordflow">return</span> NULL;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368         bat-&gt;bat_error   = 0;
<a name="l00369"></a>00369         bat-&gt;bat_session = sn;
<a name="l00370"></a>00370         bat-&gt;bat_id      = bid;
<a name="l00371"></a>00371         atomic_set(&amp;bat-&gt;bat_nactive, 0);
<a name="l00372"></a>00372         INIT_LIST_HEAD(&amp;bat-&gt;bat_tests);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374         list_add_tail(&amp;bat-&gt;bat_list, &amp;sn-&gt;sn_batches);
<a name="l00375"></a>00375         <span class="keywordflow">return</span> bat;
<a name="l00376"></a>00376 }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00379"></a>00379 sfw_get_stats (srpc_stat_reqst_t *request, srpc_stat_reply_t *reply)
<a name="l00380"></a>00380 {
<a name="l00381"></a>00381         <a class="code" href="structsfw__session__t.html">sfw_session_t</a>  *sn = sfw_data.fw_session;
<a name="l00382"></a>00382         sfw_counters_t *cnt = &amp;reply-&gt;str_fw;
<a name="l00383"></a>00383         <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>    *bat;
<a name="l00384"></a>00384         <span class="keyword">struct </span>timeval  tv;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         reply-&gt;str_sid = (sn == NULL) ? LST_INVALID_SID : sn-&gt;sn_id;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388         if (request-&gt;str_sid.ses_nid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l00389"></a>00389                 reply-&gt;str_status = EINVAL;
<a name="l00390"></a>00390                 <span class="keywordflow">return</span> 0;
<a name="l00391"></a>00391         }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393         <span class="keywordflow">if</span> (sn == NULL || !sfw_sid_equal(request-&gt;str_sid, sn-&gt;sn_id)) {
<a name="l00394"></a>00394                 reply-&gt;str_status = ESRCH;
<a name="l00395"></a>00395                 <span class="keywordflow">return</span> 0;
<a name="l00396"></a>00396         }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398         lnet_counters_get(&amp;reply-&gt;str_lnet);
<a name="l00399"></a>00399         srpc_get_counters(&amp;reply-&gt;str_rpc);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401         <span class="comment">/* send over the msecs since the session was started</span>
<a name="l00402"></a>00402 <span class="comment">         - with 32 bits to send, this is ~49 days */</span>
<a name="l00403"></a>00403         cfs_duration_usec(cfs_time_sub(cfs_time_current(),
<a name="l00404"></a>00404                                        sn-&gt;sn_started), &amp;tv);
<a name="l00405"></a>00405 
<a name="l00406"></a>00406         cnt-&gt;running_ms      = (__u32)(tv.tv_sec * 1000 + tv.tv_usec / 1000);
<a name="l00407"></a>00407         cnt-&gt;brw_errors      = atomic_read(&amp;sn-&gt;sn_brw_errors);
<a name="l00408"></a>00408         cnt-&gt;ping_errors     = atomic_read(&amp;sn-&gt;sn_ping_errors);
<a name="l00409"></a>00409         cnt-&gt;zombie_sessions = atomic_read(&amp;sfw_data.fw_nzombies);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411         cnt-&gt;active_batches = 0;
<a name="l00412"></a>00412         list_for_each_entry(bat, &amp;sn-&gt;sn_batches, bat_list) {
<a name="l00413"></a>00413                 <span class="keywordflow">if</span> (atomic_read(&amp;bat-&gt;bat_nactive) &gt; 0)
<a name="l00414"></a>00414                         cnt-&gt;active_batches++;
<a name="l00415"></a>00415         }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         reply-&gt;str_status = 0;
<a name="l00418"></a>00418         <span class="keywordflow">return</span> 0;
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 <span class="keywordtype">int</span>
<a name="l00422"></a>00422 sfw_make_session(srpc_mksn_reqst_t *request, srpc_mksn_reply_t *reply)
<a name="l00423"></a>00423 {
<a name="l00424"></a>00424         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l00425"></a>00425         <a class="code" href="structsrpc__msg.html">srpc_msg_t</a>    *msg = container_of(request, <a class="code" href="structsrpc__msg.html">srpc_msg_t</a>,
<a name="l00426"></a>00426                                           msg_body.mksn_reqst);
<a name="l00427"></a>00427         <span class="keywordtype">int</span>            cplen = 0;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429         <span class="keywordflow">if</span> (request-&gt;mksn_sid.ses_nid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l00430"></a>00430                 reply-&gt;mksn_sid = (sn == NULL) ? LST_INVALID_SID : sn-&gt;sn_id;
<a name="l00431"></a>00431                 reply-&gt;mksn_status = EINVAL;
<a name="l00432"></a>00432                 <span class="keywordflow">return</span> 0;
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435         <span class="keywordflow">if</span> (sn != NULL) {
<a name="l00436"></a>00436                 reply-&gt;mksn_status  = 0;
<a name="l00437"></a>00437                 reply-&gt;mksn_sid     = sn-&gt;sn_id;
<a name="l00438"></a>00438                 reply-&gt;mksn_timeout = sn-&gt;sn_timeout;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440                 <span class="keywordflow">if</span> (sfw_sid_equal(request-&gt;mksn_sid, sn-&gt;sn_id)) {
<a name="l00441"></a>00441                         atomic_inc(&amp;sn-&gt;sn_refcount);
<a name="l00442"></a>00442                         <span class="keywordflow">return</span> 0;
<a name="l00443"></a>00443                 }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445                 <span class="keywordflow">if</span> (!request-&gt;mksn_force) {
<a name="l00446"></a>00446                         reply-&gt;mksn_status = EBUSY;
<a name="l00447"></a>00447                         cplen = strlcpy(&amp;reply-&gt;mksn_name[0], &amp;sn-&gt;sn_name[0],
<a name="l00448"></a>00448                                         <span class="keyword">sizeof</span>(reply-&gt;mksn_name));
<a name="l00449"></a>00449                         <span class="keywordflow">if</span> (cplen &gt;= <span class="keyword">sizeof</span>(reply-&gt;mksn_name))
<a name="l00450"></a>00450                                 <span class="keywordflow">return</span> -E2BIG;
<a name="l00451"></a>00451                         <span class="keywordflow">return</span> 0;
<a name="l00452"></a>00452                 }
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         <span class="comment">/* reject the request if it requires unknown features</span>
<a name="l00456"></a>00456 <span class="comment">         * NB: old version will always accept all features because it&apos;s not</span>
<a name="l00457"></a>00457 <span class="comment">         * aware of srpc_msg_t::msg_ses_feats, it&apos;s a defect but it&apos;s also</span>
<a name="l00458"></a>00458 <span class="comment">         * harmless because it will return zero feature to console, and it&apos;s</span>
<a name="l00459"></a>00459 <span class="comment">         * console&apos;s responsibility to make sure all nodes in a session have</span>
<a name="l00460"></a>00460 <span class="comment">         * same feature mask. */</span>
<a name="l00461"></a>00461         <span class="keywordflow">if</span> ((msg-&gt;<a class="code" href="structsrpc__msg.html#a26415755866d1fb46d201e4d937db7fd" title="test session features">msg_ses_feats</a> &amp; ~LST_FEATS_MASK) != 0) {
<a name="l00462"></a>00462                 reply-&gt;mksn_status = EPROTO;
<a name="l00463"></a>00463                 <span class="keywordflow">return</span> 0;
<a name="l00464"></a>00464         }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466         <span class="comment">/* brand new or create by force */</span>
<a name="l00467"></a>00467         LIBCFS_ALLOC(sn, <span class="keyword">sizeof</span>(<a class="code" href="structsfw__session__t.html">sfw_session_t</a>));
<a name="l00468"></a>00468         <span class="keywordflow">if</span> (sn == NULL) {
<a name="l00469"></a>00469                 CERROR(<span class="stringliteral">&quot;dropping RPC mksn under memory pressure\n&quot;</span>);
<a name="l00470"></a>00470                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00471"></a>00471         }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         sfw_init_session(sn, request-&gt;mksn_sid,
<a name="l00474"></a>00474                          msg-&gt;<a class="code" href="structsrpc__msg.html#a26415755866d1fb46d201e4d937db7fd" title="test session features">msg_ses_feats</a>, &amp;request-&gt;mksn_name[0]);
<a name="l00475"></a>00475 
<a name="l00476"></a>00476         spin_lock(&amp;sfw_data.fw_lock);
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         sfw_deactivate_session();
<a name="l00479"></a>00479         LASSERT(sfw_data.fw_session == NULL);
<a name="l00480"></a>00480         sfw_data.fw_session = sn;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         reply-&gt;mksn_status  = 0;
<a name="l00485"></a>00485         reply-&gt;mksn_sid     = sn-&gt;sn_id;
<a name="l00486"></a>00486         reply-&gt;mksn_timeout = sn-&gt;sn_timeout;
<a name="l00487"></a>00487         <span class="keywordflow">return</span> 0;
<a name="l00488"></a>00488 }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00491"></a>00491 sfw_remove_session (srpc_rmsn_reqst_t *request, srpc_rmsn_reply_t *reply)
<a name="l00492"></a>00492 {
<a name="l00493"></a>00493         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         reply-&gt;rmsn_sid = (sn == NULL) ? LST_INVALID_SID : sn-&gt;sn_id;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         if (request-&gt;rmsn_sid.ses_nid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l00498"></a>00498                 reply-&gt;rmsn_status = EINVAL;
<a name="l00499"></a>00499                 <span class="keywordflow">return</span> 0;
<a name="l00500"></a>00500         }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         <span class="keywordflow">if</span> (sn == NULL || !sfw_sid_equal(request-&gt;rmsn_sid, sn-&gt;sn_id)) {
<a name="l00503"></a>00503                 reply-&gt;rmsn_status = (sn == NULL) ? ESRCH : EBUSY;
<a name="l00504"></a>00504                 <span class="keywordflow">return</span> 0;
<a name="l00505"></a>00505         }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507         <span class="keywordflow">if</span> (!atomic_dec_and_test(&amp;sn-&gt;sn_refcount)) {
<a name="l00508"></a>00508                 reply-&gt;rmsn_status = 0;
<a name="l00509"></a>00509                 <span class="keywordflow">return</span> 0;
<a name="l00510"></a>00510         }
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         spin_lock(&amp;sfw_data.fw_lock);
<a name="l00513"></a>00513         sfw_deactivate_session();
<a name="l00514"></a>00514         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516         reply-&gt;rmsn_status = 0;
<a name="l00517"></a>00517         reply-&gt;rmsn_sid    = LST_INVALID_SID;
<a name="l00518"></a>00518         LASSERT(sfw_data.fw_session == NULL);
<a name="l00519"></a>00519         <span class="keywordflow">return</span> 0;
<a name="l00520"></a>00520 }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00523"></a>00523 sfw_debug_session (srpc_debug_reqst_t *request, srpc_debug_reply_t *reply)
<a name="l00524"></a>00524 {
<a name="l00525"></a>00525         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         <span class="keywordflow">if</span> (sn == NULL) {
<a name="l00528"></a>00528                 reply-&gt;dbg_status = ESRCH;
<a name="l00529"></a>00529                 reply-&gt;dbg_sid    = LST_INVALID_SID;
<a name="l00530"></a>00530                 <span class="keywordflow">return</span> 0;
<a name="l00531"></a>00531         }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533         reply-&gt;dbg_status  = 0;
<a name="l00534"></a>00534         reply-&gt;dbg_sid     = sn-&gt;sn_id;
<a name="l00535"></a>00535         reply-&gt;dbg_timeout = sn-&gt;sn_timeout;
<a name="l00536"></a>00536         <span class="keywordflow">if</span> (strlcpy(reply-&gt;dbg_name, &amp;sn-&gt;sn_name[0], <span class="keyword">sizeof</span>(reply-&gt;dbg_name))
<a name="l00537"></a>00537             &gt;= <span class="keyword">sizeof</span>(reply-&gt;dbg_name))
<a name="l00538"></a>00538                 <span class="keywordflow">return</span> -E2BIG;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540         <span class="keywordflow">return</span> 0;
<a name="l00541"></a>00541 }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00544"></a>00544 sfw_test_rpc_fini (<a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *rpc)
<a name="l00545"></a>00545 {
<a name="l00546"></a>00546         <a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a>     *tsu = rpc-&gt;crpc_priv;
<a name="l00547"></a>00547         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi = tsu-&gt;tsu_instance;
<a name="l00548"></a>00548 
<a name="l00549"></a>00549         <span class="comment">/* Called with hold of tsi-&gt;tsi_lock */</span>
<a name="l00550"></a>00550         LASSERT(list_empty(&amp;rpc-&gt;crpc_list));
<a name="l00551"></a>00551         list_add(&amp;rpc-&gt;crpc_list, &amp;tsi-&gt;tsi_free_rpcs);
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00555"></a>00555 sfw_test_buffers(<a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi)
<a name="l00556"></a>00556 {
<a name="l00557"></a>00557         <span class="keyword">struct </span><a class="code" href="structsfw__test__case.html">sfw_test_case</a>    *tsc;
<a name="l00558"></a>00558         <span class="keyword">struct </span><a class="code" href="structsrpc__service.html">srpc_service</a>     *svc;
<a name="l00559"></a>00559         <span class="keywordtype">int</span>                     nbuf;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         LASSERT(tsi != NULL);
<a name="l00562"></a>00562         tsc = sfw_find_test_case(tsi-&gt;tsi_service);
<a name="l00563"></a>00563         LASSERT(tsc != NULL);
<a name="l00564"></a>00564         svc = tsc-&gt;tsc_srv_service;
<a name="l00565"></a>00565         LASSERT(svc != NULL);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567         nbuf = min(svc-&gt;sv_wi_total, tsi-&gt;tsi_loop) / svc-&gt;sv_ncpts;
<a name="l00568"></a>00568         <span class="keywordflow">return</span> max(SFW_TEST_WI_MIN, nbuf + SFW_TEST_WI_EXTRA);
<a name="l00569"></a>00569 }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00572"></a>00572 sfw_load_test(<span class="keyword">struct</span> <a class="code" href="structsfw__test__instance.html">sfw_test_instance</a> *tsi)
<a name="l00573"></a>00573 {
<a name="l00574"></a>00574         <span class="keyword">struct </span><a class="code" href="structsfw__test__case.html">sfw_test_case</a>    *tsc;
<a name="l00575"></a>00575         <span class="keyword">struct </span><a class="code" href="structsrpc__service.html">srpc_service</a>     *svc;
<a name="l00576"></a>00576         <span class="keywordtype">int</span>                     nbuf;
<a name="l00577"></a>00577         <span class="keywordtype">int</span>                     rc;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579         LASSERT(tsi != NULL);
<a name="l00580"></a>00580         tsc = sfw_find_test_case(tsi-&gt;tsi_service);
<a name="l00581"></a>00581         nbuf = sfw_test_buffers(tsi);
<a name="l00582"></a>00582         LASSERT(tsc != NULL);
<a name="l00583"></a>00583         svc = tsc-&gt;tsc_srv_service;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585         <span class="keywordflow">if</span> (tsi-&gt;tsi_is_client) {
<a name="l00586"></a>00586                 tsi-&gt;tsi_ops = tsc-&gt;tsc_cli_ops;
<a name="l00587"></a>00587                 <span class="keywordflow">return</span> 0;
<a name="l00588"></a>00588         }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590         rc = srpc_service_add_buffers(svc, nbuf);
<a name="l00591"></a>00591         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00592"></a>00592                 CWARN(<span class="stringliteral">&quot;Failed to reserve enough buffers: &quot;</span>
<a name="l00593"></a>00593                       <span class="stringliteral">&quot;service %s, %d needed: %d\n&quot;</span>, svc-&gt;sv_name, nbuf, rc);
<a name="l00594"></a>00594                 <span class="comment">/* NB: this error handler is not strictly correct, because</span>
<a name="l00595"></a>00595 <span class="comment">                 * it may release more buffers than already allocated,</span>
<a name="l00596"></a>00596 <span class="comment">                 * but it doesn&apos;t matter because request portal should</span>
<a name="l00597"></a>00597 <span class="comment">                 * be lazy portal and will grow buffers if necessary. */</span>
<a name="l00598"></a>00598                 srpc_service_remove_buffers(svc, nbuf);
<a name="l00599"></a>00599                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602         CDEBUG(D_NET, <span class="stringliteral">&quot;Reserved %d buffers for test %s\n&quot;</span>,
<a name="l00603"></a>00603                nbuf * (srpc_serv_is_framework(svc) ?
<a name="l00604"></a>00604                        1 : cfs_cpt_number(<a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>)), svc-&gt;sv_name);
<a name="l00605"></a>00605         <span class="keywordflow">return</span> 0;
<a name="l00606"></a>00606 }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00609"></a>00609 sfw_unload_test(<span class="keyword">struct</span> <a class="code" href="structsfw__test__instance.html">sfw_test_instance</a> *tsi)
<a name="l00610"></a>00610 {
<a name="l00611"></a>00611         <span class="keyword">struct </span><a class="code" href="structsfw__test__case.html">sfw_test_case</a> *tsc;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613         LASSERT(tsi != NULL);
<a name="l00614"></a>00614         tsc = sfw_find_test_case(tsi-&gt;tsi_service);
<a name="l00615"></a>00615         LASSERT(tsc != NULL);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617         <span class="keywordflow">if</span> (tsi-&gt;tsi_is_client)
<a name="l00618"></a>00618                 <span class="keywordflow">return</span>;
<a name="l00619"></a>00619 
<a name="l00620"></a>00620         <span class="comment">/* shrink buffers, because request portal is lazy portal</span>
<a name="l00621"></a>00621 <span class="comment">         * which can grow buffers at runtime so we may leave</span>
<a name="l00622"></a>00622 <span class="comment">         * some buffers behind, but never mind... */</span>
<a name="l00623"></a>00623         srpc_service_remove_buffers(tsc-&gt;tsc_srv_service,
<a name="l00624"></a>00624                                     sfw_test_buffers(tsi));
<a name="l00625"></a>00625         <span class="keywordflow">return</span>;
<a name="l00626"></a>00626 }
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00629"></a>00629 sfw_destroy_test_instance (<a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi)
<a name="l00630"></a>00630 {
<a name="l00631"></a>00631         <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *rpc;
<a name="l00632"></a>00632         <a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a>   *tsu;
<a name="l00633"></a>00633 
<a name="l00634"></a>00634         <span class="keywordflow">if</span> (!tsi-&gt;tsi_is_client) <span class="keywordflow">goto</span> clean;
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         tsi-&gt;tsi_ops-&gt;tso_fini(tsi);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         LASSERT(!tsi-&gt;tsi_stopping);
<a name="l00639"></a>00639         LASSERT(list_empty(&amp;tsi-&gt;tsi_active_rpcs));
<a name="l00640"></a>00640         LASSERT(!sfw_test_active(tsi));
<a name="l00641"></a>00641 
<a name="l00642"></a>00642         <span class="keywordflow">while</span> (!list_empty(&amp;tsi-&gt;tsi_units)) {
<a name="l00643"></a>00643                 tsu = list_entry(tsi-&gt;tsi_units.next,
<a name="l00644"></a>00644                                  <a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a>, tsu_list);
<a name="l00645"></a>00645                 list_del(&amp;tsu-&gt;tsu_list);
<a name="l00646"></a>00646                 LIBCFS_FREE(tsu, <span class="keyword">sizeof</span>(*tsu));
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         <span class="keywordflow">while</span> (!list_empty(&amp;tsi-&gt;tsi_free_rpcs)) {
<a name="l00650"></a>00650                 rpc = list_entry(tsi-&gt;tsi_free_rpcs.next,
<a name="l00651"></a>00651                                  <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a>, crpc_list);
<a name="l00652"></a>00652                 list_del(&amp;rpc-&gt;crpc_list);
<a name="l00653"></a>00653                 LIBCFS_FREE(rpc, srpc_client_rpc_size(rpc));
<a name="l00654"></a>00654         }
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 clean:
<a name="l00657"></a>00657         sfw_unload_test(tsi);
<a name="l00658"></a>00658         LIBCFS_FREE(tsi, <span class="keyword">sizeof</span>(*tsi));
<a name="l00659"></a>00659         <span class="keywordflow">return</span>;
<a name="l00660"></a>00660 }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00663"></a>00663 sfw_destroy_batch (<a class="code" href="structsfw__batch__t.html">sfw_batch_t</a> *tsb)
<a name="l00664"></a>00664 {
<a name="l00665"></a>00665         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi;
<a name="l00666"></a>00666 
<a name="l00667"></a>00667         LASSERT(!sfw_batch_active(tsb));
<a name="l00668"></a>00668         LASSERT(list_empty(&amp;tsb-&gt;bat_list));
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         <span class="keywordflow">while</span> (!list_empty(&amp;tsb-&gt;bat_tests)) {
<a name="l00671"></a>00671                 tsi = list_entry(tsb-&gt;bat_tests.next,
<a name="l00672"></a>00672                                  <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a>, tsi_list);
<a name="l00673"></a>00673                 list_del_init(&amp;tsi-&gt;tsi_list);
<a name="l00674"></a>00674                 sfw_destroy_test_instance(tsi);
<a name="l00675"></a>00675         }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677         LIBCFS_FREE(tsb, <span class="keyword">sizeof</span>(<a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>));
<a name="l00678"></a>00678         <span class="keywordflow">return</span>;
<a name="l00679"></a>00679 }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 <span class="keywordtype">void</span>
<a name="l00682"></a>00682 sfw_destroy_session (<a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn)
<a name="l00683"></a>00683 {
<a name="l00684"></a>00684         <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a> *batch;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686         LASSERT(list_empty(&amp;sn-&gt;sn_list));
<a name="l00687"></a>00687         LASSERT(sn != sfw_data.fw_session);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         <span class="keywordflow">while</span> (!list_empty(&amp;sn-&gt;sn_batches)) {
<a name="l00690"></a>00690                 batch = list_entry(sn-&gt;sn_batches.next,
<a name="l00691"></a>00691                                    <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>, bat_list);
<a name="l00692"></a>00692                 list_del_init(&amp;batch-&gt;bat_list);
<a name="l00693"></a>00693                 sfw_destroy_batch(batch);
<a name="l00694"></a>00694         }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696         LIBCFS_FREE(sn, <span class="keyword">sizeof</span>(*sn));
<a name="l00697"></a>00697         atomic_dec(&amp;sfw_data.fw_nzombies);
<a name="l00698"></a>00698         <span class="keywordflow">return</span>;
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00702"></a>00702 sfw_unpack_addtest_req(<a class="code" href="structsrpc__msg.html">srpc_msg_t</a> *msg)
<a name="l00703"></a>00703 {
<a name="l00704"></a>00704         srpc_test_reqst_t *req = &amp;msg-&gt;msg_body.tes_reqst;
<a name="l00705"></a>00705 
<a name="l00706"></a>00706         LASSERT (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_TEST_REQST);
<a name="l00707"></a>00707         LASSERT (req-&gt;tsr_is_client);
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a6e19bc3729ed00441eb74910836610ff" title="magic number">msg_magic</a> == SRPC_MSG_MAGIC)
<a name="l00710"></a>00710                 <span class="keywordflow">return</span>; <span class="comment">/* no flipping needed */</span>
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         LASSERT (msg-&gt;<a class="code" href="structsrpc__msg.html#a6e19bc3729ed00441eb74910836610ff" title="magic number">msg_magic</a> == __swab32(SRPC_MSG_MAGIC));
<a name="l00713"></a>00713 
<a name="l00714"></a>00714         <span class="keywordflow">if</span> (req-&gt;tsr_service == SRPC_SERVICE_BRW) {
<a name="l00715"></a>00715                 <span class="keywordflow">if</span> ((msg-&gt;<a class="code" href="structsrpc__msg.html#a26415755866d1fb46d201e4d937db7fd" title="test session features">msg_ses_feats</a> &amp; LST_FEAT_BULK_LEN) == 0) {
<a name="l00716"></a>00716                         test_bulk_req_t *bulk = &amp;req-&gt;tsr_u.bulk_v0;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718                         __swab32s(&amp;bulk-&gt;blk_opc);
<a name="l00719"></a>00719                         __swab32s(&amp;bulk-&gt;blk_npg);
<a name="l00720"></a>00720                         __swab32s(&amp;bulk-&gt;blk_flags);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722                 } <span class="keywordflow">else</span> {
<a name="l00723"></a>00723                         test_bulk_req_v1_t *bulk = &amp;req-&gt;tsr_u.bulk_v1;
<a name="l00724"></a>00724 
<a name="l00725"></a>00725                         __swab16s(&amp;bulk-&gt;blk_opc);
<a name="l00726"></a>00726                         __swab16s(&amp;bulk-&gt;blk_flags);
<a name="l00727"></a>00727                         __swab32s(&amp;bulk-&gt;blk_offset);
<a name="l00728"></a>00728                         __swab32s(&amp;bulk-&gt;blk_len);
<a name="l00729"></a>00729                 }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731                 <span class="keywordflow">return</span>;
<a name="l00732"></a>00732         }
<a name="l00733"></a>00733 
<a name="l00734"></a>00734         <span class="keywordflow">if</span> (req-&gt;tsr_service == SRPC_SERVICE_PING) {
<a name="l00735"></a>00735                 test_ping_req_t *ping = &amp;req-&gt;tsr_u.ping;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737                 __swab32s(&amp;ping-&gt;png_size);
<a name="l00738"></a>00738                 __swab32s(&amp;ping-&gt;png_flags);
<a name="l00739"></a>00739                 <span class="keywordflow">return</span>;
<a name="l00740"></a>00740         }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         LBUG();
<a name="l00743"></a>00743         <span class="keywordflow">return</span>;
<a name="l00744"></a>00744 }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00747"></a>00747 sfw_add_test_instance (<a class="code" href="structsfw__batch__t.html">sfw_batch_t</a> *tsb, <a class="code" href="structsrpc__server__rpc.html">srpc_server_rpc_t</a> *rpc)
<a name="l00748"></a>00748 {
<a name="l00749"></a>00749         <a class="code" href="structsrpc__msg.html">srpc_msg_t</a>          *msg = &amp;rpc-&gt;srpc_reqstbuf-&gt;buf_msg;
<a name="l00750"></a>00750         srpc_test_reqst_t   *req = &amp;msg-&gt;msg_body.tes_reqst;
<a name="l00751"></a>00751         <a class="code" href="structsrpc__bulk__t.html">srpc_bulk_t</a>         *bk = rpc-&gt;srpc_bulk;
<a name="l00752"></a>00752         <span class="keywordtype">int</span>                  ndest = req-&gt;tsr_ndest;
<a name="l00753"></a>00753         <a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a>     *tsu;
<a name="l00754"></a>00754         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi;
<a name="l00755"></a>00755         <span class="keywordtype">int</span>                  i;
<a name="l00756"></a>00756         <span class="keywordtype">int</span>                  rc;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758         LIBCFS_ALLOC(tsi, <span class="keyword">sizeof</span>(*tsi));
<a name="l00759"></a>00759         <span class="keywordflow">if</span> (tsi == NULL) {
<a name="l00760"></a>00760                 CERROR (<span class="stringliteral">&quot;Can&apos;t allocate test instance for batch: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00761"></a>00761                         tsb-&gt;bat_id.bat_id);
<a name="l00762"></a>00762                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00763"></a>00763         }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765         spin_lock_init(&amp;tsi-&gt;tsi_lock);
<a name="l00766"></a>00766         atomic_set(&amp;tsi-&gt;tsi_nactive, 0);
<a name="l00767"></a>00767         INIT_LIST_HEAD(&amp;tsi-&gt;tsi_units);
<a name="l00768"></a>00768         INIT_LIST_HEAD(&amp;tsi-&gt;tsi_free_rpcs);
<a name="l00769"></a>00769         INIT_LIST_HEAD(&amp;tsi-&gt;tsi_active_rpcs);
<a name="l00770"></a>00770 
<a name="l00771"></a>00771         tsi-&gt;tsi_stopping      = 0;
<a name="l00772"></a>00772         tsi-&gt;tsi_batch         = tsb;
<a name="l00773"></a>00773         tsi-&gt;tsi_loop          = req-&gt;tsr_loop;
<a name="l00774"></a>00774         tsi-&gt;tsi_concur        = req-&gt;tsr_concur;
<a name="l00775"></a>00775         tsi-&gt;tsi_service       = req-&gt;tsr_service;
<a name="l00776"></a>00776         tsi-&gt;tsi_is_client     = !!(req-&gt;tsr_is_client);
<a name="l00777"></a>00777         tsi-&gt;tsi_stoptsu_onerr = !!(req-&gt;tsr_stop_onerr);
<a name="l00778"></a>00778 
<a name="l00779"></a>00779         rc = sfw_load_test(tsi);
<a name="l00780"></a>00780         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00781"></a>00781                 LIBCFS_FREE(tsi, <span class="keyword">sizeof</span>(*tsi));
<a name="l00782"></a>00782                 <span class="keywordflow">return</span> rc;
<a name="l00783"></a>00783         }
<a name="l00784"></a>00784 
<a name="l00785"></a>00785         LASSERT (!sfw_batch_active(tsb));
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         <span class="keywordflow">if</span> (!tsi-&gt;tsi_is_client) {
<a name="l00788"></a>00788                 <span class="comment">/* it&apos;s test server, just add it to tsb */</span>
<a name="l00789"></a>00789                 list_add_tail(&amp;tsi-&gt;tsi_list, &amp;tsb-&gt;bat_tests);
<a name="l00790"></a>00790                 <span class="keywordflow">return</span> 0;
<a name="l00791"></a>00791         }
<a name="l00792"></a>00792 
<a name="l00793"></a>00793         LASSERT (bk != NULL);
<a name="l00794"></a>00794         LASSERT (bk-&gt;bk_niov * SFW_ID_PER_PAGE &gt;= (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)ndest);
<a name="l00795"></a>00795         LASSERT((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)bk-&gt;bk_len &gt;=
<a name="l00796"></a>00796                 <span class="keyword">sizeof</span>(lnet_process_id_packed_t) * ndest);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798         sfw_unpack_addtest_req(msg);
<a name="l00799"></a>00799         memcpy(&amp;tsi-&gt;tsi_u, &amp;req-&gt;tsr_u, <span class="keyword">sizeof</span>(tsi-&gt;tsi_u));
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         <span class="keywordflow">for</span> (i = 0; i &lt; ndest; i++) {
<a name="l00802"></a>00802                 lnet_process_id_packed_t *dests;
<a name="l00803"></a>00803                 lnet_process_id_packed_t  id;
<a name="l00804"></a>00804                 <span class="keywordtype">int</span>                       j;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806                 dests = page_address(bk-&gt;bk_iovs[i / SFW_ID_PER_PAGE].<a class="code" href="structlnet__kiov__t.html#a50a346ec3d5a573b47b1b81082fe15ba" title="Pointer to the page where the fragment resides.">kiov_page</a>);
<a name="l00807"></a>00807                 LASSERT (dests != NULL);  <span class="comment">/* my pages are within KVM always */</span>
<a name="l00808"></a>00808                 <span class="keywordtype">id</span> = dests[i % SFW_ID_PER_PAGE];
<a name="l00809"></a>00809                 <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a6e19bc3729ed00441eb74910836610ff" title="magic number">msg_magic</a> != SRPC_MSG_MAGIC)
<a name="l00810"></a>00810                         sfw_unpack_id(<span class="keywordtype">id</span>);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812                 <span class="keywordflow">for</span> (j = 0; j &lt; tsi-&gt;tsi_concur; j++) {
<a name="l00813"></a>00813                         LIBCFS_ALLOC(tsu, <span class="keyword">sizeof</span>(<a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a>));
<a name="l00814"></a>00814                         <span class="keywordflow">if</span> (tsu == NULL) {
<a name="l00815"></a>00815                                 rc = -ENOMEM;
<a name="l00816"></a>00816                                 CERROR (<span class="stringliteral">&quot;Can&apos;t allocate tsu for %d\n&quot;</span>,
<a name="l00817"></a>00817                                         tsi-&gt;tsi_service);
<a name="l00818"></a>00818                                 <span class="keywordflow">goto</span> error;
<a name="l00819"></a>00819                         }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821                         tsu-&gt;tsu_dest.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a> = <span class="keywordtype">id</span>.nid;
<a name="l00822"></a>00822                         tsu-&gt;tsu_dest.<a class="code" href="structlnet__process__id__t.html#ae5e3acfa9cf6ecdc2a048bf20421e4c6" title="process id">pid</a> = <span class="keywordtype">id</span>.pid;
<a name="l00823"></a>00823                         tsu-&gt;tsu_instance = tsi;
<a name="l00824"></a>00824                         tsu-&gt;tsu_private  = NULL;
<a name="l00825"></a>00825                         list_add_tail(&amp;tsu-&gt;tsu_list, &amp;tsi-&gt;tsi_units);
<a name="l00826"></a>00826                 }
<a name="l00827"></a>00827         }
<a name="l00828"></a>00828 
<a name="l00829"></a>00829         rc = tsi-&gt;tsi_ops-&gt;tso_init(tsi);
<a name="l00830"></a>00830         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00831"></a>00831                 list_add_tail(&amp;tsi-&gt;tsi_list, &amp;tsb-&gt;bat_tests);
<a name="l00832"></a>00832                 <span class="keywordflow">return</span> 0;
<a name="l00833"></a>00833         }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 error:
<a name="l00836"></a>00836         LASSERT(rc != 0);
<a name="l00837"></a>00837         sfw_destroy_test_instance(tsi);
<a name="l00838"></a>00838         <span class="keywordflow">return</span> rc;
<a name="l00839"></a>00839 }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00842"></a>00842 sfw_test_unit_done (<a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a> *tsu)
<a name="l00843"></a>00843 {
<a name="l00844"></a>00844         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi = tsu-&gt;tsu_instance;
<a name="l00845"></a>00845         <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>         *tsb = tsi-&gt;tsi_batch;
<a name="l00846"></a>00846         <a class="code" href="structsfw__session__t.html">sfw_session_t</a>       *sn = tsb-&gt;bat_session;
<a name="l00847"></a>00847 
<a name="l00848"></a>00848         LASSERT (sfw_test_active(tsi));
<a name="l00849"></a>00849 
<a name="l00850"></a>00850         <span class="keywordflow">if</span> (!atomic_dec_and_test(&amp;tsi-&gt;tsi_nactive))
<a name="l00851"></a>00851                 <span class="keywordflow">return</span>;
<a name="l00852"></a>00852 
<a name="l00853"></a>00853         <span class="comment">/* the test instance is done */</span>
<a name="l00854"></a>00854         spin_lock(&amp;tsi-&gt;tsi_lock);
<a name="l00855"></a>00855 
<a name="l00856"></a>00856         tsi-&gt;tsi_stopping = 0;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858         spin_unlock(&amp;tsi-&gt;tsi_lock);
<a name="l00859"></a>00859 
<a name="l00860"></a>00860         spin_lock(&amp;sfw_data.fw_lock);
<a name="l00861"></a>00861 
<a name="l00862"></a>00862         <span class="keywordflow">if</span> (!atomic_dec_and_test(&amp;tsb-&gt;bat_nactive) ||<span class="comment">/* tsb still active */</span>
<a name="l00863"></a>00863             sn == sfw_data.fw_session) {                  <span class="comment">/* sn also active */</span>
<a name="l00864"></a>00864                 spin_unlock(&amp;sfw_data.fw_lock);
<a name="l00865"></a>00865                 <span class="keywordflow">return</span>;
<a name="l00866"></a>00866         }
<a name="l00867"></a>00867 
<a name="l00868"></a>00868         LASSERT(!list_empty(&amp;sn-&gt;sn_list)); <span class="comment">/* I&apos;m a zombie! */</span>
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         list_for_each_entry(tsb, &amp;sn-&gt;sn_batches, bat_list) {
<a name="l00871"></a>00871                 <span class="keywordflow">if</span> (sfw_batch_active(tsb)) {
<a name="l00872"></a>00872                         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l00873"></a>00873                         <span class="keywordflow">return</span>;
<a name="l00874"></a>00874                 }
<a name="l00875"></a>00875         }
<a name="l00876"></a>00876 
<a name="l00877"></a>00877         list_del_init(&amp;sn-&gt;sn_list);
<a name="l00878"></a>00878         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l00879"></a>00879 
<a name="l00880"></a>00880         sfw_destroy_session(sn);
<a name="l00881"></a>00881         <span class="keywordflow">return</span>;
<a name="l00882"></a>00882 }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00885"></a>00885 sfw_test_rpc_done (<a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *rpc)
<a name="l00886"></a>00886 {
<a name="l00887"></a>00887         <a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a>     *tsu = rpc-&gt;crpc_priv;
<a name="l00888"></a>00888         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi = tsu-&gt;tsu_instance;
<a name="l00889"></a>00889         <span class="keywordtype">int</span>                  done = 0;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891         tsi-&gt;tsi_ops-&gt;tso_done_rpc(tsu, rpc);
<a name="l00892"></a>00892 
<a name="l00893"></a>00893         spin_lock(&amp;tsi-&gt;tsi_lock);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895         LASSERT(sfw_test_active(tsi));
<a name="l00896"></a>00896         LASSERT(!list_empty(&amp;rpc-&gt;crpc_list));
<a name="l00897"></a>00897 
<a name="l00898"></a>00898         list_del_init(&amp;rpc-&gt;crpc_list);
<a name="l00899"></a>00899 
<a name="l00900"></a>00900         <span class="comment">/* batch is stopping or loop is done or get error */</span>
<a name="l00901"></a>00901         <span class="keywordflow">if</span> (tsi-&gt;tsi_stopping ||
<a name="l00902"></a>00902             tsu-&gt;tsu_loop == 0 ||
<a name="l00903"></a>00903             (rpc-&gt;crpc_status != 0 &amp;&amp; tsi-&gt;tsi_stoptsu_onerr))
<a name="l00904"></a>00904                 done = 1;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906         <span class="comment">/* dec ref for poster */</span>
<a name="l00907"></a>00907         srpc_client_rpc_decref(rpc);
<a name="l00908"></a>00908 
<a name="l00909"></a>00909         spin_unlock(&amp;tsi-&gt;tsi_lock);
<a name="l00910"></a>00910 
<a name="l00911"></a>00911         <span class="keywordflow">if</span> (!done) {
<a name="l00912"></a>00912                 swi_schedule_workitem(&amp;tsu-&gt;tsu_worker);
<a name="l00913"></a>00913                 <span class="keywordflow">return</span>;
<a name="l00914"></a>00914         }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916         sfw_test_unit_done(tsu);
<a name="l00917"></a>00917         <span class="keywordflow">return</span>;
<a name="l00918"></a>00918 }
<a name="l00919"></a>00919 
<a name="l00920"></a>00920 <span class="keywordtype">int</span>
<a name="l00921"></a>00921 sfw_create_test_rpc(<a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a> *tsu, <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> peer,
<a name="l00922"></a>00922                     <span class="keywordtype">unsigned</span> features, <span class="keywordtype">int</span> nblk, <span class="keywordtype">int</span> blklen,
<a name="l00923"></a>00923                     <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> **rpcpp)
<a name="l00924"></a>00924 {
<a name="l00925"></a>00925         <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a>   *rpc = NULL;
<a name="l00926"></a>00926         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi = tsu-&gt;tsu_instance;
<a name="l00927"></a>00927 
<a name="l00928"></a>00928         spin_lock(&amp;tsi-&gt;tsi_lock);
<a name="l00929"></a>00929 
<a name="l00930"></a>00930         LASSERT (sfw_test_active(tsi));
<a name="l00931"></a>00931 
<a name="l00932"></a>00932         <span class="keywordflow">if</span> (!list_empty(&amp;tsi-&gt;tsi_free_rpcs)) {
<a name="l00933"></a>00933                 <span class="comment">/* pick request from buffer */</span>
<a name="l00934"></a>00934                 rpc = list_entry(tsi-&gt;tsi_free_rpcs.next,
<a name="l00935"></a>00935                                  <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a>, crpc_list);
<a name="l00936"></a>00936                 LASSERT(nblk == rpc-&gt;crpc_bulk.bk_niov);
<a name="l00937"></a>00937                 list_del_init(&amp;rpc-&gt;crpc_list);
<a name="l00938"></a>00938         }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940         spin_unlock(&amp;tsi-&gt;tsi_lock);
<a name="l00941"></a>00941 
<a name="l00942"></a>00942         <span class="keywordflow">if</span> (rpc == NULL) {
<a name="l00943"></a>00943                 rpc = srpc_create_client_rpc(peer, tsi-&gt;tsi_service, nblk,
<a name="l00944"></a>00944                                              blklen, sfw_test_rpc_done,
<a name="l00945"></a>00945                                              sfw_test_rpc_fini, tsu);
<a name="l00946"></a>00946         } <span class="keywordflow">else</span> {
<a name="l00947"></a>00947                 srpc_init_client_rpc(rpc, peer, tsi-&gt;tsi_service, nblk,
<a name="l00948"></a>00948                                      blklen, sfw_test_rpc_done,
<a name="l00949"></a>00949                                      sfw_test_rpc_fini, tsu);
<a name="l00950"></a>00950         }
<a name="l00951"></a>00951 
<a name="l00952"></a>00952         <span class="keywordflow">if</span> (rpc == NULL) {
<a name="l00953"></a>00953                 CERROR(<span class="stringliteral">&quot;Can&apos;t create rpc for test %d\n&quot;</span>, tsi-&gt;tsi_service);
<a name="l00954"></a>00954                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00955"></a>00955         }
<a name="l00956"></a>00956 
<a name="l00957"></a>00957         rpc-&gt;crpc_reqstmsg.<a class="code" href="structsrpc__msg.html#a26415755866d1fb46d201e4d937db7fd" title="test session features">msg_ses_feats</a> = features;
<a name="l00958"></a>00958         *rpcpp = rpc;
<a name="l00959"></a>00959 
<a name="l00960"></a>00960         <span class="keywordflow">return</span> 0;
<a name="l00961"></a>00961 }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00964"></a>00964 sfw_run_test (<a class="code" href="structswi__workitem.html">swi_workitem_t</a> *wi)
<a name="l00965"></a>00965 {
<a name="l00966"></a>00966         <a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a>     *tsu = wi-&gt;swi_workitem.<a class="code" href="structcfs__workitem.html#ad76e114ccdff34b0072cdaed1252e295" title="arg for working function">wi_data</a>;
<a name="l00967"></a>00967         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi = tsu-&gt;tsu_instance;
<a name="l00968"></a>00968         <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a>   *rpc = NULL;
<a name="l00969"></a>00969 
<a name="l00970"></a>00970         LASSERT (wi == &amp;tsu-&gt;tsu_worker);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972         <span class="keywordflow">if</span> (tsi-&gt;tsi_ops-&gt;tso_prep_rpc(tsu, tsu-&gt;tsu_dest, &amp;rpc) != 0) {
<a name="l00973"></a>00973                 LASSERT (rpc == NULL);
<a name="l00974"></a>00974                 <span class="keywordflow">goto</span> test_done;
<a name="l00975"></a>00975         }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         LASSERT (rpc != NULL);
<a name="l00978"></a>00978 
<a name="l00979"></a>00979         spin_lock(&amp;tsi-&gt;tsi_lock);
<a name="l00980"></a>00980 
<a name="l00981"></a>00981         <span class="keywordflow">if</span> (tsi-&gt;tsi_stopping) {
<a name="l00982"></a>00982                 list_add(&amp;rpc-&gt;crpc_list, &amp;tsi-&gt;tsi_free_rpcs);
<a name="l00983"></a>00983                 spin_unlock(&amp;tsi-&gt;tsi_lock);
<a name="l00984"></a>00984                 <span class="keywordflow">goto</span> test_done;
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986 
<a name="l00987"></a>00987         <span class="keywordflow">if</span> (tsu-&gt;tsu_loop &gt; 0)
<a name="l00988"></a>00988                 tsu-&gt;tsu_loop--;
<a name="l00989"></a>00989 
<a name="l00990"></a>00990         list_add_tail(&amp;rpc-&gt;crpc_list, &amp;tsi-&gt;tsi_active_rpcs);
<a name="l00991"></a>00991         spin_unlock(&amp;tsi-&gt;tsi_lock);
<a name="l00992"></a>00992 
<a name="l00993"></a>00993         spin_lock(&amp;rpc-&gt;crpc_lock);
<a name="l00994"></a>00994         rpc-&gt;crpc_timeout = rpc_timeout;
<a name="l00995"></a>00995         srpc_post_rpc(rpc);
<a name="l00996"></a>00996         spin_unlock(&amp;rpc-&gt;crpc_lock);
<a name="l00997"></a>00997         <span class="keywordflow">return</span> 0;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999 test_done:
<a name="l01000"></a>01000         <span class="comment">/*</span>
<a name="l01001"></a>01001 <span class="comment">         * No one can schedule me now since:</span>
<a name="l01002"></a>01002 <span class="comment">         * - previous RPC, if any, has done and</span>
<a name="l01003"></a>01003 <span class="comment">         * - no new RPC is initiated.</span>
<a name="l01004"></a>01004 <span class="comment">         * - my batch is still active; no one can run it again now.</span>
<a name="l01005"></a>01005 <span class="comment">         * Cancel pending schedules and prevent future schedule attempts:</span>
<a name="l01006"></a>01006 <span class="comment">         */</span>
<a name="l01007"></a>01007         swi_exit_workitem(wi);
<a name="l01008"></a>01008         sfw_test_unit_done(tsu);
<a name="l01009"></a>01009         <span class="keywordflow">return</span> 1;
<a name="l01010"></a>01010 }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01013"></a>01013 sfw_run_batch (<a class="code" href="structsfw__batch__t.html">sfw_batch_t</a> *tsb)
<a name="l01014"></a>01014 {
<a name="l01015"></a>01015         <a class="code" href="structswi__workitem.html">swi_workitem_t</a>      *wi;
<a name="l01016"></a>01016         <a class="code" href="structsfw__test__unit.html">sfw_test_unit_t</a>     *tsu;
<a name="l01017"></a>01017         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi;
<a name="l01018"></a>01018 
<a name="l01019"></a>01019         <span class="keywordflow">if</span> (sfw_batch_active(tsb)) {
<a name="l01020"></a>01020                 CDEBUG(D_NET, <span class="stringliteral">&quot;Batch already active: &quot;</span>LPU64<span class="stringliteral">&quot; (%d)\n&quot;</span>,
<a name="l01021"></a>01021                        tsb-&gt;bat_id.bat_id, atomic_read(&amp;tsb-&gt;bat_nactive));
<a name="l01022"></a>01022                 <span class="keywordflow">return</span> 0;
<a name="l01023"></a>01023         }
<a name="l01024"></a>01024 
<a name="l01025"></a>01025         list_for_each_entry(tsi, &amp;tsb-&gt;bat_tests, tsi_list) {
<a name="l01026"></a>01026                 <span class="keywordflow">if</span> (!tsi-&gt;tsi_is_client)        <span class="comment">/* skip server instances */</span>
<a name="l01027"></a>01027                         <span class="keywordflow">continue</span>;
<a name="l01028"></a>01028 
<a name="l01029"></a>01029                 LASSERT(!tsi-&gt;tsi_stopping);
<a name="l01030"></a>01030                 LASSERT(!sfw_test_active(tsi));
<a name="l01031"></a>01031 
<a name="l01032"></a>01032                 atomic_inc(&amp;tsb-&gt;bat_nactive);
<a name="l01033"></a>01033 
<a name="l01034"></a>01034                 list_for_each_entry(tsu, &amp;tsi-&gt;tsi_units, tsu_list) {
<a name="l01035"></a>01035                         atomic_inc(&amp;tsi-&gt;tsi_nactive);
<a name="l01036"></a>01036                         tsu-&gt;tsu_loop = tsi-&gt;tsi_loop;
<a name="l01037"></a>01037                         wi = &amp;tsu-&gt;tsu_worker;
<a name="l01038"></a>01038                         swi_init_workitem(wi, tsu, sfw_run_test,
<a name="l01039"></a>01039                                           lst_sched_test[\
<a name="l01040"></a>01040                                           lnet_cpt_of_nid(tsu-&gt;tsu_dest.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>)]);
<a name="l01041"></a>01041                         swi_schedule_workitem(wi);
<a name="l01042"></a>01042                 }
<a name="l01043"></a>01043         }
<a name="l01044"></a>01044 
<a name="l01045"></a>01045         <span class="keywordflow">return</span> 0;
<a name="l01046"></a>01046 }
<a name="l01047"></a>01047 
<a name="l01048"></a>01048 <span class="keywordtype">int</span>
<a name="l01049"></a>01049 sfw_stop_batch (<a class="code" href="structsfw__batch__t.html">sfw_batch_t</a> *tsb, <span class="keywordtype">int</span> force)
<a name="l01050"></a>01050 {
<a name="l01051"></a>01051         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi;
<a name="l01052"></a>01052         <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a>   *rpc;
<a name="l01053"></a>01053 
<a name="l01054"></a>01054         <span class="keywordflow">if</span> (!sfw_batch_active(tsb)) {
<a name="l01055"></a>01055                 CDEBUG(D_NET, <span class="stringliteral">&quot;Batch &quot;</span>LPU64<span class="stringliteral">&quot; inactive\n&quot;</span>, tsb-&gt;bat_id.bat_id);
<a name="l01056"></a>01056                 <span class="keywordflow">return</span> 0;
<a name="l01057"></a>01057         }
<a name="l01058"></a>01058 
<a name="l01059"></a>01059         list_for_each_entry(tsi, &amp;tsb-&gt;bat_tests, tsi_list) {
<a name="l01060"></a>01060                 spin_lock(&amp;tsi-&gt;tsi_lock);
<a name="l01061"></a>01061 
<a name="l01062"></a>01062                 <span class="keywordflow">if</span> (!tsi-&gt;tsi_is_client ||
<a name="l01063"></a>01063                     !sfw_test_active(tsi) || tsi-&gt;tsi_stopping) {
<a name="l01064"></a>01064                         spin_unlock(&amp;tsi-&gt;tsi_lock);
<a name="l01065"></a>01065                         <span class="keywordflow">continue</span>;
<a name="l01066"></a>01066                 }
<a name="l01067"></a>01067 
<a name="l01068"></a>01068                 tsi-&gt;tsi_stopping = 1;
<a name="l01069"></a>01069 
<a name="l01070"></a>01070                 <span class="keywordflow">if</span> (!force) {
<a name="l01071"></a>01071                         spin_unlock(&amp;tsi-&gt;tsi_lock);
<a name="l01072"></a>01072                         <span class="keywordflow">continue</span>;
<a name="l01073"></a>01073                 }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075                 <span class="comment">/* abort launched rpcs in the test */</span>
<a name="l01076"></a>01076                 list_for_each_entry(rpc, &amp;tsi-&gt;tsi_active_rpcs, crpc_list) {
<a name="l01077"></a>01077                         spin_lock(&amp;rpc-&gt;crpc_lock);
<a name="l01078"></a>01078 
<a name="l01079"></a>01079                         srpc_abort_rpc(rpc, -EINTR);
<a name="l01080"></a>01080 
<a name="l01081"></a>01081                         spin_unlock(&amp;rpc-&gt;crpc_lock);
<a name="l01082"></a>01082                 }
<a name="l01083"></a>01083 
<a name="l01084"></a>01084                 spin_unlock(&amp;tsi-&gt;tsi_lock);
<a name="l01085"></a>01085         }
<a name="l01086"></a>01086 
<a name="l01087"></a>01087         <span class="keywordflow">return</span> 0;
<a name="l01088"></a>01088 }
<a name="l01089"></a>01089 
<a name="l01090"></a>01090 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01091"></a>01091 sfw_query_batch (<a class="code" href="structsfw__batch__t.html">sfw_batch_t</a> *tsb, <span class="keywordtype">int</span> testidx, srpc_batch_reply_t *reply)
<a name="l01092"></a>01092 {
<a name="l01093"></a>01093         <a class="code" href="structsfw__test__instance.html">sfw_test_instance_t</a> *tsi;
<a name="l01094"></a>01094 
<a name="l01095"></a>01095         <span class="keywordflow">if</span> (testidx &lt; 0)
<a name="l01096"></a>01096                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01097"></a>01097 
<a name="l01098"></a>01098         <span class="keywordflow">if</span> (testidx == 0) {
<a name="l01099"></a>01099                 reply-&gt;bar_active = atomic_read(&amp;tsb-&gt;bat_nactive);
<a name="l01100"></a>01100                 <span class="keywordflow">return</span> 0;
<a name="l01101"></a>01101         }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         list_for_each_entry(tsi, &amp;tsb-&gt;bat_tests, tsi_list) {
<a name="l01104"></a>01104                 <span class="keywordflow">if</span> (testidx-- &gt; 1)
<a name="l01105"></a>01105                         <span class="keywordflow">continue</span>;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107                 reply-&gt;bar_active = atomic_read(&amp;tsi-&gt;tsi_nactive);
<a name="l01108"></a>01108                 <span class="keywordflow">return</span> 0;
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="keywordflow">return</span> -ENOENT;
<a name="l01112"></a>01112 }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114 <span class="keywordtype">void</span>
<a name="l01115"></a>01115 sfw_free_pages (<a class="code" href="structsrpc__server__rpc.html">srpc_server_rpc_t</a> *rpc)
<a name="l01116"></a>01116 {
<a name="l01117"></a>01117         srpc_free_bulk(rpc-&gt;srpc_bulk);
<a name="l01118"></a>01118         rpc-&gt;srpc_bulk = NULL;
<a name="l01119"></a>01119 }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="keywordtype">int</span>
<a name="l01122"></a>01122 sfw_alloc_pages(<span class="keyword">struct</span> <a class="code" href="structsrpc__server__rpc.html">srpc_server_rpc</a> *rpc, <span class="keywordtype">int</span> cpt, <span class="keywordtype">int</span> npages, <span class="keywordtype">int</span> len,
<a name="l01123"></a>01123                 <span class="keywordtype">int</span> sink)
<a name="l01124"></a>01124 {
<a name="l01125"></a>01125         LASSERT(rpc-&gt;srpc_bulk == NULL);
<a name="l01126"></a>01126         LASSERT(npages &gt; 0 &amp;&amp; npages &lt;= <a class="code" href="group__lnet__md.html#gae5c5481fe02371e7bf253b2b1cf0d030" title="limit on the number of fragments in discontiguous MDs">LNET_MAX_IOV</a>);
<a name="l01127"></a>01127 
<a name="l01128"></a>01128         rpc-&gt;srpc_bulk = srpc_alloc_bulk(cpt, npages, len, sink);
<a name="l01129"></a>01129         <span class="keywordflow">if</span> (rpc-&gt;srpc_bulk == NULL)
<a name="l01130"></a>01130                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01131"></a>01131 
<a name="l01132"></a>01132         <span class="keywordflow">return</span> 0;
<a name="l01133"></a>01133 }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01136"></a>01136 sfw_add_test (<a class="code" href="structsrpc__server__rpc.html">srpc_server_rpc_t</a> *rpc)
<a name="l01137"></a>01137 {
<a name="l01138"></a>01138         <a class="code" href="structsfw__session__t.html">sfw_session_t</a>     *sn = sfw_data.fw_session;
<a name="l01139"></a>01139         srpc_test_reply_t *reply = &amp;rpc-&gt;srpc_replymsg.msg_body.tes_reply;
<a name="l01140"></a>01140         srpc_test_reqst_t *request;
<a name="l01141"></a>01141         <span class="keywordtype">int</span>                rc;
<a name="l01142"></a>01142         <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>       *bat;
<a name="l01143"></a>01143 
<a name="l01144"></a>01144         request = &amp;rpc-&gt;srpc_reqstbuf-&gt;buf_msg.msg_body.tes_reqst;
<a name="l01145"></a>01145         reply-&gt;tsr_sid = (sn == NULL) ? LST_INVALID_SID : sn-&gt;sn_id;
<a name="l01146"></a>01146 
<a name="l01147"></a>01147         if (request-&gt;tsr_loop == 0 ||
<a name="l01148"></a>01148             request-&gt;tsr_concur == 0 ||
<a name="l01149"></a>01149             request-&gt;tsr_sid.ses_nid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a> ||
<a name="l01150"></a>01150             request-&gt;tsr_ndest &gt; SFW_MAX_NDESTS ||
<a name="l01151"></a>01151             (request-&gt;tsr_is_client &amp;&amp; request-&gt;tsr_ndest == 0) ||
<a name="l01152"></a>01152             request-&gt;tsr_concur &gt; SFW_MAX_CONCUR ||
<a name="l01153"></a>01153             request-&gt;tsr_service &gt; SRPC_SERVICE_MAX_ID ||
<a name="l01154"></a>01154             request-&gt;tsr_service &lt;= SRPC_FRAMEWORK_SERVICE_MAX_ID) {
<a name="l01155"></a>01155                 reply-&gt;tsr_status = EINVAL;
<a name="l01156"></a>01156                 <span class="keywordflow">return</span> 0;
<a name="l01157"></a>01157         }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159         <span class="keywordflow">if</span> (sn == NULL || !sfw_sid_equal(request-&gt;tsr_sid, sn-&gt;sn_id) ||
<a name="l01160"></a>01160             sfw_find_test_case(request-&gt;tsr_service) == NULL) {
<a name="l01161"></a>01161                 reply-&gt;tsr_status = ENOENT;
<a name="l01162"></a>01162                 <span class="keywordflow">return</span> 0;
<a name="l01163"></a>01163         }
<a name="l01164"></a>01164 
<a name="l01165"></a>01165         bat = sfw_bid2batch(request-&gt;tsr_bid);
<a name="l01166"></a>01166         <span class="keywordflow">if</span> (bat == NULL) {
<a name="l01167"></a>01167                 CERROR(<span class="stringliteral">&quot;dropping RPC %s from %s under memory pressure\n&quot;</span>,
<a name="l01168"></a>01168                         rpc-&gt;srpc_scd-&gt;<a class="code" href="structsrpc__service__cd.html#a67031f3a1bac63fc1462c7986c858640" title="backref to service">scd_svc</a>-&gt;sv_name,
<a name="l01169"></a>01169                         libcfs_id2str(rpc-&gt;srpc_peer));
<a name="l01170"></a>01170                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01171"></a>01171         }
<a name="l01172"></a>01172 
<a name="l01173"></a>01173         <span class="keywordflow">if</span> (sfw_batch_active(bat)) {
<a name="l01174"></a>01174                 reply-&gt;tsr_status = EBUSY;
<a name="l01175"></a>01175                 <span class="keywordflow">return</span> 0;
<a name="l01176"></a>01176         }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178         <span class="keywordflow">if</span> (request-&gt;tsr_is_client &amp;&amp; rpc-&gt;srpc_bulk == NULL) {
<a name="l01179"></a>01179                 <span class="comment">/* rpc will be resumed later in sfw_bulk_ready */</span>
<a name="l01180"></a>01180                 <span class="keywordtype">int</span>     npg = sfw_id_pages(request-&gt;tsr_ndest);
<a name="l01181"></a>01181                 <span class="keywordtype">int</span>     len;
<a name="l01182"></a>01182 
<a name="l01183"></a>01183                 <span class="keywordflow">if</span> ((sn-&gt;sn_features &amp; LST_FEAT_BULK_LEN) == 0) {
<a name="l01184"></a>01184                         len = npg * PAGE_CACHE_SIZE;
<a name="l01185"></a>01185 
<a name="l01186"></a>01186                 } <span class="keywordflow">else</span>  {
<a name="l01187"></a>01187                         len = <span class="keyword">sizeof</span>(lnet_process_id_packed_t) *
<a name="l01188"></a>01188                               request-&gt;tsr_ndest;
<a name="l01189"></a>01189                 }
<a name="l01190"></a>01190 
<a name="l01191"></a>01191                 <span class="keywordflow">return</span> sfw_alloc_pages(rpc, CFS_CPT_ANY, npg, len, 1);
<a name="l01192"></a>01192         }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         rc = sfw_add_test_instance(bat, rpc);
<a name="l01195"></a>01195         CDEBUG (rc == 0 ? D_NET : D_WARNING,
<a name="l01196"></a>01196                 <span class="stringliteral">&quot;%s test: sv %d %s, loop %d, concur %d, ndest %d\n&quot;</span>,
<a name="l01197"></a>01197                 rc == 0 ? <span class="stringliteral">&quot;Added&quot;</span> : <span class="stringliteral">&quot;Failed to add&quot;</span>, request-&gt;tsr_service,
<a name="l01198"></a>01198                 request-&gt;tsr_is_client ? <span class="stringliteral">&quot;client&quot;</span> : <span class="stringliteral">&quot;server&quot;</span>,
<a name="l01199"></a>01199                 request-&gt;tsr_loop, request-&gt;tsr_concur, request-&gt;tsr_ndest);
<a name="l01200"></a>01200 
<a name="l01201"></a>01201         reply-&gt;tsr_status = (rc &lt; 0) ? -rc : rc;
<a name="l01202"></a>01202         <span class="keywordflow">return</span> 0;
<a name="l01203"></a>01203 }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01206"></a>01206 sfw_control_batch (srpc_batch_reqst_t *request, srpc_batch_reply_t *reply)
<a name="l01207"></a>01207 {
<a name="l01208"></a>01208         <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l01209"></a>01209         <span class="keywordtype">int</span>            rc = 0;
<a name="l01210"></a>01210         <a class="code" href="structsfw__batch__t.html">sfw_batch_t</a>   *bat;
<a name="l01211"></a>01211 
<a name="l01212"></a>01212         reply-&gt;bar_sid = (sn == NULL) ? LST_INVALID_SID : sn-&gt;sn_id;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214         if (sn == NULL || !sfw_sid_equal(request-&gt;bar_sid, sn-&gt;sn_id)) {
<a name="l01215"></a>01215                 reply-&gt;bar_status = ESRCH;
<a name="l01216"></a>01216                 <span class="keywordflow">return</span> 0;
<a name="l01217"></a>01217         }
<a name="l01218"></a>01218 
<a name="l01219"></a>01219         bat = sfw_find_batch(request-&gt;bar_bid);
<a name="l01220"></a>01220         <span class="keywordflow">if</span> (bat == NULL) {
<a name="l01221"></a>01221                 reply-&gt;bar_status = ENOENT;
<a name="l01222"></a>01222                 <span class="keywordflow">return</span> 0;
<a name="l01223"></a>01223         }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225         <span class="keywordflow">switch</span> (request-&gt;bar_opc) {
<a name="l01226"></a>01226         <span class="keywordflow">case</span> SRPC_BATCH_OPC_RUN:
<a name="l01227"></a>01227                 rc = sfw_run_batch(bat);
<a name="l01228"></a>01228                 <span class="keywordflow">break</span>;
<a name="l01229"></a>01229 
<a name="l01230"></a>01230         <span class="keywordflow">case</span> SRPC_BATCH_OPC_STOP:
<a name="l01231"></a>01231                 rc = sfw_stop_batch(bat, request-&gt;bar_arg);
<a name="l01232"></a>01232                 <span class="keywordflow">break</span>;
<a name="l01233"></a>01233 
<a name="l01234"></a>01234         <span class="keywordflow">case</span> SRPC_BATCH_OPC_QUERY:
<a name="l01235"></a>01235                 rc = sfw_query_batch(bat, request-&gt;bar_testidx, reply);
<a name="l01236"></a>01236                 <span class="keywordflow">break</span>;
<a name="l01237"></a>01237 
<a name="l01238"></a>01238         <span class="keywordflow">default</span>:
<a name="l01239"></a>01239                 <span class="keywordflow">return</span> -EINVAL; <span class="comment">/* drop it */</span>
<a name="l01240"></a>01240         }
<a name="l01241"></a>01241 
<a name="l01242"></a>01242         reply-&gt;bar_status = (rc &lt; 0) ? -rc : rc;
<a name="l01243"></a>01243         <span class="keywordflow">return</span> 0;
<a name="l01244"></a>01244 }
<a name="l01245"></a>01245 
<a name="l01246"></a>01246 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01247"></a>01247 sfw_handle_server_rpc(<span class="keyword">struct</span> <a class="code" href="structsrpc__server__rpc.html">srpc_server_rpc</a> *rpc)
<a name="l01248"></a>01248 {
<a name="l01249"></a>01249         <span class="keyword">struct </span><a class="code" href="structsrpc__service.html">srpc_service</a>     *sv = rpc-&gt;srpc_scd-&gt;<a class="code" href="structsrpc__service__cd.html#a67031f3a1bac63fc1462c7986c858640" title="backref to service">scd_svc</a>;
<a name="l01250"></a>01250         <a class="code" href="structsrpc__msg.html">srpc_msg_t</a>     *reply   = &amp;rpc-&gt;srpc_replymsg;
<a name="l01251"></a>01251         <a class="code" href="structsrpc__msg.html">srpc_msg_t</a>     *request = &amp;rpc-&gt;srpc_reqstbuf-&gt;buf_msg;
<a name="l01252"></a>01252         <span class="keywordtype">unsigned</span>        features = LST_FEATS_MASK;
<a name="l01253"></a>01253         <span class="keywordtype">int</span>             rc = 0;
<a name="l01254"></a>01254 
<a name="l01255"></a>01255         LASSERT(sfw_data.fw_active_srpc == NULL);
<a name="l01256"></a>01256         LASSERT(sv-&gt;sv_id &lt;= SRPC_FRAMEWORK_SERVICE_MAX_ID);
<a name="l01257"></a>01257 
<a name="l01258"></a>01258         spin_lock(&amp;sfw_data.fw_lock);
<a name="l01259"></a>01259 
<a name="l01260"></a>01260         <span class="keywordflow">if</span> (sfw_data.fw_shuttingdown) {
<a name="l01261"></a>01261                 spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01262"></a>01262                 <span class="keywordflow">return</span> -ESHUTDOWN;
<a name="l01263"></a>01263         }
<a name="l01264"></a>01264 
<a name="l01265"></a>01265         <span class="comment">/* Remove timer to avoid racing with it or expiring active session */</span>
<a name="l01266"></a>01266         <span class="keywordflow">if</span> (sfw_del_session_timer() != 0) {
<a name="l01267"></a>01267                 CERROR(<span class="stringliteral">&quot;dropping RPC %s from %s: racing with expiry timer\n&quot;</span>,
<a name="l01268"></a>01268                        sv-&gt;sv_name, libcfs_id2str(rpc-&gt;srpc_peer));
<a name="l01269"></a>01269                 spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01270"></a>01270                 <span class="keywordflow">return</span> -EAGAIN;
<a name="l01271"></a>01271         }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273         sfw_data.fw_active_srpc = rpc;
<a name="l01274"></a>01274         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01275"></a>01275 
<a name="l01276"></a>01276         sfw_unpack_message(request);
<a name="l01277"></a>01277         LASSERT(request-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == srpc_service2request(sv-&gt;sv_id));
<a name="l01278"></a>01278 
<a name="l01279"></a>01279         <span class="comment">/* rpc module should have checked this */</span>
<a name="l01280"></a>01280         LASSERT(request-&gt;<a class="code" href="structsrpc__msg.html#a908c4f62d058a1478431f326b24be5a3" title="message version number">msg_version</a> == SRPC_MSG_VERSION);
<a name="l01281"></a>01281 
<a name="l01282"></a>01282         <span class="keywordflow">if</span> (sv-&gt;sv_id != SRPC_SERVICE_MAKE_SESSION &amp;&amp;
<a name="l01283"></a>01283             sv-&gt;sv_id != SRPC_SERVICE_DEBUG) {
<a name="l01284"></a>01284                 <a class="code" href="structsfw__session__t.html">sfw_session_t</a> *sn = sfw_data.fw_session;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286                 <span class="keywordflow">if</span> (sn != NULL &amp;&amp;
<a name="l01287"></a>01287                     sn-&gt;sn_features != request-&gt;<a class="code" href="structsrpc__msg.html#a26415755866d1fb46d201e4d937db7fd" title="test session features">msg_ses_feats</a>) {
<a name="l01288"></a>01288                         CNETERR(<span class="stringliteral">&quot;Features of framework RPC don&apos;t match &quot;</span>
<a name="l01289"></a>01289                                 <span class="stringliteral">&quot;features of current session: %x/%x\n&quot;</span>,
<a name="l01290"></a>01290                                 request-&gt;<a class="code" href="structsrpc__msg.html#a26415755866d1fb46d201e4d937db7fd" title="test session features">msg_ses_feats</a>, sn-&gt;sn_features);
<a name="l01291"></a>01291                         reply-&gt;msg_body.reply.status = EPROTO;
<a name="l01292"></a>01292                         reply-&gt;msg_body.reply.sid    = sn-&gt;sn_id;
<a name="l01293"></a>01293                         <span class="keywordflow">goto</span> out;
<a name="l01294"></a>01294                 }
<a name="l01295"></a>01295 
<a name="l01296"></a>01296         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((request-&gt;<a class="code" href="structsrpc__msg.html#a26415755866d1fb46d201e4d937db7fd" title="test session features">msg_ses_feats</a> &amp; ~LST_FEATS_MASK) != 0) {
<a name="l01297"></a>01297                 <span class="comment">/* NB: at this point, old version will ignore features and</span>
<a name="l01298"></a>01298 <span class="comment">                 * create new session anyway, so console should be able</span>
<a name="l01299"></a>01299 <span class="comment">                 * to handle this */</span>
<a name="l01300"></a>01300                 reply-&gt;msg_body.reply.status = EPROTO;
<a name="l01301"></a>01301                 <span class="keywordflow">goto</span> out;
<a name="l01302"></a>01302         }
<a name="l01303"></a>01303 
<a name="l01304"></a>01304         <span class="keywordflow">switch</span>(sv-&gt;sv_id) {
<a name="l01305"></a>01305         <span class="keywordflow">default</span>:
<a name="l01306"></a>01306                 LBUG ();
<a name="l01307"></a>01307         <span class="keywordflow">case</span> SRPC_SERVICE_TEST:
<a name="l01308"></a>01308                 rc = sfw_add_test(rpc);
<a name="l01309"></a>01309                 <span class="keywordflow">break</span>;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         <span class="keywordflow">case</span> SRPC_SERVICE_BATCH:
<a name="l01312"></a>01312                 rc = sfw_control_batch(&amp;request-&gt;msg_body.bat_reqst,
<a name="l01313"></a>01313                                        &amp;reply-&gt;msg_body.bat_reply);
<a name="l01314"></a>01314                 <span class="keywordflow">break</span>;
<a name="l01315"></a>01315 
<a name="l01316"></a>01316         <span class="keywordflow">case</span> SRPC_SERVICE_QUERY_STAT:
<a name="l01317"></a>01317                 rc = sfw_get_stats(&amp;request-&gt;msg_body.stat_reqst,
<a name="l01318"></a>01318                                    &amp;reply-&gt;msg_body.stat_reply);
<a name="l01319"></a>01319                 <span class="keywordflow">break</span>;
<a name="l01320"></a>01320 
<a name="l01321"></a>01321         <span class="keywordflow">case</span> SRPC_SERVICE_DEBUG:
<a name="l01322"></a>01322                 rc = sfw_debug_session(&amp;request-&gt;msg_body.dbg_reqst,
<a name="l01323"></a>01323                                        &amp;reply-&gt;msg_body.dbg_reply);
<a name="l01324"></a>01324                 <span class="keywordflow">break</span>;
<a name="l01325"></a>01325 
<a name="l01326"></a>01326         <span class="keywordflow">case</span> SRPC_SERVICE_MAKE_SESSION:
<a name="l01327"></a>01327                 rc = sfw_make_session(&amp;request-&gt;msg_body.mksn_reqst,
<a name="l01328"></a>01328                                       &amp;reply-&gt;msg_body.mksn_reply);
<a name="l01329"></a>01329                 <span class="keywordflow">break</span>;
<a name="l01330"></a>01330 
<a name="l01331"></a>01331         <span class="keywordflow">case</span> SRPC_SERVICE_REMOVE_SESSION:
<a name="l01332"></a>01332                 rc = sfw_remove_session(&amp;request-&gt;msg_body.rmsn_reqst,
<a name="l01333"></a>01333                                         &amp;reply-&gt;msg_body.rmsn_reply);
<a name="l01334"></a>01334                 <span class="keywordflow">break</span>;
<a name="l01335"></a>01335         }
<a name="l01336"></a>01336 
<a name="l01337"></a>01337         <span class="keywordflow">if</span> (sfw_data.fw_session != NULL)
<a name="l01338"></a>01338                 features = sfw_data.fw_session-&gt;sn_features;
<a name="l01339"></a>01339  out:
<a name="l01340"></a>01340         reply-&gt;<a class="code" href="structsrpc__msg.html#a26415755866d1fb46d201e4d937db7fd" title="test session features">msg_ses_feats</a> = features;
<a name="l01341"></a>01341         rpc-&gt;srpc_done = sfw_server_rpc_done;
<a name="l01342"></a>01342         spin_lock(&amp;sfw_data.fw_lock);
<a name="l01343"></a>01343 
<a name="l01344"></a>01344         <span class="keywordflow">if</span> (!sfw_data.fw_shuttingdown)
<a name="l01345"></a>01345                 sfw_add_session_timer();
<a name="l01346"></a>01346 
<a name="l01347"></a>01347         sfw_data.fw_active_srpc = NULL;
<a name="l01348"></a>01348         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01349"></a>01349         <span class="keywordflow">return</span> rc;
<a name="l01350"></a>01350 }
<a name="l01351"></a>01351 
<a name="l01352"></a>01352 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01353"></a>01353 sfw_bulk_ready(<span class="keyword">struct</span> <a class="code" href="structsrpc__server__rpc.html">srpc_server_rpc</a> *rpc, <span class="keywordtype">int</span> status)
<a name="l01354"></a>01354 {
<a name="l01355"></a>01355         <span class="keyword">struct </span><a class="code" href="structsrpc__service.html">srpc_service</a>     *sv = rpc-&gt;srpc_scd-&gt;<a class="code" href="structsrpc__service__cd.html#a67031f3a1bac63fc1462c7986c858640" title="backref to service">scd_svc</a>;
<a name="l01356"></a>01356         <span class="keywordtype">int</span>                     rc;
<a name="l01357"></a>01357 
<a name="l01358"></a>01358         LASSERT(rpc-&gt;srpc_bulk != NULL);
<a name="l01359"></a>01359         LASSERT(sv-&gt;sv_id == SRPC_SERVICE_TEST);
<a name="l01360"></a>01360         LASSERT(sfw_data.fw_active_srpc == NULL);
<a name="l01361"></a>01361         LASSERT(rpc-&gt;srpc_reqstbuf-&gt;buf_msg.msg_body.tes_reqst.tsr_is_client);
<a name="l01362"></a>01362 
<a name="l01363"></a>01363         spin_lock(&amp;sfw_data.fw_lock);
<a name="l01364"></a>01364 
<a name="l01365"></a>01365         <span class="keywordflow">if</span> (status != 0) {
<a name="l01366"></a>01366                 CERROR(<span class="stringliteral">&quot;Bulk transfer failed for RPC: &quot;</span>
<a name="l01367"></a>01367                        <span class="stringliteral">&quot;service %s, peer %s, status %d\n&quot;</span>,
<a name="l01368"></a>01368                        sv-&gt;sv_name, libcfs_id2str(rpc-&gt;srpc_peer), status);
<a name="l01369"></a>01369                 spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01370"></a>01370                 <span class="keywordflow">return</span> -EIO;
<a name="l01371"></a>01371         }
<a name="l01372"></a>01372 
<a name="l01373"></a>01373         <span class="keywordflow">if</span> (sfw_data.fw_shuttingdown) {
<a name="l01374"></a>01374                 spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01375"></a>01375                 <span class="keywordflow">return</span> -ESHUTDOWN;
<a name="l01376"></a>01376         }
<a name="l01377"></a>01377 
<a name="l01378"></a>01378         <span class="keywordflow">if</span> (sfw_del_session_timer() != 0) {
<a name="l01379"></a>01379                 CERROR(<span class="stringliteral">&quot;dropping RPC %s from %s: racing with expiry timer\n&quot;</span>,
<a name="l01380"></a>01380                        sv-&gt;sv_name, libcfs_id2str(rpc-&gt;srpc_peer));
<a name="l01381"></a>01381                 spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01382"></a>01382                 <span class="keywordflow">return</span> -EAGAIN;
<a name="l01383"></a>01383         }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385         sfw_data.fw_active_srpc = rpc;
<a name="l01386"></a>01386         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01387"></a>01387 
<a name="l01388"></a>01388         rc = sfw_add_test(rpc);
<a name="l01389"></a>01389 
<a name="l01390"></a>01390         spin_lock(&amp;sfw_data.fw_lock);
<a name="l01391"></a>01391 
<a name="l01392"></a>01392         <span class="keywordflow">if</span> (!sfw_data.fw_shuttingdown)
<a name="l01393"></a>01393                 sfw_add_session_timer();
<a name="l01394"></a>01394 
<a name="l01395"></a>01395         sfw_data.fw_active_srpc = NULL;
<a name="l01396"></a>01396         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01397"></a>01397         <span class="keywordflow">return</span> rc;
<a name="l01398"></a>01398 }
<a name="l01399"></a>01399 
<a name="l01400"></a>01400 <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *
<a name="l01401"></a>01401 sfw_create_rpc(<a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> peer, <span class="keywordtype">int</span> service,
<a name="l01402"></a>01402                <span class="keywordtype">unsigned</span> features, <span class="keywordtype">int</span> nbulkiov, <span class="keywordtype">int</span> bulklen,
<a name="l01403"></a>01403                <span class="keywordtype">void</span> (*done)(<a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *), <span class="keywordtype">void</span> *priv)
<a name="l01404"></a>01404 {
<a name="l01405"></a>01405         <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *rpc = NULL;
<a name="l01406"></a>01406 
<a name="l01407"></a>01407         spin_lock(&amp;sfw_data.fw_lock);
<a name="l01408"></a>01408 
<a name="l01409"></a>01409         LASSERT (!sfw_data.fw_shuttingdown);
<a name="l01410"></a>01410         LASSERT (service &lt;= SRPC_FRAMEWORK_SERVICE_MAX_ID);
<a name="l01411"></a>01411 
<a name="l01412"></a>01412         <span class="keywordflow">if</span> (nbulkiov == 0 &amp;&amp; !list_empty(&amp;sfw_data.fw_zombie_rpcs)) {
<a name="l01413"></a>01413                 rpc = list_entry(sfw_data.fw_zombie_rpcs.next,
<a name="l01414"></a>01414                                      <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a>, crpc_list);
<a name="l01415"></a>01415                 list_del(&amp;rpc-&gt;crpc_list);
<a name="l01416"></a>01416 
<a name="l01417"></a>01417                 srpc_init_client_rpc(rpc, peer, service, 0, 0,
<a name="l01418"></a>01418                                      done, sfw_client_rpc_fini, priv);
<a name="l01419"></a>01419         }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01422"></a>01422 
<a name="l01423"></a>01423         <span class="keywordflow">if</span> (rpc == NULL) {
<a name="l01424"></a>01424                 rpc = srpc_create_client_rpc(peer, service,
<a name="l01425"></a>01425                                              nbulkiov, bulklen, done,
<a name="l01426"></a>01426                                              nbulkiov != 0 ?  NULL :
<a name="l01427"></a>01427                                              sfw_client_rpc_fini,
<a name="l01428"></a>01428                                              priv);
<a name="l01429"></a>01429         }
<a name="l01430"></a>01430 
<a name="l01431"></a>01431         <span class="keywordflow">if</span> (rpc != NULL) <span class="comment">/* &quot;session&quot; is concept in framework */</span>
<a name="l01432"></a>01432                 rpc-&gt;crpc_reqstmsg.<a class="code" href="structsrpc__msg.html#a26415755866d1fb46d201e4d937db7fd" title="test session features">msg_ses_feats</a> = features;
<a name="l01433"></a>01433 
<a name="l01434"></a>01434         <span class="keywordflow">return</span> rpc;
<a name="l01435"></a>01435 }
<a name="l01436"></a>01436 
<a name="l01437"></a>01437 <span class="keywordtype">void</span>
<a name="l01438"></a>01438 sfw_unpack_message (<a class="code" href="structsrpc__msg.html">srpc_msg_t</a> *msg)
<a name="l01439"></a>01439 {
<a name="l01440"></a>01440         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a6e19bc3729ed00441eb74910836610ff" title="magic number">msg_magic</a> == SRPC_MSG_MAGIC)
<a name="l01441"></a>01441                 <span class="keywordflow">return</span>; <span class="comment">/* no flipping needed */</span>
<a name="l01442"></a>01442 
<a name="l01443"></a>01443         <span class="comment">/* srpc module should guarantee I wouldn&apos;t get crap */</span>
<a name="l01444"></a>01444         LASSERT (msg-&gt;<a class="code" href="structsrpc__msg.html#a6e19bc3729ed00441eb74910836610ff" title="magic number">msg_magic</a> == __swab32(SRPC_MSG_MAGIC));
<a name="l01445"></a>01445 
<a name="l01446"></a>01446         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_STAT_REQST) {
<a name="l01447"></a>01447                 srpc_stat_reqst_t *req = &amp;msg-&gt;msg_body.stat_reqst;
<a name="l01448"></a>01448 
<a name="l01449"></a>01449                 __swab32s(&amp;req-&gt;str_type);
<a name="l01450"></a>01450                 __swab64s(&amp;req-&gt;str_rpyid);
<a name="l01451"></a>01451                 sfw_unpack_sid(req-&gt;str_sid);
<a name="l01452"></a>01452                 <span class="keywordflow">return</span>;
<a name="l01453"></a>01453         }
<a name="l01454"></a>01454 
<a name="l01455"></a>01455         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_STAT_REPLY) {
<a name="l01456"></a>01456                 srpc_stat_reply_t *rep = &amp;msg-&gt;msg_body.stat_reply;
<a name="l01457"></a>01457 
<a name="l01458"></a>01458                 __swab32s(&amp;rep-&gt;str_status);
<a name="l01459"></a>01459                 sfw_unpack_sid(rep-&gt;str_sid);
<a name="l01460"></a>01460                 sfw_unpack_fw_counters(rep-&gt;str_fw);
<a name="l01461"></a>01461                 sfw_unpack_rpc_counters(rep-&gt;str_rpc);
<a name="l01462"></a>01462                 sfw_unpack_lnet_counters(rep-&gt;str_lnet);
<a name="l01463"></a>01463                 <span class="keywordflow">return</span>;
<a name="l01464"></a>01464         }
<a name="l01465"></a>01465 
<a name="l01466"></a>01466         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_MKSN_REQST) {
<a name="l01467"></a>01467                 srpc_mksn_reqst_t *req = &amp;msg-&gt;msg_body.mksn_reqst;
<a name="l01468"></a>01468 
<a name="l01469"></a>01469                 __swab64s(&amp;req-&gt;mksn_rpyid);
<a name="l01470"></a>01470                 __swab32s(&amp;req-&gt;mksn_force);
<a name="l01471"></a>01471                 sfw_unpack_sid(req-&gt;mksn_sid);
<a name="l01472"></a>01472                 <span class="keywordflow">return</span>;
<a name="l01473"></a>01473         }
<a name="l01474"></a>01474 
<a name="l01475"></a>01475         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_MKSN_REPLY) {
<a name="l01476"></a>01476                 srpc_mksn_reply_t *rep = &amp;msg-&gt;msg_body.mksn_reply;
<a name="l01477"></a>01477 
<a name="l01478"></a>01478                 __swab32s(&amp;rep-&gt;mksn_status);
<a name="l01479"></a>01479                 __swab32s(&amp;rep-&gt;mksn_timeout);
<a name="l01480"></a>01480                 sfw_unpack_sid(rep-&gt;mksn_sid);
<a name="l01481"></a>01481                 <span class="keywordflow">return</span>;
<a name="l01482"></a>01482         }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_RMSN_REQST) {
<a name="l01485"></a>01485                 srpc_rmsn_reqst_t *req = &amp;msg-&gt;msg_body.rmsn_reqst;
<a name="l01486"></a>01486 
<a name="l01487"></a>01487                 __swab64s(&amp;req-&gt;rmsn_rpyid);
<a name="l01488"></a>01488                 sfw_unpack_sid(req-&gt;rmsn_sid);
<a name="l01489"></a>01489                 <span class="keywordflow">return</span>;
<a name="l01490"></a>01490         }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_RMSN_REPLY) {
<a name="l01493"></a>01493                 srpc_rmsn_reply_t *rep = &amp;msg-&gt;msg_body.rmsn_reply;
<a name="l01494"></a>01494 
<a name="l01495"></a>01495                 __swab32s(&amp;rep-&gt;rmsn_status);
<a name="l01496"></a>01496                 sfw_unpack_sid(rep-&gt;rmsn_sid);
<a name="l01497"></a>01497                 <span class="keywordflow">return</span>;
<a name="l01498"></a>01498         }
<a name="l01499"></a>01499 
<a name="l01500"></a>01500         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_DEBUG_REQST) {
<a name="l01501"></a>01501                 srpc_debug_reqst_t *req = &amp;msg-&gt;msg_body.dbg_reqst;
<a name="l01502"></a>01502 
<a name="l01503"></a>01503                 __swab64s(&amp;req-&gt;dbg_rpyid);
<a name="l01504"></a>01504                 __swab32s(&amp;req-&gt;dbg_flags);
<a name="l01505"></a>01505                 sfw_unpack_sid(req-&gt;dbg_sid);
<a name="l01506"></a>01506                 <span class="keywordflow">return</span>;
<a name="l01507"></a>01507         }
<a name="l01508"></a>01508 
<a name="l01509"></a>01509         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_DEBUG_REPLY) {
<a name="l01510"></a>01510                 srpc_debug_reply_t *rep = &amp;msg-&gt;msg_body.dbg_reply;
<a name="l01511"></a>01511 
<a name="l01512"></a>01512                 __swab32s(&amp;rep-&gt;dbg_nbatch);
<a name="l01513"></a>01513                 __swab32s(&amp;rep-&gt;dbg_timeout);
<a name="l01514"></a>01514                 sfw_unpack_sid(rep-&gt;dbg_sid);
<a name="l01515"></a>01515                 <span class="keywordflow">return</span>;
<a name="l01516"></a>01516         }
<a name="l01517"></a>01517 
<a name="l01518"></a>01518         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_BATCH_REQST) {
<a name="l01519"></a>01519                 srpc_batch_reqst_t *req = &amp;msg-&gt;msg_body.bat_reqst;
<a name="l01520"></a>01520 
<a name="l01521"></a>01521                 __swab32s(&amp;req-&gt;bar_opc);
<a name="l01522"></a>01522                 __swab64s(&amp;req-&gt;bar_rpyid);
<a name="l01523"></a>01523                 __swab32s(&amp;req-&gt;bar_testidx);
<a name="l01524"></a>01524                 __swab32s(&amp;req-&gt;bar_arg);
<a name="l01525"></a>01525                 sfw_unpack_sid(req-&gt;bar_sid);
<a name="l01526"></a>01526                 __swab64s(&amp;req-&gt;bar_bid.bat_id);
<a name="l01527"></a>01527                 <span class="keywordflow">return</span>;
<a name="l01528"></a>01528         }
<a name="l01529"></a>01529 
<a name="l01530"></a>01530         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_BATCH_REPLY) {
<a name="l01531"></a>01531                 srpc_batch_reply_t *rep = &amp;msg-&gt;msg_body.bat_reply;
<a name="l01532"></a>01532 
<a name="l01533"></a>01533                 __swab32s(&amp;rep-&gt;bar_status);
<a name="l01534"></a>01534                 sfw_unpack_sid(rep-&gt;bar_sid);
<a name="l01535"></a>01535                 <span class="keywordflow">return</span>;
<a name="l01536"></a>01536         }
<a name="l01537"></a>01537 
<a name="l01538"></a>01538         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_TEST_REQST) {
<a name="l01539"></a>01539                 srpc_test_reqst_t *req = &amp;msg-&gt;msg_body.tes_reqst;
<a name="l01540"></a>01540 
<a name="l01541"></a>01541                 __swab64s(&amp;req-&gt;tsr_rpyid);
<a name="l01542"></a>01542                 __swab64s(&amp;req-&gt;tsr_bulkid);
<a name="l01543"></a>01543                 __swab32s(&amp;req-&gt;tsr_loop);
<a name="l01544"></a>01544                 __swab32s(&amp;req-&gt;tsr_ndest);
<a name="l01545"></a>01545                 __swab32s(&amp;req-&gt;tsr_concur);
<a name="l01546"></a>01546                 __swab32s(&amp;req-&gt;tsr_service);
<a name="l01547"></a>01547                 sfw_unpack_sid(req-&gt;tsr_sid);
<a name="l01548"></a>01548                 __swab64s(&amp;req-&gt;tsr_bid.bat_id);
<a name="l01549"></a>01549                 <span class="keywordflow">return</span>;
<a name="l01550"></a>01550         }
<a name="l01551"></a>01551 
<a name="l01552"></a>01552         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_TEST_REPLY) {
<a name="l01553"></a>01553                 srpc_test_reply_t *rep = &amp;msg-&gt;msg_body.tes_reply;
<a name="l01554"></a>01554 
<a name="l01555"></a>01555                 __swab32s(&amp;rep-&gt;tsr_status);
<a name="l01556"></a>01556                 sfw_unpack_sid(rep-&gt;tsr_sid);
<a name="l01557"></a>01557                 <span class="keywordflow">return</span>;
<a name="l01558"></a>01558         }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_JOIN_REQST) {
<a name="l01561"></a>01561                 srpc_join_reqst_t *req = &amp;msg-&gt;msg_body.join_reqst;
<a name="l01562"></a>01562 
<a name="l01563"></a>01563                 __swab64s(&amp;req-&gt;join_rpyid);
<a name="l01564"></a>01564                 sfw_unpack_sid(req-&gt;join_sid);
<a name="l01565"></a>01565                 <span class="keywordflow">return</span>;
<a name="l01566"></a>01566         }
<a name="l01567"></a>01567 
<a name="l01568"></a>01568         <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="structsrpc__msg.html#a671d12977af3f77ec638f20b383630b5" title="type of message body: srpc_msg_type_t">msg_type</a> == SRPC_MSG_JOIN_REPLY) {
<a name="l01569"></a>01569                 srpc_join_reply_t *rep = &amp;msg-&gt;msg_body.join_reply;
<a name="l01570"></a>01570 
<a name="l01571"></a>01571                 __swab32s(&amp;rep-&gt;join_status);
<a name="l01572"></a>01572                 __swab32s(&amp;rep-&gt;join_timeout);
<a name="l01573"></a>01573                 sfw_unpack_sid(rep-&gt;join_sid);
<a name="l01574"></a>01574                 <span class="keywordflow">return</span>;
<a name="l01575"></a>01575         }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577         LBUG ();
<a name="l01578"></a>01578         <span class="keywordflow">return</span>;
<a name="l01579"></a>01579 }
<a name="l01580"></a>01580 
<a name="l01581"></a>01581 <span class="keywordtype">void</span>
<a name="l01582"></a>01582 sfw_abort_rpc (<a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *rpc)
<a name="l01583"></a>01583 {
<a name="l01584"></a>01584         LASSERT(atomic_read(&amp;rpc-&gt;crpc_refcount) &gt; 0);
<a name="l01585"></a>01585         LASSERT(rpc-&gt;crpc_service &lt;= SRPC_FRAMEWORK_SERVICE_MAX_ID);
<a name="l01586"></a>01586 
<a name="l01587"></a>01587         spin_lock(&amp;rpc-&gt;crpc_lock);
<a name="l01588"></a>01588         srpc_abort_rpc(rpc, -EINTR);
<a name="l01589"></a>01589         spin_unlock(&amp;rpc-&gt;crpc_lock);
<a name="l01590"></a>01590         <span class="keywordflow">return</span>;
<a name="l01591"></a>01591 }
<a name="l01592"></a>01592 
<a name="l01593"></a>01593 <span class="keywordtype">void</span>
<a name="l01594"></a>01594 sfw_post_rpc (<a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *rpc)
<a name="l01595"></a>01595 {
<a name="l01596"></a>01596         spin_lock(&amp;rpc-&gt;crpc_lock);
<a name="l01597"></a>01597 
<a name="l01598"></a>01598         LASSERT(!rpc-&gt;crpc_closed);
<a name="l01599"></a>01599         LASSERT(!rpc-&gt;crpc_aborted);
<a name="l01600"></a>01600         LASSERT(list_empty(&amp;rpc-&gt;crpc_list));
<a name="l01601"></a>01601         LASSERT(!sfw_data.fw_shuttingdown);
<a name="l01602"></a>01602 
<a name="l01603"></a>01603         rpc-&gt;crpc_timeout = rpc_timeout;
<a name="l01604"></a>01604         srpc_post_rpc(rpc);
<a name="l01605"></a>01605 
<a name="l01606"></a>01606         spin_unlock(&amp;rpc-&gt;crpc_lock);
<a name="l01607"></a>01607         <span class="keywordflow">return</span>;
<a name="l01608"></a>01608 }
<a name="l01609"></a>01609 
<a name="l01610"></a>01610 <span class="keyword">static</span> <a class="code" href="structsrpc__service.html">srpc_service_t</a> sfw_services[] =
<a name="l01611"></a>01611 {
<a name="l01612"></a>01612         {
<a name="l01613"></a>01613                 <span class="comment">/* sv_id */</span>    SRPC_SERVICE_DEBUG,
<a name="l01614"></a>01614                 <span class="comment">/* sv_name */</span>  <span class="stringliteral">&quot;debug&quot;</span>,
<a name="l01615"></a>01615                 0
<a name="l01616"></a>01616         },
<a name="l01617"></a>01617         {
<a name="l01618"></a>01618                 <span class="comment">/* sv_id */</span>    SRPC_SERVICE_QUERY_STAT,
<a name="l01619"></a>01619                 <span class="comment">/* sv_name */</span>  <span class="stringliteral">&quot;query stats&quot;</span>,
<a name="l01620"></a>01620                 0
<a name="l01621"></a>01621         },
<a name="l01622"></a>01622         {
<a name="l01623"></a>01623                 <span class="comment">/* sv_id */</span>    SRPC_SERVICE_MAKE_SESSION,
<a name="l01624"></a>01624                 <span class="comment">/* sv_name */</span>  <span class="stringliteral">&quot;make session&quot;</span>,
<a name="l01625"></a>01625                 0
<a name="l01626"></a>01626         },
<a name="l01627"></a>01627         {
<a name="l01628"></a>01628                 <span class="comment">/* sv_id */</span>    SRPC_SERVICE_REMOVE_SESSION,
<a name="l01629"></a>01629                 <span class="comment">/* sv_name */</span>  <span class="stringliteral">&quot;remove session&quot;</span>,
<a name="l01630"></a>01630                 0
<a name="l01631"></a>01631         },
<a name="l01632"></a>01632         {
<a name="l01633"></a>01633                 <span class="comment">/* sv_id */</span>    SRPC_SERVICE_BATCH,
<a name="l01634"></a>01634                 <span class="comment">/* sv_name */</span>  <span class="stringliteral">&quot;batch service&quot;</span>,
<a name="l01635"></a>01635                 0
<a name="l01636"></a>01636         },
<a name="l01637"></a>01637         {
<a name="l01638"></a>01638                 <span class="comment">/* sv_id */</span>    SRPC_SERVICE_TEST,
<a name="l01639"></a>01639                 <span class="comment">/* sv_name */</span>  <span class="stringliteral">&quot;test service&quot;</span>,
<a name="l01640"></a>01640                 0
<a name="l01641"></a>01641         },
<a name="l01642"></a>01642         {
<a name="l01643"></a>01643                 <span class="comment">/* sv_id */</span>    0,
<a name="l01644"></a>01644                 <span class="comment">/* sv_name */</span>  NULL,
<a name="l01645"></a>01645                 0
<a name="l01646"></a>01646         }
<a name="l01647"></a>01647 };
<a name="l01648"></a>01648 
<a name="l01649"></a>01649 <span class="keywordtype">int</span>
<a name="l01650"></a>01650 sfw_startup (<span class="keywordtype">void</span>)
<a name="l01651"></a>01651 {
<a name="l01652"></a>01652         <span class="keywordtype">int</span>              i;
<a name="l01653"></a>01653         <span class="keywordtype">int</span>              rc;
<a name="l01654"></a>01654         <span class="keywordtype">int</span>              error;
<a name="l01655"></a>01655         <a class="code" href="structsrpc__service.html">srpc_service_t</a>  *sv;
<a name="l01656"></a>01656         <a class="code" href="structsfw__test__case.html">sfw_test_case_t</a> *tsc;
<a name="l01657"></a>01657 
<a name="l01658"></a>01658 
<a name="l01659"></a>01659         <span class="keywordflow">if</span> (session_timeout &lt; 0) {
<a name="l01660"></a>01660                 CERROR (<span class="stringliteral">&quot;Session timeout must be non-negative: %d\n&quot;</span>,
<a name="l01661"></a>01661                         session_timeout);
<a name="l01662"></a>01662                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01663"></a>01663         }
<a name="l01664"></a>01664 
<a name="l01665"></a>01665         <span class="keywordflow">if</span> (rpc_timeout &lt; 0) {
<a name="l01666"></a>01666                 CERROR (<span class="stringliteral">&quot;RPC timeout must be non-negative: %d\n&quot;</span>,
<a name="l01667"></a>01667                         rpc_timeout);
<a name="l01668"></a>01668                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01669"></a>01669         }
<a name="l01670"></a>01670 
<a name="l01671"></a>01671         <span class="keywordflow">if</span> (session_timeout == 0)
<a name="l01672"></a>01672                 CWARN (<span class="stringliteral">&quot;Zero session_timeout specified &quot;</span>
<a name="l01673"></a>01673                        <span class="stringliteral">&quot;- test sessions never expire.\n&quot;</span>);
<a name="l01674"></a>01674 
<a name="l01675"></a>01675         <span class="keywordflow">if</span> (rpc_timeout == 0)
<a name="l01676"></a>01676                 CWARN (<span class="stringliteral">&quot;Zero rpc_timeout specified &quot;</span>
<a name="l01677"></a>01677                        <span class="stringliteral">&quot;- test RPC never expire.\n&quot;</span>);
<a name="l01678"></a>01678 
<a name="l01679"></a>01679         memset(&amp;sfw_data, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> smoketest_framework));
<a name="l01680"></a>01680 
<a name="l01681"></a>01681         sfw_data.fw_session     = NULL;
<a name="l01682"></a>01682         sfw_data.fw_active_srpc = NULL;
<a name="l01683"></a>01683         spin_lock_init(&amp;sfw_data.fw_lock);
<a name="l01684"></a>01684         atomic_set(&amp;sfw_data.fw_nzombies, 0);
<a name="l01685"></a>01685         INIT_LIST_HEAD(&amp;sfw_data.fw_tests);
<a name="l01686"></a>01686         INIT_LIST_HEAD(&amp;sfw_data.fw_zombie_rpcs);
<a name="l01687"></a>01687         INIT_LIST_HEAD(&amp;sfw_data.fw_zombie_sessions);
<a name="l01688"></a>01688 
<a name="l01689"></a>01689         brw_init_test_client();
<a name="l01690"></a>01690         brw_init_test_service();
<a name="l01691"></a>01691         rc = sfw_register_test(&amp;brw_test_service, &amp;brw_test_client);
<a name="l01692"></a>01692         LASSERT (rc == 0);
<a name="l01693"></a>01693 
<a name="l01694"></a>01694         ping_init_test_client();
<a name="l01695"></a>01695         ping_init_test_service();
<a name="l01696"></a>01696         rc = sfw_register_test(&amp;ping_test_service, &amp;ping_test_client);
<a name="l01697"></a>01697         LASSERT (rc == 0);
<a name="l01698"></a>01698 
<a name="l01699"></a>01699         error = 0;
<a name="l01700"></a>01700         list_for_each_entry(tsc, &amp;sfw_data.fw_tests, tsc_list) {
<a name="l01701"></a>01701                 sv = tsc-&gt;tsc_srv_service;
<a name="l01702"></a>01702 
<a name="l01703"></a>01703                 rc = srpc_add_service(sv);
<a name="l01704"></a>01704                 LASSERT(rc != -EBUSY);
<a name="l01705"></a>01705                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01706"></a>01706                         CWARN(<span class="stringliteral">&quot;Failed to add %s service: %d\n&quot;</span>,
<a name="l01707"></a>01707                               sv-&gt;sv_name, rc);
<a name="l01708"></a>01708                         error = rc;
<a name="l01709"></a>01709                 }
<a name="l01710"></a>01710         }
<a name="l01711"></a>01711 
<a name="l01712"></a>01712         <span class="keywordflow">for</span> (i = 0; ; i++) {
<a name="l01713"></a>01713                 sv = &amp;sfw_services[i];
<a name="l01714"></a>01714                 <span class="keywordflow">if</span> (sv-&gt;sv_name == NULL) <span class="keywordflow">break</span>;
<a name="l01715"></a>01715 
<a name="l01716"></a>01716                 sv-&gt;sv_bulk_ready = NULL;
<a name="l01717"></a>01717                 sv-&gt;sv_handler    = sfw_handle_server_rpc;
<a name="l01718"></a>01718                 sv-&gt;sv_wi_total   = SFW_FRWK_WI_MAX;
<a name="l01719"></a>01719                 <span class="keywordflow">if</span> (sv-&gt;sv_id == SRPC_SERVICE_TEST)
<a name="l01720"></a>01720                         sv-&gt;sv_bulk_ready = sfw_bulk_ready;
<a name="l01721"></a>01721 
<a name="l01722"></a>01722                 rc = srpc_add_service(sv);
<a name="l01723"></a>01723                 LASSERT (rc != -EBUSY);
<a name="l01724"></a>01724                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01725"></a>01725                         CWARN (<span class="stringliteral">&quot;Failed to add %s service: %d\n&quot;</span>,
<a name="l01726"></a>01726                                sv-&gt;sv_name, rc);
<a name="l01727"></a>01727                         error = rc;
<a name="l01728"></a>01728                 }
<a name="l01729"></a>01729 
<a name="l01730"></a>01730                 <span class="comment">/* about to sfw_shutdown, no need to add buffer */</span>
<a name="l01731"></a>01731                 <span class="keywordflow">if</span> (error) <span class="keywordflow">continue</span>;
<a name="l01732"></a>01732 
<a name="l01733"></a>01733                 rc = srpc_service_add_buffers(sv, sv-&gt;sv_wi_total);
<a name="l01734"></a>01734                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01735"></a>01735                         CWARN(<span class="stringliteral">&quot;Failed to reserve enough buffers: &quot;</span>
<a name="l01736"></a>01736                               <span class="stringliteral">&quot;service %s, %d needed: %d\n&quot;</span>,
<a name="l01737"></a>01737                               sv-&gt;sv_name, sv-&gt;sv_wi_total, rc);
<a name="l01738"></a>01738                         error = -ENOMEM;
<a name="l01739"></a>01739                 }
<a name="l01740"></a>01740         }
<a name="l01741"></a>01741 
<a name="l01742"></a>01742         <span class="keywordflow">if</span> (error != 0)
<a name="l01743"></a>01743                 sfw_shutdown();
<a name="l01744"></a>01744         <span class="keywordflow">return</span> error;
<a name="l01745"></a>01745 }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747 <span class="keywordtype">void</span>
<a name="l01748"></a>01748 sfw_shutdown (<span class="keywordtype">void</span>)
<a name="l01749"></a>01749 {
<a name="l01750"></a>01750         <a class="code" href="structsrpc__service.html">srpc_service_t</a>  *sv;
<a name="l01751"></a>01751         <a class="code" href="structsfw__test__case.html">sfw_test_case_t</a> *tsc;
<a name="l01752"></a>01752         <span class="keywordtype">int</span>              i;
<a name="l01753"></a>01753 
<a name="l01754"></a>01754         spin_lock(&amp;sfw_data.fw_lock);
<a name="l01755"></a>01755 
<a name="l01756"></a>01756         sfw_data.fw_shuttingdown = 1;
<a name="l01757"></a>01757         lst_wait_until(sfw_data.fw_active_srpc == NULL, sfw_data.fw_lock,
<a name="l01758"></a>01758                        <span class="stringliteral">&quot;waiting for active RPC to finish.\n&quot;</span>);
<a name="l01759"></a>01759 
<a name="l01760"></a>01760         <span class="keywordflow">if</span> (sfw_del_session_timer() != 0)
<a name="l01761"></a>01761                 lst_wait_until(sfw_data.fw_session == NULL, sfw_data.fw_lock,
<a name="l01762"></a>01762                                <span class="stringliteral">&quot;waiting for session timer to explode.\n&quot;</span>);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764         sfw_deactivate_session();
<a name="l01765"></a>01765         lst_wait_until(atomic_read(&amp;sfw_data.fw_nzombies) == 0,
<a name="l01766"></a>01766                        sfw_data.fw_lock,
<a name="l01767"></a>01767                        <span class="stringliteral">&quot;waiting for %d zombie sessions to die.\n&quot;</span>,
<a name="l01768"></a>01768                        atomic_read(&amp;sfw_data.fw_nzombies));
<a name="l01769"></a>01769 
<a name="l01770"></a>01770         spin_unlock(&amp;sfw_data.fw_lock);
<a name="l01771"></a>01771 
<a name="l01772"></a>01772         <span class="keywordflow">for</span> (i = 0; ; i++) {
<a name="l01773"></a>01773                 sv = &amp;sfw_services[i];
<a name="l01774"></a>01774                 <span class="keywordflow">if</span> (sv-&gt;sv_name == NULL)
<a name="l01775"></a>01775                         <span class="keywordflow">break</span>;
<a name="l01776"></a>01776 
<a name="l01777"></a>01777                 srpc_shutdown_service(sv);
<a name="l01778"></a>01778                 srpc_remove_service(sv);
<a name="l01779"></a>01779         }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781         list_for_each_entry(tsc, &amp;sfw_data.fw_tests, tsc_list) {
<a name="l01782"></a>01782                 sv = tsc-&gt;tsc_srv_service;
<a name="l01783"></a>01783                 srpc_shutdown_service(sv);
<a name="l01784"></a>01784                 srpc_remove_service(sv);
<a name="l01785"></a>01785         }
<a name="l01786"></a>01786 
<a name="l01787"></a>01787         <span class="keywordflow">while</span> (!list_empty(&amp;sfw_data.fw_zombie_rpcs)) {
<a name="l01788"></a>01788                 <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a> *rpc;
<a name="l01789"></a>01789 
<a name="l01790"></a>01790                 rpc = list_entry(sfw_data.fw_zombie_rpcs.next,
<a name="l01791"></a>01791                                  <a class="code" href="structsrpc__client__rpc.html">srpc_client_rpc_t</a>, crpc_list);
<a name="l01792"></a>01792                 list_del(&amp;rpc-&gt;crpc_list);
<a name="l01793"></a>01793 
<a name="l01794"></a>01794                 LIBCFS_FREE(rpc, srpc_client_rpc_size(rpc));
<a name="l01795"></a>01795         }
<a name="l01796"></a>01796 
<a name="l01797"></a>01797         <span class="keywordflow">for</span> (i = 0; ; i++) {
<a name="l01798"></a>01798                 sv = &amp;sfw_services[i];
<a name="l01799"></a>01799                 <span class="keywordflow">if</span> (sv-&gt;sv_name == NULL)
<a name="l01800"></a>01800                         <span class="keywordflow">break</span>;
<a name="l01801"></a>01801 
<a name="l01802"></a>01802                 srpc_wait_service_shutdown(sv);
<a name="l01803"></a>01803         }
<a name="l01804"></a>01804 
<a name="l01805"></a>01805         <span class="keywordflow">while</span> (!list_empty(&amp;sfw_data.fw_tests)) {
<a name="l01806"></a>01806                 tsc = list_entry(sfw_data.fw_tests.next,
<a name="l01807"></a>01807                                  <a class="code" href="structsfw__test__case.html">sfw_test_case_t</a>, tsc_list);
<a name="l01808"></a>01808 
<a name="l01809"></a>01809                 srpc_wait_service_shutdown(tsc-&gt;tsc_srv_service);
<a name="l01810"></a>01810 
<a name="l01811"></a>01811                 list_del(&amp;tsc-&gt;tsc_list);
<a name="l01812"></a>01812                 LIBCFS_FREE(tsc, <span class="keyword">sizeof</span>(*tsc));
<a name="l01813"></a>01813         }
<a name="l01814"></a>01814 
<a name="l01815"></a>01815         <span class="keywordflow">return</span>;
<a name="l01816"></a>01816 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:12 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
