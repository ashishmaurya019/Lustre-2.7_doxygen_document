<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: osc</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>osc</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__io.html">osc_io</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State maintained by osc layer for each IO context.  <a href="structosc__io.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__session.html">osc_session</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State maintained by osc layer for the duration of a system call.  <a href="structosc__session.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__thread__info.html">osc_thread_info</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__object.html">osc_object</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html">osc_lock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">osc-private state of <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>.  <a href="structosc__lock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__page.html">osc_page</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Page state private for osc layer.  <a href="structosc__page.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__extent.html">osc_extent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a> data to manage dirty pages.  <a href="structosc__extent.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1657b98d6a7972886535b57344778282"></a><!-- doxytag: member="osc::EXTSTR" ref="ga1657b98d6a7972886535b57344778282" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EXTSTR</b>&nbsp;&nbsp;&nbsp;&quot;[%lu -&gt; %lu/%lu]&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab11189dcb9f88aed51615d8f5a706828"></a><!-- doxytag: member="osc::EXTPARA" ref="gab11189dcb9f88aed51615d8f5a706828" args="(ext)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EXTPARA</b>(ext)&nbsp;&nbsp;&nbsp;(ext)-&gt;oe_start, (ext)-&gt;oe_end, (ext)-&gt;oe_max_end</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSC_EXTENT_DUMP</b>(lvl, extent, fmt,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EASSERTF</b>(expr, ext, fmt, args...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga546d404bb6139588eb80ad91b5066c65"></a><!-- doxytag: member="osc::EASSERT" ref="ga546d404bb6139588eb80ad91b5066c65" args="(expr, ext)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EASSERT</b>(expr, ext)&nbsp;&nbsp;&nbsp;EASSERTF(expr, ext, &quot;\n&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga12967e90fecbca17fd2506b51fb8293d"></a><!-- doxytag: member="osc::sanity_check_nolock" ref="ga12967e90fecbca17fd2506b51fb8293d" args="(ext)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>sanity_check_nolock</b>(ext)&nbsp;&nbsp;&nbsp;osc_extent_sanity_check0(ext, __func__, __LINE__)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>sanity_check</b>(ext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSC_IO_DEBUG</b>(OSC, STR, args...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSC_DUMP_GRANT</b>(lvl, cli, fmt, args...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>list_to_obj</b>(list, item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1060effa512bff483d71c38a0db5dda2"></a><!-- doxytag: member="osc::OTI_PVEC_SIZE" ref="ga1060effa512bff483d71c38a0db5dda2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OTI_PVEC_SIZE</b>&nbsp;&nbsp;&nbsp;256</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga082e56b9502ea5417d9b5d53f8f84bcb"></a><!-- doxytag: member="osc::OSC_FLAGS" ref="ga082e56b9502ea5417d9b5d53f8f84bcb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSC_FLAGS</b>&nbsp;&nbsp;&nbsp;(ASYNC_URGENT|ASYNC_READY)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga46b4a8ffae8b7ea1e45fd7884069fc34"></a><!-- doxytag: member="osc::osc_page_gang_cbt" ref="ga46b4a8ffae8b7ea1e45fd7884069fc34" args=")(const struct lu_env *, struct cl_io *, struct osc_page *, void *)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_page_gang_cbt</b> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *, struct <a class="el" href="structcl__io.html">cl_io</a> *, struct <a class="el" href="structosc__page.html">osc_page</a> *, void *)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_lock_state</b> { <br/>
&nbsp;&nbsp;<b>OLS_NEW</b>, 
<b>OLS_ENQUEUED</b>, 
<b>OLS_UPCALL_RECEIVED</b>, 
<b>OLS_GRANTED</b>, 
<br/>
&nbsp;&nbsp;<b>OLS_CANCELLED</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga6186b8ce09edf79ddb470068d980fa3d">osc_extent_state</a> { <br/>
&nbsp;&nbsp;<b>OES_INV</b> =  0, 
<a class="el" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da57a171603bdbe9ce372e2c23f1b4fcb5">OES_ACTIVE</a> =  1, 
<a class="el" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da5fa3ea0f8426b29ae208cb22e435cf77">OES_CACHE</a> =  2, 
<a class="el" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da7558231f4c40076af91adcb4f605e3a3">OES_LOCKING</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da0cfb17d1d0abe58ee5a6e210ecd3b685">OES_LOCK_DONE</a> =  4, 
<a class="el" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da7ed8d9d8557c8185d7cd464ca6916303">OES_RPC</a> =  5, 
<a class="el" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3daeac60d8c4aeeae580c118b4f08ea961c">OES_TRUNC</a> =  6, 
<a class="el" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3dac862e82e76aa4803851aca25ad9fc532">OES_STATE_MAX</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06e75737c5c000e1e1b65419a81aef2e"></a><!-- doxytag: member="osc::osc_extent_release" ref="ga06e75737c5c000e1e1b65419a81aef2e" args="(const struct lu_env *env, struct osc_extent *ext)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga06e75737c5c000e1e1b65419a81aef2e">osc_extent_release</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__extent.html">osc_extent</a> *ext)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop user count of <a class="el" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a>, and unplug IO asynchronously. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf6b8a4d60ebeba7a3b97618165e566b3"></a><!-- doxytag: member="osc::osc_extent_finish" ref="gaf6b8a4d60ebeba7a3b97618165e566b3" args="(const struct lu_env *env, struct osc_extent *ext, int sent, int rc)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaf6b8a4d60ebeba7a3b97618165e566b3">osc_extent_finish</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__extent.html">osc_extent</a> *ext, int sent, int rc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when IO is finished to an extent. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6d219e813ad848aa526b59c3c304f025"></a><!-- doxytag: member="osc::osc_wake_cache_waiters" ref="ga6d219e813ad848aa526b59c3c304f025" args="(struct client_obd *cli)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_wake_cache_waiters</b> (struct <a class="el" href="structclient__obd.html">client_obd</a> *cli)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1f9e06867823247b9cf968ba80a9bb3"></a><!-- doxytag: member="osc::osc_io_unplug" ref="gab1f9e06867823247b9cf968ba80a9bb3" args="(const struct lu_env *env, struct client_obd *cli, struct osc_object *osc)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_io_unplug</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structclient__obd.html">client_obd</a> *cli, struct <a class="el" href="structosc__object.html">osc_object</a> *osc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad7357c1e41d1c62baf4fb61d51c2de71"></a><!-- doxytag: member="osc::osc_prep_async_page" ref="gad7357c1e41d1c62baf4fb61d51c2de71" args="(struct osc_object *osc, struct osc_page *ops, struct page *page, loff_t offset)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_prep_async_page</b> (struct <a class="el" href="structosc__object.html">osc_object</a> *osc, struct <a class="el" href="structosc__page.html">osc_page</a> *ops, struct page *page, loff_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5ccfa774e02b3b82a4ef0ae1d9bc936"></a><!-- doxytag: member="osc::osc_queue_async_io" ref="gaa5ccfa774e02b3b82a4ef0ae1d9bc936" args="(const struct lu_env *env, struct cl_io *io, struct osc_page *ops)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_queue_async_io</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structosc__page.html">osc_page</a> *ops)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ea34d6cb6b65bbd9ed9e7322b5589cd"></a><!-- doxytag: member="osc::osc_teardown_async_page" ref="ga6ea34d6cb6b65bbd9ed9e7322b5589cd" args="(const struct lu_env *env, struct osc_object *obj, struct osc_page *ops)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_teardown_async_page</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *obj, struct <a class="el" href="structosc__page.html">osc_page</a> *ops)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gacbca1d2858196fd14f5de2a27cb7c857">osc_flush_async_page</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structosc__page.html">osc_page</a> *ops)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called when a page is picked up by kernel to write out.  <a href="#gacbca1d2858196fd14f5de2a27cb7c857"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gad22b15d739092f8a8d27214eff304e66">osc_cancel_async_page</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__page.html">osc_page</a> *ops)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is called when a sync waiter receives an interruption.  <a href="#gad22b15d739092f8a8d27214eff304e66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac7b21c4ee69191fe5fe48df729410912"></a><!-- doxytag: member="osc::osc_queue_sync_pages" ref="gac7b21c4ee69191fe5fe48df729410912" args="(const struct lu_env *env, struct osc_object *obj, struct list_head *list, int cmd, int brw_flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_queue_sync_pages</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *obj, struct <a class="el" href="structlist__head.html">list_head</a> *list, int cmd, int brw_flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50a5681d5c52a69e84bb265c202f3ecf"></a><!-- doxytag: member="osc::osc_cache_truncate_start" ref="ga50a5681d5c52a69e84bb265c202f3ecf" args="(const struct lu_env *env, struct osc_object *obj, __u64 size, struct osc_extent **extp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga50a5681d5c52a69e84bb265c202f3ecf">osc_cache_truncate_start</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *obj, __u64 size, struct <a class="el" href="structosc__extent.html">osc_extent</a> **extp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by osc_io_setattr_start() to freeze and destroy covering extents. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5d8bb46841ff73ab14ca09abac5d767c"></a><!-- doxytag: member="osc::osc_cache_truncate_end" ref="ga5d8bb46841ff73ab14ca09abac5d767c" args="(const struct lu_env *env, struct osc_extent *ext)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga5d8bb46841ff73ab14ca09abac5d767c">osc_cache_truncate_end</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__extent.html">osc_extent</a> *ext)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called after osc_io_setattr_end to add oio-&gt;oi_trunc back to cache. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga4c709e4df4c17373354b20238e863f2a">osc_cache_wait_range</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *obj, pgoff_t start, pgoff_t end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for extents in a specific range to be written out.  <a href="#ga4c709e4df4c17373354b20238e863f2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga91e31015ca9c3df0750e008ebd5831cf">osc_cache_writeback_range</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *obj, pgoff_t start, pgoff_t end, int hp, int discard)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to write out a range of osc object.  <a href="#ga91e31015ca9c3df0750e008ebd5831cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga4ac00d525c8750fbccb312796dfb0542">osc_page_gang_lookup</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__io.html">cl_io</a> *io, struct <a class="el" href="structosc__object.html">osc_object</a> *osc, pgoff_t start, pgoff_t end, osc_page_gang_cbt cb, void *cbdata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of pages by a given [start, end] of <em>obj</em>.  <a href="#ga4ac00d525c8750fbccb312796dfb0542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gad86265cc2892261e7634f0d9a2050a6b">osc_lock_discard_pages</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *osc, pgoff_t start, pgoff_t end, enum <a class="el" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1">cl_lock_mode</a> mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discard pages protected by the given lock.  <a href="#gad86265cc2892261e7634f0d9a2050a6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabd5ab860e2021ff6b4cd161a7392744a"></a><!-- doxytag: member="osc::osc_lock_init" ref="gabd5ab860e2021ff6b4cd161a7392744a" args="(const struct lu_env *env, struct cl_object *obj, struct cl_lock *lock, const struct cl_io *io)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_lock_init</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__lock.html">cl_lock</a> *lock, const struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga718b431e8195226a8bd635c9b0c3ed83"></a><!-- doxytag: member="osc::osc_io_init" ref="ga718b431e8195226a8bd635c9b0c3ed83" args="(const struct lu_env *env, struct cl_object *obj, struct cl_io *io)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_io_init</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad941e20e17432e49a26fb19daf01d110"></a><!-- doxytag: member="osc::osc_object_alloc" ref="gad941e20e17432e49a26fb19daf01d110" args="(const struct lu_env *env, const struct lu_object_header *hdr, struct lu_device *dev)" -->
struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_object_alloc</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *hdr, struct <a class="el" href="structlu__device.html">lu_device</a> *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga633c62b020126f225e1b0df1dc284251"></a><!-- doxytag: member="osc::osc_page_init" ref="ga633c62b020126f225e1b0df1dc284251" args="(const struct lu_env *env, struct cl_object *obj, struct cl_page *page, pgoff_t ind)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_page_init</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__object.html">cl_object</a> *obj, struct <a class="el" href="structcl__page.html">cl_page</a> *page, pgoff_t ind)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5023e2c6d3427c41c4f8002c8845bcfe"></a><!-- doxytag: member="osc::osc_index2policy" ref="ga5023e2c6d3427c41c4f8002c8845bcfe" args="(union ldlm_policy_data *policy, const struct cl_object *obj, pgoff_t start, pgoff_t end)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_index2policy</b> (union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy, const struct <a class="el" href="structcl__object.html">cl_object</a> *obj, pgoff_t start, pgoff_t end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6aa1f3c3c89042ae19f13680ff68cf89"></a><!-- doxytag: member="osc::osc_lvb_print" ref="ga6aa1f3c3c89042ae19f13680ff68cf89" args="(const struct lu_env *env, void *cookie, lu_printer_t p, const struct ost_lvb *lvb)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_lvb_print</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> p, const struct <a class="el" href="structost__lvb.html">ost_lvb</a> *lvb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0665f963a72ace52377c0d51df2b2319"></a><!-- doxytag: member="osc::osc_lru_add_batch" ref="ga0665f963a72ace52377c0d51df2b2319" args="(struct client_obd *cli, struct list_head *list)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_lru_add_batch</b> (struct <a class="el" href="structclient__obd.html">client_obd</a> *cli, struct <a class="el" href="structlist__head.html">list_head</a> *list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae4802860d91daed5d098a08f4ed45dea"></a><!-- doxytag: member="osc::osc_page_submit" ref="gae4802860d91daed5d098a08f4ed45dea" args="(const struct lu_env *env, struct osc_page *opg, enum cl_req_type crt, int brw_flags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gae4802860d91daed5d098a08f4ed45dea">osc_page_submit</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__page.html">osc_page</a> *opg, enum <a class="el" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02">cl_req_type</a> crt, int brw_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function called by osc_io_submit() for every page in an immediate transfer (i.e., transferred synchronously). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeeebabba4671768419987298a91f77a2"></a><!-- doxytag: member="osc::osc_set_async_flags" ref="gaeeebabba4671768419987298a91f77a2" args="(struct osc_object *obj, struct osc_page *opg, u32 async_flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_set_async_flags</b> (struct <a class="el" href="structosc__object.html">osc_object</a> *obj, struct <a class="el" href="structosc__page.html">osc_page</a> *opg, u32 async_flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga191a56f071d6752db73aed4510a49639"></a><!-- doxytag: member="osc::osc_page_cache_add" ref="ga191a56f071d6752db73aed4510a49639" args="(const struct lu_env *env, const struct cl_page_slice *slice, struct cl_io *io)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_page_cache_add</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *io)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab2c0eac927bf007a05676854f0f440fe"></a><!-- doxytag: member="osc::lru_queue_work" ref="gab2c0eac927bf007a05676854f0f440fe" args="(const struct lu_env *env, void *data)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lru_queue_work</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga898abac02468e34cf3cc62075837b421"></a><!-- doxytag: member="osc::osc_object_set_contended" ref="ga898abac02468e34cf3cc62075837b421" args="(struct osc_object *obj)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_object_set_contended</b> (struct <a class="el" href="structosc__object.html">osc_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e489947271b7ff2af03b3686f2c0deb"></a><!-- doxytag: member="osc::osc_object_clear_contended" ref="ga6e489947271b7ff2af03b3686f2c0deb" args="(struct osc_object *obj)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_object_clear_contended</b> (struct <a class="el" href="structosc__object.html">osc_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2bf0d492fc8978c34d62dc408ead87d"></a><!-- doxytag: member="osc::osc_object_is_contended" ref="gac2bf0d492fc8978c34d62dc408ead87d" args="(struct osc_object *obj)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_object_is_contended</b> (struct <a class="el" href="structosc__object.html">osc_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa565e6849b165c1b13f243a672677c99"></a><!-- doxytag: member="osc::osc_lock_is_lockless" ref="gaa565e6849b165c1b13f243a672677c99" args="(const struct osc_lock *olck)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_lock_is_lockless</b> (const struct <a class="el" href="structosc__lock.html">osc_lock</a> *olck)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7375f630804fd120775f5d2d67470740"></a><!-- doxytag: member="osc::LU_TYPE_INIT_FINI" ref="ga7375f630804fd120775f5d2d67470740" args="(osc,&amp;osc_key,&amp;osc_session_key)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_TYPE_INIT_FINI</b> (osc,&amp;osc_key,&amp;osc_session_key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35e11197afdf291ad1614fe6217d4108"></a><!-- doxytag: member="osc::osc_ldlm_weigh_ast" ref="ga35e11197afdf291ad1614fe6217d4108" args="(struct ldlm_lock *dlmlock)" -->
unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga35e11197afdf291ad1614fe6217d4108">osc_ldlm_weigh_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *dlmlock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the weight of dlm lock for early cancellation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8977a8e1e24c419f01c5a96f6fbf65a2"></a><!-- doxytag: member="osc::osc_dlmlock_at_pgoff" ref="ga8977a8e1e24c419f01c5a96f6fbf65a2" args="(const struct lu_env *env, struct osc_object *obj, pgoff_t index, enum osc_dap_flags dap_flags)" -->
struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga8977a8e1e24c419f01c5a96f6fbf65a2">osc_dlmlock_at_pgoff</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *obj, pgoff_t index, enum osc_dap_flags dap_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds an existing lock covering given index and optionally different from a given <em>except</em> lock. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6fff2cb3d86d8a7b0206286da8bbfc6b"></a><!-- doxytag: member="osc::osc_object_invalidate" ref="ga6fff2cb3d86d8a7b0206286da8bbfc6b" args="(const struct lu_env *env, struct osc_object *osc)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_object_invalidate</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structosc__object.html">osc_object</a> *osc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacad2bab69d5c52c6248c0b76fcf1e93a"></a><!-- doxytag: member="osc::osc_lru_shrink" ref="gacad2bab69d5c52c6248c0b76fcf1e93a" args="(const struct lu_env *env, struct client_obd *cli, long target, bool force)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a">osc_lru_shrink</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structclient__obd.html">client_obd</a> *cli, long target, bool force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop  of pages from LRU at most. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga6739eb4d14ea9d44005f4e5131ba8ade">osc_lru_reserve</a> (struct <a class="el" href="structclient__obd.html">client_obd</a> *cli, unsigned long npages)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__osc.html#ga6739eb4d14ea9d44005f4e5131ba8ade" title="osc_lru_reserve() is called to reserve enough LRU slots for I/O.">osc_lru_reserve()</a> is called to reserve enough LRU slots for I/O.  <a href="#ga6739eb4d14ea9d44005f4e5131ba8ade"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaacf75a0c2b6ddc3e431b00b684de8eed">osc_lru_unreserve</a> (struct <a class="el" href="structclient__obd.html">client_obd</a> *cli, unsigned long npages)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__osc.html#gaacf75a0c2b6ddc3e431b00b684de8eed" title="osc_lru_unreserve() is called to unreserve LRU slots.">osc_lru_unreserve()</a> is called to unreserve LRU slots.  <a href="#gaacf75a0c2b6ddc3e431b00b684de8eed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga06cb0f9449c99e3cec373a61af41929a">osc_dec_unstable_pages</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs "unstable" page accounting.  <a href="#ga06cb0f9449c99e3cec373a61af41929a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaba135e313f6a93ebb5d5cc3a823116c4">osc_inc_unstable_pages</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"unstable" page accounting.  <a href="#gaba135e313f6a93ebb5d5cc3a823116c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaa2bc86b38907996c03e4debb5953688b">osc_over_unstable_soft_limit</a> (struct <a class="el" href="structclient__obd.html">client_obd</a> *cli)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if it piggybacks SOFT_SYNC flag to OST from this OSC.  <a href="#gaa2bc86b38907996c03e4debb5953688b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#gaec0dd919ecdfdb232dca4819b15617c5">osc_cache_shrink_count</a> (struct shrinker *sk, struct <a class="el" href="structshrink__control.html">shrink_control</a> *sc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return how many LRU pages in the cache of all OSC devices.  <a href="#gaec0dd919ecdfdb232dca4819b15617c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osc.html#ga084c788be8d116db87ebdd3c273d9a23">osc_cache_shrink_scan</a> (struct shrinker *sk, struct <a class="el" href="structshrink__control.html">shrink_control</a> *sc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan and try to reclaim sc-&gt;nr_to_scan cached LRU pages.  <a href="#ga084c788be8d116db87ebdd3c273d9a23"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab64712a972a010e480fe937ff1382a55"></a><!-- doxytag: member="osc::osc_lock_kmem" ref="gab64712a972a010e480fe937ff1382a55" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_lock_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3eb040878c1bcbe41439a52e81ac568c"></a><!-- doxytag: member="osc::osc_object_kmem" ref="ga3eb040878c1bcbe41439a52e81ac568c" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_object_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ba94effca81566bb47feac75c05f552"></a><!-- doxytag: member="osc::osc_thread_kmem" ref="ga0ba94effca81566bb47feac75c05f552" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_thread_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7e9be433a17470fa98b0ef4f3c7df031"></a><!-- doxytag: member="osc::osc_session_kmem" ref="ga7e9be433a17470fa98b0ef4f3c7df031" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_session_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaecbde970d2c1b138493f82a192098c84"></a><!-- doxytag: member="osc::osc_extent_kmem" ref="gaecbde970d2c1b138493f82a192098c84" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_extent_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga40d14c8c546010ba5c116bc0ee4fa598"></a><!-- doxytag: member="osc::osc_device_type" ref="ga40d14c8c546010ba5c116bc0ee4fa598" args="" -->
struct <a class="el" href="structlu__device__type.html">lu_device_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_device_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadaf1b8cc09a172dcf2739a03e5b0fa44"></a><!-- doxytag: member="osc::osc_key" ref="gadaf1b8cc09a172dcf2739a03e5b0fa44" args="" -->
struct <a class="el" href="structlu__context__key.html">lu_context_key</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_key</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2fdc1e11d4fac80fc5f4ea7daac25f5b"></a><!-- doxytag: member="osc::osc_session_key" ref="ga2fdc1e11d4fac80fc5f4ea7daac25f5b" args="" -->
struct <a class="el" href="structlu__context__key.html">lu_context_key</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_session_key</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab64712a972a010e480fe937ff1382a55"></a><!-- doxytag: member="osc::osc_lock_kmem" ref="gab64712a972a010e480fe937ff1382a55" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_lock_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3eb040878c1bcbe41439a52e81ac568c"></a><!-- doxytag: member="osc::osc_object_kmem" ref="ga3eb040878c1bcbe41439a52e81ac568c" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_object_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ba94effca81566bb47feac75c05f552"></a><!-- doxytag: member="osc::osc_thread_kmem" ref="ga0ba94effca81566bb47feac75c05f552" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_thread_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7e9be433a17470fa98b0ef4f3c7df031"></a><!-- doxytag: member="osc::osc_session_kmem" ref="ga7e9be433a17470fa98b0ef4f3c7df031" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_session_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaecbde970d2c1b138493f82a192098c84"></a><!-- doxytag: member="osc::osc_extent_kmem" ref="gaecbde970d2c1b138493f82a192098c84" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_extent_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70b280b4f8aa627b91e8b1ba485c9e6c"></a><!-- doxytag: member="osc::osc_quota_kmem" ref="ga70b280b4f8aa627b91e8b1ba485c9e6c" args="" -->
struct kmem_cache *&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_quota_kmem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac38b7ef212655bdc25df953d7917a0dc"></a><!-- doxytag: member="osc::osc_caches" ref="gac38b7ef212655bdc25df953d7917a0dc" args="[]" -->
struct <a class="el" href="structlu__kmem__descr.html">lu_kmem_descr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_caches</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__context__key.html">lu_context_key</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_key</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__context__key.html">lu_context_key</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_session_key</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__device__type.html">lu_device_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>osc_device_type</b></td></tr>
</table>


<h3><a class="anchor" id="is">covered by an extra lock or discard it.</a></h3><p>Check if page </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga10bd82d5fe369dca952502d4b71804f6"></a><!-- doxytag: member="osc_cache.c::EASSERTF" ref="ga10bd82d5fe369dca952502d4b71804f6" args="(expr, ext, fmt, args...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EASSERTF</td>
          <td>(</td>
          <td class="paramtype">expr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ext, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args...&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                            \
        <span class="keywordflow">if</span> (!(expr)) {                                                  \
                OSC_EXTENT_DUMP(D_ERROR, (ext), fmt, ##args);           \
                osc_extent_tree_dump(D_ERROR, (ext)-&gt;oe_obj);           \
                LASSERT(expr);                                          \
        }                                                               \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="osc__cache_8c_source.html#l00139">139</a> of file <a class="el" href="osc__cache_8c_source.html">osc_cache.c</a>.</p>

</div>
</div>
<a class="anchor" id="gadcea901783c395715ce961c8517df442"></a><!-- doxytag: member="osc_cache.c::list_to_obj" ref="gadcea901783c395715ce961c8517df442" args="(list, item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define list_to_obj</td>
          <td>(</td>
          <td class="paramtype">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">item&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                            \
        <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *__tmp = (list)-&gt;next;                               \
        list_del_init(__tmp);                                         \
        list_entry(__tmp, <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a>, oo_##item);                      \
})
</pre></div>
<p>Definition at line <a class="el" href="osc__cache_8c_source.html#l02124">2124</a> of file <a class="el" href="osc__cache_8c_source.html">osc_cache.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga498ae01e3e74412d04e4b5ca472f848b"></a><!-- doxytag: member="osc_cache.c::OSC_DUMP_GRANT" ref="ga498ae01e3e74412d04e4b5ca472f848b" args="(lvl, cli, fmt, args...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSC_DUMP_GRANT</td>
          <td>(</td>
          <td class="paramtype">lvl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cli, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args...&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                    \
        <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *__tmp = (cli);                               \
        CDEBUG(lvl, <span class="stringliteral">&quot;%s: grant { dirty: %ld/%ld dirty_pages: %ld/%lu &quot;</span>  \
               <span class="stringliteral">&quot;dropped: %ld avail: %ld, dirty_grant: %ld, &quot;</span>            \
               <span class="stringliteral">&quot;reserved: %ld, flight: %d } lru {in list: %ld, &quot;</span>        \
               <span class="stringliteral">&quot;left: %ld, waiters: %d }&quot;</span> fmt <span class="stringliteral">&quot;\n&quot;</span>,                     \
               cli_name(__tmp),                                         \
               __tmp-&gt;cl_dirty_pages, __tmp-&gt;cl_dirty_max_pages,        \
               atomic_long_read(&amp;obd_dirty_pages), obd_max_dirty_pages, \
               __tmp-&gt;cl_lost_grant, __tmp-&gt;cl_avail_grant,             \
               __tmp-&gt;cl_dirty_grant,                                   \
               __tmp-&gt;cl_reserved_grant, __tmp-&gt;cl_w_in_flight,         \
               atomic_long_read(&amp;__tmp-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>),                \
               atomic_long_read(&amp;__tmp-&gt;<a class="code" href="structclient__obd.html#a2570ada40488ca5becf30dd69bd17add" title="# of busy LRU pages.">cl_lru_busy</a>),                   \
               atomic_read(&amp;__tmp-&gt;<a class="code" href="structclient__obd.html#a0f0b10f102c86214c6ace7570d19c1a8" title="# of threads are shrinking LRU cache.">cl_lru_shrinkers</a>), ##args);          \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="osc__cache_8c_source.html#l01358">1358</a> of file <a class="el" href="osc__cache_8c_source.html">osc_cache.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga46b53e57ffc4a110c0b2001d67ff96ba"></a><!-- doxytag: member="osc_cache.c::OSC_EXTENT_DUMP" ref="ga46b53e57ffc4a110c0b2001d67ff96ba" args="(lvl, extent, fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSC_EXTENT_DUMP</td>
          <td>(</td>
          <td class="paramtype">lvl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">extent, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                          \
        <span class="keyword">struct </span><a class="code" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a> *__ext = (extent);                                  \
        <span class="keywordtype">char</span> __buf[16];                                                       \
                                                                              \
        CDEBUG(lvl,                                                           \
                <span class="stringliteral">&quot;extent %p@{&quot;</span> EXTSTR <span class="stringliteral">&quot;, &quot;</span>                                     \
                <span class="stringliteral">&quot;[%d|%d|%c|%s|%s|%p], [%d|%d|%c|%c|%p|%u|%p]} &quot;</span> fmt,          \
                <span class="comment">/* ----- extent part 0 ----- */</span>                               \
                __ext, EXTPARA(__ext),                                        \
                <span class="comment">/* ----- part 1 ----- */</span>                                      \
                atomic_read(&amp;__ext-&gt;<a class="code" href="structosc__extent.html#a7f522192b2e730b2700372aa917ed70d" title="refcount, removed from red-black tree if reaches zero.">oe_refc</a>),                         \
                atomic_read(&amp;__ext-&gt;<a class="code" href="structosc__extent.html#ac28ac9cd6c7240ad0afaff28ff007f89" title="busy if non-zero">oe_users</a>),                        \
                list_empty_marker(&amp;__ext-&gt;<a class="code" href="structosc__extent.html#aeaa3b4c221431f0522dee297a6bf8b7f" title="link list of osc_object&amp;#39;s oo_{hp|urgent|locking}_exts.">oe_link</a>),                           \
                oes_strings[__ext-&gt;<a class="code" href="structosc__extent.html#ab5924332afc7ba73b69e414e239afcb8" title="state of this extent">oe_state</a>], ext_flags(__ext, __buf),        \
                __ext-&gt;<a class="code" href="structosc__extent.html#ad9dab12e21e4e8231a81ecb8f170633a" title="osc_object of this extent">oe_obj</a>,                                                \
                <span class="comment">/* ----- part 2 ----- */</span>                                      \
                __ext-&gt;<a class="code" href="structosc__extent.html#a056f40e5f22d4f17f33f318930fcc56a" title="how many grants allocated for this extent.">oe_grants</a>, __ext-&gt;<a class="code" href="structosc__extent.html#a68938c4d75d133def3289025bf89553f" title="# of dirty pages in this extent">oe_nr_pages</a>,                         \
                list_empty_marker(&amp;__ext-&gt;<a class="code" href="structosc__extent.html#a560c7ce178a0a9cdac244d3d6cccf5ab" title="list of pending oap pages.">oe_pages</a>),                          \
                waitqueue_active(&amp;__ext-&gt;<a class="code" href="structosc__extent.html#abd3aea75cbadc65687de172606fb2bac" title="waitqueue - for those who want to be notified if this extent&amp;#39;s state has changed...">oe_waitq</a>) ? <span class="charliteral">&apos;+&apos;</span> : <span class="charliteral">&apos;-&apos;</span>,               \
                __ext-&gt;<a class="code" href="structosc__extent.html#a1c38bc43de56c6c6b5b09ef9477d7a8c" title="lock covering this extent">oe_dlmlock</a>, __ext-&gt;<a class="code" href="structosc__extent.html#aaa171d17018dc34315f19e53a7df019e" title="max pages per rpc when this extent was created">oe_mppr</a>, __ext-&gt;<a class="code" href="structosc__extent.html#a78831d5d0e5db8c6c1a4e166784bca0e" title="terminator of this extent.">oe_owner</a>,           \
                <span class="comment">/* ----- part 4 ----- */</span>                                      \
                ## __VA_ARGS__);                                              \
        <span class="keywordflow">if</span> (lvl == D_ERROR &amp;&amp; __ext-&gt;<a class="code" href="structosc__extent.html#a1c38bc43de56c6c6b5b09ef9477d7a8c" title="lock covering this extent">oe_dlmlock</a> != NULL)                      \
                LDLM_ERROR(__ext-&gt;<a class="code" href="structosc__extent.html#a1c38bc43de56c6c6b5b09ef9477d7a8c" title="lock covering this extent">oe_dlmlock</a>, <span class="stringliteral">&quot;extent: %p&quot;</span>, __ext);           \
        <span class="keywordflow">else</span>                                                                  \
                LDLM_DEBUG(__ext-&gt;<a class="code" href="structosc__extent.html#a1c38bc43de56c6c6b5b09ef9477d7a8c" title="lock covering this extent">oe_dlmlock</a>, <span class="stringliteral">&quot;extent: %p&quot;</span>, __ext);           \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="osc__cache_8c_source.html#l00110">110</a> of file <a class="el" href="osc__cache_8c_source.html">osc_cache.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaccc33c0d71addd205fb0d9454a49508b"></a><!-- doxytag: member="osc_cache.c::OSC_IO_DEBUG" ref="gaccc33c0d71addd205fb0d9454a49508b" args="(OSC, STR, args...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSC_IO_DEBUG</td>
          <td>(</td>
          <td class="paramtype">OSC, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args...&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">CDEBUG(D_CACHE, <span class="stringliteral">&quot;obj %p ready %d|%c|%c wr %d|%c|%c rd %d|%c &quot;</span> STR,     \
               (OSC), osc_is_ready(OSC),                                       \
               list_empty_marker(&amp;(OSC)-&gt;oo_hp_ready_item),                    \
               list_empty_marker(&amp;(OSC)-&gt;oo_ready_item),                       \
               atomic_read(&amp;(OSC)-&gt;oo_nr_writes),                              \
               list_empty_marker(&amp;(OSC)-&gt;oo_hp_exts),                          \
               list_empty_marker(&amp;(OSC)-&gt;oo_urgent_exts),                      \
               atomic_read(&amp;(OSC)-&gt;oo_nr_reads),                               \
               list_empty_marker(&amp;(OSC)-&gt;oo_reading_exts),                     \
               ##args)
</pre></div>
<p>Definition at line <a class="el" href="osc__cache_8c_source.html#l01249">1249</a> of file <a class="el" href="osc__cache_8c_source.html">osc_cache.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga393ccfc241a11b4a496b2a737d4b9896"></a><!-- doxytag: member="osc_cache.c::sanity_check" ref="ga393ccfc241a11b4a496b2a737d4b9896" args="(ext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sanity_check</td>
          <td>(</td>
          <td class="paramtype">ext&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                                   \
        <span class="keywordtype">int</span> __res;                                                             \
        osc_object_lock((ext)-&gt;<a class="code" href="structosc__extent.html#ad9dab12e21e4e8231a81ecb8f170633a" title="osc_object of this extent">oe_obj</a>);                                        \
        __res = sanity_check_nolock(ext);                                      \
        osc_object_unlock((ext)-&gt;<a class="code" href="structosc__extent.html#ad9dab12e21e4e8231a81ecb8f170633a" title="osc_object of this extent">oe_obj</a>);                                      \
        __res;                                                                 \
})
</pre></div>
<p>Definition at line <a class="el" href="osc__cache_8c_source.html#l00276">276</a> of file <a class="el" href="osc__cache_8c_source.html">osc_cache.c</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga6186b8ce09edf79ddb470068d980fa3d"></a><!-- doxytag: member="osc_cl_internal.h::osc_extent_state" ref="ga6186b8ce09edf79ddb470068d980fa3d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__osc.html#ga6186b8ce09edf79ddb470068d980fa3d">osc_extent_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga6186b8ce09edf79ddb470068d980fa3da57a171603bdbe9ce372e2c23f1b4fcb5"></a><!-- doxytag: member="OES_ACTIVE" ref="gga6186b8ce09edf79ddb470068d980fa3da57a171603bdbe9ce372e2c23f1b4fcb5" args="" -->OES_ACTIVE</em>&nbsp;</td><td>
<p>extent is just initialized or destroyed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6186b8ce09edf79ddb470068d980fa3da5fa3ea0f8426b29ae208cb22e435cf77"></a><!-- doxytag: member="OES_CACHE" ref="gga6186b8ce09edf79ddb470068d980fa3da5fa3ea0f8426b29ae208cb22e435cf77" args="" -->OES_CACHE</em>&nbsp;</td><td>
<p>process is using this extent </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6186b8ce09edf79ddb470068d980fa3da7558231f4c40076af91adcb4f605e3a3"></a><!-- doxytag: member="OES_LOCKING" ref="gga6186b8ce09edf79ddb470068d980fa3da7558231f4c40076af91adcb4f605e3a3" args="" -->OES_LOCKING</em>&nbsp;</td><td>
<p>extent is ready for IO </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6186b8ce09edf79ddb470068d980fa3da0cfb17d1d0abe58ee5a6e210ecd3b685"></a><!-- doxytag: member="OES_LOCK_DONE" ref="gga6186b8ce09edf79ddb470068d980fa3da0cfb17d1d0abe58ee5a6e210ecd3b685" args="" -->OES_LOCK_DONE</em>&nbsp;</td><td>
<p>locking page to prepare IO </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6186b8ce09edf79ddb470068d980fa3da7ed8d9d8557c8185d7cd464ca6916303"></a><!-- doxytag: member="OES_RPC" ref="gga6186b8ce09edf79ddb470068d980fa3da7ed8d9d8557c8185d7cd464ca6916303" args="" -->OES_RPC</em>&nbsp;</td><td>
<p>locking finished, ready to send </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6186b8ce09edf79ddb470068d980fa3daeac60d8c4aeeae580c118b4f08ea961c"></a><!-- doxytag: member="OES_TRUNC" ref="gga6186b8ce09edf79ddb470068d980fa3daeac60d8c4aeeae580c118b4f08ea961c" args="" -->OES_TRUNC</em>&nbsp;</td><td>
<p>in RPC </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6186b8ce09edf79ddb470068d980fa3dac862e82e76aa4803851aca25ad9fc532"></a><!-- doxytag: member="OES_STATE_MAX" ref="gga6186b8ce09edf79ddb470068d980fa3dac862e82e76aa4803851aca25ad9fc532" args="" -->OES_STATE_MAX</em>&nbsp;</td><td>
<p>being truncated </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00571">571</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00571"></a>00571                       {
<a name="l00572"></a>00572         OES_INV       = 0, 
<a name="l00573"></a>00573         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da57a171603bdbe9ce372e2c23f1b4fcb5" title="extent is just initialized or destroyed">OES_ACTIVE</a>    = 1, 
<a name="l00574"></a>00574         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da5fa3ea0f8426b29ae208cb22e435cf77" title="process is using this extent">OES_CACHE</a>     = 2, 
<a name="l00575"></a>00575         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da7558231f4c40076af91adcb4f605e3a3" title="extent is ready for IO">OES_LOCKING</a>   = 3, 
<a name="l00576"></a>00576         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da0cfb17d1d0abe58ee5a6e210ecd3b685" title="locking page to prepare IO">OES_LOCK_DONE</a> = 4, 
<a name="l00577"></a>00577         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da7ed8d9d8557c8185d7cd464ca6916303" title="locking finished, ready to send">OES_RPC</a>       = 5, 
<a name="l00578"></a>00578         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3daeac60d8c4aeeae580c118b4f08ea961c" title="in RPC">OES_TRUNC</a>     = 6, 
<a name="l00579"></a>00579         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3dac862e82e76aa4803851aca25ad9fc532" title="being truncated">OES_STATE_MAX</a>
<a name="l00580"></a>00580 };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaec0dd919ecdfdb232dca4819b15617c5"></a><!-- doxytag: member="osc_page.c::osc_cache_shrink_count" ref="gaec0dd919ecdfdb232dca4819b15617c5" args="(struct shrinker *sk, struct shrink_control *sc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long osc_cache_shrink_count </td>
          <td>(</td>
          <td class="paramtype">struct shrinker *&nbsp;</td>
          <td class="paramname"> <em>sk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structshrink__control.html">shrink_control</a> *&nbsp;</td>
          <td class="paramname"> <em>sc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return how many LRU pages in the cache of all OSC devices. </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>return</em>&nbsp;</td><td># of cached LRU pages times reclaimation tendency </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SHRINK_STOP</em>&nbsp;</td><td>if it cannot do any scanning in this time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="osc__page_8c_source.html#l01134">1134</a> of file <a class="el" href="osc__page_8c_source.html">osc_page.c</a>.</p>

<p>References <a class="el" href="obd_8h_source.html#l00266">client_obd::cl_lru_in_list</a>, and <a class="el" href="obd_8h_source.html#l00286">client_obd::cl_shrink_list</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01136"></a>01136 {
<a name="l01137"></a>01137         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *cli;
<a name="l01138"></a>01138         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cached = 0;
<a name="l01139"></a>01139 
<a name="l01140"></a>01140         spin_lock(&amp;osc_shrink_lock);
<a name="l01141"></a>01141         list_for_each_entry(cli, &amp;osc_shrink_list, <a class="code" href="structclient__obd.html#a14ec05e4781d916049029a0976da1eb9" title="Link to osc_shrinker_list.">cl_shrink_list</a>)
<a name="l01142"></a>01142                 cached += atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#ac9f92301393a89d78fc95a70d3bfe390" title="# of LRU pages in the cache for this client_obd">cl_lru_in_list</a>);
<a name="l01143"></a>01143         spin_unlock(&amp;osc_shrink_lock);
<a name="l01144"></a>01144 
<a name="l01145"></a>01145         return (cached  * sysctl_vfs_cache_pressure) / 100;
<a name="l01146"></a>01146 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga084c788be8d116db87ebdd3c273d9a23"></a><!-- doxytag: member="osc_page.c::osc_cache_shrink_scan" ref="ga084c788be8d116db87ebdd3c273d9a23" args="(struct shrinker *sk, struct shrink_control *sc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long osc_cache_shrink_scan </td>
          <td>(</td>
          <td class="paramtype">struct shrinker *&nbsp;</td>
          <td class="paramname"> <em>sk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structshrink__control.html">shrink_control</a> *&nbsp;</td>
          <td class="paramname"> <em>sc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan and try to reclaim sc-&gt;nr_to_scan cached LRU pages. </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>of cached LRU pages reclaimed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SHRINK_STOP</em>&nbsp;</td><td>if it cannot do any scanning in this time</td></tr>
  </table>
  </dd>
</dl>
<p>Linux kernel will loop calling this shrinker scan routine with sc-&gt;nr_to_scan = SHRINK_BATCH(128 for now) until kernel got enough memory.</p>
<p>If sc-&gt;nr_to_scan is 0, the VM is querying the cache size, we don't need to scan and try to reclaim LRU pages, just return 0 and <a class="el" href="group__osc.html#gaec0dd919ecdfdb232dca4819b15617c5" title="Return how many LRU pages in the cache of all OSC devices.">osc_cache_shrink_count()</a> will report the LRU page number. </p>

<p>Definition at line <a class="el" href="osc__page_8c_source.html#l01161">1161</a> of file <a class="el" href="osc__page_8c_source.html">osc_page.c</a>.</p>

<p>References <a class="el" href="obd_8h_source.html#l00286">client_obd::cl_shrink_list</a>, and <a class="el" href="osc__page_8c_source.html#l00667">osc_lru_shrink()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01163"></a>01163 {
<a name="l01164"></a>01164         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *cli;
<a name="l01165"></a>01165         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *stop_anchor = NULL;
<a name="l01166"></a>01166         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a> nest;
<a name="l01167"></a>01167         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01168"></a>01168         <span class="keywordtype">long</span> shrank = 0;
<a name="l01169"></a>01169         <span class="keywordtype">int</span> rc;
<a name="l01170"></a>01170 
<a name="l01171"></a>01171         <span class="keywordflow">if</span> (sc-&gt;nr_to_scan == 0)
<a name="l01172"></a>01172                 <span class="keywordflow">return</span> 0;
<a name="l01173"></a>01173 
<a name="l01174"></a>01174         <span class="keywordflow">if</span> (!(sc-&gt;gfp_mask &amp; __GFP_FS))
<a name="l01175"></a>01175                 <span class="keywordflow">return</span> SHRINK_STOP;
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         env = cl_env_nested_get(&amp;nest);
<a name="l01178"></a>01178         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01179"></a>01179                 <span class="keywordflow">return</span> SHRINK_STOP;
<a name="l01180"></a>01180 
<a name="l01181"></a>01181         spin_lock(&amp;osc_shrink_lock);
<a name="l01182"></a>01182         <span class="keywordflow">while</span> (!list_empty(&amp;osc_shrink_list)) {
<a name="l01183"></a>01183                 cli = list_entry(osc_shrink_list.next, <span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a>,
<a name="l01184"></a>01184                                  cl_shrink_list);
<a name="l01185"></a>01185 
<a name="l01186"></a>01186                 <span class="keywordflow">if</span> (stop_anchor == NULL)
<a name="l01187"></a>01187                         stop_anchor = cli;
<a name="l01188"></a>01188                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cli == stop_anchor)
<a name="l01189"></a>01189                         <span class="keywordflow">break</span>;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191                 list_move_tail(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a14ec05e4781d916049029a0976da1eb9" title="Link to osc_shrinker_list.">cl_shrink_list</a>, &amp;osc_shrink_list);
<a name="l01192"></a>01192                 spin_unlock(&amp;osc_shrink_lock);
<a name="l01193"></a>01193 
<a name="l01194"></a>01194                 <span class="comment">/* shrink no more than max_pages_per_rpc for an OSC */</span>
<a name="l01195"></a>01195                 rc = <a class="code" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop  of pages from LRU at most.">osc_lru_shrink</a>(env, cli, (sc-&gt;nr_to_scan - shrank) &gt;
<a name="l01196"></a>01196                                     cli-&gt;cl_max_pages_per_rpc ?
<a name="l01197"></a>01197                                     cli-&gt;cl_max_pages_per_rpc :
<a name="l01198"></a>01198                                     sc-&gt;nr_to_scan - shrank, <span class="keyword">true</span>);
<a name="l01199"></a>01199                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l01200"></a>01200                         shrank += rc;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202                 <span class="keywordflow">if</span> (shrank &gt;= sc-&gt;nr_to_scan)
<a name="l01203"></a>01203                         <span class="keywordflow">goto</span> out;
<a name="l01204"></a>01204 
<a name="l01205"></a>01205                 spin_lock(&amp;osc_shrink_lock);
<a name="l01206"></a>01206         }
<a name="l01207"></a>01207         spin_unlock(&amp;osc_shrink_lock);
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 out:
<a name="l01210"></a>01210         cl_env_nested_put(&amp;nest, env);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212         <span class="keywordflow">return</span> shrank;
<a name="l01213"></a>01213 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__osc_ga084c788be8d116db87ebdd3c273d9a23_cgraph.png" border="0" usemap="#group__osc_ga084c788be8d116db87ebdd3c273d9a23_cgraph_map" alt=""></div>
<map name="group__osc_ga084c788be8d116db87ebdd3c273d9a23_cgraph_map" id="group__osc_ga084c788be8d116db87ebdd3c273d9a23_cgraph">
<area shape="rect" id="node3" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop &#160;of pages from LRU at most." alt="" coords="231,165,343,195"/><area shape="rect" id="node5" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom&#45;to&#45;top." alt="" coords="421,5,499,35"/><area shape="rect" id="node7" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top&#45;to&#45;bottom." alt="" coords="421,59,499,88"/><area shape="rect" id="node11" href="group__cl__object.html#gae84de86afc6e9dbf1f9e1a7219bd202b" title="Acquire an additional reference to the object o." alt="" coords="403,112,517,141"/><area shape="rect" id="node13" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o." alt="" coords="403,165,517,195"/><area shape="rect" id="node17" href="group__cl__page.html#gae41a4c98faae723b2566a721b6e4b7fb" title="Releases page ownership." alt="" coords="397,219,523,248"/><area shape="rect" id="node24" href="group__cl__page.html#gafc2fc785c3daf1db46bb250244dfde13" title="Acquires an additional reference to a page." alt="" coords="408,272,512,301"/><area shape="rect" id="node26" href="group__cl__page.html#ga105c7ed0e326d75ffc75980986186bb7" title="Nonblock version of cl_page_own()." alt="" coords="393,325,527,355"/><area shape="rect" id="node9" href="group__cl__object.html#ga00ef0f7240b9a7d773a49a77c667f03a" title="Returns the top&#45;object for a given o." alt="" coords="589,59,704,88"/><area shape="rect" id="node15" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object." alt="" coords="589,165,704,195"/><area shape="rect" id="node19" href="group__cl__io.html#ga4bb065eb52291173dbda9a0721b1ea2c" title="Returns top&#45;level io." alt="" coords="767,245,847,275"/><area shape="rect" id="node21" href="group__cl__page.html#gabf5979233c47e0913f8d438d01051ebf" title="returns true, iff page is owned by the given io." alt="" coords="576,271,717,300"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga4c709e4df4c17373354b20238e863f2a"></a><!-- doxytag: member="osc_cache.c::osc_cache_wait_range" ref="ga4c709e4df4c17373354b20238e863f2a" args="(const struct lu_env *env, struct osc_object *obj, pgoff_t start, pgoff_t end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osc_cache_wait_range </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structosc__object.html">osc_object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for extents in a specific range to be written out. </p>
<p>The caller must have called <a class="el" href="group__osc.html#ga91e31015ca9c3df0750e008ebd5831cf" title="Called to write out a range of osc object.">osc_cache_writeback_range()</a> to issue IO otherwise it will take a long time for this function to finish.</p>
<p>Caller must hold inode_mutex , or cancel exclusive dlm lock so that nobody else can dirty this range of file while we're waiting for extents to be written. </p>

</div>
</div>
<a class="anchor" id="ga91e31015ca9c3df0750e008ebd5831cf"></a><!-- doxytag: member="osc_cache.c::osc_cache_writeback_range" ref="ga91e31015ca9c3df0750e008ebd5831cf" args="(const struct lu_env *env, struct osc_object *obj, pgoff_t start, pgoff_t end, int hp, int discard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osc_cache_writeback_range </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structosc__object.html">osc_object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>discard</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called to write out a range of osc object. </p>
<p>: should be set this is caused by lock cancel; : is set if dirty pages should be dropped - file will be deleted or truncated, this implies there is no partially discarding extents.</p>
<p>Return how many pages will be issued, or error code if error occurred. </p>

</div>
</div>
<a class="anchor" id="gad22b15d739092f8a8d27214eff304e66"></a><!-- doxytag: member="osc_cache.c::osc_cancel_async_page" ref="gad22b15d739092f8a8d27214eff304e66" args="(const struct lu_env *env, struct osc_page *ops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osc_cancel_async_page </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structosc__page.html">osc_page</a> *&nbsp;</td>
          <td class="paramname"> <em>ops</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this is called when a sync waiter receives an interruption. </p>
<p>Its job is to get the caller woken as soon as possible. If its page hasn't been put in an rpc yet it can dequeue immediately. Otherwise it has to mark the rpc as desiring interruption which will forcefully complete the rpc once the rpc has timed out. </p>

</div>
</div>
<a class="anchor" id="ga06cb0f9449c99e3cec373a61af41929a"></a><!-- doxytag: member="osc_page.c::osc_dec_unstable_pages" ref="ga06cb0f9449c99e3cec373a61af41929a" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osc_dec_unstable_pages </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs "unstable" page accounting. </p>
<p>This function balances the increment operations performed in osc_inc_unstable_pages. It is registered as the RPC request callback, and is executed when the bulk RPC is committed on the server. Thus at this point, the pages involved in the bulk transfer are no longer considered unstable.</p>
<p>If this function is called, the request should have been committed or req:rq_unstable must have been set; it implies that the unstable statistic have been added. </p>

<p>Definition at line <a class="el" href="osc__page_8c_source.html#l01041">1041</a> of file <a class="el" href="osc__page_8c_source.html">osc_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l02211">cl_client_cache::ccc_unstable_nr</a>, <a class="el" href="cl__object_8h_source.html#l02216">cl_client_cache::ccc_unstable_waitq</a>, <a class="el" href="obd_8h_source.html#l00254">client_obd::cl_cache</a>, <a class="el" href="obd_8h_source.html#l00284">client_obd::cl_unstable_count</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, and <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>.</p>

<p>Referenced by <a class="el" href="osc__page_8c_source.html#l01068">osc_inc_unstable_pages()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01042"></a>01042 {
<a name="l01043"></a>01043         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc       = req-&gt;rq_bulk;
<a name="l01044"></a>01044         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a>       *cli        = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;u.cli;
<a name="l01045"></a>01045         <span class="keywordtype">int</span>                      page_count = desc-&gt;bd_iov_count;
<a name="l01046"></a>01046         <span class="keywordtype">long</span>                     unstable_count;
<a name="l01047"></a>01047 
<a name="l01048"></a>01048         LASSERT(page_count &gt;= 0);
<a name="l01049"></a>01049         dec_unstable_page_accounting(desc);
<a name="l01050"></a>01050 
<a name="l01051"></a>01051         unstable_count = atomic_long_sub_return(page_count,
<a name="l01052"></a>01052                                                 &amp;cli-&gt;<a class="code" href="structclient__obd.html#a4757a1bb410e50bd8c828cc497e45734" title="# of unstable pages in this client_obd.">cl_unstable_count</a>);
<a name="l01053"></a>01053         LASSERT(unstable_count &gt;= 0);
<a name="l01054"></a>01054 
<a name="l01055"></a>01055         unstable_count = atomic_long_sub_return(page_count,
<a name="l01056"></a>01056                                            &amp;cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a2f819a992c85af943adf3120cf2d509d" title="# of unstable pages for this mount point">ccc_unstable_nr</a>);
<a name="l01057"></a>01057         LASSERT(unstable_count &gt;= 0);
<a name="l01058"></a>01058         <span class="keywordflow">if</span> (unstable_count == 0)
<a name="l01059"></a>01059                 wake_up_all(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a2522ffba520c532065c98791724fc521" title="Waitq for awaiting unstable pages to reach zero.">ccc_unstable_waitq</a>);
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         <span class="keywordflow">if</span> (waitqueue_active(&amp;osc_lru_waitq))
<a name="l01062"></a>01062                 (void)ptlrpcd_queue_work(cli-&gt;cl_lru_work);
<a name="l01063"></a>01063 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__osc_ga06cb0f9449c99e3cec373a61af41929a_icgraph.png" border="0" usemap="#group__osc_ga06cb0f9449c99e3cec373a61af41929a_icgraph_map" alt=""></div>
<map name="group__osc_ga06cb0f9449c99e3cec373a61af41929a_icgraph_map" id="group__osc_ga06cb0f9449c99e3cec373a61af41929a_icgraph">
<area shape="rect" id="node3" href="group__osc.html#gaba135e313f6a93ebb5d5cc3a823116c4" title="&quot;unstable&quot; page accounting." alt="" coords="244,5,425,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gacbca1d2858196fd14f5de2a27cb7c857"></a><!-- doxytag: member="osc_cache.c::osc_flush_async_page" ref="gacbca1d2858196fd14f5de2a27cb7c857" args="(const struct lu_env *env, struct cl_io *io, struct osc_page *ops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osc_flush_async_page </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structosc__page.html">osc_page</a> *&nbsp;</td>
          <td class="paramname"> <em>ops</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is called when a page is picked up by kernel to write out. </p>
<p>We should find out the corresponding extent and add the whole extent into urgent list. The extent may be being truncated or used, handle it carefully. </p>

</div>
</div>
<a class="anchor" id="gaba135e313f6a93ebb5d5cc3a823116c4"></a><!-- doxytag: member="osc_page.c::osc_inc_unstable_pages" ref="gaba135e313f6a93ebb5d5cc3a823116c4" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osc_inc_unstable_pages </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"unstable" page accounting. </p>
<p>See: osc_dec_unstable_pages. </p>

<p>Definition at line <a class="el" href="osc__page_8c_source.html#l01068">1068</a> of file <a class="el" href="osc__page_8c_source.html">osc_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l02207">cl_client_cache::ccc_unstable_check</a>, <a class="el" href="cl__object_8h_source.html#l02211">cl_client_cache::ccc_unstable_nr</a>, <a class="el" href="obd_8h_source.html#l00254">client_obd::cl_cache</a>, <a class="el" href="obd_8h_source.html#l00284">client_obd::cl_unstable_count</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="osc__page_8c_source.html#l01041">osc_dec_unstable_pages()</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, and <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01069"></a>01069 {
<a name="l01070"></a>01070         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc = req-&gt;rq_bulk;
<a name="l01071"></a>01071         <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a>       *cli  = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;u.cli;
<a name="l01072"></a>01072         <span class="keywordtype">long</span>                     page_count = desc-&gt;bd_iov_count;
<a name="l01073"></a>01073 
<a name="l01074"></a>01074         <span class="comment">/* No unstable page tracking */</span>
<a name="l01075"></a>01075         <span class="keywordflow">if</span> (cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a> == NULL || !cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#af3635fd3633a4dbcbb2a37b5de0a2a3f" title="Set if unstable check is enabled.">ccc_unstable_check</a>)
<a name="l01076"></a>01076                 <span class="keywordflow">return</span>;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078         add_unstable_page_accounting(desc);
<a name="l01079"></a>01079         atomic_long_add(page_count, &amp;cli-&gt;<a class="code" href="structclient__obd.html#a4757a1bb410e50bd8c828cc497e45734" title="# of unstable pages in this client_obd.">cl_unstable_count</a>);
<a name="l01080"></a>01080         atomic_long_add(page_count, &amp;cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a2f819a992c85af943adf3120cf2d509d" title="# of unstable pages for this mount point">ccc_unstable_nr</a>);
<a name="l01081"></a>01081 
<a name="l01082"></a>01082         <span class="comment">/* If the request has already been committed (i.e. brw_commit</span>
<a name="l01083"></a>01083 <span class="comment">         * called via rq_commit_cb), we need to undo the unstable page</span>
<a name="l01084"></a>01084 <span class="comment">         * increments we just performed because rq_commit_cb wont be</span>
<a name="l01085"></a>01085 <span class="comment">         * called again. */</span>
<a name="l01086"></a>01086         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01087"></a>01087         <span class="keywordflow">if</span> (unlikely(req-&gt;rq_committed)) {
<a name="l01088"></a>01088                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01089"></a>01089 
<a name="l01090"></a>01090                 <a class="code" href="group__osc.html#ga06cb0f9449c99e3cec373a61af41929a" title="Performs &amp;quot;unstable&amp;quot; page accounting.">osc_dec_unstable_pages</a>(req);
<a name="l01091"></a>01091         } <span class="keywordflow">else</span> {
<a name="l01092"></a>01092                 req-&gt;rq_unstable = 1;
<a name="l01093"></a>01093                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01094"></a>01094         }
<a name="l01095"></a>01095 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__osc_gaba135e313f6a93ebb5d5cc3a823116c4_cgraph.png" border="0" usemap="#group__osc_gaba135e313f6a93ebb5d5cc3a823116c4_cgraph_map" alt=""></div>
<map name="group__osc_gaba135e313f6a93ebb5d5cc3a823116c4_cgraph_map" id="group__osc_gaba135e313f6a93ebb5d5cc3a823116c4_cgraph">
<area shape="rect" id="node3" href="group__osc.html#ga06cb0f9449c99e3cec373a61af41929a" title="Performs &quot;unstable&quot; page accounting." alt="" coords="237,5,427,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad86265cc2892261e7634f0d9a2050a6b"></a><!-- doxytag: member="osc_cache.c::osc_lock_discard_pages" ref="gad86265cc2892261e7634f0d9a2050a6b" args="(const struct lu_env *env, struct osc_object *osc, pgoff_t start, pgoff_t end, enum cl_lock_mode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osc_lock_discard_pages </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structosc__object.html">osc_object</a> *&nbsp;</td>
          <td class="paramname"> <em>osc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1">cl_lock_mode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Discard pages protected by the given lock. </p>
<p>This function traverses radix tree to find all covering pages and discard them. If a page is being covered by other locks, it should remain in cache.</p>
<p>If error happens on any step, the process continues anyway (the reasoning behind this being that lock cancellation cannot be delayed indefinitely). </p>

</div>
</div>
<a class="anchor" id="ga6739eb4d14ea9d44005f4e5131ba8ade"></a><!-- doxytag: member="osc_page.c::osc_lru_reserve" ref="ga6739eb4d14ea9d44005f4e5131ba8ade" args="(struct client_obd *cli, unsigned long npages)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long osc_lru_reserve </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structclient__obd.html">client_obd</a> *&nbsp;</td>
          <td class="paramname"> <em>cli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>npages</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="group__osc.html#ga6739eb4d14ea9d44005f4e5131ba8ade" title="osc_lru_reserve() is called to reserve enough LRU slots for I/O.">osc_lru_reserve()</a> is called to reserve enough LRU slots for I/O. </p>
<p>The benefit of doing this is to reduce contention against atomic counter cl_lru_left by changing it from per-page access to per-IO access. </p>

<p>Definition at line <a class="el" href="osc__page_8c_source.html#l00936">936</a> of file <a class="el" href="osc__page_8c_source.html">osc_page.c</a>.</p>

<p>References <a class="el" href="obd_8h_source.html#l00260">client_obd::cl_lru_left</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00937"></a>00937 {
<a name="l00938"></a>00938         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> reserved = 0;
<a name="l00939"></a>00939         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> max_pages;
<a name="l00940"></a>00940         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> c;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942         <span class="comment">/* reserve a full RPC window at most to avoid that a thread accidentally</span>
<a name="l00943"></a>00943 <span class="comment">         * consumes too many LRU slots */</span>
<a name="l00944"></a>00944         max_pages = cli-&gt;cl_max_pages_per_rpc * cli-&gt;cl_max_rpcs_in_flight;
<a name="l00945"></a>00945         <span class="keywordflow">if</span> (npages &gt; max_pages)
<a name="l00946"></a>00946                 npages = max_pages;
<a name="l00947"></a>00947 
<a name="l00948"></a>00948         c = atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00949"></a>00949         <span class="keywordflow">if</span> (c &lt; npages &amp;&amp; osc_lru_reclaim(cli, npages) &gt; 0)
<a name="l00950"></a>00950                 c = atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00951"></a>00951         <span class="keywordflow">while</span> (c &gt;= npages) {
<a name="l00952"></a>00952                 <span class="keywordflow">if</span> (c == atomic_long_cmpxchg(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>, c, c - npages)) {
<a name="l00953"></a>00953                         reserved = npages;
<a name="l00954"></a>00954                         <span class="keywordflow">break</span>;
<a name="l00955"></a>00955                 }
<a name="l00956"></a>00956                 c = atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00957"></a>00957         }
<a name="l00958"></a>00958         <span class="keywordflow">if</span> (atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>) &lt; max_pages) {
<a name="l00959"></a>00959                 <span class="comment">/* If there aren&apos;t enough pages in the per-OSC LRU then</span>
<a name="l00960"></a>00960 <span class="comment">                 * wake up the LRU thread to try and clear out space, so</span>
<a name="l00961"></a>00961 <span class="comment">                 * we don&apos;t block if pages are being dirtied quickly. */</span>
<a name="l00962"></a>00962                 CDEBUG(D_CACHE, <span class="stringliteral">&quot;%s: queue LRU, left: %lu/%ld.\n&quot;</span>,
<a name="l00963"></a>00963                        cli_name(cli), atomic_long_read(cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>),
<a name="l00964"></a>00964                        max_pages);
<a name="l00965"></a>00965                 (void)ptlrpcd_queue_work(cli-&gt;cl_lru_work);
<a name="l00966"></a>00966         }
<a name="l00967"></a>00967 
<a name="l00968"></a>00968         <span class="keywordflow">return</span> reserved;
<a name="l00969"></a>00969 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaacf75a0c2b6ddc3e431b00b684de8eed"></a><!-- doxytag: member="osc_page.c::osc_lru_unreserve" ref="gaacf75a0c2b6ddc3e431b00b684de8eed" args="(struct client_obd *cli, unsigned long npages)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osc_lru_unreserve </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structclient__obd.html">client_obd</a> *&nbsp;</td>
          <td class="paramname"> <em>cli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>npages</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="group__osc.html#gaacf75a0c2b6ddc3e431b00b684de8eed" title="osc_lru_unreserve() is called to unreserve LRU slots.">osc_lru_unreserve()</a> is called to unreserve LRU slots. </p>
<p>LRU slots reserved by <a class="el" href="group__osc.html#ga6739eb4d14ea9d44005f4e5131ba8ade" title="osc_lru_reserve() is called to reserve enough LRU slots for I/O.">osc_lru_reserve()</a> may have entries left due to several reasons such as page already existing or I/O error. Those reserved slots should be freed by calling this function. </p>

<p>Definition at line <a class="el" href="osc__page_8c_source.html#l00978">978</a> of file <a class="el" href="osc__page_8c_source.html">osc_page.c</a>.</p>

<p>References <a class="el" href="obd_8h_source.html#l00260">client_obd::cl_lru_left</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00979"></a>00979 {
<a name="l00980"></a>00980         atomic_long_add(npages, cli-&gt;<a class="code" href="structclient__obd.html#ac7a50799f915bc96e39e00dfe045e3ce" title="# of available LRU slots left in the per-OSC cache.">cl_lru_left</a>);
<a name="l00981"></a>00981         wake_up_all(&amp;osc_lru_waitq);
<a name="l00982"></a>00982 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa2bc86b38907996c03e4debb5953688b"></a><!-- doxytag: member="osc_page.c::osc_over_unstable_soft_limit" ref="gaa2bc86b38907996c03e4debb5953688b" args="(struct client_obd *cli)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osc_over_unstable_soft_limit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structclient__obd.html">client_obd</a> *&nbsp;</td>
          <td class="paramname"> <em>cli</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if it piggybacks SOFT_SYNC flag to OST from this OSC. </p>
<p>This function will be called by every BRW RPC so it's critical to make this function fast. </p>

<p>Definition at line <a class="el" href="osc__page_8c_source.html#l01102">1102</a> of file <a class="el" href="osc__page_8c_source.html">osc_page.c</a>.</p>

<p>References <a class="el" href="cl__object_8h_source.html#l02199">cl_client_cache::ccc_lru_max</a>, <a class="el" href="cl__object_8h_source.html#l02207">cl_client_cache::ccc_unstable_check</a>, <a class="el" href="cl__object_8h_source.html#l02211">cl_client_cache::ccc_unstable_nr</a>, <a class="el" href="obd_8h_source.html#l00254">client_obd::cl_cache</a>, and <a class="el" href="obd_8h_source.html#l00284">client_obd::cl_unstable_count</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01103"></a>01103 {
<a name="l01104"></a>01104         <span class="keywordtype">long</span> unstable_nr, osc_unstable_count;
<a name="l01105"></a>01105 
<a name="l01106"></a>01106         <span class="comment">/* Can&apos;t check cli-&gt;cl_unstable_count, therefore, no soft limit */</span>
<a name="l01107"></a>01107         <span class="keywordflow">if</span> (cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a> == NULL || !cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#af3635fd3633a4dbcbb2a37b5de0a2a3f" title="Set if unstable check is enabled.">ccc_unstable_check</a>)
<a name="l01108"></a>01108                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110         osc_unstable_count = atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a4757a1bb410e50bd8c828cc497e45734" title="# of unstable pages in this client_obd.">cl_unstable_count</a>);
<a name="l01111"></a>01111         unstable_nr = atomic_long_read(&amp;cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a2f819a992c85af943adf3120cf2d509d" title="# of unstable pages for this mount point">ccc_unstable_nr</a>);
<a name="l01112"></a>01112 
<a name="l01113"></a>01113         CDEBUG(D_CACHE,
<a name="l01114"></a>01114                <span class="stringliteral">&quot;%s: cli: %p unstable pages: %lu, osc unstable pages: %lu\n&quot;</span>,
<a name="l01115"></a>01115                cli_name(cli), cli, unstable_nr, osc_unstable_count);
<a name="l01116"></a>01116 
<a name="l01117"></a>01117         <span class="comment">/* If the LRU slots are in shortage - 25% remaining AND this OSC</span>
<a name="l01118"></a>01118 <span class="comment">         * has one full RPC window of unstable pages, it&apos;s a good chance</span>
<a name="l01119"></a>01119 <span class="comment">         * to piggyback a SOFT_SYNC flag.</span>
<a name="l01120"></a>01120 <span class="comment">         * Please notice that the OST won&apos;t take immediate response for the</span>
<a name="l01121"></a>01121 <span class="comment">         * SOFT_SYNC request so active OSCs will have more chance to carry</span>
<a name="l01122"></a>01122 <span class="comment">         * the flag, this is reasonable. */</span>
<a name="l01123"></a>01123         <span class="keywordflow">return</span> unstable_nr &gt; cli-&gt;<a class="code" href="structclient__obd.html#a54a7cb17572c1e55c384911366940382" title="LRU for osc caching pages.">cl_cache</a>-&gt;<a class="code" href="structcl__client__cache.html#a6533ffde6bee6a5e60c0db19b5966a71" title="Max # of LRU entries.">ccc_lru_max</a> &gt;&gt; 2 &amp;&amp;
<a name="l01124"></a>01124                osc_unstable_count &gt; cli-&gt;cl_max_pages_per_rpc *
<a name="l01125"></a>01125                                     cli-&gt;cl_max_rpcs_in_flight;
<a name="l01126"></a>01126 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4ac00d525c8750fbccb312796dfb0542"></a><!-- doxytag: member="osc_cache.c::osc_page_gang_lookup" ref="ga4ac00d525c8750fbccb312796dfb0542" args="(const struct lu_env *env, struct cl_io *io, struct osc_object *osc, pgoff_t start, pgoff_t end, osc_page_gang_cbt cb, void *cbdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osc_page_gang_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcl__io.html">cl_io</a> *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structosc__object.html">osc_object</a> *&nbsp;</td>
          <td class="paramname"> <em>osc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pgoff_t&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">osc_page_gang_cbt&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cbdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of pages by a given [start, end] of <em>obj</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resched</em>&nbsp;</td><td>If not NULL, then we give up before hogging CPU for too long and set *resched = 1, in that case caller should implement a retry logic.</td></tr>
  </table>
  </dd>
</dl>
<p>Gang tree lookup (radix_tree_gang_lookup()) optimization is absolutely crucial in the face of [offset, EOF] locks.</p>
<p>Return at least one page in  unless there is no covered page. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga40d14c8c546010ba5c116bc0ee4fa598"></a><!-- doxytag: member="osc_dev.c::osc_device_type" ref="ga40d14c8c546010ba5c116bc0ee4fa598" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__device__type.html">lu_device_type</a> osc_device_type</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        .ldt_tags     = <a class="code" href="group__lu.html#ggaa318f5b20c40de1d564f59dd72726345a6950d6daf539cb6aa3902679e6232783" title="data device in the client stack">LU_DEVICE_CL</a>,
        .ldt_name     = LUSTRE_OSC_NAME,
        .ldt_ops      = &amp;osc_device_type_ops,
        .ldt_ctx_tags = <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" title="Thread on client.">LCT_CL_THREAD</a>
}
</pre></div>
<p>Definition at line <a class="el" href="osc__dev_8c_source.html#l00243">243</a> of file <a class="el" href="osc__dev_8c_source.html">osc_dev.c</a>.</p>

</div>
</div>
<a class="anchor" id="gadaf1b8cc09a172dcf2739a03e5b0fa44"></a><!-- doxytag: member="osc_dev.c::osc_key" ref="gadaf1b8cc09a172dcf2739a03e5b0fa44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__context__key.html">lu_context_key</a> osc_key</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        .lct_tags = <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" title="Thread on client.">LCT_CL_THREAD</a>,
        .lct_init = osc_key_init,
        .lct_fini = osc_key_fini
}
</pre></div>
<p>Definition at line <a class="el" href="osc__dev_8c_source.html#l00132">132</a> of file <a class="el" href="osc__dev_8c_source.html">osc_dev.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2fdc1e11d4fac80fc5f4ea7daac25f5b"></a><!-- doxytag: member="osc_dev.c::osc_session_key" ref="ga2fdc1e11d4fac80fc5f4ea7daac25f5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__context__key.html">lu_context_key</a> osc_session_key</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        .lct_tags = <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa76aa3f8e745622ced47e2687d27c4b84" title="A per-request session on a server, and a per-system-call session on a client.">LCT_SESSION</a>,
        .lct_init = osc_session_init,
        .lct_fini = osc_session_fini
}
</pre></div>
<p>Definition at line <a class="el" href="osc__dev_8c_source.html#l00156">156</a> of file <a class="el" href="osc__dev_8c_source.html">osc_dev.c</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:47 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
