<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: ha</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ha</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga034393ab029d377596a43164f9e3e7f3"></a><!-- doxytag: member="ha::ptlrpc_replay" ref="ga034393ab029d377596a43164f9e3e7f3" args="(struct obd_import *imp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_replay</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ha.html#gaf20ae4ef40ab6633e816a6b842697203">ptlrpc_resend</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule resending of request on sending_list.  <a href="#gaf20ae4ef40ab6633e816a6b842697203"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ha.html#ga1201e450853aba39256bafedcfae7f11">ptlrpc_free_committed</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates through replay_list on import and prunes all requests have transno smaller than last_committed for the import and don't have rq_replay set.  <a href="#ga1201e450853aba39256bafedcfae7f11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga903dde67851aeb4d8fa5869641a95c34"></a><!-- doxytag: member="ha::ptlrpc_wake_delayed" ref="ga903dde67851aeb4d8fa5869641a95c34" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ha.html#ga903dde67851aeb4d8fa5869641a95c34">ptlrpc_wake_delayed</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Go through all requests in delayed list and wake their threads for resending. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb6b0dff9cb6a6523a07f3760a5fc713"></a><!-- doxytag: member="ha::ptlrpc_recover_import" ref="gaeb6b0dff9cb6a6523a07f3760a5fc713" args="(struct obd_import *imp, char *new_uuid, int async)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_recover_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, char *new_uuid, int async)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ha.html#gaa5fa7cae0d8f72e02ff80fa961723668">ptlrpc_set_import_active</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, int active)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Administratively active/deactive a client.  <a href="#gaa5fa7cae0d8f72e02ff80fa961723668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gade2892381fe2d1cb83a0afd69c454850"></a><!-- doxytag: member="ha::ptlrpc_activate_import" ref="gade2892381fe2d1cb83a0afd69c454850" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_activate_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2f5b15ea43e40d5cf0ade40337705a5"></a><!-- doxytag: member="ha::ptlrpc_deactivate_import" ref="gaa2f5b15ea43e40d5cf0ade40337705a5" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_deactivate_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5301cdfd160cb1e18f119fbc8fac3252"></a><!-- doxytag: member="ha::ptlrpc_invalidate_import" ref="ga5301cdfd160cb1e18f119fbc8fac3252" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ha.html#ga5301cdfd160cb1e18f119fbc8fac3252">ptlrpc_invalidate_import</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will invalidate the import, if necessary, then block for all the RPC completions, and finally notify the obd to invalidate its state (ie cancel locks, clear pending requests, etc). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06f34c2863693ef75e87b52a27e8b24a"></a><!-- doxytag: member="ha::ptlrpc_fail_import" ref="ga06f34c2863693ef75e87b52a27e8b24a" args="(struct obd_import *imp, __u32 conn_cnt)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_fail_import</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, __u32 conn_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1498bfee146a727a917aa03b64128a74"></a><!-- doxytag: member="ha::ptlrpc_pinger_force" ref="ga1498bfee146a727a917aa03b64128a74" args="(struct obd_import *imp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ptlrpc_pinger_force</b> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga1201e450853aba39256bafedcfae7f11"></a><!-- doxytag: member="lustre_ha.h::ptlrpc_free_committed" ref="ga1201e450853aba39256bafedcfae7f11" args="(struct obd_import *imp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_free_committed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates through replay_list on import and prunes all requests have transno smaller than last_committed for the import and don't have rq_replay set. </p>
<p>Since requests are sorted in transno order, stops when meetign first transno bigger than last_committed. caller must hold imp-&gt;imp_lock </p>

<p>Definition at line <a class="el" href="client_8c_source.html#l02626">2626</a> of file <a class="el" href="client_8c_source.html">client.c</a>.</p>

<p>References <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="lustre__import_8h_source.html#l00195">obd_import::imp_committed_list</a>, <a class="el" href="lustre__import_8h_source.html#l00237">obd_import::imp_generation</a>, <a class="el" href="lustre__import_8h_source.html#l00244">obd_import::imp_last_generation_checked</a>, <a class="el" href="lustre__import_8h_source.html#l00255">obd_import::imp_last_transno_checked</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="lustre__import_8h_source.html#l00248">obd_import::imp_peer_committed_transno</a>, <a class="el" href="lustre__import_8h_source.html#l00183">obd_import::imp_replay_list</a>, <a class="el" href="lustre__net_8h_source.html#l00968">ptlrpc_request::rq_replay</a>, <a class="el" href="lustre__net_8h_source.html#l01045">ptlrpc_request::rq_replay_list</a>, and <a class="el" href="lustre__net_8h_source.html#l01034">ptlrpc_request::rq_transno</a>.</p>

<p>Referenced by <a class="el" href="client_8c_source.html#l03045">ptlrpc_abort_inflight()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02627"></a>02627 {
<a name="l02628"></a>02628         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *req, *saved;
<a name="l02629"></a>02629         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *last_req = NULL; <span class="comment">/* temporary fire escape */</span>
<a name="l02630"></a>02630         <span class="keywordtype">bool</span>                     skip_committed_list = <span class="keyword">true</span>;
<a name="l02631"></a>02631         ENTRY;
<a name="l02632"></a>02632 
<a name="l02633"></a>02633         LASSERT(imp != NULL);
<a name="l02634"></a>02634         assert_spin_locked(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l02635"></a>02635 
<a name="l02636"></a>02636         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a> == imp-&gt;<a class="code" href="structobd__import.html#a3211da741142c7d7c6997a88825ab6da">imp_last_transno_checked</a> &amp;&amp;
<a name="l02637"></a>02637             imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a> == imp-&gt;<a class="code" href="structobd__import.html#a53945e09c13c835d35ac9c6a4e4c8b5a">imp_last_generation_checked</a>) {
<a name="l02638"></a>02638                 CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: skip recheck: last_committed &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l02639"></a>02639                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name, imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>);
<a name="l02640"></a>02640                 RETURN_EXIT;
<a name="l02641"></a>02641         }
<a name="l02642"></a>02642         CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;%s: committing for last_committed &quot;</span>LPU64<span class="stringliteral">&quot; gen %d\n&quot;</span>,
<a name="l02643"></a>02643                imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name, imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>,
<a name="l02644"></a>02644                imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>);
<a name="l02645"></a>02645 
<a name="l02646"></a>02646         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a> != imp-&gt;<a class="code" href="structobd__import.html#a53945e09c13c835d35ac9c6a4e4c8b5a">imp_last_generation_checked</a> ||
<a name="l02647"></a>02647             imp-&gt;<a class="code" href="structobd__import.html#a3211da741142c7d7c6997a88825ab6da">imp_last_transno_checked</a> == 0)
<a name="l02648"></a>02648                 skip_committed_list = <span class="keyword">false</span>;
<a name="l02649"></a>02649 
<a name="l02650"></a>02650         imp-&gt;<a class="code" href="structobd__import.html#a3211da741142c7d7c6997a88825ab6da">imp_last_transno_checked</a> = imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>;
<a name="l02651"></a>02651         imp-&gt;<a class="code" href="structobd__import.html#a53945e09c13c835d35ac9c6a4e4c8b5a">imp_last_generation_checked</a> = imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>;
<a name="l02652"></a>02652 
<a name="l02653"></a>02653         list_for_each_entry_safe(req, saved, &amp;imp-&gt;<a class="code" href="structobd__import.html#ae3f32574c5a9b068001d451c8506ef7b" title="Lists of requests that are retained for replay, waiting for a reply, or waiting for...">imp_replay_list</a>,
<a name="l02654"></a>02654                                      <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>) {
<a name="l02655"></a>02655                 <span class="comment">/* XXX ok to remove when 1357 resolved - rread 05/29/03  */</span>
<a name="l02656"></a>02656                 LASSERT(req != last_req);
<a name="l02657"></a>02657                 last_req = req;
<a name="l02658"></a>02658 
<a name="l02659"></a>02659                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> == 0) {
<a name="l02660"></a>02660                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_EMERG, req, <span class="stringliteral">&quot;zero transno during replay&quot;</span>);
<a name="l02661"></a>02661                         LBUG();
<a name="l02662"></a>02662                 }
<a name="l02663"></a>02663                 <span class="keywordflow">if</span> (req-&gt;rq_import_generation &lt; imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>) {
<a name="l02664"></a>02664                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;free request with old gen&quot;</span>);
<a name="l02665"></a>02665                         GOTO(free_req, 0);
<a name="l02666"></a>02666                 }
<a name="l02667"></a>02667 
<a name="l02668"></a>02668                 <span class="comment">/* not yet committed */</span>
<a name="l02669"></a>02669                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> &gt; imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>) {
<a name="l02670"></a>02670                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;stopping search&quot;</span>);
<a name="l02671"></a>02671                         <span class="keywordflow">break</span>;
<a name="l02672"></a>02672                 }
<a name="l02673"></a>02673 
<a name="l02674"></a>02674                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ae9b053a81331ff81f4568df30b253bf0" title="when -&amp;gt;rq_replay is set, request is kept by the client even after server commits...">rq_replay</a>) {
<a name="l02675"></a>02675                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;keeping (FL_REPLAY)&quot;</span>);
<a name="l02676"></a>02676                         list_move_tail(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>,
<a name="l02677"></a>02677                                            &amp;imp-&gt;<a class="code" href="structobd__import.html#a05271cb9def4ce64191d4d7089fa831c" title="List of requests that are retained for committed open replay.">imp_committed_list</a>);
<a name="l02678"></a>02678                         <span class="keywordflow">continue</span>;
<a name="l02679"></a>02679                 }
<a name="l02680"></a>02680 
<a name="l02681"></a>02681                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_INFO, req, <span class="stringliteral">&quot;commit (last_committed &quot;</span>LPU64<span class="stringliteral">&quot;)&quot;</span>,
<a name="l02682"></a>02682                           imp-&gt;<a class="code" href="structobd__import.html#a386b654673fa0ed7ef5a1ea90bd0a0cb" title="Last transno committed on remote side.">imp_peer_committed_transno</a>);
<a name="l02683"></a>02683 free_req:
<a name="l02684"></a>02684                 ptlrpc_free_request(req);
<a name="l02685"></a>02685         }
<a name="l02686"></a>02686 
<a name="l02687"></a>02687         <span class="keywordflow">if</span> (skip_committed_list)
<a name="l02688"></a>02688                 GOTO(out, 0);
<a name="l02689"></a>02689 
<a name="l02690"></a>02690         list_for_each_entry_safe(req, saved, &amp;imp-&gt;<a class="code" href="structobd__import.html#a05271cb9def4ce64191d4d7089fa831c" title="List of requests that are retained for committed open replay.">imp_committed_list</a>,
<a name="l02691"></a>02691                                      <a class="code" href="structptlrpc__request.html#a34521a5a283777b7d82b9bdaded0b329" title="List item to for replay list.">rq_replay_list</a>) {
<a name="l02692"></a>02692                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a> != 0);
<a name="l02693"></a>02693                 <span class="keywordflow">if</span> (req-&gt;rq_import_generation &lt; imp-&gt;<a class="code" href="structobd__import.html#a37ffba6837dd8612475a9ea4d5bb939c" title="Current import generation.">imp_generation</a>) {
<a name="l02694"></a>02694                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;free stale open request&quot;</span>);
<a name="l02695"></a>02695                         ptlrpc_free_request(req);
<a name="l02696"></a>02696                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!req-&gt;<a class="code" href="structptlrpc__request.html#ae9b053a81331ff81f4568df30b253bf0" title="when -&amp;gt;rq_replay is set, request is kept by the client even after server commits...">rq_replay</a>) {
<a name="l02697"></a>02697                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_RPCTRACE, req, <span class="stringliteral">&quot;free closed open request&quot;</span>);
<a name="l02698"></a>02698                         ptlrpc_free_request(req);
<a name="l02699"></a>02699                 }
<a name="l02700"></a>02700         }
<a name="l02701"></a>02701 out:
<a name="l02702"></a>02702         EXIT;
<a name="l02703"></a>02703 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__ha_ga1201e450853aba39256bafedcfae7f11_icgraph.png" border="0" usemap="#group__ha_ga1201e450853aba39256bafedcfae7f11_icgraph_map" alt=""></div>
<map name="group__ha_ga1201e450853aba39256bafedcfae7f11_icgraph_map" id="group__ha_ga1201e450853aba39256bafedcfae7f11_icgraph">
<area shape="rect" id="node3" href="group__net.html#gaebf74d120543fbad3a68316dc1a5c97c" title="Aborts all in&#45;flight request on import imp sending and delayed lists." alt="" coords="232,5,389,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf20ae4ef40ab6633e816a6b842697203"></a><!-- doxytag: member="lustre_ha.h::ptlrpc_resend" ref="gaf20ae4ef40ab6633e816a6b842697203" args="(struct obd_import *imp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_resend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule resending of request on sending_list. </p>
<p>This is done after we completed replaying of requests and locks. </p>

<p>Definition at line <a class="el" href="recover_8c_source.html#l00196">196</a> of file <a class="el" href="recover_8c_source.html">recover.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00230">obd_import::imp_state</a>, and <a class="el" href="lustre__net_8h_source.html#l00962">ptlrpc_request::rq_list</a>.</p>

<p>Referenced by <a class="el" href="import_8c_source.html#l01449">ptlrpc_import_recovery_state_machine()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00197"></a>00197 {
<a name="l00198"></a>00198         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, *next;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         ENTRY;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="comment">/* As long as we&apos;re in recovery, nothing should be added to the sending</span>
<a name="l00203"></a>00203 <span class="comment">         * list, so we don&apos;t need to hold the lock during this iteration and</span>
<a name="l00204"></a>00204 <span class="comment">         * resend process.</span>
<a name="l00205"></a>00205 <span class="comment">         */</span>
<a name="l00206"></a>00206         <span class="comment">/* Well... what if lctl recover is called twice at the same time?</span>
<a name="l00207"></a>00207 <span class="comment">         */</span>
<a name="l00208"></a>00208         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00209"></a>00209         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a> != LUSTRE_IMP_RECOVER) {
<a name="l00210"></a>00210                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00211"></a>00211                 RETURN(-1);
<a name="l00212"></a>00212         }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         list_for_each_entry_safe(req, next, &amp;imp-&gt;imp_sending_list, <a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>) {
<a name="l00215"></a>00215                 LASSERTF((<span class="keywordtype">long</span>)req &gt; PAGE_CACHE_SIZE &amp;&amp; req != LP_POISON,
<a name="l00216"></a>00216                          <span class="stringliteral">&quot;req %p bad\n&quot;</span>, req);
<a name="l00217"></a>00217                 LASSERTF(req-&gt;rq_type != LI_POISON, <span class="stringliteral">&quot;req %p freed\n&quot;</span>, req);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219                 <span class="comment">/* If the request is allowed to be sent during replay and it</span>
<a name="l00220"></a>00220 <span class="comment">                 * is not timeout yet, then it does not need to be resent. */</span>
<a name="l00221"></a>00221                 <span class="keywordflow">if</span> (!ptlrpc_no_resend(req) &amp;&amp;
<a name="l00222"></a>00222                     (req-&gt;rq_timedout || !req-&gt;rq_allow_replay))
<a name="l00223"></a>00223                         ptlrpc_resend_req(req);
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227         RETURN(0);
<a name="l00228"></a>00228 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__ha_gaf20ae4ef40ab6633e816a6b842697203_icgraph.png" border="0" usemap="#group__ha_gaf20ae4ef40ab6633e816a6b842697203_icgraph_map" alt=""></div>
<map name="group__ha_gaf20ae4ef40ab6633e816a6b842697203_icgraph_map" id="group__ha_gaf20ae4ef40ab6633e816a6b842697203_icgraph">
<area shape="rect" id="node3" href="group__net.html#gae24ff0ea3f19794b41cb4da94ffa9ce2" title="This is the state machine for client&#45;side recovery on import." alt="" coords="168,5,456,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa5fa7cae0d8f72e02ff80fa961723668"></a><!-- doxytag: member="lustre_ha.h::ptlrpc_set_import_active" ref="gaa5fa7cae0d8f72e02ff80fa961723668" args="(struct obd_import *imp, int active)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_set_import_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>active</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Administratively active/deactive a client. </p>
<p>This should only be called by the ioctl interface, currently</p>
<ul>
<li>the lctl deactivate and activate commands</li>
<li>echo 0/1 &gt;&gt; /proc/osc/XXX/active</li>
<li>client umount -f (ll_umount_begin) </li>
</ul>

<p>Definition at line <a class="el" href="recover_8c_source.html#l00290">290</a> of file <a class="el" href="recover_8c_source.html">recover.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, and <a class="el" href="import_8c_source.html#l00286">ptlrpc_invalidate_import()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00291"></a>00291 {
<a name="l00292"></a>00292         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd = imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>;
<a name="l00293"></a>00293         <span class="keywordtype">int</span> rc = 0;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295         ENTRY;
<a name="l00296"></a>00296         LASSERT(obd);
<a name="l00297"></a>00297 
<a name="l00298"></a>00298         <span class="comment">/* When deactivating, mark import invalid, and abort in-flight</span>
<a name="l00299"></a>00299 <span class="comment">         * requests. */</span>
<a name="l00300"></a>00300         <span class="keywordflow">if</span> (!active) {
<a name="l00301"></a>00301                 LCONSOLE_WARN(<span class="stringliteral">&quot;setting import %s INACTIVE by administrator &quot;</span>
<a name="l00302"></a>00302                               <span class="stringliteral">&quot;request\n&quot;</span>, obd2cli_tgt(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>));
<a name="l00303"></a>00303 
<a name="l00304"></a>00304                 <span class="comment">/* set before invalidate to avoid messages about imp_inval</span>
<a name="l00305"></a>00305 <span class="comment">                 * set without imp_deactive in ptlrpc_import_delay_req */</span>
<a name="l00306"></a>00306                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00307"></a>00307                 imp-&gt;imp_deactive = 1;
<a name="l00308"></a>00308                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310                 <a class="code" href="group__export.html#ga25e24f2ae3efcc8caa89c9e6c4c47d31" title="List of import event types.">obd_import_event</a>(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>, imp, IMP_EVENT_DEACTIVATE);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312                 <a class="code" href="group__ha.html#ga5301cdfd160cb1e18f119fbc8fac3252" title="This function will invalidate the import, if necessary, then block for all the RPC...">ptlrpc_invalidate_import</a>(imp);
<a name="l00313"></a>00313         }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315         <span class="comment">/* When activating, mark import valid, and attempt recovery */</span>
<a name="l00316"></a>00316         <span class="keywordflow">if</span> (active) {
<a name="l00317"></a>00317                 CDEBUG(D_HA, <span class="stringliteral">&quot;setting import %s VALID\n&quot;</span>,
<a name="l00318"></a>00318                        obd2cli_tgt(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>));
<a name="l00319"></a>00319 
<a name="l00320"></a>00320                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00321"></a>00321                 imp-&gt;imp_deactive = 0;
<a name="l00322"></a>00322                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00323"></a>00323                 <a class="code" href="group__export.html#ga25e24f2ae3efcc8caa89c9e6c4c47d31" title="List of import event types.">obd_import_event</a>(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>, imp, IMP_EVENT_ACTIVATE);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325                 rc = ptlrpc_recover_import(imp, NULL, 0);
<a name="l00326"></a>00326         }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328         RETURN(rc);
<a name="l00329"></a>00329 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__ha_gaa5fa7cae0d8f72e02ff80fa961723668_cgraph.png" border="0" usemap="#group__ha_gaa5fa7cae0d8f72e02ff80fa961723668_cgraph_map" alt=""></div>
<map name="group__ha_gaa5fa7cae0d8f72e02ff80fa961723668_cgraph_map" id="group__ha_gaa5fa7cae0d8f72e02ff80fa961723668_cgraph">
<area shape="rect" id="node3" href="group__ha.html#ga5301cdfd160cb1e18f119fbc8fac3252" title="This function will invalidate the import, if necessary, then block for all the RPC..." alt="" coords="245,5,429,35"/></map>
</div>
</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:43 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
