<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/include/lustre_sec.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/include/lustre_sec.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2012, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> */</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#ifndef _LUSTRE_SEC_H_</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#define _LUSTRE_SEC_H_</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="comment">/*</span>
<a name="l00046"></a>00046 <span class="comment"> * to avoid include</span>
<a name="l00047"></a>00047 <span class="comment"> */</span>
<a name="l00048"></a>00048 <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a>;
<a name="l00049"></a>00049 <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>;
<a name="l00050"></a>00050 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>;
<a name="l00051"></a>00051 <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>;
<a name="l00052"></a>00052 <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a>;
<a name="l00053"></a>00053 <span class="keyword">struct </span><a class="code" href="structbrw__page.html">brw_page</a>;
<a name="l00054"></a>00054 <span class="comment">/* Linux specific */</span>
<a name="l00055"></a>00055 <span class="keyword">struct </span>key;
<a name="l00056"></a>00056 <span class="keyword">struct </span>seq_file;
<a name="l00057"></a>00057 <span class="keyword">struct </span><a class="code" href="structlustre__cfg.html">lustre_cfg</a>;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="comment">/*</span>
<a name="l00060"></a>00060 <span class="comment"> * forward declaration</span>
<a name="l00061"></a>00061 <span class="comment"> */</span>
<a name="l00062"></a>00062 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a>;
<a name="l00063"></a>00063 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__cops.html" title="client side policy operation vector.">ptlrpc_sec_cops</a>;
<a name="l00064"></a>00064 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__sops.html" title="server side policy operation vector.">ptlrpc_sec_sops</a>;
<a name="l00065"></a>00065 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>;
<a name="l00066"></a>00066 <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a>;
<a name="l00067"></a>00067 <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>;
<a name="l00068"></a>00068 <span class="keyword">struct </span><a class="code" href="structptlrpc__ctx__ops.html">ptlrpc_ctx_ops</a>;
<a name="l00069"></a>00069 
<a name="l00084"></a>00084 <span class="comment">/*</span>
<a name="l00085"></a>00085 <span class="comment"> * flavor constants</span>
<a name="l00086"></a>00086 <span class="comment"> */</span>
<a name="l00087"></a>00087 <span class="keyword">enum</span> sptlrpc_policy {
<a name="l00088"></a>00088         SPTLRPC_POLICY_NULL             = 0,
<a name="l00089"></a>00089         SPTLRPC_POLICY_PLAIN            = 1,
<a name="l00090"></a>00090         SPTLRPC_POLICY_GSS              = 2,
<a name="l00091"></a>00091         SPTLRPC_POLICY_MAX,
<a name="l00092"></a>00092 };
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="keyword">enum</span> sptlrpc_mech_null {
<a name="l00095"></a>00095         SPTLRPC_MECH_NULL               = 0,
<a name="l00096"></a>00096         SPTLRPC_MECH_NULL_MAX,
<a name="l00097"></a>00097 };
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="keyword">enum</span> sptlrpc_mech_plain {
<a name="l00100"></a>00100         SPTLRPC_MECH_PLAIN              = 0,
<a name="l00101"></a>00101         SPTLRPC_MECH_PLAIN_MAX,
<a name="l00102"></a>00102 };
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="keyword">enum</span> sptlrpc_mech_gss {
<a name="l00105"></a>00105         SPTLRPC_MECH_GSS_NULL           = 0,
<a name="l00106"></a>00106         SPTLRPC_MECH_GSS_KRB5           = 1,
<a name="l00107"></a>00107         SPTLRPC_MECH_GSS_SK             = 2,
<a name="l00108"></a>00108         SPTLRPC_MECH_GSS_MAX,
<a name="l00109"></a>00109 };
<a name="l00110"></a>00110 
<a name="l00111"></a><a class="code" href="group__flavor.html#gab48fb51b4fb60d481bc12e344e73df3a">00111</a> <span class="keyword">enum</span> <a class="code" href="group__flavor.html#gab48fb51b4fb60d481bc12e344e73df3a">sptlrpc_service_type</a> {
<a name="l00112"></a><a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa9962cb9ccc8b90b4c67ada0e7b00210b">00112</a>         <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa9962cb9ccc8b90b4c67ada0e7b00210b" title="no security">SPTLRPC_SVC_NULL</a>                = 0,    
<a name="l00113"></a><a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa691acc99dba7191db4f6c2e177331e30">00113</a>         <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa691acc99dba7191db4f6c2e177331e30" title="authentication only">SPTLRPC_SVC_AUTH</a>                = 1,    
<a name="l00114"></a><a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa74b1cc494dcf8dbf001b3a19e8790fd9">00114</a>         <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa74b1cc494dcf8dbf001b3a19e8790fd9" title="integrity">SPTLRPC_SVC_INTG</a>                = 2,    
<a name="l00115"></a><a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa1baf868991ad935c71ceb65c53389564">00115</a>         <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa1baf868991ad935c71ceb65c53389564" title="privacy">SPTLRPC_SVC_PRIV</a>                = 3,    
<a name="l00116"></a>00116         SPTLRPC_SVC_MAX,
<a name="l00117"></a>00117 };
<a name="l00118"></a>00118 
<a name="l00119"></a><a class="code" href="group__flavor.html#gad2835bbbaf785453306bfed7eaaf415b">00119</a> <span class="keyword">enum</span> <a class="code" href="group__flavor.html#gad2835bbbaf785453306bfed7eaaf415b">sptlrpc_bulk_type</a> {
<a name="l00120"></a><a class="code" href="group__flavor.html#ggad2835bbbaf785453306bfed7eaaf415ba1e3a31888a9fc5589a0ebe72b5633c32">00120</a>         <a class="code" href="group__flavor.html#ggad2835bbbaf785453306bfed7eaaf415ba1e3a31888a9fc5589a0ebe72b5633c32" title="follow rpc flavor">SPTLRPC_BULK_DEFAULT</a>            = 0,    
<a name="l00121"></a><a class="code" href="group__flavor.html#ggad2835bbbaf785453306bfed7eaaf415ba038f8794055f24035774f29b7acf902e">00121</a>         <a class="code" href="group__flavor.html#ggad2835bbbaf785453306bfed7eaaf415ba038f8794055f24035774f29b7acf902e" title="hash integrity">SPTLRPC_BULK_HASH</a>               = 1,    
<a name="l00122"></a>00122         SPTLRPC_BULK_MAX,
<a name="l00123"></a>00123 };
<a name="l00124"></a>00124 
<a name="l00125"></a><a class="code" href="group__flavor.html#ga475c572a7bfc33daec9df01be01b3d4f">00125</a> <span class="keyword">enum</span> <a class="code" href="group__flavor.html#ga475c572a7bfc33daec9df01be01b3d4f">sptlrpc_bulk_service</a> {
<a name="l00126"></a><a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4fa77b1660050aa8df70047fcd9debca29e">00126</a>         <a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4fa77b1660050aa8df70047fcd9debca29e" title="no security">SPTLRPC_BULK_SVC_NULL</a>           = 0,    
<a name="l00127"></a><a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4faafdeaba74d14434a5bef69bead463f47">00127</a>         <a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4faafdeaba74d14434a5bef69bead463f47" title="authentication only">SPTLRPC_BULK_SVC_AUTH</a>           = 1,    
<a name="l00128"></a><a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4faec306d681efa1995b008526cfa7500a4">00128</a>         <a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4faec306d681efa1995b008526cfa7500a4" title="integrity">SPTLRPC_BULK_SVC_INTG</a>           = 2,    
<a name="l00129"></a><a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4fae3bae4ed551d3148b1742dcd88cfc7f8">00129</a>         <a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4fae3bae4ed551d3148b1742dcd88cfc7f8" title="privacy">SPTLRPC_BULK_SVC_PRIV</a>           = 3,    
<a name="l00130"></a>00130         SPTLRPC_BULK_SVC_MAX,
<a name="l00131"></a>00131 };
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="comment">/*</span>
<a name="l00134"></a>00134 <span class="comment"> * compose/extract macros</span>
<a name="l00135"></a>00135 <span class="comment"> */</span>
<a name="l00136"></a>00136 <span class="preprocessor">#define FLVR_POLICY_OFFSET              (0)</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#define FLVR_MECH_OFFSET                (4)</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span><span class="preprocessor">#define FLVR_SVC_OFFSET                 (8)</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor">#define FLVR_BULK_TYPE_OFFSET           (12)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#define FLVR_BULK_SVC_OFFSET            (16)</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span>
<a name="l00142"></a>00142 <span class="preprocessor">#define MAKE_FLVR(policy, mech, svc, btype, bsvc)                       \</span>
<a name="l00143"></a>00143 <span class="preprocessor">        (((__u32)(policy) &lt;&lt; FLVR_POLICY_OFFSET) |                      \</span>
<a name="l00144"></a>00144 <span class="preprocessor">         ((__u32)(mech) &lt;&lt; FLVR_MECH_OFFSET) |                          \</span>
<a name="l00145"></a>00145 <span class="preprocessor">         ((__u32)(svc) &lt;&lt; FLVR_SVC_OFFSET) |                            \</span>
<a name="l00146"></a>00146 <span class="preprocessor">         ((__u32)(btype) &lt;&lt; FLVR_BULK_TYPE_OFFSET) |                    \</span>
<a name="l00147"></a>00147 <span class="preprocessor">         ((__u32)(bsvc) &lt;&lt; FLVR_BULK_SVC_OFFSET))</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span>
<a name="l00149"></a>00149 <span class="comment">/*</span>
<a name="l00150"></a>00150 <span class="comment"> * extraction</span>
<a name="l00151"></a>00151 <span class="comment"> */</span>
<a name="l00152"></a>00152 <span class="preprocessor">#define SPTLRPC_FLVR_POLICY(flavor)                                     \</span>
<a name="l00153"></a>00153 <span class="preprocessor">        ((((__u32)(flavor)) &gt;&gt; FLVR_POLICY_OFFSET) &amp; 0xF)</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_MECH(flavor)                                       \</span>
<a name="l00155"></a>00155 <span class="preprocessor">        ((((__u32)(flavor)) &gt;&gt; FLVR_MECH_OFFSET) &amp; 0xF)</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_SVC(flavor)                                        \</span>
<a name="l00157"></a>00157 <span class="preprocessor">        ((((__u32)(flavor)) &gt;&gt; FLVR_SVC_OFFSET) &amp; 0xF)</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_BULK_TYPE(flavor)                                  \</span>
<a name="l00159"></a>00159 <span class="preprocessor">        ((((__u32)(flavor)) &gt;&gt; FLVR_BULK_TYPE_OFFSET) &amp; 0xF)</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_BULK_SVC(flavor)                                   \</span>
<a name="l00161"></a>00161 <span class="preprocessor">        ((((__u32)(flavor)) &gt;&gt; FLVR_BULK_SVC_OFFSET) &amp; 0xF)</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span>
<a name="l00163"></a>00163 <span class="preprocessor">#define SPTLRPC_FLVR_BASE(flavor)                                       \</span>
<a name="l00164"></a>00164 <span class="preprocessor">        ((((__u32)(flavor)) &gt;&gt; FLVR_POLICY_OFFSET) &amp; 0xFFF)</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_BASE_SUB(flavor)                                   \</span>
<a name="l00166"></a>00166 <span class="preprocessor">        ((((__u32)(flavor)) &gt;&gt; FLVR_MECH_OFFSET) &amp; 0xFF)</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span>
<a name="l00168"></a>00168 <span class="comment">/*</span>
<a name="l00169"></a>00169 <span class="comment"> * gss subflavors</span>
<a name="l00170"></a>00170 <span class="comment"> */</span>
<a name="l00171"></a>00171 <span class="preprocessor">#define MAKE_BASE_SUBFLVR(mech, svc)                                    \</span>
<a name="l00172"></a>00172 <span class="preprocessor">        ((__u32)(mech) |                                                \</span>
<a name="l00173"></a>00173 <span class="preprocessor">         ((__u32)(svc) &lt;&lt; (FLVR_SVC_OFFSET - FLVR_MECH_OFFSET)))</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span>
<a name="l00175"></a>00175 <span class="preprocessor">#define SPTLRPC_SUBFLVR_GSSNULL                                         \</span>
<a name="l00176"></a>00176 <span class="preprocessor">        MAKE_BASE_SUBFLVR(SPTLRPC_MECH_GSS_NULL, SPTLRPC_SVC_NULL)</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_SUBFLVR_KRB5N                                           \</span>
<a name="l00178"></a>00178 <span class="preprocessor">        MAKE_BASE_SUBFLVR(SPTLRPC_MECH_GSS_KRB5, SPTLRPC_SVC_NULL)</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_SUBFLVR_KRB5A                                           \</span>
<a name="l00180"></a>00180 <span class="preprocessor">        MAKE_BASE_SUBFLVR(SPTLRPC_MECH_GSS_KRB5, SPTLRPC_SVC_AUTH)</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_SUBFLVR_KRB5I                                           \</span>
<a name="l00182"></a>00182 <span class="preprocessor">        MAKE_BASE_SUBFLVR(SPTLRPC_MECH_GSS_KRB5, SPTLRPC_SVC_INTG)</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_SUBFLVR_KRB5P                                           \</span>
<a name="l00184"></a>00184 <span class="preprocessor">        MAKE_BASE_SUBFLVR(SPTLRPC_MECH_GSS_KRB5, SPTLRPC_SVC_PRIV)</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_SUBFLVR_SKI                                             \</span>
<a name="l00186"></a>00186 <span class="preprocessor">        MAKE_BASE_SUBFLVR(SPTLRPC_MECH_GSS_SK, SPTLRPC_SVC_INTG)</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_SUBFLVR_SKPI                                            \</span>
<a name="l00188"></a>00188 <span class="preprocessor">        MAKE_BASE_SUBFLVR(SPTLRPC_MECH_GSS_SK, SPTLRPC_SVC_PRIV)</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span>
<a name="l00190"></a>00190 <span class="comment">/*</span>
<a name="l00191"></a>00191 <span class="comment"> * &quot;end user&quot; flavors</span>
<a name="l00192"></a>00192 <span class="comment"> */</span>
<a name="l00193"></a>00193 <span class="preprocessor">#define SPTLRPC_FLVR_NULL                               \</span>
<a name="l00194"></a>00194 <span class="preprocessor">        MAKE_FLVR(SPTLRPC_POLICY_NULL,                  \</span>
<a name="l00195"></a>00195 <span class="preprocessor">                  SPTLRPC_MECH_NULL,                    \</span>
<a name="l00196"></a>00196 <span class="preprocessor">                  SPTLRPC_SVC_NULL,                     \</span>
<a name="l00197"></a>00197 <span class="preprocessor">                  SPTLRPC_BULK_DEFAULT,                 \</span>
<a name="l00198"></a>00198 <span class="preprocessor">                  SPTLRPC_BULK_SVC_NULL)</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_PLAIN                              \</span>
<a name="l00200"></a>00200 <span class="preprocessor">        MAKE_FLVR(SPTLRPC_POLICY_PLAIN,                 \</span>
<a name="l00201"></a>00201 <span class="preprocessor">                  SPTLRPC_MECH_PLAIN,                   \</span>
<a name="l00202"></a>00202 <span class="preprocessor">                  SPTLRPC_SVC_NULL,                     \</span>
<a name="l00203"></a>00203 <span class="preprocessor">                  SPTLRPC_BULK_HASH,                    \</span>
<a name="l00204"></a>00204 <span class="preprocessor">                  SPTLRPC_BULK_SVC_INTG)</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_GSSNULL                            \</span>
<a name="l00206"></a>00206 <span class="preprocessor">        MAKE_FLVR(SPTLRPC_POLICY_GSS,                   \</span>
<a name="l00207"></a>00207 <span class="preprocessor">                  SPTLRPC_MECH_GSS_NULL,                \</span>
<a name="l00208"></a>00208 <span class="preprocessor">                  SPTLRPC_SVC_NULL,                     \</span>
<a name="l00209"></a>00209 <span class="preprocessor">                  SPTLRPC_BULK_DEFAULT,                 \</span>
<a name="l00210"></a>00210 <span class="preprocessor">                  SPTLRPC_BULK_SVC_NULL)</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_KRB5N                              \</span>
<a name="l00212"></a>00212 <span class="preprocessor">        MAKE_FLVR(SPTLRPC_POLICY_GSS,                   \</span>
<a name="l00213"></a>00213 <span class="preprocessor">                  SPTLRPC_MECH_GSS_KRB5,                \</span>
<a name="l00214"></a>00214 <span class="preprocessor">                  SPTLRPC_SVC_NULL,                     \</span>
<a name="l00215"></a>00215 <span class="preprocessor">                  SPTLRPC_BULK_DEFAULT,                 \</span>
<a name="l00216"></a>00216 <span class="preprocessor">                  SPTLRPC_BULK_SVC_NULL)</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_KRB5A                              \</span>
<a name="l00218"></a>00218 <span class="preprocessor">        MAKE_FLVR(SPTLRPC_POLICY_GSS,                   \</span>
<a name="l00219"></a>00219 <span class="preprocessor">                  SPTLRPC_MECH_GSS_KRB5,                \</span>
<a name="l00220"></a>00220 <span class="preprocessor">                  SPTLRPC_SVC_AUTH,                     \</span>
<a name="l00221"></a>00221 <span class="preprocessor">                  SPTLRPC_BULK_DEFAULT,                 \</span>
<a name="l00222"></a>00222 <span class="preprocessor">                  SPTLRPC_BULK_SVC_NULL)</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_KRB5I                              \</span>
<a name="l00224"></a>00224 <span class="preprocessor">        MAKE_FLVR(SPTLRPC_POLICY_GSS,                   \</span>
<a name="l00225"></a>00225 <span class="preprocessor">                  SPTLRPC_MECH_GSS_KRB5,                \</span>
<a name="l00226"></a>00226 <span class="preprocessor">                  SPTLRPC_SVC_INTG,                     \</span>
<a name="l00227"></a>00227 <span class="preprocessor">                  SPTLRPC_BULK_DEFAULT,                 \</span>
<a name="l00228"></a>00228 <span class="preprocessor">                  SPTLRPC_BULK_SVC_INTG)</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_KRB5P                              \</span>
<a name="l00230"></a>00230 <span class="preprocessor">        MAKE_FLVR(SPTLRPC_POLICY_GSS,                   \</span>
<a name="l00231"></a>00231 <span class="preprocessor">                  SPTLRPC_MECH_GSS_KRB5,                \</span>
<a name="l00232"></a>00232 <span class="preprocessor">                  SPTLRPC_SVC_PRIV,                     \</span>
<a name="l00233"></a>00233 <span class="preprocessor">                  SPTLRPC_BULK_DEFAULT,                 \</span>
<a name="l00234"></a>00234 <span class="preprocessor">                  SPTLRPC_BULK_SVC_PRIV)</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_SKI                                \</span>
<a name="l00236"></a>00236 <span class="preprocessor">        MAKE_FLVR(SPTLRPC_POLICY_GSS,                   \</span>
<a name="l00237"></a>00237 <span class="preprocessor">                  SPTLRPC_MECH_GSS_SK,                  \</span>
<a name="l00238"></a>00238 <span class="preprocessor">                  SPTLRPC_SVC_INTG,                     \</span>
<a name="l00239"></a>00239 <span class="preprocessor">                  SPTLRPC_BULK_DEFAULT,                 \</span>
<a name="l00240"></a>00240 <span class="preprocessor">                  SPTLRPC_BULK_SVC_PRIV)</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_SKPI                               \</span>
<a name="l00242"></a>00242 <span class="preprocessor">        MAKE_FLVR(SPTLRPC_POLICY_GSS,                   \</span>
<a name="l00243"></a>00243 <span class="preprocessor">                  SPTLRPC_MECH_GSS_SK,                  \</span>
<a name="l00244"></a>00244 <span class="preprocessor">                  SPTLRPC_SVC_PRIV,                     \</span>
<a name="l00245"></a>00245 <span class="preprocessor">                  SPTLRPC_BULK_DEFAULT,                 \</span>
<a name="l00246"></a>00246 <span class="preprocessor">                  SPTLRPC_BULK_SVC_PRIV)</span>
<a name="l00247"></a>00247 <span class="preprocessor"></span>
<a name="l00248"></a>00248 <span class="preprocessor">#define SPTLRPC_FLVR_DEFAULT            SPTLRPC_FLVR_NULL</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span>
<a name="l00250"></a>00250 <span class="preprocessor">#define SPTLRPC_FLVR_INVALID            ((__u32) 0xFFFFFFFF)</span>
<a name="l00251"></a>00251 <span class="preprocessor"></span><span class="preprocessor">#define SPTLRPC_FLVR_ANY                ((__u32) 0xFFF00000)</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>
<a name="l00256"></a><a class="code" href="group__flavor.html#ga7746f840ac0ba4799482883ea5719881">00256</a> <span class="preprocessor">#define WIRE_FLVR(wflvr)                (((__u32) (wflvr)) &amp; 0x000FFFFF)</span>
<a name="l00257"></a>00257 <span class="preprocessor"></span>
<a name="l00260"></a>00260 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> flvr_set_svc(__u32 *flvr, __u32 svc)
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262         LASSERT(svc &lt; SPTLRPC_SVC_MAX);
<a name="l00263"></a>00263         *flvr = MAKE_FLVR(SPTLRPC_FLVR_POLICY(*flvr),
<a name="l00264"></a>00264                           SPTLRPC_FLVR_MECH(*flvr),
<a name="l00265"></a>00265                           svc,
<a name="l00266"></a>00266                           SPTLRPC_FLVR_BULK_TYPE(*flvr),
<a name="l00267"></a>00267                           SPTLRPC_FLVR_BULK_SVC(*flvr));
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> flvr_set_bulk_svc(__u32 *flvr, __u32 svc)
<a name="l00271"></a>00271 {
<a name="l00272"></a>00272         LASSERT(svc &lt; SPTLRPC_BULK_SVC_MAX);
<a name="l00273"></a>00273         *flvr = MAKE_FLVR(SPTLRPC_FLVR_POLICY(*flvr),
<a name="l00274"></a>00274                           SPTLRPC_FLVR_MECH(*flvr),
<a name="l00275"></a>00275                           SPTLRPC_FLVR_SVC(*flvr),
<a name="l00276"></a>00276                           SPTLRPC_FLVR_BULK_TYPE(*flvr),
<a name="l00277"></a>00277                           svc);
<a name="l00278"></a>00278 }
<a name="l00279"></a>00279 
<a name="l00280"></a><a class="code" href="structbulk__spec__hash.html">00280</a> <span class="keyword">struct </span><a class="code" href="structbulk__spec__hash.html">bulk_spec_hash</a> {
<a name="l00281"></a>00281         __u8    hash_alg;
<a name="l00282"></a>00282 };
<a name="l00283"></a>00283 
<a name="l00288"></a><a class="code" href="structsptlrpc__flavor.html">00288</a> <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> {
<a name="l00292"></a><a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7">00292</a>         __u32   <a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>;
<a name="l00296"></a><a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626">00296</a>         __u32   <a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a>;
<a name="l00300"></a>00300         <span class="keyword">union </span>{
<a name="l00301"></a>00301                 <span class="comment">/* nothing for now */</span>
<a name="l00302"></a>00302         } <a class="code" href="structsptlrpc__flavor.html#a35ce63f06f2b3c9ad324c029e529bf72" title="rpc flavor specification">u_rpc</a>;
<a name="l00306"></a>00306         <span class="keyword">union </span>{
<a name="l00307"></a>00307                 <span class="keyword">struct </span><a class="code" href="structbulk__spec__hash.html">bulk_spec_hash</a> hash;
<a name="l00308"></a>00308         } <a class="code" href="structsptlrpc__flavor.html#a0cec2e241f5c0d8a29621642f73d1a7c" title="bulk flavor specification">u_bulk</a>;
<a name="l00309"></a>00309 };
<a name="l00310"></a>00310 
<a name="l00315"></a><a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177">00315</a> <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a> {
<a name="l00316"></a>00316         LUSTRE_SP_CLI           = 0,
<a name="l00317"></a>00317         LUSTRE_SP_MDT,
<a name="l00318"></a>00318         LUSTRE_SP_OST,
<a name="l00319"></a>00319         LUSTRE_SP_MGC,
<a name="l00320"></a>00320         LUSTRE_SP_MGS,
<a name="l00321"></a>00321         LUSTRE_SP_ANY           = 0xFF
<a name="l00322"></a>00322 };
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="keyword">const</span> <span class="keywordtype">char</span> *sptlrpc_part2name(<span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a> sp);
<a name="l00325"></a>00325 <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a> sptlrpc_target_sec_part(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd);
<a name="l00326"></a>00326 
<a name="l00331"></a><a class="code" href="structsptlrpc__rule.html">00331</a> <span class="keyword">struct </span><a class="code" href="structsptlrpc__rule.html" title="A rule specifies a flavor to be used by a ptlrpc connection between two Lustre parts...">sptlrpc_rule</a> {
<a name="l00332"></a>00332         __u32                   sr_netid;   <span class="comment">/* LNET network ID */</span>
<a name="l00333"></a>00333         __u8                    sr_from;    <span class="comment">/* sec_part */</span>
<a name="l00334"></a>00334         __u8                    sr_to;      <span class="comment">/* sec_part */</span>
<a name="l00335"></a>00335         __u16                   sr_padding;
<a name="l00336"></a>00336         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a>   sr_flvr;
<a name="l00337"></a>00337 };
<a name="l00338"></a>00338 
<a name="l00345"></a><a class="code" href="structsptlrpc__rule__set.html">00345</a> <span class="keyword">struct </span><a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> {
<a name="l00346"></a>00346         <span class="keywordtype">int</span>                     srs_nslot;
<a name="l00347"></a>00347         <span class="keywordtype">int</span>                     srs_nrule;
<a name="l00348"></a>00348         <span class="keyword">struct </span><a class="code" href="structsptlrpc__rule.html" title="A rule specifies a flavor to be used by a ptlrpc connection between two Lustre parts...">sptlrpc_rule</a>    *srs_rules;
<a name="l00349"></a>00349 };
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 <span class="keywordtype">int</span> sptlrpc_parse_flavor(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *flvr);
<a name="l00352"></a>00352 <span class="keywordtype">int</span> sptlrpc_flavor_has_bulk(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *flvr);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> sptlrpc_rule_set_init(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *<span class="keyword">set</span>)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356         memset(<span class="keyword">set</span>, 0, <span class="keyword">sizeof</span>(*<span class="keyword">set</span>));
<a name="l00357"></a>00357 }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="keywordtype">void</span> sptlrpc_rule_set_free(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *<span class="keyword">set</span>);
<a name="l00360"></a>00360 <span class="keywordtype">int</span>  sptlrpc_rule_set_expand(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *<span class="keyword">set</span>);
<a name="l00361"></a>00361 <span class="keywordtype">int</span>  sptlrpc_rule_set_merge(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *<span class="keyword">set</span>,
<a name="l00362"></a>00362                             <span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule.html" title="A rule specifies a flavor to be used by a ptlrpc connection between two Lustre parts...">sptlrpc_rule</a> *rule);
<a name="l00363"></a>00363 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gaa86a438c13250916b84e0d12810d5786" title="given from/to/nid, determine a matching flavor in ruleset.">sptlrpc_rule_set_choose</a>(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *rset,
<a name="l00364"></a>00364                             <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a> from,
<a name="l00365"></a>00365                             <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a> to,
<a name="l00366"></a>00366                             <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid,
<a name="l00367"></a>00367                             <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf);
<a name="l00368"></a>00368 <span class="keywordtype">void</span> sptlrpc_rule_set_dump(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *<span class="keyword">set</span>);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="keywordtype">int</span>  sptlrpc_process_config(<span class="keyword">struct</span> <a class="code" href="structlustre__cfg.html">lustre_cfg</a> *lcfg);
<a name="l00371"></a>00371 <span class="keywordtype">void</span> sptlrpc_conf_log_start(<span class="keyword">const</span> <span class="keywordtype">char</span> *logname);
<a name="l00372"></a>00372 <span class="keywordtype">void</span> sptlrpc_conf_log_stop(<span class="keyword">const</span> <span class="keywordtype">char</span> *logname);
<a name="l00373"></a>00373 <span class="keywordtype">void</span> sptlrpc_conf_log_update_begin(<span class="keyword">const</span> <span class="keywordtype">char</span> *logname);
<a name="l00374"></a>00374 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#gaf01cd5684aea35fb175f6c9606735fa0" title="mark a config log has been updated">sptlrpc_conf_log_update_end</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *logname);
<a name="l00375"></a>00375 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga5e58c9331d8eafe4108b46943df678d4" title="called by client devices, notify the sptlrpc config has changed and do import_sec_adapt...">sptlrpc_conf_client_adapt</a>(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd);
<a name="l00376"></a>00376 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#gaa7d95f365760c1a00381d8e0b116c4cb" title="called by target devices, extract sptlrpc rules which applies to this target, to...">sptlrpc_conf_target_get_rules</a>(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd,
<a name="l00377"></a>00377                                    <span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *rset,
<a name="l00378"></a>00378                                    <span class="keywordtype">int</span> initial);
<a name="l00379"></a>00379 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#gac2dcbcaee70d89f9e5f250d5e095ab4e" title="called by target devices, determine the expected flavor from certain peer (from,...">sptlrpc_target_choose_flavor</a>(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *rset,
<a name="l00380"></a>00380                                   <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a> from,
<a name="l00381"></a>00381                                   <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid,
<a name="l00382"></a>00382                                   <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *flavor);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="comment">/* The maximum length of security payload. 1024 is enough for Kerberos 5,</span>
<a name="l00385"></a>00385 <span class="comment"> * and should be enough for other future mechanisms but not sure.</span>
<a name="l00386"></a>00386 <span class="comment"> * Only used by pre-allocated request/reply pool.</span>
<a name="l00387"></a>00387 <span class="comment"> */</span>
<a name="l00388"></a>00388 <span class="preprocessor">#define SPTLRPC_MAX_PAYLOAD     (1024)</span>
<a name="l00389"></a>00389 <span class="preprocessor"></span>
<a name="l00390"></a>00390 
<a name="l00391"></a><a class="code" href="structvfs__cred.html">00391</a> <span class="keyword">struct </span><a class="code" href="structvfs__cred.html">vfs_cred</a> {
<a name="l00392"></a>00392         uint32_t        vc_uid;
<a name="l00393"></a>00393         uint32_t        vc_gid;
<a name="l00394"></a>00394 };
<a name="l00395"></a>00395 
<a name="l00396"></a><a class="code" href="structptlrpc__ctx__ops.html">00396</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__ctx__ops.html">ptlrpc_ctx_ops</a> {
<a name="l00400"></a>00400         int     (*<a class="code" href="structptlrpc__ctx__ops.html#a01fd4f091d29feea575abfe2253cebc9" title="To determine whether it&amp;#39;s suitable to use the ctx for vcred.">match</a>)       (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00401"></a>00401                                 <span class="keyword">struct </span><a class="code" href="structvfs__cred.html">vfs_cred</a> *vcred);
<a name="l00402"></a>00402 
<a name="l00406"></a>00406         int     (*<a class="code" href="structptlrpc__ctx__ops.html#ad2d600893d9bf038f602916ca9419eb8" title="To bring the ctx uptodate.">refresh</a>)     (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx);
<a name="l00407"></a>00407 
<a name="l00411"></a>00411         int     (*<a class="code" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255" title="Validate the ctx.">validate</a>)    (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx);
<a name="l00412"></a>00412 
<a name="l00416"></a>00416         void    (*<a class="code" href="structptlrpc__ctx__ops.html#a87347673c61d50fb34d358829bcff5ae" title="Force the ctx to die.">die</a>)         (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00417"></a>00417                                 <span class="keywordtype">int</span> grace);
<a name="l00418"></a>00418         int     (*display)     (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00419"></a>00419                                 <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize);
<a name="l00420"></a>00420 
<a name="l00431"></a>00431         int     (*<a class="code" href="structptlrpc__ctx__ops.html#a56a7044b0eb1b542f387d61fb0f2c2c9" title="Sign the request message using ctx.">sign</a>)        (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00432"></a>00432                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00433"></a>00433 
<a name="l00444"></a>00444         int     (*<a class="code" href="structptlrpc__ctx__ops.html#af81c94560ecbdcb48151bd89767d9f75" title="Verify the reply message using ctx.">verify</a>)      (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00445"></a>00445                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00446"></a>00446 
<a name="l00457"></a>00457         int     (*<a class="code" href="structptlrpc__ctx__ops.html#a21b8b702790d8794111c70b0d81529dc" title="Encrypt the request message using ctx.">seal</a>)        (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00458"></a>00458                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00459"></a>00459 
<a name="l00470"></a>00470         int     (*<a class="code" href="structptlrpc__ctx__ops.html#adfd6f5c19365d9e9d49f6e52ca55be61" title="Decrypt the reply message using ctx.">unseal</a>)      (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00471"></a>00471                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00472"></a>00472 
<a name="l00493"></a>00493         int     (*<a class="code" href="structptlrpc__ctx__ops.html#a1440abe65b4eac150d2f52c160582631" title="Wrap bulk request data.">wrap_bulk</a>)   (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00494"></a>00494                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00495"></a>00495                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l00496"></a>00496 
<a name="l00510"></a>00510         int     (*<a class="code" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e" title="Unwrap bulk reply data.">unwrap_bulk</a>) (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00511"></a>00511                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00512"></a>00512                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l00513"></a>00513 };
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 <span class="preprocessor">#define PTLRPC_CTX_NEW_BIT             (0)  </span><span class="comment">/* newly created */</span>
<a name="l00516"></a>00516 <span class="preprocessor">#define PTLRPC_CTX_UPTODATE_BIT        (1)  </span><span class="comment">/* uptodate */</span>
<a name="l00517"></a>00517 <span class="preprocessor">#define PTLRPC_CTX_DEAD_BIT            (2)  </span><span class="comment">/* mark expired gracefully */</span>
<a name="l00518"></a>00518 <span class="preprocessor">#define PTLRPC_CTX_ERROR_BIT           (3)  </span><span class="comment">/* fatal error (refresh, etc.) */</span>
<a name="l00519"></a>00519 <span class="preprocessor">#define PTLRPC_CTX_CACHED_BIT          (8)  </span><span class="comment">/* in ctx cache (hash etc.) */</span>
<a name="l00520"></a>00520 <span class="preprocessor">#define PTLRPC_CTX_ETERNAL_BIT         (9)  </span><span class="comment">/* always valid */</span>
<a name="l00521"></a>00521 
<a name="l00522"></a>00522 <span class="preprocessor">#define PTLRPC_CTX_NEW                 (1 &lt;&lt; PTLRPC_CTX_NEW_BIT)</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span><span class="preprocessor">#define PTLRPC_CTX_UPTODATE            (1 &lt;&lt; PTLRPC_CTX_UPTODATE_BIT)</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span><span class="preprocessor">#define PTLRPC_CTX_DEAD                (1 &lt;&lt; PTLRPC_CTX_DEAD_BIT)</span>
<a name="l00525"></a>00525 <span class="preprocessor"></span><span class="preprocessor">#define PTLRPC_CTX_ERROR               (1 &lt;&lt; PTLRPC_CTX_ERROR_BIT)</span>
<a name="l00526"></a>00526 <span class="preprocessor"></span><span class="preprocessor">#define PTLRPC_CTX_CACHED              (1 &lt;&lt; PTLRPC_CTX_CACHED_BIT)</span>
<a name="l00527"></a>00527 <span class="preprocessor"></span><span class="preprocessor">#define PTLRPC_CTX_ETERNAL             (1 &lt;&lt; PTLRPC_CTX_ETERNAL_BIT)</span>
<a name="l00528"></a>00528 <span class="preprocessor"></span>
<a name="l00529"></a>00529 <span class="preprocessor">#define PTLRPC_CTX_STATUS_MASK         (PTLRPC_CTX_NEW_BIT    |       \</span>
<a name="l00530"></a>00530 <span class="preprocessor">                                        PTLRPC_CTX_UPTODATE   |       \</span>
<a name="l00531"></a>00531 <span class="preprocessor">                                        PTLRPC_CTX_DEAD       |       \</span>
<a name="l00532"></a>00532 <span class="preprocessor">                                        PTLRPC_CTX_ERROR)</span>
<a name="l00533"></a>00533 <span class="preprocessor"></span>
<a name="l00534"></a><a class="code" href="structptlrpc__cli__ctx.html">00534</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> {
<a name="l00535"></a>00535         <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>       cc_cache;       <span class="comment">/* linked into ctx cache */</span>
<a name="l00536"></a>00536         atomic_t                cc_refcount;
<a name="l00537"></a>00537         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>      *cc_sec;
<a name="l00538"></a>00538         <span class="keyword">struct </span><a class="code" href="structptlrpc__ctx__ops.html">ptlrpc_ctx_ops</a>  *cc_ops;
<a name="l00539"></a>00539         cfs_time_t              cc_expire;      <span class="comment">/* in seconds */</span>
<a name="l00540"></a>00540         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            cc_early_expire:1;
<a name="l00541"></a>00541         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>           cc_flags;
<a name="l00542"></a>00542         <span class="keyword">struct </span><a class="code" href="structvfs__cred.html">vfs_cred</a>         cc_vcred;
<a name="l00543"></a>00543         spinlock_t              cc_lock;
<a name="l00544"></a>00544         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        cc_req_list;    <span class="comment">/* waiting reqs linked here */</span>
<a name="l00545"></a>00545         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        cc_gc_chain;    <span class="comment">/* linked to gc chain */</span>
<a name="l00546"></a>00546 };
<a name="l00547"></a>00547 
<a name="l00551"></a><a class="code" href="structptlrpc__sec__cops.html">00551</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__cops.html" title="client side policy operation vector.">ptlrpc_sec_cops</a> {
<a name="l00564"></a>00564         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *     (*create_sec)  (<span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00565"></a>00565                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx,
<a name="l00566"></a>00566                                                 <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *flavor);
<a name="l00567"></a>00567 
<a name="l00574"></a>00574         void                    (*<a class="code" href="structptlrpc__sec__cops.html#a53a9874a373d044027d52b2bf118fc00" title="Destructor of ptlrpc_sec.">destroy_sec</a>) (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec);
<a name="l00575"></a>00575 
<a name="l00583"></a>00583         void                    (*<a class="code" href="structptlrpc__sec__cops.html#a08e2b30856f5887883df0abf37c3a5c1" title="Notify that this ptlrpc_sec is going to die.">kill_sec</a>)    (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec);
<a name="l00584"></a>00584 
<a name="l00593"></a>00593         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> * (*lookup_ctx)  (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00594"></a>00594                                                 <span class="keyword">struct </span><a class="code" href="structvfs__cred.html">vfs_cred</a> *vcred,
<a name="l00595"></a>00595                                                 <span class="keywordtype">int</span> create,
<a name="l00596"></a>00596                                                 <span class="keywordtype">int</span> remove_dead);
<a name="l00597"></a>00597 
<a name="l00608"></a>00608         void                    (*<a class="code" href="structptlrpc__sec__cops.html#aabc06c431b7e2b62d2d81f0707834122" title="Called then the reference of ctx dropped to 0.">release_ctx</a>) (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00609"></a>00609                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00610"></a>00610                                                 <span class="keywordtype">int</span> sync);
<a name="l00611"></a>00611 
<a name="l00622"></a>00622         int                     (*<a class="code" href="structptlrpc__sec__cops.html#a26e276d2b4143cd7376a9a13b194b51a" title="Flush the context cache.">flush_ctx_cache</a>)
<a name="l00623"></a>00623                                                (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00624"></a>00624                                                 uid_t uid,
<a name="l00625"></a>00625                                                 <span class="keywordtype">int</span> grace,
<a name="l00626"></a>00626                                                 <span class="keywordtype">int</span> force);
<a name="l00627"></a>00627 
<a name="l00634"></a>00634         void                    (*<a class="code" href="structptlrpc__sec__cops.html#ae5fd60f1e3563bd552852ccbc51883d0" title="Called periodically by garbage collector to remove dead contexts from cache.">gc_ctx</a>)      (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec);
<a name="l00635"></a>00635 
<a name="l00642"></a>00642         int                     (*<a class="code" href="structptlrpc__sec__cops.html#af147272a7b7761512f4e964a6b72d14d" title="Given an context ctx, install a corresponding reverse service context on client side...">install_rctx</a>)(<span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00643"></a>00643                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00644"></a>00644                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx);
<a name="l00645"></a>00645 
<a name="l00657"></a>00657         int                     (*<a class="code" href="structptlrpc__sec__cops.html#aa41ab203ee2687014b25d0876b7427e5" title="To allocate request buffer for req.">alloc_reqbuf</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00658"></a>00658                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00659"></a>00659                                                 <span class="keywordtype">int</span> lustre_msg_size);
<a name="l00660"></a>00660 
<a name="l00668"></a>00668         void                    (*<a class="code" href="structptlrpc__sec__cops.html#a1ccde999a88cf1028d6e9f7106c3fdf3" title="To free request buffer for req.">free_reqbuf</a>) (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00669"></a>00669                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00670"></a>00670 
<a name="l00681"></a>00681         int                     (*<a class="code" href="structptlrpc__sec__cops.html#a6b48ac1eaef3ac1159a8d8cac74d5eef" title="To allocate reply buffer for req.">alloc_repbuf</a>)(<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00682"></a>00682                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00683"></a>00683                                                 <span class="keywordtype">int</span> lustre_msg_size);
<a name="l00684"></a>00684 
<a name="l00694"></a>00694         void                    (*<a class="code" href="structptlrpc__sec__cops.html#ae72ed3fbdbb93a9fb7d08931fd536082" title="To free reply buffer for req.">free_repbuf</a>) (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00695"></a>00695                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00696"></a>00696 
<a name="l00707"></a>00707         int                     (*<a class="code" href="structptlrpc__sec__cops.html#a67af7eed6f87fb433e01dc500814723f" title="To expand the request buffer of req, thus the segment in the request message pointed...">enlarge_reqbuf</a>)
<a name="l00708"></a>00708                                                (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00709"></a>00709                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00710"></a>00710                                                 <span class="keywordtype">int</span> segment, <span class="keywordtype">int</span> newsize);
<a name="l00711"></a>00711         <span class="comment">/*</span>
<a name="l00712"></a>00712 <span class="comment">         * misc</span>
<a name="l00713"></a>00713 <span class="comment">         */</span>
<a name="l00714"></a>00714         int                     (*display)     (<span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00715"></a>00715                                                 <span class="keyword">struct </span>seq_file *seq);
<a name="l00716"></a>00716 };
<a name="l00717"></a>00717 
<a name="l00721"></a><a class="code" href="structptlrpc__sec__sops.html">00721</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__sops.html" title="server side policy operation vector.">ptlrpc_sec_sops</a> {
<a name="l00739"></a>00739         int                     (*<a class="code" href="structptlrpc__sec__sops.html#a2a593984c53aea5425bc29f6ede99144" title="verify an incoming request.">accept</a>)      (<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00740"></a>00740 
<a name="l00751"></a>00751         int                     (*<a class="code" href="structptlrpc__sec__sops.html#a876a2e82cdca22048ce6521778690e83" title="Perform security transformation upon reply message.">authorize</a>)   (<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00752"></a>00752 
<a name="l00758"></a>00758         void                    (*<a class="code" href="structptlrpc__sec__sops.html#a26a206ee7e1e7782f6ebd2994ecab72b" title="Invalidate server context ctx.">invalidate_ctx</a>)
<a name="l00759"></a>00759                                                (<span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx);
<a name="l00760"></a>00760 
<a name="l00773"></a>00773         int                     (*<a class="code" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412" title="Allocate a ptlrpc_reply_state.">alloc_rs</a>)    (<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00774"></a>00774                                                 <span class="keywordtype">int</span> msgsize);
<a name="l00775"></a>00775 
<a name="l00779"></a>00779         void                    (*<a class="code" href="structptlrpc__sec__sops.html#a9efbc6c11a531f258abfbb66ec8d3c83" title="Free a ptlrpc_reply_state.">free_rs</a>)     (<span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs);
<a name="l00780"></a>00780 
<a name="l00786"></a>00786         void                    (*<a class="code" href="structptlrpc__sec__sops.html#af0088688e5488aa185de82f8c48be04c" title="Release the server context ctx.">free_ctx</a>)    (<span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx);
<a name="l00787"></a>00787 
<a name="l00793"></a>00793         int                     (*<a class="code" href="structptlrpc__sec__sops.html#a54b152657628c74074ae4ea4989846a3" title="Install a reverse context based on the server context ctx.">install_rctx</a>)(<span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00794"></a>00794                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx);
<a name="l00795"></a>00795 
<a name="l00804"></a>00804         int                     (*<a class="code" href="structptlrpc__sec__sops.html#a5f77240383f3487906dfdaae468168b8" title="Prepare buffer for incoming bulk write.">prep_bulk</a>)   (<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00805"></a>00805                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l00806"></a>00806 
<a name="l00812"></a>00812         int                     (*<a class="code" href="structptlrpc__sec__sops.html#a56c58f3ce724e969057039fb1a0360b3" title="Unwrap the bulk write data.">unwrap_bulk</a>) (<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00813"></a>00813                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l00814"></a>00814 
<a name="l00820"></a>00820         int                     (*<a class="code" href="structptlrpc__sec__sops.html#abbee33a52946011b640ea70e9ad75252" title="Wrap the bulk read data.">wrap_bulk</a>)   (<span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00821"></a>00821                                                 <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l00822"></a>00822 };
<a name="l00823"></a>00823 
<a name="l00824"></a><a class="code" href="structptlrpc__sec__policy.html">00824</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> {
<a name="l00825"></a>00825         <span class="keyword">struct </span>module                  *sp_owner;
<a name="l00826"></a>00826         <span class="keywordtype">char</span>                           *sp_name;
<a name="l00827"></a>00827         __u16                           sp_policy; <span class="comment">/* policy number */</span>
<a name="l00828"></a>00828         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__cops.html" title="client side policy operation vector.">ptlrpc_sec_cops</a>         *sp_cops;   <span class="comment">/* client ops */</span>
<a name="l00829"></a>00829         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__sops.html" title="server side policy operation vector.">ptlrpc_sec_sops</a>         *sp_sops;   <span class="comment">/* server ops */</span>
<a name="l00830"></a>00830 };
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 <span class="preprocessor">#define PTLRPC_SEC_FL_REVERSE           0x0001 </span><span class="comment">/* reverse sec */</span>
<a name="l00833"></a>00833 <span class="preprocessor">#define PTLRPC_SEC_FL_ROOTONLY          0x0002 </span><span class="comment">/* treat everyone as root */</span>
<a name="l00834"></a>00834 <span class="preprocessor">#define PTLRPC_SEC_FL_UDESC             0x0004 </span><span class="comment">/* ship udesc */</span>
<a name="l00835"></a>00835 <span class="preprocessor">#define PTLRPC_SEC_FL_BULK              0x0008 </span><span class="comment">/* intensive bulk i/o expected */</span>
<a name="l00836"></a>00836 <span class="preprocessor">#define PTLRPC_SEC_FL_PAG               0x0010 </span><span class="comment">/* PAG mode */</span>
<a name="l00837"></a>00837 
<a name="l00845"></a><a class="code" href="structptlrpc__sec.html">00845</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> {
<a name="l00846"></a>00846         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a>       *ps_policy;
<a name="l00847"></a>00847         atomic_t                        ps_refcount;
<a name="l00849"></a><a class="code" href="structptlrpc__sec.html#a9e8ab0f2316d16b984a6452a73df5790">00849</a>         atomic_t                        <a class="code" href="structptlrpc__sec.html#a9e8ab0f2316d16b984a6452a73df5790" title="statistic only">ps_nctx</a>;
<a name="l00851"></a><a class="code" href="structptlrpc__sec.html#a68829ae9ed27305779a9d5ad9d1b8283">00851</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__sec.html#a68829ae9ed27305779a9d5ad9d1b8283" title="unique identifier">ps_id</a>;
<a name="l00852"></a>00852         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a>           ps_flvr;
<a name="l00853"></a>00853         <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a>            ps_part;
<a name="l00855"></a><a class="code" href="structptlrpc__sec.html#a8167c9f501f66f17a2fe9c6ccc6b0f39">00855</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="structptlrpc__sec.html#a8167c9f501f66f17a2fe9c6ccc6b0f39" title="after set, no more new context will be created">ps_dying</a>:1;
<a name="l00857"></a><a class="code" href="structptlrpc__sec.html#a52e343bfafb7fde35949b51da5125458">00857</a>         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a>              *<a class="code" href="structptlrpc__sec.html#a52e343bfafb7fde35949b51da5125458" title="owning import">ps_import</a>;
<a name="l00858"></a>00858         spinlock_t                      ps_lock;
<a name="l00859"></a>00859 
<a name="l00860"></a>00860         <span class="comment">/*</span>
<a name="l00861"></a>00861 <span class="comment">         * garbage collection</span>
<a name="l00862"></a>00862 <span class="comment">         */</span>
<a name="l00863"></a>00863         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ps_gc_list;
<a name="l00864"></a>00864         cfs_time_t                      ps_gc_interval; <span class="comment">/* in seconds */</span>
<a name="l00865"></a>00865         cfs_time_t                      ps_gc_next;     <span class="comment">/* in seconds */</span>
<a name="l00866"></a>00866 };
<a name="l00867"></a>00867 
<a name="l00868"></a>00868 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sec_is_reverse(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l00869"></a>00869 {
<a name="l00870"></a>00870         <span class="keywordflow">return</span> (sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> &amp; PTLRPC_SEC_FL_REVERSE);
<a name="l00871"></a>00871 }
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sec_is_rootonly(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l00874"></a>00874 {
<a name="l00875"></a>00875         <span class="keywordflow">return</span> (sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> &amp; PTLRPC_SEC_FL_ROOTONLY);
<a name="l00876"></a>00876 }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878 
<a name="l00879"></a><a class="code" href="structptlrpc__svc__ctx.html">00879</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> {
<a name="l00880"></a>00880         atomic_t                        sc_refcount;
<a name="l00881"></a>00881         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a>       *sc_policy;
<a name="l00882"></a>00882 };
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 <span class="comment">/*</span>
<a name="l00885"></a>00885 <span class="comment"> * user identity descriptor</span>
<a name="l00886"></a>00886 <span class="comment"> */</span>
<a name="l00887"></a>00887 <span class="preprocessor">#define LUSTRE_MAX_GROUPS               (128)</span>
<a name="l00888"></a>00888 <span class="preprocessor"></span>
<a name="l00889"></a><a class="code" href="structptlrpc__user__desc.html">00889</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__user__desc.html">ptlrpc_user_desc</a> {
<a name="l00890"></a>00890         __u32           pud_uid;
<a name="l00891"></a>00891         __u32           pud_gid;
<a name="l00892"></a>00892         __u32           pud_fsuid;
<a name="l00893"></a>00893         __u32           pud_fsgid;
<a name="l00894"></a>00894         __u32           pud_cap;
<a name="l00895"></a>00895         __u32           pud_ngroups;
<a name="l00896"></a>00896         __u32           pud_groups[0];
<a name="l00897"></a>00897 };
<a name="l00898"></a>00898 
<a name="l00899"></a>00899 <span class="comment">/*</span>
<a name="l00900"></a>00900 <span class="comment"> * bulk flavors</span>
<a name="l00901"></a>00901 <span class="comment"> */</span>
<a name="l00902"></a>00902 <span class="keyword">enum</span> sptlrpc_bulk_hash_alg {
<a name="l00903"></a>00903         BULK_HASH_ALG_NULL      = 0,
<a name="l00904"></a>00904         BULK_HASH_ALG_ADLER32,
<a name="l00905"></a>00905         BULK_HASH_ALG_CRC32,
<a name="l00906"></a>00906         BULK_HASH_ALG_MD5,
<a name="l00907"></a>00907         BULK_HASH_ALG_SHA1,
<a name="l00908"></a>00908         BULK_HASH_ALG_SHA256,
<a name="l00909"></a>00909         BULK_HASH_ALG_SHA384,
<a name="l00910"></a>00910         BULK_HASH_ALG_SHA512,
<a name="l00911"></a>00911         BULK_HASH_ALG_MAX
<a name="l00912"></a>00912 };
<a name="l00913"></a>00913 
<a name="l00914"></a>00914 <span class="keyword">const</span> <span class="keywordtype">char</span> * sptlrpc_get_hash_name(__u8 hash_alg);
<a name="l00915"></a>00915 __u8 sptlrpc_get_hash_alg(<span class="keyword">const</span> <span class="keywordtype">char</span> *algname);
<a name="l00916"></a>00916 
<a name="l00917"></a>00917 <span class="keyword">enum</span> {
<a name="l00918"></a>00918         BSD_FL_ERR      = 1,
<a name="l00919"></a>00919 };
<a name="l00920"></a>00920 
<a name="l00921"></a><a class="code" href="structptlrpc__bulk__sec__desc.html">00921</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__sec__desc.html">ptlrpc_bulk_sec_desc</a> {
<a name="l00922"></a>00922         __u8            bsd_version;    <span class="comment">/* 0 */</span>
<a name="l00923"></a>00923         __u8            bsd_type;       <span class="comment">/* SPTLRPC_BULK_XXX */</span>
<a name="l00924"></a>00924         __u8            bsd_svc;        <span class="comment">/* SPTLRPC_BULK_SVC_XXXX */</span>
<a name="l00925"></a>00925         __u8            bsd_flags;      <span class="comment">/* flags */</span>
<a name="l00926"></a>00926         __u32           bsd_nob;        <span class="comment">/* nob of bulk data */</span>
<a name="l00927"></a>00927         __u8            bsd_data[0];    <span class="comment">/* policy-specific token */</span>
<a name="l00928"></a>00928 };
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 <span class="comment">/*</span>
<a name="l00932"></a>00932 <span class="comment"> * lprocfs</span>
<a name="l00933"></a>00933 <span class="comment"> */</span>
<a name="l00934"></a>00934 <span class="keyword">struct </span>proc_dir_entry;
<a name="l00935"></a>00935 <span class="keyword">extern</span> <span class="keyword">struct </span>proc_dir_entry *sptlrpc_proc_root;
<a name="l00936"></a>00936 
<a name="l00937"></a>00937 <span class="comment">/*</span>
<a name="l00938"></a>00938 <span class="comment"> * round size up to next power of 2, for slab allocation.</span>
<a name="l00939"></a>00939 <span class="comment"> * @size must be sane (can&apos;t overflow after round up)</span>
<a name="l00940"></a>00940 <span class="comment"> */</span>
<a name="l00941"></a>00941 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> size_roundup_power2(<span class="keywordtype">int</span> size)
<a name="l00942"></a>00942 {
<a name="l00943"></a>00943         size--;
<a name="l00944"></a>00944         size |= size &gt;&gt; 1;
<a name="l00945"></a>00945         size |= size &gt;&gt; 2;
<a name="l00946"></a>00946         size |= size &gt;&gt; 4;
<a name="l00947"></a>00947         size |= size &gt;&gt; 8;
<a name="l00948"></a>00948         size |= size &gt;&gt; 16;
<a name="l00949"></a>00949         size++;
<a name="l00950"></a>00950         <span class="keywordflow">return</span> size;
<a name="l00951"></a>00951 }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953 <span class="comment">/*</span>
<a name="l00954"></a>00954 <span class="comment"> * internal support libraries</span>
<a name="l00955"></a>00955 <span class="comment"> */</span>
<a name="l00956"></a>00956 <span class="keywordtype">void</span> _sptlrpc_enlarge_msg_inplace(<span class="keyword">struct</span> lustre_msg *msg,
<a name="l00957"></a>00957                                   <span class="keywordtype">int</span> segment, <span class="keywordtype">int</span> newsize);
<a name="l00958"></a>00958 
<a name="l00959"></a>00959 <span class="comment">/*</span>
<a name="l00960"></a>00960 <span class="comment"> * security policies</span>
<a name="l00961"></a>00961 <span class="comment"> */</span>
<a name="l00962"></a>00962 <span class="keywordtype">int</span> sptlrpc_register_policy(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy);
<a name="l00963"></a>00963 <span class="keywordtype">int</span> sptlrpc_unregister_policy(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy);
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 __u32 sptlrpc_name2flavor_base(<span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l00966"></a>00966 <span class="keyword">const</span> <span class="keywordtype">char</span> *sptlrpc_flavor2name_base(__u32 flvr);
<a name="l00967"></a>00967 <span class="keywordtype">char</span> *sptlrpc_flavor2name_bulk(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf,
<a name="l00968"></a>00968                                <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize);
<a name="l00969"></a>00969 <span class="keywordtype">char</span> *sptlrpc_flavor2name(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize);
<a name="l00970"></a>00970 <span class="keywordtype">char</span> *sptlrpc_secflags2str(__u32 flags, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *
<a name="l00973"></a>00973 sptlrpc_policy_get(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy)
<a name="l00974"></a>00974 {
<a name="l00975"></a>00975         __module_get(policy-&gt;sp_owner);
<a name="l00976"></a>00976         <span class="keywordflow">return</span> policy;
<a name="l00977"></a>00977 }
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00980"></a>00980 sptlrpc_policy_put(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy)
<a name="l00981"></a>00981 {
<a name="l00982"></a>00982         module_put(policy-&gt;sp_owner);
<a name="l00983"></a>00983 }
<a name="l00984"></a>00984 
<a name="l00985"></a>00985 <span class="comment">/*</span>
<a name="l00986"></a>00986 <span class="comment"> * client credential</span>
<a name="l00987"></a>00987 <span class="comment"> */</span>
<a name="l00988"></a>00988 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00989"></a>00989 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cli_ctx_status(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00990"></a>00990 {
<a name="l00991"></a>00991         <span class="keywordflow">return</span> (ctx-&gt;cc_flags &amp; PTLRPC_CTX_STATUS_MASK);
<a name="l00992"></a>00992 }
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00995"></a>00995 <span class="keywordtype">int</span> cli_ctx_is_ready(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00996"></a>00996 {
<a name="l00997"></a>00997         <span class="keywordflow">return</span> (cli_ctx_status(ctx) == PTLRPC_CTX_UPTODATE);
<a name="l00998"></a>00998 }
<a name="l00999"></a>00999 
<a name="l01000"></a>01000 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01001"></a>01001 <span class="keywordtype">int</span> cli_ctx_is_refreshed(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l01002"></a>01002 {
<a name="l01003"></a>01003         <span class="keywordflow">return</span> (cli_ctx_status(ctx) != 0);
<a name="l01004"></a>01004 }
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01007"></a>01007 <span class="keywordtype">int</span> cli_ctx_is_uptodate(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l01008"></a>01008 {
<a name="l01009"></a>01009         <span class="keywordflow">return</span> ((ctx-&gt;cc_flags &amp; PTLRPC_CTX_UPTODATE) != 0);
<a name="l01010"></a>01010 }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01013"></a>01013 <span class="keywordtype">int</span> cli_ctx_is_error(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l01014"></a>01014 {
<a name="l01015"></a>01015         <span class="keywordflow">return</span> ((ctx-&gt;cc_flags &amp; PTLRPC_CTX_ERROR) != 0);
<a name="l01016"></a>01016 }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01019"></a>01019 <span class="keywordtype">int</span> cli_ctx_is_dead(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021         <span class="keywordflow">return</span> ((ctx-&gt;cc_flags &amp; (PTLRPC_CTX_DEAD | PTLRPC_CTX_ERROR)) != 0);
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01025"></a>01025 <span class="keywordtype">int</span> cli_ctx_is_eternal(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l01026"></a>01026 {
<a name="l01027"></a>01027         <span class="keywordflow">return</span> ((ctx-&gt;cc_flags &amp; PTLRPC_CTX_ETERNAL) != 0);
<a name="l01028"></a>01028 }
<a name="l01029"></a>01029 
<a name="l01030"></a>01030 <span class="comment">/*</span>
<a name="l01031"></a>01031 <span class="comment"> * sec get/put</span>
<a name="l01032"></a>01032 <span class="comment"> */</span>
<a name="l01033"></a>01033 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sptlrpc_sec_get(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec);
<a name="l01034"></a>01034 <span class="keywordtype">void</span> sptlrpc_sec_put(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec);
<a name="l01035"></a>01035 
<a name="l01036"></a>01036 <span class="comment">/*</span>
<a name="l01037"></a>01037 <span class="comment"> * internal apis which only used by policy impelentation</span>
<a name="l01038"></a>01038 <span class="comment"> */</span>
<a name="l01039"></a>01039 <span class="keywordtype">int</span>  sptlrpc_get_next_secid(<span class="keywordtype">void</span>);
<a name="l01040"></a>01040 <span class="keywordtype">void</span> sptlrpc_sec_destroy(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec);
<a name="l01041"></a>01041 
<a name="l01042"></a>01042 <span class="comment">/*</span>
<a name="l01043"></a>01043 <span class="comment"> * exported client context api</span>
<a name="l01044"></a>01044 <span class="comment"> */</span>
<a name="l01045"></a>01045 <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *sptlrpc_cli_ctx_get(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx);
<a name="l01046"></a>01046 <span class="keywordtype">void</span> sptlrpc_cli_ctx_put(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">int</span> sync);
<a name="l01047"></a>01047 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga6c05663895d669f077f0369232b46dad" title="Expire the client context immediately.">sptlrpc_cli_ctx_expire</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx);
<a name="l01048"></a>01048 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#gae8509673f10f3ba05986d960f5b4a20d" title="To wake up the threads who are waiting for this client context.">sptlrpc_cli_ctx_wakeup</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx);
<a name="l01049"></a>01049 <span class="keywordtype">int</span> sptlrpc_cli_ctx_display(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize);
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 <span class="comment">/*</span>
<a name="l01052"></a>01052 <span class="comment"> * exported client context wrap/buffers</span>
<a name="l01053"></a>01053 <span class="comment"> */</span>
<a name="l01054"></a>01054 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre-defined security transformation upon the...">sptlrpc_cli_wrap_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01055"></a>01055 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga4e652d7f03a8727b8eb9c290936aec23" title="Used by ptlrpc client, to perform security transformation upon the reply message...">sptlrpc_cli_unwrap_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01056"></a>01056 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gaafb426af1f450b0f25952ba1b38f640d" title="Used by ptlrpc client to allocate request buffer of req.">sptlrpc_cli_alloc_reqbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> msgsize);
<a name="l01057"></a>01057 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga2f36863ed408b2fc13f7a04eb6280dd4" title="Used by ptlrpc client to free request buffer of req.">sptlrpc_cli_free_reqbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01058"></a>01058 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req.">sptlrpc_cli_alloc_repbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> msgsize);
<a name="l01059"></a>01059 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga6cd89bd371e4a81930e260bb1b8c79f8" title="Used by ptlrpc client to free reply buffer of req.">sptlrpc_cli_free_repbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01060"></a>01060 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gae060941c4c97b1cb7ba03904a24b53c3" title="Used by ptlrpc client to enlarge the segment of request message pointed by req-&amp;gt;rq_reqmsg...">sptlrpc_cli_enlarge_reqbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01061"></a>01061                                <span class="keywordtype">int</span> segment, <span class="keywordtype">int</span> newsize);
<a name="l01062"></a>01062 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#ga555969de6cd1c126c5a8887b740e1354" title="Used by ptlrpc client, to perform security transformation upon the early reply message...">sptlrpc_cli_unwrap_early_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01063"></a>01063                                     <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> **req_ret);
<a name="l01064"></a>01064 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga9e900c41f0c033d65d6a108d1a1a553c" title="Used by ptlrpc client, to release a processed early reply early_req.">sptlrpc_cli_finish_early_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *early_req);
<a name="l01065"></a>01065 
<a name="l01066"></a>01066 <span class="keywordtype">void</span> sptlrpc_request_out_callback(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01067"></a>01067 
<a name="l01068"></a>01068 <span class="comment">/*</span>
<a name="l01069"></a>01069 <span class="comment"> * exported higher interface of import &amp; request</span>
<a name="l01070"></a>01070 <span class="comment"> */</span>
<a name="l01071"></a>01071 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration...">sptlrpc_import_sec_adapt</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01072"></a>01072                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx,
<a name="l01073"></a>01073                              <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *flvr);
<a name="l01074"></a>01074 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sptlrpc_import_sec_ref(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l01075"></a>01075 <span class="keywordtype">void</span> sptlrpc_import_sec_put(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5" title="Given an import imp, check whether current user has a valid context or not.">sptlrpc_import_check_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l01078"></a>01078 <span class="keywordtype">void</span> sptlrpc_import_flush_root_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l01079"></a>01079 <span class="keywordtype">void</span> sptlrpc_import_flush_my_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l01080"></a>01080 <span class="keywordtype">void</span> sptlrpc_import_flush_all_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp);
<a name="l01081"></a>01081 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it.">sptlrpc_req_get_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01082"></a>01082 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req.">sptlrpc_req_put_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> sync);
<a name="l01083"></a>01083 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&amp;#39;s not up-to-date.">sptlrpc_req_refresh_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">long</span> timeout);
<a name="l01084"></a>01084 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g.">sptlrpc_req_replace_dead_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01085"></a>01085 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga701bf20eebf0fd9d03c94918418f3b31" title="Initialize flavor settings for req, according to opcode.">sptlrpc_req_set_flavor</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> opcode);
<a name="l01086"></a>01086 
<a name="l01087"></a>01087 <span class="keywordtype">int</span> sptlrpc_parse_rule(<span class="keywordtype">char</span> *param, <span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule.html" title="A rule specifies a flavor to be used by a ptlrpc connection between two Lustre parts...">sptlrpc_rule</a> *rule);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089 <span class="comment">/* gc */</span>
<a name="l01090"></a>01090 <span class="keywordtype">void</span> sptlrpc_gc_add_sec(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec);
<a name="l01091"></a>01091 <span class="keywordtype">void</span> sptlrpc_gc_del_sec(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec);
<a name="l01092"></a>01092 <span class="keywordtype">void</span> sptlrpc_gc_add_ctx(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx);
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 <span class="comment">/* misc */</span>
<a name="l01095"></a>01095 <span class="keyword">const</span> <span class="keywordtype">char</span> * sec2target_str(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec);
<a name="l01096"></a>01096 <span class="keywordtype">int</span> sptlrpc_lprocfs_cliobd_attach(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *dev);
<a name="l01097"></a>01097 
<a name="l01098"></a>01098 <span class="comment">/*</span>
<a name="l01099"></a>01099 <span class="comment"> * server side</span>
<a name="l01100"></a>01100 <span class="comment"> */</span>
<a name="l01101"></a>01101 <span class="keyword">enum</span> secsvc_accept_res {
<a name="l01102"></a>01102         SECSVC_OK       = 0,
<a name="l01103"></a>01103         SECSVC_COMPLETE,
<a name="l01104"></a>01104         SECSVC_DROP,
<a name="l01105"></a>01105 };
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#ga6fdd12db4bcfd925fed91da8a4ecf857" title="Used by ptlrpc server, to perform transformation upon request message of incoming...">sptlrpc_svc_unwrap_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01108"></a>01108 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#ga1bcf6cf901c5c461f6f273a9b764430a" title="Used by ptlrpc server, to allocate reply buffer for req.">sptlrpc_svc_alloc_rs</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> msglen);
<a name="l01109"></a>01109 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#gaa36445bb3135100651ecb584e151f3cb" title="Used by ptlrpc server, to perform transformation upon reply message.">sptlrpc_svc_wrap_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01110"></a>01110 <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga993608bc2cfa31615e26f5f368801d30" title="Used by ptlrpc server, to free reply_state.">sptlrpc_svc_free_rs</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs);
<a name="l01111"></a>01111 <span class="keywordtype">void</span> sptlrpc_svc_ctx_addref(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01112"></a>01112 <span class="keywordtype">void</span> sptlrpc_svc_ctx_decref(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01113"></a>01113 <span class="keywordtype">void</span> sptlrpc_svc_ctx_invalidate(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="keywordtype">int</span>  <a class="code" href="group__sptlrpc.html#gaf12efdd6553013c0e886d356541dd86b" title="Given an export exp, check whether the flavor of incoming req is allowed by the export...">sptlrpc_target_export_check</a>(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,
<a name="l01116"></a>01116                                  <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l01117"></a>01117 <span class="keywordtype">void</span> sptlrpc_target_update_exp_flavor(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd,
<a name="l01118"></a>01118                                       <span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *rset);
<a name="l01119"></a>01119 
<a name="l01120"></a>01120 <span class="comment">/*</span>
<a name="l01121"></a>01121 <span class="comment"> * reverse context</span>
<a name="l01122"></a>01122 <span class="comment"> */</span>
<a name="l01123"></a>01123 <span class="keywordtype">int</span> sptlrpc_svc_install_rvs_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01124"></a>01124                                 <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx);
<a name="l01125"></a>01125 <span class="keywordtype">int</span> sptlrpc_cli_install_rvs_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01126"></a>01126                                 <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx);
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 <span class="comment">/* bulk security api */</span>
<a name="l01129"></a>01129 <span class="keywordtype">int</span> sptlrpc_enc_pool_add_user(<span class="keywordtype">void</span>);
<a name="l01130"></a>01130 <span class="keywordtype">int</span> sptlrpc_enc_pool_del_user(<span class="keywordtype">void</span>);
<a name="l01131"></a>01131 <span class="keywordtype">int</span>  sptlrpc_enc_pool_get_pages(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l01132"></a>01132 <span class="keywordtype">void</span> sptlrpc_enc_pool_put_pages(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l01133"></a>01133 <span class="keywordtype">int</span> get_free_pages_in_pool(<span class="keywordtype">void</span>);
<a name="l01134"></a>01134 <span class="keywordtype">int</span> pool_is_at_full_capacity(<span class="keywordtype">void</span>);
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc.">sptlrpc_cli_wrap_bulk</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01137"></a>01137                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l01138"></a>01138 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga40f686bb862f149e189cf81f3a51a7c3" title="This is called after unwrap the reply message.">sptlrpc_cli_unwrap_bulk_read</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01139"></a>01139                                  <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l01140"></a>01140                                  <span class="keywordtype">int</span> nob);
<a name="l01141"></a>01141 <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga4a0448bc155a2dd383e108188f99beec" title="This is called after unwrap the reply message.">sptlrpc_cli_unwrap_bulk_write</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01142"></a>01142                                   <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l01143"></a>01143 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span><span class="keywordtype">int</span> sptlrpc_svc_prep_bulk(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01145"></a>01145                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l01146"></a>01146 <span class="keywordtype">int</span> sptlrpc_svc_wrap_bulk(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01147"></a>01147                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l01148"></a>01148 <span class="keywordtype">int</span> sptlrpc_svc_unwrap_bulk(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01149"></a>01149                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc);
<a name="l01150"></a>01150 <span class="preprocessor">#endif</span>
<a name="l01151"></a>01151 <span class="preprocessor"></span>
<a name="l01152"></a>01152 <span class="comment">/* bulk helpers (internal use only by policies) */</span>
<a name="l01153"></a>01153 <span class="keywordtype">int</span> sptlrpc_get_bulk_checksum(<span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc, __u8 alg,
<a name="l01154"></a>01154                               <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> buflen);
<a name="l01155"></a>01155 
<a name="l01156"></a>01156 <span class="keywordtype">int</span> bulk_sec_desc_unpack(<span class="keyword">struct</span> lustre_msg *msg, <span class="keywordtype">int</span> offset, <span class="keywordtype">int</span> swabbed);
<a name="l01157"></a>01157 
<a name="l01158"></a>01158 <span class="comment">/* user descriptor helpers */</span>
<a name="l01159"></a>01159 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sptlrpc_user_desc_size(<span class="keywordtype">int</span> ngroups)
<a name="l01160"></a>01160 {
<a name="l01161"></a>01161         <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structptlrpc__user__desc.html">ptlrpc_user_desc</a>) + ngroups * <span class="keyword">sizeof</span>(__u32);
<a name="l01162"></a>01162 }
<a name="l01163"></a>01163 
<a name="l01164"></a>01164 <span class="keywordtype">int</span> sptlrpc_current_user_desc_size(<span class="keywordtype">void</span>);
<a name="l01165"></a>01165 <span class="keywordtype">int</span> sptlrpc_pack_user_desc(<span class="keyword">struct</span> lustre_msg *msg, <span class="keywordtype">int</span> offset);
<a name="l01166"></a>01166 <span class="keywordtype">int</span> sptlrpc_unpack_user_desc(<span class="keyword">struct</span> lustre_msg *req, <span class="keywordtype">int</span> offset, <span class="keywordtype">int</span> swabbed);
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 
<a name="l01169"></a>01169 <span class="preprocessor">#define CFS_CAP_CHOWN_MASK (1 &lt;&lt; CFS_CAP_CHOWN)</span>
<a name="l01170"></a>01170 <span class="preprocessor"></span><span class="preprocessor">#define CFS_CAP_SYS_RESOURCE_MASK (1 &lt;&lt; CFS_CAP_SYS_RESOURCE)</span>
<a name="l01171"></a>01171 <span class="preprocessor"></span>
<a name="l01172"></a>01172 <span class="keyword">enum</span> {
<a name="l01173"></a>01173         LUSTRE_SEC_NONE         = 0,
<a name="l01174"></a>01174         LUSTRE_SEC_REMOTE       = 1,
<a name="l01175"></a>01175         LUSTRE_SEC_SPECIFY      = 2,
<a name="l01176"></a>01176         LUSTRE_SEC_ALL          = 3
<a name="l01177"></a>01177 };
<a name="l01178"></a>01178 
<a name="l01181"></a>01181 <span class="preprocessor">#endif </span><span class="comment">/* _LUSTRE_SEC_H_ */</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:13 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
