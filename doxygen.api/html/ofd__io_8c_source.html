<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ofd/ofd_io.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/ofd/ofd_io.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.gnu.org/licenses/gpl-2.0.html</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * GPL HEADER END</span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 <span class="comment">/*</span>
<a name="l00023"></a>00023 <span class="comment"> * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00024"></a>00024 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00025"></a>00025 <span class="comment"> *</span>
<a name="l00026"></a>00026 <span class="comment"> * Copyright (c) 2012, 2015, Intel Corporation.</span>
<a name="l00027"></a>00027 <span class="comment"> */</span>
<a name="l00028"></a>00028 <span class="comment">/*</span>
<a name="l00029"></a>00029 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00030"></a>00030 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00031"></a>00031 <span class="comment"> *</span>
<a name="l00032"></a>00032 <span class="comment"> * lustre/ofd/ofd_io.c</span>
<a name="l00033"></a>00033 <span class="comment"> *</span>
<a name="l00034"></a>00034 <span class="comment"> * This file provides functions to handle IO requests from clients and</span>
<a name="l00035"></a>00035 <span class="comment"> * also LFSCK routines to check parent file identifier (PFID) consistency.</span>
<a name="l00036"></a>00036 <span class="comment"> *</span>
<a name="l00037"></a>00037 <span class="comment"> * Author: Alexey Zhuravlev &lt;alexey.zhuravlev@intel.com&gt;</span>
<a name="l00038"></a>00038 <span class="comment"> * Author: Fan Yong &lt;fan.yong@intel.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> */</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_FILTER</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;linux/kthread.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;ofd_internal.h&quot;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">struct </span>ofd_inconsistency_item {
<a name="l00047"></a>00047         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>         oii_list;
<a name="l00048"></a>00048         <span class="keyword">struct </span><a class="code" href="structofd__object.html">ofd_object</a>       *oii_obj;
<a name="l00049"></a>00049         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>            oii_pfid;
<a name="l00050"></a>00050 };
<a name="l00051"></a>00051 
<a name="l00065"></a>00065 <span class="keyword">static</span> <span class="keywordtype">void</span> ofd_inconsistency_verify_one(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00066"></a>00066                                          <span class="keyword">struct</span> <a class="code" href="structofd__device.html">ofd_device</a> *ofd,
<a name="l00067"></a>00067                                          <span class="keyword">struct</span> ofd_inconsistency_item *oii,
<a name="l00068"></a>00068                                          <span class="keyword">struct</span> <a class="code" href="structlfsck__request.html">lfsck_request</a> *lr)
<a name="l00069"></a>00069 {
<a name="l00070"></a>00070         <span class="keyword">struct </span><a class="code" href="structofd__object.html">ofd_object</a>       *fo     = oii-&gt;oii_obj;
<a name="l00071"></a>00071         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           *pfid   = &amp;fo-&gt;ofo_pfid;
<a name="l00072"></a>00072         <span class="keywordtype">int</span>                      rc;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         LASSERT(fo-&gt;ofo_pfid_checking);
<a name="l00075"></a>00075         LASSERT(!fo-&gt;ofo_pfid_verified);
<a name="l00076"></a>00076 
<a name="l00077"></a>00077         lr-&gt;lr_fid = fo-&gt;ofo_header.<a class="code" href="structlu__object__header.html#ae1336fa61cf0b1730f951b8255b9a4d7" title="Fid, uniquely identifying this object.">loh_fid</a>; <span class="comment">/* OST-object itself FID. */</span>
<a name="l00078"></a>00078         lr-&gt;lr_fid2 = oii-&gt;oii_pfid; <span class="comment">/* client given PFID. */</span>
<a name="l00079"></a>00079         lr-&gt;lr_fid3 = *pfid; <span class="comment">/* OST local stored PFID. */</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081         rc = lfsck_in_notify(env, ofd-&gt;ofd_osd, lr, NULL);
<a name="l00082"></a>00082         ofd_write_lock(env, fo);
<a name="l00083"></a>00083         <span class="keywordflow">switch</span> (lr-&gt;lr_status) {
<a name="l00084"></a>00084         <span class="keywordflow">case</span> LPVS_INIT:
<a name="l00085"></a>00085                 LASSERT(rc &lt;= 0);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00088"></a>00088                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: fail to verify OST local stored &quot;</span>
<a name="l00089"></a>00089                                <span class="stringliteral">&quot;PFID xattr for &quot;</span>DFID<span class="stringliteral">&quot;, the client given PFID &quot;</span>
<a name="l00090"></a>00090                                DFID<span class="stringliteral">&quot;, OST local stored PFID &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l00091"></a>00091                                ofd_name(ofd), PFID(&amp;fo-&gt;ofo_header.<a class="code" href="structlu__object__header.html#ae1336fa61cf0b1730f951b8255b9a4d7" title="Fid, uniquely identifying this object.">loh_fid</a>),
<a name="l00092"></a>00092                                PFID(&amp;oii-&gt;oii_pfid), PFID(pfid), rc);
<a name="l00093"></a>00093                 <span class="keywordflow">else</span>
<a name="l00094"></a>00094                         fo-&gt;ofo_pfid_verified = 1;
<a name="l00095"></a>00095                 <span class="keywordflow">break</span>;
<a name="l00096"></a>00096         <span class="keywordflow">case</span> LPVS_INCONSISTENT:
<a name="l00097"></a>00097                 LASSERT(rc != 0);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099                 ofd-&gt;ofd_inconsistency_self_detected++;
<a name="l00100"></a>00100                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00101"></a>00101                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: fail to verify the client given &quot;</span>
<a name="l00102"></a>00102                                <span class="stringliteral">&quot;PFID for &quot;</span>DFID<span class="stringliteral">&quot;, the client given PFID &quot;</span>DFID
<a name="l00103"></a>00103                                <span class="stringliteral">&quot;, local stored PFID &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l00104"></a>00104                                ofd_name(ofd), PFID(&amp;fo-&gt;ofo_header.<a class="code" href="structlu__object__header.html#ae1336fa61cf0b1730f951b8255b9a4d7" title="Fid, uniquely identifying this object.">loh_fid</a>),
<a name="l00105"></a>00105                                PFID(&amp;oii-&gt;oii_pfid), PFID(pfid), rc);
<a name="l00106"></a>00106                 <span class="keywordflow">else</span>
<a name="l00107"></a>00107                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: both the client given PFID and &quot;</span>
<a name="l00108"></a>00108                                <span class="stringliteral">&quot;the OST local stored PFID are stale for the &quot;</span>
<a name="l00109"></a>00109                                <span class="stringliteral">&quot;OST-object &quot;</span>DFID<span class="stringliteral">&quot;, client given PFID is &quot;</span>DFID
<a name="l00110"></a>00110                                <span class="stringliteral">&quot;, local stored PFID is &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00111"></a>00111                                ofd_name(ofd), PFID(&amp;fo-&gt;ofo_header.<a class="code" href="structlu__object__header.html#ae1336fa61cf0b1730f951b8255b9a4d7" title="Fid, uniquely identifying this object.">loh_fid</a>),
<a name="l00112"></a>00112                                PFID(&amp;oii-&gt;oii_pfid), PFID(pfid));
<a name="l00113"></a>00113                 <span class="keywordflow">break</span>;
<a name="l00114"></a>00114         <span class="keywordflow">case</span> LPVS_INCONSISTENT_TOFIX:
<a name="l00115"></a>00115                 ofd-&gt;ofd_inconsistency_self_detected++;
<a name="l00116"></a>00116                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l00117"></a>00117                         ofd-&gt;ofd_inconsistency_self_repaired++;
<a name="l00118"></a>00118                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: fixed the staled OST PFID xattr &quot;</span>
<a name="l00119"></a>00119                                <span class="stringliteral">&quot;for &quot;</span>DFID<span class="stringliteral">&quot;, with the client given PFID &quot;</span>DFID
<a name="l00120"></a>00120                                <span class="stringliteral">&quot;, the old stored PFID &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00121"></a>00121                                ofd_name(ofd), PFID(&amp;fo-&gt;ofo_header.<a class="code" href="structlu__object__header.html#ae1336fa61cf0b1730f951b8255b9a4d7" title="Fid, uniquely identifying this object.">loh_fid</a>),
<a name="l00122"></a>00122                                PFID(&amp;oii-&gt;oii_pfid), PFID(pfid));
<a name="l00123"></a>00123                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00124"></a>00124                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: fail to fix the OST PFID xattr &quot;</span>
<a name="l00125"></a>00125                                <span class="stringliteral">&quot;for &quot;</span>DFID<span class="stringliteral">&quot;, client given PFID &quot;</span>DFID<span class="stringliteral">&quot;, local &quot;</span>
<a name="l00126"></a>00126                                <span class="stringliteral">&quot;stored PFID &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l00127"></a>00127                                ofd_name(ofd), PFID(&amp;fo-&gt;ofo_header.<a class="code" href="structlu__object__header.html#ae1336fa61cf0b1730f951b8255b9a4d7" title="Fid, uniquely identifying this object.">loh_fid</a>),
<a name="l00128"></a>00128                                PFID(&amp;oii-&gt;oii_pfid), PFID(pfid), rc);
<a name="l00129"></a>00129                 }
<a name="l00130"></a>00130                 *pfid = oii-&gt;oii_pfid;
<a name="l00131"></a>00131                 fo-&gt;ofo_pfid_verified = 1;
<a name="l00132"></a>00132                 <span class="keywordflow">break</span>;
<a name="l00133"></a>00133         <span class="keywordflow">default</span>:
<a name="l00134"></a>00134                 <span class="keywordflow">break</span>;
<a name="l00135"></a>00135         }
<a name="l00136"></a>00136         fo-&gt;ofo_pfid_checking = 0;
<a name="l00137"></a>00137         ofd_write_unlock(env, fo);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, &amp;fo-&gt;ofo_obj.do_lu);
<a name="l00140"></a>00140         OBD_FREE_PTR(oii);
<a name="l00141"></a>00141 }
<a name="l00142"></a>00142 
<a name="l00154"></a>00154 <span class="keyword">static</span> <span class="keywordtype">int</span> ofd_inconsistency_verification_main(<span class="keywordtype">void</span> *args)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>                  env;
<a name="l00157"></a>00157         <span class="keyword">struct </span><a class="code" href="structofd__device.html">ofd_device</a>             *ofd    = args;
<a name="l00158"></a>00158         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>          *thread = &amp;ofd-&gt;ofd_inconsistency_thread;
<a name="l00159"></a>00159         <span class="keyword">struct </span>ofd_inconsistency_item *oii;
<a name="l00160"></a>00160         <span class="keyword">struct </span><a class="code" href="structlfsck__request.html">lfsck_request</a>          *lr     = NULL;
<a name="l00161"></a>00161         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>             lwi    = { 0 };
<a name="l00162"></a>00162         <span class="keywordtype">int</span>                            rc;
<a name="l00163"></a>00163         ENTRY;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165         rc = lu_env_init(&amp;env, <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f" title="Thread on dt server.">LCT_DT_THREAD</a>);
<a name="l00166"></a>00166         spin_lock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00167"></a>00167         thread_set_flags(thread, rc != 0 ? SVC_STOPPED : SVC_RUNNING);
<a name="l00168"></a>00168         wake_up_all(&amp;thread-&gt;t_ctl_waitq);
<a name="l00169"></a>00169         spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00170"></a>00170         <span class="keywordflow">if</span> (rc != 0)
<a name="l00171"></a>00171                 RETURN(rc);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         OBD_ALLOC_PTR(lr);
<a name="l00174"></a>00174         <span class="keywordflow">if</span> (unlikely(lr == NULL))
<a name="l00175"></a>00175                 GOTO(out_unlocked, rc = -ENOMEM);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         lr-&gt;lr_event = LE_PAIRS_VERIFY;
<a name="l00178"></a>00178         lr-&gt;lr_active = LFSCK_TYPE_LAYOUT;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180         spin_lock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00181"></a>00181         <span class="keywordflow">while</span> (1) {
<a name="l00182"></a>00182                 <span class="keywordflow">if</span> (unlikely(!thread_is_running(thread)))
<a name="l00183"></a>00183                         <span class="keywordflow">break</span>;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185                 <span class="keywordflow">while</span> (!list_empty(&amp;ofd-&gt;ofd_inconsistency_list)) {
<a name="l00186"></a>00186                         oii = list_entry(ofd-&gt;ofd_inconsistency_list.next,
<a name="l00187"></a>00187                                          <span class="keyword">struct</span> ofd_inconsistency_item,
<a name="l00188"></a>00188                                          oii_list);
<a name="l00189"></a>00189                         list_del_init(&amp;oii-&gt;oii_list);
<a name="l00190"></a>00190                         spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00191"></a>00191                         ofd_inconsistency_verify_one(&amp;env, ofd, oii, lr);
<a name="l00192"></a>00192                         spin_lock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00193"></a>00193                 }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195                 spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00196"></a>00196                 l_wait_event(thread-&gt;t_ctl_waitq,
<a name="l00197"></a>00197                              !list_empty(&amp;ofd-&gt;ofd_inconsistency_list) ||
<a name="l00198"></a>00198                              !thread_is_running(thread),
<a name="l00199"></a>00199                              &amp;lwi);
<a name="l00200"></a>00200                 spin_lock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00201"></a>00201         }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         <span class="keywordflow">while</span> (!list_empty(&amp;ofd-&gt;ofd_inconsistency_list)) {
<a name="l00204"></a>00204                 <span class="keyword">struct </span><a class="code" href="structofd__object.html">ofd_object</a> *fo;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206                 oii = list_entry(ofd-&gt;ofd_inconsistency_list.next,
<a name="l00207"></a>00207                                  <span class="keyword">struct</span> ofd_inconsistency_item,
<a name="l00208"></a>00208                                  oii_list);
<a name="l00209"></a>00209                 list_del_init(&amp;oii-&gt;oii_list);
<a name="l00210"></a>00210                 fo = oii-&gt;oii_obj;
<a name="l00211"></a>00211                 spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00212"></a>00212 
<a name="l00213"></a>00213                 ofd_write_lock(&amp;env, fo);
<a name="l00214"></a>00214                 fo-&gt;ofo_pfid_checking = 0;
<a name="l00215"></a>00215                 ofd_write_unlock(&amp;env, fo);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217                 <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(&amp;env, &amp;fo-&gt;ofo_obj.do_lu);
<a name="l00218"></a>00218                 OBD_FREE_PTR(oii);
<a name="l00219"></a>00219                 spin_lock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222         OBD_FREE_PTR(lr);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224         GOTO(out, rc = 0);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 out_unlocked:
<a name="l00227"></a>00227         spin_lock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00228"></a>00228 out:
<a name="l00229"></a>00229         thread_set_flags(thread, SVC_STOPPED);
<a name="l00230"></a>00230         wake_up_all(&amp;thread-&gt;t_ctl_waitq);
<a name="l00231"></a>00231         spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00232"></a>00232         lu_env_fini(&amp;env);
<a name="l00233"></a>00233 
<a name="l00234"></a>00234         <span class="keywordflow">return</span> rc;
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00247"></a>00247 <span class="keywordtype">int</span> ofd_start_inconsistency_verification_thread(<span class="keyword">struct</span> <a class="code" href="structofd__device.html">ofd_device</a> *ofd)
<a name="l00248"></a>00248 {
<a name="l00249"></a>00249         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>    *thread = &amp;ofd-&gt;ofd_inconsistency_thread;
<a name="l00250"></a>00250         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>       lwi    = { 0 };
<a name="l00251"></a>00251         <span class="keyword">struct </span>task_struct      *task;
<a name="l00252"></a>00252         <span class="keywordtype">int</span>                      rc;
<a name="l00253"></a>00253 
<a name="l00254"></a>00254         spin_lock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00255"></a>00255         <span class="keywordflow">if</span> (unlikely(thread_is_running(thread))) {
<a name="l00256"></a>00256                 spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258                 <span class="keywordflow">return</span> -EALREADY;
<a name="l00259"></a>00259         }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261         thread_set_flags(thread, 0);
<a name="l00262"></a>00262         spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00263"></a>00263         task = kthread_run(ofd_inconsistency_verification_main, ofd,
<a name="l00264"></a>00264                            <span class="stringliteral">&quot;inconsistency_verification&quot;</span>);
<a name="l00265"></a>00265         <span class="keywordflow">if</span> (IS_ERR(task)) {
<a name="l00266"></a>00266                 rc = PTR_ERR(task);
<a name="l00267"></a>00267                 CERROR(<span class="stringliteral">&quot;%s: cannot start self_repair thread: rc = %d\n&quot;</span>,
<a name="l00268"></a>00268                        ofd_name(ofd), rc);
<a name="l00269"></a>00269         } <span class="keywordflow">else</span> {
<a name="l00270"></a>00270                 rc = 0;
<a name="l00271"></a>00271                 l_wait_event(thread-&gt;t_ctl_waitq,
<a name="l00272"></a>00272                              thread_is_running(thread) ||
<a name="l00273"></a>00273                              thread_is_stopped(thread),
<a name="l00274"></a>00274                              &amp;lwi);
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         <span class="keywordflow">return</span> rc;
<a name="l00278"></a>00278 }
<a name="l00279"></a>00279 
<a name="l00288"></a>00288 <span class="keywordtype">int</span> ofd_stop_inconsistency_verification_thread(<span class="keyword">struct</span> <a class="code" href="structofd__device.html">ofd_device</a> *ofd)
<a name="l00289"></a>00289 {
<a name="l00290"></a>00290         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>    *thread = &amp;ofd-&gt;ofd_inconsistency_thread;
<a name="l00291"></a>00291         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>       lwi    = { 0 };
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         spin_lock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00294"></a>00294         <span class="keywordflow">if</span> (thread_is_init(thread) || thread_is_stopped(thread)) {
<a name="l00295"></a>00295                 spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297                 <span class="keywordflow">return</span> -EALREADY;
<a name="l00298"></a>00298         }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300         thread_set_flags(thread, SVC_STOPPING);
<a name="l00301"></a>00301         spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00302"></a>00302         wake_up_all(&amp;thread-&gt;t_ctl_waitq);
<a name="l00303"></a>00303         l_wait_event(thread-&gt;t_ctl_waitq,
<a name="l00304"></a>00304                      thread_is_stopped(thread),
<a name="l00305"></a>00305                      &amp;lwi);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307         <span class="keywordflow">return</span> 0;
<a name="l00308"></a>00308 }
<a name="l00309"></a>00309 
<a name="l00320"></a>00320 <span class="keyword">static</span> <span class="keywordtype">void</span> ofd_add_inconsistency_item(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00321"></a>00321                                        <span class="keyword">struct</span> <a class="code" href="structofd__object.html">ofd_object</a> *fo, <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa)
<a name="l00322"></a>00322 {
<a name="l00323"></a>00323         <span class="keyword">struct </span><a class="code" href="structofd__device.html">ofd_device</a>               *ofd    = ofd_obj2dev(fo);
<a name="l00324"></a>00324         <span class="keyword">struct </span>ofd_inconsistency_item   *oii;
<a name="l00325"></a>00325         <span class="keywordtype">bool</span>                             wakeup = <span class="keyword">false</span>;
<a name="l00326"></a>00326 
<a name="l00327"></a>00327         OBD_ALLOC_PTR(oii);
<a name="l00328"></a>00328         <span class="keywordflow">if</span> (oii == NULL)
<a name="l00329"></a>00329                 <span class="keywordflow">return</span>;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331         INIT_LIST_HEAD(&amp;oii-&gt;oii_list);
<a name="l00332"></a>00332         lu_object_get(&amp;fo-&gt;ofo_obj.do_lu);
<a name="l00333"></a>00333         oii-&gt;oii_obj = fo;
<a name="l00334"></a>00334         oii-&gt;oii_pfid.f_seq = oa-&gt;o_parent_seq;
<a name="l00335"></a>00335         oii-&gt;oii_pfid.f_oid = oa-&gt;o_parent_oid;
<a name="l00336"></a>00336         oii-&gt;oii_pfid.f_stripe_idx = oa-&gt;o_stripe_idx;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338         spin_lock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00339"></a>00339         <span class="keywordflow">if</span> (fo-&gt;ofo_pfid_checking || fo-&gt;ofo_pfid_verified) {
<a name="l00340"></a>00340                 spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00341"></a>00341                 OBD_FREE_PTR(oii);
<a name="l00342"></a>00342 
<a name="l00343"></a>00343                 <span class="keywordflow">return</span>;
<a name="l00344"></a>00344         }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346         fo-&gt;ofo_pfid_checking = 1;
<a name="l00347"></a>00347         <span class="keywordflow">if</span> (list_empty(&amp;ofd-&gt;ofd_inconsistency_list))
<a name="l00348"></a>00348                 wakeup = <span class="keyword">true</span>;
<a name="l00349"></a>00349         list_add_tail(&amp;oii-&gt;oii_list, &amp;ofd-&gt;ofd_inconsistency_list);
<a name="l00350"></a>00350         spin_unlock(&amp;ofd-&gt;ofd_inconsistency_lock);
<a name="l00351"></a>00351         <span class="keywordflow">if</span> (wakeup)
<a name="l00352"></a>00352                 wake_up_all(&amp;ofd-&gt;ofd_inconsistency_thread.t_ctl_waitq);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354         <span class="comment">/* XXX: When the found inconsistency exceeds some threshold,</span>
<a name="l00355"></a>00355 <span class="comment">         *      we can trigger the LFSCK to scan part of the system</span>
<a name="l00356"></a>00356 <span class="comment">         *      or the whole system, which depends on how to define</span>
<a name="l00357"></a>00357 <span class="comment">         *      the threshold, a simple way maybe like that: define</span>
<a name="l00358"></a>00358 <span class="comment">         *      the absolute value of how many inconsisteny allowed</span>
<a name="l00359"></a>00359 <span class="comment">         *      to be repaired via self detect/repair mechanism, if</span>
<a name="l00360"></a>00360 <span class="comment">         *      exceeded, then trigger the LFSCK to scan the layout</span>
<a name="l00361"></a>00361 <span class="comment">         *      inconsistency within the whole system. */</span>
<a name="l00362"></a>00362 }
<a name="l00363"></a>00363 
<a name="l00378"></a>00378 <span class="keywordtype">int</span> ofd_verify_ff(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structofd__object.html">ofd_object</a> *fo,
<a name="l00379"></a>00379                   <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa)
<a name="l00380"></a>00380 {
<a name="l00381"></a>00381         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   *pfid   = &amp;fo-&gt;ofo_pfid;
<a name="l00382"></a>00382         <span class="keywordtype">int</span>              rc     = 0;
<a name="l00383"></a>00383         ENTRY;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385         <span class="keywordflow">if</span> (fid_is_sane(pfid)) {
<a name="l00386"></a>00386                 <span class="keywordflow">if</span> (likely(oa-&gt;o_parent_seq == pfid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> &amp;&amp;
<a name="l00387"></a>00387                            oa-&gt;o_parent_oid == pfid-&gt;f_oid &amp;&amp;
<a name="l00388"></a>00388                            oa-&gt;o_stripe_idx == pfid-&gt;f_stripe_idx))
<a name="l00389"></a>00389                         RETURN(0);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391                 <span class="keywordflow">if</span> (fo-&gt;ofo_pfid_verified)
<a name="l00392"></a>00392                         RETURN(-EPERM);
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395         <span class="comment">/* The OST-object may be inconsistent, and we need further verification.</span>
<a name="l00396"></a>00396 <span class="comment">         * To avoid block the RPC service thread, return -EINPROGRESS to client</span>
<a name="l00397"></a>00397 <span class="comment">         * and make it retry later. */</span>
<a name="l00398"></a>00398         <span class="keywordflow">if</span> (fo-&gt;ofo_pfid_checking)
<a name="l00399"></a>00399                 RETURN(-EINPROGRESS);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401         rc = ofd_object_ff_load(env, fo);
<a name="l00402"></a>00402         <span class="keywordflow">if</span> (rc == -ENODATA)
<a name="l00403"></a>00403                 RETURN(0);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00406"></a>00406                 RETURN(rc);
<a name="l00407"></a>00407 
<a name="l00408"></a>00408         <span class="keywordflow">if</span> (likely(oa-&gt;o_parent_seq == pfid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> &amp;&amp;
<a name="l00409"></a>00409                    oa-&gt;o_parent_oid == pfid-&gt;f_oid &amp;&amp;
<a name="l00410"></a>00410                    oa-&gt;o_stripe_idx == pfid-&gt;f_stripe_idx))
<a name="l00411"></a>00411                 RETURN(0);
<a name="l00412"></a>00412 
<a name="l00413"></a>00413         <span class="comment">/* Push it to the dedicated thread for further verification. */</span>
<a name="l00414"></a>00414         ofd_add_inconsistency_item(env, fo, oa);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         RETURN(-EINPROGRESS);
<a name="l00417"></a>00417 }
<a name="l00418"></a>00418 
<a name="l00440"></a>00440 <span class="keyword">static</span> <span class="keywordtype">int</span> ofd_preprw_read(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,
<a name="l00441"></a>00441                            <span class="keyword">struct</span> <a class="code" href="structofd__device.html">ofd_device</a> *ofd, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00442"></a>00442                            <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la, <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa, <span class="keywordtype">int</span> niocount,
<a name="l00443"></a>00443                            <span class="keyword">struct</span> <a class="code" href="structniobuf__remote.html">niobuf_remote</a> *rnb, <span class="keywordtype">int</span> *nr_local,
<a name="l00444"></a>00444                            <span class="keyword">struct</span> <a class="code" href="structniobuf__local.html">niobuf_local</a> *lnb, <span class="keywordtype">char</span> *jobid)
<a name="l00445"></a>00445 {
<a name="l00446"></a>00446         <span class="keyword">struct </span><a class="code" href="structofd__object.html">ofd_object</a>       *fo;
<a name="l00447"></a>00447         <span class="keywordtype">int</span>                      i, j, rc, tot_bytes = 0;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449         ENTRY;
<a name="l00450"></a>00450         LASSERT(env != NULL);
<a name="l00451"></a>00451 
<a name="l00452"></a>00452         fo = ofd_object_find(env, ofd, fid);
<a name="l00453"></a>00453         <span class="keywordflow">if</span> (IS_ERR(fo))
<a name="l00454"></a>00454                 RETURN(PTR_ERR(fo));
<a name="l00455"></a>00455         LASSERT(fo != NULL);
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         ofd_read_lock(env, fo);
<a name="l00458"></a>00458         <span class="keywordflow">if</span> (!ofd_object_exists(fo))
<a name="l00459"></a>00459                 GOTO(unlock, rc = -ENOENT);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (ofd-&gt;ofd_lfsck_verify_pfid &amp;&amp; oa-&gt;o_valid &amp; OBD_MD_FLFID) {
<a name="l00462"></a>00462                 rc = ofd_verify_ff(env, fo, oa);
<a name="l00463"></a>00463                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00464"></a>00464                         GOTO(unlock, rc);
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         *nr_local = 0;
<a name="l00468"></a>00468         <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; niocount; i++) {
<a name="l00469"></a>00469                 rc = dt_bufs_get(env, ofd_object_child(fo), rnb + i,
<a name="l00470"></a>00470                                  lnb + j, 0);
<a name="l00471"></a>00471                 <span class="keywordflow">if</span> (unlikely(rc &lt; 0))
<a name="l00472"></a>00472                         GOTO(buf_put, rc);
<a name="l00473"></a>00473                 LASSERT(rc &lt;= PTLRPC_MAX_BRW_PAGES);
<a name="l00474"></a>00474                 <span class="comment">/* correct index for local buffers to continue with */</span>
<a name="l00475"></a>00475                 j += rc;
<a name="l00476"></a>00476                 *nr_local += rc;
<a name="l00477"></a>00477                 LASSERT(j &lt;= PTLRPC_MAX_BRW_PAGES);
<a name="l00478"></a>00478                 tot_bytes += rnb[i].rnb_len;
<a name="l00479"></a>00479         }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         LASSERT(*nr_local &gt; 0 &amp;&amp; *nr_local &lt;= PTLRPC_MAX_BRW_PAGES);
<a name="l00482"></a>00482         rc = dt_attr_get(env, ofd_object_child(fo), la);
<a name="l00483"></a>00483         <span class="keywordflow">if</span> (unlikely(rc))
<a name="l00484"></a>00484                 GOTO(buf_put, rc);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486         rc = dt_read_prep(env, ofd_object_child(fo), lnb, *nr_local);
<a name="l00487"></a>00487         <span class="keywordflow">if</span> (unlikely(rc))
<a name="l00488"></a>00488                 GOTO(buf_put, rc);
<a name="l00489"></a>00489 
<a name="l00490"></a>00490         ofd_counter_incr(exp, LPROC_OFD_STATS_READ, jobid, tot_bytes);
<a name="l00491"></a>00491         RETURN(0);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 buf_put:
<a name="l00494"></a>00494         dt_bufs_put(env, ofd_object_child(fo), lnb, *nr_local);
<a name="l00495"></a>00495 unlock:
<a name="l00496"></a>00496         ofd_read_unlock(env, fo);
<a name="l00497"></a>00497         ofd_object_put(env, fo);
<a name="l00498"></a>00498         <span class="keywordflow">return</span> rc;
<a name="l00499"></a>00499 }
<a name="l00500"></a>00500 
<a name="l00524"></a>00524 <span class="keyword">static</span> <span class="keywordtype">int</span> ofd_preprw_write(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,
<a name="l00525"></a>00525                             <span class="keyword">struct</span> <a class="code" href="structofd__device.html">ofd_device</a> *ofd, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00526"></a>00526                             <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la, <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa,
<a name="l00527"></a>00527                             <span class="keywordtype">int</span> objcount, <span class="keyword">struct</span> <a class="code" href="structobd__ioobj.html">obd_ioobj</a> *obj,
<a name="l00528"></a>00528                             <span class="keyword">struct</span> <a class="code" href="structniobuf__remote.html">niobuf_remote</a> *rnb, <span class="keywordtype">int</span> *nr_local,
<a name="l00529"></a>00529                             <span class="keyword">struct</span> <a class="code" href="structniobuf__local.html">niobuf_local</a> *lnb, <span class="keywordtype">char</span> *jobid)
<a name="l00530"></a>00530 {
<a name="l00531"></a>00531         <span class="keyword">struct </span><a class="code" href="structofd__object.html">ofd_object</a>       *fo;
<a name="l00532"></a>00532         <span class="keywordtype">int</span>                      i, j, k, rc = 0, tot_bytes = 0;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         ENTRY;
<a name="l00535"></a>00535         LASSERT(env != NULL);
<a name="l00536"></a>00536         LASSERT(objcount == 1);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538         <span class="keywordflow">if</span> (unlikely(exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_recovering)) {
<a name="l00539"></a>00539                 u64 seq = <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid);
<a name="l00540"></a>00540                 u64 oid = fid_oid(fid);
<a name="l00541"></a>00541                 <span class="keyword">struct </span><a class="code" href="structofd__seq.html">ofd_seq</a> *oseq;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543                 oseq = ofd_seq_load(env, ofd, seq);
<a name="l00544"></a>00544                 <span class="keywordflow">if</span> (IS_ERR(oseq)) {
<a name="l00545"></a>00545                         CERROR(<span class="stringliteral">&quot;%s: Can&apos;t find FID Sequence &quot;</span>LPX64<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l00546"></a>00546                                ofd_name(ofd), seq, (<span class="keywordtype">int</span>)PTR_ERR(oseq));
<a name="l00547"></a>00547                         GOTO(out, rc = -EINVAL);
<a name="l00548"></a>00548                 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550                 <span class="keywordflow">if</span> (oid &gt; ofd_seq_last_oid(oseq)) {
<a name="l00551"></a>00551                         <span class="keywordtype">int</span> sync = 0;
<a name="l00552"></a>00552                         <span class="keywordtype">int</span> diff;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554                         mutex_lock(&amp;oseq-&gt;os_create_lock);
<a name="l00555"></a>00555                         diff = oid - ofd_seq_last_oid(oseq);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557                         <span class="comment">/* Do sync create if the seq is about to used up */</span>
<a name="l00558"></a>00558                         <span class="keywordflow">if</span> (fid_seq_is_idif(seq) || fid_seq_is_mdt0(seq)) {
<a name="l00559"></a>00559                                 <span class="keywordflow">if</span> (unlikely(oid &gt;= IDIF_MAX_OID - 1))
<a name="l00560"></a>00560                                         sync = 1;
<a name="l00561"></a>00561                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid_seq_is_norm(seq)) {
<a name="l00562"></a>00562                                 <span class="keywordflow">if</span> (unlikely(oid &gt;=
<a name="l00563"></a>00563                                              LUSTRE_DATA_SEQ_MAX_WIDTH - 1))
<a name="l00564"></a>00564                                         sync = 1;
<a name="l00565"></a>00565                         } <span class="keywordflow">else</span> {
<a name="l00566"></a>00566                                 CERROR(<span class="stringliteral">&quot;%s : invalid o_seq &quot;</span>DOSTID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00567"></a>00567                                        ofd_name(ofd), POSTID(&amp;oa-&gt;o_oi));
<a name="l00568"></a>00568                                 mutex_unlock(&amp;oseq-&gt;os_create_lock);
<a name="l00569"></a>00569                                 ofd_seq_put(env, oseq);
<a name="l00570"></a>00570                                 GOTO(out, rc = -EINVAL);
<a name="l00571"></a>00571                         }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573                         <span class="keywordflow">while</span> (diff &gt; 0) {
<a name="l00574"></a>00574                                 u64 next_id = ofd_seq_last_oid(oseq) + 1;
<a name="l00575"></a>00575                                 <span class="keywordtype">int</span> count = ofd_precreate_batch(ofd, diff);
<a name="l00576"></a>00576 
<a name="l00577"></a>00577                                 rc = ofd_precreate_objects(env, ofd, next_id,
<a name="l00578"></a>00578                                                            oseq, count, sync);
<a name="l00579"></a>00579                                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00580"></a>00580                                         mutex_unlock(&amp;oseq-&gt;os_create_lock);
<a name="l00581"></a>00581                                         ofd_seq_put(env, oseq);
<a name="l00582"></a>00582                                         GOTO(out, rc);
<a name="l00583"></a>00583                                 }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585                                 diff -= rc;
<a name="l00586"></a>00586                         }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588                         mutex_unlock(&amp;oseq-&gt;os_create_lock);
<a name="l00589"></a>00589                 }
<a name="l00590"></a>00590 
<a name="l00591"></a>00591                 ofd_seq_put(env, oseq);
<a name="l00592"></a>00592         }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594         fo = ofd_object_find(env, ofd, fid);
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (IS_ERR(fo))
<a name="l00596"></a>00596                 GOTO(out, rc = PTR_ERR(fo));
<a name="l00597"></a>00597         LASSERT(fo != NULL);
<a name="l00598"></a>00598 
<a name="l00599"></a>00599         ofd_read_lock(env, fo);
<a name="l00600"></a>00600         <span class="keywordflow">if</span> (!ofd_object_exists(fo)) {
<a name="l00601"></a>00601                 CERROR(<span class="stringliteral">&quot;%s: BRW to missing obj &quot;</span>DOSTID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00602"></a>00602                        exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_name, POSTID(&amp;obj-&gt;ioo_oid));
<a name="l00603"></a>00603                 ofd_read_unlock(env, fo);
<a name="l00604"></a>00604                 ofd_object_put(env, fo);
<a name="l00605"></a>00605                 GOTO(out, rc = -ENOENT);
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         <span class="keywordflow">if</span> (ofd-&gt;ofd_lfsck_verify_pfid &amp;&amp; oa-&gt;o_valid &amp; OBD_MD_FLFID) {
<a name="l00609"></a>00609                 rc = ofd_verify_ff(env, fo, oa);
<a name="l00610"></a>00610                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l00611"></a>00611                         ofd_read_unlock(env, fo);
<a name="l00612"></a>00612                         ofd_object_put(env, fo);
<a name="l00613"></a>00613                         GOTO(out, rc);
<a name="l00614"></a>00614                 }
<a name="l00615"></a>00615         }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617         <span class="comment">/* Process incoming grant info, set OBD_BRW_GRANTED flag and grant some</span>
<a name="l00618"></a>00618 <span class="comment">         * space back if possible */</span>
<a name="l00619"></a>00619         ofd_grant_prepare_write(env, exp, oa, rnb, obj-&gt;ioo_bufcnt);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621         <span class="comment">/* parse remote buffers to local buffers and prepare the latter */</span>
<a name="l00622"></a>00622         *nr_local = 0;
<a name="l00623"></a>00623         <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; obj-&gt;ioo_bufcnt; i++) {
<a name="l00624"></a>00624                 rc = dt_bufs_get(env, ofd_object_child(fo),
<a name="l00625"></a>00625                                  rnb + i, lnb + j, 1);
<a name="l00626"></a>00626                 <span class="keywordflow">if</span> (unlikely(rc &lt; 0))
<a name="l00627"></a>00627                         GOTO(err, rc);
<a name="l00628"></a>00628                 LASSERT(rc &lt;= PTLRPC_MAX_BRW_PAGES);
<a name="l00629"></a>00629                 <span class="comment">/* correct index for local buffers to continue with */</span>
<a name="l00630"></a>00630                 <span class="keywordflow">for</span> (k = 0; k &lt; rc; k++) {
<a name="l00631"></a>00631                         lnb[j+k].lnb_flags = rnb[i].rnb_flags;
<a name="l00632"></a>00632                         <span class="keywordflow">if</span> (!(rnb[i].rnb_flags &amp; OBD_BRW_GRANTED))
<a name="l00633"></a>00633                                 lnb[j+k].lnb_rc = -ENOSPC;
<a name="l00634"></a>00634 
<a name="l00635"></a>00635                         <span class="comment">/* remote client can&apos;t break through quota */</span>
<a name="l00636"></a>00636                         <span class="keywordflow">if</span> (exp_connect_rmtclient(exp))
<a name="l00637"></a>00637                                 lnb[j+k].lnb_flags &amp;= ~OBD_BRW_NOQUOTA;
<a name="l00638"></a>00638                 }
<a name="l00639"></a>00639                 j += rc;
<a name="l00640"></a>00640                 *nr_local += rc;
<a name="l00641"></a>00641                 LASSERT(j &lt;= PTLRPC_MAX_BRW_PAGES);
<a name="l00642"></a>00642                 tot_bytes += rnb[i].rnb_len;
<a name="l00643"></a>00643         }
<a name="l00644"></a>00644         LASSERT(*nr_local &gt; 0 &amp;&amp; *nr_local &lt;= PTLRPC_MAX_BRW_PAGES);
<a name="l00645"></a>00645 
<a name="l00646"></a>00646         rc = dt_write_prep(env, ofd_object_child(fo), lnb, *nr_local);
<a name="l00647"></a>00647         <span class="keywordflow">if</span> (unlikely(rc != 0))
<a name="l00648"></a>00648                 GOTO(err, rc);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         ofd_counter_incr(exp, LPROC_OFD_STATS_WRITE, jobid, tot_bytes);
<a name="l00651"></a>00651         RETURN(0);
<a name="l00652"></a>00652 err:
<a name="l00653"></a>00653         dt_bufs_put(env, ofd_object_child(fo), lnb, *nr_local);
<a name="l00654"></a>00654         ofd_read_unlock(env, fo);
<a name="l00655"></a>00655         ofd_object_put(env, fo);
<a name="l00656"></a>00656         <span class="comment">/* ofd_grant_prepare_write() was called, so we must commit */</span>
<a name="l00657"></a>00657         ofd_grant_commit(exp, oa-&gt;o_grant_used, rc);
<a name="l00658"></a>00658 out:
<a name="l00659"></a>00659         <span class="comment">/* let&apos;s still process incoming grant information packed in the oa,</span>
<a name="l00660"></a>00660 <span class="comment">         * but without enforcing grant since we won&apos;t proceed with the write.</span>
<a name="l00661"></a>00661 <span class="comment">         * Just like a read request actually. */</span>
<a name="l00662"></a>00662         ofd_grant_prepare_read(env, exp, oa);
<a name="l00663"></a>00663         <span class="keywordflow">return</span> rc;
<a name="l00664"></a>00664 }
<a name="l00665"></a>00665 
<a name="l00685"></a>00685 <span class="keywordtype">int</span> ofd_preprw(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">int</span> cmd, <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,
<a name="l00686"></a>00686                <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa, <span class="keywordtype">int</span> objcount, <span class="keyword">struct</span> <a class="code" href="structobd__ioobj.html">obd_ioobj</a> *obj,
<a name="l00687"></a>00687                <span class="keyword">struct</span> <a class="code" href="structniobuf__remote.html">niobuf_remote</a> *rnb, <span class="keywordtype">int</span> *nr_local,
<a name="l00688"></a>00688                <span class="keyword">struct</span> <a class="code" href="structniobuf__local.html">niobuf_local</a> *lnb)
<a name="l00689"></a>00689 {
<a name="l00690"></a>00690         <span class="keyword">struct </span><a class="code" href="structtgt__session__info.html">tgt_session_info</a> *tsi = tgt_ses_info(env);
<a name="l00691"></a>00691         <span class="keyword">struct </span><a class="code" href="structofd__device.html">ofd_device</a>       *ofd = ofd_exp(exp);
<a name="l00692"></a>00692         <span class="keyword">struct </span><a class="code" href="structofd__thread__info.html">ofd_thread_info</a>  *info;
<a name="l00693"></a>00693         <span class="keywordtype">char</span>                    *jobid;
<a name="l00694"></a>00694         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>     *fid = &amp;oa-&gt;o_oi.oi_fid;
<a name="l00695"></a>00695         <span class="keywordtype">int</span>                      rc = 0;
<a name="l00696"></a>00696 
<a name="l00697"></a>00697         <span class="keywordflow">if</span> (*nr_local &gt; PTLRPC_MAX_BRW_PAGES) {
<a name="l00698"></a>00698                 CERROR(<span class="stringliteral">&quot;%s: bulk has too many pages %d, which exceeds the&quot;</span>
<a name="l00699"></a>00699                        <span class="stringliteral">&quot;maximum pages per RPC of %d\n&quot;</span>,
<a name="l00700"></a>00700                        exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_name, *nr_local, PTLRPC_MAX_BRW_PAGES);
<a name="l00701"></a>00701                 RETURN(-EPROTO);
<a name="l00702"></a>00702         }
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         <span class="keywordflow">if</span> (tgt_ses_req(tsi) == NULL) { <span class="comment">/* echo client case */</span>
<a name="l00705"></a>00705                 info = ofd_info_init(env, exp);
<a name="l00706"></a>00706                 jobid = NULL;
<a name="l00707"></a>00707         } <span class="keywordflow">else</span> {
<a name="l00708"></a>00708                 info = tsi2ofd_info(tsi);
<a name="l00709"></a>00709                 jobid = tsi-&gt;tsi_jobid;
<a name="l00710"></a>00710         }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         LASSERT(oa != NULL);
<a name="l00713"></a>00713 
<a name="l00714"></a>00714         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_SRV_ENOENT)) {
<a name="l00715"></a>00715                 <span class="keyword">struct </span><a class="code" href="structofd__seq.html">ofd_seq</a>          *oseq;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717                 oseq = ofd_seq_load(env, ofd, ostid_seq(&amp;oa-&gt;o_oi));
<a name="l00718"></a>00718                 <span class="keywordflow">if</span> (IS_ERR(oseq)) {
<a name="l00719"></a>00719                         CERROR(<span class="stringliteral">&quot;%s: Can not find seq for &quot;</span>DOSTID
<a name="l00720"></a>00720                                <span class="stringliteral">&quot;: rc = %ld\n&quot;</span>, ofd_name(ofd), POSTID(&amp;oa-&gt;o_oi),
<a name="l00721"></a>00721                                PTR_ERR(oseq));
<a name="l00722"></a>00722                         RETURN(-EINVAL);
<a name="l00723"></a>00723                 }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725                 <span class="keywordflow">if</span> (oseq-&gt;os_destroys_in_progress == 0) {
<a name="l00726"></a>00726                         <span class="comment">/* don&apos;t fail lookups for orphan recovery, it causes</span>
<a name="l00727"></a>00727 <span class="comment">                         * later LBUGs when objects still exist during</span>
<a name="l00728"></a>00728 <span class="comment">                         * precreate */</span>
<a name="l00729"></a>00729                         ofd_seq_put(env, oseq);
<a name="l00730"></a>00730                         RETURN(-ENOENT);
<a name="l00731"></a>00731                 }
<a name="l00732"></a>00732                 ofd_seq_put(env, oseq);
<a name="l00733"></a>00733         }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         LASSERT(objcount == 1);
<a name="l00736"></a>00736         LASSERT(obj-&gt;ioo_bufcnt &gt; 0);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         <span class="keywordflow">if</span> (cmd == OBD_BRW_WRITE) {
<a name="l00739"></a>00739                 la_from_obdo(&amp;info-&gt;fti_attr, oa, OBD_MD_FLGETATTR);
<a name="l00740"></a>00740                 rc = ofd_preprw_write(env, exp, ofd, fid, &amp;info-&gt;fti_attr, oa,
<a name="l00741"></a>00741                                       objcount, obj, rnb, nr_local, lnb, jobid);
<a name="l00742"></a>00742         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmd == OBD_BRW_READ) {
<a name="l00743"></a>00743                 ofd_grant_prepare_read(env, exp, oa);
<a name="l00744"></a>00744                 rc = ofd_preprw_read(env, exp, ofd, fid, &amp;info-&gt;fti_attr, oa,
<a name="l00745"></a>00745                                      obj-&gt;ioo_bufcnt, rnb, nr_local, lnb,
<a name="l00746"></a>00746                                      jobid);
<a name="l00747"></a>00747                 obdo_from_la(oa, &amp;info-&gt;fti_attr, LA_ATIME);
<a name="l00748"></a>00748         } <span class="keywordflow">else</span> {
<a name="l00749"></a>00749                 CERROR(<span class="stringliteral">&quot;%s: wrong cmd %d received!\n&quot;</span>,
<a name="l00750"></a>00750                        exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_name, cmd);
<a name="l00751"></a>00751                 rc = -EPROTO;
<a name="l00752"></a>00752         }
<a name="l00753"></a>00753         RETURN(rc);
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 
<a name="l00771"></a>00771 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00772"></a>00772 ofd_commitrw_read(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structofd__device.html">ofd_device</a> *ofd,
<a name="l00773"></a>00773                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keywordtype">int</span> objcount, <span class="keywordtype">int</span> niocount,
<a name="l00774"></a>00774                   <span class="keyword">struct</span> <a class="code" href="structniobuf__local.html">niobuf_local</a> *lnb)
<a name="l00775"></a>00775 {
<a name="l00776"></a>00776         <span class="keyword">struct </span><a class="code" href="structofd__object.html">ofd_object</a> *fo;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778         ENTRY;
<a name="l00779"></a>00779 
<a name="l00780"></a>00780         LASSERT(niocount &gt; 0);
<a name="l00781"></a>00781 
<a name="l00782"></a>00782         fo = ofd_object_find(env, ofd, fid);
<a name="l00783"></a>00783         <span class="keywordflow">if</span> (IS_ERR(fo))
<a name="l00784"></a>00784                 RETURN(PTR_ERR(fo));
<a name="l00785"></a>00785         LASSERT(fo != NULL);
<a name="l00786"></a>00786         LASSERT(ofd_object_exists(fo));
<a name="l00787"></a>00787         dt_bufs_put(env, ofd_object_child(fo), lnb, niocount);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789         ofd_read_unlock(env, fo);
<a name="l00790"></a>00790         ofd_object_put(env, fo);
<a name="l00791"></a>00791         <span class="comment">/* second put is pair to object_get in ofd_preprw_read */</span>
<a name="l00792"></a>00792         ofd_object_put(env, fo);
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         RETURN(0);
<a name="l00795"></a>00795 }
<a name="l00796"></a>00796 
<a name="l00812"></a>00812 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00813"></a>00813 ofd_write_attr_set(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structofd__device.html">ofd_device</a> *ofd,
<a name="l00814"></a>00814                    <span class="keyword">struct</span> <a class="code" href="structofd__object.html">ofd_object</a> *ofd_obj, <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la,
<a name="l00815"></a>00815                    <span class="keyword">struct</span> <a class="code" href="structfilter__fid.html">filter_fid</a> *ff)
<a name="l00816"></a>00816 {
<a name="l00817"></a>00817         <span class="keyword">struct </span><a class="code" href="structofd__thread__info.html">ofd_thread_info</a>  *info = ofd_info(env);
<a name="l00818"></a>00818         __u64                    valid = la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a>;
<a name="l00819"></a>00819         <span class="keywordtype">int</span>                      rc;
<a name="l00820"></a>00820         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *th;
<a name="l00821"></a>00821         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *dt_obj;
<a name="l00822"></a>00822         <span class="keywordtype">int</span>                      ff_needed = 0;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824         ENTRY;
<a name="l00825"></a>00825 
<a name="l00826"></a>00826         LASSERT(la);
<a name="l00827"></a>00827 
<a name="l00828"></a>00828         dt_obj = ofd_object_child(ofd_obj);
<a name="l00829"></a>00829         LASSERT(dt_obj != NULL);
<a name="l00830"></a>00830 
<a name="l00831"></a>00831         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp;= LA_UID | LA_GID;
<a name="l00832"></a>00832 
<a name="l00833"></a>00833         rc = ofd_attr_handle_ugid(env, ofd_obj, la, 0 <span class="comment">/* !is_setattr */</span>);
<a name="l00834"></a>00834         <span class="keywordflow">if</span> (rc != 0)
<a name="l00835"></a>00835                 GOTO(out, rc);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837         <span class="keywordflow">if</span> (ff != NULL) {
<a name="l00838"></a>00838                 rc = ofd_object_ff_load(env, ofd_obj);
<a name="l00839"></a>00839                 <span class="keywordflow">if</span> (rc == -ENODATA)
<a name="l00840"></a>00840                         ff_needed = 1;
<a name="l00841"></a>00841                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00842"></a>00842                         GOTO(out, rc);
<a name="l00843"></a>00843         }
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         <span class="keywordflow">if</span> (!la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp;&amp; !ff_needed)
<a name="l00846"></a>00846                 <span class="comment">/* no attributes to set */</span>
<a name="l00847"></a>00847                 GOTO(out, rc = 0);
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         th = ofd_trans_create(env, ofd);
<a name="l00850"></a>00850         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l00851"></a>00851                 GOTO(out, rc = PTR_ERR(th));
<a name="l00852"></a>00852 
<a name="l00853"></a>00853         <span class="keywordflow">if</span> (la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a>) {
<a name="l00854"></a>00854                 rc = dt_declare_attr_set(env, dt_obj, la, th);
<a name="l00855"></a>00855                 <span class="keywordflow">if</span> (rc)
<a name="l00856"></a>00856                         GOTO(out_tx, rc);
<a name="l00857"></a>00857         }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859         <span class="keywordflow">if</span> (ff_needed) {
<a name="l00860"></a>00860                 <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_UNMATCHED_PAIR1))
<a name="l00861"></a>00861                         ff-&gt;ff_parent.f_oid = cpu_to_le32(1UL &lt;&lt; 31);
<a name="l00862"></a>00862                 <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_UNMATCHED_PAIR2))
<a name="l00863"></a>00863                         ff-&gt;ff_parent.f_oid =
<a name="l00864"></a>00864                         cpu_to_le32(le32_to_cpu(ff-&gt;ff_parent.f_oid) - 1);
<a name="l00865"></a>00865 
<a name="l00866"></a>00866                 info-&gt;fti_buf.lb_buf = ff;
<a name="l00867"></a>00867                 info-&gt;fti_buf.lb_len = <span class="keyword">sizeof</span>(*ff);
<a name="l00868"></a>00868                 rc = dt_declare_xattr_set(env, dt_obj, &amp;info-&gt;fti_buf,
<a name="l00869"></a>00869                                           XATTR_NAME_FID, 0, th);
<a name="l00870"></a>00870                 <span class="keywordflow">if</span> (rc)
<a name="l00871"></a>00871                         GOTO(out_tx, rc);
<a name="l00872"></a>00872         }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874         <span class="comment">/* We don&apos;t need a transno for this operation which will be re-executed</span>
<a name="l00875"></a>00875 <span class="comment">         * anyway when the OST_WRITE (with a transno assigned) is replayed */</span>
<a name="l00876"></a>00876         rc = dt_trans_start_local(env, ofd-&gt;ofd_osd , th);
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (rc)
<a name="l00878"></a>00878                 GOTO(out_tx, rc);
<a name="l00879"></a>00879 
<a name="l00880"></a>00880         <span class="comment">/* set uid/gid */</span>
<a name="l00881"></a>00881         <span class="keywordflow">if</span> (la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a>) {
<a name="l00882"></a>00882                 rc = dt_attr_set(env, dt_obj, la, th);
<a name="l00883"></a>00883                 <span class="keywordflow">if</span> (rc)
<a name="l00884"></a>00884                         GOTO(out_tx, rc);
<a name="l00885"></a>00885         }
<a name="l00886"></a>00886 
<a name="l00887"></a>00887         <span class="comment">/* set filter fid EA */</span>
<a name="l00888"></a>00888         <span class="keywordflow">if</span> (ff_needed) {
<a name="l00889"></a>00889                 <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_NOPFID))
<a name="l00890"></a>00890                         GOTO(out_tx, rc);
<a name="l00891"></a>00891 
<a name="l00892"></a>00892                 rc = dt_xattr_set(env, dt_obj, &amp;info-&gt;fti_buf, XATTR_NAME_FID,
<a name="l00893"></a>00893                                   0, th);
<a name="l00894"></a>00894                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l00895"></a>00895                         ofd_obj-&gt;ofo_pfid.<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = le64_to_cpu(ff-&gt;ff_parent.<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a>);
<a name="l00896"></a>00896                         ofd_obj-&gt;ofo_pfid.f_oid = le32_to_cpu(ff-&gt;ff_parent.f_oid);
<a name="l00897"></a>00897                         <span class="comment">/* Currently, the filter_fid::ff_parent::f_ver is not</span>
<a name="l00898"></a>00898 <span class="comment">                         * the real parent MDT-object&apos;s FID::f_ver, instead it</span>
<a name="l00899"></a>00899 <span class="comment">                         * is the OST-object index in its parent MDT-object&apos;s</span>
<a name="l00900"></a>00900 <span class="comment">                         * layout EA. */</span>
<a name="l00901"></a>00901                         ofd_obj-&gt;ofo_pfid.f_stripe_idx =
<a name="l00902"></a>00902                                         le32_to_cpu(ff-&gt;ff_parent.f_stripe_idx);
<a name="l00903"></a>00903                 }
<a name="l00904"></a>00904         }
<a name="l00905"></a>00905 
<a name="l00906"></a>00906         GOTO(out_tx, rc);
<a name="l00907"></a>00907 
<a name="l00908"></a>00908 out_tx:
<a name="l00909"></a>00909         dt_trans_stop(env, ofd-&gt;ofd_osd, th);
<a name="l00910"></a>00910 out:
<a name="l00911"></a>00911         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = valid;
<a name="l00912"></a>00912         <span class="keywordflow">return</span> rc;
<a name="l00913"></a>00913 }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915 <span class="keyword">struct </span>ofd_soft_sync_callback {
<a name="l00916"></a>00916         <span class="keyword">struct </span><a class="code" href="structdt__txn__commit__cb.html">dt_txn_commit_cb</a>  ossc_cb;
<a name="l00917"></a>00917         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>       *ossc_exp;
<a name="l00918"></a>00918 };
<a name="l00919"></a>00919 
<a name="l00931"></a>00931 <span class="keyword">static</span> <span class="keywordtype">void</span> ofd_cb_soft_sync(<span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th,
<a name="l00932"></a>00932                              <span class="keyword">struct</span> <a class="code" href="structdt__txn__commit__cb.html">dt_txn_commit_cb</a> *cb, <span class="keywordtype">int</span> err)
<a name="l00933"></a>00933 {
<a name="l00934"></a>00934         <span class="keyword">struct </span>ofd_soft_sync_callback   *ossc;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936         ossc = container_of(cb, <span class="keyword">struct</span> ofd_soft_sync_callback, ossc_cb);
<a name="l00937"></a>00937 
<a name="l00938"></a>00938         CDEBUG(D_INODE, <span class="stringliteral">&quot;export %p soft sync count is reset\n&quot;</span>, ossc-&gt;ossc_exp);
<a name="l00939"></a>00939         atomic_set(&amp;ossc-&gt;ossc_exp-&gt;exp_filter_data.fed_soft_sync_count, 0);
<a name="l00940"></a>00940 
<a name="l00941"></a>00941         class_export_cb_put(ossc-&gt;ossc_exp);
<a name="l00942"></a>00942         OBD_FREE_PTR(ossc);
<a name="l00943"></a>00943 }
<a name="l00944"></a>00944 
<a name="l00961"></a>00961 <span class="keyword">static</span> <span class="keywordtype">int</span> ofd_soft_sync_cb_add(<span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th, <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp)
<a name="l00962"></a>00962 {
<a name="l00963"></a>00963         <span class="keyword">struct </span>ofd_soft_sync_callback           *ossc;
<a name="l00964"></a>00964         <span class="keyword">struct </span><a class="code" href="structdt__txn__commit__cb.html">dt_txn_commit_cb</a>                 *dcb;
<a name="l00965"></a>00965         <span class="keywordtype">int</span>                                      rc;
<a name="l00966"></a>00966 
<a name="l00967"></a>00967         OBD_ALLOC_PTR(ossc);
<a name="l00968"></a>00968         <span class="keywordflow">if</span> (ossc == NULL)
<a name="l00969"></a>00969                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00970"></a>00970 
<a name="l00971"></a>00971         ossc-&gt;ossc_exp = class_export_cb_get(exp);
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         dcb = &amp;ossc-&gt;ossc_cb;
<a name="l00974"></a>00974         dcb-&gt;dcb_func = ofd_cb_soft_sync;
<a name="l00975"></a>00975         INIT_LIST_HEAD(&amp;dcb-&gt;dcb_linkage);
<a name="l00976"></a>00976         strlcpy(dcb-&gt;dcb_name, <span class="stringliteral">&quot;ofd_cb_soft_sync&quot;</span>, <span class="keyword">sizeof</span>(dcb-&gt;dcb_name));
<a name="l00977"></a>00977 
<a name="l00978"></a>00978         rc = dt_trans_cb_add(th, dcb);
<a name="l00979"></a>00979         <span class="keywordflow">if</span> (rc) {
<a name="l00980"></a>00980                 class_export_cb_put(exp);
<a name="l00981"></a>00981                 OBD_FREE_PTR(ossc);
<a name="l00982"></a>00982         }
<a name="l00983"></a>00983 
<a name="l00984"></a>00984         <span class="keywordflow">return</span> rc;
<a name="l00985"></a>00985 }
<a name="l00986"></a>00986 
<a name="l01008"></a>01008 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01009"></a>01009 ofd_commitrw_write(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,
<a name="l01010"></a>01010                    <span class="keyword">struct</span> <a class="code" href="structofd__device.html">ofd_device</a> *ofd, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l01011"></a>01011                    <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la, <span class="keyword">struct</span> <a class="code" href="structfilter__fid.html">filter_fid</a> *ff, <span class="keywordtype">int</span> objcount,
<a name="l01012"></a>01012                    <span class="keywordtype">int</span> niocount, <span class="keyword">struct</span> <a class="code" href="structniobuf__local.html">niobuf_local</a> *lnb,
<a name="l01013"></a>01013                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> granted, <span class="keywordtype">int</span> old_rc)
<a name="l01014"></a>01014 {
<a name="l01015"></a>01015         <span class="keyword">struct </span><a class="code" href="structofd__object.html">ofd_object</a>       *fo;
<a name="l01016"></a>01016         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *o;
<a name="l01017"></a>01017         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *th;
<a name="l01018"></a>01018         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01019"></a>01019         <span class="keywordtype">int</span>                      retries = 0;
<a name="l01020"></a>01020         <span class="keywordtype">int</span>                      i;
<a name="l01021"></a>01021         <span class="keyword">struct </span><a class="code" href="structfilter__export__data.html" title="Filter (oss-side) specific import data.">filter_export_data</a> *fed = &amp;exp-&gt;exp_filter_data;
<a name="l01022"></a>01022         <span class="keywordtype">bool</span>                     soft_sync = <span class="keyword">false</span>;
<a name="l01023"></a>01023         <span class="keywordtype">bool</span>                     cb_registered = <span class="keyword">false</span>;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025         ENTRY;
<a name="l01026"></a>01026 
<a name="l01027"></a>01027         LASSERT(objcount == 1);
<a name="l01028"></a>01028 
<a name="l01029"></a>01029         fo = ofd_object_find(env, ofd, fid);
<a name="l01030"></a>01030         LASSERT(fo != NULL);
<a name="l01031"></a>01031         LASSERT(ofd_object_exists(fo));
<a name="l01032"></a>01032 
<a name="l01033"></a>01033         o = ofd_object_child(fo);
<a name="l01034"></a>01034         LASSERT(o != NULL);
<a name="l01035"></a>01035 
<a name="l01036"></a>01036         <span class="keywordflow">if</span> (old_rc)
<a name="l01037"></a>01037                 GOTO(out, rc = old_rc);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039         <span class="comment">/*</span>
<a name="l01040"></a>01040 <span class="comment">         * The first write to each object must set some attributes.  It is</span>
<a name="l01041"></a>01041 <span class="comment">         * important to set the uid/gid before calling</span>
<a name="l01042"></a>01042 <span class="comment">         * dt_declare_write_commit() since quota enforcement is now handled in</span>
<a name="l01043"></a>01043 <span class="comment">         * declare phases.</span>
<a name="l01044"></a>01044 <span class="comment">         */</span>
<a name="l01045"></a>01045         rc = ofd_write_attr_set(env, ofd, fo, la, ff);
<a name="l01046"></a>01046         <span class="keywordflow">if</span> (rc)
<a name="l01047"></a>01047                 GOTO(out, rc);
<a name="l01048"></a>01048 
<a name="l01049"></a>01049         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp;= LA_ATIME | LA_MTIME | LA_CTIME;
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 retry:
<a name="l01052"></a>01052         th = ofd_trans_create(env, ofd);
<a name="l01053"></a>01053         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l01054"></a>01054                 GOTO(out, rc = PTR_ERR(th));
<a name="l01055"></a>01055 
<a name="l01056"></a>01056         th-&gt;<a class="code" href="structthandle.html#a4ebd1192a1e6fd4868826aee3ad1ec05" title="whether we need sync commit">th_sync</a> |= ofd-&gt;ofd_syncjournal;
<a name="l01057"></a>01057         <span class="keywordflow">if</span> (th-&gt;<a class="code" href="structthandle.html#a4ebd1192a1e6fd4868826aee3ad1ec05" title="whether we need sync commit">th_sync</a> == 0) {
<a name="l01058"></a>01058                 <span class="keywordflow">for</span> (i = 0; i &lt; niocount; i++) {
<a name="l01059"></a>01059                         <span class="keywordflow">if</span> (!(lnb[i].lnb_flags &amp; OBD_BRW_ASYNC)) {
<a name="l01060"></a>01060                                 th-&gt;<a class="code" href="structthandle.html#a4ebd1192a1e6fd4868826aee3ad1ec05" title="whether we need sync commit">th_sync</a> = 1;
<a name="l01061"></a>01061                                 <span class="keywordflow">break</span>;
<a name="l01062"></a>01062                         }
<a name="l01063"></a>01063                         <span class="keywordflow">if</span> (lnb[i].lnb_flags &amp; OBD_BRW_SOFT_SYNC)
<a name="l01064"></a>01064                                 soft_sync = <span class="keyword">true</span>;
<a name="l01065"></a>01065                 }
<a name="l01066"></a>01066         }
<a name="l01067"></a>01067 
<a name="l01068"></a>01068         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_OST_DQACQ_NET))
<a name="l01069"></a>01069                 GOTO(out_stop, rc = -EINPROGRESS);
<a name="l01070"></a>01070 
<a name="l01071"></a>01071         rc = dt_declare_write_commit(env, o, lnb, niocount, th);
<a name="l01072"></a>01072         <span class="keywordflow">if</span> (rc)
<a name="l01073"></a>01073                 GOTO(out_stop, rc);
<a name="l01074"></a>01074 
<a name="l01075"></a>01075         <span class="keywordflow">if</span> (la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a>) {
<a name="l01076"></a>01076                 <span class="comment">/* update [mac]time if needed */</span>
<a name="l01077"></a>01077                 rc = dt_declare_attr_set(env, o, la, th);
<a name="l01078"></a>01078                 <span class="keywordflow">if</span> (rc)
<a name="l01079"></a>01079                         GOTO(out_stop, rc);
<a name="l01080"></a>01080         }
<a name="l01081"></a>01081 
<a name="l01082"></a>01082         rc = ofd_trans_start(env, ofd, fo, th);
<a name="l01083"></a>01083         <span class="keywordflow">if</span> (rc)
<a name="l01084"></a>01084                 GOTO(out_stop, rc);
<a name="l01085"></a>01085 
<a name="l01086"></a>01086         rc = dt_write_commit(env, o, lnb, niocount, th);
<a name="l01087"></a>01087         <span class="keywordflow">if</span> (rc)
<a name="l01088"></a>01088                 GOTO(out_stop, rc);
<a name="l01089"></a>01089 
<a name="l01090"></a>01090         <span class="keywordflow">if</span> (la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a>) {
<a name="l01091"></a>01091                 rc = dt_attr_set(env, o, la, th);
<a name="l01092"></a>01092                 <span class="keywordflow">if</span> (rc)
<a name="l01093"></a>01093                         GOTO(out_stop, rc);
<a name="l01094"></a>01094         }
<a name="l01095"></a>01095 
<a name="l01096"></a>01096         <span class="comment">/* get attr to return */</span>
<a name="l01097"></a>01097         rc = dt_attr_get(env, o, la);
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 out_stop:
<a name="l01100"></a>01100         <span class="comment">/* Force commit to make the just-deleted blocks</span>
<a name="l01101"></a>01101 <span class="comment">         * reusable. LU-456 */</span>
<a name="l01102"></a>01102         <span class="keywordflow">if</span> (rc == -ENOSPC)
<a name="l01103"></a>01103                 th-&gt;<a class="code" href="structthandle.html#a4ebd1192a1e6fd4868826aee3ad1ec05" title="whether we need sync commit">th_sync</a> = 1;
<a name="l01104"></a>01104 
<a name="l01105"></a>01105         <span class="comment">/* do this before trans stop in case commit has finished */</span>
<a name="l01106"></a>01106         <span class="keywordflow">if</span> (!th-&gt;<a class="code" href="structthandle.html#a4ebd1192a1e6fd4868826aee3ad1ec05" title="whether we need sync commit">th_sync</a> &amp;&amp; soft_sync &amp;&amp; !cb_registered) {
<a name="l01107"></a>01107                 ofd_soft_sync_cb_add(th, exp);
<a name="l01108"></a>01108                 cb_registered = <span class="keyword">true</span>;
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; granted &gt; 0) {
<a name="l01112"></a>01112                 <span class="keywordflow">if</span> (ofd_grant_commit_cb_add(th, exp, granted) == 0)
<a name="l01113"></a>01113                         granted = 0;
<a name="l01114"></a>01114         }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116         ofd_trans_stop(env, ofd, th, rc);
<a name="l01117"></a>01117         <span class="keywordflow">if</span> (rc == -ENOSPC &amp;&amp; retries++ &lt; 3) {
<a name="l01118"></a>01118                 CDEBUG(D_INODE, <span class="stringliteral">&quot;retry after force commit, retries:%d\n&quot;</span>,
<a name="l01119"></a>01119                        retries);
<a name="l01120"></a>01120                 <span class="keywordflow">goto</span> retry;
<a name="l01121"></a>01121         }
<a name="l01122"></a>01122 
<a name="l01123"></a>01123         <span class="keywordflow">if</span> (!soft_sync)
<a name="l01124"></a>01124                 <span class="comment">/* reset fed_soft_sync_count upon non-SOFT_SYNC RPC */</span>
<a name="l01125"></a>01125                 atomic_set(&amp;fed-&gt;fed_soft_sync_count, 0);
<a name="l01126"></a>01126         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (atomic_inc_return(&amp;fed-&gt;fed_soft_sync_count) ==
<a name="l01127"></a>01127                  ofd-&gt;ofd_soft_sync_limit)
<a name="l01128"></a>01128                 dt_commit_async(env, ofd-&gt;ofd_osd);
<a name="l01129"></a>01129 
<a name="l01130"></a>01130 out:
<a name="l01131"></a>01131         dt_bufs_put(env, o, lnb, niocount);
<a name="l01132"></a>01132         ofd_read_unlock(env, fo);
<a name="l01133"></a>01133         ofd_object_put(env, fo);
<a name="l01134"></a>01134         <span class="comment">/* second put is pair to object_get in ofd_preprw_write */</span>
<a name="l01135"></a>01135         ofd_object_put(env, fo);
<a name="l01136"></a>01136         <span class="keywordflow">if</span> (granted &gt; 0)
<a name="l01137"></a>01137                 ofd_grant_commit(exp, granted, old_rc);
<a name="l01138"></a>01138         RETURN(rc);
<a name="l01139"></a>01139 }
<a name="l01140"></a>01140 
<a name="l01163"></a>01163 <span class="keywordtype">int</span> ofd_commitrw(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">int</span> cmd, <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,
<a name="l01164"></a>01164                  <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa, <span class="keywordtype">int</span> objcount, <span class="keyword">struct</span> <a class="code" href="structobd__ioobj.html">obd_ioobj</a> *obj,
<a name="l01165"></a>01165                  <span class="keyword">struct</span> <a class="code" href="structniobuf__remote.html">niobuf_remote</a> *rnb, <span class="keywordtype">int</span> npages,
<a name="l01166"></a>01166                  <span class="keyword">struct</span> <a class="code" href="structniobuf__local.html">niobuf_local</a> *lnb, <span class="keywordtype">int</span> old_rc)
<a name="l01167"></a>01167 {
<a name="l01168"></a>01168         <span class="keyword">struct </span><a class="code" href="structofd__thread__info.html">ofd_thread_info</a>  *info = ofd_info(env);
<a name="l01169"></a>01169         <span class="keyword">struct </span><a class="code" href="structofd__mod__data.html">ofd_mod_data</a>     *fmd;
<a name="l01170"></a>01170         __u64                    valid;
<a name="l01171"></a>01171         <span class="keyword">struct </span><a class="code" href="structofd__device.html">ofd_device</a>       *ofd = ofd_exp(exp);
<a name="l01172"></a>01172         <span class="keyword">struct </span><a class="code" href="structfilter__fid.html">filter_fid</a>       *ff = NULL;
<a name="l01173"></a>01173         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>     *fid = &amp;oa-&gt;o_oi.oi_fid;
<a name="l01174"></a>01174         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176         LASSERT(npages &gt; 0);
<a name="l01177"></a>01177 
<a name="l01178"></a>01178         <span class="keywordflow">if</span> (cmd == OBD_BRW_WRITE) {
<a name="l01179"></a>01179                 <span class="comment">/* Don&apos;t update timestamps if this write is older than a</span>
<a name="l01180"></a>01180 <span class="comment">                 * setattr which modifies the timestamps. b=10150 */</span>
<a name="l01181"></a>01181 
<a name="l01182"></a>01182                 <span class="comment">/* XXX when we start having persistent reservations this needs</span>
<a name="l01183"></a>01183 <span class="comment">                 * to be changed to ofd_fmd_get() to create the fmd if it</span>
<a name="l01184"></a>01184 <span class="comment">                 * doesn&apos;t already exist so we can store the reservation handle</span>
<a name="l01185"></a>01185 <span class="comment">                 * there. */</span>
<a name="l01186"></a>01186                 valid = OBD_MD_FLUID | OBD_MD_FLGID;
<a name="l01187"></a>01187                 fmd = ofd_fmd_find(exp, fid);
<a name="l01188"></a>01188                 <span class="keywordflow">if</span> (!fmd || fmd-&gt;fmd_mactime_xid &lt; info-&gt;fti_xid)
<a name="l01189"></a>01189                         valid |= OBD_MD_FLATIME | OBD_MD_FLMTIME |
<a name="l01190"></a>01190                                  OBD_MD_FLCTIME;
<a name="l01191"></a>01191                 ofd_fmd_put(exp, fmd);
<a name="l01192"></a>01192                 la_from_obdo(&amp;info-&gt;fti_attr, oa, valid);
<a name="l01193"></a>01193 
<a name="l01194"></a>01194                 <span class="keywordflow">if</span> (oa-&gt;o_valid &amp; OBD_MD_FLFID) {
<a name="l01195"></a>01195                         ff = &amp;info-&gt;fti_mds_fid;
<a name="l01196"></a>01196                         ofd_prepare_fidea(ff, oa);
<a name="l01197"></a>01197                 }
<a name="l01198"></a>01198 
<a name="l01199"></a>01199                 rc = ofd_commitrw_write(env, exp, ofd, fid, &amp;info-&gt;fti_attr,
<a name="l01200"></a>01200                                         ff, objcount, npages, lnb,
<a name="l01201"></a>01201                                         oa-&gt;o_grant_used, old_rc);
<a name="l01202"></a>01202                 <span class="keywordflow">if</span> (rc == 0)
<a name="l01203"></a>01203                         obdo_from_la(oa, &amp;info-&gt;fti_attr,
<a name="l01204"></a>01204                                      OFD_VALID_FLAGS | LA_GID | LA_UID);
<a name="l01205"></a>01205                 <span class="keywordflow">else</span>
<a name="l01206"></a>01206                         obdo_from_la(oa, &amp;info-&gt;fti_attr, LA_GID | LA_UID);
<a name="l01207"></a>01207 
<a name="l01208"></a>01208                 <span class="comment">/* don&apos;t report overquota flag if we failed before reaching</span>
<a name="l01209"></a>01209 <span class="comment">                 * commit */</span>
<a name="l01210"></a>01210                 <span class="keywordflow">if</span> (old_rc == 0 &amp;&amp; (rc == 0 || rc == -EDQUOT)) {
<a name="l01211"></a>01211                         <span class="comment">/* return the overquota flags to client */</span>
<a name="l01212"></a>01212                         <span class="keywordflow">if</span> (lnb[0].lnb_flags &amp; OBD_BRW_OVER_USRQUOTA) {
<a name="l01213"></a>01213                                 <span class="keywordflow">if</span> (oa-&gt;o_valid &amp; OBD_MD_FLFLAGS)
<a name="l01214"></a>01214                                         oa-&gt;o_flags |= OBD_FL_NO_USRQUOTA;
<a name="l01215"></a>01215                                 <span class="keywordflow">else</span>
<a name="l01216"></a>01216                                         oa-&gt;o_flags = OBD_FL_NO_USRQUOTA;
<a name="l01217"></a>01217                         }
<a name="l01218"></a>01218 
<a name="l01219"></a>01219                         <span class="keywordflow">if</span> (lnb[0].lnb_flags &amp; OBD_BRW_OVER_GRPQUOTA) {
<a name="l01220"></a>01220                                 <span class="keywordflow">if</span> (oa-&gt;o_valid &amp; OBD_MD_FLFLAGS)
<a name="l01221"></a>01221                                         oa-&gt;o_flags |= OBD_FL_NO_GRPQUOTA;
<a name="l01222"></a>01222                                 <span class="keywordflow">else</span>
<a name="l01223"></a>01223                                         oa-&gt;o_flags = OBD_FL_NO_GRPQUOTA;
<a name="l01224"></a>01224                         }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226                         oa-&gt;o_valid |= OBD_MD_FLFLAGS;
<a name="l01227"></a>01227                         oa-&gt;o_valid |= OBD_MD_FLUSRQUOTA | OBD_MD_FLGRPQUOTA;
<a name="l01228"></a>01228                 }
<a name="l01229"></a>01229         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmd == OBD_BRW_READ) {
<a name="l01230"></a>01230                 <span class="keyword">struct </span><a class="code" href="structldlm__namespace.html" title="LDLM Namespace.">ldlm_namespace</a> *ns = ofd-&gt;ofd_namespace;
<a name="l01231"></a>01231 
<a name="l01232"></a>01232                 <span class="comment">/* If oa != NULL then ofd_preprw_read updated the inode</span>
<a name="l01233"></a>01233 <span class="comment">                 * atime and we should update the lvb so that other glimpses</span>
<a name="l01234"></a>01234 <span class="comment">                 * will also get the updated value. bug 5972 */</span>
<a name="l01235"></a>01235                 <span class="keywordflow">if</span> (oa &amp;&amp; ns &amp;&amp; ns-&gt;<a class="code" href="structldlm__namespace.html#ac6fc5806130bda67b8685acdb93ccf48" title="LVB operations for this namespace.">ns_lvbo</a> &amp;&amp; ns-&gt;<a class="code" href="structldlm__namespace.html#ac6fc5806130bda67b8685acdb93ccf48" title="LVB operations for this namespace.">ns_lvbo</a>-&gt;lvbo_update) {
<a name="l01236"></a>01236                          <span class="keyword">struct </span><a class="code" href="structldlm__resource.html" title="LDLM resource description.">ldlm_resource</a> *rs = NULL;
<a name="l01237"></a>01237 
<a name="l01238"></a>01238                         ost_fid_build_resid(fid, &amp;info-&gt;fti_resid);
<a name="l01239"></a>01239                         rs = <a class="code" href="group__LDLM.html#ga083fb1ea92619c4b2e526633c3a486fb" title="Return a reference to resource with given name, creating it if necessary.">ldlm_resource_get</a>(ns, NULL, &amp;info-&gt;fti_resid,
<a name="l01240"></a>01240                                                LDLM_EXTENT, 0);
<a name="l01241"></a>01241                         <span class="keywordflow">if</span> (!IS_ERR(rs)) {
<a name="l01242"></a>01242                                 ldlm_res_lvbo_update(rs, NULL, 1);
<a name="l01243"></a>01243                                 ldlm_resource_putref(rs);
<a name="l01244"></a>01244                         }
<a name="l01245"></a>01245                 }
<a name="l01246"></a>01246                 rc = ofd_commitrw_read(env, ofd, fid, objcount,
<a name="l01247"></a>01247                                        npages, lnb);
<a name="l01248"></a>01248                 <span class="keywordflow">if</span> (old_rc)
<a name="l01249"></a>01249                         rc = old_rc;
<a name="l01250"></a>01250         } <span class="keywordflow">else</span> {
<a name="l01251"></a>01251                 LBUG();
<a name="l01252"></a>01252                 rc = -EPROTO;
<a name="l01253"></a>01253         }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255         RETURN(rc);
<a name="l01256"></a>01256 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:18 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
