<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/osc/osc_cl_internal.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/osc/osc_cl_internal.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2012, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> */</span>
<a name="l00036"></a>00036 <span class="comment">/*</span>
<a name="l00037"></a>00037 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00038"></a>00038 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * Internal interfaces of OSC layer.</span>
<a name="l00041"></a>00041 <span class="comment"> *</span>
<a name="l00042"></a>00042 <span class="comment"> *   Author: Nikita Danilov &lt;nikita.danilov@sun.com&gt;</span>
<a name="l00043"></a>00043 <span class="comment"> *   Author: Jinshan Xiong &lt;jinshan.xiong@whamcloud.com&gt;</span>
<a name="l00044"></a>00044 <span class="comment"> */</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#ifndef OSC_CL_INTERNAL_H</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#define OSC_CL_INTERNAL_H</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;libcfs/libcfs.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;obd.h&gt;</span>
<a name="l00051"></a>00051 <span class="comment">/* osc_build_res_name() */</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;cl_object.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;osc_internal.h&quot;</span>
<a name="l00054"></a>00054 
<a name="l00059"></a>00059 <span class="keyword">struct </span><a class="code" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a>;
<a name="l00060"></a>00060 
<a name="l00064"></a><a class="code" href="structosc__io.html">00064</a> <span class="keyword">struct </span><a class="code" href="structosc__io.html" title="State maintained by osc layer for each IO context.">osc_io</a> {
<a name="l00066"></a><a class="code" href="structosc__io.html#a7ee5ca22311af0cd83adac47b95af6ca">00066</a>         <span class="keyword">struct </span><a class="code" href="structcl__io__slice.html" title="IO state private for a layer.">cl_io_slice</a> <a class="code" href="structosc__io.html#a7ee5ca22311af0cd83adac47b95af6ca" title="super class">oi_cl</a>;
<a name="l00068"></a><a class="code" href="structosc__io.html#a8dc8c1963fac8b54b8e5953f22352b3e">00068</a>         <span class="keywordtype">int</span>                <a class="code" href="structosc__io.html#a8dc8c1963fac8b54b8e5953f22352b3e" title="true if this io is lockless.">oi_lockless</a>:1,
<a name="l00070"></a>00070                            <a class="code" href="structosc__io.html#ab5b395882729990a4693d2e816799b92" title="true if this io is counted as active IO">oi_is_active</a>:1;
<a name="l00072"></a><a class="code" href="structosc__io.html#ac05667bcd9ece4df269f92cb403a95b1">00072</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>      <a class="code" href="structosc__io.html#ac05667bcd9ece4df269f92cb403a95b1" title="how many LRU pages are reserved for this IO">oi_lru_reserved</a>;
<a name="l00073"></a>00073 
<a name="l00076"></a><a class="code" href="structosc__io.html#a30e221731b68077ff9bbd54d983ba4d6">00076</a>         <span class="keyword">struct </span><a class="code" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a> *<a class="code" href="structosc__io.html#a30e221731b68077ff9bbd54d983ba4d6" title="active extents, we know how many bytes is going to be written, so having an active...">oi_active</a>;
<a name="l00079"></a><a class="code" href="structosc__io.html#afc3d50aeec62c272067b4e5f923ac420">00079</a>         <span class="keyword">struct </span><a class="code" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a> *<a class="code" href="structosc__io.html#afc3d50aeec62c272067b4e5f923ac420" title="partially truncated extent, we need to hold this extent to prevent page writeback...">oi_trunc</a>;
<a name="l00081"></a><a class="code" href="structosc__io.html#a40f597a8aa0127c8b2db17502f0dcbea">00081</a>         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>   *<a class="code" href="structosc__io.html#a40f597a8aa0127c8b2db17502f0dcbea" title="write osc_lock for this IO, used by osc_extent_find().">oi_write_osclock</a>;
<a name="l00082"></a>00082         <span class="keyword">struct </span><a class="code" href="structobdo.html">obdo</a>        oi_oa;
<a name="l00083"></a><a class="code" href="structosc__io_1_1osc__async__cbargs.html">00083</a>         <span class="keyword">struct </span><a class="code" href="structosc__io_1_1osc__async__cbargs.html">osc_async_cbargs</a> {
<a name="l00084"></a>00084                 <span class="keywordtype">bool</span>              opc_rpc_sent;
<a name="l00085"></a>00085                 <span class="keywordtype">int</span>               opc_rc;
<a name="l00086"></a>00086                 <span class="keyword">struct </span>completion       opc_sync;
<a name="l00087"></a>00087         } oi_cbarg;
<a name="l00088"></a>00088 };
<a name="l00089"></a>00089 
<a name="l00093"></a><a class="code" href="structosc__session.html">00093</a> <span class="keyword">struct </span><a class="code" href="structosc__session.html" title="State maintained by osc layer for the duration of a system call.">osc_session</a> {
<a name="l00094"></a>00094         <span class="keyword">struct </span><a class="code" href="structosc__io.html" title="State maintained by osc layer for each IO context.">osc_io</a>       os_io;
<a name="l00095"></a>00095 };
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="preprocessor">#define OTI_PVEC_SIZE 256</span>
<a name="l00098"></a><a class="code" href="structosc__thread__info.html">00098</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structosc__thread__info.html">osc_thread_info</a> {
<a name="l00099"></a>00099         <span class="keyword">struct </span><a class="code" href="structldlm__res__id.html">ldlm_res_id</a>      oti_resname;
<a name="l00100"></a>00100         <span class="keyword">union </span><a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a>  oti_policy;
<a name="l00101"></a>00101         <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a>    oti_descr;
<a name="l00102"></a>00102         <span class="keyword">struct </span><a class="code" href="structcl__attr.html" title="&amp;quot;Data attributes&amp;quot; of cl_object.">cl_attr</a>          oti_attr;
<a name="l00103"></a>00103         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    oti_handle;
<a name="l00104"></a>00104         <span class="keyword">struct </span><a class="code" href="structcl__page__list.html">cl_page_list</a>     oti_plist;
<a name="l00105"></a>00105         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>            oti_io;
<a name="l00106"></a>00106         <span class="keywordtype">void</span>                    *oti_pvec[OTI_PVEC_SIZE];
<a name="l00110"></a><a class="code" href="structosc__thread__info.html#a781049d45b4a79b0a87c0f13dcf840e2">00110</a>         pgoff_t                 <a class="code" href="structosc__thread__info.html#a781049d45b4a79b0a87c0f13dcf840e2" title="Fields used by cl_lock_discard_pages().">oti_next_index</a>;
<a name="l00111"></a>00111         pgoff_t                 oti_fn_index; <span class="comment">/* first non-overlapped index */</span>
<a name="l00112"></a>00112         <span class="keyword">struct </span><a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a>       oti_anchor;
<a name="l00113"></a>00113         <span class="keyword">struct </span><a class="code" href="structcl__req__attr.html" title="Per-transfer attributes.">cl_req_attr</a>      oti_req_attr;
<a name="l00114"></a>00114         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           oti_ladvise_buf;
<a name="l00115"></a>00115 };
<a name="l00116"></a>00116 
<a name="l00117"></a><a class="code" href="structosc__object.html">00117</a> <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a> {
<a name="l00118"></a>00118         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>   oo_cl;
<a name="l00119"></a>00119         <span class="keyword">struct </span><a class="code" href="structlov__oinfo.html">lov_oinfo</a>  *oo_oinfo;
<a name="l00123"></a><a class="code" href="structosc__object.html#a1d4ac88f5d261ddd99f90eb985b55b24">00123</a>         <span class="keywordtype">int</span>                <a class="code" href="structosc__object.html#a1d4ac88f5d261ddd99f90eb985b55b24" title="True if locking against this stripe got -EUSERS.">oo_contended</a>;
<a name="l00124"></a>00124         cfs_time_t         oo_contention_time;
<a name="l00125"></a>00125 <span class="preprocessor">#ifdef CONFIG_LUSTRE_DEBUG_EXPENSIVE_CHECK</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span>
<a name="l00129"></a>00129         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>       oo_debug_io;
<a name="l00131"></a>00131         <span class="keyword">struct </span>mutex       oo_debug_mutex;
<a name="l00132"></a>00132 <span class="preprocessor">#endif</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span>
<a name="l00137"></a><a class="code" href="structosc__object.html#a19d2ca658694060f0f358885959fa46d">00137</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structosc__object.html#a19d2ca658694060f0f358885959fa46d" title="used by the osc to keep track of what objects to build into rpcs.">oo_ready_item</a>;
<a name="l00138"></a>00138         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        oo_hp_ready_item;
<a name="l00139"></a>00139         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        oo_write_item;
<a name="l00140"></a>00140         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        oo_read_item;
<a name="l00141"></a>00141 
<a name="l00145"></a><a class="code" href="structosc__object.html#ad9dc14d89b4a8e551c99538da037e9c1">00145</a>         <span class="keyword">struct </span>rb_root       <a class="code" href="structosc__object.html#ad9dc14d89b4a8e551c99538da037e9c1" title="extent is a red black tree to manage (async) dirty pages.">oo_root</a>;
<a name="l00149"></a><a class="code" href="structosc__object.html#a4f61788f7362518e03287458c7bb1006">00149</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structosc__object.html#a4f61788f7362518e03287458c7bb1006" title="Manage write(dirty) extents.">oo_hp_exts</a>;     <span class="comment">/* list of hp extents */</span>
<a name="l00150"></a>00150         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        oo_urgent_exts; <span class="comment">/* list of writeback extents */</span>
<a name="l00151"></a>00151         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        oo_rpc_exts;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        oo_reading_exts;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155         atomic_t         oo_nr_reads;
<a name="l00156"></a>00156         atomic_t         oo_nr_writes;
<a name="l00157"></a>00157 
<a name="l00160"></a><a class="code" href="structosc__object.html#af24115a584d6561a4fb6fe8e81db2d19">00160</a>         spinlock_t          <a class="code" href="structosc__object.html#af24115a584d6561a4fb6fe8e81db2d19" title="Protect extent tree.">oo_lock</a>;
<a name="l00161"></a>00161 
<a name="l00165"></a><a class="code" href="structosc__object.html#ae1141a32bbd6271afa1c12de174c5c5e">00165</a>         spinlock_t              <a class="code" href="structosc__object.html#ae1141a32bbd6271afa1c12de174c5c5e" title="Radix tree for caching pages.">oo_tree_lock</a>;
<a name="l00166"></a>00166         <span class="keyword">struct </span>radix_tree_root  oo_tree;
<a name="l00167"></a>00167         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>           oo_npages;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         <span class="comment">/* Protect osc_lock this osc_object has */</span>
<a name="l00170"></a>00170         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        oo_ol_list;
<a name="l00171"></a>00171         spinlock_t              oo_ol_spin;
<a name="l00172"></a>00172 
<a name="l00174"></a><a class="code" href="structosc__object.html#a28cd85ef79a7655f2c51493cedce38b4">00174</a>         atomic_t                <a class="code" href="structosc__object.html#a28cd85ef79a7655f2c51493cedce38b4" title="number of active IOs of this object">oo_nr_ios</a>;
<a name="l00175"></a>00175         wait_queue_head_t       oo_io_waitq;
<a name="l00176"></a>00176 };
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> osc_object_lock(<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180         spin_lock(&amp;obj-&gt;<a class="code" href="structosc__object.html#af24115a584d6561a4fb6fe8e81db2d19" title="Protect extent tree.">oo_lock</a>);
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> osc_object_trylock(<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj)
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185         <span class="keywordflow">return</span> spin_trylock(&amp;obj-&gt;<a class="code" href="structosc__object.html#af24115a584d6561a4fb6fe8e81db2d19" title="Protect extent tree.">oo_lock</a>);
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> osc_object_unlock(<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj)
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190         spin_unlock(&amp;obj-&gt;<a class="code" href="structosc__object.html#af24115a584d6561a4fb6fe8e81db2d19" title="Protect extent tree.">oo_lock</a>);
<a name="l00191"></a>00191 }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> osc_object_is_locked(<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj)
<a name="l00194"></a>00194 {
<a name="l00195"></a>00195 <span class="preprocessor">#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span>        <span class="keywordflow">return</span> spin_is_locked(&amp;obj-&gt;<a class="code" href="structosc__object.html#af24115a584d6561a4fb6fe8e81db2d19" title="Protect extent tree.">oo_lock</a>);
<a name="l00197"></a>00197 <span class="preprocessor">#else</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span>        <span class="comment">/*</span>
<a name="l00199"></a>00199 <span class="comment">         * It is not perfect to return true all the time.</span>
<a name="l00200"></a>00200 <span class="comment">         * But since this function is only used for assertion</span>
<a name="l00201"></a>00201 <span class="comment">         * and checking, it seems OK.</span>
<a name="l00202"></a>00202 <span class="comment">         */</span>
<a name="l00203"></a>00203         <span class="keywordflow">return</span> 1;
<a name="l00204"></a>00204 <span class="preprocessor">#endif</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>}
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="comment">/*</span>
<a name="l00208"></a>00208 <span class="comment"> * Lock &quot;micro-states&quot; for osc layer.</span>
<a name="l00209"></a>00209 <span class="comment"> */</span>
<a name="l00210"></a>00210 <span class="keyword">enum</span> osc_lock_state {
<a name="l00211"></a>00211         OLS_NEW,
<a name="l00212"></a>00212         OLS_ENQUEUED,
<a name="l00213"></a>00213         OLS_UPCALL_RECEIVED,
<a name="l00214"></a>00214         OLS_GRANTED,
<a name="l00215"></a>00215         OLS_CANCELLED
<a name="l00216"></a>00216 };
<a name="l00217"></a>00217 
<a name="l00260"></a><a class="code" href="structosc__lock.html">00260</a> <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> {
<a name="l00261"></a>00261         <span class="keyword">struct </span><a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a>    ols_cl;
<a name="l00263"></a><a class="code" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641">00263</a>         spinlock_t              <a class="code" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">ols_lock</a>;
<a name="l00265"></a><a class="code" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7">00265</a>         <span class="keyword">struct </span><a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a>       *<a class="code" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7" title="Owner sleeps on this channel for state change.">ols_owner</a>;
<a name="l00267"></a><a class="code" href="structosc__lock.html#a59dd81488c9fbd6733740cfaeed61b56">00267</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structosc__lock.html#a59dd81488c9fbd6733740cfaeed61b56" title="waiting list for this lock to be cancelled">ols_waiting_list</a>;
<a name="l00269"></a><a class="code" href="structosc__lock.html#aaf07ba3202fb5cd4074a6b98bc41f9e3">00269</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structosc__lock.html#aaf07ba3202fb5cd4074a6b98bc41f9e3" title="wait entry of ols_waiting_list">ols_wait_entry</a>;
<a name="l00271"></a><a class="code" href="structosc__lock.html#a61ed1b1236e5970e472888bb62c81193">00271</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structosc__lock.html#a61ed1b1236e5970e472888bb62c81193" title="list entry for osc_object::oo_ol_list">ols_nextlock_oscobj</a>;
<a name="l00272"></a>00272 
<a name="l00274"></a><a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f">00274</a>         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a>        *<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a>;
<a name="l00276"></a><a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275">00276</a>         __u64                   <a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a>;
<a name="l00278"></a><a class="code" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732">00278</a>         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>     <a class="code" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">ols_handle</a>;
<a name="l00279"></a>00279         <span class="keyword">struct </span><a class="code" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters.">ldlm_enqueue_info</a> ols_einfo;
<a name="l00280"></a>00280         <span class="keyword">enum</span> osc_lock_state      ols_state;
<a name="l00282"></a><a class="code" href="structosc__lock.html#a942265d5ad56c6b1260aa06ae9df6960">00282</a>         <span class="keyword">struct </span><a class="code" href="structost__lvb.html">ost_lvb</a>          <a class="code" href="structosc__lock.html#a942265d5ad56c6b1260aa06ae9df6960" title="lock value block">ols_lvb</a>;
<a name="l00283"></a>00283 
<a name="l00290"></a><a class="code" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed">00290</a>         <span class="keywordtype">unsigned</span>                  <a class="code" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">ols_hold</a> :1,
<a name="l00306"></a>00306                                  <a class="code" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152" title="this is much like osc_lock::ols_hold, except that this bit is cleared _after_ reference...">ols_has_ref</a>:1,
<a name="l00311"></a>00311                                  <a class="code" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed" title="inherit the lockless attribute from top level cl_io.">ols_locklessable</a>:1,
<a name="l00320"></a>00320                                  <a class="code" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416" title="if set, the osc_lock is a glimpse lock.">ols_glimpse</a>:1,
<a name="l00324"></a>00324                                  <a class="code" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001" title="For async glimpse lock.">ols_agl</a>:1;
<a name="l00325"></a>00325 };
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 
<a name="l00331"></a><a class="code" href="structosc__page.html">00331</a> <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> {
<a name="l00332"></a>00332         <span class="keyword">struct </span><a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a>  ops_cl;
<a name="l00336"></a><a class="code" href="structosc__page.html#ac424e48e0933ccb574c998608984079b">00336</a>         <span class="keyword">struct </span><a class="code" href="structosc__async__page.html">osc_async_page</a> <a class="code" href="structosc__page.html#ac424e48e0933ccb574c998608984079b" title="Page queues used by osc to detect when RPC can be formed.">ops_oap</a>;
<a name="l00341"></a><a class="code" href="structosc__page.html#a355a0bda5e453c9d76e44b4e734427b6">00341</a>         <span class="keywordtype">int</span>                   <a class="code" href="structosc__page.html#a355a0bda5e453c9d76e44b4e734427b6" title="An offset within page from which next transfer starts.">ops_from</a>;
<a name="l00347"></a><a class="code" href="structosc__page.html#a77cefd1ebc7f1f0e4230b98979b71159">00347</a>         <span class="keywordtype">int</span>                   <a class="code" href="structosc__page.html#a77cefd1ebc7f1f0e4230b98979b71159" title="An offset within page at which next transfer ends.">ops_to</a>;
<a name="l00351"></a><a class="code" href="structosc__page.html#adee94877990cdc09712adb1b33a437fc">00351</a>         <span class="keywordtype">unsigned</span>              <a class="code" href="structosc__page.html#adee94877990cdc09712adb1b33a437fc" title="Boolean, true iff page is under transfer.">ops_transfer_pinned</a>:1,
<a name="l00356"></a>00356                               <a class="code" href="structosc__page.html#a3169ca9d568a6d318b2e9e15ecfd27fa" title="True for a `temporary page&amp;#39; created by read-ahead code, probably outside of any...">ops_temp</a>:1,
<a name="l00360"></a>00360                               <a class="code" href="structosc__page.html#a80412cd310c52d494977e6c89c4e6f51" title="in LRU?">ops_in_lru</a>:1,
<a name="l00364"></a>00364                               <a class="code" href="structosc__page.html#a4ced8cb240b8ddf47fe922ecaae83de9" title="Set if the page must be transferred with OBD_BRW_SRVLOCK.">ops_srvlock</a>:1;
<a name="l00368"></a><a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5">00368</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structosc__page.html#a6efc6530f83294db491d1cda5669b9f5" title="lru page list.">ops_lru</a>;
<a name="l00372"></a><a class="code" href="structosc__page.html#ae2717ab94b4940fbd543f76a06d3e289">00372</a>         cfs_time_t            <a class="code" href="structosc__page.html#ae2717ab94b4940fbd543f76a06d3e289" title="Submit time - the time when the page is starting RPC.">ops_submit_time</a>;
<a name="l00373"></a>00373 };
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *osc_lock_kmem;
<a name="l00376"></a>00376 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *osc_object_kmem;
<a name="l00377"></a>00377 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *osc_thread_kmem;
<a name="l00378"></a>00378 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *osc_session_kmem;
<a name="l00379"></a>00379 <span class="keyword">extern</span> <span class="keyword">struct </span>kmem_cache *osc_extent_kmem;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> osc_device_type;
<a name="l00382"></a>00382 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> osc_key;
<a name="l00383"></a>00383 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> osc_session_key;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 <span class="preprocessor">#define OSC_FLAGS (ASYNC_URGENT|ASYNC_READY)</span>
<a name="l00386"></a>00386 <span class="preprocessor"></span>
<a name="l00387"></a>00387 <span class="keywordtype">int</span> osc_lock_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00388"></a>00388                   <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock,
<a name="l00389"></a>00389                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00390"></a>00390 <span class="keywordtype">int</span> osc_io_init  (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00391"></a>00391                   <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00392"></a>00392 <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *osc_object_alloc(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00393"></a>00393                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object__header.html" title="&amp;quot;Compound&amp;quot; object, consisting of multiple layers.">lu_object_header</a> *hdr,
<a name="l00394"></a>00394                                    <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *dev);
<a name="l00395"></a>00395 <span class="keywordtype">int</span> osc_page_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00396"></a>00396                   <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page, pgoff_t ind);
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 <span class="keywordtype">void</span> osc_index2policy(<span class="keyword">union</span> <a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy,
<a name="l00399"></a>00399                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj, pgoff_t start, pgoff_t end);
<a name="l00400"></a>00400 <span class="keywordtype">int</span>  osc_lvb_print(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">void</span> *cookie,
<a name="l00401"></a>00401                    <a class="code" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc" title="Type of &amp;quot;printer&amp;quot; function used by lu_object_operations::loo_object_print()...">lu_printer_t</a> p, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__lvb.html">ost_lvb</a> *lvb);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 <span class="keywordtype">void</span> osc_lru_add_batch(<span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *list);
<a name="l00404"></a>00404 <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gae4802860d91daed5d098a08f4ed45dea" title="Helper function called by osc_io_submit() for every page in an immediate transfer...">osc_page_submit</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg,
<a name="l00405"></a>00405                      <span class="keyword">enum</span> <a class="code" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02" title="Requested transfer type.">cl_req_type</a> crt, <span class="keywordtype">int</span> brw_flags);
<a name="l00406"></a>00406 <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gad22b15d739092f8a8d27214eff304e66" title="this is called when a sync waiter receives an interruption.">osc_cancel_async_page</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *ops);
<a name="l00407"></a>00407 <span class="keywordtype">int</span> osc_set_async_flags(<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg,
<a name="l00408"></a>00408                         u32 async_flags);
<a name="l00409"></a>00409 <span class="keywordtype">int</span> osc_prep_async_page(<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *osc, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *ops,
<a name="l00410"></a>00410                         <span class="keyword">struct</span> page *page, loff_t offset);
<a name="l00411"></a>00411 <span class="keywordtype">int</span> osc_queue_async_io(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00412"></a>00412                        <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *ops);
<a name="l00413"></a>00413 <span class="keywordtype">int</span> osc_page_cache_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00414"></a>00414                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io);
<a name="l00415"></a>00415 <span class="keywordtype">int</span> osc_teardown_async_page(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj,
<a name="l00416"></a>00416                             <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *ops);
<a name="l00417"></a>00417 <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gacbca1d2858196fd14f5de2a27cb7c857" title="This is called when a page is picked up by kernel to write out.">osc_flush_async_page</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00418"></a>00418                          <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *ops);
<a name="l00419"></a>00419 <span class="keywordtype">int</span> osc_queue_sync_pages(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj,
<a name="l00420"></a>00420                          <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *list, <span class="keywordtype">int</span> cmd, <span class="keywordtype">int</span> brw_flags);
<a name="l00421"></a>00421 <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga50a5681d5c52a69e84bb265c202f3ecf" title="Called by osc_io_setattr_start() to freeze and destroy covering extents.">osc_cache_truncate_start</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj,
<a name="l00422"></a>00422                              __u64 size, <span class="keyword">struct</span> <a class="code" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a> **extp);
<a name="l00423"></a>00423 <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga5d8bb46841ff73ab14ca09abac5d767c" title="Called after osc_io_setattr_end to add oio-&amp;gt;oi_trunc back to cache.">osc_cache_truncate_end</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a> *ext);
<a name="l00424"></a>00424 <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga91e31015ca9c3df0750e008ebd5831cf" title="Called to write out a range of osc object.">osc_cache_writeback_range</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj,
<a name="l00425"></a>00425                               pgoff_t start, pgoff_t end, <span class="keywordtype">int</span> hp, <span class="keywordtype">int</span> discard);
<a name="l00426"></a>00426 <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga4c709e4df4c17373354b20238e863f2a" title="Wait for extents in a specific range to be written out.">osc_cache_wait_range</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj,
<a name="l00427"></a>00427                          pgoff_t start, pgoff_t end);
<a name="l00428"></a>00428 <span class="keywordtype">void</span> osc_io_unplug(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structclient__obd.html">client_obd</a> *cli,
<a name="l00429"></a>00429                    <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *osc);
<a name="l00430"></a>00430 <span class="keywordtype">int</span> lru_queue_work(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">void</span> *data);
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 <span class="keywordtype">void</span> osc_object_set_contended  (<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj);
<a name="l00433"></a>00433 <span class="keywordtype">void</span> osc_object_clear_contended(<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj);
<a name="l00434"></a>00434 <span class="keywordtype">int</span>  osc_object_is_contended   (<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj);
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 <span class="keywordtype">int</span>  osc_lock_is_lockless      (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *olck);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 <span class="comment">/*****************************************************************************</span>
<a name="l00439"></a>00439 <span class="comment"> *</span>
<a name="l00440"></a>00440 <span class="comment"> * Accessors.</span>
<a name="l00441"></a>00441 <span class="comment"> *</span>
<a name="l00442"></a>00442 <span class="comment"> */</span>
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__thread__info.html">osc_thread_info</a> *osc_env_info(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l00445"></a>00445 {
<a name="l00446"></a>00446         <span class="keyword">struct </span><a class="code" href="structosc__thread__info.html">osc_thread_info</a> *info;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         info = <a class="code" href="group__lu.html#ga8fcebe57d8fb288a73a39144693074af" title="Return value associated with key key in context ctx.">lu_context_key_get</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>, &amp;osc_key);
<a name="l00449"></a>00449         LASSERT(info != NULL);
<a name="l00450"></a>00450         <span class="keywordflow">return</span> info;
<a name="l00451"></a>00451 }
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__session.html" title="State maintained by osc layer for the duration of a system call.">osc_session</a> *osc_env_session(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l00454"></a>00454 {
<a name="l00455"></a>00455         <span class="keyword">struct </span><a class="code" href="structosc__session.html" title="State maintained by osc layer for the duration of a system call.">osc_session</a> *ses;
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         ses = <a class="code" href="group__lu.html#ga8fcebe57d8fb288a73a39144693074af" title="Return value associated with key key in context ctx.">lu_context_key_get</a>(env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>, &amp;osc_session_key);
<a name="l00458"></a>00458         LASSERT(ses != NULL);
<a name="l00459"></a>00459         <span class="keywordflow">return</span> ses;
<a name="l00460"></a>00460 }
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__io.html" title="State maintained by osc layer for each IO context.">osc_io</a> *osc_env_io(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l00463"></a>00463 {
<a name="l00464"></a>00464         <span class="keywordflow">return</span> &amp;osc_env_session(env)-&gt;os_io;
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> osc_is_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj)
<a name="l00468"></a>00468 {
<a name="l00469"></a>00469         <span class="keywordflow">return</span> obj-&gt;<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a> == &amp;osc_device_type;
<a name="l00470"></a>00470 }
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__device.html">osc_device</a> *lu2osc_dev(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *d)
<a name="l00473"></a>00473 {
<a name="l00474"></a>00474         LINVRNT(d-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a> == &amp;osc_device_type);
<a name="l00475"></a>00475         <span class="keywordflow">return</span> container_of0(d, <span class="keyword">struct</span> <a class="code" href="structosc__device.html">osc_device</a>, od_cl.cd_lu_dev);
<a name="l00476"></a>00476 }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *osc_export(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj)
<a name="l00479"></a>00479 {
<a name="l00480"></a>00480         <span class="keywordflow">return</span> lu2osc_dev(obj-&gt;oo_cl.<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>)-&gt;od_exp;
<a name="l00481"></a>00481 }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *osc_cli(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj)
<a name="l00484"></a>00484 {
<a name="l00485"></a>00485         <span class="keywordflow">return</span> &amp;osc_export(obj)-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;u.cli;
<a name="l00486"></a>00486 }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a> *cl2osc(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj)
<a name="l00489"></a>00489 {
<a name="l00490"></a>00490         LINVRNT(osc_is_object(&amp;obj-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00491"></a>00491         <span class="keywordflow">return</span> container_of0(obj, <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a>, oo_cl);
<a name="l00492"></a>00492 }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *osc2cl(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj)
<a name="l00495"></a>00495 {
<a name="l00496"></a>00496         <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *)&amp;obj-&gt;oo_cl;
<a name="l00497"></a>00497 }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">enum</span> ldlm_mode osc_cl_lock2ldlm(<span class="keyword">enum</span> <a class="code" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1" title="Lock mode.">cl_lock_mode</a> mode)
<a name="l00500"></a>00500 {
<a name="l00501"></a>00501         LASSERT(mode == CLM_READ || mode == CLM_WRITE || mode == CLM_GROUP);
<a name="l00502"></a>00502         <span class="keywordflow">if</span> (mode == CLM_READ)
<a name="l00503"></a>00503                 <span class="keywordflow">return</span> LCK_PR;
<a name="l00504"></a>00504         <span class="keywordflow">if</span> (mode == CLM_WRITE)
<a name="l00505"></a>00505                 <span class="keywordflow">return</span> LCK_PW;
<a name="l00506"></a>00506         <span class="keywordflow">return</span> LCK_GROUP;
<a name="l00507"></a>00507 }
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">enum</span> <a class="code" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1" title="Lock mode.">cl_lock_mode</a> osc_ldlm2cl_lock(<span class="keyword">enum</span> ldlm_mode mode)
<a name="l00510"></a>00510 {
<a name="l00511"></a>00511         LASSERT(mode == LCK_PR || mode == LCK_PW || mode == LCK_GROUP);
<a name="l00512"></a>00512         <span class="keywordflow">if</span> (mode == LCK_PR)
<a name="l00513"></a>00513                 <span class="keywordflow">return</span> CLM_READ;
<a name="l00514"></a>00514         <span class="keywordflow">if</span> (mode == LCK_PW)
<a name="l00515"></a>00515                 <span class="keywordflow">return</span> CLM_WRITE;
<a name="l00516"></a>00516         <span class="keywordflow">return</span> CLM_GROUP;
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *cl2osc_page(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice)
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521         LINVRNT(osc_is_object(&amp;slice-&gt;<a class="code" href="structcl__page__slice.html#a71c54d2bf9c69b3a66df261412d0ba78" title="Object slice corresponding to this page slice.">cpl_obj</a>-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00522"></a>00522         <span class="keywordflow">return</span> container_of0(slice, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a>, ops_cl);
<a name="l00523"></a>00523 }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *oap2osc(<span class="keyword">struct</span> <a class="code" href="structosc__async__page.html">osc_async_page</a> *oap)
<a name="l00526"></a>00526 {
<a name="l00527"></a>00527         <span class="keywordflow">return</span> container_of0(oap, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a>, <a class="code" href="structosc__page.html#ac424e48e0933ccb574c998608984079b" title="Page queues used by osc to detect when RPC can be formed.">ops_oap</a>);
<a name="l00528"></a>00528 }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="keyword">static</span> <span class="keyword">inline</span> pgoff_t osc_index(<span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *opg)
<a name="l00531"></a>00531 {
<a name="l00532"></a>00532         <span class="keywordflow">return</span> opg-&gt;ops_cl.cpl_index;
<a name="l00533"></a>00533 }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *oap2cl_page(<span class="keyword">struct</span> <a class="code" href="structosc__async__page.html">osc_async_page</a> *oap)
<a name="l00536"></a>00536 {
<a name="l00537"></a>00537         <span class="keywordflow">return</span> oap2osc(oap)-&gt;ops_cl.cpl_page;
<a name="l00538"></a>00538 }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *oap2osc_page(<span class="keyword">struct</span> <a class="code" href="structosc__async__page.html">osc_async_page</a> *oap)
<a name="l00541"></a>00541 {
<a name="l00542"></a>00542         <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *)container_of(oap, <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a>, <a class="code" href="structosc__page.html#ac424e48e0933ccb574c998608984079b" title="Page queues used by osc to detect when RPC can be formed.">ops_oap</a>);
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *
<a name="l00546"></a>00546 osc_cl_page_osc(<span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page, <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *osc)
<a name="l00547"></a>00547 {
<a name="l00548"></a>00548         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice;
<a name="l00549"></a>00549 
<a name="l00550"></a>00550         LASSERT(osc != NULL);
<a name="l00551"></a>00551         slice = cl_object_page_slice(&amp;osc-&gt;oo_cl, page);
<a name="l00552"></a>00552         <span class="keywordflow">return</span> cl2osc_page(slice);
<a name="l00553"></a>00553 }
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *cl2osc_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice)
<a name="l00556"></a>00556 {
<a name="l00557"></a>00557         LINVRNT(osc_is_object(&amp;slice-&gt;<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>));
<a name="l00558"></a>00558         <span class="keywordflow">return</span> container_of0(slice, <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>, ols_cl);
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *osc_lock_at(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock)
<a name="l00562"></a>00562 {
<a name="l00563"></a>00563         <span class="keywordflow">return</span> cl2osc_lock(<a class="code" href="group__cl__lock.html#ga9b59ad7624c11fcecf6eadb1a58f6f8b" title="Returns a slice with a lock, corresponding to the given layer in the device stack...">cl_lock_at</a>(lock, &amp;osc_device_type));
<a name="l00564"></a>00564 }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> osc_io_srvlock(<span class="keyword">struct</span> <a class="code" href="structosc__io.html" title="State maintained by osc layer for each IO context.">osc_io</a> *oio)
<a name="l00567"></a>00567 {
<a name="l00568"></a>00568         <span class="keywordflow">return</span> (oio-&gt;<a class="code" href="structosc__io.html#a8dc8c1963fac8b54b8e5953f22352b3e" title="true if this io is lockless.">oi_lockless</a> &amp;&amp; !oio-&gt;<a class="code" href="structosc__io.html#a7ee5ca22311af0cd83adac47b95af6ca" title="super class">oi_cl</a>.cis_io-&gt;<a class="code" href="structcl__io.html#a435468f51ab9aab5145e46b36c669376" title="This io has held grouplock, to inform sublayers that don&amp;#39;t do lockless i/o.">ci_no_srvlock</a>);
<a name="l00569"></a>00569 }
<a name="l00570"></a>00570 
<a name="l00571"></a><a class="code" href="group__osc.html#ga6186b8ce09edf79ddb470068d980fa3d">00571</a> <span class="keyword">enum</span> <a class="code" href="group__osc.html#ga6186b8ce09edf79ddb470068d980fa3d">osc_extent_state</a> {
<a name="l00572"></a>00572         OES_INV       = 0, 
<a name="l00573"></a><a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da57a171603bdbe9ce372e2c23f1b4fcb5">00573</a>         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da57a171603bdbe9ce372e2c23f1b4fcb5" title="extent is just initialized or destroyed">OES_ACTIVE</a>    = 1, 
<a name="l00574"></a><a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da5fa3ea0f8426b29ae208cb22e435cf77">00574</a>         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da5fa3ea0f8426b29ae208cb22e435cf77" title="process is using this extent">OES_CACHE</a>     = 2, 
<a name="l00575"></a><a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da7558231f4c40076af91adcb4f605e3a3">00575</a>         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da7558231f4c40076af91adcb4f605e3a3" title="extent is ready for IO">OES_LOCKING</a>   = 3, 
<a name="l00576"></a><a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da0cfb17d1d0abe58ee5a6e210ecd3b685">00576</a>         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da0cfb17d1d0abe58ee5a6e210ecd3b685" title="locking page to prepare IO">OES_LOCK_DONE</a> = 4, 
<a name="l00577"></a><a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da7ed8d9d8557c8185d7cd464ca6916303">00577</a>         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3da7ed8d9d8557c8185d7cd464ca6916303" title="locking finished, ready to send">OES_RPC</a>       = 5, 
<a name="l00578"></a><a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3daeac60d8c4aeeae580c118b4f08ea961c">00578</a>         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3daeac60d8c4aeeae580c118b4f08ea961c" title="in RPC">OES_TRUNC</a>     = 6, 
<a name="l00579"></a><a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3dac862e82e76aa4803851aca25ad9fc532">00579</a>         <a class="code" href="group__osc.html#gga6186b8ce09edf79ddb470068d980fa3dac862e82e76aa4803851aca25ad9fc532" title="being truncated">OES_STATE_MAX</a>
<a name="l00580"></a>00580 };
<a name="l00581"></a>00581 
<a name="l00597"></a><a class="code" href="structosc__extent.html">00597</a> <span class="keyword">struct </span><a class="code" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a> {
<a name="l00599"></a><a class="code" href="structosc__extent.html#aa4a16d199366364669427d172d5eb79d">00599</a>         <span class="keyword">struct </span>rb_node          <a class="code" href="structosc__extent.html#aa4a16d199366364669427d172d5eb79d" title="red-black tree node">oe_node</a>;
<a name="l00601"></a><a class="code" href="structosc__extent.html#ad9dab12e21e4e8231a81ecb8f170633a">00601</a>         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a>       *<a class="code" href="structosc__extent.html#ad9dab12e21e4e8231a81ecb8f170633a" title="osc_object of this extent">oe_obj</a>;
<a name="l00603"></a><a class="code" href="structosc__extent.html#a7f522192b2e730b2700372aa917ed70d">00603</a>         atomic_t                <a class="code" href="structosc__extent.html#a7f522192b2e730b2700372aa917ed70d" title="refcount, removed from red-black tree if reaches zero.">oe_refc</a>;
<a name="l00605"></a><a class="code" href="structosc__extent.html#ac28ac9cd6c7240ad0afaff28ff007f89">00605</a>         atomic_t                <a class="code" href="structosc__extent.html#ac28ac9cd6c7240ad0afaff28ff007f89" title="busy if non-zero">oe_users</a>;
<a name="l00607"></a><a class="code" href="structosc__extent.html#aeaa3b4c221431f0522dee297a6bf8b7f">00607</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structosc__extent.html#aeaa3b4c221431f0522dee297a6bf8b7f" title="link list of osc_object&amp;#39;s oo_{hp|urgent|locking}_exts.">oe_link</a>;
<a name="l00609"></a><a class="code" href="structosc__extent.html#ab5924332afc7ba73b69e414e239afcb8">00609</a>         <span class="keyword">enum</span> <a class="code" href="group__osc.html#ga6186b8ce09edf79ddb470068d980fa3d">osc_extent_state</a>   <a class="code" href="structosc__extent.html#ab5924332afc7ba73b69e414e239afcb8" title="state of this extent">oe_state</a>;
<a name="l00611"></a><a class="code" href="structosc__extent.html#a3436c7ac13989c41f87094dab9677c7c">00611</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structosc__extent.html#aca42d776510ff8c88d4a504e668414e9" title="flags for this extent.">oe_intree</a>:1,
<a name="l00613"></a>00613                                 <a class="code" href="structosc__extent.html#a23daef960fd5ea5e7cc8366148c51817" title="0 is write, 1 is read">oe_rw</a>:1,
<a name="l00615"></a>00615                                 <a class="code" href="structosc__extent.html#a09d5477ecb9c0692709e41cbbf990b24" title="sync extent, queued by osc_queue_sync_pages()">oe_sync</a>:1,
<a name="l00618"></a>00618                                 <a class="code" href="structosc__extent.html#a604ed01b94aba0db116878e5666a2f2b" title="set if this extent has partial, sync pages.">oe_no_merge</a>:1,
<a name="l00619"></a>00619                                 oe_srvlock:1,
<a name="l00620"></a>00620                                 oe_memalloc:1,
<a name="l00623"></a>00623                                 <a class="code" href="structosc__extent.html#affe4104ed478c6b9c2c567e5871decb7" title="an ACTIVE extent is going to be truncated, so when this extent is released, it will...">oe_trunc_pending</a>:1,
<a name="l00629"></a>00629                                 <a class="code" href="structosc__extent.html#a0dfd859c9dad8d1d5417a42505739fda" title="this extent should be written asap and someone may wait for the write to finish.">oe_fsync_wait</a>:1,
<a name="l00631"></a>00631                                 <a class="code" href="structosc__extent.html#a546e893451e0db8f24f98daaf7ad653d" title="covering lock is being canceled">oe_hp</a>:1,
<a name="l00634"></a>00634                                 <a class="code" href="structosc__extent.html#a3436c7ac13989c41f87094dab9677c7c" title="this extent should be written back asap.">oe_urgent</a>:1;
<a name="l00638"></a><a class="code" href="structosc__extent.html#a056f40e5f22d4f17f33f318930fcc56a">00638</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structosc__extent.html#a056f40e5f22d4f17f33f318930fcc56a" title="how many grants allocated for this extent.">oe_grants</a>;
<a name="l00640"></a><a class="code" href="structosc__extent.html#a68938c4d75d133def3289025bf89553f">00640</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structosc__extent.html#a68938c4d75d133def3289025bf89553f" title="# of dirty pages in this extent">oe_nr_pages</a>;
<a name="l00642"></a><a class="code" href="structosc__extent.html#a560c7ce178a0a9cdac244d3d6cccf5ab">00642</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structosc__extent.html#a560c7ce178a0a9cdac244d3d6cccf5ab" title="list of pending oap pages.">oe_pages</a>;
<a name="l00647"></a><a class="code" href="structosc__extent.html#a9dadddf6f0d544f52ea31255c99e1364">00647</a>         <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a>         *<a class="code" href="structosc__extent.html#a9dadddf6f0d544f52ea31255c99e1364" title="Since an extent has to be written out in atomic, this is used to remember the next...">oe_next_page</a>;
<a name="l00651"></a><a class="code" href="structosc__extent.html#ad0b1ed86cc62802d3ad3ca17ef5b2782">00651</a>         pgoff_t                 <a class="code" href="structosc__extent.html#ad0b1ed86cc62802d3ad3ca17ef5b2782" title="start and end index of this extent, include start and end themselves.">oe_start</a>;
<a name="l00652"></a>00652         pgoff_t                 oe_end;
<a name="l00655"></a><a class="code" href="structosc__extent.html#aec4a959324e6e350005452d2a7c2aa7c">00655</a>         pgoff_t                 <a class="code" href="structosc__extent.html#aec4a959324e6e350005452d2a7c2aa7c" title="maximum ending index of this extent, this is limited by max_pages_per_rpc, lock extent...">oe_max_end</a>;
<a name="l00658"></a><a class="code" href="structosc__extent.html#abd3aea75cbadc65687de172606fb2bac">00658</a>         wait_queue_head_t       <a class="code" href="structosc__extent.html#abd3aea75cbadc65687de172606fb2bac" title="waitqueue - for those who want to be notified if this extent&amp;#39;s state has changed...">oe_waitq</a>;
<a name="l00660"></a><a class="code" href="structosc__extent.html#a1c38bc43de56c6c6b5b09ef9477d7a8c">00660</a>         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a>        *<a class="code" href="structosc__extent.html#a1c38bc43de56c6c6b5b09ef9477d7a8c" title="lock covering this extent">oe_dlmlock</a>;
<a name="l00662"></a><a class="code" href="structosc__extent.html#a78831d5d0e5db8c6c1a4e166784bca0e">00662</a>         <span class="keyword">struct </span>task_struct      *<a class="code" href="structosc__extent.html#a78831d5d0e5db8c6c1a4e166784bca0e" title="terminator of this extent.">oe_owner</a>;
<a name="l00665"></a><a class="code" href="structosc__extent.html#a78557e0781952ba4d6736d195a3df466">00665</a>         <span class="keywordtype">int</span>                     <a class="code" href="structosc__extent.html#a78557e0781952ba4d6736d195a3df466" title="return value of writeback.">oe_rc</a>;
<a name="l00667"></a><a class="code" href="structosc__extent.html#aaa171d17018dc34315f19e53a7df019e">00667</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structosc__extent.html#aaa171d17018dc34315f19e53a7df019e" title="max pages per rpc when this extent was created">oe_mppr</a>;
<a name="l00668"></a>00668 };
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gaf6b8a4d60ebeba7a3b97618165e566b3" title="Called when IO is finished to an extent.">osc_extent_finish</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a> *ext,
<a name="l00671"></a>00671                       <span class="keywordtype">int</span> sent, <span class="keywordtype">int</span> rc);
<a name="l00672"></a>00672 <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga06e75737c5c000e1e1b65419a81aef2e" title="Drop user count of osc_extent, and unplug IO asynchronously.">osc_extent_release</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__extent.html" title="osc_extent data to manage dirty pages.">osc_extent</a> *ext);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gad86265cc2892261e7634f0d9a2050a6b" title="Discard pages protected by the given lock.">osc_lock_discard_pages</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *osc,
<a name="l00675"></a>00675                            pgoff_t start, pgoff_t end, <span class="keyword">enum</span> <a class="code" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1" title="Lock mode.">cl_lock_mode</a> mode);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="keyword">typedef</span> int (*osc_page_gang_cbt)(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *, <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *,
<a name="l00678"></a>00678                                  <span class="keyword">struct </span><a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *, <span class="keywordtype">void</span> *);
<a name="l00679"></a>00679 <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga4ac00d525c8750fbccb312796dfb0542" title="Returns a list of pages by a given [start, end] of obj.">osc_page_gang_lookup</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00680"></a>00680                          <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *osc, pgoff_t start, pgoff_t end,
<a name="l00681"></a>00681                          osc_page_gang_cbt cb, <span class="keywordtype">void</span> *cbdata);
<a name="l00684"></a>00684 <span class="preprocessor">#endif </span><span class="comment">/* OSC_CL_INTERNAL_H */</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:18 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
