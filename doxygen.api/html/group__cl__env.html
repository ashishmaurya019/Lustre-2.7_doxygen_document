<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: cl_env</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cl_env<br/>
<small>
[<a class="el" href="group__clio.html">clio</a>]</small>
</h1>
<p><a class="el" href="structlu__env.html" title="Environment.">lu_env</a> handling for a client.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for cl_env:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__cl__env.png" border="0" alt="" usemap="#group____cl____env_map"/>
<map name="group____cl____env_map" id="group____cl____env">
<area shape="rect" id="node1" href="group__clio.html" title="Client objects implement io operations and cache pages." alt="" coords="7,5,49,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__env__nest.html">cl_env_nest</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6cae9e9e53d78c25ee1deae1ae3b8f4"></a><!-- doxytag: member="cl_env::cl_env_peek" ref="gad6cae9e9e53d78c25ee1deae1ae3b8f4" args="(__u16 *refcheck)" -->
struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_env_peek</b> (__u16 *refcheck)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1">cl_env_get</a> (__u16 *refcheck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <a class="el" href="structlu__env.html" title="Environment.">lu_env</a>: if there already is an environment associated with the current thread, it is returned, otherwise, new environment is allocated.  <a href="#ga17240d2c6cef5226d4ec8c0b4046afa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga2d91b169de0380c5f5be4c1118c7af8e">cl_env_alloc</a> (__u16 *refcheck, __u32 tags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces an allocation of a fresh environment with given tags.  <a href="#ga2d91b169de0380c5f5be4c1118c7af8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ed10b419dd63d9fa101c7e14e75f965"></a><!-- doxytag: member="cl_env::cl_env_nested_get" ref="ga6ed10b419dd63d9fa101c7e14e75f965" args="(struct cl_env_nest *nest)" -->
struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_env_nested_get</b> (struct <a class="el" href="structcl__env__nest.html">cl_env_nest</a> *nest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2">cl_env_put</a> (struct <a class="el" href="structlu__env.html">lu_env</a> *env, __u16 *refcheck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release an environment.  <a href="#ga9cf31d221b7596143ff46bd799f19cf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad0152e8236bb22b70e9066509070fded"></a><!-- doxytag: member="cl_env::cl_env_nested_put" ref="gad0152e8236bb22b70e9066509070fded" args="(struct cl_env_nest *nest, struct lu_env *env)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_env_nested_put</b> (struct <a class="el" href="structcl__env__nest.html">cl_env_nest</a> *nest, struct <a class="el" href="structlu__env.html">lu_env</a> *env)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga2c3cf05baa558c0e2888b5c82d0039a2">cl_env_reenter</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declares a point of re-entrancy.  <a href="#ga2c3cf05baa558c0e2888b5c82d0039a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a2f0ccf8118ede1c1f191a545937eac"></a><!-- doxytag: member="cl_env::cl_env_reexit" ref="ga6a2f0ccf8118ede1c1f191a545937eac" args="(void *cookie)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga6a2f0ccf8118ede1c1f191a545937eac">cl_env_reexit</a> (void *cookie)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exits re-entrancy. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#gad07c2a6339d36f40375805d9ae5e02cc">cl_env_implant</a> (struct <a class="el" href="structlu__env.html">lu_env</a> *env, __u16 *refcheck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup user-supplied <em>env</em> as a current environment.  <a href="#gad07c2a6339d36f40375805d9ae5e02cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace30ddb0f3834c7dad1c4d5315dd63ba"></a><!-- doxytag: member="cl_env::cl_env_unplant" ref="gace30ddb0f3834c7dad1c4d5315dd63ba" args="(struct lu_env *env, __u16 *refcheck)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#gace30ddb0f3834c7dad1c4d5315dd63ba">cl_env_unplant</a> (struct <a class="el" href="structlu__env.html">lu_env</a> *env, __u16 *refcheck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach environment installed earlier by <a class="el" href="group__cl__env.html#gad07c2a6339d36f40375805d9ae5e02cc" title="Setup user-supplied env as a current environment.">cl_env_implant()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cl__env.html#ga865dfbdba69721fb16c551ec6ce996d1">cl_env_cache_purge</a> (unsigned nr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalizes and frees a given number of cached environments.  <a href="#ga865dfbdba69721fb16c551ec6ce996d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8d7bb468153f7ccc6259ecef4dfa91bf"></a><!-- doxytag: member="cl_env::cl_env_percpu_get" ref="ga8d7bb468153f7ccc6259ecef4dfa91bf" args="(void)" -->
struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_env_percpu_get</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbd19d47d20a5e5787bb6e61acaf1461"></a><!-- doxytag: member="cl_env::cl_env_percpu_put" ref="gabbd19d47d20a5e5787bb6e61acaf1461" args="(struct lu_env *env)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cl_env_percpu_put</b> (struct <a class="el" href="structlu__env.html">lu_env</a> *env)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="structlu__env.html" title="Environment.">lu_env</a> handling for a client. </p>
<p><a class="el" href="structlu__env.html" title="Environment.">lu_env</a> is an environment within which lustre code executes. Its major part is lu_context---a fast memory allocation mechanism that is used to conserve precious kernel stack space. Originally <a class="el" href="structlu__env.html" title="Environment.">lu_env</a> was designed for a server, where</p>
<ul>
<li>there is a (mostly) fixed number of threads, and</li>
</ul>
<ul>
<li>call chains have no non-lustre portions inserted between lustre code.</li>
</ul>
<p>On a client both these assumtpion fails, because every user thread can potentially execute lustre code as part of a system call, and lustre calls into VFS or MM that call back into lustre.</p>
<p>To deal with that, cl_env wrapper functions implement the following optimizations:</p>
<ul>
<li>allocation and destruction of environment is amortized by caching no longer used environments instead of destroying them;</li>
</ul>
<ul>
<li>there is a notion of "current" environment, attached to the kernel data structure representing current thread Top-level lustre code allocates an environment and makes it current, then calls into non-lustre code, that in turn calls lustre back. Low-level lustre code thus called can fetch environment created by the top-level code and reuse it, avoiding additional environment allocation. Right now, three interfaces can attach the cl_env to running thread:<ul>
<li>cl_env_get</li>
<li>cl_env_implant</li>
<li>cl_env_reexit(cl_env_reenter had to be called priorly)</li>
</ul>
</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structlu__env.html" title="Environment.">lu_env</a>, <a class="el" href="structlu__context.html" title="lu_context.">lu_context</a>, <a class="el" href="structlu__context__key.html" title="Key.">lu_context_key</a> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2d91b169de0380c5f5be4c1118c7af8e"></a><!-- doxytag: member="cl_object.h::cl_env_alloc" ref="ga2d91b169de0380c5f5be4c1118c7af8e" args="(__u16 *refcheck, __u32 tags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__env.html">lu_env</a>* cl_env_alloc </td>
          <td>(</td>
          <td class="paramtype">__u16 *&nbsp;</td>
          <td class="paramname"> <em>refcheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>tags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forces an allocation of a fresh environment with given tags. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__object_8c_source.html#l00931">931</a> of file <a class="el" href="cl__object_8c_source.html">cl_object.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00932"></a>00932 {
<a name="l00933"></a>00933         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l00934"></a>00934 
<a name="l00935"></a>00935         LASSERT(cl_env_peek(refcheck) == NULL);
<a name="l00936"></a>00936         env = cl_env_new(tags, tags, __builtin_return_address(0));
<a name="l00937"></a>00937         <span class="keywordflow">if</span> (!IS_ERR(env)) {
<a name="l00938"></a>00938                 <span class="keyword">struct </span>cl_env *cle;
<a name="l00939"></a>00939 
<a name="l00940"></a>00940                 cle = cl_env_container(env);
<a name="l00941"></a>00941                 *refcheck = cle-&gt;ce_ref;
<a name="l00942"></a>00942                 CDEBUG(D_OTHER, <span class="stringliteral">&quot;%d@%p\n&quot;</span>, cle-&gt;ce_ref, cle);
<a name="l00943"></a>00943         }
<a name="l00944"></a>00944         <span class="keywordflow">return</span> env;
<a name="l00945"></a>00945 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga865dfbdba69721fb16c551ec6ce996d1"></a><!-- doxytag: member="cl_object.h::cl_env_cache_purge" ref="ga865dfbdba69721fb16c551ec6ce996d1" args="(unsigned nr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned cl_env_cache_purge </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>nr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalizes and frees a given number of cached environments. </p>
<p>This is done to (1) free some memory (not currently hooked into VM), or (2) release references to modules. </p>

<p>Definition at line <a class="el" href="cl__object_8c_source.html#l00960">960</a> of file <a class="el" href="cl__object_8c_source.html">cl_object.c</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l01594">lu_context_key_quiesce()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00961"></a>00961 {
<a name="l00962"></a>00962         <span class="keyword">struct </span>cl_env *cle;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964         ENTRY;
<a name="l00965"></a>00965         spin_lock(&amp;cl_envs_guard);
<a name="l00966"></a>00966         <span class="keywordflow">for</span> (; !list_empty(&amp;cl_envs) &amp;&amp; nr &gt; 0; --nr) {
<a name="l00967"></a>00967                 cle = container_of(cl_envs.next, <span class="keyword">struct</span> cl_env, ce_linkage);
<a name="l00968"></a>00968                 list_del_init(&amp;cle-&gt;ce_linkage);
<a name="l00969"></a>00969                 LASSERT(cl_envs_cached_nr &gt; 0);
<a name="l00970"></a>00970                 cl_envs_cached_nr--;
<a name="l00971"></a>00971                 spin_unlock(&amp;cl_envs_guard);
<a name="l00972"></a>00972 
<a name="l00973"></a>00973                 cl_env_fini(cle);
<a name="l00974"></a>00974                 spin_lock(&amp;cl_envs_guard);
<a name="l00975"></a>00975         }
<a name="l00976"></a>00976         LASSERT(equi(cl_envs_cached_nr == 0, list_empty(&amp;cl_envs)));
<a name="l00977"></a>00977         spin_unlock(&amp;cl_envs_guard);
<a name="l00978"></a>00978         RETURN(nr);
<a name="l00979"></a>00979 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__env_ga865dfbdba69721fb16c551ec6ce996d1_icgraph.png" border="0" usemap="#group__cl__env_ga865dfbdba69721fb16c551ec6ce996d1_icgraph_map" alt=""></div>
<map name="group__cl__env_ga865dfbdba69721fb16c551ec6ce996d1_icgraph_map" id="group__cl__env_ga865dfbdba69721fb16c551ec6ce996d1_icgraph">
<area shape="rect" id="node3" href="group__lu.html#ga26d0d8d30e9702d38f9d2e372d48002e" title="Destroy key in all remembered contexts." alt="" coords="215,85,399,115"/><area shape="rect" id="node5" href="group__lu.html#ga6e069db37ac446fe47b8b211c3d721c5" title="Deregister key." alt="" coords="468,59,657,88"/><area shape="rect" id="node13" href="group__lu.html#ga48615706cf5edca3013bafd6f2f22059" title="Quiescent a number of keys." alt="" coords="448,112,677,141"/><area shape="rect" id="node7" href="group__lu.html#ga3826a7e5b3ea78a0a1be49390c5efe18" title="De&#45;register a number of keys." alt="" coords="727,5,959,35"/><area shape="rect" id="node9" href="group__lu.html#gabc82bcbb2d0d7e41ec7965f71878a606" title="Register a number of keys." alt="" coords="728,59,957,88"/><area shape="rect" id="node11" href="group__lu.html#ga342d9d23d96d691f49863e21af40bbcd" title="Dual to lu_global_init()." alt="" coords="791,112,895,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga17240d2c6cef5226d4ec8c0b4046afa1"></a><!-- doxytag: member="cl_object.h::cl_env_get" ref="ga17240d2c6cef5226d4ec8c0b4046afa1" args="(__u16 *refcheck)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__env.html">lu_env</a>* cl_env_get </td>
          <td>(</td>
          <td class="paramtype">__u16 *&nbsp;</td>
          <td class="paramname"> <em>refcheck</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <a class="el" href="structlu__env.html" title="Environment.">lu_env</a>: if there already is an environment associated with the current thread, it is returned, otherwise, new environment is allocated. </p>
<p>Allocations are amortized through the global cache of environments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>refcheck</em>&nbsp;</td><td>pointer to a counter used to detect environment leaks. In the usual case <a class="el" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get()</a> and <a class="el" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put()</a> are called in the same lexical scope and pointer to the same integer is passed as <em>refcheck</em>. This is used to detect missed <a class="el" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__object_8c_source.html#l00906">906</a> of file <a class="el" href="cl__object_8c_source.html">cl_object.c</a>.</p>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l01051">cl_env_implant()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00907"></a>00907 {
<a name="l00908"></a>00908         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910         env = cl_env_peek(refcheck);
<a name="l00911"></a>00911         <span class="keywordflow">if</span> (env == NULL) {
<a name="l00912"></a>00912                 env = cl_env_obtain(__builtin_return_address(0));
<a name="l00913"></a>00913                 <span class="keywordflow">if</span> (!IS_ERR(env)) {
<a name="l00914"></a>00914                         <span class="keyword">struct </span>cl_env *cle;
<a name="l00915"></a>00915 
<a name="l00916"></a>00916                         cle = cl_env_container(env);
<a name="l00917"></a>00917                         cl_env_attach(cle);
<a name="l00918"></a>00918                         *refcheck = cle-&gt;ce_ref;
<a name="l00919"></a>00919                         CDEBUG(D_OTHER, <span class="stringliteral">&quot;%d@%p\n&quot;</span>, cle-&gt;ce_ref, cle);
<a name="l00920"></a>00920                 }
<a name="l00921"></a>00921         }
<a name="l00922"></a>00922         <span class="keywordflow">return</span> env;
<a name="l00923"></a>00923 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__env_ga17240d2c6cef5226d4ec8c0b4046afa1_icgraph.png" border="0" usemap="#group__cl__env_ga17240d2c6cef5226d4ec8c0b4046afa1_icgraph_map" alt=""></div>
<map name="group__cl__env_ga17240d2c6cef5226d4ec8c0b4046afa1_icgraph_map" id="group__cl__env_ga17240d2c6cef5226d4ec8c0b4046afa1_icgraph">
<area shape="rect" id="node3" href="group__cl__env.html#gad07c2a6339d36f40375805d9ae5e02cc" title="Setup user&#45;supplied env as a current environment." alt="" coords="149,5,272,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad07c2a6339d36f40375805d9ae5e02cc"></a><!-- doxytag: member="cl_object.h::cl_env_implant" ref="gad07c2a6339d36f40375805d9ae5e02cc" args="(struct lu_env *env, __u16 *refcheck)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_env_implant </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u16 *&nbsp;</td>
          <td class="paramname"> <em>refcheck</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup user-supplied <em>env</em> as a current environment. </p>
<p>This is to be used to guaranteed that environment exists even when <a class="el" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get()</a> fails. It is up to user to ensure proper concurrency control.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__env.html#gace30ddb0f3834c7dad1c4d5315dd63ba" title="Detach environment installed earlier by cl_env_implant().">cl_env_unplant()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__object_8c_source.html#l01051">1051</a> of file <a class="el" href="cl__object_8c_source.html">cl_object.c</a>.</p>

<p>References <a class="el" href="cl__object_8c_source.html#l00906">cl_env_get()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01052"></a>01052 {
<a name="l01053"></a>01053         <span class="keyword">struct </span>cl_env *cle = cl_env_container(env);
<a name="l01054"></a>01054 
<a name="l01055"></a>01055         LASSERT(cle-&gt;ce_ref &gt; 0);
<a name="l01056"></a>01056 
<a name="l01057"></a>01057         cl_env_attach(cle);
<a name="l01058"></a>01058         <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(refcheck);
<a name="l01059"></a>01059         CDEBUG(D_OTHER, <span class="stringliteral">&quot;%d@%p\n&quot;</span>, cle-&gt;ce_ref, cle);
<a name="l01060"></a>01060 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__env_gad07c2a6339d36f40375805d9ae5e02cc_cgraph.png" border="0" usemap="#group__cl__env_gad07c2a6339d36f40375805d9ae5e02cc_cgraph_map" alt=""></div>
<map name="group__cl__env_gad07c2a6339d36f40375805d9ae5e02cc_cgraph_map" id="group__cl__env_gad07c2a6339d36f40375805d9ae5e02cc_cgraph">
<area shape="rect" id="node3" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread..." alt="" coords="176,5,272,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9cf31d221b7596143ff46bd799f19cf2"></a><!-- doxytag: member="cl_object.h::cl_env_put" ref="ga9cf31d221b7596143ff46bd799f19cf2" args="(struct lu_env *env, __u16 *refcheck)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_env_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u16 *&nbsp;</td>
          <td class="paramname"> <em>refcheck</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release an environment. </p>
<p>Decrement <em>env</em> reference counter. When counter drops to 0, nothing in this thread is using environment and it is returned to the allocation cache, or freed straight away, if cache is large enough. </p>

<p>Definition at line <a class="el" href="cl__object_8c_source.html#l00989">989</a> of file <a class="el" href="cl__object_8c_source.html">cl_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00958">lu_context::lc_tags</a>, <a class="el" href="lu__object_8h_source.html#l01007">LCT_CL_THREAD</a>, <a class="el" href="lu__object_8h_source.html#l01034">LCT_HAS_EXIT</a>, <a class="el" href="lu__object_8h_source.html#l01012">LCT_SESSION</a>, <a class="el" href="lu__object_8h_source.html#l01273">lu_env::le_ctx</a>, and <a class="el" href="lu__object_8h_source.html#l01277">lu_env::le_ses</a>.</p>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l01066">cl_env_unplant()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00990"></a>00990 {
<a name="l00991"></a>00991         <span class="keyword">struct </span>cl_env *cle;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993         cle = cl_env_container(env);
<a name="l00994"></a>00994 
<a name="l00995"></a>00995         LASSERT(cle-&gt;ce_ref &gt; 0);
<a name="l00996"></a>00996         LASSERT(ergo(refcheck != NULL, cle-&gt;ce_ref == *refcheck));
<a name="l00997"></a>00997 
<a name="l00998"></a>00998         CDEBUG(D_OTHER, <span class="stringliteral">&quot;%d@%p\n&quot;</span>, cle-&gt;ce_ref, cle);
<a name="l00999"></a>00999         <span class="keywordflow">if</span> (--cle-&gt;ce_ref == 0) {
<a name="l01000"></a>01000                 CL_ENV_DEC(busy);
<a name="l01001"></a>01001                 cl_env_detach(cle);
<a name="l01002"></a>01002                 cle-&gt;ce_debug = NULL;
<a name="l01003"></a>01003                 cl_env_exit(cle);
<a name="l01004"></a>01004                 <span class="comment">/*</span>
<a name="l01005"></a>01005 <span class="comment">                 * Don&apos;t bother to take a lock here.</span>
<a name="l01006"></a>01006 <span class="comment">                 *</span>
<a name="l01007"></a>01007 <span class="comment">                 * Return environment to the cache only when it was allocated</span>
<a name="l01008"></a>01008 <span class="comment">                 * with the standard tags.</span>
<a name="l01009"></a>01009 <span class="comment">                 */</span>
<a name="l01010"></a>01010                 <span class="keywordflow">if</span> (cl_envs_cached_nr &lt; cl_envs_cached_max &amp;&amp;
<a name="l01011"></a>01011                     (env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>.<a class="code" href="structlu__context.html#af10e2b16ba4601b8625e8075068f6c14" title="lu_context is used on the client side too.">lc_tags</a> &amp; ~<a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa17f47648c605de40856da551f04fe939" title="Set when at least one of keys, having values in this context has non-NULL lu_context_key::lct_exit()...">LCT_HAS_EXIT</a>) == <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" title="Thread on client.">LCT_CL_THREAD</a> &amp;&amp;
<a name="l01012"></a>01012                     (env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>-&gt;<a class="code" href="structlu__context.html#af10e2b16ba4601b8625e8075068f6c14" title="lu_context is used on the client side too.">lc_tags</a> &amp; ~<a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa17f47648c605de40856da551f04fe939" title="Set when at least one of keys, having values in this context has non-NULL lu_context_key::lct_exit()...">LCT_HAS_EXIT</a>) == <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa76aa3f8e745622ced47e2687d27c4b84" title="A per-request session on a server, and a per-system-call session on a client.">LCT_SESSION</a>) {
<a name="l01013"></a>01013                         spin_lock(&amp;cl_envs_guard);
<a name="l01014"></a>01014                         list_add(&amp;cle-&gt;ce_linkage, &amp;cl_envs);
<a name="l01015"></a>01015                         cl_envs_cached_nr++;
<a name="l01016"></a>01016                         spin_unlock(&amp;cl_envs_guard);
<a name="l01017"></a>01017                 } <span class="keywordflow">else</span>
<a name="l01018"></a>01018                         cl_env_fini(cle);
<a name="l01019"></a>01019         }
<a name="l01020"></a>01020 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__cl__env_ga9cf31d221b7596143ff46bd799f19cf2_icgraph.png" border="0" usemap="#group__cl__env_ga9cf31d221b7596143ff46bd799f19cf2_icgraph_map" alt=""></div>
<map name="group__cl__env_ga9cf31d221b7596143ff46bd799f19cf2_icgraph_map" id="group__cl__env_ga9cf31d221b7596143ff46bd799f19cf2_icgraph">
<area shape="rect" id="node3" href="group__cl__env.html#gace30ddb0f3834c7dad1c4d5315dd63ba" title="Detach environment installed earlier by cl_env_implant()." alt="" coords="149,5,272,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga2c3cf05baa558c0e2888b5c82d0039a2"></a><!-- doxytag: member="cl_object.h::cl_env_reenter" ref="ga2c3cf05baa558c0e2888b5c82d0039a2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cl_env_reenter </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declares a point of re-entrancy. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__env.html#ga6a2f0ccf8118ede1c1f191a545937eac" title="Exits re-entrancy.">cl_env_reexit()</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__object_8c_source.html#l01028">1028</a> of file <a class="el" href="cl__object_8c_source.html">cl_object.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01029"></a>01029 {
<a name="l01030"></a>01030         <span class="keywordflow">return</span> cl_env_detach(NULL);
<a name="l01031"></a>01031 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:38 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
