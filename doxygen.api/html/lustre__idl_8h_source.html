<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/include/lustre/lustre_idl.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/include/lustre/lustre_idl.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lustre/include/lustre/lustre_idl.h</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Lustre wire protocol definitions.</span>
<a name="l00039"></a>00039 <span class="comment"> */</span>
<a name="l00040"></a>00040 
<a name="l00073"></a>00073 <span class="preprocessor">#ifndef _LUSTRE_IDL_H_</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#define _LUSTRE_IDL_H_</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &lt;linux/types.h&gt;</span>
<a name="l00077"></a>00077 <span class="preprocessor">#include &lt;libcfs/libcfs.h&gt;</span>
<a name="l00078"></a>00078 <span class="preprocessor">#include &lt;lnet/types.h&gt;</span>
<a name="l00079"></a>00079 <span class="preprocessor">#include &lt;lustre/lustre_user.h&gt;</span> <span class="comment">/* Defn&apos;s shared with user-space. */</span>
<a name="l00080"></a>00080 <span class="preprocessor">#include &lt;lustre/lustre_errno.h&gt;</span>
<a name="l00081"></a>00081 <span class="preprocessor">#include &lt;lustre_ver.h&gt;</span>
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment">/*</span>
<a name="l00084"></a>00084 <span class="comment"> *  GENERAL STUFF</span>
<a name="l00085"></a>00085 <span class="comment"> */</span>
<a name="l00086"></a>00086 <span class="comment">/* FOO_REQUEST_PORTAL is for incoming requests on the FOO</span>
<a name="l00087"></a>00087 <span class="comment"> * FOO_REPLY_PORTAL   is for incoming replies on the FOO</span>
<a name="l00088"></a>00088 <span class="comment"> * FOO_BULK_PORTAL    is for incoming bulk on the FOO</span>
<a name="l00089"></a>00089 <span class="comment"> */</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="preprocessor">#define CONNMGR_REQUEST_PORTAL          1</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#define CONNMGR_REPLY_PORTAL            2</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="comment">//#define OSC_REQUEST_PORTAL            3</span>
<a name="l00094"></a>00094 <span class="preprocessor">#define OSC_REPLY_PORTAL                4</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="comment">//#define OSC_BULK_PORTAL               5</span>
<a name="l00096"></a>00096 <span class="preprocessor">#define OST_IO_PORTAL                   6</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#define OST_CREATE_PORTAL               7</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#define OST_BULK_PORTAL                 8</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="comment">//#define MDC_REQUEST_PORTAL            9</span>
<a name="l00100"></a>00100 <span class="preprocessor">#define MDC_REPLY_PORTAL               10</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="comment">//#define MDC_BULK_PORTAL              11</span>
<a name="l00102"></a>00102 <span class="preprocessor">#define MDS_REQUEST_PORTAL             12</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="comment">//#define MDS_REPLY_PORTAL             13</span>
<a name="l00104"></a>00104 <span class="preprocessor">#define MDS_BULK_PORTAL                14</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_CB_REQUEST_PORTAL         15</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_CB_REPLY_PORTAL           16</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_CANCEL_REQUEST_PORTAL     17</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_CANCEL_REPLY_PORTAL       18</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="comment">//#define PTLBD_REQUEST_PORTAL           19</span>
<a name="l00110"></a>00110 <span class="comment">//#define PTLBD_REPLY_PORTAL             20</span>
<a name="l00111"></a>00111 <span class="comment">//#define PTLBD_BULK_PORTAL              21</span>
<a name="l00112"></a>00112 <span class="preprocessor">#define MDS_SETATTR_PORTAL             22</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#define MDS_READPAGE_PORTAL            23</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#define OUT_PORTAL                      24</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span><span class="preprocessor">#define MGC_REPLY_PORTAL               25</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span><span class="preprocessor">#define MGS_REQUEST_PORTAL             26</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#define MGS_REPLY_PORTAL               27</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor">#define OST_REQUEST_PORTAL             28</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="preprocessor">#define FLD_REQUEST_PORTAL             29</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span><span class="preprocessor">#define SEQ_METADATA_PORTAL            30</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="preprocessor">#define SEQ_DATA_PORTAL                31</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor">#define SEQ_CONTROLLER_PORTAL          32</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#define MGS_BULK_PORTAL                33</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span>
<a name="l00125"></a>00125 <span class="comment">/* Portal 63 is reserved for the Cray Inc DVS - nic@cray.com, roe@cray.com, n8851@cray.com */</span>
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="comment">/* packet types */</span>
<a name="l00128"></a>00128 <span class="preprocessor">#define PTL_RPC_MSG_REQUEST 4711</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span><span class="preprocessor">#define PTL_RPC_MSG_ERR     4712</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span><span class="preprocessor">#define PTL_RPC_MSG_REPLY   4713</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>
<a name="l00132"></a>00132 <span class="comment">/* DON&apos;T use swabbed values of MAGIC as magic! */</span>
<a name="l00133"></a>00133 <span class="preprocessor">#define LUSTRE_MSG_MAGIC_V2 0x0BD00BD3</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><span class="preprocessor">#define LUSTRE_MSG_MAGIC_V2_SWABBED 0xD30BD00B</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00136"></a>00136 <span class="preprocessor">#define LUSTRE_MSG_MAGIC LUSTRE_MSG_MAGIC_V2</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>
<a name="l00138"></a>00138 <span class="preprocessor">#define PTLRPC_MSG_VERSION  0x00000003</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor">#define LUSTRE_VERSION_MASK 0xffff0000</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#define LUSTRE_OBD_VERSION  0x00010000</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="preprocessor">#define LUSTRE_MDS_VERSION  0x00020000</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span><span class="preprocessor">#define LUSTRE_OST_VERSION  0x00030000</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span><span class="preprocessor">#define LUSTRE_DLM_VERSION  0x00040000</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span><span class="preprocessor">#define LUSTRE_LOG_VERSION  0x00050000</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span><span class="preprocessor">#define LUSTRE_MGS_VERSION  0x00060000</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span>
<a name="l00153"></a><a class="code" href="structlu__seq__range.html">00153</a> <span class="keyword">struct </span><a class="code" href="structlu__seq__range.html" title="Describes a range of sequence, lsr_start is included but lsr_end is not in the range...">lu_seq_range</a> {
<a name="l00154"></a>00154         __u64 lsr_start;
<a name="l00155"></a>00155         __u64 lsr_end;
<a name="l00156"></a>00156         __u32 lsr_index;
<a name="l00157"></a>00157         __u32 lsr_flags;
<a name="l00158"></a>00158 };
<a name="l00159"></a>00159 
<a name="l00160"></a><a class="code" href="structlu__seq__range__array.html">00160</a> <span class="keyword">struct </span><a class="code" href="structlu__seq__range__array.html">lu_seq_range_array</a> {
<a name="l00161"></a>00161         __u32 lsra_count;
<a name="l00162"></a>00162         __u32 lsra_padding;
<a name="l00163"></a>00163         <span class="keyword">struct </span><a class="code" href="structlu__seq__range.html" title="Describes a range of sequence, lsr_start is included but lsr_end is not in the range...">lu_seq_range</a> lsra_lsr[0];
<a name="l00164"></a>00164 };
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="preprocessor">#define LU_SEQ_RANGE_MDT        0x0</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">#define LU_SEQ_RANGE_OST        0x1</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><span class="preprocessor">#define LU_SEQ_RANGE_ANY        0x3</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span>
<a name="l00170"></a>00170 <span class="preprocessor">#define LU_SEQ_RANGE_MASK       0x3</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span>
<a name="l00180"></a><a class="code" href="group__lu__fid.html#ga081d8a344dc74bcb57c19b9f45ddb7c0">00180</a> <span class="keyword">enum</span> <a class="code" href="group__lu__fid.html#ga081d8a344dc74bcb57c19b9f45ddb7c0" title="Flags for lustre_mdt_attrs::lma_compat and lustre_mdt_attrs::lma_incompat.">lma_compat</a> {
<a name="l00181"></a>00181         LMAC_HSM        = 0x00000001,
<a name="l00182"></a>00182 <span class="comment">/*      LMAC_SOM        = 0x00000002, obsolete since 2.8.0 */</span>
<a name="l00183"></a>00183         LMAC_NOT_IN_OI  = 0x00000004, <span class="comment">/* the object does NOT need OI mapping */</span>
<a name="l00184"></a>00184         LMAC_FID_ON_OST = 0x00000008, <span class="comment">/* For OST-object, its OI mapping is</span>
<a name="l00185"></a>00185 <span class="comment">                                       * under /O/&lt;seq&gt;/d&lt;x&gt;. */</span>
<a name="l00186"></a>00186 };
<a name="l00187"></a>00187 
<a name="l00193"></a><a class="code" href="group__lu__fid.html#ga5c86b0d816a99aa2ef2c9f6f41d4f893">00193</a> <span class="keyword">enum</span> <a class="code" href="group__lu__fid.html#ga5c86b0d816a99aa2ef2c9f6f41d4f893" title="Masks for all features that should be supported by a Lustre version to access a specific...">lma_incompat</a> {
<a name="l00194"></a>00194         LMAI_RELEASED           = 0x00000001, <span class="comment">/* file is released */</span>
<a name="l00195"></a>00195         LMAI_AGENT              = 0x00000002, <span class="comment">/* agent inode */</span>
<a name="l00196"></a>00196         LMAI_REMOTE_PARENT      = 0x00000004, <span class="comment">/* the parent of the object</span>
<a name="l00197"></a>00197 <span class="comment">                                                 is on the remote MDT */</span>
<a name="l00198"></a>00198         LMAI_STRIPED            = 0x00000008, <span class="comment">/* striped directory inode */</span>
<a name="l00199"></a>00199         LMAI_ORPHAN             = 0x00000010, <span class="comment">/* inode is orphan */</span>
<a name="l00200"></a>00200         LMA_INCOMPAT_SUPP       = (LMAI_AGENT | LMAI_REMOTE_PARENT | \
<a name="l00201"></a>00201                                    LMAI_STRIPED | LMAI_ORPHAN)
<a name="l00202"></a>00202 };
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__lu__fid.html#ga57ce2f0700c0cc37b3d423df0ff5e3aa" title="Swab, if needed, LMA structure which is stored on-disk in little-endian order.">lustre_lma_swab</a>(<span class="keyword">struct</span> <a class="code" href="structlustre__mdt__attrs.html" title="Following struct for object attributes, that will be kept inode&amp;#39;s EA.">lustre_mdt_attrs</a> *lma);
<a name="l00205"></a>00205 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__lu__fid.html#gad6d276486e37db88948da19fc7b6cf89" title="Initialize new lma.">lustre_lma_init</a>(<span class="keyword">struct</span> <a class="code" href="structlustre__mdt__attrs.html" title="Following struct for object attributes, that will be kept inode&amp;#39;s EA.">lustre_mdt_attrs</a> *lma,
<a name="l00206"></a>00206                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00207"></a>00207                             __u32 compat, __u32 incompat);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="comment">/* copytool uses a 32b bitmask field to encode archive-Ids during register</span>
<a name="l00210"></a>00210 <span class="comment"> * with MDT thru kuc.</span>
<a name="l00211"></a>00211 <span class="comment"> * archive num = 0 =&gt; all</span>
<a name="l00212"></a>00212 <span class="comment"> * archive num from 1 to 32</span>
<a name="l00213"></a>00213 <span class="comment"> */</span>
<a name="l00214"></a>00214 <span class="preprocessor">#define LL_HSM_MAX_ARCHIVE (sizeof(__u32) * 8)</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span>
<a name="l00219"></a><a class="code" href="structhsm__attrs.html">00219</a> <span class="keyword">struct </span><a class="code" href="structhsm__attrs.html" title="HSM on-disk attributes stored in a separate xattr.">hsm_attrs</a> {
<a name="l00221"></a><a class="code" href="structhsm__attrs.html#a784c34a6bd2cc72df8b8503f424b0521">00221</a>         __u32   <a class="code" href="structhsm__attrs.html#a784c34a6bd2cc72df8b8503f424b0521" title="Bitfield for supported data in this structure.">hsm_compat</a>;
<a name="l00222"></a>00222 
<a name="l00224"></a><a class="code" href="structhsm__attrs.html#aef839e4efceb4c5950040a81dd1ced4b">00224</a>         __u32   <a class="code" href="structhsm__attrs.html#aef839e4efceb4c5950040a81dd1ced4b" title="HSM flags, see hsm_flags enum below.">hsm_flags</a>;
<a name="l00226"></a><a class="code" href="structhsm__attrs.html#ac16d2ab278b3116decbd9f88f98049cb">00226</a>         __u64   <a class="code" href="structhsm__attrs.html#ac16d2ab278b3116decbd9f88f98049cb" title="backend archive id associated with the file">hsm_arch_id</a>;
<a name="l00228"></a><a class="code" href="structhsm__attrs.html#a24b51da015e8ee16579f7dde21d772e6">00228</a>         __u64   <a class="code" href="structhsm__attrs.html#a24b51da015e8ee16579f7dde21d772e6" title="version associated with the last archiving, if any">hsm_arch_ver</a>;
<a name="l00229"></a>00229 };
<a name="l00230"></a>00230 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__lu__fid.html#ga5ca354ba0913bf236001c307b119ef21" title="Swab, if needed, HSM structure which is stored on-disk in little-endian order.">lustre_hsm_swab</a>(<span class="keyword">struct</span> <a class="code" href="structhsm__attrs.html" title="HSM on-disk attributes stored in a separate xattr.">hsm_attrs</a> *attrs);
<a name="l00231"></a>00231 
<a name="l00235"></a>00235 <span class="keyword">enum</span> {
<a name="l00237"></a><a class="code" href="group__lu__fid.html#gga39fca1837c5ce7715cbf571669660c13a8b43011f1da1d645f997f4750219e307">00237</a>         <a class="code" href="group__lu__fid.html#gga39fca1837c5ce7715cbf571669660c13a8b43011f1da1d645f997f4750219e307" title="LASTID file has zero OID.">LUSTRE_FID_LASTID_OID</a> = 0UL,
<a name="l00239"></a><a class="code" href="group__lu__fid.html#gga39fca1837c5ce7715cbf571669660c13a94db8d3ca92311f57ec84c66630a5f97">00239</a>         <a class="code" href="group__lu__fid.html#gga39fca1837c5ce7715cbf571669660c13a94db8d3ca92311f57ec84c66630a5f97" title="initial fid id value">LUSTRE_FID_INIT_OID</a>  = 1UL
<a name="l00240"></a>00240 };
<a name="l00241"></a>00241 
<a name="l00243"></a>00243 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00244"></a>00244 {
<a name="l00245"></a>00245         <span class="keywordflow">return</span> fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a>;
<a name="l00246"></a>00246 }
<a name="l00247"></a>00247 
<a name="l00249"></a>00249 <span class="keyword">static</span> <span class="keyword">inline</span> __u32 fid_oid(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00250"></a>00250 {
<a name="l00251"></a>00251         <span class="keywordflow">return</span> fid-&gt;f_oid;
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 
<a name="l00255"></a>00255 <span class="keyword">static</span> <span class="keyword">inline</span> __u32 fid_ver(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00256"></a>00256 {
<a name="l00257"></a>00257         <span class="keywordflow">return</span> fid-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a>;
<a name="l00258"></a>00258 }
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> fid_zero(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262         memset(fid, 0, <span class="keyword">sizeof</span>(*fid));
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 fid_ver_oid(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00266"></a>00266 {
<a name="l00267"></a>00267         <span class="keywordflow">return</span> ((__u64)fid_ver(fid) &lt;&lt; 32 | fid_oid(fid));
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00278"></a><a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f">00278</a> <span class="keyword">enum</span> <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a> {
<a name="l00279"></a>00279         FID_SEQ_OST_MDT0        = 0,
<a name="l00280"></a>00280         FID_SEQ_LLOG            = 1, <span class="comment">/* unnamed llogs */</span>
<a name="l00281"></a>00281         FID_SEQ_ECHO            = 2,
<a name="l00282"></a>00282         FID_SEQ_UNUSED_START    = 3,
<a name="l00283"></a>00283         FID_SEQ_UNUSED_END      = 9,
<a name="l00284"></a>00284         FID_SEQ_LLOG_NAME       = 10, <span class="comment">/* named llogs */</span>
<a name="l00285"></a>00285         FID_SEQ_RSVD            = 11,
<a name="l00286"></a>00286         FID_SEQ_IGIF            = 12,
<a name="l00287"></a>00287         FID_SEQ_IGIF_MAX        = 0x0ffffffffULL,
<a name="l00288"></a>00288         FID_SEQ_IDIF            = 0x100000000ULL,
<a name="l00289"></a>00289         FID_SEQ_IDIF_MAX        = 0x1ffffffffULL,
<a name="l00290"></a>00290         <span class="comment">/* Normal FID sequence starts from this value, i.e. 1&lt;&lt;33 */</span>
<a name="l00291"></a>00291         FID_SEQ_START           = 0x200000000ULL,
<a name="l00292"></a>00292         <span class="comment">/* sequence for local pre-defined FIDs listed in local_oid */</span>
<a name="l00293"></a>00293         FID_SEQ_LOCAL_FILE      = 0x200000001ULL,
<a name="l00294"></a>00294         FID_SEQ_DOT_LUSTRE      = 0x200000002ULL,
<a name="l00295"></a>00295         <span class="comment">/* sequence is used for local named objects FIDs generated</span>
<a name="l00296"></a>00296 <span class="comment">         * by local_object_storage library */</span>
<a name="l00297"></a>00297         FID_SEQ_LOCAL_NAME      = 0x200000003ULL,
<a name="l00298"></a>00298         <span class="comment">/* Because current FLD will only cache the fid sequence, instead</span>
<a name="l00299"></a>00299 <span class="comment">         * of oid on the client side, if the FID needs to be exposed to</span>
<a name="l00300"></a>00300 <span class="comment">         * clients sides, it needs to make sure all of fids under one</span>
<a name="l00301"></a>00301 <span class="comment">         * sequence will be located in one MDT. */</span>
<a name="l00302"></a>00302         FID_SEQ_SPECIAL         = 0x200000004ULL,
<a name="l00303"></a>00303         FID_SEQ_QUOTA           = 0x200000005ULL,
<a name="l00304"></a>00304         FID_SEQ_QUOTA_GLB       = 0x200000006ULL,
<a name="l00305"></a>00305         FID_SEQ_ROOT            = 0x200000007ULL,  <span class="comment">/* Located on MDT0 */</span>
<a name="l00306"></a>00306         FID_SEQ_LAYOUT_RBTREE   = 0x200000008ULL,
<a name="l00307"></a>00307         <span class="comment">/* sequence is used for update logs of cross-MDT operation */</span>
<a name="l00308"></a>00308         FID_SEQ_UPDATE_LOG      = 0x200000009ULL,
<a name="l00309"></a>00309         <span class="comment">/* Sequence is used for the directory under which update logs</span>
<a name="l00310"></a>00310 <span class="comment">         * are created. */</span>
<a name="l00311"></a>00311         FID_SEQ_UPDATE_LOG_DIR  = 0x20000000aULL,
<a name="l00312"></a>00312         FID_SEQ_NORMAL          = 0x200000400ULL,
<a name="l00313"></a>00313         FID_SEQ_LOV_DEFAULT     = 0xffffffffffffffffULL
<a name="l00314"></a>00314 };
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="preprocessor">#define OBIF_OID_MAX_BITS           32</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span><span class="preprocessor">#define OBIF_MAX_OID                (1ULL &lt;&lt; OBIF_OID_MAX_BITS)</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span><span class="preprocessor">#define OBIF_OID_MASK               ((1ULL &lt;&lt; OBIF_OID_MAX_BITS) - 1)</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span><span class="preprocessor">#define IDIF_OID_MAX_BITS           48</span>
<a name="l00320"></a>00320 <span class="preprocessor"></span><span class="preprocessor">#define IDIF_MAX_OID                (1ULL &lt;&lt; IDIF_OID_MAX_BITS)</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span><span class="preprocessor">#define IDIF_OID_MASK               ((1ULL &lt;&lt; IDIF_OID_MAX_BITS) - 1)</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span>
<a name="l00324"></a><a class="code" href="group__lu__fid.html#gaabd104e6a31a8938c432ca2e879df604">00324</a> <span class="keyword">enum</span> <a class="code" href="group__lu__fid.html#gaabd104e6a31a8938c432ca2e879df604" title="OID for FID_SEQ_SPECIAL.">special_oid</a> {
<a name="l00325"></a>00325         <span class="comment">/* Big Filesystem Lock to serialize rename operations */</span>
<a name="l00326"></a>00326         FID_OID_SPECIAL_BFL     = 1UL,
<a name="l00327"></a>00327 };
<a name="l00328"></a>00328 
<a name="l00330"></a><a class="code" href="group__lu__fid.html#ga75ebbd83cf9ff73571541e51c26ce786">00330</a> <span class="keyword">enum</span> <a class="code" href="group__lu__fid.html#ga75ebbd83cf9ff73571541e51c26ce786" title="OID for FID_SEQ_DOT_LUSTRE.">dot_lustre_oid</a> {
<a name="l00331"></a>00331         FID_OID_DOT_LUSTRE      = 1UL,
<a name="l00332"></a>00332         FID_OID_DOT_LUSTRE_OBF  = 2UL,
<a name="l00333"></a>00333         FID_OID_DOT_LUSTRE_LPF  = 3UL,
<a name="l00334"></a>00334 };
<a name="l00335"></a>00335 
<a name="l00337"></a><a class="code" href="group__lu__fid.html#ga363203a813dc870a46b320f5e4ba5718">00337</a> <span class="keyword">enum</span> <a class="code" href="group__lu__fid.html#ga363203a813dc870a46b320f5e4ba5718" title="OID for FID_SEQ_ROOT.">root_oid</a> {
<a name="l00338"></a>00338         FID_OID_ROOT            = 1UL,
<a name="l00339"></a>00339         FID_OID_ECHO_ROOT       = 2UL,
<a name="l00340"></a>00340 };
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_mdt0(__u64 seq)
<a name="l00343"></a>00343 {
<a name="l00344"></a>00344         <span class="keywordflow">return</span> seq == FID_SEQ_OST_MDT0;
<a name="l00345"></a>00345 }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_mdt(__u64 seq)
<a name="l00348"></a>00348 {
<a name="l00349"></a>00349         <span class="keywordflow">return</span> seq == FID_SEQ_OST_MDT0 || seq &gt;= FID_SEQ_NORMAL;
<a name="l00350"></a>00350 };
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_echo(__u64 seq)
<a name="l00353"></a>00353 {
<a name="l00354"></a>00354         <span class="keywordflow">return</span> seq == FID_SEQ_ECHO;
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_echo(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359         <span class="keywordflow">return</span> fid_seq_is_echo(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid));
<a name="l00360"></a>00360 }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_llog(__u64 seq)
<a name="l00363"></a>00363 {
<a name="l00364"></a>00364         <span class="keywordflow">return</span> seq == FID_SEQ_LLOG;
<a name="l00365"></a>00365 }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_llog(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00368"></a>00368 {
<a name="l00369"></a>00369         <span class="comment">/* file with OID == 0 is not llog but contains last oid */</span>
<a name="l00370"></a>00370         <span class="keywordflow">return</span> fid_seq_is_llog(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid)) &amp;&amp; fid_oid(fid) &gt; 0;
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_rsvd(__u64 seq)
<a name="l00374"></a>00374 {
<a name="l00375"></a>00375         <span class="keywordflow">return</span> seq &gt; FID_SEQ_OST_MDT0 &amp;&amp; seq &lt;= FID_SEQ_RSVD;
<a name="l00376"></a>00376 };
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_special(__u64 seq)
<a name="l00379"></a>00379 {
<a name="l00380"></a>00380         <span class="keywordflow">return</span> seq == FID_SEQ_SPECIAL;
<a name="l00381"></a>00381 };
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_local_file(__u64 seq)
<a name="l00384"></a>00384 {
<a name="l00385"></a>00385         <span class="keywordflow">return</span> seq == FID_SEQ_LOCAL_FILE ||
<a name="l00386"></a>00386                seq == FID_SEQ_LOCAL_NAME;
<a name="l00387"></a>00387 };
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_root(__u64 seq)
<a name="l00390"></a>00390 {
<a name="l00391"></a>00391         <span class="keywordflow">return</span> seq == FID_SEQ_ROOT;
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_dot(__u64 seq)
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396         <span class="keywordflow">return</span> seq == FID_SEQ_DOT_LUSTRE;
<a name="l00397"></a>00397 }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_default(__u64 seq)
<a name="l00400"></a>00400 {
<a name="l00401"></a>00401         <span class="keywordflow">return</span> seq == FID_SEQ_LOV_DEFAULT;
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_mdt0(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00405"></a>00405 {
<a name="l00406"></a>00406         <span class="keywordflow">return</span> fid_seq_is_mdt0(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid));
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lu_root_fid(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00410"></a>00410 {
<a name="l00411"></a>00411         fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = FID_SEQ_ROOT;
<a name="l00412"></a>00412         fid-&gt;f_oid = FID_OID_ROOT;
<a name="l00413"></a>00413         fid-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = 0;
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lu_echo_root_fid(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00417"></a>00417 {
<a name="l00418"></a>00418         fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = FID_SEQ_ROOT;
<a name="l00419"></a>00419         fid-&gt;f_oid = FID_OID_ECHO_ROOT;
<a name="l00420"></a>00420         fid-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = 0;
<a name="l00421"></a>00421 }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lu_update_log_fid(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, __u32 index)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425         fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = FID_SEQ_UPDATE_LOG;
<a name="l00426"></a>00426         fid-&gt;f_oid = index;
<a name="l00427"></a>00427         fid-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = 0;
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lu_update_log_dir_fid(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, __u32 index)
<a name="l00431"></a>00431 {
<a name="l00432"></a>00432         fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = FID_SEQ_UPDATE_LOG_DIR;
<a name="l00433"></a>00433         fid-&gt;f_oid = index;
<a name="l00434"></a>00434         fid-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = 0;
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00442"></a>00442 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_igif(__u64 seq)
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444         <span class="keywordflow">return</span> seq &gt;= FID_SEQ_IGIF &amp;&amp; seq &lt;= FID_SEQ_IGIF_MAX;
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_igif(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00448"></a>00448 {
<a name="l00449"></a>00449         <span class="keywordflow">return</span> fid_seq_is_igif(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid));
<a name="l00450"></a>00450 }
<a name="l00451"></a>00451 
<a name="l00457"></a>00457 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_idif(__u64 seq)
<a name="l00458"></a>00458 {
<a name="l00459"></a>00459         <span class="keywordflow">return</span> seq &gt;= FID_SEQ_IDIF &amp;&amp; seq &lt;= FID_SEQ_IDIF_MAX;
<a name="l00460"></a>00460 }
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_idif(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00463"></a>00463 {
<a name="l00464"></a>00464         <span class="keywordflow">return</span> fid_seq_is_idif(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid));
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_local_file(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00468"></a>00468 {
<a name="l00469"></a>00469         <span class="keywordflow">return</span> fid_seq_is_local_file(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid));
<a name="l00470"></a>00470 }
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_norm(__u64 seq)
<a name="l00473"></a>00473 {
<a name="l00474"></a>00474         <span class="keywordflow">return</span> (seq &gt;= FID_SEQ_NORMAL);
<a name="l00475"></a>00475 }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_norm(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00478"></a>00478 {
<a name="l00479"></a>00479         <span class="keywordflow">return</span> fid_seq_is_norm(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid));
<a name="l00480"></a>00480 }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> fid_is_layout_rbtree(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00483"></a>00483 {
<a name="l00484"></a>00484         <span class="keywordflow">return</span> <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid) == FID_SEQ_LAYOUT_RBTREE;
<a name="l00485"></a>00485 }
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_update_log(__u64 seq)
<a name="l00488"></a>00488 {
<a name="l00489"></a>00489         <span class="keywordflow">return</span> seq == FID_SEQ_UPDATE_LOG;
<a name="l00490"></a>00490 }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_update_log(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494         <span class="keywordflow">return</span> fid_seq_is_update_log(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid));
<a name="l00495"></a>00495 }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_seq_is_update_log_dir(__u64 seq)
<a name="l00498"></a>00498 {
<a name="l00499"></a>00499         <span class="keywordflow">return</span> seq == FID_SEQ_UPDATE_LOG_DIR;
<a name="l00500"></a>00500 }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_update_log_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00503"></a>00503 {
<a name="l00504"></a>00504         <span class="keywordflow">return</span> fid_seq_is_update_log_dir(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid));
<a name="l00505"></a>00505 }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 <span class="comment">/* convert an OST objid into an IDIF FID SEQ number */</span>
<a name="l00508"></a>00508 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 fid_idif_seq(__u64 <span class="keywordtype">id</span>, __u32 ost_idx)
<a name="l00509"></a>00509 {
<a name="l00510"></a>00510         <span class="keywordflow">return</span> FID_SEQ_IDIF | (ost_idx &lt;&lt; 16) | ((id &gt;&gt; 32) &amp; 0xffff);
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="comment">/* convert a packed IDIF FID into an OST objid */</span>
<a name="l00514"></a>00514 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 fid_idif_id(__u64 seq, __u32 oid, __u32 ver)
<a name="l00515"></a>00515 {
<a name="l00516"></a>00516         <span class="keywordflow">return</span> ((__u64)ver &lt;&lt; 48) | ((seq &amp; 0xffff) &lt;&lt; 32) | oid;
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="keyword">static</span> <span class="keyword">inline</span> __u32 idif_ost_idx(__u64 seq)
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521         <span class="keywordflow">return</span> (seq &gt;&gt; 16) &amp; 0xffff;
<a name="l00522"></a>00522 }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 <span class="comment">/* extract ost index from IDIF FID */</span>
<a name="l00525"></a>00525 <span class="keyword">static</span> <span class="keyword">inline</span> __u32 fid_idif_ost_idx(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00526"></a>00526 {
<a name="l00527"></a>00527         <span class="keywordflow">return</span> idif_ost_idx(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid));
<a name="l00528"></a>00528 }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="comment">/* extract OST sequence (group) from a wire ost_id (id/seq) pair */</span>
<a name="l00531"></a>00531 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 ostid_seq(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *ostid)
<a name="l00532"></a>00532 {
<a name="l00533"></a>00533         <span class="keywordflow">if</span> (fid_seq_is_mdt0(ostid-&gt;oi.oi_seq))
<a name="l00534"></a>00534                 <span class="keywordflow">return</span> FID_SEQ_OST_MDT0;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <span class="keywordflow">if</span> (unlikely(fid_seq_is_default(ostid-&gt;oi.oi_seq)))
<a name="l00537"></a>00537                 <span class="keywordflow">return</span> FID_SEQ_LOV_DEFAULT;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <span class="keywordflow">if</span> (fid_is_idif(&amp;ostid-&gt;oi_fid))
<a name="l00540"></a>00540                 <span class="keywordflow">return</span> FID_SEQ_OST_MDT0;
<a name="l00541"></a>00541 
<a name="l00542"></a>00542         <span class="keywordflow">return</span> <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(&amp;ostid-&gt;oi_fid);
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 <span class="comment">/* extract OST objid from a wire ost_id (id/seq) pair */</span>
<a name="l00546"></a>00546 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 ostid_id(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *ostid)
<a name="l00547"></a>00547 {
<a name="l00548"></a>00548         <span class="keywordflow">if</span> (fid_seq_is_mdt0(ostid-&gt;oi.oi_seq))
<a name="l00549"></a>00549                 <span class="keywordflow">return</span> ostid-&gt;oi.oi_id &amp; IDIF_OID_MASK;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551         <span class="keywordflow">if</span> (unlikely(fid_seq_is_default(ostid-&gt;oi.oi_seq)))
<a name="l00552"></a>00552                 <span class="keywordflow">return</span> ostid-&gt;oi.oi_id;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554         <span class="keywordflow">if</span> (fid_is_idif(&amp;ostid-&gt;oi_fid))
<a name="l00555"></a>00555                 <span class="keywordflow">return</span> fid_idif_id(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(&amp;ostid-&gt;oi_fid),
<a name="l00556"></a>00556                                    fid_oid(&amp;ostid-&gt;oi_fid), 0);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         <span class="keywordflow">return</span> fid_oid(&amp;ostid-&gt;oi_fid);
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ostid_set_seq(<span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi, __u64 seq)
<a name="l00562"></a>00562 {
<a name="l00563"></a>00563         <span class="keywordflow">if</span> (fid_seq_is_mdt0(seq) || fid_seq_is_default(seq)) {
<a name="l00564"></a>00564                 oi-&gt;oi.oi_seq = seq;
<a name="l00565"></a>00565         } <span class="keywordflow">else</span> {
<a name="l00566"></a>00566                 oi-&gt;oi_fid.<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = seq;
<a name="l00567"></a>00567                 <span class="comment">/* Note: if f_oid + f_ver is zero, we need init it</span>
<a name="l00568"></a>00568 <span class="comment">                 * to be 1, otherwise, ostid_seq will treat this</span>
<a name="l00569"></a>00569 <span class="comment">                 * as old ostid (oi_seq == 0) */</span>
<a name="l00570"></a>00570                 <span class="keywordflow">if</span> (oi-&gt;oi_fid.f_oid == 0 &amp;&amp; oi-&gt;oi_fid.<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> == 0)
<a name="l00571"></a>00571                         oi-&gt;oi_fid.f_oid = <a class="code" href="group__lu__fid.html#gga39fca1837c5ce7715cbf571669660c13a94db8d3ca92311f57ec84c66630a5f97" title="initial fid id value">LUSTRE_FID_INIT_OID</a>;
<a name="l00572"></a>00572         }
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ostid_set_seq_mdt0(<span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi)
<a name="l00576"></a>00576 {
<a name="l00577"></a>00577         ostid_set_seq(oi, FID_SEQ_OST_MDT0);
<a name="l00578"></a>00578 }
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ostid_set_seq_echo(<span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi)
<a name="l00581"></a>00581 {
<a name="l00582"></a>00582         ostid_set_seq(oi, FID_SEQ_ECHO);
<a name="l00583"></a>00583 }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ostid_set_seq_llog(<span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi)
<a name="l00586"></a>00586 {
<a name="l00587"></a>00587         ostid_set_seq(oi, FID_SEQ_LLOG);
<a name="l00588"></a>00588 }
<a name="l00589"></a>00589 
<a name="l00594"></a>00594 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ostid_set_id(<span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi, __u64 oid)
<a name="l00595"></a>00595 {
<a name="l00596"></a>00596         <span class="keywordflow">if</span> (fid_seq_is_mdt0(oi-&gt;oi.oi_seq)) {
<a name="l00597"></a>00597                 <span class="keywordflow">if</span> (oid &gt;= IDIF_MAX_OID) {
<a name="l00598"></a>00598                         CERROR(<span class="stringliteral">&quot;Too large OID %#llx to set MDT0 &quot;</span>DOSTID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00599"></a>00599                                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)oid, POSTID(oi));
<a name="l00600"></a>00600                         <span class="keywordflow">return</span>;
<a name="l00601"></a>00601                 }
<a name="l00602"></a>00602                 oi-&gt;oi.oi_id = oid;
<a name="l00603"></a>00603         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid_is_idif(&amp;oi-&gt;oi_fid)) {
<a name="l00604"></a>00604                 <span class="keywordflow">if</span> (oid &gt;= IDIF_MAX_OID) {
<a name="l00605"></a>00605                         CERROR(<span class="stringliteral">&quot;Too large OID %#llx to set IDIF &quot;</span>DOSTID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00606"></a>00606                                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)oid, POSTID(oi));
<a name="l00607"></a>00607                         <span class="keywordflow">return</span>;
<a name="l00608"></a>00608                 }
<a name="l00609"></a>00609                 oi-&gt;oi_fid.<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = fid_idif_seq(oid,
<a name="l00610"></a>00610                                                 fid_idif_ost_idx(&amp;oi-&gt;oi_fid));
<a name="l00611"></a>00611                 oi-&gt;oi_fid.f_oid = oid;
<a name="l00612"></a>00612                 oi-&gt;oi_fid.<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = oid &gt;&gt; 48;
<a name="l00613"></a>00613         } <span class="keywordflow">else</span> {
<a name="l00614"></a>00614                 <span class="keywordflow">if</span> (oid &gt; OBIF_MAX_OID) {
<a name="l00615"></a>00615                         CERROR(<span class="stringliteral">&quot;Too large oid %#llx to set REG &quot;</span>DOSTID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00616"></a>00616                                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)oid, POSTID(oi));
<a name="l00617"></a>00617                         <span class="keywordflow">return</span>;
<a name="l00618"></a>00618                 }
<a name="l00619"></a>00619                 oi-&gt;oi_fid.f_oid = oid;
<a name="l00620"></a>00620         }
<a name="l00621"></a>00621 }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> fid_set_id(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, __u64 oid)
<a name="l00624"></a>00624 {
<a name="l00625"></a>00625         <span class="keywordflow">if</span> (unlikely(fid_seq_is_igif(fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a>))) {
<a name="l00626"></a>00626                 CERROR(<span class="stringliteral">&quot;bad IGIF, &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>, PFID(fid));
<a name="l00627"></a>00627                 <span class="keywordflow">return</span> -EBADF;
<a name="l00628"></a>00628         }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         <span class="keywordflow">if</span> (fid_is_idif(fid)) {
<a name="l00631"></a>00631                 <span class="keywordflow">if</span> (oid &gt;= IDIF_MAX_OID) {
<a name="l00632"></a>00632                         CERROR(<span class="stringliteral">&quot;Too large OID %#llx to set IDIF &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00633"></a>00633                                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)oid, PFID(fid));
<a name="l00634"></a>00634                         <span class="keywordflow">return</span> -EBADF;
<a name="l00635"></a>00635                 }
<a name="l00636"></a>00636                 fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = fid_idif_seq(oid, fid_idif_ost_idx(fid));
<a name="l00637"></a>00637                 fid-&gt;f_oid = oid;
<a name="l00638"></a>00638                 fid-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = oid &gt;&gt; 48;
<a name="l00639"></a>00639         } <span class="keywordflow">else</span> {
<a name="l00640"></a>00640                 <span class="keywordflow">if</span> (oid &gt; OBIF_MAX_OID) {
<a name="l00641"></a>00641                         CERROR(<span class="stringliteral">&quot;Too large OID %#llx to set REG &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00642"></a>00642                                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)oid, PFID(fid));
<a name="l00643"></a>00643                         <span class="keywordflow">return</span> -EBADF;
<a name="l00644"></a>00644                 }
<a name="l00645"></a>00645                 fid-&gt;f_oid = oid;
<a name="l00646"></a>00646         }
<a name="l00647"></a>00647         <span class="keywordflow">return</span> 0;
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00659"></a>00659 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ostid_to_fid(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *ostid,
<a name="l00660"></a>00660                                __u32 ost_idx)
<a name="l00661"></a>00661 {
<a name="l00662"></a>00662         __u64 seq = ostid_seq(ostid);
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         <span class="keywordflow">if</span> (ost_idx &gt; 0xffff) {
<a name="l00665"></a>00665                 CERROR(<span class="stringliteral">&quot;bad ost_idx, &quot;</span>DOSTID<span class="stringliteral">&quot; ost_idx:%u\n&quot;</span>, POSTID(ostid),
<a name="l00666"></a>00666                        ost_idx);
<a name="l00667"></a>00667                 <span class="keywordflow">return</span> -EBADF;
<a name="l00668"></a>00668         }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         <span class="keywordflow">if</span> (fid_seq_is_mdt0(seq)) {
<a name="l00671"></a>00671                 __u64 oid = ostid_id(ostid);
<a name="l00672"></a>00672 
<a name="l00673"></a>00673                 <span class="comment">/* This is a &quot;legacy&quot; (old 1.x/2.early) OST object in &quot;group 0&quot;</span>
<a name="l00674"></a>00674 <span class="comment">                 * that we map into the IDIF namespace.  It allows up to 2^48</span>
<a name="l00675"></a>00675 <span class="comment">                 * objects per OST, as this is the object namespace that has</span>
<a name="l00676"></a>00676 <span class="comment">                 * been in production for years.  This can handle create rates</span>
<a name="l00677"></a>00677 <span class="comment">                 * of 1M objects/s/OST for 9 years, or combinations thereof. */</span>
<a name="l00678"></a>00678                 <span class="keywordflow">if</span> (oid &gt;= IDIF_MAX_OID) {
<a name="l00679"></a>00679                         CERROR(<span class="stringliteral">&quot;bad MDT0 id(1), &quot;</span>DOSTID<span class="stringliteral">&quot; ost_idx:%u\n&quot;</span>,
<a name="l00680"></a>00680                                POSTID(ostid), ost_idx);
<a name="l00681"></a>00681                         <span class="keywordflow">return</span> -EBADF;
<a name="l00682"></a>00682                 }
<a name="l00683"></a>00683                 fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = fid_idif_seq(oid, ost_idx);
<a name="l00684"></a>00684                 <span class="comment">/* truncate to 32 bits by assignment */</span>
<a name="l00685"></a>00685                 fid-&gt;f_oid = oid;
<a name="l00686"></a>00686                 <span class="comment">/* in theory, not currently used */</span>
<a name="l00687"></a>00687                 fid-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = oid &gt;&gt; 48;
<a name="l00688"></a>00688         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (likely(!fid_seq_is_default(seq)))
<a name="l00689"></a>00689                 <span class="comment">/* if (fid_seq_is_idif(seq) || fid_seq_is_norm(seq)) */</span> {
<a name="l00690"></a>00690                 <span class="comment">/* This is either an IDIF object, which identifies objects</span>
<a name="l00691"></a>00691 <span class="comment">                 * across all OSTs, or a regular FID.  The IDIF namespace maps</span>
<a name="l00692"></a>00692 <span class="comment">                 * legacy OST objects into the FID namespace.  In both cases,</span>
<a name="l00693"></a>00693 <span class="comment">                 * we just pass the FID through, no conversion needed. */</span>
<a name="l00694"></a>00694                 <span class="keywordflow">if</span> (ostid-&gt;oi_fid.<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> != 0) {
<a name="l00695"></a>00695                         CERROR(<span class="stringliteral">&quot;bad MDT0 id(2), &quot;</span>DOSTID<span class="stringliteral">&quot; ost_idx:%u\n&quot;</span>,
<a name="l00696"></a>00696                                 POSTID(ostid), ost_idx);
<a name="l00697"></a>00697                         <span class="keywordflow">return</span> -EBADF;
<a name="l00698"></a>00698                 }
<a name="l00699"></a>00699                 *fid = ostid-&gt;oi_fid;
<a name="l00700"></a>00700         }
<a name="l00701"></a>00701 
<a name="l00702"></a>00702         <span class="keywordflow">return</span> 0;
<a name="l00703"></a>00703 }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 <span class="comment">/* pack any OST FID into an ostid (id/seq) for the wire/disk */</span>
<a name="l00706"></a>00706 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> fid_to_ostid(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *ostid)
<a name="l00707"></a>00707 {
<a name="l00708"></a>00708         <span class="keywordflow">if</span> (unlikely(fid_seq_is_igif(fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a>))) {
<a name="l00709"></a>00709                 CERROR(<span class="stringliteral">&quot;bad IGIF, &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>, PFID(fid));
<a name="l00710"></a>00710                 <span class="keywordflow">return</span> -EBADF;
<a name="l00711"></a>00711         }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713         <span class="keywordflow">if</span> (fid_is_idif(fid)) {
<a name="l00714"></a>00714                 ostid_set_seq_mdt0(ostid);
<a name="l00715"></a>00715                 ostid_set_id(ostid, fid_idif_id(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid), fid_oid(fid),
<a name="l00716"></a>00716                                                 fid_ver(fid)));
<a name="l00717"></a>00717         } <span class="keywordflow">else</span> {
<a name="l00718"></a>00718                 ostid-&gt;oi_fid = *fid;
<a name="l00719"></a>00719         }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         <span class="keywordflow">return</span> 0;
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="comment">/* Check whether the fid is for LAST_ID */</span>
<a name="l00725"></a>00725 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_last_id(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00726"></a>00726 {
<a name="l00727"></a>00727         <span class="keywordflow">return</span> fid_oid(fid) == 0 &amp;&amp; <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid) != FID_SEQ_UPDATE_LOG &amp;&amp;
<a name="l00728"></a>00728                <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid) != FID_SEQ_UPDATE_LOG_DIR;
<a name="l00729"></a>00729 }
<a name="l00730"></a>00730 
<a name="l00736"></a>00736 <span class="keyword">static</span> <span class="keyword">inline</span> ino_t lu_igif_ino(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00737"></a>00737 {
<a name="l00738"></a>00738         <span class="keywordflow">return</span> <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid);
<a name="l00739"></a>00739 }
<a name="l00740"></a>00740 
<a name="l00746"></a>00746 <span class="keyword">static</span> <span class="keyword">inline</span> __u32 lu_igif_gen(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00747"></a>00747 {
<a name="l00748"></a>00748         <span class="keywordflow">return</span> fid_oid(fid);
<a name="l00749"></a>00749 }
<a name="l00750"></a>00750 
<a name="l00754"></a>00754 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lu_igif_build(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, __u32 ino, __u32 gen)
<a name="l00755"></a>00755 {
<a name="l00756"></a>00756         fid-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = ino;
<a name="l00757"></a>00757         fid-&gt;f_oid = gen;
<a name="l00758"></a>00758         fid-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = 0;
<a name="l00759"></a>00759 }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 <span class="comment">/*</span>
<a name="l00762"></a>00762 <span class="comment"> * Fids are transmitted across network (in the sender byte-ordering),</span>
<a name="l00763"></a>00763 <span class="comment"> * and stored on disk in big-endian order.</span>
<a name="l00764"></a>00764 <span class="comment"> */</span>
<a name="l00765"></a>00765 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> fid_cpu_to_le(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *dst, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *src)
<a name="l00766"></a>00766 {
<a name="l00767"></a>00767         dst-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = cpu_to_le64(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(src));
<a name="l00768"></a>00768         dst-&gt;f_oid = cpu_to_le32(fid_oid(src));
<a name="l00769"></a>00769         dst-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = cpu_to_le32(fid_ver(src));
<a name="l00770"></a>00770 }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> fid_le_to_cpu(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *dst, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *src)
<a name="l00773"></a>00773 {
<a name="l00774"></a>00774         dst-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = le64_to_cpu(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(src));
<a name="l00775"></a>00775         dst-&gt;f_oid = le32_to_cpu(fid_oid(src));
<a name="l00776"></a>00776         dst-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = le32_to_cpu(fid_ver(src));
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> fid_cpu_to_be(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *dst, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *src)
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781         dst-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = cpu_to_be64(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(src));
<a name="l00782"></a>00782         dst-&gt;f_oid = cpu_to_be32(fid_oid(src));
<a name="l00783"></a>00783         dst-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = cpu_to_be32(fid_ver(src));
<a name="l00784"></a>00784 }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> fid_be_to_cpu(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *dst, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *src)
<a name="l00787"></a>00787 {
<a name="l00788"></a>00788         dst-&gt;<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = be64_to_cpu(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(src));
<a name="l00789"></a>00789         dst-&gt;f_oid = be32_to_cpu(fid_oid(src));
<a name="l00790"></a>00790         dst-&gt;<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = be32_to_cpu(fid_ver(src));
<a name="l00791"></a>00791 }
<a name="l00792"></a>00792 
<a name="l00793"></a>00793 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> fid_is_sane(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00794"></a>00794 {
<a name="l00795"></a>00795         <span class="keywordflow">return</span> fid != NULL &amp;&amp;
<a name="l00796"></a>00796                ((<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid) &gt;= FID_SEQ_START &amp;&amp; fid_ver(fid) == 0) ||
<a name="l00797"></a>00797                 fid_is_igif(fid) || fid_is_idif(fid) ||
<a name="l00798"></a>00798                 fid_seq_is_rsvd(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid)));
<a name="l00799"></a>00799 }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> lu_fid_eq(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *f0, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *f1)
<a name="l00802"></a>00802 {
<a name="l00803"></a>00803         <span class="keywordflow">return</span> memcmp(f0, f1, <span class="keyword">sizeof</span> *f0) == 0;
<a name="l00804"></a>00804 }
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <span class="preprocessor">#define __diff_normalize(val0, val1)                            \</span>
<a name="l00807"></a>00807 <span class="preprocessor">({                                                              \</span>
<a name="l00808"></a>00808 <span class="preprocessor">        typeof(val0) __val0 = (val0);                           \</span>
<a name="l00809"></a>00809 <span class="preprocessor">        typeof(val1) __val1 = (val1);                           \</span>
<a name="l00810"></a>00810 <span class="preprocessor">                                                                \</span>
<a name="l00811"></a>00811 <span class="preprocessor">        (__val0 == __val1 ? 0 : __val0 &gt; __val1 ? +1 : -1);     \</span>
<a name="l00812"></a>00812 <span class="preprocessor">})</span>
<a name="l00813"></a>00813 <span class="preprocessor"></span>
<a name="l00814"></a>00814 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lu_fid_cmp(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *f0,
<a name="l00815"></a>00815                              <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *f1)
<a name="l00816"></a>00816 {
<a name="l00817"></a>00817         <span class="keywordflow">return</span>
<a name="l00818"></a>00818                 __diff_normalize(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(f0), <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(f1)) ?:
<a name="l00819"></a>00819                 __diff_normalize(fid_oid(f0), fid_oid(f1)) ?:
<a name="l00820"></a>00820                 __diff_normalize(fid_ver(f0), fid_ver(f1));
<a name="l00821"></a>00821 }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ostid_cpu_to_le(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *src_oi,
<a name="l00824"></a>00824                                    <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *dst_oi)
<a name="l00825"></a>00825 {
<a name="l00826"></a>00826         <span class="keywordflow">if</span> (fid_seq_is_mdt0(src_oi-&gt;oi.oi_seq)) {
<a name="l00827"></a>00827                 dst_oi-&gt;oi.oi_id = cpu_to_le64(src_oi-&gt;oi.oi_id);
<a name="l00828"></a>00828                 dst_oi-&gt;oi.oi_seq = cpu_to_le64(src_oi-&gt;oi.oi_seq);
<a name="l00829"></a>00829         } <span class="keywordflow">else</span> {
<a name="l00830"></a>00830                 fid_cpu_to_le(&amp;dst_oi-&gt;oi_fid, &amp;src_oi-&gt;oi_fid);
<a name="l00831"></a>00831         }
<a name="l00832"></a>00832 }
<a name="l00833"></a>00833 
<a name="l00834"></a>00834 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ostid_le_to_cpu(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *src_oi,
<a name="l00835"></a>00835                                    <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *dst_oi)
<a name="l00836"></a>00836 {
<a name="l00837"></a>00837         <span class="keywordflow">if</span> (fid_seq_is_mdt0(src_oi-&gt;oi.oi_seq)) {
<a name="l00838"></a>00838                 dst_oi-&gt;oi.oi_id = le64_to_cpu(src_oi-&gt;oi.oi_id);
<a name="l00839"></a>00839                 dst_oi-&gt;oi.oi_seq = le64_to_cpu(src_oi-&gt;oi.oi_seq);
<a name="l00840"></a>00840         } <span class="keywordflow">else</span> {
<a name="l00841"></a>00841                 fid_le_to_cpu(&amp;dst_oi-&gt;oi_fid, &amp;src_oi-&gt;oi_fid);
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843 }
<a name="l00844"></a>00844 
<a name="l00845"></a><a class="code" href="structlu__orphan__rec.html">00845</a> <span class="keyword">struct </span><a class="code" href="structlu__orphan__rec.html">lu_orphan_rec</a> {
<a name="l00846"></a>00846         <span class="comment">/* The MDT-object&apos;s FID referenced by the orphan OST-object */</span>
<a name="l00847"></a>00847         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   lor_fid;
<a name="l00848"></a>00848         __u32           lor_uid;
<a name="l00849"></a>00849         __u32           lor_gid;
<a name="l00850"></a>00850 };
<a name="l00851"></a>00851 
<a name="l00852"></a><a class="code" href="structlu__orphan__ent.html">00852</a> <span class="keyword">struct </span><a class="code" href="structlu__orphan__ent.html">lu_orphan_ent</a> {
<a name="l00853"></a>00853         <span class="comment">/* The orphan OST-object&apos;s FID */</span>
<a name="l00854"></a>00854         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           loe_key;
<a name="l00855"></a>00855         <span class="keyword">struct </span><a class="code" href="structlu__orphan__rec.html">lu_orphan_rec</a>    loe_rec;
<a name="l00856"></a>00856 };
<a name="l00857"></a>00857 
<a name="l00869"></a><a class="code" href="group__lu__dir.html#gadf424fa0b5a6cfc7859f55b85f3548aa">00869</a> <span class="keyword">enum</span> <a class="code" href="group__lu__dir.html#gadf424fa0b5a6cfc7859f55b85f3548aa" title="Enumeration of possible directory entry attributes.">lu_dirent_attrs</a> {
<a name="l00870"></a>00870         LUDA_FID                = 0x0001,
<a name="l00871"></a>00871         LUDA_TYPE               = 0x0002,
<a name="l00872"></a>00872         LUDA_64BITHASH          = 0x0004,
<a name="l00873"></a>00873 
<a name="l00874"></a>00874         <span class="comment">/* The following attrs are used for MDT internal only,</span>
<a name="l00875"></a>00875 <span class="comment">         * not visible to client */</span>
<a name="l00876"></a>00876 
<a name="l00877"></a>00877         <span class="comment">/* Something in the record is unknown, to be verified in further. */</span>
<a name="l00878"></a>00878         LUDA_UNKNOWN            = 0x0400,
<a name="l00879"></a>00879         <span class="comment">/* Ignore this record, go to next directly. */</span>
<a name="l00880"></a>00880         LUDA_IGNORE             = 0x0800,
<a name="l00881"></a>00881         <span class="comment">/* The system is upgraded, has beed or to be repaired (dryrun). */</span>
<a name="l00882"></a>00882         LUDA_UPGRADE            = 0x1000,
<a name="l00883"></a>00883         <span class="comment">/* The dirent has been repaired, or to be repaired (dryrun). */</span>
<a name="l00884"></a>00884         LUDA_REPAIR             = 0x2000,
<a name="l00885"></a>00885         <span class="comment">/* Only check but not repair the dirent inconsistency */</span>
<a name="l00886"></a>00886         LUDA_VERIFY_DRYRUN      = 0x4000,
<a name="l00887"></a>00887         <span class="comment">/* Verify the dirent consistency */</span>
<a name="l00888"></a>00888         LUDA_VERIFY             = 0x8000,
<a name="l00889"></a>00889 };
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 <span class="preprocessor">#define LU_DIRENT_ATTRS_MASK    0xff00</span>
<a name="l00892"></a>00892 <span class="preprocessor"></span>
<a name="l00896"></a><a class="code" href="structlu__dirent.html">00896</a> <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> {
<a name="l00898"></a><a class="code" href="structlu__dirent.html#a58764bd31894298ed7ab119d7a245308">00898</a>         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> <a class="code" href="structlu__dirent.html#a58764bd31894298ed7ab119d7a245308" title="valid if LUDA_FID is set.">lde_fid</a>;
<a name="l00900"></a><a class="code" href="structlu__dirent.html#a93db8cf242015f8192bd7263f8a50e2e">00900</a>         __u64         <a class="code" href="structlu__dirent.html#a93db8cf242015f8192bd7263f8a50e2e" title="a unique entry identifier: a hash or an offset.">lde_hash</a>;
<a name="l00902"></a><a class="code" href="structlu__dirent.html#a241bc48a83ebfb3219722f6a6afbe66a">00902</a>         __u16         <a class="code" href="structlu__dirent.html#a241bc48a83ebfb3219722f6a6afbe66a" title="total record length, including all attributes.">lde_reclen</a>;
<a name="l00904"></a><a class="code" href="structlu__dirent.html#a6cf011f9cdc36e619bad6e893a537c02">00904</a>         __u16         <a class="code" href="structlu__dirent.html#a6cf011f9cdc36e619bad6e893a537c02" title="name length">lde_namelen</a>;
<a name="l00908"></a><a class="code" href="structlu__dirent.html#af1fe2598c44bab695e849de0a2ca80dc">00908</a>         __u32         <a class="code" href="structlu__dirent.html#af1fe2598c44bab695e849de0a2ca80dc" title="optional variable size attributes following this entry.">lde_attrs</a>;
<a name="l00913"></a><a class="code" href="structlu__dirent.html#a3e3b5a552269757293891e23de373a3f">00913</a>         <span class="keywordtype">char</span>          <a class="code" href="structlu__dirent.html#a3e3b5a552269757293891e23de373a3f" title="name is followed by the attributes indicated in -&amp;gt;ldp_attrs, in their natural...">lde_name</a>[0];
<a name="l00914"></a>00914 };
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 <span class="comment">/*</span>
<a name="l00917"></a>00917 <span class="comment"> * Definitions of optional directory entry attributes formats.</span>
<a name="l00918"></a>00918 <span class="comment"> *</span>
<a name="l00919"></a>00919 <span class="comment"> * Individual attributes do not have their length encoded in a generic way. It</span>
<a name="l00920"></a>00920 <span class="comment"> * is assumed that consumer of an attribute knows its format. This means that</span>
<a name="l00921"></a>00921 <span class="comment"> * it is impossible to skip over an unknown attribute, except by skipping over all</span>
<a name="l00922"></a>00922 <span class="comment"> * remaining attributes (by using -&gt;lde_reclen), which is not too</span>
<a name="l00923"></a>00923 <span class="comment"> * constraining, because new server versions will append new attributes at</span>
<a name="l00924"></a>00924 <span class="comment"> * the end of an entry.</span>
<a name="l00925"></a>00925 <span class="comment"> */</span>
<a name="l00926"></a>00926 
<a name="l00933"></a>00933 <span class="comment">/* To have compatibility with 1.8, lets have fid in lu_dirent struct. */</span>
<a name="l00934"></a>00934 
<a name="l00940"></a><a class="code" href="structluda__type.html">00940</a> <span class="keyword">struct </span><a class="code" href="structluda__type.html" title="Fid directory attribute: a fid of an object referenced by the entry.">luda_type</a> {
<a name="l00941"></a>00941         __u16 lt_type;
<a name="l00942"></a>00942 };
<a name="l00943"></a>00943 
<a name="l00944"></a><a class="code" href="structlu__dirpage.html">00944</a> <span class="keyword">struct </span><a class="code" href="structlu__dirpage.html">lu_dirpage</a> {
<a name="l00945"></a>00945         __u64            ldp_hash_start;
<a name="l00946"></a>00946         __u64            ldp_hash_end;
<a name="l00947"></a>00947         __u32            ldp_flags;
<a name="l00948"></a>00948         __u32            ldp_pad0;
<a name="l00949"></a>00949         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> ldp_entries[0];
<a name="l00950"></a>00950 };
<a name="l00951"></a>00951 
<a name="l00952"></a><a class="code" href="group__lu__dir.html#ga8e36a5c3ab28f2a81a6a17c6397bffee">00952</a> <span class="keyword">enum</span> <a class="code" href="group__lu__dir.html#ga8e36a5c3ab28f2a81a6a17c6397bffee">lu_dirpage_flags</a> {
<a name="l00956"></a><a class="code" href="group__lu__dir.html#gga8e36a5c3ab28f2a81a6a17c6397bffeea02f7885580c8a3b030cac3515ff7e3b6">00956</a>         <a class="code" href="group__lu__dir.html#gga8e36a5c3ab28f2a81a6a17c6397bffeea02f7885580c8a3b030cac3515ff7e3b6" title="dirpage contains no entry.">LDF_EMPTY</a>   = 1 &lt;&lt; 0,
<a name="l00960"></a><a class="code" href="group__lu__dir.html#gga8e36a5c3ab28f2a81a6a17c6397bffeea2e5d9d6700b40d5386cd4a6597e74ab2">00960</a>         <a class="code" href="group__lu__dir.html#gga8e36a5c3ab28f2a81a6a17c6397bffeea2e5d9d6700b40d5386cd4a6597e74ab2" title="last entry&amp;#39;s lde_hash equals ldp_hash_end.">LDF_COLLIDE</a> = 1 &lt;&lt; 1
<a name="l00961"></a>00961 };
<a name="l00962"></a>00962 
<a name="l00963"></a>00963 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *lu_dirent_start(<span class="keyword">struct</span> <a class="code" href="structlu__dirpage.html">lu_dirpage</a> *dp)
<a name="l00964"></a>00964 {
<a name="l00965"></a>00965         <span class="keywordflow">if</span> (le32_to_cpu(dp-&gt;ldp_flags) &amp; <a class="code" href="group__lu__dir.html#gga8e36a5c3ab28f2a81a6a17c6397bffeea02f7885580c8a3b030cac3515ff7e3b6" title="dirpage contains no entry.">LDF_EMPTY</a>)
<a name="l00966"></a>00966                 <span class="keywordflow">return</span> NULL;
<a name="l00967"></a>00967         <span class="keywordflow">else</span>
<a name="l00968"></a>00968                 <span class="keywordflow">return</span> dp-&gt;ldp_entries;
<a name="l00969"></a>00969 }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *lu_dirent_next(<span class="keyword">struct</span> <a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *ent)
<a name="l00972"></a>00972 {
<a name="l00973"></a>00973         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *next;
<a name="l00974"></a>00974 
<a name="l00975"></a>00975         <span class="keywordflow">if</span> (le16_to_cpu(ent-&gt;<a class="code" href="structlu__dirent.html#a241bc48a83ebfb3219722f6a6afbe66a" title="total record length, including all attributes.">lde_reclen</a>) != 0)
<a name="l00976"></a>00976                 next = ((<span class="keywordtype">void</span> *)ent) + le16_to_cpu(ent-&gt;<a class="code" href="structlu__dirent.html#a241bc48a83ebfb3219722f6a6afbe66a" title="total record length, including all attributes.">lde_reclen</a>);
<a name="l00977"></a>00977         <span class="keywordflow">else</span>
<a name="l00978"></a>00978                 next = NULL;
<a name="l00979"></a>00979 
<a name="l00980"></a>00980         <span class="keywordflow">return</span> next;
<a name="l00981"></a>00981 }
<a name="l00982"></a>00982 
<a name="l00983"></a>00983 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> lu_dirent_calc_size(<span class="keywordtype">size_t</span> namelen, __u16 attr)
<a name="l00984"></a>00984 {
<a name="l00985"></a>00985         <span class="keywordtype">size_t</span> size;
<a name="l00986"></a>00986 
<a name="l00987"></a>00987         <span class="keywordflow">if</span> (attr &amp; LUDA_TYPE) {
<a name="l00988"></a>00988                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> align = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structluda__type.html" title="Fid directory attribute: a fid of an object referenced by the entry.">luda_type</a>) - 1;
<a name="l00989"></a>00989                 size = (<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>) + namelen + align) &amp; ~align;
<a name="l00990"></a>00990                 size += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structluda__type.html" title="Fid directory attribute: a fid of an object referenced by the entry.">luda_type</a>);
<a name="l00991"></a>00991         } <span class="keywordflow">else</span>
<a name="l00992"></a>00992                 size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>) + namelen;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994         <span class="keywordflow">return</span> (size + 7) &amp; ~7;
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 <span class="preprocessor">#define MDS_DIR_END_OFF 0xfffffffffffffffeULL</span>
<a name="l00998"></a>00998 <span class="preprocessor"></span>
<a name="l01008"></a><a class="code" href="group__lu__dir.html#ga7606e5469f1ecc97b2ef8616d3023fbb">01008</a> <span class="preprocessor">#define LU_PAGE_SHIFT 12</span>
<a name="l01009"></a>01009 <span class="preprocessor"></span><span class="preprocessor">#define LU_PAGE_SIZE  (1UL &lt;&lt; LU_PAGE_SHIFT)</span>
<a name="l01010"></a>01010 <span class="preprocessor"></span><span class="preprocessor">#define LU_PAGE_MASK  (~(LU_PAGE_SIZE - 1))</span>
<a name="l01011"></a>01011 <span class="preprocessor"></span>
<a name="l01012"></a>01012 <span class="preprocessor">#define LU_PAGE_COUNT (1 &lt;&lt; (PAGE_CACHE_SHIFT - LU_PAGE_SHIFT))</span>
<a name="l01013"></a>01013 <span class="preprocessor"></span>
<a name="l01016"></a><a class="code" href="structlustre__handle.html">01016</a> <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> {
<a name="l01017"></a>01017         __u64 cookie;
<a name="l01018"></a>01018 };
<a name="l01019"></a>01019 <span class="preprocessor">#define DEAD_HANDLE_MAGIC 0xdeadbeefcafebabeULL</span>
<a name="l01020"></a>01020 <span class="preprocessor"></span>
<a name="l01021"></a>01021 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> lustre_handle_is_used(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lh)
<a name="l01022"></a>01022 {
<a name="l01023"></a>01023         <span class="keywordflow">return</span> lh-&gt;cookie != 0;
<a name="l01024"></a>01024 }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> lustre_handle_equal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lh1,
<a name="l01027"></a>01027                                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lh2)
<a name="l01028"></a>01028 {
<a name="l01029"></a>01029         <span class="keywordflow">return</span> lh1-&gt;cookie == lh2-&gt;cookie;
<a name="l01030"></a>01030 }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lustre_handle_copy(<span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *tgt,
<a name="l01033"></a>01033                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *src)
<a name="l01034"></a>01034 {
<a name="l01035"></a>01035         tgt-&gt;cookie = src-&gt;cookie;
<a name="l01036"></a>01036 }
<a name="l01037"></a>01037 
<a name="l01038"></a><a class="code" href="structlustre__handle__array.html">01038</a> <span class="keyword">struct </span><a class="code" href="structlustre__handle__array.html">lustre_handle_array</a> {
<a name="l01039"></a>01039         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            count;
<a name="l01040"></a>01040         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    handles[0];
<a name="l01041"></a>01041 };
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 <span class="comment">/* flags for lm_flags */</span>
<a name="l01044"></a>01044 <span class="preprocessor">#define MSGHDR_AT_SUPPORT               0x1</span>
<a name="l01045"></a>01045 <span class="preprocessor"></span><span class="preprocessor">#define MSGHDR_CKSUM_INCOMPAT18         0x2</span>
<a name="l01046"></a>01046 <span class="preprocessor"></span>
<a name="l01047"></a>01047 <span class="preprocessor">#define lustre_msg lustre_msg_v2</span>
<a name="l01048"></a>01048 <span class="preprocessor"></span><span class="comment">/* we depend on this structure to be 8-byte aligned */</span>
<a name="l01049"></a>01049 <span class="comment">/* this type is only endian-adjusted in lustre_unpack_msg() */</span>
<a name="l01050"></a><a class="code" href="structlustre__msg__v2.html">01050</a> <span class="keyword">struct </span><a class="code" href="structlustre__msg__v2.html">lustre_msg_v2</a> {
<a name="l01051"></a>01051         __u32 lm_bufcount;
<a name="l01052"></a>01052         __u32 lm_secflvr;
<a name="l01053"></a>01053         __u32 lm_magic;
<a name="l01054"></a>01054         __u32 lm_repsize;
<a name="l01055"></a>01055         __u32 lm_cksum;
<a name="l01056"></a>01056         __u32 lm_flags;
<a name="l01057"></a>01057         __u32 lm_padding_2;
<a name="l01058"></a>01058         __u32 lm_padding_3;
<a name="l01059"></a>01059         __u32 lm_buflens[0];
<a name="l01060"></a>01060 };
<a name="l01061"></a>01061 
<a name="l01062"></a>01062 <span class="comment">/* without gss, ptlrpc_body is put at the first buffer. */</span>
<a name="l01063"></a>01063 <span class="preprocessor">#define PTLRPC_NUM_VERSIONS     4</span>
<a name="l01064"></a><a class="code" href="structptlrpc__body__v3.html">01064</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structptlrpc__body__v3.html">ptlrpc_body_v3</a> {
<a name="l01065"></a>01065         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> pb_handle;
<a name="l01066"></a>01066         __u32 pb_type;
<a name="l01067"></a>01067         __u32 pb_version;
<a name="l01068"></a>01068         __u32 pb_opc;
<a name="l01069"></a>01069         __u32 pb_status;
<a name="l01070"></a>01070         __u64 pb_last_xid; <span class="comment">/* highest replied XID without lower unreplied XID */</span>
<a name="l01071"></a>01071         __u16 pb_tag;      <span class="comment">/* virtual slot idx for multiple modifying RPCs */</span>
<a name="l01072"></a>01072         __u16 pb_padding0;
<a name="l01073"></a>01073         __u32 pb_padding1;
<a name="l01074"></a>01074         __u64 pb_last_committed;
<a name="l01075"></a>01075         __u64 pb_transno;
<a name="l01076"></a>01076         __u32 pb_flags;
<a name="l01077"></a>01077         __u32 pb_op_flags;
<a name="l01078"></a>01078         __u32 pb_conn_cnt;
<a name="l01079"></a>01079         __u32 pb_timeout;  <span class="comment">/* for req, the deadline, for rep, the service est */</span>
<a name="l01080"></a>01080         __u32 pb_service_time; <span class="comment">/* for rep, actual service time */</span>
<a name="l01081"></a>01081         __u32 pb_limit;
<a name="l01082"></a>01082         __u64 pb_slv;
<a name="l01083"></a>01083         <span class="comment">/* VBR: pre-versions */</span>
<a name="l01084"></a>01084         __u64 pb_pre_versions[PTLRPC_NUM_VERSIONS];
<a name="l01085"></a><a class="code" href="structptlrpc__body__v3.html#a87b7dfbfeb3e9c39a10a2113e560f9c0">01085</a>         __u64 <a class="code" href="structptlrpc__body__v3.html#a87b7dfbfeb3e9c39a10a2113e560f9c0" title="match bits for bulk request">pb_mbits</a>; 
<a name="l01086"></a>01086         <span class="comment">/* padding for future needs */</span>
<a name="l01087"></a>01087         __u64 pb_padding64_0;
<a name="l01088"></a>01088         __u64 pb_padding64_1;
<a name="l01089"></a>01089         __u64 pb_padding64_2;
<a name="l01090"></a>01090         <span class="keywordtype">char</span>  pb_jobid[LUSTRE_JOBID_SIZE];
<a name="l01091"></a>01091 };
<a name="l01092"></a>01092 <span class="preprocessor">#define ptlrpc_body     ptlrpc_body_v3</span>
<a name="l01093"></a>01093 <span class="preprocessor"></span>
<a name="l01094"></a><a class="code" href="structptlrpc__body__v2.html">01094</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__body__v2.html">ptlrpc_body_v2</a> {
<a name="l01095"></a>01095         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> pb_handle;
<a name="l01096"></a>01096         __u32 pb_type;
<a name="l01097"></a>01097         __u32 pb_version;
<a name="l01098"></a>01098         __u32 pb_opc;
<a name="l01099"></a>01099         __u32 pb_status;
<a name="l01100"></a>01100         __u64 pb_last_xid; <span class="comment">/* highest replied XID without lower unreplied XID */</span>
<a name="l01101"></a>01101         __u16 pb_tag;      <span class="comment">/* virtual slot idx for multiple modifying RPCs */</span>
<a name="l01102"></a>01102         __u16 pb_padding0;
<a name="l01103"></a>01103         __u32 pb_padding1;
<a name="l01104"></a>01104         __u64 pb_last_committed;
<a name="l01105"></a>01105         __u64 pb_transno;
<a name="l01106"></a>01106         __u32 pb_flags;
<a name="l01107"></a>01107         __u32 pb_op_flags;
<a name="l01108"></a>01108         __u32 pb_conn_cnt;
<a name="l01109"></a>01109         __u32 pb_timeout;  <span class="comment">/* for req, the deadline, for rep, the service est */</span>
<a name="l01110"></a>01110         __u32 pb_service_time; <span class="comment">/* for rep, actual service time, also used for</span>
<a name="l01111"></a>01111 <span class="comment">                                  net_latency of req */</span>
<a name="l01112"></a>01112         __u32 pb_limit;
<a name="l01113"></a>01113         __u64 pb_slv;
<a name="l01114"></a>01114         <span class="comment">/* VBR: pre-versions */</span>
<a name="l01115"></a>01115         __u64 pb_pre_versions[PTLRPC_NUM_VERSIONS];
<a name="l01116"></a><a class="code" href="structptlrpc__body__v2.html#a29cf9d652892ce480416f228ce7a422a">01116</a>         __u64 <a class="code" href="structptlrpc__body__v2.html#a29cf9d652892ce480416f228ce7a422a" title="unused in V2">pb_mbits</a>; 
<a name="l01117"></a>01117         <span class="comment">/* padding for future needs */</span>
<a name="l01118"></a>01118         __u64 pb_padding64_0;
<a name="l01119"></a>01119         __u64 pb_padding64_1;
<a name="l01120"></a>01120         __u64 pb_padding64_2;
<a name="l01121"></a>01121 };
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="comment">/* message body offset for lustre_msg_v2 */</span>
<a name="l01124"></a>01124 <span class="comment">/* ptlrpc body offset in all request/reply messages */</span>
<a name="l01125"></a>01125 <span class="preprocessor">#define MSG_PTLRPC_BODY_OFF             0</span>
<a name="l01126"></a>01126 <span class="preprocessor"></span>
<a name="l01127"></a>01127 <span class="comment">/* normal request/reply message record offset */</span>
<a name="l01128"></a>01128 <span class="preprocessor">#define REQ_REC_OFF                     1</span>
<a name="l01129"></a>01129 <span class="preprocessor"></span><span class="preprocessor">#define REPLY_REC_OFF                   1</span>
<a name="l01130"></a>01130 <span class="preprocessor"></span>
<a name="l01131"></a>01131 <span class="comment">/* ldlm request message body offset */</span>
<a name="l01132"></a>01132 <span class="preprocessor">#define DLM_LOCKREQ_OFF                 1 </span><span class="comment">/* lockreq offset */</span>
<a name="l01133"></a>01133 <span class="preprocessor">#define DLM_REQ_REC_OFF                 2 </span><span class="comment">/* normal dlm request record offset */</span>
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 <span class="comment">/* ldlm intent lock message body offset */</span>
<a name="l01136"></a>01136 <span class="preprocessor">#define DLM_INTENT_IT_OFF               2 </span><span class="comment">/* intent lock it offset */</span>
<a name="l01137"></a>01137 <span class="preprocessor">#define DLM_INTENT_REC_OFF              3 </span><span class="comment">/* intent lock record offset */</span>
<a name="l01138"></a>01138 
<a name="l01139"></a>01139 <span class="comment">/* ldlm reply message body offset */</span>
<a name="l01140"></a>01140 <span class="preprocessor">#define DLM_LOCKREPLY_OFF               1 </span><span class="comment">/* lockrep offset */</span>
<a name="l01141"></a>01141 <span class="preprocessor">#define DLM_REPLY_REC_OFF               2 </span><span class="comment">/* reply record offset */</span>
<a name="l01142"></a>01142 
<a name="l01144"></a><a class="code" href="group__lustreidl.html#gafa5c71e7497acfe5dea4f5efd14ef8ec">01144</a> <span class="preprocessor">#define MSG_PTLRPC_HEADER_OFF           31</span>
<a name="l01145"></a>01145 <span class="preprocessor"></span>
<a name="l01146"></a>01146 <span class="comment">/* Flags that are operation-specific go in the top 16 bits. */</span>
<a name="l01147"></a>01147 <span class="preprocessor">#define MSG_OP_FLAG_MASK   0xffff0000</span>
<a name="l01148"></a>01148 <span class="preprocessor"></span><span class="preprocessor">#define MSG_OP_FLAG_SHIFT  16</span>
<a name="l01149"></a>01149 <span class="preprocessor"></span>
<a name="l01150"></a>01150 <span class="comment">/* Flags that apply to all requests are in the bottom 16 bits */</span>
<a name="l01151"></a>01151 <span class="preprocessor">#define MSG_GEN_FLAG_MASK     0x0000ffff</span>
<a name="l01152"></a>01152 <span class="preprocessor"></span><span class="preprocessor">#define MSG_LAST_REPLAY           0x0001</span>
<a name="l01153"></a>01153 <span class="preprocessor"></span><span class="preprocessor">#define MSG_RESENT                0x0002</span>
<a name="l01154"></a>01154 <span class="preprocessor"></span><span class="preprocessor">#define MSG_REPLAY                0x0004</span>
<a name="l01155"></a>01155 <span class="preprocessor"></span><span class="comment">/* #define MSG_AT_SUPPORT         0x0008</span>
<a name="l01156"></a>01156 <span class="comment"> * This was used in early prototypes of adaptive timeouts, and while there</span>
<a name="l01157"></a>01157 <span class="comment"> * shouldn&apos;t be any users of that code there also isn&apos;t a need for using this</span>
<a name="l01158"></a>01158 <span class="comment"> * bits. Defer usage until at least 1.10 to avoid potential conflict. */</span>
<a name="l01159"></a>01159 <span class="preprocessor">#define MSG_DELAY_REPLAY          0x0010</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span><span class="preprocessor">#define MSG_VERSION_REPLAY        0x0020</span>
<a name="l01161"></a>01161 <span class="preprocessor"></span><span class="preprocessor">#define MSG_REQ_REPLAY_DONE       0x0040</span>
<a name="l01162"></a>01162 <span class="preprocessor"></span><span class="preprocessor">#define MSG_LOCK_REPLAY_DONE      0x0080</span>
<a name="l01163"></a>01163 <span class="preprocessor"></span>
<a name="l01164"></a>01164 <span class="comment">/*</span>
<a name="l01165"></a>01165 <span class="comment"> * Flags for all connect opcodes (MDS_CONNECT, OST_CONNECT)</span>
<a name="l01166"></a>01166 <span class="comment"> */</span>
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <span class="preprocessor">#define MSG_CONNECT_RECOVERING  0x00000001</span>
<a name="l01169"></a>01169 <span class="preprocessor"></span><span class="preprocessor">#define MSG_CONNECT_RECONNECT   0x00000002</span>
<a name="l01170"></a>01170 <span class="preprocessor"></span><span class="preprocessor">#define MSG_CONNECT_REPLAYABLE  0x00000004</span>
<a name="l01171"></a>01171 <span class="preprocessor"></span><span class="comment">//#define MSG_CONNECT_PEER        0x8</span>
<a name="l01172"></a>01172 <span class="preprocessor">#define MSG_CONNECT_LIBCLIENT   0x00000010</span>
<a name="l01173"></a>01173 <span class="preprocessor"></span><span class="preprocessor">#define MSG_CONNECT_INITIAL     0x00000020</span>
<a name="l01174"></a>01174 <span class="preprocessor"></span><span class="preprocessor">#define MSG_CONNECT_ASYNC       0x00000040</span>
<a name="l01175"></a>01175 <span class="preprocessor"></span><span class="preprocessor">#define MSG_CONNECT_NEXT_VER    0x00000080 </span><span class="comment">/* use next version of lustre_msg */</span>
<a name="l01176"></a>01176 <span class="preprocessor">#define MSG_CONNECT_TRANSNO     0x00000100 </span><span class="comment">/* report transno */</span>
<a name="l01177"></a>01177 
<a name="l01178"></a>01178 <span class="comment">/* Connect flags */</span>
<a name="l01179"></a>01179 <span class="preprocessor">#define OBD_CONNECT_RDONLY                0x1ULL </span><span class="comment">/*client has read-only access*/</span>
<a name="l01180"></a>01180 <span class="preprocessor">#define OBD_CONNECT_INDEX                 0x2ULL </span><span class="comment">/*connect specific LOV idx */</span>
<a name="l01181"></a>01181 <span class="preprocessor">#define OBD_CONNECT_MDS                   0x4ULL </span><span class="comment">/*connect from MDT to OST */</span>
<a name="l01182"></a>01182 <span class="preprocessor">#define OBD_CONNECT_GRANT                 0x8ULL </span><span class="comment">/*OSC gets grant at connect */</span>
<a name="l01183"></a>01183 <span class="preprocessor">#define OBD_CONNECT_SRVLOCK              0x10ULL </span><span class="comment">/*server takes locks for cli */</span>
<a name="l01184"></a>01184 <span class="preprocessor">#define OBD_CONNECT_VERSION              0x20ULL </span><span class="comment">/*Lustre versions in ocd */</span>
<a name="l01185"></a>01185 <span class="preprocessor">#define OBD_CONNECT_REQPORTAL            0x40ULL </span><span class="comment">/*Separate non-IO req portal */</span>
<a name="l01186"></a>01186 <span class="preprocessor">#define OBD_CONNECT_ACL                  0x80ULL </span><span class="comment">/*access control lists */</span>
<a name="l01187"></a>01187 <span class="preprocessor">#define OBD_CONNECT_XATTR               0x100ULL </span><span class="comment">/*client use extended attr */</span>
<a name="l01188"></a>01188 <span class="preprocessor">#define OBD_CONNECT_CROW                0x200ULL </span><span class="comment">/*MDS+OST create obj on write*/</span>
<a name="l01189"></a>01189 <span class="preprocessor">#define OBD_CONNECT_TRUNCLOCK           0x400ULL </span><span class="comment">/*locks on server for punch */</span>
<a name="l01190"></a>01190 <span class="preprocessor">#define OBD_CONNECT_TRANSNO             0x800ULL </span><span class="comment">/*replay sends init transno */</span>
<a name="l01191"></a>01191 <span class="preprocessor">#define OBD_CONNECT_IBITS              0x1000ULL </span><span class="comment">/*support for inodebits locks*/</span>
<a name="l01192"></a>01192 <span class="preprocessor">#define OBD_CONNECT_JOIN               0x2000ULL </span><span class="comment">/*files can be concatenated.</span>
<a name="l01193"></a>01193 <span class="comment">                                                  *We do not support JOIN FILE</span>
<a name="l01194"></a>01194 <span class="comment">                                                  *anymore, reserve this flags</span>
<a name="l01195"></a>01195 <span class="comment">                                                  *just for preventing such bit</span>
<a name="l01196"></a>01196 <span class="comment">                                                  *to be reused.*/</span>
<a name="l01197"></a>01197 <span class="preprocessor">#define OBD_CONNECT_ATTRFID            0x4000ULL </span><span class="comment">/*Server can GetAttr By Fid*/</span>
<a name="l01198"></a>01198 <span class="preprocessor">#define OBD_CONNECT_NODEVOH            0x8000ULL </span><span class="comment">/*No open hndl on specl nodes*/</span>
<a name="l01199"></a>01199 <span class="preprocessor">#define OBD_CONNECT_RMT_CLIENT        0x10000ULL </span><span class="comment">/*Remote client */</span>
<a name="l01200"></a>01200 <span class="preprocessor">#define OBD_CONNECT_RMT_CLIENT_FORCE  0x20000ULL </span><span class="comment">/*Remote client by force */</span>
<a name="l01201"></a>01201 <span class="preprocessor">#define OBD_CONNECT_BRW_SIZE          0x40000ULL </span><span class="comment">/*Max bytes per rpc */</span>
<a name="l01202"></a>01202 <span class="preprocessor">#define OBD_CONNECT_QUOTA64           0x80000ULL </span><span class="comment">/*Not used since 2.4 */</span>
<a name="l01203"></a>01203 <span class="preprocessor">#define OBD_CONNECT_MDS_CAPA         0x100000ULL </span><span class="comment">/*MDS capability */</span>
<a name="l01204"></a>01204 <span class="preprocessor">#define OBD_CONNECT_OSS_CAPA         0x200000ULL </span><span class="comment">/*OSS capability */</span>
<a name="l01205"></a>01205 <span class="preprocessor">#define OBD_CONNECT_CANCELSET        0x400000ULL </span><span class="comment">/*Early batched cancels. */</span>
<a name="l01206"></a>01206 <span class="preprocessor">#define OBD_CONNECT_SOM              0x800000ULL </span><span class="comment">/*Size on MDS */</span>
<a name="l01207"></a>01207 <span class="preprocessor">#define OBD_CONNECT_AT              0x1000000ULL </span><span class="comment">/*client uses AT */</span>
<a name="l01208"></a>01208 <span class="preprocessor">#define OBD_CONNECT_LRU_RESIZE      0x2000000ULL </span><span class="comment">/*LRU resize feature. */</span>
<a name="l01209"></a>01209 <span class="preprocessor">#define OBD_CONNECT_MDS_MDS         0x4000000ULL </span><span class="comment">/*MDS-MDS connection */</span>
<a name="l01210"></a>01210 <span class="preprocessor">#define OBD_CONNECT_REAL            0x8000000ULL </span><span class="comment">/*real connection */</span>
<a name="l01211"></a>01211 <span class="preprocessor">#define OBD_CONNECT_CHANGE_QS      0x10000000ULL </span><span class="comment">/*Not used since 2.4 */</span>
<a name="l01212"></a>01212 <span class="preprocessor">#define OBD_CONNECT_CKSUM          0x20000000ULL </span><span class="comment">/*support several cksum algos*/</span>
<a name="l01213"></a>01213 <span class="preprocessor">#define OBD_CONNECT_FID            0x40000000ULL </span><span class="comment">/*FID is supported by server */</span>
<a name="l01214"></a>01214 <span class="preprocessor">#define OBD_CONNECT_VBR            0x80000000ULL </span><span class="comment">/*version based recovery */</span>
<a name="l01215"></a>01215 <span class="preprocessor">#define OBD_CONNECT_LOV_V3        0x100000000ULL </span><span class="comment">/*client supports LOV v3 EA */</span>
<a name="l01216"></a>01216 <span class="preprocessor">#define OBD_CONNECT_GRANT_SHRINK  0x200000000ULL </span><span class="comment">/* support grant shrink */</span>
<a name="l01217"></a>01217 <span class="preprocessor">#define OBD_CONNECT_SKIP_ORPHAN   0x400000000ULL </span><span class="comment">/* don&apos;t reuse orphan objids */</span>
<a name="l01218"></a>01218 <span class="preprocessor">#define OBD_CONNECT_MAX_EASIZE    0x800000000ULL </span><span class="comment">/* preserved for large EA */</span>
<a name="l01219"></a>01219 <span class="preprocessor">#define OBD_CONNECT_FULL20       0x1000000000ULL </span><span class="comment">/* it is 2.0 client */</span>
<a name="l01220"></a>01220 <span class="preprocessor">#define OBD_CONNECT_LAYOUTLOCK   0x2000000000ULL </span><span class="comment">/* client uses layout lock */</span>
<a name="l01221"></a>01221 <span class="preprocessor">#define OBD_CONNECT_64BITHASH    0x4000000000ULL </span><span class="comment">/* client supports 64-bits</span>
<a name="l01222"></a>01222 <span class="comment">                                                  * directory hash */</span>
<a name="l01223"></a>01223 <span class="preprocessor">#define OBD_CONNECT_MAXBYTES     0x8000000000ULL </span><span class="comment">/* max stripe size */</span>
<a name="l01224"></a>01224 <span class="preprocessor">#define OBD_CONNECT_IMP_RECOV   0x10000000000ULL </span><span class="comment">/* imp recovery support */</span>
<a name="l01225"></a>01225 <span class="preprocessor">#define OBD_CONNECT_JOBSTATS    0x20000000000ULL </span><span class="comment">/* jobid in ptlrpc_body */</span>
<a name="l01226"></a>01226 <span class="preprocessor">#define OBD_CONNECT_UMASK       0x40000000000ULL </span><span class="comment">/* create uses client umask */</span>
<a name="l01227"></a>01227 <span class="preprocessor">#define OBD_CONNECT_EINPROGRESS 0x80000000000ULL </span><span class="comment">/* client handles -EINPROGRESS</span>
<a name="l01228"></a>01228 <span class="comment">                                                  * RPC error properly */</span>
<a name="l01229"></a>01229 <span class="preprocessor">#define OBD_CONNECT_GRANT_PARAM 0x100000000000ULL</span><span class="comment">/* extra grant params used for</span>
<a name="l01230"></a>01230 <span class="comment">                                                  * finer space reservation */</span>
<a name="l01231"></a>01231 <span class="preprocessor">#define OBD_CONNECT_FLOCK_OWNER 0x200000000000ULL </span><span class="comment">/* for the fixed 1.8</span>
<a name="l01232"></a>01232 <span class="comment">                                                   * policy and 2.x server */</span>
<a name="l01233"></a>01233 <span class="preprocessor">#define OBD_CONNECT_LVB_TYPE    0x400000000000ULL </span><span class="comment">/* variable type of LVB */</span>
<a name="l01234"></a>01234 <span class="preprocessor">#define OBD_CONNECT_NANOSEC_TIME 0x800000000000ULL </span><span class="comment">/* nanosecond timestamps */</span>
<a name="l01235"></a>01235 <span class="preprocessor">#define OBD_CONNECT_LIGHTWEIGHT 0x1000000000000ULL</span><span class="comment">/* lightweight connection */</span>
<a name="l01236"></a>01236 <span class="preprocessor">#define OBD_CONNECT_SHORTIO     0x2000000000000ULL</span><span class="comment">/* short io */</span>
<a name="l01237"></a>01237 <span class="preprocessor">#define OBD_CONNECT_PINGLESS    0x4000000000000ULL</span><span class="comment">/* pings not required */</span>
<a name="l01238"></a>01238 <span class="preprocessor">#define OBD_CONNECT_FLOCK_DEAD  0x8000000000000ULL</span><span class="comment">/* improved flock deadlock detection */</span>
<a name="l01239"></a>01239 <span class="preprocessor">#define OBD_CONNECT_DISP_STRIPE 0x10000000000000ULL</span><span class="comment">/* create stripe disposition*/</span>
<a name="l01240"></a>01240 <span class="preprocessor">#define OBD_CONNECT_OPEN_BY_FID 0x20000000000000ULL </span><span class="comment">/* open by fid won&apos;t pack</span>
<a name="l01241"></a>01241 <span class="comment">                                                       name in request */</span>
<a name="l01242"></a>01242 <span class="preprocessor">#define OBD_CONNECT_LFSCK      0x40000000000000ULL</span><span class="comment">/* support online LFSCK */</span>
<a name="l01243"></a>01243 <span class="preprocessor">#define OBD_CONNECT_UNLINK_CLOSE 0x100000000000000ULL</span><span class="comment">/* close file in unlink */</span>
<a name="l01244"></a>01244 <span class="preprocessor">#define OBD_CONNECT_MULTIMODRPCS 0x200000000000000ULL </span><span class="comment">/* support multiple modify</span>
<a name="l01245"></a>01245 <span class="comment">                                                         RPCs in parallel */</span>
<a name="l01246"></a>01246 <span class="preprocessor">#define OBD_CONNECT_DIR_STRIPE   0x400000000000000ULL </span><span class="comment">/* striped DNE dir */</span>
<a name="l01247"></a>01247 <span class="preprocessor">#define OBD_CONNECT_SUBTREE     0x800000000000000ULL </span><span class="comment">/* fileset mount */</span>
<a name="l01248"></a>01248 <span class="preprocessor">#define OBD_CONNECT_LOCK_AHEAD   0x1000000000000000ULL </span><span class="comment">/* lock ahead */</span>
<a name="l01249"></a>01249 
<a name="l01250"></a><a class="code" href="group__lustreidl.html#ga456effb777dd41a46a6288fd71193f5c">01250</a> <span class="preprocessor">#define OBD_CONNECT_BULK_MBITS   0x2000000000000000ULL</span>
<a name="l01251"></a>01251 <span class="preprocessor"></span><span class="preprocessor">#define OBD_CONNECT_OBDOPACK     0x4000000000000000ULL </span><span class="comment">/* compact OUT obdo */</span>
<a name="l01252"></a>01252 <span class="preprocessor">#define OBD_CONNECT_FLAGS2       0x8000000000000000ULL </span><span class="comment">/* second flags word */</span>
<a name="l01253"></a>01253 <span class="comment">/* XXX README XXX:</span>
<a name="l01254"></a>01254 <span class="comment"> * Please DO NOT add flag values here before first ensuring that this same</span>
<a name="l01255"></a>01255 <span class="comment"> * flag value is not in use on some other branch.  Please clear any such</span>
<a name="l01256"></a>01256 <span class="comment"> * changes with senior engineers before starting to use a new flag.  Then,</span>
<a name="l01257"></a>01257 <span class="comment"> * submit a small patch against EVERY branch that ONLY adds the new flag,</span>
<a name="l01258"></a>01258 <span class="comment"> * updates obd_connect_names[] for lprocfs_rd_connect_flags(), adds the</span>
<a name="l01259"></a>01259 <span class="comment"> * flag to check_obd_connect_data(), and updates wiretests accordingly, so it</span>
<a name="l01260"></a>01260 <span class="comment"> * can be approved and landed easily to reserve the flag for future use. */</span>
<a name="l01261"></a>01261 
<a name="l01262"></a>01262 <span class="comment">/* The MNE_SWAB flag is overloading the MDS_MDS bit only for the MGS</span>
<a name="l01263"></a>01263 <span class="comment"> * connection.  It is a temporary bug fix for Imperative Recovery interop</span>
<a name="l01264"></a>01264 <span class="comment"> * between 2.2 and 2.3 x86/ppc nodes, and can be removed when interop for</span>
<a name="l01265"></a>01265 <span class="comment"> * 2.2 clients/servers is no longer needed.  LU-1252/LU-1644. */</span>
<a name="l01266"></a>01266 <span class="preprocessor">#define OBD_CONNECT_MNE_SWAB             OBD_CONNECT_MDS_MDS</span>
<a name="l01267"></a>01267 <span class="preprocessor"></span>
<a name="l01268"></a>01268 <span class="preprocessor">#define OCD_HAS_FLAG(ocd, flg)  \</span>
<a name="l01269"></a>01269 <span class="preprocessor">        (!!((ocd)-&gt;ocd_connect_flags &amp; OBD_CONNECT_##flg))</span>
<a name="l01270"></a>01270 <span class="preprocessor"></span>
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 <span class="preprocessor">#ifdef HAVE_LRU_RESIZE_SUPPORT</span>
<a name="l01273"></a>01273 <span class="preprocessor"></span><span class="preprocessor">#define LRU_RESIZE_CONNECT_FLAG OBD_CONNECT_LRU_RESIZE</span>
<a name="l01274"></a>01274 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01275"></a>01275 <span class="preprocessor"></span><span class="preprocessor">#define LRU_RESIZE_CONNECT_FLAG 0</span>
<a name="l01276"></a>01276 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01277"></a>01277 <span class="preprocessor"></span>
<a name="l01278"></a>01278 <span class="preprocessor">#define MDT_CONNECT_SUPPORTED  (OBD_CONNECT_RDONLY | OBD_CONNECT_VERSION | \</span>
<a name="l01279"></a>01279 <span class="preprocessor">                                OBD_CONNECT_ACL | OBD_CONNECT_XATTR | \</span>
<a name="l01280"></a>01280 <span class="preprocessor">                                OBD_CONNECT_IBITS | \</span>
<a name="l01281"></a>01281 <span class="preprocessor">                                OBD_CONNECT_NODEVOH | OBD_CONNECT_ATTRFID | \</span>
<a name="l01282"></a>01282 <span class="preprocessor">                                OBD_CONNECT_CANCELSET | OBD_CONNECT_AT | \</span>
<a name="l01283"></a>01283 <span class="preprocessor">                                OBD_CONNECT_RMT_CLIENT | \</span>
<a name="l01284"></a>01284 <span class="preprocessor">                                OBD_CONNECT_RMT_CLIENT_FORCE | \</span>
<a name="l01285"></a>01285 <span class="preprocessor">                                OBD_CONNECT_BRW_SIZE | OBD_CONNECT_MDS_MDS | \</span>
<a name="l01286"></a>01286 <span class="preprocessor">                                OBD_CONNECT_FID | LRU_RESIZE_CONNECT_FLAG | \</span>
<a name="l01287"></a>01287 <span class="preprocessor">                                OBD_CONNECT_VBR | OBD_CONNECT_LOV_V3 | \</span>
<a name="l01288"></a>01288 <span class="preprocessor">                                OBD_CONNECT_FULL20 | \</span>
<a name="l01289"></a>01289 <span class="preprocessor">                                OBD_CONNECT_64BITHASH | OBD_CONNECT_JOBSTATS | \</span>
<a name="l01290"></a>01290 <span class="preprocessor">                                OBD_CONNECT_EINPROGRESS | \</span>
<a name="l01291"></a>01291 <span class="preprocessor">                                OBD_CONNECT_LIGHTWEIGHT | OBD_CONNECT_UMASK | \</span>
<a name="l01292"></a>01292 <span class="preprocessor">                                OBD_CONNECT_LVB_TYPE | OBD_CONNECT_LAYOUTLOCK |\</span>
<a name="l01293"></a>01293 <span class="preprocessor">                                OBD_CONNECT_PINGLESS | OBD_CONNECT_MAX_EASIZE |\</span>
<a name="l01294"></a>01294 <span class="preprocessor">                                OBD_CONNECT_FLOCK_DEAD | \</span>
<a name="l01295"></a>01295 <span class="preprocessor">                                OBD_CONNECT_DISP_STRIPE | OBD_CONNECT_LFSCK | \</span>
<a name="l01296"></a>01296 <span class="preprocessor">                                OBD_CONNECT_OPEN_BY_FID | \</span>
<a name="l01297"></a>01297 <span class="preprocessor">                                OBD_CONNECT_DIR_STRIPE | \</span>
<a name="l01298"></a>01298 <span class="preprocessor">                                OBD_CONNECT_BULK_MBITS | \</span>
<a name="l01299"></a>01299 <span class="preprocessor">                                OBD_CONNECT_MULTIMODRPCS | \</span>
<a name="l01300"></a>01300 <span class="preprocessor">                                OBD_CONNECT_SUBTREE)</span>
<a name="l01301"></a>01301 <span class="preprocessor"></span>
<a name="l01302"></a>01302 <span class="preprocessor">#define OST_CONNECT_SUPPORTED  (OBD_CONNECT_SRVLOCK | OBD_CONNECT_GRANT | \</span>
<a name="l01303"></a>01303 <span class="preprocessor">                                OBD_CONNECT_REQPORTAL | OBD_CONNECT_VERSION | \</span>
<a name="l01304"></a>01304 <span class="preprocessor">                                OBD_CONNECT_TRUNCLOCK | OBD_CONNECT_INDEX | \</span>
<a name="l01305"></a>01305 <span class="preprocessor">                                OBD_CONNECT_BRW_SIZE | \</span>
<a name="l01306"></a>01306 <span class="preprocessor">                                OBD_CONNECT_CANCELSET | OBD_CONNECT_AT | \</span>
<a name="l01307"></a>01307 <span class="preprocessor">                                LRU_RESIZE_CONNECT_FLAG | OBD_CONNECT_CKSUM | \</span>
<a name="l01308"></a>01308 <span class="preprocessor">                                OBD_CONNECT_RMT_CLIENT | \</span>
<a name="l01309"></a>01309 <span class="preprocessor">                                OBD_CONNECT_RMT_CLIENT_FORCE | OBD_CONNECT_VBR | \</span>
<a name="l01310"></a>01310 <span class="preprocessor">                                OBD_CONNECT_MDS | OBD_CONNECT_SKIP_ORPHAN | \</span>
<a name="l01311"></a>01311 <span class="preprocessor">                                OBD_CONNECT_GRANT_SHRINK | OBD_CONNECT_FULL20 | \</span>
<a name="l01312"></a>01312 <span class="preprocessor">                                OBD_CONNECT_64BITHASH | OBD_CONNECT_MAXBYTES | \</span>
<a name="l01313"></a>01313 <span class="preprocessor">                                OBD_CONNECT_MAX_EASIZE | \</span>
<a name="l01314"></a>01314 <span class="preprocessor">                                OBD_CONNECT_EINPROGRESS | \</span>
<a name="l01315"></a>01315 <span class="preprocessor">                                OBD_CONNECT_JOBSTATS | \</span>
<a name="l01316"></a>01316 <span class="preprocessor">                                OBD_CONNECT_LIGHTWEIGHT | OBD_CONNECT_LVB_TYPE|\</span>
<a name="l01317"></a>01317 <span class="preprocessor">                                OBD_CONNECT_LAYOUTLOCK | OBD_CONNECT_FID | \</span>
<a name="l01318"></a>01318 <span class="preprocessor">                                OBD_CONNECT_PINGLESS | OBD_CONNECT_LFSCK | \</span>
<a name="l01319"></a>01319 <span class="preprocessor">                                OBD_CONNECT_BULK_MBITS | \</span>
<a name="l01320"></a>01320 <span class="preprocessor">                                OBD_CONNECT_GRANT_PARAM)</span>
<a name="l01321"></a>01321 <span class="preprocessor"></span><span class="preprocessor">#define ECHO_CONNECT_SUPPORTED (0)</span>
<a name="l01322"></a>01322 <span class="preprocessor"></span><span class="preprocessor">#define MGS_CONNECT_SUPPORTED  (OBD_CONNECT_VERSION | OBD_CONNECT_AT | \</span>
<a name="l01323"></a>01323 <span class="preprocessor">                                OBD_CONNECT_FULL20 | OBD_CONNECT_IMP_RECOV | \</span>
<a name="l01324"></a>01324 <span class="preprocessor">                                OBD_CONNECT_MNE_SWAB | OBD_CONNECT_PINGLESS |\</span>
<a name="l01325"></a>01325 <span class="preprocessor">                                OBD_CONNECT_BULK_MBITS)</span>
<a name="l01326"></a>01326 <span class="preprocessor"></span>
<a name="l01327"></a>01327 <span class="comment">/* Features required for this version of the client to work with server */</span>
<a name="l01328"></a>01328 <span class="preprocessor">#define CLIENT_CONNECT_MDT_REQD (OBD_CONNECT_IBITS | OBD_CONNECT_FID | \</span>
<a name="l01329"></a>01329 <span class="preprocessor">                                 OBD_CONNECT_FULL20)</span>
<a name="l01330"></a>01330 <span class="preprocessor"></span>
<a name="l01331"></a>01331 <span class="comment">/* This structure is used for both request and reply.</span>
<a name="l01332"></a>01332 <span class="comment"> *</span>
<a name="l01333"></a>01333 <span class="comment"> * If we eventually have separate connect data for different types, which we</span>
<a name="l01334"></a>01334 <span class="comment"> * almost certainly will, then perhaps we stick a union in here. */</span>
<a name="l01335"></a><a class="code" href="structobd__connect__data.html">01335</a> <span class="keyword">struct </span><a class="code" href="structobd__connect__data.html">obd_connect_data</a> {
<a name="l01336"></a>01336         __u64 ocd_connect_flags; <span class="comment">/* OBD_CONNECT_* per above */</span>
<a name="l01337"></a>01337         __u32 ocd_version;       <span class="comment">/* lustre release version number */</span>
<a name="l01338"></a>01338         __u32 ocd_grant;         <span class="comment">/* initial cache grant amount (bytes) */</span>
<a name="l01339"></a>01339         __u32 ocd_index;         <span class="comment">/* LOV index to connect to */</span>
<a name="l01340"></a>01340         __u32 ocd_brw_size;      <span class="comment">/* Maximum BRW size in bytes */</span>
<a name="l01341"></a>01341         __u64 ocd_ibits_known;   <span class="comment">/* inode bits this client understands */</span>
<a name="l01342"></a>01342         __u8  ocd_grant_blkbits; <span class="comment">/* log2 of the backend filesystem blocksize */</span>
<a name="l01343"></a>01343         __u8  ocd_grant_inobits; <span class="comment">/* log2 of the per-inode space consumption */</span>
<a name="l01344"></a>01344         __u16 ocd_grant_tax_kb;  <span class="comment">/* extent insertion overhead, in 1K blocks */</span>
<a name="l01345"></a>01345         __u32 ocd_grant_max_blks;<span class="comment">/* maximum number of blocks per extent */</span>
<a name="l01346"></a>01346         __u64 ocd_transno;       <span class="comment">/* first transno from client to be replayed */</span>
<a name="l01347"></a>01347         __u32 ocd_group;         <span class="comment">/* MDS group on OST */</span>
<a name="l01348"></a>01348         __u32 ocd_cksum_types;   <span class="comment">/* supported checksum algorithms */</span>
<a name="l01349"></a>01349         __u32 ocd_max_easize;    <span class="comment">/* How big LOV EA can be on MDS */</span>
<a name="l01350"></a>01350         __u32 ocd_instance;      <span class="comment">/* instance # of this target */</span>
<a name="l01351"></a>01351         __u64 ocd_maxbytes;      <span class="comment">/* Maximum stripe size in bytes */</span>
<a name="l01352"></a>01352         <span class="comment">/* Fields after ocd_maxbytes are only accessible by the receiver</span>
<a name="l01353"></a>01353 <span class="comment">         * if the corresponding flag in ocd_connect_flags is set. Accessing</span>
<a name="l01354"></a>01354 <span class="comment">         * any field after ocd_maxbytes on the receiver without a valid flag</span>
<a name="l01355"></a>01355 <span class="comment">         * may result in out-of-bound memory access and kernel oops. */</span>
<a name="l01356"></a>01356         __u16 ocd_maxmodrpcs;    <span class="comment">/* Maximum modify RPCs in parallel */</span>
<a name="l01357"></a>01357         __u16 padding0;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01358"></a>01358         __u32 padding1;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01359"></a>01359         __u64 ocd_connect_flags2;
<a name="l01360"></a>01360         __u64 padding3;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01361"></a>01361         __u64 padding4;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01362"></a>01362         __u64 padding5;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01363"></a>01363         __u64 padding6;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01364"></a>01364         __u64 padding7;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01365"></a>01365         __u64 padding8;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01366"></a>01366         __u64 padding9;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01367"></a>01367         __u64 paddingA;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01368"></a>01368         __u64 paddingB;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01369"></a>01369         __u64 paddingC;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01370"></a>01370         __u64 paddingD;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01371"></a>01371         __u64 paddingE;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01372"></a>01372         __u64 paddingF;          <span class="comment">/* added 2.1.0. also fix lustre_swab_connect */</span>
<a name="l01373"></a>01373 };
<a name="l01374"></a>01374 <span class="comment">/* XXX README XXX:</span>
<a name="l01375"></a>01375 <span class="comment"> * Please DO NOT use any fields here before first ensuring that this same</span>
<a name="l01376"></a>01376 <span class="comment"> * field is not in use on some other branch.  Please clear any such changes</span>
<a name="l01377"></a>01377 <span class="comment"> * with senior engineers before starting to use a new field.  Then, submit</span>
<a name="l01378"></a>01378 <span class="comment"> * a small patch against EVERY branch that ONLY adds the new field along with</span>
<a name="l01379"></a>01379 <span class="comment"> * the matching OBD_CONNECT flag, so that can be approved and landed easily to</span>
<a name="l01380"></a>01380 <span class="comment"> * reserve the flag for future use. */</span>
<a name="l01381"></a>01381 
<a name="l01382"></a>01382 <span class="comment">/*</span>
<a name="l01383"></a>01383 <span class="comment"> * Supported checksum algorithms. Up to 32 checksum types are supported.</span>
<a name="l01384"></a>01384 <span class="comment"> * (32-bit mask stored in obd_connect_data::ocd_cksum_types)</span>
<a name="l01385"></a>01385 <span class="comment"> * Please update DECLARE_CKSUM_NAME/OBD_CKSUM_ALL in obd.h when adding a new</span>
<a name="l01386"></a>01386 <span class="comment"> * algorithm and also the OBD_FL_CKSUM* flags.</span>
<a name="l01387"></a>01387 <span class="comment"> */</span>
<a name="l01388"></a>01388 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l01389"></a>01389         OBD_CKSUM_CRC32 = 0x00000001,
<a name="l01390"></a>01390         OBD_CKSUM_ADLER = 0x00000002,
<a name="l01391"></a>01391         OBD_CKSUM_CRC32C= 0x00000004,
<a name="l01392"></a>01392 } cksum_type_t;
<a name="l01393"></a>01393 
<a name="l01394"></a>01394 <span class="comment">/*</span>
<a name="l01395"></a>01395 <span class="comment"> *   OST requests: OBDO &amp; OBD request records</span>
<a name="l01396"></a>01396 <span class="comment"> */</span>
<a name="l01397"></a>01397 
<a name="l01398"></a>01398 <span class="comment">/* opcodes */</span>
<a name="l01399"></a>01399 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l01400"></a>01400         OST_REPLY      =  0,       <span class="comment">/* reply ? */</span>
<a name="l01401"></a>01401         OST_GETATTR    =  1,
<a name="l01402"></a>01402         OST_SETATTR    =  2,
<a name="l01403"></a>01403         OST_READ       =  3,
<a name="l01404"></a>01404         OST_WRITE      =  4,
<a name="l01405"></a>01405         OST_CREATE     =  5,
<a name="l01406"></a>01406         OST_DESTROY    =  6,
<a name="l01407"></a>01407         OST_GET_INFO   =  7,
<a name="l01408"></a>01408         OST_CONNECT    =  8,
<a name="l01409"></a>01409         OST_DISCONNECT =  9,
<a name="l01410"></a>01410         OST_PUNCH      = 10,
<a name="l01411"></a>01411         OST_OPEN       = 11,
<a name="l01412"></a>01412         OST_CLOSE      = 12,
<a name="l01413"></a>01413         OST_STATFS     = 13,
<a name="l01414"></a>01414         OST_SYNC       = 16,
<a name="l01415"></a>01415         OST_SET_INFO   = 17,
<a name="l01416"></a>01416         OST_QUOTACHECK = 18, <span class="comment">/* not used since 2.4 */</span>
<a name="l01417"></a>01417         OST_QUOTACTL   = 19,
<a name="l01418"></a>01418         OST_QUOTA_ADJUST_QUNIT = 20, <span class="comment">/* not used since 2.4 */</span>
<a name="l01419"></a>01419         OST_LADVISE    = 21,
<a name="l01420"></a>01420         OST_LAST_OPC <span class="comment">/* must be &lt; 33 to avoid MDS_GETATTR */</span>
<a name="l01421"></a>01421 } ost_cmd_t;
<a name="l01422"></a>01422 <span class="preprocessor">#define OST_FIRST_OPC  OST_REPLY</span>
<a name="l01423"></a>01423 <span class="preprocessor"></span>
<a name="l01424"></a>01424 <span class="keyword">enum</span> obdo_flags {
<a name="l01425"></a>01425         OBD_FL_INLINEDATA   = 0x00000001,
<a name="l01426"></a>01426         OBD_FL_OBDMDEXISTS  = 0x00000002,
<a name="l01427"></a>01427         OBD_FL_DELORPHAN    = 0x00000004, <span class="comment">/* if set in o_flags delete orphans */</span>
<a name="l01428"></a>01428         OBD_FL_NORPC        = 0x00000008, <span class="comment">/* set in o_flags do in OSC not OST */</span>
<a name="l01429"></a>01429         OBD_FL_IDONLY       = 0x00000010, <span class="comment">/* set in o_flags only adjust obj id*/</span>
<a name="l01430"></a>01430         OBD_FL_RECREATE_OBJS= 0x00000020, <span class="comment">/* recreate missing obj */</span>
<a name="l01431"></a>01431         OBD_FL_DEBUG_CHECK  = 0x00000040, <span class="comment">/* echo client/server debug check */</span>
<a name="l01432"></a>01432         OBD_FL_NO_USRQUOTA  = 0x00000100, <span class="comment">/* the object&apos;s owner is over quota */</span>
<a name="l01433"></a>01433         OBD_FL_NO_GRPQUOTA  = 0x00000200, <span class="comment">/* the object&apos;s group is over quota */</span>
<a name="l01434"></a>01434         OBD_FL_CREATE_CROW  = 0x00000400, <span class="comment">/* object should be create on write */</span>
<a name="l01435"></a>01435         OBD_FL_SRVLOCK      = 0x00000800, <span class="comment">/* delegate DLM locking to server */</span>
<a name="l01436"></a>01436         OBD_FL_CKSUM_CRC32  = 0x00001000, <span class="comment">/* CRC32 checksum type */</span>
<a name="l01437"></a>01437         OBD_FL_CKSUM_ADLER  = 0x00002000, <span class="comment">/* ADLER checksum type */</span>
<a name="l01438"></a>01438         OBD_FL_CKSUM_CRC32C = 0x00004000, <span class="comment">/* CRC32C checksum type */</span>
<a name="l01439"></a>01439         OBD_FL_CKSUM_RSVD2  = 0x00008000, <span class="comment">/* for future cksum types */</span>
<a name="l01440"></a>01440         OBD_FL_CKSUM_RSVD3  = 0x00010000, <span class="comment">/* for future cksum types */</span>
<a name="l01441"></a>01441         OBD_FL_SHRINK_GRANT = 0x00020000, <span class="comment">/* object shrink the grant */</span>
<a name="l01442"></a>01442         OBD_FL_MMAP         = 0x00040000, <span class="comment">/* object is mmapped on the client.</span>
<a name="l01443"></a>01443 <span class="comment">                                           * XXX: obsoleted - reserved for old</span>
<a name="l01444"></a>01444 <span class="comment">                                           * clients prior than 2.2 */</span>
<a name="l01445"></a>01445         OBD_FL_RECOV_RESEND = 0x00080000, <span class="comment">/* recoverable resent */</span>
<a name="l01446"></a>01446         OBD_FL_NOSPC_BLK    = 0x00100000, <span class="comment">/* no more block space on OST */</span>
<a name="l01447"></a>01447         OBD_FL_FLUSH        = 0x00200000, <span class="comment">/* flush pages on the OST */</span>
<a name="l01448"></a>01448         OBD_FL_SHORT_IO     = 0x00400000, <span class="comment">/* short io request */</span>
<a name="l01449"></a>01449 
<a name="l01450"></a>01450         <span class="comment">/* Note that while these checksum values are currently separate bits,</span>
<a name="l01451"></a>01451 <span class="comment">         * in 2.x we can actually allow all values from 1-31 if we wanted. */</span>
<a name="l01452"></a>01452         OBD_FL_CKSUM_ALL    = OBD_FL_CKSUM_CRC32 | OBD_FL_CKSUM_ADLER |
<a name="l01453"></a>01453                               OBD_FL_CKSUM_CRC32C,
<a name="l01454"></a>01454 
<a name="l01455"></a>01455         <span class="comment">/* mask for local-only flag, which won&apos;t be sent over network */</span>
<a name="l01456"></a>01456         OBD_FL_LOCAL_MASK   = 0xF0000000,
<a name="l01457"></a>01457 };
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 <span class="comment">/*</span>
<a name="l01460"></a>01460 <span class="comment"> * All LOV EA magics should have the same postfix, if some new version</span>
<a name="l01461"></a>01461 <span class="comment"> * Lustre instroduces new LOV EA magic, then when down-grade to an old</span>
<a name="l01462"></a>01462 <span class="comment"> * Lustre, even though the old version system does not recognizes such</span>
<a name="l01463"></a>01463 <span class="comment"> * new magic, it still can distinguish the corrupted cases by checking</span>
<a name="l01464"></a>01464 <span class="comment"> * the magic&apos;s postfix.</span>
<a name="l01465"></a>01465 <span class="comment"> */</span>
<a name="l01466"></a>01466 <span class="preprocessor">#define LOV_MAGIC_MAGIC 0x0BD0</span>
<a name="l01467"></a>01467 <span class="preprocessor"></span><span class="preprocessor">#define LOV_MAGIC_MASK  0xFFFF</span>
<a name="l01468"></a>01468 <span class="preprocessor"></span>
<a name="l01469"></a>01469 <span class="preprocessor">#define LOV_MAGIC_V1            (0x0BD10000 | LOV_MAGIC_MAGIC)</span>
<a name="l01470"></a>01470 <span class="preprocessor"></span><span class="preprocessor">#define LOV_MAGIC_JOIN_V1       (0x0BD20000 | LOV_MAGIC_MAGIC)</span>
<a name="l01471"></a>01471 <span class="preprocessor"></span><span class="preprocessor">#define LOV_MAGIC_V3            (0x0BD30000 | LOV_MAGIC_MAGIC)</span>
<a name="l01472"></a>01472 <span class="preprocessor"></span><span class="preprocessor">#define LOV_MAGIC_MIGRATE       (0x0BD40000 | LOV_MAGIC_MAGIC)</span>
<a name="l01473"></a>01473 <span class="preprocessor"></span><span class="comment">/* reserved for specifying OSTs */</span>
<a name="l01474"></a>01474 <span class="preprocessor">#define LOV_MAGIC_SPECIFIC      (0x0BD50000 | LOV_MAGIC_MAGIC)</span>
<a name="l01475"></a>01475 <span class="preprocessor"></span><span class="preprocessor">#define LOV_MAGIC               LOV_MAGIC_V1</span>
<a name="l01476"></a>01476 <span class="preprocessor"></span>
<a name="l01477"></a>01477 <span class="comment">/*</span>
<a name="l01478"></a>01478 <span class="comment"> * magic for fully defined striping</span>
<a name="l01479"></a>01479 <span class="comment"> * the idea is that we should have different magics for striping &quot;hints&quot;</span>
<a name="l01480"></a>01480 <span class="comment"> * (struct lov_user_md_v[13]) and defined ready-to-use striping (struct</span>
<a name="l01481"></a>01481 <span class="comment"> * lov_mds_md_v[13]). at the moment the magics are used in wire protocol,</span>
<a name="l01482"></a>01482 <span class="comment"> * we can&apos;t just change it w/o long way preparation, but we still need a</span>
<a name="l01483"></a>01483 <span class="comment"> * mechanism to allow LOD to differentiate hint versus ready striping.</span>
<a name="l01484"></a>01484 <span class="comment"> * so, at the moment we do a trick: MDT knows what to expect from request</span>
<a name="l01485"></a>01485 <span class="comment"> * depending on the case (replay uses ready striping, non-replay req uses</span>
<a name="l01486"></a>01486 <span class="comment"> * hints), so MDT replaces magic with appropriate one and now LOD can</span>
<a name="l01487"></a>01487 <span class="comment"> * easily understand what&apos;s inside -bzzz</span>
<a name="l01488"></a>01488 <span class="comment"> */</span>
<a name="l01489"></a>01489 <span class="preprocessor">#define LOV_MAGIC_V1_DEF  0x0CD10BD0</span>
<a name="l01490"></a>01490 <span class="preprocessor"></span><span class="preprocessor">#define LOV_MAGIC_V3_DEF  0x0CD30BD0</span>
<a name="l01491"></a>01491 <span class="preprocessor"></span>
<a name="l01492"></a>01492 <span class="preprocessor">#define lov_pattern(pattern)            (pattern &amp; ~LOV_PATTERN_F_MASK)</span>
<a name="l01493"></a>01493 <span class="preprocessor"></span><span class="preprocessor">#define lov_pattern_flags(pattern)      (pattern &amp; LOV_PATTERN_F_MASK)</span>
<a name="l01494"></a>01494 <span class="preprocessor"></span>
<a name="l01495"></a>01495 <span class="preprocessor">#define lov_ost_data lov_ost_data_v1</span>
<a name="l01496"></a><a class="code" href="structlov__ost__data__v1.html">01496</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structlov__ost__data__v1.html">lov_ost_data_v1</a> {          <span class="comment">/* per-stripe data structure (little-endian)*/</span>
<a name="l01497"></a>01497         <span class="keyword">struct </span><a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> l_ost_oi;   <span class="comment">/* OST object ID */</span>
<a name="l01498"></a>01498         __u32 l_ost_gen;          <span class="comment">/* generation of this l_ost_idx */</span>
<a name="l01499"></a>01499         __u32 l_ost_idx;          <span class="comment">/* OST index in LOV (lov_tgt_desc-&gt;tgts) */</span>
<a name="l01500"></a>01500 };
<a name="l01501"></a>01501 
<a name="l01502"></a>01502 <span class="preprocessor">#define lov_mds_md lov_mds_md_v1</span>
<a name="l01503"></a><a class="code" href="structlov__mds__md__v1.html">01503</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structlov__mds__md__v1.html">lov_mds_md_v1</a> {            <span class="comment">/* LOV EA mds/wire data (little-endian) */</span>
<a name="l01504"></a>01504         __u32 lmm_magic;          <span class="comment">/* magic number = LOV_MAGIC_V1 */</span>
<a name="l01505"></a>01505         __u32 lmm_pattern;        <span class="comment">/* LOV_PATTERN_RAID0, LOV_PATTERN_RAID1 */</span>
<a name="l01506"></a>01506         <span class="keyword">struct </span><a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a>   lmm_oi;   <span class="comment">/* LOV object ID */</span>
<a name="l01507"></a>01507         __u32 lmm_stripe_size;    <span class="comment">/* size of stripe in bytes */</span>
<a name="l01508"></a>01508         <span class="comment">/* lmm_stripe_count used to be __u32 */</span>
<a name="l01509"></a>01509         __u16 lmm_stripe_count;   <span class="comment">/* num stripes in use for this object */</span>
<a name="l01510"></a>01510         __u16 lmm_layout_gen;     <span class="comment">/* layout generation number */</span>
<a name="l01511"></a>01511         <span class="keyword">struct </span><a class="code" href="structlov__ost__data__v1.html">lov_ost_data_v1</a> lmm_objects[0]; <span class="comment">/* per-stripe data */</span>
<a name="l01512"></a>01512 };
<a name="l01513"></a>01513 
<a name="l01538"></a>01538 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> fid_to_lmm_oi(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l01539"></a>01539                                  <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi)
<a name="l01540"></a>01540 {
<a name="l01541"></a>01541         oi-&gt;oi.oi_id = fid_oid(fid);
<a name="l01542"></a>01542         oi-&gt;oi.oi_seq = <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid);
<a name="l01543"></a>01543 }
<a name="l01544"></a>01544 
<a name="l01545"></a>01545 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lmm_oi_set_seq(<span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi, __u64 seq)
<a name="l01546"></a>01546 {
<a name="l01547"></a>01547         oi-&gt;oi.oi_seq = seq;
<a name="l01548"></a>01548 }
<a name="l01549"></a>01549 
<a name="l01550"></a>01550 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lmm_oi_set_id(<span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi, __u64 oid)
<a name="l01551"></a>01551 {
<a name="l01552"></a>01552         oi-&gt;oi.oi_id = oid;
<a name="l01553"></a>01553 }
<a name="l01554"></a>01554 
<a name="l01555"></a>01555 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 lmm_oi_id(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi)
<a name="l01556"></a>01556 {
<a name="l01557"></a>01557         <span class="keywordflow">return</span> oi-&gt;oi.oi_id;
<a name="l01558"></a>01558 }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 lmm_oi_seq(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi)
<a name="l01561"></a>01561 {
<a name="l01562"></a>01562         <span class="keywordflow">return</span> oi-&gt;oi.oi_seq;
<a name="l01563"></a>01563 }
<a name="l01564"></a>01564 
<a name="l01565"></a>01565 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lmm_oi_le_to_cpu(<span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *dst_oi,
<a name="l01566"></a>01566                                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *src_oi)
<a name="l01567"></a>01567 {
<a name="l01568"></a>01568         dst_oi-&gt;oi.oi_id = le64_to_cpu(src_oi-&gt;oi.oi_id);
<a name="l01569"></a>01569         dst_oi-&gt;oi.oi_seq = le64_to_cpu(src_oi-&gt;oi.oi_seq);
<a name="l01570"></a>01570 }
<a name="l01571"></a>01571 
<a name="l01572"></a>01572 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> lmm_oi_cpu_to_le(<span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *dst_oi,
<a name="l01573"></a>01573                                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *src_oi)
<a name="l01574"></a>01574 {
<a name="l01575"></a>01575         dst_oi-&gt;oi.oi_id = cpu_to_le64(src_oi-&gt;oi.oi_id);
<a name="l01576"></a>01576         dst_oi-&gt;oi.oi_seq = cpu_to_le64(src_oi-&gt;oi.oi_seq);
<a name="l01577"></a>01577 }
<a name="l01578"></a>01578 
<a name="l01579"></a>01579 <span class="preprocessor">#define MAX_MD_SIZE (sizeof(struct lov_mds_md) + 4 * sizeof(struct lov_ost_data))</span>
<a name="l01580"></a>01580 <span class="preprocessor"></span><span class="preprocessor">#define MIN_MD_SIZE (sizeof(struct lov_mds_md) + 1 * sizeof(struct lov_ost_data))</span>
<a name="l01581"></a>01581 <span class="preprocessor"></span>
<a name="l01582"></a>01582 <span class="comment">/* This is the default MDT reply size allocated, should the striping be bigger,</span>
<a name="l01583"></a>01583 <span class="comment"> * it will be reallocated in mdt_fix_reply.</span>
<a name="l01584"></a>01584 <span class="comment"> * 100 stripes is a bit less than 2.5k of data */</span>
<a name="l01585"></a>01585 <span class="preprocessor">#define DEF_REP_MD_SIZE (sizeof(struct lov_mds_md) + \</span>
<a name="l01586"></a>01586 <span class="preprocessor">                         100 * sizeof(struct lov_ost_data))</span>
<a name="l01587"></a>01587 <span class="preprocessor"></span>
<a name="l01588"></a>01588 <span class="preprocessor">#define XATTR_NAME_ACL_ACCESS   &quot;system.posix_acl_access&quot;</span>
<a name="l01589"></a>01589 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_ACL_DEFAULT  &quot;system.posix_acl_default&quot;</span>
<a name="l01590"></a>01590 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_USER_PREFIX       &quot;user.&quot;</span>
<a name="l01591"></a>01591 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_TRUSTED_PREFIX    &quot;trusted.&quot;</span>
<a name="l01592"></a>01592 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_SECURITY_PREFIX   &quot;security.&quot;</span>
<a name="l01593"></a>01593 <span class="preprocessor"></span>
<a name="l01594"></a>01594 <span class="preprocessor">#define XATTR_NAME_LOV          &quot;trusted.lov&quot;</span>
<a name="l01595"></a>01595 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_LMA          &quot;trusted.lma&quot;</span>
<a name="l01596"></a>01596 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_LMV          &quot;trusted.lmv&quot;</span>
<a name="l01597"></a>01597 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_DEFAULT_LMV  &quot;trusted.dmv&quot;</span>
<a name="l01598"></a>01598 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_LINK         &quot;trusted.link&quot;</span>
<a name="l01599"></a>01599 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_FID          &quot;trusted.fid&quot;</span>
<a name="l01600"></a>01600 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_VERSION      &quot;trusted.version&quot;</span>
<a name="l01601"></a>01601 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_SOM          &quot;trusted.som&quot;</span>
<a name="l01602"></a>01602 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_HSM          &quot;trusted.hsm&quot;</span>
<a name="l01603"></a>01603 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_LFSCK_BITMAP &quot;trusted.lfsck_bitmap&quot;</span>
<a name="l01604"></a>01604 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_DUMMY        &quot;trusted.dummy&quot;</span>
<a name="l01605"></a>01605 <span class="preprocessor"></span>
<a name="l01606"></a>01606 <span class="preprocessor">#define XATTR_NAME_LFSCK_NAMESPACE &quot;trusted.lfsck_ns&quot;</span>
<a name="l01607"></a>01607 <span class="preprocessor"></span><span class="preprocessor">#define XATTR_NAME_MAX_LEN      32 </span><span class="comment">/* increase this, if there is longer name. */</span>
<a name="l01608"></a>01608 
<a name="l01609"></a><a class="code" href="structlov__mds__md__v3.html">01609</a> <span class="keyword">struct </span><a class="code" href="structlov__mds__md__v3.html">lov_mds_md_v3</a> {            <span class="comment">/* LOV EA mds/wire data (little-endian) */</span>
<a name="l01610"></a>01610         __u32 lmm_magic;          <span class="comment">/* magic number = LOV_MAGIC_V3 */</span>
<a name="l01611"></a>01611         __u32 lmm_pattern;        <span class="comment">/* LOV_PATTERN_RAID0, LOV_PATTERN_RAID1 */</span>
<a name="l01612"></a>01612         <span class="keyword">struct </span><a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a>   lmm_oi;   <span class="comment">/* LOV object ID */</span>
<a name="l01613"></a>01613         __u32 lmm_stripe_size;    <span class="comment">/* size of stripe in bytes */</span>
<a name="l01614"></a>01614         <span class="comment">/* lmm_stripe_count used to be __u32 */</span>
<a name="l01615"></a>01615         __u16 lmm_stripe_count;   <span class="comment">/* num stripes in use for this object */</span>
<a name="l01616"></a>01616         __u16 lmm_layout_gen;     <span class="comment">/* layout generation number */</span>
<a name="l01617"></a>01617         <span class="keywordtype">char</span>  lmm_pool_name[LOV_MAXPOOLNAME + 1]; <span class="comment">/* must be 32bit aligned */</span>
<a name="l01618"></a>01618         <span class="keyword">struct </span><a class="code" href="structlov__ost__data__v1.html">lov_ost_data_v1</a> lmm_objects[0]; <span class="comment">/* per-stripe data */</span>
<a name="l01619"></a>01619 };
<a name="l01620"></a>01620 
<a name="l01621"></a>01621 <span class="keyword">static</span> <span class="keyword">inline</span> __u32 lov_mds_md_size(__u16 stripes, __u32 lmm_magic)
<a name="l01622"></a>01622 {
<a name="l01623"></a>01623         <span class="keywordflow">if</span> (lmm_magic == LOV_MAGIC_V3)
<a name="l01624"></a>01624                 <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlov__mds__md__v3.html">lov_mds_md_v3</a>) +
<a name="l01625"></a>01625                                 stripes * <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlov__ost__data__v1.html">lov_ost_data_v1</a>);
<a name="l01626"></a>01626         <span class="keywordflow">else</span>
<a name="l01627"></a>01627                 <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlov__mds__md__v1.html">lov_mds_md_v1</a>) +
<a name="l01628"></a>01628                                 stripes * <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlov__ost__data__v1.html">lov_ost_data_v1</a>);
<a name="l01629"></a>01629 }
<a name="l01630"></a>01630 
<a name="l01631"></a>01631 <span class="keyword">static</span> <span class="keyword">inline</span> __u32
<a name="l01632"></a>01632 lov_mds_md_max_stripe_count(<span class="keywordtype">size_t</span> buf_size, __u32 lmm_magic)
<a name="l01633"></a>01633 {
<a name="l01634"></a>01634         <span class="keywordflow">switch</span> (lmm_magic) {
<a name="l01635"></a>01635         <span class="keywordflow">case</span> LOV_MAGIC_V1: {
<a name="l01636"></a>01636                 <span class="keyword">struct </span><a class="code" href="structlov__mds__md__v1.html">lov_mds_md_v1</a> lmm;
<a name="l01637"></a>01637 
<a name="l01638"></a>01638                 <span class="keywordflow">if</span> (buf_size &lt; <span class="keyword">sizeof</span>(lmm))
<a name="l01639"></a>01639                         <span class="keywordflow">return</span> 0;
<a name="l01640"></a>01640 
<a name="l01641"></a>01641                 <span class="keywordflow">return</span> (buf_size - <span class="keyword">sizeof</span>(lmm)) / <span class="keyword">sizeof</span>(lmm.lmm_objects[0]);
<a name="l01642"></a>01642         }
<a name="l01643"></a>01643         <span class="keywordflow">case</span> LOV_MAGIC_V3: {
<a name="l01644"></a>01644                 <span class="keyword">struct </span><a class="code" href="structlov__mds__md__v3.html">lov_mds_md_v3</a> lmm;
<a name="l01645"></a>01645 
<a name="l01646"></a>01646                 <span class="keywordflow">if</span> (buf_size &lt; <span class="keyword">sizeof</span>(lmm))
<a name="l01647"></a>01647                         <span class="keywordflow">return</span> 0;
<a name="l01648"></a>01648 
<a name="l01649"></a>01649                 <span class="keywordflow">return</span> (buf_size - <span class="keyword">sizeof</span>(lmm)) / <span class="keyword">sizeof</span>(lmm.lmm_objects[0]);
<a name="l01650"></a>01650         }
<a name="l01651"></a>01651         <span class="keywordflow">default</span>:
<a name="l01652"></a>01652                 <span class="keywordflow">return</span> 0;
<a name="l01653"></a>01653         }
<a name="l01654"></a>01654 }
<a name="l01655"></a>01655 
<a name="l01656"></a>01656 <span class="preprocessor">#define OBD_MD_FLID        (0x00000001ULL) </span><span class="comment">/* object ID */</span>
<a name="l01657"></a>01657 <span class="preprocessor">#define OBD_MD_FLATIME     (0x00000002ULL) </span><span class="comment">/* access time */</span>
<a name="l01658"></a>01658 <span class="preprocessor">#define OBD_MD_FLMTIME     (0x00000004ULL) </span><span class="comment">/* data modification time */</span>
<a name="l01659"></a>01659 <span class="preprocessor">#define OBD_MD_FLCTIME     (0x00000008ULL) </span><span class="comment">/* change time */</span>
<a name="l01660"></a>01660 <span class="preprocessor">#define OBD_MD_FLSIZE      (0x00000010ULL) </span><span class="comment">/* size */</span>
<a name="l01661"></a>01661 <span class="preprocessor">#define OBD_MD_FLBLOCKS    (0x00000020ULL) </span><span class="comment">/* allocated blocks count */</span>
<a name="l01662"></a>01662 <span class="preprocessor">#define OBD_MD_FLBLKSZ     (0x00000040ULL) </span><span class="comment">/* block size */</span>
<a name="l01663"></a>01663 <span class="preprocessor">#define OBD_MD_FLMODE      (0x00000080ULL) </span><span class="comment">/* access bits (mode &amp; ~S_IFMT) */</span>
<a name="l01664"></a>01664 <span class="preprocessor">#define OBD_MD_FLTYPE      (0x00000100ULL) </span><span class="comment">/* object type (mode &amp; S_IFMT) */</span>
<a name="l01665"></a>01665 <span class="preprocessor">#define OBD_MD_FLUID       (0x00000200ULL) </span><span class="comment">/* user ID */</span>
<a name="l01666"></a>01666 <span class="preprocessor">#define OBD_MD_FLGID       (0x00000400ULL) </span><span class="comment">/* group ID */</span>
<a name="l01667"></a>01667 <span class="preprocessor">#define OBD_MD_FLFLAGS     (0x00000800ULL) </span><span class="comment">/* flags word */</span>
<a name="l01668"></a>01668 <span class="preprocessor">#define OBD_MD_FLNLINK     (0x00002000ULL) </span><span class="comment">/* link count */</span>
<a name="l01669"></a>01669 <span class="preprocessor">#define OBD_MD_FLGENER     (0x00004000ULL) </span><span class="comment">/* generation number */</span>
<a name="l01670"></a>01670 <span class="comment">/*#define OBD_MD_FLINLINE    (0x00008000ULL)  inline data. used until 1.6.5 */</span>
<a name="l01671"></a>01671 <span class="preprocessor">#define OBD_MD_FLRDEV      (0x00010000ULL) </span><span class="comment">/* device number */</span>
<a name="l01672"></a>01672 <span class="preprocessor">#define OBD_MD_FLEASIZE    (0x00020000ULL) </span><span class="comment">/* extended attribute data */</span>
<a name="l01673"></a>01673 <span class="preprocessor">#define OBD_MD_LINKNAME    (0x00040000ULL) </span><span class="comment">/* symbolic link target */</span>
<a name="l01674"></a>01674 <span class="preprocessor">#define OBD_MD_FLHANDLE    (0x00080000ULL) </span><span class="comment">/* file/lock handle */</span>
<a name="l01675"></a>01675 <span class="preprocessor">#define OBD_MD_FLCKSUM     (0x00100000ULL) </span><span class="comment">/* bulk data checksum */</span>
<a name="l01676"></a>01676 <span class="preprocessor">#define OBD_MD_FLQOS       (0x00200000ULL) </span><span class="comment">/* quality of service stats */</span>
<a name="l01677"></a>01677 <span class="comment">/*#define OBD_MD_FLOSCOPQ    (0x00400000ULL) osc opaque data, never used */</span>
<a name="l01678"></a>01678 <span class="comment">/*      OBD_MD_FLCOOKIE    (0x00800000ULL)    obsolete in 2.8 */</span>
<a name="l01679"></a>01679 <span class="preprocessor">#define OBD_MD_FLGROUP     (0x01000000ULL) </span><span class="comment">/* group */</span>
<a name="l01680"></a>01680 <span class="preprocessor">#define OBD_MD_FLFID       (0x02000000ULL) </span><span class="comment">/* -&gt;ost write inline fid */</span>
<a name="l01681"></a>01681 <span class="preprocessor">#define OBD_MD_FLEPOCH     (0x04000000ULL) </span><span class="comment">/* -&gt;ost write with ioepoch */</span>
<a name="l01682"></a>01682                                            <span class="comment">/* -&gt;mds if epoch opens or closes */</span>
<a name="l01683"></a>01683 <span class="preprocessor">#define OBD_MD_FLGRANT     (0x08000000ULL) </span><span class="comment">/* ost preallocation space grant */</span>
<a name="l01684"></a>01684 <span class="preprocessor">#define OBD_MD_FLDIREA     (0x10000000ULL) </span><span class="comment">/* dir&apos;s extended attribute data */</span>
<a name="l01685"></a>01685 <span class="preprocessor">#define OBD_MD_FLUSRQUOTA  (0x20000000ULL) </span><span class="comment">/* over quota flags sent from ost */</span>
<a name="l01686"></a>01686 <span class="preprocessor">#define OBD_MD_FLGRPQUOTA  (0x40000000ULL) </span><span class="comment">/* over quota flags sent from ost */</span>
<a name="l01687"></a>01687 <span class="preprocessor">#define OBD_MD_FLMODEASIZE (0x80000000ULL) </span><span class="comment">/* EA size will be changed */</span>
<a name="l01688"></a>01688 
<a name="l01689"></a>01689 <span class="preprocessor">#define OBD_MD_MDS         (0x0000000100000000ULL) </span><span class="comment">/* where an inode lives on */</span>
<a name="l01690"></a>01690 <span class="preprocessor">#define OBD_MD_REINT       (0x0000000200000000ULL) </span><span class="comment">/* reintegrate oa */</span>
<a name="l01691"></a>01691 <span class="preprocessor">#define OBD_MD_MEA         (0x0000000400000000ULL) </span><span class="comment">/* CMD split EA  */</span>
<a name="l01692"></a>01692 <span class="preprocessor">#define OBD_MD_TSTATE      (0x0000000800000000ULL) </span><span class="comment">/* transient state field */</span>
<a name="l01693"></a>01693 
<a name="l01694"></a>01694 <span class="preprocessor">#define OBD_MD_FLXATTR       (0x0000001000000000ULL) </span><span class="comment">/* xattr */</span>
<a name="l01695"></a>01695 <span class="preprocessor">#define OBD_MD_FLXATTRLS     (0x0000002000000000ULL) </span><span class="comment">/* xattr list */</span>
<a name="l01696"></a>01696 <span class="preprocessor">#define OBD_MD_FLXATTRRM     (0x0000004000000000ULL) </span><span class="comment">/* xattr remove */</span>
<a name="l01697"></a>01697 <span class="preprocessor">#define OBD_MD_FLACL         (0x0000008000000000ULL) </span><span class="comment">/* ACL */</span>
<a name="l01698"></a>01698 <span class="preprocessor">#define OBD_MD_FLRMTPERM     (0x0000010000000000ULL) </span><span class="comment">/* remote permission */</span>
<a name="l01699"></a>01699 <span class="preprocessor">#define OBD_MD_FLMDSCAPA     (0x0000020000000000ULL) </span><span class="comment">/* MDS capability */</span>
<a name="l01700"></a>01700 <span class="preprocessor">#define OBD_MD_FLOSSCAPA     (0x0000040000000000ULL) </span><span class="comment">/* OSS capability */</span>
<a name="l01701"></a>01701 <span class="preprocessor">#define OBD_MD_FLCKSPLIT     (0x0000080000000000ULL) </span><span class="comment">/* Check split on server */</span>
<a name="l01702"></a>01702 <span class="preprocessor">#define OBD_MD_FLCROSSREF    (0x0000100000000000ULL) </span><span class="comment">/* Cross-ref case */</span>
<a name="l01703"></a>01703 <span class="preprocessor">#define OBD_MD_FLGETATTRLOCK (0x0000200000000000ULL) </span><span class="comment">/* Get IOEpoch attributes</span>
<a name="l01704"></a>01704 <span class="comment">                                                      * under lock; for xattr</span>
<a name="l01705"></a>01705 <span class="comment">                                                      * requests means the</span>
<a name="l01706"></a>01706 <span class="comment">                                                      * client holds the lock */</span>
<a name="l01707"></a>01707 <span class="preprocessor">#define OBD_MD_FLOBJCOUNT    (0x0000400000000000ULL) </span><span class="comment">/* for multiple destroy */</span>
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 <span class="preprocessor">#define OBD_MD_FLRMTLSETFACL (0x0001000000000000ULL) </span><span class="comment">/* lfs lsetfacl case */</span>
<a name="l01710"></a>01710 <span class="preprocessor">#define OBD_MD_FLRMTLGETFACL (0x0002000000000000ULL) </span><span class="comment">/* lfs lgetfacl case */</span>
<a name="l01711"></a>01711 <span class="preprocessor">#define OBD_MD_FLRMTRSETFACL (0x0004000000000000ULL) </span><span class="comment">/* lfs rsetfacl case */</span>
<a name="l01712"></a>01712 <span class="preprocessor">#define OBD_MD_FLRMTRGETFACL (0x0008000000000000ULL) </span><span class="comment">/* lfs rgetfacl case */</span>
<a name="l01713"></a>01713 
<a name="l01714"></a>01714 <span class="preprocessor">#define OBD_MD_FLDATAVERSION (0x0010000000000000ULL) </span><span class="comment">/* iversion sum */</span>
<a name="l01715"></a>01715 <span class="preprocessor">#define OBD_MD_CLOSE_INTENT_EXECED (0x0020000000000000ULL) </span><span class="comment">/* close intent</span>
<a name="l01716"></a>01716 <span class="comment">                                                              executed */</span>
<a name="l01717"></a>01717 
<a name="l01718"></a>01718 <span class="preprocessor">#define OBD_MD_DEFAULT_MEA   (0x0040000000000000ULL) </span><span class="comment">/* default MEA */</span>
<a name="l01719"></a>01719 
<a name="l01720"></a>01720 <span class="preprocessor">#define OBD_MD_FLGETATTR (OBD_MD_FLID    | OBD_MD_FLATIME | OBD_MD_FLMTIME | \</span>
<a name="l01721"></a>01721 <span class="preprocessor">                          OBD_MD_FLCTIME | OBD_MD_FLSIZE  | OBD_MD_FLBLKSZ | \</span>
<a name="l01722"></a>01722 <span class="preprocessor">                          OBD_MD_FLMODE  | OBD_MD_FLTYPE  | OBD_MD_FLUID   | \</span>
<a name="l01723"></a>01723 <span class="preprocessor">                          OBD_MD_FLGID   | OBD_MD_FLFLAGS | OBD_MD_FLNLINK | \</span>
<a name="l01724"></a>01724 <span class="preprocessor">                          OBD_MD_FLGENER | OBD_MD_FLRDEV  | OBD_MD_FLGROUP)</span>
<a name="l01725"></a>01725 <span class="preprocessor"></span>
<a name="l01726"></a>01726 <span class="preprocessor">#define OBD_MD_FLXATTRALL (OBD_MD_FLXATTR | OBD_MD_FLXATTRLS)</span>
<a name="l01727"></a>01727 <span class="preprocessor"></span>
<a name="l01728"></a>01728 <span class="comment">/* don&apos;t forget obdo_fid which is way down at the bottom so it can</span>
<a name="l01729"></a>01729 <span class="comment"> * come after the definition of llog_cookie */</span>
<a name="l01730"></a>01730 
<a name="l01731"></a>01731 <span class="keyword">enum</span> hss_valid {
<a name="l01732"></a>01732         HSS_SETMASK     = 0x01,
<a name="l01733"></a>01733         HSS_CLEARMASK   = 0x02,
<a name="l01734"></a>01734         HSS_ARCHIVE_ID  = 0x04,
<a name="l01735"></a>01735 };
<a name="l01736"></a>01736 
<a name="l01737"></a><a class="code" href="structhsm__state__set.html">01737</a> <span class="keyword">struct </span><a class="code" href="structhsm__state__set.html">hsm_state_set</a> {
<a name="l01738"></a>01738         __u32   hss_valid;
<a name="l01739"></a>01739         __u32   hss_archive_id;
<a name="l01740"></a>01740         __u64   hss_setmask;
<a name="l01741"></a>01741         __u64   hss_clearmask;
<a name="l01742"></a>01742 };
<a name="l01743"></a>01743 
<a name="l01744"></a>01744 <span class="comment">/* ost_body.data values for OST_BRW */</span>
<a name="l01745"></a>01745 
<a name="l01746"></a>01746 <span class="preprocessor">#define OBD_BRW_READ            0x01</span>
<a name="l01747"></a>01747 <span class="preprocessor"></span><span class="preprocessor">#define OBD_BRW_WRITE           0x02</span>
<a name="l01748"></a>01748 <span class="preprocessor"></span><span class="preprocessor">#define OBD_BRW_RWMASK          (OBD_BRW_READ | OBD_BRW_WRITE)</span>
<a name="l01749"></a>01749 <span class="preprocessor"></span><span class="preprocessor">#define OBD_BRW_SYNC            0x08 </span><span class="comment">/* this page is a part of synchronous</span>
<a name="l01750"></a>01750 <span class="comment">                                      * transfer and is not accounted in</span>
<a name="l01751"></a>01751 <span class="comment">                                      * the grant. */</span>
<a name="l01752"></a>01752 <span class="preprocessor">#define OBD_BRW_CHECK           0x10</span>
<a name="l01753"></a>01753 <span class="preprocessor"></span><span class="preprocessor">#define OBD_BRW_FROM_GRANT      0x20 </span><span class="comment">/* the osc manages this under llite */</span>
<a name="l01754"></a>01754 <span class="preprocessor">#define OBD_BRW_GRANTED         0x40 </span><span class="comment">/* the ost manages this */</span>
<a name="l01755"></a>01755 <span class="preprocessor">#define OBD_BRW_NOCACHE         0x80 </span><span class="comment">/* this page is a part of non-cached IO */</span>
<a name="l01756"></a>01756 <span class="preprocessor">#define OBD_BRW_NOQUOTA        0x100</span>
<a name="l01757"></a>01757 <span class="preprocessor"></span><span class="preprocessor">#define OBD_BRW_SRVLOCK        0x200 </span><span class="comment">/* Client holds no lock over this page */</span>
<a name="l01758"></a>01758 <span class="preprocessor">#define OBD_BRW_ASYNC          0x400 </span><span class="comment">/* Server may delay commit to disk */</span>
<a name="l01759"></a>01759 <span class="preprocessor">#define OBD_BRW_MEMALLOC       0x800 </span><span class="comment">/* Client runs in the &quot;kswapd&quot; context */</span>
<a name="l01760"></a>01760 <span class="preprocessor">#define OBD_BRW_OVER_USRQUOTA 0x1000 </span><span class="comment">/* Running out of user quota */</span>
<a name="l01761"></a>01761 <span class="preprocessor">#define OBD_BRW_OVER_GRPQUOTA 0x2000 </span><span class="comment">/* Running out of group quota */</span>
<a name="l01762"></a>01762 <span class="preprocessor">#define OBD_BRW_SOFT_SYNC     0x4000 </span><span class="comment">/* This flag notifies the server</span>
<a name="l01763"></a>01763 <span class="comment">                                      * that the client is running low on</span>
<a name="l01764"></a>01764 <span class="comment">                                      * space for unstable pages; asking</span>
<a name="l01765"></a>01765 <span class="comment">                                      * it to sync quickly */</span>
<a name="l01766"></a>01766 
<a name="l01767"></a>01767 <span class="preprocessor">#define OBD_OBJECT_EOF LUSTRE_EOF</span>
<a name="l01768"></a>01768 <span class="preprocessor"></span>
<a name="l01769"></a>01769 <span class="preprocessor">#define OST_MIN_PRECREATE 32</span>
<a name="l01770"></a>01770 <span class="preprocessor"></span><span class="preprocessor">#define OST_MAX_PRECREATE 20000</span>
<a name="l01771"></a>01771 <span class="preprocessor"></span>
<a name="l01772"></a><a class="code" href="structobd__ioobj.html">01772</a> <span class="keyword">struct </span><a class="code" href="structobd__ioobj.html">obd_ioobj</a> {
<a name="l01773"></a>01773         <span class="keyword">struct </span><a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a>   ioo_oid;        <span class="comment">/* object ID, if multi-obj BRW */</span>
<a name="l01774"></a>01774         __u32           ioo_max_brw;    <span class="comment">/* low 16 bits were o_mode before 2.4,</span>
<a name="l01775"></a>01775 <span class="comment">                                         * now (PTLRPC_BULK_OPS_COUNT - 1) in</span>
<a name="l01776"></a>01776 <span class="comment">                                         * high 16 bits in 2.4 and later */</span>
<a name="l01777"></a>01777         __u32           ioo_bufcnt;     <span class="comment">/* number of niobufs for this object */</span>
<a name="l01778"></a>01778 };
<a name="l01779"></a>01779 
<a name="l01780"></a>01780 <span class="comment">/* NOTE: IOOBJ_MAX_BRW_BITS defines the _offset_ of the max_brw field in</span>
<a name="l01781"></a>01781 <span class="comment"> * ioo_max_brw, NOT the maximum number of bits in PTLRPC_BULK_OPS_BITS.</span>
<a name="l01782"></a>01782 <span class="comment"> * That said, ioo_max_brw is a 32-bit field so the limit is also 16 bits. */</span>
<a name="l01783"></a>01783 <span class="preprocessor">#define IOOBJ_MAX_BRW_BITS      16</span>
<a name="l01784"></a>01784 <span class="preprocessor"></span><span class="preprocessor">#define ioobj_max_brw_get(ioo)  (((ioo)-&gt;ioo_max_brw &gt;&gt; IOOBJ_MAX_BRW_BITS) + 1)</span>
<a name="l01785"></a>01785 <span class="preprocessor"></span><span class="preprocessor">#define ioobj_max_brw_set(ioo, num)                                     \</span>
<a name="l01786"></a>01786 <span class="preprocessor">do { (ioo)-&gt;ioo_max_brw = ((num) - 1) &lt;&lt; IOOBJ_MAX_BRW_BITS; } while (0)</span>
<a name="l01787"></a>01787 <span class="preprocessor"></span>
<a name="l01788"></a>01788 <span class="comment">/* multiple of 8 bytes =&gt; can array */</span>
<a name="l01789"></a><a class="code" href="structniobuf__remote.html">01789</a> <span class="keyword">struct </span><a class="code" href="structniobuf__remote.html">niobuf_remote</a> {
<a name="l01790"></a>01790         __u64   rnb_offset;
<a name="l01791"></a>01791         __u32   rnb_len;
<a name="l01792"></a>01792         __u32   rnb_flags;
<a name="l01793"></a>01793 };
<a name="l01794"></a>01794 
<a name="l01795"></a>01795 <span class="comment">/* lock value block communicated between the filter and llite */</span>
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 <span class="comment">/* OST_LVB_ERR_INIT is needed because the return code in rc is</span>
<a name="l01798"></a>01798 <span class="comment"> * negative, i.e. because ((MASK + rc) &amp; MASK) != MASK. */</span>
<a name="l01799"></a>01799 <span class="preprocessor">#define OST_LVB_ERR_INIT 0xffbadbad80000000ULL</span>
<a name="l01800"></a>01800 <span class="preprocessor"></span><span class="preprocessor">#define OST_LVB_ERR_MASK 0xffbadbad00000000ULL</span>
<a name="l01801"></a>01801 <span class="preprocessor"></span><span class="preprocessor">#define OST_LVB_IS_ERR(blocks)                                          \</span>
<a name="l01802"></a>01802 <span class="preprocessor">        ((blocks &amp; OST_LVB_ERR_MASK) == OST_LVB_ERR_MASK)</span>
<a name="l01803"></a>01803 <span class="preprocessor"></span><span class="preprocessor">#define OST_LVB_SET_ERR(blocks, rc)                                     \</span>
<a name="l01804"></a>01804 <span class="preprocessor">        do { blocks = OST_LVB_ERR_INIT + rc; } while (0)</span>
<a name="l01805"></a>01805 <span class="preprocessor"></span><span class="preprocessor">#define OST_LVB_GET_ERR(blocks)    (int)(blocks - OST_LVB_ERR_INIT)</span>
<a name="l01806"></a>01806 <span class="preprocessor"></span>
<a name="l01807"></a><a class="code" href="structost__lvb__v1.html">01807</a> <span class="keyword">struct </span><a class="code" href="structost__lvb__v1.html">ost_lvb_v1</a> {
<a name="l01808"></a>01808         __u64   lvb_size;
<a name="l01809"></a>01809         __s64   lvb_mtime;
<a name="l01810"></a>01810         __s64   lvb_atime;
<a name="l01811"></a>01811         __s64   lvb_ctime;
<a name="l01812"></a>01812         __u64   lvb_blocks;
<a name="l01813"></a>01813 };
<a name="l01814"></a>01814 
<a name="l01815"></a><a class="code" href="structost__lvb.html">01815</a> <span class="keyword">struct </span><a class="code" href="structost__lvb.html">ost_lvb</a> {
<a name="l01816"></a>01816         __u64   lvb_size;
<a name="l01817"></a>01817         __s64   lvb_mtime;
<a name="l01818"></a>01818         __s64   lvb_atime;
<a name="l01819"></a>01819         __s64   lvb_ctime;
<a name="l01820"></a>01820         __u64   lvb_blocks;
<a name="l01821"></a>01821         __u32   lvb_mtime_ns;
<a name="l01822"></a>01822         __u32   lvb_atime_ns;
<a name="l01823"></a>01823         __u32   lvb_ctime_ns;
<a name="l01824"></a>01824         __u32   lvb_padding;
<a name="l01825"></a>01825 };
<a name="l01826"></a>01826 
<a name="l01827"></a>01827 <span class="comment">/*</span>
<a name="l01828"></a>01828 <span class="comment"> *   lquota data structures</span>
<a name="l01829"></a>01829 <span class="comment"> */</span>
<a name="l01830"></a>01830 
<a name="l01831"></a>01831 <span class="preprocessor">#ifndef QUOTABLOCK_BITS</span>
<a name="l01832"></a>01832 <span class="preprocessor"></span><span class="preprocessor"># define QUOTABLOCK_BITS LUSTRE_QUOTABLOCK_BITS</span>
<a name="l01833"></a>01833 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01834"></a>01834 <span class="preprocessor"></span>
<a name="l01835"></a>01835 <span class="preprocessor">#ifndef QUOTABLOCK_SIZE</span>
<a name="l01836"></a>01836 <span class="preprocessor"></span><span class="preprocessor"># define QUOTABLOCK_SIZE LUSTRE_QUOTABLOCK_SIZE</span>
<a name="l01837"></a>01837 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01838"></a>01838 <span class="preprocessor"></span>
<a name="l01839"></a>01839 <span class="preprocessor">#ifndef toqb</span>
<a name="l01840"></a>01840 <span class="preprocessor"></span><span class="preprocessor"># define toqb lustre_stoqb</span>
<a name="l01841"></a>01841 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01842"></a>01842 <span class="preprocessor"></span>
<a name="l01843"></a>01843 <span class="comment">/* The lquota_id structure is an union of all the possible identifier types that</span>
<a name="l01844"></a>01844 <span class="comment"> * can be used with quota, this includes:</span>
<a name="l01845"></a>01845 <span class="comment"> * - 64-bit user ID</span>
<a name="l01846"></a>01846 <span class="comment"> * - 64-bit group ID</span>
<a name="l01847"></a>01847 <span class="comment"> * - a FID which can be used for per-directory quota in the future */</span>
<a name="l01848"></a><a class="code" href="unionlquota__id.html">01848</a> <span class="keyword">union </span><a class="code" href="unionlquota__id.html">lquota_id</a> {
<a name="l01849"></a>01849         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   qid_fid; <span class="comment">/* FID for per-directory quota */</span>
<a name="l01850"></a>01850         __u64           qid_uid; <span class="comment">/* user identifier */</span>
<a name="l01851"></a>01851         __u64           qid_gid; <span class="comment">/* group identifier */</span>
<a name="l01852"></a>01852 };
<a name="l01853"></a>01853 
<a name="l01854"></a>01854 <span class="comment">/* quotactl management */</span>
<a name="l01855"></a><a class="code" href="structobd__quotactl.html">01855</a> <span class="keyword">struct </span><a class="code" href="structobd__quotactl.html">obd_quotactl</a> {
<a name="l01856"></a>01856         __u32                   qc_cmd;
<a name="l01857"></a>01857         __u32                   qc_type; <span class="comment">/* see Q_* flag below */</span>
<a name="l01858"></a>01858         __u32                   qc_id;
<a name="l01859"></a>01859         __u32                   qc_stat;
<a name="l01860"></a>01860         <span class="keyword">struct </span><a class="code" href="structobd__dqinfo.html">obd_dqinfo</a>       qc_dqinfo;
<a name="l01861"></a>01861         <span class="keyword">struct </span><a class="code" href="structobd__dqblk.html">obd_dqblk</a>        qc_dqblk;
<a name="l01862"></a>01862 };
<a name="l01863"></a>01863 
<a name="l01864"></a>01864 <span class="preprocessor">#define Q_COPY(out, in, member) (out)-&gt;member = (in)-&gt;member</span>
<a name="l01865"></a>01865 <span class="preprocessor"></span>
<a name="l01866"></a>01866 <span class="preprocessor">#define QCTL_COPY(out, in)              \</span>
<a name="l01867"></a>01867 <span class="preprocessor">do {                                    \</span>
<a name="l01868"></a>01868 <span class="preprocessor">        Q_COPY(out, in, qc_cmd);        \</span>
<a name="l01869"></a>01869 <span class="preprocessor">        Q_COPY(out, in, qc_type);       \</span>
<a name="l01870"></a>01870 <span class="preprocessor">        Q_COPY(out, in, qc_id);         \</span>
<a name="l01871"></a>01871 <span class="preprocessor">        Q_COPY(out, in, qc_stat);       \</span>
<a name="l01872"></a>01872 <span class="preprocessor">        Q_COPY(out, in, qc_dqinfo);     \</span>
<a name="l01873"></a>01873 <span class="preprocessor">        Q_COPY(out, in, qc_dqblk);      \</span>
<a name="l01874"></a>01874 <span class="preprocessor">} while (0)</span>
<a name="l01875"></a>01875 <span class="preprocessor"></span>
<a name="l01876"></a>01876 <span class="comment">/* Body of quota request used for quota acquire/release RPCs between quota</span>
<a name="l01877"></a>01877 <span class="comment"> * master (aka QMT) and slaves (ak QSD). */</span>
<a name="l01878"></a><a class="code" href="structquota__body.html">01878</a> <span class="keyword">struct </span><a class="code" href="structquota__body.html">quota_body</a> {
<a name="l01879"></a>01879         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   qb_fid;     <span class="comment">/* FID of global index packing the pool ID</span>
<a name="l01880"></a>01880 <span class="comment">                                      * and type (data or metadata) as well as</span>
<a name="l01881"></a>01881 <span class="comment">                                      * the quota type (user or group). */</span>
<a name="l01882"></a>01882         <span class="keyword">union </span><a class="code" href="unionlquota__id.html">lquota_id</a> qb_id;      <span class="comment">/* uid or gid or directory FID */</span>
<a name="l01883"></a>01883         __u32           qb_flags;   <span class="comment">/* see below */</span>
<a name="l01884"></a>01884         __u32           qb_padding;
<a name="l01885"></a>01885         __u64           qb_count;   <span class="comment">/* acquire/release count (kbytes/inodes) */</span>
<a name="l01886"></a>01886         __u64           qb_usage;   <span class="comment">/* current slave usage (kbytes/inodes) */</span>
<a name="l01887"></a>01887         __u64           qb_slv_ver; <span class="comment">/* slave index file version */</span>
<a name="l01888"></a>01888         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    qb_lockh;     <span class="comment">/* per-ID lock handle */</span>
<a name="l01889"></a>01889         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    qb_glb_lockh; <span class="comment">/* global lock handle */</span>
<a name="l01890"></a>01890         __u64           qb_padding1[4];
<a name="l01891"></a>01891 };
<a name="l01892"></a>01892 
<a name="l01893"></a>01893 <span class="comment">/* When the quota_body is used in the reply of quota global intent</span>
<a name="l01894"></a>01894 <span class="comment"> * lock (IT_QUOTA_CONN) reply, qb_fid contains slave index file FID. */</span>
<a name="l01895"></a>01895 <span class="preprocessor">#define qb_slv_fid      qb_fid</span>
<a name="l01896"></a>01896 <span class="preprocessor"></span><span class="comment">/* qb_usage is the current qunit (in kbytes/inodes) when quota_body is used in</span>
<a name="l01897"></a>01897 <span class="comment"> * quota reply */</span>
<a name="l01898"></a>01898 <span class="preprocessor">#define qb_qunit        qb_usage</span>
<a name="l01899"></a>01899 <span class="preprocessor"></span>
<a name="l01900"></a>01900 <span class="preprocessor">#define QUOTA_DQACQ_FL_ACQ      0x1  </span><span class="comment">/* acquire quota */</span>
<a name="l01901"></a>01901 <span class="preprocessor">#define QUOTA_DQACQ_FL_PREACQ   0x2  </span><span class="comment">/* pre-acquire */</span>
<a name="l01902"></a>01902 <span class="preprocessor">#define QUOTA_DQACQ_FL_REL      0x4  </span><span class="comment">/* release quota */</span>
<a name="l01903"></a>01903 <span class="preprocessor">#define QUOTA_DQACQ_FL_REPORT   0x8  </span><span class="comment">/* report usage */</span>
<a name="l01904"></a>01904 
<a name="l01905"></a>01905 <span class="comment">/* Quota types currently supported */</span>
<a name="l01906"></a>01906 <span class="keyword">enum</span> {
<a name="l01907"></a>01907         LQUOTA_TYPE_USR = 0x00, <span class="comment">/* maps to USRQUOTA */</span>
<a name="l01908"></a>01908         LQUOTA_TYPE_GRP = 0x01, <span class="comment">/* maps to GRPQUOTA */</span>
<a name="l01909"></a>01909         LQUOTA_TYPE_MAX
<a name="l01910"></a>01910 };
<a name="l01911"></a>01911 
<a name="l01912"></a>01912 <span class="comment">/* There are 2 different resource types on which a quota limit can be enforced:</span>
<a name="l01913"></a>01913 <span class="comment"> * - inodes on the MDTs</span>
<a name="l01914"></a>01914 <span class="comment"> * - blocks on the OSTs */</span>
<a name="l01915"></a>01915 <span class="keyword">enum</span> {
<a name="l01916"></a>01916         LQUOTA_RES_MD           = 0x01, <span class="comment">/* skip 0 to avoid null oid in FID */</span>
<a name="l01917"></a>01917         LQUOTA_RES_DT           = 0x02,
<a name="l01918"></a>01918         LQUOTA_LAST_RES,
<a name="l01919"></a>01919         LQUOTA_FIRST_RES        = LQUOTA_RES_MD
<a name="l01920"></a>01920 };
<a name="l01921"></a>01921 <span class="preprocessor">#define LQUOTA_NR_RES (LQUOTA_LAST_RES - LQUOTA_FIRST_RES + 1)</span>
<a name="l01922"></a>01922 <span class="preprocessor"></span>
<a name="l01923"></a>01923 <span class="comment">/*</span>
<a name="l01924"></a>01924 <span class="comment"> * Space accounting support</span>
<a name="l01925"></a>01925 <span class="comment"> * Format of an accounting record, providing disk usage information for a given</span>
<a name="l01926"></a>01926 <span class="comment"> * user or group</span>
<a name="l01927"></a>01927 <span class="comment"> */</span>
<a name="l01928"></a><a class="code" href="structlquota__acct__rec.html">01928</a> <span class="keyword">struct </span><a class="code" href="structlquota__acct__rec.html">lquota_acct_rec</a> { <span class="comment">/* 16 bytes */</span>
<a name="l01929"></a>01929         __u64 bspace;  <span class="comment">/* current space in use */</span>
<a name="l01930"></a>01930         __u64 ispace;  <span class="comment">/* current # inodes in use */</span>
<a name="l01931"></a>01931 };
<a name="l01932"></a>01932 
<a name="l01933"></a>01933 <span class="comment">/*</span>
<a name="l01934"></a>01934 <span class="comment"> * Global quota index support</span>
<a name="l01935"></a>01935 <span class="comment"> * Format of a global record, providing global quota settings for a given quota</span>
<a name="l01936"></a>01936 <span class="comment"> * identifier</span>
<a name="l01937"></a>01937 <span class="comment"> */</span>
<a name="l01938"></a><a class="code" href="structlquota__glb__rec.html">01938</a> <span class="keyword">struct </span><a class="code" href="structlquota__glb__rec.html">lquota_glb_rec</a> { <span class="comment">/* 32 bytes */</span>
<a name="l01939"></a>01939         __u64 qbr_hardlimit; <span class="comment">/* quota hard limit, in #inodes or kbytes */</span>
<a name="l01940"></a>01940         __u64 qbr_softlimit; <span class="comment">/* quota soft limit, in #inodes or kbytes */</span>
<a name="l01941"></a>01941         __u64 qbr_time;      <span class="comment">/* grace time, in seconds */</span>
<a name="l01942"></a>01942         __u64 qbr_granted;   <span class="comment">/* how much is granted to slaves, in #inodes or</span>
<a name="l01943"></a>01943 <span class="comment">                              * kbytes */</span>
<a name="l01944"></a>01944 };
<a name="l01945"></a>01945 
<a name="l01946"></a>01946 <span class="comment">/*</span>
<a name="l01947"></a>01947 <span class="comment"> * Slave index support</span>
<a name="l01948"></a>01948 <span class="comment"> * Format of a slave record, recording how much space is granted to a given</span>
<a name="l01949"></a>01949 <span class="comment"> * slave</span>
<a name="l01950"></a>01950 <span class="comment"> */</span>
<a name="l01951"></a><a class="code" href="structlquota__slv__rec.html">01951</a> <span class="keyword">struct </span><a class="code" href="structlquota__slv__rec.html">lquota_slv_rec</a> { <span class="comment">/* 8 bytes */</span>
<a name="l01952"></a>01952         __u64 qsr_granted; <span class="comment">/* space granted to the slave for the key=ID,</span>
<a name="l01953"></a>01953 <span class="comment">                            * in #inodes or kbytes */</span>
<a name="l01954"></a>01954 };
<a name="l01955"></a>01955 
<a name="l01956"></a>01956 <span class="comment">/* Data structures associated with the quota locks */</span>
<a name="l01957"></a>01957 
<a name="l01958"></a>01958 <span class="comment">/* Glimpse descriptor used for the index &amp; per-ID quota locks */</span>
<a name="l01959"></a><a class="code" href="structldlm__gl__lquota__desc.html">01959</a> <span class="keyword">struct </span><a class="code" href="structldlm__gl__lquota__desc.html">ldlm_gl_lquota_desc</a> {
<a name="l01960"></a>01960         <span class="keyword">union </span><a class="code" href="unionlquota__id.html">lquota_id</a> gl_id;    <span class="comment">/* quota ID subject to the glimpse */</span>
<a name="l01961"></a>01961         __u64           gl_flags; <span class="comment">/* see LQUOTA_FL* below */</span>
<a name="l01962"></a>01962         __u64           gl_ver;   <span class="comment">/* new index version */</span>
<a name="l01963"></a>01963         __u64           gl_hardlimit; <span class="comment">/* new hardlimit or qunit value */</span>
<a name="l01964"></a>01964         __u64           gl_softlimit; <span class="comment">/* new softlimit */</span>
<a name="l01965"></a>01965         __u64           gl_time;
<a name="l01966"></a>01966         __u64           gl_pad2;
<a name="l01967"></a>01967 };
<a name="l01968"></a>01968 <span class="preprocessor">#define gl_qunit        gl_hardlimit </span><span class="comment">/* current qunit value used when</span>
<a name="l01969"></a>01969 <span class="comment">                                      * glimpsing per-ID quota locks */</span>
<a name="l01970"></a>01970 
<a name="l01971"></a>01971 <span class="comment">/* quota glimpse flags */</span>
<a name="l01972"></a>01972 <span class="preprocessor">#define LQUOTA_FL_EDQUOT 0x1 </span><span class="comment">/* user/group out of quota space on QMT */</span>
<a name="l01973"></a>01973 
<a name="l01974"></a>01974 <span class="comment">/* LVB used with quota (global and per-ID) locks */</span>
<a name="l01975"></a><a class="code" href="structlquota__lvb.html">01975</a> <span class="keyword">struct </span><a class="code" href="structlquota__lvb.html">lquota_lvb</a> {
<a name="l01976"></a>01976         __u64   lvb_flags;      <span class="comment">/* see LQUOTA_FL* above */</span>
<a name="l01977"></a>01977         __u64   lvb_id_may_rel; <span class="comment">/* space that might be released later */</span>
<a name="l01978"></a>01978         __u64   lvb_id_rel;     <span class="comment">/* space released by the slave for this ID */</span>
<a name="l01979"></a>01979         __u64   lvb_id_qunit;   <span class="comment">/* current qunit value */</span>
<a name="l01980"></a>01980         __u64   lvb_pad1;
<a name="l01981"></a>01981 };
<a name="l01982"></a>01982 
<a name="l01983"></a>01983 <span class="comment">/* LVB used with global quota lock */</span>
<a name="l01984"></a>01984 <span class="preprocessor">#define lvb_glb_ver  lvb_id_may_rel </span><span class="comment">/* current version of the global index */</span>
<a name="l01985"></a>01985 
<a name="l01986"></a>01986 <span class="comment">/* op codes */</span>
<a name="l01987"></a>01987 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l01988"></a>01988         QUOTA_DQACQ     = 601,
<a name="l01989"></a>01989         QUOTA_DQREL     = 602,
<a name="l01990"></a>01990         QUOTA_LAST_OPC
<a name="l01991"></a>01991 } quota_cmd_t;
<a name="l01992"></a>01992 <span class="preprocessor">#define QUOTA_FIRST_OPC QUOTA_DQACQ</span>
<a name="l01993"></a>01993 <span class="preprocessor"></span>
<a name="l01994"></a>01994 <span class="comment">/*</span>
<a name="l01995"></a>01995 <span class="comment"> *   MDS REQ RECORDS</span>
<a name="l01996"></a>01996 <span class="comment"> */</span>
<a name="l01997"></a>01997 
<a name="l01998"></a>01998 <span class="comment">/* opcodes */</span>
<a name="l01999"></a>01999 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l02000"></a>02000         MDS_GETATTR             = 33,
<a name="l02001"></a>02001         MDS_GETATTR_NAME        = 34,
<a name="l02002"></a>02002         MDS_CLOSE               = 35,
<a name="l02003"></a>02003         MDS_REINT               = 36,
<a name="l02004"></a>02004         MDS_READPAGE            = 37,
<a name="l02005"></a>02005         MDS_CONNECT             = 38,
<a name="l02006"></a>02006         MDS_DISCONNECT          = 39,
<a name="l02007"></a>02007         MDS_GET_ROOT            = 40,
<a name="l02008"></a>02008         MDS_STATFS              = 41,
<a name="l02009"></a>02009         MDS_PIN                 = 42, <span class="comment">/* obsolete, never used in a release */</span>
<a name="l02010"></a>02010         MDS_UNPIN               = 43, <span class="comment">/* obsolete, never used in a release */</span>
<a name="l02011"></a>02011         MDS_SYNC                = 44,
<a name="l02012"></a>02012         MDS_DONE_WRITING        = 45, <span class="comment">/* obsolete since 2.8.0 */</span>
<a name="l02013"></a>02013         MDS_SET_INFO            = 46,
<a name="l02014"></a>02014         MDS_QUOTACHECK          = 47, <span class="comment">/* not used since 2.4 */</span>
<a name="l02015"></a>02015         MDS_QUOTACTL            = 48,
<a name="l02016"></a>02016         MDS_GETXATTR            = 49,
<a name="l02017"></a>02017         MDS_SETXATTR            = 50, <span class="comment">/* obsolete, now it&apos;s MDS_REINT op */</span>
<a name="l02018"></a>02018         MDS_WRITEPAGE           = 51,
<a name="l02019"></a>02019         MDS_IS_SUBDIR           = 52, <span class="comment">/* obsolete, never used in a release */</span>
<a name="l02020"></a>02020         MDS_GET_INFO            = 53,
<a name="l02021"></a>02021         MDS_HSM_STATE_GET       = 54,
<a name="l02022"></a>02022         MDS_HSM_STATE_SET       = 55,
<a name="l02023"></a>02023         MDS_HSM_ACTION          = 56,
<a name="l02024"></a>02024         MDS_HSM_PROGRESS        = 57,
<a name="l02025"></a>02025         MDS_HSM_REQUEST         = 58,
<a name="l02026"></a>02026         MDS_HSM_CT_REGISTER     = 59,
<a name="l02027"></a>02027         MDS_HSM_CT_UNREGISTER   = 60,
<a name="l02028"></a>02028         MDS_SWAP_LAYOUTS        = 61,
<a name="l02029"></a>02029         MDS_LAST_OPC
<a name="l02030"></a>02030 } mds_cmd_t;
<a name="l02031"></a>02031 
<a name="l02032"></a>02032 <span class="preprocessor">#define MDS_FIRST_OPC    MDS_GETATTR</span>
<a name="l02033"></a>02033 <span class="preprocessor"></span>
<a name="l02034"></a>02034 
<a name="l02035"></a>02035 <span class="comment">/* opcodes for object update */</span>
<a name="l02036"></a>02036 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l02037"></a>02037         OUT_UPDATE      = 1000,
<a name="l02038"></a>02038         OUT_UPDATE_LAST_OPC
<a name="l02039"></a>02039 } update_cmd_t;
<a name="l02040"></a>02040 
<a name="l02041"></a>02041 <span class="preprocessor">#define OUT_UPDATE_FIRST_OPC    OUT_UPDATE</span>
<a name="l02042"></a>02042 <span class="preprocessor"></span>
<a name="l02043"></a>02043 <span class="comment">/*</span>
<a name="l02044"></a>02044 <span class="comment"> * Do not exceed 63</span>
<a name="l02045"></a>02045 <span class="comment"> */</span>
<a name="l02046"></a>02046 
<a name="l02047"></a>02047 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l02048"></a>02048         REINT_SETATTR  = 1,
<a name="l02049"></a>02049         REINT_CREATE   = 2,
<a name="l02050"></a>02050         REINT_LINK     = 3,
<a name="l02051"></a>02051         REINT_UNLINK   = 4,
<a name="l02052"></a>02052         REINT_RENAME   = 5,
<a name="l02053"></a>02053         REINT_OPEN     = 6,
<a name="l02054"></a>02054         REINT_SETXATTR = 7,
<a name="l02055"></a>02055         REINT_RMENTRY  = 8,
<a name="l02056"></a>02056         REINT_MIGRATE  = 9,
<a name="l02057"></a>02057         REINT_MAX
<a name="l02058"></a>02058 } mds_reint_t, mdt_reint_t;
<a name="l02059"></a>02059 
<a name="l02060"></a>02060 <span class="comment">/* the disposition of the intent outlines what was executed */</span>
<a name="l02061"></a>02061 <span class="preprocessor">#define DISP_IT_EXECD        0x00000001</span>
<a name="l02062"></a>02062 <span class="preprocessor"></span><span class="preprocessor">#define DISP_LOOKUP_EXECD    0x00000002</span>
<a name="l02063"></a>02063 <span class="preprocessor"></span><span class="preprocessor">#define DISP_LOOKUP_NEG      0x00000004</span>
<a name="l02064"></a>02064 <span class="preprocessor"></span><span class="preprocessor">#define DISP_LOOKUP_POS      0x00000008</span>
<a name="l02065"></a>02065 <span class="preprocessor"></span><span class="preprocessor">#define DISP_OPEN_CREATE     0x00000010</span>
<a name="l02066"></a>02066 <span class="preprocessor"></span><span class="preprocessor">#define DISP_OPEN_OPEN       0x00000020</span>
<a name="l02067"></a>02067 <span class="preprocessor"></span><span class="preprocessor">#define DISP_ENQ_COMPLETE    0x00400000         </span><span class="comment">/* obsolete and unused */</span>
<a name="l02068"></a>02068 <span class="preprocessor">#define DISP_ENQ_OPEN_REF    0x00800000</span>
<a name="l02069"></a>02069 <span class="preprocessor"></span><span class="preprocessor">#define DISP_ENQ_CREATE_REF  0x01000000</span>
<a name="l02070"></a>02070 <span class="preprocessor"></span><span class="preprocessor">#define DISP_OPEN_LOCK       0x02000000</span>
<a name="l02071"></a>02071 <span class="preprocessor"></span><span class="preprocessor">#define DISP_OPEN_LEASE      0x04000000</span>
<a name="l02072"></a>02072 <span class="preprocessor"></span><span class="preprocessor">#define DISP_OPEN_STRIPE     0x08000000</span>
<a name="l02073"></a>02073 <span class="preprocessor"></span><span class="preprocessor">#define DISP_OPEN_DENY       0x10000000</span>
<a name="l02074"></a>02074 <span class="preprocessor"></span>
<a name="l02075"></a>02075 <span class="comment">/* INODE LOCK PARTS */</span>
<a name="l02076"></a>02076 <span class="preprocessor">#define MDS_INODELOCK_LOOKUP 0x000001   </span><span class="comment">/* For namespace, dentry etc, and also</span>
<a name="l02077"></a>02077 <span class="comment">                                         * was used to protect permission (mode,</span>
<a name="l02078"></a>02078 <span class="comment">                                         * owner, group etc) before 2.4. */</span>
<a name="l02079"></a>02079 <span class="preprocessor">#define MDS_INODELOCK_UPDATE 0x000002   </span><span class="comment">/* size, links, timestamps */</span>
<a name="l02080"></a>02080 <span class="preprocessor">#define MDS_INODELOCK_OPEN   0x000004   </span><span class="comment">/* For opened files */</span>
<a name="l02081"></a>02081 <span class="preprocessor">#define MDS_INODELOCK_LAYOUT 0x000008   </span><span class="comment">/* for layout */</span>
<a name="l02082"></a>02082 
<a name="l02083"></a>02083 <span class="comment">/* The PERM bit is added int 2.4, and it is used to protect permission(mode,</span>
<a name="l02084"></a>02084 <span class="comment"> * owner, group, acl etc), so to separate the permission from LOOKUP lock.</span>
<a name="l02085"></a>02085 <span class="comment"> * Because for remote directories(in DNE), these locks will be granted by</span>
<a name="l02086"></a>02086 <span class="comment"> * different MDTs(different ldlm namespace).</span>
<a name="l02087"></a>02087 <span class="comment"> *</span>
<a name="l02088"></a>02088 <span class="comment"> * For local directory, MDT will always grant UPDATE_LOCK|PERM_LOCK together.</span>
<a name="l02089"></a>02089 <span class="comment"> * For Remote directory, the master MDT, where the remote directory is, will</span>
<a name="l02090"></a>02090 <span class="comment"> * grant UPDATE_LOCK|PERM_LOCK, and the remote MDT, where the name entry is,</span>
<a name="l02091"></a>02091 <span class="comment"> * will grant LOOKUP_LOCK. */</span>
<a name="l02092"></a>02092 <span class="preprocessor">#define MDS_INODELOCK_PERM   0x000010</span>
<a name="l02093"></a>02093 <span class="preprocessor"></span><span class="preprocessor">#define MDS_INODELOCK_XATTR  0x000020   </span><span class="comment">/* extended attributes */</span>
<a name="l02094"></a>02094 
<a name="l02095"></a>02095 <span class="preprocessor">#define MDS_INODELOCK_MAXSHIFT 5</span>
<a name="l02096"></a>02096 <span class="preprocessor"></span><span class="comment">/* This FULL lock is useful to take on unlink sort of operations */</span>
<a name="l02097"></a>02097 <span class="preprocessor">#define MDS_INODELOCK_FULL ((1&lt;&lt;(MDS_INODELOCK_MAXSHIFT+1))-1)</span>
<a name="l02098"></a>02098 <span class="preprocessor"></span>
<a name="l02099"></a>02099 <span class="comment">/* NOTE: until Lustre 1.8.7/2.1.1 the fid_ver() was packed into name[2],</span>
<a name="l02100"></a>02100 <span class="comment"> * but was moved into name[1] along with the OID to avoid consuming the</span>
<a name="l02101"></a>02101 <span class="comment"> * name[2,3] fields that need to be used for the quota id (also a FID). */</span>
<a name="l02102"></a>02102 <span class="keyword">enum</span> {
<a name="l02103"></a>02103         LUSTRE_RES_ID_SEQ_OFF = 0,
<a name="l02104"></a>02104         LUSTRE_RES_ID_VER_OID_OFF = 1,
<a name="l02105"></a>02105         LUSTRE_RES_ID_WAS_VER_OFF = 2, <span class="comment">/* see note above */</span>
<a name="l02106"></a>02106         LUSTRE_RES_ID_QUOTA_SEQ_OFF = 2,
<a name="l02107"></a>02107         LUSTRE_RES_ID_QUOTA_VER_OID_OFF = 3,
<a name="l02108"></a>02108         LUSTRE_RES_ID_HSH_OFF = 3
<a name="l02109"></a>02109 };
<a name="l02110"></a>02110 
<a name="l02111"></a>02111 <span class="preprocessor">#define MDS_STATUS_CONN 1</span>
<a name="l02112"></a>02112 <span class="preprocessor"></span><span class="preprocessor">#define MDS_STATUS_LOV 2</span>
<a name="l02113"></a>02113 <span class="preprocessor"></span>
<a name="l02114"></a>02114 <span class="keyword">enum</span> {
<a name="l02115"></a>02115         <span class="comment">/* these should be identical to their EXT4_*_FL counterparts, they are</span>
<a name="l02116"></a>02116 <span class="comment">         * redefined here only to avoid dragging in fs/ext4/ext4.h */</span>
<a name="l02117"></a>02117         LUSTRE_SYNC_FL = 0x00000008, <span class="comment">/* Synchronous updates */</span>
<a name="l02118"></a>02118         LUSTRE_IMMUTABLE_FL = 0x00000010, <span class="comment">/* Immutable file */</span>
<a name="l02119"></a>02119         LUSTRE_APPEND_FL = 0x00000020, <span class="comment">/* writes to file may only append */</span>
<a name="l02120"></a>02120         LUSTRE_NODUMP_FL = 0x00000040, <span class="comment">/* do not dump file */</span>
<a name="l02121"></a>02121         LUSTRE_NOATIME_FL = 0x00000080, <span class="comment">/* do not update atime */</span>
<a name="l02122"></a>02122         LUSTRE_INDEX_FL = 0x00001000, <span class="comment">/* hash-indexed directory */</span>
<a name="l02123"></a>02123         LUSTRE_DIRSYNC_FL = 0x00010000, <span class="comment">/* dirsync behaviour (dir only) */</span>
<a name="l02124"></a>02124         LUSTRE_TOPDIR_FL = 0x00020000, <span class="comment">/* Top of directory hierarchies*/</span>
<a name="l02125"></a>02125         LUSTRE_DIRECTIO_FL = 0x00100000, <span class="comment">/* Use direct i/o */</span>
<a name="l02126"></a>02126         LUSTRE_INLINE_DATA_FL = 0x10000000, <span class="comment">/* Inode has inline data. */</span>
<a name="l02127"></a>02127 
<a name="l02128"></a>02128         <span class="comment">/* These flags will not be identical to any EXT4_*_FL counterparts,</span>
<a name="l02129"></a>02129 <span class="comment">         * and only reserved for lustre purpose. Note: these flags might</span>
<a name="l02130"></a>02130 <span class="comment">         * be conflict with some of EXT4 flags, so</span>
<a name="l02131"></a>02131 <span class="comment">         * 1. these conflict flags needs to be removed when the flag is</span>
<a name="l02132"></a>02132 <span class="comment">         * wired by la_flags see osd_attr_get().</span>
<a name="l02133"></a>02133 <span class="comment">         * 2. If these flags needs to be stored into inode, they will be</span>
<a name="l02134"></a>02134 <span class="comment">         * stored in LMA. see LMAI_XXXX */</span>
<a name="l02135"></a>02135         LUSTRE_ORPHAN_FL = 0x00002000,
<a name="l02136"></a>02136 
<a name="l02137"></a>02137         LUSTRE_LMA_FL_MASKS = LUSTRE_ORPHAN_FL,
<a name="l02138"></a>02138 };
<a name="l02139"></a>02139 
<a name="l02140"></a>02140 <span class="comment">/* LUSTRE_LMA_FL_MASKS defines which flags will be stored in LMA */</span>
<a name="l02141"></a>02141 
<a name="l02142"></a>02142 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lma_to_lustre_flags(__u32 lma_flags)
<a name="l02143"></a>02143 {
<a name="l02144"></a>02144         <span class="keywordflow">return</span> (lma_flags &amp; LMAI_ORPHAN) ? LUSTRE_ORPHAN_FL : 0;
<a name="l02145"></a>02145 }
<a name="l02146"></a>02146 
<a name="l02147"></a>02147 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lustre_to_lma_flags(__u32 la_flags)
<a name="l02148"></a>02148 {
<a name="l02149"></a>02149         <span class="keywordflow">return</span> (la_flags &amp; LUSTRE_ORPHAN_FL) ? LMAI_ORPHAN : 0;
<a name="l02150"></a>02150 }
<a name="l02151"></a>02151 
<a name="l02152"></a>02152 
<a name="l02153"></a>02153 <span class="preprocessor">#ifdef __KERNEL__</span>
<a name="l02154"></a>02154 <span class="preprocessor"></span><span class="comment">/* Convert wire LUSTRE_*_FL to corresponding client local VFS S_* values</span>
<a name="l02155"></a>02155 <span class="comment"> * for the client inode i_flags.  The LUSTRE_*_FL are the Lustre wire</span>
<a name="l02156"></a>02156 <span class="comment"> * protocol equivalents of LDISKFS_*_FL values stored on disk, while</span>
<a name="l02157"></a>02157 <span class="comment"> * the S_* flags are kernel-internal values that change between kernel</span>
<a name="l02158"></a>02158 <span class="comment"> * versions.  These flags are set/cleared via FSFILT_IOC_{GET,SET}_FLAGS.</span>
<a name="l02159"></a>02159 <span class="comment"> * See b=16526 for a full history. */</span>
<a name="l02160"></a>02160 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ll_ext_to_inode_flags(<span class="keywordtype">int</span> flags)
<a name="l02161"></a>02161 {
<a name="l02162"></a>02162         <span class="keywordflow">return</span> (((flags &amp; LUSTRE_SYNC_FL)      ? S_SYNC      : 0) |
<a name="l02163"></a>02163                 ((flags &amp; LUSTRE_NOATIME_FL)   ? S_NOATIME   : 0) |
<a name="l02164"></a>02164                 ((flags &amp; LUSTRE_APPEND_FL)    ? S_APPEND    : 0) |
<a name="l02165"></a>02165 #<span class="keywordflow">if</span> defined(S_DIRSYNC)
<a name="l02166"></a>02166                 ((flags &amp; LUSTRE_DIRSYNC_FL)   ? S_DIRSYNC   : 0) |
<a name="l02167"></a>02167 #endif
<a name="l02168"></a>02168                 ((flags &amp; LUSTRE_IMMUTABLE_FL) ? S_IMMUTABLE : 0));
<a name="l02169"></a>02169 }
<a name="l02170"></a>02170 
<a name="l02171"></a>02171 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ll_inode_to_ext_flags(<span class="keywordtype">int</span> iflags)
<a name="l02172"></a>02172 {
<a name="l02173"></a>02173         <span class="keywordflow">return</span> (((iflags &amp; S_SYNC)      ? LUSTRE_SYNC_FL      : 0) |
<a name="l02174"></a>02174                 ((iflags &amp; S_NOATIME)   ? LUSTRE_NOATIME_FL   : 0) |
<a name="l02175"></a>02175                 ((iflags &amp; S_APPEND)    ? LUSTRE_APPEND_FL    : 0) |
<a name="l02176"></a>02176 #<span class="keywordflow">if</span> defined(S_DIRSYNC)
<a name="l02177"></a>02177                 ((iflags &amp; S_DIRSYNC)   ? LUSTRE_DIRSYNC_FL   : 0) |
<a name="l02178"></a>02178 #endif
<a name="l02179"></a>02179                 ((iflags &amp; S_IMMUTABLE) ? LUSTRE_IMMUTABLE_FL : 0));
<a name="l02180"></a>02180 }
<a name="l02181"></a>02181 <span class="preprocessor">#endif</span>
<a name="l02182"></a>02182 <span class="preprocessor"></span>
<a name="l02183"></a>02183 <span class="comment">/* 64 possible states */</span>
<a name="l02184"></a>02184 <span class="keyword">enum</span> md_transient_state {
<a name="l02185"></a>02185         MS_RESTORE      = (1 &lt;&lt; 0),     <span class="comment">/* restore is running */</span>
<a name="l02186"></a>02186 };
<a name="l02187"></a>02187 
<a name="l02188"></a><a class="code" href="structmdt__body.html">02188</a> <span class="keyword">struct </span><a class="code" href="structmdt__body.html">mdt_body</a> {
<a name="l02189"></a>02189         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> mbo_fid1;
<a name="l02190"></a>02190         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> mbo_fid2;
<a name="l02191"></a>02191         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> mbo_handle;
<a name="l02192"></a>02192         __u64   mbo_valid;
<a name="l02193"></a>02193         __u64   mbo_size; <span class="comment">/* Offset, in the case of MDS_READPAGE */</span>
<a name="l02194"></a>02194         __s64   mbo_mtime;
<a name="l02195"></a>02195         __s64   mbo_atime;
<a name="l02196"></a>02196         __s64   mbo_ctime;
<a name="l02197"></a>02197         __u64   mbo_blocks; <span class="comment">/* XID, in the case of MDS_READPAGE */</span>
<a name="l02198"></a>02198         __u64   mbo_ioepoch;
<a name="l02199"></a>02199         __u64   mbo_t_state; <span class="comment">/* transient file state defined in</span>
<a name="l02200"></a>02200 <span class="comment">                              * enum md_transient_state</span>
<a name="l02201"></a>02201 <span class="comment">                              * was &quot;ino&quot; until 2.4.0 */</span>
<a name="l02202"></a>02202         __u32   mbo_fsuid;
<a name="l02203"></a>02203         __u32   mbo_fsgid;
<a name="l02204"></a>02204         __u32   mbo_capability;
<a name="l02205"></a>02205         __u32   mbo_mode;
<a name="l02206"></a>02206         __u32   mbo_uid;
<a name="l02207"></a>02207         __u32   mbo_gid;
<a name="l02208"></a>02208         __u32   mbo_flags;   <span class="comment">/* LUSTRE_*_FL file attributes */</span>
<a name="l02209"></a>02209         __u32   mbo_rdev;
<a name="l02210"></a>02210         __u32   mbo_nlink; <span class="comment">/* #bytes to read in the case of MDS_READPAGE */</span>
<a name="l02211"></a>02211         __u32   mbo_unused2; <span class="comment">/* was &quot;generation&quot; until 2.4.0 */</span>
<a name="l02212"></a>02212         __u32   mbo_suppgid;
<a name="l02213"></a>02213         __u32   mbo_eadatasize;
<a name="l02214"></a>02214         __u32   mbo_aclsize;
<a name="l02215"></a>02215         __u32   mbo_max_mdsize;
<a name="l02216"></a>02216         __u32   mbo_unused3; <span class="comment">/* was max_cookiesize until 2.8 */</span>
<a name="l02217"></a>02217         __u32   mbo_uid_h; <span class="comment">/* high 32-bits of uid, for FUID */</span>
<a name="l02218"></a>02218         __u32   mbo_gid_h; <span class="comment">/* high 32-bits of gid, for FUID */</span>
<a name="l02219"></a>02219         __u32   mbo_padding_5; <span class="comment">/* also fix lustre_swab_mdt_body */</span>
<a name="l02220"></a>02220         __u64   mbo_padding_6;
<a name="l02221"></a>02221         __u64   mbo_padding_7;
<a name="l02222"></a>02222         __u64   mbo_padding_8;
<a name="l02223"></a>02223         __u64   mbo_padding_9;
<a name="l02224"></a>02224         __u64   mbo_padding_10;
<a name="l02225"></a>02225 }; <span class="comment">/* 216 */</span>
<a name="l02226"></a>02226 
<a name="l02227"></a><a class="code" href="structmdt__ioepoch.html">02227</a> <span class="keyword">struct </span><a class="code" href="structmdt__ioepoch.html">mdt_ioepoch</a> {
<a name="l02228"></a>02228         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> mio_handle;
<a name="l02229"></a>02229         __u64 mio_unused1; <span class="comment">/* was ioepoch */</span>
<a name="l02230"></a>02230         __u32 mio_unused2; <span class="comment">/* was flags */</span>
<a name="l02231"></a>02231         __u32 mio_padding;
<a name="l02232"></a>02232 };
<a name="l02233"></a>02233 
<a name="l02234"></a>02234 <span class="comment">/* permissions for md_perm.mp_perm */</span>
<a name="l02235"></a>02235 <span class="keyword">enum</span> {
<a name="l02236"></a>02236         CFS_SETUID_PERM = 0x01,
<a name="l02237"></a>02237         CFS_SETGID_PERM = 0x02,
<a name="l02238"></a>02238         CFS_SETGRP_PERM = 0x04,
<a name="l02239"></a>02239         CFS_RMTACL_PERM = 0x08,
<a name="l02240"></a>02240         CFS_RMTOWN_PERM = 0x10
<a name="l02241"></a>02241 };
<a name="l02242"></a>02242 
<a name="l02243"></a>02243 <span class="comment">/* inode access permission for remote user, the inode info are omitted,</span>
<a name="l02244"></a>02244 <span class="comment"> * for client knows them. */</span>
<a name="l02245"></a><a class="code" href="structmdt__remote__perm.html">02245</a> <span class="keyword">struct </span><a class="code" href="structmdt__remote__perm.html">mdt_remote_perm</a> {
<a name="l02246"></a>02246         __u32           rp_uid;
<a name="l02247"></a>02247         __u32           rp_gid;
<a name="l02248"></a>02248         __u32           rp_fsuid;
<a name="l02249"></a>02249         __u32           rp_fsuid_h;
<a name="l02250"></a>02250         __u32           rp_fsgid;
<a name="l02251"></a>02251         __u32           rp_fsgid_h;
<a name="l02252"></a>02252         __u32           rp_access_perm; <span class="comment">/* MAY_READ/WRITE/EXEC */</span>
<a name="l02253"></a>02253         __u32           rp_padding;
<a name="l02254"></a>02254 };
<a name="l02255"></a>02255 
<a name="l02256"></a><a class="code" href="structmdt__rec__setattr.html">02256</a> <span class="keyword">struct </span><a class="code" href="structmdt__rec__setattr.html">mdt_rec_setattr</a> {
<a name="l02257"></a>02257         __u32           sa_opcode;
<a name="l02258"></a>02258         __u32           sa_cap;
<a name="l02259"></a>02259         __u32           sa_fsuid;
<a name="l02260"></a>02260         __u32           sa_fsuid_h;
<a name="l02261"></a>02261         __u32           sa_fsgid;
<a name="l02262"></a>02262         __u32           sa_fsgid_h;
<a name="l02263"></a>02263         __u32           sa_suppgid;
<a name="l02264"></a>02264         __u32           sa_suppgid_h;
<a name="l02265"></a>02265         __u32           sa_padding_1;
<a name="l02266"></a>02266         __u32           sa_padding_1_h;
<a name="l02267"></a>02267         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   sa_fid;
<a name="l02268"></a>02268         __u64           sa_valid;
<a name="l02269"></a>02269         __u32           sa_uid;
<a name="l02270"></a>02270         __u32           sa_gid;
<a name="l02271"></a>02271         __u64           sa_size;
<a name="l02272"></a>02272         __u64           sa_blocks;
<a name="l02273"></a>02273         __s64           sa_mtime;
<a name="l02274"></a>02274         __s64           sa_atime;
<a name="l02275"></a>02275         __s64           sa_ctime;
<a name="l02276"></a>02276         __u32           sa_attr_flags;
<a name="l02277"></a>02277         __u32           sa_mode;
<a name="l02278"></a>02278         __u32           sa_bias;      <span class="comment">/* some operation flags */</span>
<a name="l02279"></a>02279         __u32           sa_padding_3;
<a name="l02280"></a>02280         __u32           sa_padding_4;
<a name="l02281"></a>02281         __u32           sa_padding_5;
<a name="l02282"></a>02282 };
<a name="l02283"></a>02283 
<a name="l02284"></a>02284 <span class="comment">/*</span>
<a name="l02285"></a>02285 <span class="comment"> * Attribute flags used in mdt_rec_setattr::sa_valid.</span>
<a name="l02286"></a>02286 <span class="comment"> * The kernel&apos;s #defines for ATTR_* should not be used over the network</span>
<a name="l02287"></a>02287 <span class="comment"> * since the client and MDS may run different kernels (see bug 13828)</span>
<a name="l02288"></a>02288 <span class="comment"> * Therefore, we should only use MDS_ATTR_* attributes for sa_valid.</span>
<a name="l02289"></a>02289 <span class="comment"> */</span>
<a name="l02290"></a>02290 <span class="preprocessor">#define MDS_ATTR_MODE          0x1ULL </span><span class="comment">/* = 1 */</span>
<a name="l02291"></a>02291 <span class="preprocessor">#define MDS_ATTR_UID           0x2ULL </span><span class="comment">/* = 2 */</span>
<a name="l02292"></a>02292 <span class="preprocessor">#define MDS_ATTR_GID           0x4ULL </span><span class="comment">/* = 4 */</span>
<a name="l02293"></a>02293 <span class="preprocessor">#define MDS_ATTR_SIZE          0x8ULL </span><span class="comment">/* = 8 */</span>
<a name="l02294"></a>02294 <span class="preprocessor">#define MDS_ATTR_ATIME        0x10ULL </span><span class="comment">/* = 16 */</span>
<a name="l02295"></a>02295 <span class="preprocessor">#define MDS_ATTR_MTIME        0x20ULL </span><span class="comment">/* = 32 */</span>
<a name="l02296"></a>02296 <span class="preprocessor">#define MDS_ATTR_CTIME        0x40ULL </span><span class="comment">/* = 64 */</span>
<a name="l02297"></a>02297 <span class="preprocessor">#define MDS_ATTR_ATIME_SET    0x80ULL </span><span class="comment">/* = 128 */</span>
<a name="l02298"></a>02298 <span class="preprocessor">#define MDS_ATTR_MTIME_SET   0x100ULL </span><span class="comment">/* = 256 */</span>
<a name="l02299"></a>02299 <span class="preprocessor">#define MDS_ATTR_FORCE       0x200ULL </span><span class="comment">/* = 512, Not a change, but a change it */</span>
<a name="l02300"></a>02300 <span class="preprocessor">#define MDS_ATTR_ATTR_FLAG   0x400ULL </span><span class="comment">/* = 1024 */</span>
<a name="l02301"></a>02301 <span class="preprocessor">#define MDS_ATTR_KILL_SUID   0x800ULL </span><span class="comment">/* = 2048 */</span>
<a name="l02302"></a>02302 <span class="preprocessor">#define MDS_ATTR_KILL_SGID  0x1000ULL </span><span class="comment">/* = 4096 */</span>
<a name="l02303"></a>02303 <span class="preprocessor">#define MDS_ATTR_CTIME_SET  0x2000ULL </span><span class="comment">/* = 8192 */</span>
<a name="l02304"></a>02304 <span class="preprocessor">#define MDS_ATTR_FROM_OPEN  0x4000ULL </span><span class="comment">/* = 16384, called from open path, ie O_TRUNC */</span>
<a name="l02305"></a>02305 <span class="preprocessor">#define MDS_ATTR_BLOCKS     0x8000ULL </span><span class="comment">/* = 32768 */</span>
<a name="l02306"></a>02306 
<a name="l02307"></a>02307 <span class="preprocessor">#ifndef FMODE_READ</span>
<a name="l02308"></a>02308 <span class="preprocessor"></span><span class="preprocessor">#define FMODE_READ               00000001</span>
<a name="l02309"></a>02309 <span class="preprocessor"></span><span class="preprocessor">#define FMODE_WRITE              00000002</span>
<a name="l02310"></a>02310 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02311"></a>02311 <span class="preprocessor"></span>
<a name="l02312"></a>02312 <span class="preprocessor">#define MDS_FMODE_CLOSED         00000000</span>
<a name="l02313"></a>02313 <span class="preprocessor"></span><span class="preprocessor">#define MDS_FMODE_EXEC           00000004</span>
<a name="l02314"></a>02314 <span class="preprocessor"></span><span class="comment">/*      MDS_FMODE_EPOCH          01000000 obsolete since 2.8.0 */</span>
<a name="l02315"></a>02315 <span class="comment">/*      MDS_FMODE_TRUNC          02000000 obsolete since 2.8.0 */</span>
<a name="l02316"></a>02316 <span class="comment">/*      MDS_FMODE_SOM            04000000 obsolete since 2.8.0 */</span>
<a name="l02317"></a>02317 
<a name="l02318"></a>02318 <span class="preprocessor">#define MDS_OPEN_CREATED         00000010</span>
<a name="l02319"></a>02319 <span class="preprocessor"></span><span class="preprocessor">#define MDS_OPEN_CROSS           00000020</span>
<a name="l02320"></a>02320 <span class="preprocessor"></span>
<a name="l02321"></a>02321 <span class="preprocessor">#define MDS_OPEN_CREAT           00000100</span>
<a name="l02322"></a>02322 <span class="preprocessor"></span><span class="preprocessor">#define MDS_OPEN_EXCL            00000200</span>
<a name="l02323"></a>02323 <span class="preprocessor"></span><span class="preprocessor">#define MDS_OPEN_TRUNC           00001000</span>
<a name="l02324"></a>02324 <span class="preprocessor"></span><span class="preprocessor">#define MDS_OPEN_APPEND          00002000</span>
<a name="l02325"></a>02325 <span class="preprocessor"></span><span class="preprocessor">#define MDS_OPEN_SYNC            00010000</span>
<a name="l02326"></a>02326 <span class="preprocessor"></span><span class="preprocessor">#define MDS_OPEN_DIRECTORY       00200000</span>
<a name="l02327"></a>02327 <span class="preprocessor"></span>
<a name="l02328"></a>02328 <span class="preprocessor">#define MDS_OPEN_BY_FID         040000000 </span><span class="comment">/* open_by_fid for known object */</span>
<a name="l02329"></a>02329 <span class="preprocessor">#define MDS_OPEN_DELAY_CREATE  0100000000 </span><span class="comment">/* delay initial object create */</span>
<a name="l02330"></a>02330 <span class="preprocessor">#define MDS_OPEN_OWNEROVERRIDE 0200000000 </span><span class="comment">/* NFSD rw-reopen ro file for owner */</span>
<a name="l02331"></a>02331 <span class="preprocessor">#define MDS_OPEN_JOIN_FILE     0400000000 </span><span class="comment">/* open for join file.</span>
<a name="l02332"></a>02332 <span class="comment">                                           * We do not support JOIN FILE</span>
<a name="l02333"></a>02333 <span class="comment">                                           * anymore, reserve this flags</span>
<a name="l02334"></a>02334 <span class="comment">                                           * just for preventing such bit</span>
<a name="l02335"></a>02335 <span class="comment">                                           * to be reused. */</span>
<a name="l02336"></a>02336 
<a name="l02337"></a>02337 <span class="preprocessor">#define MDS_OPEN_LOCK         04000000000 </span><span class="comment">/* This open requires open lock */</span>
<a name="l02338"></a>02338 <span class="preprocessor">#define MDS_OPEN_HAS_EA      010000000000 </span><span class="comment">/* specify object create pattern */</span>
<a name="l02339"></a>02339 <span class="preprocessor">#define MDS_OPEN_HAS_OBJS    020000000000 </span><span class="comment">/* Just set the EA the obj exist */</span>
<a name="l02340"></a>02340 <span class="preprocessor">#define MDS_OPEN_NORESTORE  0100000000000ULL </span><span class="comment">/* Do not restore file at open */</span>
<a name="l02341"></a>02341 <span class="preprocessor">#define MDS_OPEN_NEWSTRIPE  0200000000000ULL </span><span class="comment">/* New stripe needed (restripe or</span>
<a name="l02342"></a>02342 <span class="comment">                                              * hsm restore) */</span>
<a name="l02343"></a>02343 <span class="preprocessor">#define MDS_OPEN_VOLATILE   0400000000000ULL </span><span class="comment">/* File is volatile = created</span>
<a name="l02344"></a>02344 <span class="comment">                                                unlinked */</span>
<a name="l02345"></a>02345 <span class="preprocessor">#define MDS_OPEN_LEASE     01000000000000ULL </span><span class="comment">/* Open the file and grant lease</span>
<a name="l02346"></a>02346 <span class="comment">                                              * delegation, succeed if it&apos;s not</span>
<a name="l02347"></a>02347 <span class="comment">                                              * being opened with conflict mode.</span>
<a name="l02348"></a>02348 <span class="comment">                                              */</span>
<a name="l02349"></a>02349 <span class="preprocessor">#define MDS_OPEN_RELEASE   02000000000000ULL </span><span class="comment">/* Open the file for HSM release */</span>
<a name="l02350"></a>02350 
<a name="l02351"></a>02351 <span class="comment">/* lustre internal open flags, which should not be set from user space */</span>
<a name="l02352"></a>02352 <span class="preprocessor">#define MDS_OPEN_FL_INTERNAL (MDS_OPEN_HAS_EA | MDS_OPEN_HAS_OBJS |     \</span>
<a name="l02353"></a>02353 <span class="preprocessor">                              MDS_OPEN_OWNEROVERRIDE | MDS_OPEN_LOCK |  \</span>
<a name="l02354"></a>02354 <span class="preprocessor">                              MDS_OPEN_BY_FID | MDS_OPEN_LEASE |        \</span>
<a name="l02355"></a>02355 <span class="preprocessor">                              MDS_OPEN_RELEASE)</span>
<a name="l02356"></a>02356 <span class="preprocessor"></span>
<a name="l02357"></a>02357 <span class="keyword">enum</span> mds_op_bias {
<a name="l02358"></a>02358         MDS_CHECK_SPLIT         = 1 &lt;&lt; 0,
<a name="l02359"></a>02359         MDS_CROSS_REF           = 1 &lt;&lt; 1,
<a name="l02360"></a>02360         MDS_VTX_BYPASS          = 1 &lt;&lt; 2,
<a name="l02361"></a>02361         MDS_PERM_BYPASS         = 1 &lt;&lt; 3,
<a name="l02362"></a>02362 <span class="comment">/*      MDS_SOM                 = 1 &lt;&lt; 4, obsolete since 2.8.0 */</span>
<a name="l02363"></a>02363         MDS_QUOTA_IGNORE        = 1 &lt;&lt; 5,
<a name="l02364"></a>02364         <span class="comment">/* Was MDS_CLOSE_CLEANUP (1 &lt;&lt; 6), No more used */</span>
<a name="l02365"></a>02365         MDS_KEEP_ORPHAN         = 1 &lt;&lt; 7,
<a name="l02366"></a>02366         MDS_RECOV_OPEN          = 1 &lt;&lt; 8,
<a name="l02367"></a>02367         MDS_DATA_MODIFIED       = 1 &lt;&lt; 9,
<a name="l02368"></a>02368         MDS_CREATE_VOLATILE     = 1 &lt;&lt; 10,
<a name="l02369"></a>02369         MDS_OWNEROVERRIDE       = 1 &lt;&lt; 11,
<a name="l02370"></a>02370         MDS_HSM_RELEASE         = 1 &lt;&lt; 12,
<a name="l02371"></a>02371         MDS_RENAME_MIGRATE      = 1 &lt;&lt; 13,
<a name="l02372"></a>02372         MDS_CLOSE_LAYOUT_SWAP   = 1 &lt;&lt; 14,
<a name="l02373"></a>02373 };
<a name="l02374"></a>02374 
<a name="l02375"></a>02375 <span class="comment">/* instance of mdt_reint_rec */</span>
<a name="l02376"></a><a class="code" href="structmdt__rec__create.html">02376</a> <span class="keyword">struct </span><a class="code" href="structmdt__rec__create.html">mdt_rec_create</a> {
<a name="l02377"></a>02377         __u32           cr_opcode;
<a name="l02378"></a>02378         __u32           cr_cap;
<a name="l02379"></a>02379         __u32           cr_fsuid;
<a name="l02380"></a>02380         __u32           cr_fsuid_h;
<a name="l02381"></a>02381         __u32           cr_fsgid;
<a name="l02382"></a>02382         __u32           cr_fsgid_h;
<a name="l02383"></a>02383         __u32           cr_suppgid1;
<a name="l02384"></a>02384         __u32           cr_suppgid1_h;
<a name="l02385"></a>02385         __u32           cr_suppgid2;
<a name="l02386"></a>02386         __u32           cr_suppgid2_h;
<a name="l02387"></a>02387         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   cr_fid1;
<a name="l02388"></a>02388         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   cr_fid2;
<a name="l02389"></a>02389         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> cr_old_handle; <span class="comment">/* handle in case of open replay */</span>
<a name="l02390"></a>02390         __s64           cr_time;
<a name="l02391"></a>02391         __u64           cr_rdev;
<a name="l02392"></a>02392         __u64           cr_ioepoch;
<a name="l02393"></a>02393         __u64           cr_padding_1;   <span class="comment">/* rr_blocks */</span>
<a name="l02394"></a>02394         __u32           cr_mode;
<a name="l02395"></a>02395         __u32           cr_bias;
<a name="l02396"></a>02396         <span class="comment">/* use of helpers set/get_mrc_cr_flags() is needed to access</span>
<a name="l02397"></a>02397 <span class="comment">         * 64 bits cr_flags [cr_flags_l, cr_flags_h], this is done to</span>
<a name="l02398"></a>02398 <span class="comment">         * extend cr_flags size without breaking 1.8 compat */</span>
<a name="l02399"></a>02399         __u32           cr_flags_l;     <span class="comment">/* for use with open, low  32 bits  */</span>
<a name="l02400"></a>02400         __u32           cr_flags_h;     <span class="comment">/* for use with open, high 32 bits */</span>
<a name="l02401"></a>02401         __u32           cr_umask;       <span class="comment">/* umask for create */</span>
<a name="l02402"></a>02402         __u32           cr_padding_4;   <span class="comment">/* rr_padding_4 */</span>
<a name="l02403"></a>02403 };
<a name="l02404"></a>02404 
<a name="l02405"></a>02405 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> set_mrc_cr_flags(<span class="keyword">struct</span> <a class="code" href="structmdt__rec__create.html">mdt_rec_create</a> *mrc, __u64 flags)
<a name="l02406"></a>02406 {
<a name="l02407"></a>02407         mrc-&gt;cr_flags_l = (__u32)(flags &amp; 0xFFFFFFFFUll);
<a name="l02408"></a>02408         mrc-&gt;cr_flags_h = (__u32)(flags &gt;&gt; 32);
<a name="l02409"></a>02409 }
<a name="l02410"></a>02410 
<a name="l02411"></a>02411 <span class="keyword">static</span> <span class="keyword">inline</span> __u64 get_mrc_cr_flags(<span class="keyword">struct</span> <a class="code" href="structmdt__rec__create.html">mdt_rec_create</a> *mrc)
<a name="l02412"></a>02412 {
<a name="l02413"></a>02413         <span class="keywordflow">return</span> ((__u64)(mrc-&gt;cr_flags_l) | ((__u64)mrc-&gt;cr_flags_h &lt;&lt; 32));
<a name="l02414"></a>02414 }
<a name="l02415"></a>02415 
<a name="l02416"></a>02416 <span class="comment">/* instance of mdt_reint_rec */</span>
<a name="l02417"></a><a class="code" href="structmdt__rec__link.html">02417</a> <span class="keyword">struct </span><a class="code" href="structmdt__rec__link.html">mdt_rec_link</a> {
<a name="l02418"></a>02418         __u32           lk_opcode;
<a name="l02419"></a>02419         __u32           lk_cap;
<a name="l02420"></a>02420         __u32           lk_fsuid;
<a name="l02421"></a>02421         __u32           lk_fsuid_h;
<a name="l02422"></a>02422         __u32           lk_fsgid;
<a name="l02423"></a>02423         __u32           lk_fsgid_h;
<a name="l02424"></a>02424         __u32           lk_suppgid1;
<a name="l02425"></a>02425         __u32           lk_suppgid1_h;
<a name="l02426"></a>02426         __u32           lk_suppgid2;
<a name="l02427"></a>02427         __u32           lk_suppgid2_h;
<a name="l02428"></a>02428         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   lk_fid1;
<a name="l02429"></a>02429         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   lk_fid2;
<a name="l02430"></a>02430         __s64           lk_time;
<a name="l02431"></a>02431         __u64           lk_padding_1;   <span class="comment">/* rr_atime */</span>
<a name="l02432"></a>02432         __u64           lk_padding_2;   <span class="comment">/* rr_ctime */</span>
<a name="l02433"></a>02433         __u64           lk_padding_3;   <span class="comment">/* rr_size */</span>
<a name="l02434"></a>02434         __u64           lk_padding_4;   <span class="comment">/* rr_blocks */</span>
<a name="l02435"></a>02435         __u32           lk_bias;
<a name="l02436"></a>02436         __u32           lk_padding_5;   <span class="comment">/* rr_mode */</span>
<a name="l02437"></a>02437         __u32           lk_padding_6;   <span class="comment">/* rr_flags */</span>
<a name="l02438"></a>02438         __u32           lk_padding_7;   <span class="comment">/* rr_padding_2 */</span>
<a name="l02439"></a>02439         __u32           lk_padding_8;   <span class="comment">/* rr_padding_3 */</span>
<a name="l02440"></a>02440         __u32           lk_padding_9;   <span class="comment">/* rr_padding_4 */</span>
<a name="l02441"></a>02441 };
<a name="l02442"></a>02442 
<a name="l02443"></a>02443 <span class="comment">/* instance of mdt_reint_rec */</span>
<a name="l02444"></a><a class="code" href="structmdt__rec__unlink.html">02444</a> <span class="keyword">struct </span><a class="code" href="structmdt__rec__unlink.html">mdt_rec_unlink</a> {
<a name="l02445"></a>02445         __u32           ul_opcode;
<a name="l02446"></a>02446         __u32           ul_cap;
<a name="l02447"></a>02447         __u32           ul_fsuid;
<a name="l02448"></a>02448         __u32           ul_fsuid_h;
<a name="l02449"></a>02449         __u32           ul_fsgid;
<a name="l02450"></a>02450         __u32           ul_fsgid_h;
<a name="l02451"></a>02451         __u32           ul_suppgid1;
<a name="l02452"></a>02452         __u32           ul_suppgid1_h;
<a name="l02453"></a>02453         __u32           ul_suppgid2;
<a name="l02454"></a>02454         __u32           ul_suppgid2_h;
<a name="l02455"></a>02455         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   ul_fid1;
<a name="l02456"></a>02456         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   ul_fid2;
<a name="l02457"></a>02457         __s64           ul_time;
<a name="l02458"></a>02458         __u64           ul_padding_2;   <span class="comment">/* rr_atime */</span>
<a name="l02459"></a>02459         __u64           ul_padding_3;   <span class="comment">/* rr_ctime */</span>
<a name="l02460"></a>02460         __u64           ul_padding_4;   <span class="comment">/* rr_size */</span>
<a name="l02461"></a>02461         __u64           ul_padding_5;   <span class="comment">/* rr_blocks */</span>
<a name="l02462"></a>02462         __u32           ul_bias;
<a name="l02463"></a>02463         __u32           ul_mode;
<a name="l02464"></a>02464         __u32           ul_padding_6;   <span class="comment">/* rr_flags */</span>
<a name="l02465"></a>02465         __u32           ul_padding_7;   <span class="comment">/* rr_padding_2 */</span>
<a name="l02466"></a>02466         __u32           ul_padding_8;   <span class="comment">/* rr_padding_3 */</span>
<a name="l02467"></a>02467         __u32           ul_padding_9;   <span class="comment">/* rr_padding_4 */</span>
<a name="l02468"></a>02468 };
<a name="l02469"></a>02469 
<a name="l02470"></a>02470 <span class="comment">/* instance of mdt_reint_rec */</span>
<a name="l02471"></a><a class="code" href="structmdt__rec__rename.html">02471</a> <span class="keyword">struct </span><a class="code" href="structmdt__rec__rename.html">mdt_rec_rename</a> {
<a name="l02472"></a>02472         __u32           rn_opcode;
<a name="l02473"></a>02473         __u32           rn_cap;
<a name="l02474"></a>02474         __u32           rn_fsuid;
<a name="l02475"></a>02475         __u32           rn_fsuid_h;
<a name="l02476"></a>02476         __u32           rn_fsgid;
<a name="l02477"></a>02477         __u32           rn_fsgid_h;
<a name="l02478"></a>02478         __u32           rn_suppgid1;
<a name="l02479"></a>02479         __u32           rn_suppgid1_h;
<a name="l02480"></a>02480         __u32           rn_suppgid2;
<a name="l02481"></a>02481         __u32           rn_suppgid2_h;
<a name="l02482"></a>02482         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   rn_fid1;
<a name="l02483"></a>02483         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   rn_fid2;
<a name="l02484"></a>02484         __s64           rn_time;
<a name="l02485"></a>02485         __u64           rn_padding_1;   <span class="comment">/* rr_atime */</span>
<a name="l02486"></a>02486         __u64           rn_padding_2;   <span class="comment">/* rr_ctime */</span>
<a name="l02487"></a>02487         __u64           rn_padding_3;   <span class="comment">/* rr_size */</span>
<a name="l02488"></a>02488         __u64           rn_padding_4;   <span class="comment">/* rr_blocks */</span>
<a name="l02489"></a>02489         __u32           rn_bias;        <span class="comment">/* some operation flags */</span>
<a name="l02490"></a>02490         __u32           rn_mode;        <span class="comment">/* cross-ref rename has mode */</span>
<a name="l02491"></a>02491         __u32           rn_padding_5;   <span class="comment">/* rr_flags */</span>
<a name="l02492"></a>02492         __u32           rn_padding_6;   <span class="comment">/* rr_padding_2 */</span>
<a name="l02493"></a>02493         __u32           rn_padding_7;   <span class="comment">/* rr_padding_3 */</span>
<a name="l02494"></a>02494         __u32           rn_padding_8;   <span class="comment">/* rr_padding_4 */</span>
<a name="l02495"></a>02495 };
<a name="l02496"></a>02496 
<a name="l02497"></a>02497 <span class="comment">/* instance of mdt_reint_rec */</span>
<a name="l02498"></a><a class="code" href="structmdt__rec__setxattr.html">02498</a> <span class="keyword">struct </span><a class="code" href="structmdt__rec__setxattr.html">mdt_rec_setxattr</a> {
<a name="l02499"></a>02499         __u32           sx_opcode;
<a name="l02500"></a>02500         __u32           sx_cap;
<a name="l02501"></a>02501         __u32           sx_fsuid;
<a name="l02502"></a>02502         __u32           sx_fsuid_h;
<a name="l02503"></a>02503         __u32           sx_fsgid;
<a name="l02504"></a>02504         __u32           sx_fsgid_h;
<a name="l02505"></a>02505         __u32           sx_suppgid1;
<a name="l02506"></a>02506         __u32           sx_suppgid1_h;
<a name="l02507"></a>02507         __u32           sx_suppgid2;
<a name="l02508"></a>02508         __u32           sx_suppgid2_h;
<a name="l02509"></a>02509         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   sx_fid;
<a name="l02510"></a>02510         __u64           sx_padding_1;   <span class="comment">/* These three are rr_fid2 */</span>
<a name="l02511"></a>02511         __u32           sx_padding_2;
<a name="l02512"></a>02512         __u32           sx_padding_3;
<a name="l02513"></a>02513         __u64           sx_valid;
<a name="l02514"></a>02514         __s64           sx_time;
<a name="l02515"></a>02515         __u64           sx_padding_5;   <span class="comment">/* rr_ctime */</span>
<a name="l02516"></a>02516         __u64           sx_padding_6;   <span class="comment">/* rr_size */</span>
<a name="l02517"></a>02517         __u64           sx_padding_7;   <span class="comment">/* rr_blocks */</span>
<a name="l02518"></a>02518         __u32           sx_size;
<a name="l02519"></a>02519         __u32           sx_flags;
<a name="l02520"></a>02520         __u32           sx_padding_8;   <span class="comment">/* rr_flags */</span>
<a name="l02521"></a>02521         __u32           sx_padding_9;   <span class="comment">/* rr_padding_2 */</span>
<a name="l02522"></a>02522         __u32           sx_padding_10;  <span class="comment">/* rr_padding_3 */</span>
<a name="l02523"></a>02523         __u32           sx_padding_11;  <span class="comment">/* rr_padding_4 */</span>
<a name="l02524"></a>02524 };
<a name="l02525"></a>02525 
<a name="l02526"></a>02526 <span class="comment">/*</span>
<a name="l02527"></a>02527 <span class="comment"> * mdt_rec_reint is the template for all mdt_reint_xxx structures.</span>
<a name="l02528"></a>02528 <span class="comment"> * Do NOT change the size of various members, otherwise the value</span>
<a name="l02529"></a>02529 <span class="comment"> * will be broken in lustre_swab_mdt_rec_reint().</span>
<a name="l02530"></a>02530 <span class="comment"> *</span>
<a name="l02531"></a>02531 <span class="comment"> * If you add new members in other mdt_reint_xxx structres and need to use the</span>
<a name="l02532"></a>02532 <span class="comment"> * rr_padding_x fields, then update lustre_swab_mdt_rec_reint() also.</span>
<a name="l02533"></a>02533 <span class="comment"> */</span>
<a name="l02534"></a><a class="code" href="structmdt__rec__reint.html">02534</a> <span class="keyword">struct </span><a class="code" href="structmdt__rec__reint.html">mdt_rec_reint</a> {
<a name="l02535"></a>02535         __u32           rr_opcode;
<a name="l02536"></a>02536         __u32           rr_cap;
<a name="l02537"></a>02537         __u32           rr_fsuid;
<a name="l02538"></a>02538         __u32           rr_fsuid_h;
<a name="l02539"></a>02539         __u32           rr_fsgid;
<a name="l02540"></a>02540         __u32           rr_fsgid_h;
<a name="l02541"></a>02541         __u32           rr_suppgid1;
<a name="l02542"></a>02542         __u32           rr_suppgid1_h;
<a name="l02543"></a>02543         __u32           rr_suppgid2;
<a name="l02544"></a>02544         __u32           rr_suppgid2_h;
<a name="l02545"></a>02545         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   rr_fid1;
<a name="l02546"></a>02546         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   rr_fid2;
<a name="l02547"></a>02547         __s64           rr_mtime;
<a name="l02548"></a>02548         __s64           rr_atime;
<a name="l02549"></a>02549         __s64           rr_ctime;
<a name="l02550"></a>02550         __u64           rr_size;
<a name="l02551"></a>02551         __u64           rr_blocks;
<a name="l02552"></a>02552         __u32           rr_bias;
<a name="l02553"></a>02553         __u32           rr_mode;
<a name="l02554"></a>02554         __u32           rr_flags;
<a name="l02555"></a>02555         __u32           rr_flags_h;
<a name="l02556"></a>02556         __u32           rr_umask;
<a name="l02557"></a>02557         __u32           rr_padding_4; <span class="comment">/* also fix lustre_swab_mdt_rec_reint */</span>
<a name="l02558"></a>02558 };
<a name="l02559"></a>02559 
<a name="l02560"></a>02560 <span class="comment">/* lmv structures */</span>
<a name="l02561"></a><a class="code" href="structlmv__desc.html">02561</a> <span class="keyword">struct </span><a class="code" href="structlmv__desc.html">lmv_desc</a> {
<a name="l02562"></a>02562         __u32 ld_tgt_count;                <span class="comment">/* how many MDS&apos;s */</span>
<a name="l02563"></a>02563         __u32 ld_active_tgt_count;         <span class="comment">/* how many active */</span>
<a name="l02564"></a>02564         __u32 ld_default_stripe_count;     <span class="comment">/* how many objects are used */</span>
<a name="l02565"></a>02565         __u32 ld_pattern;                  <span class="comment">/* default hash pattern */</span>
<a name="l02566"></a>02566         __u64 ld_default_hash_size;
<a name="l02567"></a>02567         __u64 ld_padding_1;                <span class="comment">/* also fix lustre_swab_lmv_desc */</span>
<a name="l02568"></a>02568         __u32 ld_padding_2;                <span class="comment">/* also fix lustre_swab_lmv_desc */</span>
<a name="l02569"></a>02569         __u32 ld_qos_maxage;               <span class="comment">/* in second */</span>
<a name="l02570"></a>02570         __u32 ld_padding_3;                <span class="comment">/* also fix lustre_swab_lmv_desc */</span>
<a name="l02571"></a>02571         __u32 ld_padding_4;                <span class="comment">/* also fix lustre_swab_lmv_desc */</span>
<a name="l02572"></a>02572         <span class="keyword">struct </span><a class="code" href="structobd__uuid.html">obd_uuid</a> ld_uuid;
<a name="l02573"></a>02573 };
<a name="l02574"></a>02574 
<a name="l02575"></a>02575 <span class="comment">/* LMV layout EA, and it will be stored both in master and slave object */</span>
<a name="l02576"></a><a class="code" href="structlmv__mds__md__v1.html">02576</a> <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a> {
<a name="l02577"></a>02577         __u32 lmv_magic;
<a name="l02578"></a>02578         __u32 lmv_stripe_count;
<a name="l02579"></a>02579         __u32 lmv_master_mdt_index;     <span class="comment">/* On master object, it is master</span>
<a name="l02580"></a>02580 <span class="comment">                                         * MDT index, on slave object, it</span>
<a name="l02581"></a>02581 <span class="comment">                                         * is stripe index of the slave obj */</span>
<a name="l02582"></a>02582         __u32 lmv_hash_type;            <span class="comment">/* dir stripe policy, i.e. indicate</span>
<a name="l02583"></a>02583 <span class="comment">                                         * which hash function to be used,</span>
<a name="l02584"></a>02584 <span class="comment">                                         * Note: only lower 16 bits is being</span>
<a name="l02585"></a>02585 <span class="comment">                                         * used for now. Higher 16 bits will</span>
<a name="l02586"></a>02586 <span class="comment">                                         * be used to mark the object status,</span>
<a name="l02587"></a>02587 <span class="comment">                                         * for example migrating or dead. */</span>
<a name="l02588"></a>02588         __u32 lmv_layout_version;       <span class="comment">/* Used for directory restriping */</span>
<a name="l02589"></a>02589         __u32 lmv_padding1;
<a name="l02590"></a>02590         __u64 lmv_padding2;
<a name="l02591"></a>02591         __u64 lmv_padding3;
<a name="l02592"></a>02592         <span class="keywordtype">char</span> lmv_pool_name[LOV_MAXPOOLNAME + 1];        <span class="comment">/* pool name */</span>
<a name="l02593"></a>02593         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> lmv_stripe_fids[0];       <span class="comment">/* FIDs for each stripe */</span>
<a name="l02594"></a>02594 };
<a name="l02595"></a>02595 
<a name="l02596"></a>02596 <span class="preprocessor">#define LMV_MAGIC_V1    0x0CD20CD0    </span><span class="comment">/* normal stripe lmv magic */</span>
<a name="l02597"></a>02597 <span class="preprocessor">#define LMV_MAGIC       LMV_MAGIC_V1</span>
<a name="l02598"></a>02598 <span class="preprocessor"></span>
<a name="l02599"></a>02599 <span class="comment">/* #define LMV_USER_MAGIC 0x0CD30CD0 */</span>
<a name="l02600"></a>02600 <span class="preprocessor">#define LMV_MAGIC_STRIPE 0x0CD40CD0 </span><span class="comment">/* magic for dir sub_stripe */</span>
<a name="l02601"></a>02601 
<a name="l02602"></a>02602 <span class="comment">/* Right now only the lower part(0-16bits) of lmv_hash_type is being used,</span>
<a name="l02603"></a>02603 <span class="comment"> * and the higher part will be the flag to indicate the status of object,</span>
<a name="l02604"></a>02604 <span class="comment"> * for example the object is being migrated. And the hash function</span>
<a name="l02605"></a>02605 <span class="comment"> * might be interpreted differently with different flags. */</span>
<a name="l02606"></a>02606 <span class="preprocessor">#define LMV_HASH_TYPE_MASK 0x0000ffff</span>
<a name="l02607"></a>02607 <span class="preprocessor"></span>
<a name="l02608"></a>02608 <span class="preprocessor">#define LMV_HASH_FLAG_MIGRATION 0x80000000</span>
<a name="l02609"></a>02609 <span class="preprocessor"></span>
<a name="l02610"></a>02610 <span class="preprocessor">#if LUSTRE_VERSION_CODE &lt; OBD_OCD_VERSION(2, 10, 53, 0)</span>
<a name="l02611"></a>02611 <span class="preprocessor"></span><span class="comment">/* Since lustre 2.8, this flag will not be needed, instead this DEAD</span>
<a name="l02612"></a>02612 <span class="comment"> * and orphan flags will be stored in LMA (see LMAI_ORPHAN)</span>
<a name="l02613"></a>02613 <span class="comment"> * Keep this flag just for LFSCK, because it still might meet such</span>
<a name="l02614"></a>02614 <span class="comment"> * flag when it checks the old FS */</span>
<a name="l02615"></a>02615 <span class="preprocessor">#define LMV_HASH_FLAG_DEAD      0x40000000</span>
<a name="l02616"></a>02616 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02617"></a>02617 <span class="preprocessor"></span><span class="preprocessor">#define LMV_HASH_FLAG_BAD_TYPE  0x20000000</span>
<a name="l02618"></a>02618 <span class="preprocessor"></span>
<a name="l02619"></a>02619 <span class="comment">/* The striped directory has ever lost its master LMV EA, then LFSCK</span>
<a name="l02620"></a>02620 <span class="comment"> * re-generated it. This flag is used to indicate such case. It is an</span>
<a name="l02621"></a>02621 <span class="comment"> * on-disk flag. */</span>
<a name="l02622"></a>02622 <span class="preprocessor">#define LMV_HASH_FLAG_LOST_LMV  0x10000000</span>
<a name="l02623"></a>02623 <span class="preprocessor"></span>
<a name="l02636"></a><a class="code" href="group__lustreidl.html#ga2774b7d1c0ebda1aaba7d0103f21cdec">02636</a> <span class="preprocessor">#define LUSTRE_FNV_1A_64_PRIME  0x100000001b3ULL</span>
<a name="l02637"></a>02637 <span class="preprocessor"></span><span class="preprocessor">#define LUSTRE_FNV_1A_64_OFFSET_BIAS 0xcbf29ce484222325ULL</span>
<a name="l02638"></a>02638 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> __u64 lustre_hash_fnv_1a_64(<span class="keyword">const</span> <span class="keywordtype">void</span> *buf, <span class="keywordtype">size_t</span> size)
<a name="l02639"></a>02639 {
<a name="l02640"></a>02640         __u64 hash = LUSTRE_FNV_1A_64_OFFSET_BIAS;
<a name="l02641"></a>02641         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p = buf;
<a name="l02642"></a>02642         <span class="keywordtype">size_t</span> i;
<a name="l02643"></a>02643 
<a name="l02644"></a>02644         <span class="keywordflow">for</span> (i = 0; i &lt; size; i++) {
<a name="l02645"></a>02645                 hash ^= p[i];
<a name="l02646"></a>02646                 hash *= <a class="code" href="group__lustreidl.html#ga2774b7d1c0ebda1aaba7d0103f21cdec" title="The FNV-1a hash algorithm is as follows: hash = FNV_offset_basis for each octet_of_data...">LUSTRE_FNV_1A_64_PRIME</a>;
<a name="l02647"></a>02647         }
<a name="l02648"></a>02648 
<a name="l02649"></a>02649         <span class="keywordflow">return</span> hash;
<a name="l02650"></a>02650 }
<a name="l02651"></a>02651 
<a name="l02652"></a><a class="code" href="unionlmv__mds__md.html">02652</a> <span class="keyword">union </span><a class="code" href="unionlmv__mds__md.html">lmv_mds_md</a> {
<a name="l02653"></a>02653         __u32                    lmv_magic;
<a name="l02654"></a>02654         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>     lmv_md_v1;
<a name="l02655"></a>02655         <span class="keyword">struct </span>lmv_user_md       lmv_user_md;
<a name="l02656"></a>02656 };
<a name="l02657"></a>02657 
<a name="l02658"></a>02658 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lmv_mds_md_size(<span class="keywordtype">int</span> stripe_count, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lmm_magic)
<a name="l02659"></a>02659 {
<a name="l02660"></a>02660         <span class="keywordflow">switch</span> (lmm_magic) {
<a name="l02661"></a>02661         <span class="keywordflow">case</span> LMV_MAGIC_V1:{
<a name="l02662"></a>02662                 <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a> *lmm1;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664                 <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(*lmm1) + stripe_count *
<a name="l02665"></a>02665                                        <span class="keyword">sizeof</span>(lmm1-&gt;lmv_stripe_fids[0]);
<a name="l02666"></a>02666         }
<a name="l02667"></a>02667         <span class="keywordflow">default</span>:
<a name="l02668"></a>02668                 <span class="keywordflow">return</span> -EINVAL;
<a name="l02669"></a>02669         }
<a name="l02670"></a>02670 }
<a name="l02671"></a>02671 
<a name="l02672"></a>02672 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lmv_mds_md_stripe_count_get(<span class="keyword">const</span> <span class="keyword">union</span> <a class="code" href="unionlmv__mds__md.html">lmv_mds_md</a> *lmm)
<a name="l02673"></a>02673 {
<a name="l02674"></a>02674         <span class="keywordflow">switch</span> (le32_to_cpu(lmm-&gt;lmv_magic)) {
<a name="l02675"></a>02675         <span class="keywordflow">case</span> LMV_MAGIC_V1:
<a name="l02676"></a>02676                 <span class="keywordflow">return</span> le32_to_cpu(lmm-&gt;lmv_md_v1.lmv_stripe_count);
<a name="l02677"></a>02677         <span class="keywordflow">case</span> LMV_USER_MAGIC:
<a name="l02678"></a>02678                 <span class="keywordflow">return</span> le32_to_cpu(lmm-&gt;lmv_user_md.lum_stripe_count);
<a name="l02679"></a>02679         <span class="keywordflow">default</span>:
<a name="l02680"></a>02680                 <span class="keywordflow">return</span> -EINVAL;
<a name="l02681"></a>02681         }
<a name="l02682"></a>02682 }
<a name="l02683"></a>02683 
<a name="l02684"></a>02684 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lmv_mds_md_stripe_count_set(<span class="keyword">union</span> <a class="code" href="unionlmv__mds__md.html">lmv_mds_md</a> *lmm,
<a name="l02685"></a>02685                                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stripe_count)
<a name="l02686"></a>02686 {
<a name="l02687"></a>02687         <span class="keywordflow">switch</span> (le32_to_cpu(lmm-&gt;lmv_magic)) {
<a name="l02688"></a>02688         <span class="keywordflow">case</span> LMV_MAGIC_V1:
<a name="l02689"></a>02689                 lmm-&gt;lmv_md_v1.lmv_stripe_count = cpu_to_le32(stripe_count);
<a name="l02690"></a>02690                 <span class="keywordflow">break</span>;
<a name="l02691"></a>02691         <span class="keywordflow">case</span> LMV_USER_MAGIC:
<a name="l02692"></a>02692                 lmm-&gt;lmv_user_md.lum_stripe_count = cpu_to_le32(stripe_count);
<a name="l02693"></a>02693                 <span class="keywordflow">break</span>;
<a name="l02694"></a>02694         <span class="keywordflow">default</span>:
<a name="l02695"></a>02695                 <span class="keywordflow">return</span> -EINVAL;
<a name="l02696"></a>02696         }
<a name="l02697"></a>02697         <span class="keywordflow">return</span> 0;
<a name="l02698"></a>02698 }
<a name="l02699"></a>02699 
<a name="l02700"></a>02700 <span class="keyword">enum</span> fld_rpc_opc {
<a name="l02701"></a>02701         FLD_QUERY       = 900,
<a name="l02702"></a>02702         FLD_READ        = 901,
<a name="l02703"></a>02703         FLD_LAST_OPC,
<a name="l02704"></a>02704         FLD_FIRST_OPC   = FLD_QUERY
<a name="l02705"></a>02705 };
<a name="l02706"></a>02706 
<a name="l02707"></a>02707 <span class="keyword">enum</span> seq_rpc_opc {
<a name="l02708"></a>02708         SEQ_QUERY                       = 700,
<a name="l02709"></a>02709         SEQ_LAST_OPC,
<a name="l02710"></a>02710         SEQ_FIRST_OPC                   = SEQ_QUERY
<a name="l02711"></a>02711 };
<a name="l02712"></a>02712 
<a name="l02713"></a>02713 <span class="keyword">enum</span> seq_op {
<a name="l02714"></a>02714         SEQ_ALLOC_SUPER = 0,
<a name="l02715"></a>02715         SEQ_ALLOC_META = 1
<a name="l02716"></a>02716 };
<a name="l02717"></a>02717 
<a name="l02718"></a>02718 <span class="keyword">enum</span> fld_op {
<a name="l02719"></a>02719         FLD_CREATE = 0,
<a name="l02720"></a>02720         FLD_DELETE = 1,
<a name="l02721"></a>02721         FLD_LOOKUP = 2,
<a name="l02722"></a>02722 };
<a name="l02723"></a>02723 
<a name="l02724"></a>02724 <span class="comment">/* LFSCK opcodes */</span>
<a name="l02725"></a>02725 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l02726"></a>02726         LFSCK_NOTIFY            = 1101,
<a name="l02727"></a>02727         LFSCK_QUERY             = 1102,
<a name="l02728"></a>02728         LFSCK_LAST_OPC,
<a name="l02729"></a>02729         LFSCK_FIRST_OPC         = LFSCK_NOTIFY
<a name="l02730"></a>02730 } lfsck_cmd_t;
<a name="l02731"></a>02731 
<a name="l02732"></a>02732 <span class="comment">/*</span>
<a name="l02733"></a>02733 <span class="comment"> *  LOV data structures</span>
<a name="l02734"></a>02734 <span class="comment"> */</span>
<a name="l02735"></a>02735 
<a name="l02736"></a>02736 <span class="preprocessor">#define LOV_MAX_UUID_BUFFER_SIZE  8192</span>
<a name="l02737"></a>02737 <span class="preprocessor"></span><span class="comment">/* The size of the buffer the lov/mdc reserves for the</span>
<a name="l02738"></a>02738 <span class="comment"> * array of UUIDs returned by the MDS.  With the current</span>
<a name="l02739"></a>02739 <span class="comment"> * protocol, this will limit the max number of OSTs per LOV */</span>
<a name="l02740"></a>02740 
<a name="l02741"></a>02741 <span class="preprocessor">#define LOV_DESC_MAGIC 0xB0CCDE5C</span>
<a name="l02742"></a>02742 <span class="preprocessor"></span><span class="preprocessor">#define LOV_DESC_QOS_MAXAGE_DEFAULT 5  </span><span class="comment">/* Seconds */</span>
<a name="l02743"></a>02743 <span class="preprocessor">#define LOV_DESC_STRIPE_SIZE_DEFAULT (1 &lt;&lt; LNET_MTU_BITS)</span>
<a name="l02744"></a>02744 <span class="preprocessor"></span>
<a name="l02745"></a>02745 <span class="comment">/* LOV settings descriptor (should only contain static info) */</span>
<a name="l02746"></a><a class="code" href="structlov__desc.html">02746</a> <span class="keyword">struct </span><a class="code" href="structlov__desc.html">lov_desc</a> {
<a name="l02747"></a>02747         __u32 ld_tgt_count;                <span class="comment">/* how many OBD&apos;s */</span>
<a name="l02748"></a>02748         __u32 ld_active_tgt_count;         <span class="comment">/* how many active */</span>
<a name="l02749"></a>02749         __u32 ld_default_stripe_count;     <span class="comment">/* how many objects are used */</span>
<a name="l02750"></a>02750         __u32 ld_pattern;                  <span class="comment">/* default PATTERN_RAID0 */</span>
<a name="l02751"></a>02751         __u64 ld_default_stripe_size;      <span class="comment">/* in bytes */</span>
<a name="l02752"></a>02752         __u64 ld_default_stripe_offset;    <span class="comment">/* in bytes */</span>
<a name="l02753"></a>02753         __u32 ld_padding_0;                <span class="comment">/* unused */</span>
<a name="l02754"></a>02754         __u32 ld_qos_maxage;               <span class="comment">/* in second */</span>
<a name="l02755"></a>02755         __u32 ld_padding_1;                <span class="comment">/* also fix lustre_swab_lov_desc */</span>
<a name="l02756"></a>02756         __u32 ld_padding_2;                <span class="comment">/* also fix lustre_swab_lov_desc */</span>
<a name="l02757"></a>02757         <span class="keyword">struct </span><a class="code" href="structobd__uuid.html">obd_uuid</a> ld_uuid;
<a name="l02758"></a>02758 };
<a name="l02759"></a>02759 
<a name="l02760"></a>02760 <span class="preprocessor">#define ld_magic ld_active_tgt_count       </span><span class="comment">/* for swabbing from llogs */</span>
<a name="l02761"></a>02761 
<a name="l02762"></a>02762 <span class="comment">/*</span>
<a name="l02763"></a>02763 <span class="comment"> *   LDLM requests:</span>
<a name="l02764"></a>02764 <span class="comment"> */</span>
<a name="l02765"></a>02765 <span class="comment">/* opcodes -- MUST be distinct from OST/MDS opcodes */</span>
<a name="l02766"></a>02766 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l02767"></a>02767         LDLM_ENQUEUE     = 101,
<a name="l02768"></a>02768         LDLM_CONVERT     = 102,
<a name="l02769"></a>02769         LDLM_CANCEL      = 103,
<a name="l02770"></a>02770         LDLM_BL_CALLBACK = 104,
<a name="l02771"></a>02771         LDLM_CP_CALLBACK = 105,
<a name="l02772"></a>02772         LDLM_GL_CALLBACK = 106,
<a name="l02773"></a>02773         LDLM_SET_INFO    = 107,
<a name="l02774"></a>02774         LDLM_LAST_OPC
<a name="l02775"></a>02775 } ldlm_cmd_t;
<a name="l02776"></a>02776 <span class="preprocessor">#define LDLM_FIRST_OPC LDLM_ENQUEUE</span>
<a name="l02777"></a>02777 <span class="preprocessor"></span>
<a name="l02778"></a>02778 <span class="preprocessor">#define RES_NAME_SIZE 4</span>
<a name="l02779"></a><a class="code" href="structldlm__res__id.html">02779</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structldlm__res__id.html">ldlm_res_id</a> {
<a name="l02780"></a>02780         __u64 name[RES_NAME_SIZE];
<a name="l02781"></a>02781 };
<a name="l02782"></a>02782 
<a name="l02783"></a>02783 <span class="preprocessor">#define DLDLMRES        &quot;[%#llx:%#llx:%#llx].%#llx&quot;</span>
<a name="l02784"></a>02784 <span class="preprocessor"></span><span class="preprocessor">#define PLDLMRES(res)   (unsigned long long)(res)-&gt;lr_name.name[0],     \</span>
<a name="l02785"></a>02785 <span class="preprocessor">                        (unsigned long long)(res)-&gt;lr_name.name[1],     \</span>
<a name="l02786"></a>02786 <span class="preprocessor">                        (unsigned long long)(res)-&gt;lr_name.name[2],     \</span>
<a name="l02787"></a>02787 <span class="preprocessor">                        (unsigned long long)(res)-&gt;lr_name.name[3]</span>
<a name="l02788"></a>02788 <span class="preprocessor"></span>
<a name="l02789"></a>02789 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ldlm_res_eq(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structldlm__res__id.html">ldlm_res_id</a> *res0,
<a name="l02790"></a>02790                                <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structldlm__res__id.html">ldlm_res_id</a> *res1)
<a name="l02791"></a>02791 {
<a name="l02792"></a>02792         <span class="keywordflow">return</span> memcmp(res0, res1, <span class="keyword">sizeof</span>(*res0)) == 0;
<a name="l02793"></a>02793 }
<a name="l02794"></a>02794 
<a name="l02795"></a>02795 <span class="comment">/* lock types */</span>
<a name="l02796"></a>02796 <span class="keyword">typedef</span> <span class="keyword">enum</span> ldlm_mode {
<a name="l02797"></a>02797         LCK_MINMODE     = 0,
<a name="l02798"></a>02798         LCK_EX          = 1,
<a name="l02799"></a>02799         LCK_PW          = 2,
<a name="l02800"></a>02800         LCK_PR          = 4,
<a name="l02801"></a>02801         LCK_CW          = 8,
<a name="l02802"></a>02802         LCK_CR          = 16,
<a name="l02803"></a>02803         LCK_NL          = 32,
<a name="l02804"></a>02804         LCK_GROUP       = 64,
<a name="l02805"></a>02805         LCK_COS         = 128,
<a name="l02806"></a>02806         LCK_MAXMODE
<a name="l02807"></a>02807 } ldlm_mode_t;
<a name="l02808"></a>02808 
<a name="l02809"></a>02809 <span class="preprocessor">#define LCK_MODE_NUM    8</span>
<a name="l02810"></a>02810 <span class="preprocessor"></span>
<a name="l02811"></a>02811 <span class="keyword">typedef</span> <span class="keyword">enum</span> ldlm_type {
<a name="l02812"></a>02812         LDLM_PLAIN      = 10,
<a name="l02813"></a>02813         LDLM_EXTENT     = 11,
<a name="l02814"></a>02814         LDLM_FLOCK      = 12,
<a name="l02815"></a>02815         LDLM_IBITS      = 13,
<a name="l02816"></a>02816         LDLM_MAX_TYPE
<a name="l02817"></a>02817 } ldlm_type_t;
<a name="l02818"></a>02818 
<a name="l02819"></a>02819 <span class="preprocessor">#define LDLM_MIN_TYPE LDLM_PLAIN</span>
<a name="l02820"></a>02820 <span class="preprocessor"></span>
<a name="l02821"></a><a class="code" href="structldlm__extent.html">02821</a> <span class="keyword">struct </span><a class="code" href="structldlm__extent.html">ldlm_extent</a> {
<a name="l02822"></a>02822         __u64 start;
<a name="l02823"></a>02823         __u64 end;
<a name="l02824"></a>02824         __u64 gid;
<a name="l02825"></a>02825 };
<a name="l02826"></a>02826 
<a name="l02827"></a>02827 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ldlm_extent_overlap(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structldlm__extent.html">ldlm_extent</a> *ex1,
<a name="l02828"></a>02828                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structldlm__extent.html">ldlm_extent</a> *ex2)
<a name="l02829"></a>02829 {
<a name="l02830"></a>02830         <span class="keywordflow">return</span> ex1-&gt;start &lt;= ex2-&gt;end &amp;&amp; ex2-&gt;start &lt;= ex1-&gt;end;
<a name="l02831"></a>02831 }
<a name="l02832"></a>02832 
<a name="l02833"></a>02833 <span class="comment">/* check if @ex1 contains @ex2 */</span>
<a name="l02834"></a>02834 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ldlm_extent_contain(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structldlm__extent.html">ldlm_extent</a> *ex1,
<a name="l02835"></a>02835                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structldlm__extent.html">ldlm_extent</a> *ex2)
<a name="l02836"></a>02836 {
<a name="l02837"></a>02837         <span class="keywordflow">return</span> ex1-&gt;start &lt;= ex2-&gt;start &amp;&amp; ex1-&gt;end &gt;= ex2-&gt;end;
<a name="l02838"></a>02838 }
<a name="l02839"></a>02839 
<a name="l02840"></a><a class="code" href="structldlm__inodebits.html">02840</a> <span class="keyword">struct </span><a class="code" href="structldlm__inodebits.html">ldlm_inodebits</a> {
<a name="l02841"></a>02841         __u64 bits;
<a name="l02842"></a>02842 };
<a name="l02843"></a>02843 
<a name="l02844"></a><a class="code" href="structldlm__flock__wire.html">02844</a> <span class="keyword">struct </span><a class="code" href="structldlm__flock__wire.html">ldlm_flock_wire</a> {
<a name="l02845"></a>02845         __u64 lfw_start;
<a name="l02846"></a>02846         __u64 lfw_end;
<a name="l02847"></a>02847         __u64 lfw_owner;
<a name="l02848"></a>02848         __u32 lfw_padding;
<a name="l02849"></a>02849         __u32 lfw_pid;
<a name="l02850"></a>02850 };
<a name="l02851"></a>02851 
<a name="l02852"></a>02852 <span class="comment">/* it&apos;s important that the fields of the ldlm_extent structure match</span>
<a name="l02853"></a>02853 <span class="comment"> * the first fields of the ldlm_flock structure because there is only</span>
<a name="l02854"></a>02854 <span class="comment"> * one ldlm_swab routine to process the ldlm_policy_data_t union. if</span>
<a name="l02855"></a>02855 <span class="comment"> * this ever changes we will need to swab the union differently based</span>
<a name="l02856"></a>02856 <span class="comment"> * on the resource type. */</span>
<a name="l02857"></a>02857 
<a name="l02858"></a><a class="code" href="unionldlm__wire__policy__data.html">02858</a> <span class="keyword">typedef</span> <span class="keyword">union </span><a class="code" href="unionldlm__wire__policy__data.html">ldlm_wire_policy_data</a> {
<a name="l02859"></a>02859         <span class="keyword">struct </span><a class="code" href="structldlm__extent.html">ldlm_extent</a>      l_extent;
<a name="l02860"></a>02860         <span class="keyword">struct </span><a class="code" href="structldlm__flock__wire.html">ldlm_flock_wire</a>  l_flock;
<a name="l02861"></a>02861         <span class="keyword">struct </span><a class="code" href="structldlm__inodebits.html">ldlm_inodebits</a>   l_inodebits;
<a name="l02862"></a>02862 } <a class="code" href="unionldlm__wire__policy__data.html">ldlm_wire_policy_data_t</a>;
<a name="l02863"></a>02863 
<a name="l02864"></a><a class="code" href="unionldlm__gl__desc.html">02864</a> <span class="keyword">union </span><a class="code" href="unionldlm__gl__desc.html">ldlm_gl_desc</a> {
<a name="l02865"></a>02865         <span class="keyword">struct </span><a class="code" href="structldlm__gl__lquota__desc.html">ldlm_gl_lquota_desc</a>      lquota_desc;
<a name="l02866"></a>02866 };
<a name="l02867"></a>02867 
<a name="l02868"></a>02868 <span class="keyword">enum</span> ldlm_intent_flags {
<a name="l02869"></a>02869         IT_OPEN        = 0x00000001,
<a name="l02870"></a>02870         IT_CREAT       = 0x00000002,
<a name="l02871"></a>02871         IT_OPEN_CREAT  = 0x00000003,
<a name="l02872"></a>02872         IT_READDIR     = 0x00000004,
<a name="l02873"></a>02873         IT_GETATTR     = 0x00000008,
<a name="l02874"></a>02874         IT_LOOKUP      = 0x00000010,
<a name="l02875"></a>02875         IT_UNLINK      = 0x00000020,
<a name="l02876"></a>02876         IT_TRUNC       = 0x00000040,
<a name="l02877"></a>02877         IT_GETXATTR    = 0x00000080,
<a name="l02878"></a>02878         IT_EXEC        = 0x00000100,
<a name="l02879"></a>02879         IT_PIN         = 0x00000200,
<a name="l02880"></a>02880         IT_LAYOUT      = 0x00000400,
<a name="l02881"></a>02881         IT_QUOTA_DQACQ = 0x00000800,
<a name="l02882"></a>02882         IT_QUOTA_CONN  = 0x00001000,
<a name="l02883"></a>02883         IT_SETXATTR    = 0x00002000,
<a name="l02884"></a>02884 };
<a name="l02885"></a>02885 
<a name="l02886"></a><a class="code" href="structldlm__intent.html">02886</a> <span class="keyword">struct </span><a class="code" href="structldlm__intent.html">ldlm_intent</a> {
<a name="l02887"></a>02887         __u64 opc;
<a name="l02888"></a>02888 };
<a name="l02889"></a>02889 
<a name="l02890"></a><a class="code" href="structldlm__resource__desc.html">02890</a> <span class="keyword">struct </span><a class="code" href="structldlm__resource__desc.html">ldlm_resource_desc</a> {
<a name="l02891"></a>02891         <span class="keyword">enum</span> ldlm_type     lr_type;
<a name="l02892"></a>02892         __u32              lr_pad; <span class="comment">/* also fix lustre_swab_ldlm_resource_desc */</span>
<a name="l02893"></a>02893         <span class="keyword">struct </span><a class="code" href="structldlm__res__id.html">ldlm_res_id</a> lr_name;
<a name="l02894"></a>02894 };
<a name="l02895"></a>02895 
<a name="l02896"></a><a class="code" href="structldlm__lock__desc.html">02896</a> <span class="keyword">struct </span><a class="code" href="structldlm__lock__desc.html">ldlm_lock_desc</a> {
<a name="l02897"></a>02897         <span class="keyword">struct </span><a class="code" href="structldlm__resource__desc.html">ldlm_resource_desc</a> l_resource;
<a name="l02898"></a>02898         <span class="keyword">enum</span> ldlm_mode l_req_mode;
<a name="l02899"></a>02899         <span class="keyword">enum</span> ldlm_mode l_granted_mode;
<a name="l02900"></a>02900         <span class="keyword">union </span><a class="code" href="unionldlm__wire__policy__data.html">ldlm_wire_policy_data</a> l_policy_data;
<a name="l02901"></a>02901 };
<a name="l02902"></a>02902 
<a name="l02903"></a>02903 <span class="preprocessor">#define LDLM_LOCKREQ_HANDLES 2</span>
<a name="l02904"></a>02904 <span class="preprocessor"></span><span class="preprocessor">#define LDLM_ENQUEUE_CANCEL_OFF 1</span>
<a name="l02905"></a>02905 <span class="preprocessor"></span>
<a name="l02906"></a><a class="code" href="structldlm__request.html">02906</a> <span class="keyword">struct </span><a class="code" href="structldlm__request.html">ldlm_request</a> {
<a name="l02907"></a>02907         __u32 lock_flags;
<a name="l02908"></a>02908         __u32 lock_count;
<a name="l02909"></a>02909         <span class="keyword">struct </span><a class="code" href="structldlm__lock__desc.html">ldlm_lock_desc</a> lock_desc;
<a name="l02910"></a>02910         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lock_handle[LDLM_LOCKREQ_HANDLES];
<a name="l02911"></a>02911 };
<a name="l02912"></a>02912 
<a name="l02913"></a>02913 <span class="comment">/* If LDLM_ENQUEUE, 1 slot is already occupied, 1 is available.</span>
<a name="l02914"></a>02914 <span class="comment"> * Otherwise, 2 are available. */</span>
<a name="l02915"></a>02915 <span class="preprocessor">#define ldlm_request_bufsize(count,type)                                \</span>
<a name="l02916"></a>02916 <span class="preprocessor">({                                                                      \</span>
<a name="l02917"></a>02917 <span class="preprocessor">        int _avail = LDLM_LOCKREQ_HANDLES;                              \</span>
<a name="l02918"></a>02918 <span class="preprocessor">        _avail -= (type == LDLM_ENQUEUE ? LDLM_ENQUEUE_CANCEL_OFF : 0); \</span>
<a name="l02919"></a>02919 <span class="preprocessor">        sizeof(struct ldlm_request) +                                   \</span>
<a name="l02920"></a>02920 <span class="preprocessor">        (count &gt; _avail ? count - _avail : 0) *                         \</span>
<a name="l02921"></a>02921 <span class="preprocessor">        sizeof(struct lustre_handle);                                   \</span>
<a name="l02922"></a>02922 <span class="preprocessor">})</span>
<a name="l02923"></a>02923 <span class="preprocessor"></span>
<a name="l02924"></a><a class="code" href="structldlm__reply.html">02924</a> <span class="keyword">struct </span><a class="code" href="structldlm__reply.html">ldlm_reply</a> {
<a name="l02925"></a>02925         __u32 lock_flags;
<a name="l02926"></a>02926         __u32 lock_padding;     <span class="comment">/* also fix lustre_swab_ldlm_reply */</span>
<a name="l02927"></a>02927         <span class="keyword">struct </span><a class="code" href="structldlm__lock__desc.html">ldlm_lock_desc</a> lock_desc;
<a name="l02928"></a>02928         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lock_handle;
<a name="l02929"></a>02929         __u64  lock_policy_res1;
<a name="l02930"></a>02930         __u64  lock_policy_res2;
<a name="l02931"></a>02931 };
<a name="l02932"></a>02932 
<a name="l02933"></a>02933 <span class="preprocessor">#define ldlm_flags_to_wire(flags)    ((__u32)(flags))</span>
<a name="l02934"></a>02934 <span class="preprocessor"></span><span class="preprocessor">#define ldlm_flags_from_wire(flags)  ((__u64)(flags))</span>
<a name="l02935"></a>02935 <span class="preprocessor"></span>
<a name="l02936"></a>02936 <span class="comment">/*</span>
<a name="l02937"></a>02937 <span class="comment"> * Opcodes for mountconf (mgs and mgc)</span>
<a name="l02938"></a>02938 <span class="comment"> */</span>
<a name="l02939"></a>02939 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l02940"></a>02940         MGS_CONNECT = 250,
<a name="l02941"></a>02941         MGS_DISCONNECT,
<a name="l02942"></a>02942         MGS_EXCEPTION,         <span class="comment">/* node died, etc. */</span>
<a name="l02943"></a>02943         MGS_TARGET_REG,        <span class="comment">/* whenever target starts up */</span>
<a name="l02944"></a>02944         MGS_TARGET_DEL,
<a name="l02945"></a>02945         MGS_SET_INFO,
<a name="l02946"></a>02946         MGS_CONFIG_READ,
<a name="l02947"></a>02947         MGS_LAST_OPC
<a name="l02948"></a>02948 } mgs_cmd_t;
<a name="l02949"></a>02949 <span class="preprocessor">#define MGS_FIRST_OPC MGS_CONNECT</span>
<a name="l02950"></a>02950 <span class="preprocessor"></span>
<a name="l02951"></a>02951 <span class="preprocessor">#define MGS_PARAM_MAXLEN 1024</span>
<a name="l02952"></a>02952 <span class="preprocessor"></span><span class="preprocessor">#define KEY_SET_INFO &quot;set_info&quot;</span>
<a name="l02953"></a>02953 <span class="preprocessor"></span>
<a name="l02954"></a><a class="code" href="structmgs__send__param.html">02954</a> <span class="keyword">struct </span><a class="code" href="structmgs__send__param.html">mgs_send_param</a> {
<a name="l02955"></a>02955         <span class="keywordtype">char</span>             mgs_param[MGS_PARAM_MAXLEN];
<a name="l02956"></a>02956 };
<a name="l02957"></a>02957 
<a name="l02958"></a>02958 <span class="comment">/* We pass this info to the MGS so it can write config logs */</span>
<a name="l02959"></a>02959 <span class="preprocessor">#define MTI_NAME_MAXLEN  64</span>
<a name="l02960"></a>02960 <span class="preprocessor"></span><span class="preprocessor">#define MTI_PARAM_MAXLEN 4096</span>
<a name="l02961"></a>02961 <span class="preprocessor"></span><span class="preprocessor">#define MTI_NIDS_MAX     32</span>
<a name="l02962"></a><a class="code" href="structmgs__target__info.html">02962</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structmgs__target__info.html">mgs_target_info</a> {
<a name="l02963"></a>02963         __u32            mti_lustre_ver;
<a name="l02964"></a>02964         __u32            mti_stripe_index;
<a name="l02965"></a>02965         __u32            mti_config_ver;
<a name="l02966"></a>02966         __u32            mti_flags;
<a name="l02967"></a>02967         __u32            mti_nid_count;
<a name="l02968"></a>02968         __u32            mti_instance; <span class="comment">/* Running instance of target */</span>
<a name="l02969"></a>02969         <span class="keywordtype">char</span>             mti_fsname[MTI_NAME_MAXLEN];
<a name="l02970"></a>02970         <span class="keywordtype">char</span>             mti_svname[MTI_NAME_MAXLEN];
<a name="l02971"></a>02971         <span class="keywordtype">char</span>             mti_uuid[<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structobd__uuid.html">obd_uuid</a>)];
<a name="l02972"></a>02972         __u64            mti_nids[MTI_NIDS_MAX];     <span class="comment">/* host nids (lnet_nid_t)*/</span>
<a name="l02973"></a>02973         <span class="keywordtype">char</span>             mti_params[MTI_PARAM_MAXLEN];
<a name="l02974"></a>02974 };
<a name="l02975"></a>02975 
<a name="l02976"></a><a class="code" href="structmgs__nidtbl__entry.html">02976</a> <span class="keyword">struct </span><a class="code" href="structmgs__nidtbl__entry.html">mgs_nidtbl_entry</a> {
<a name="l02977"></a>02977         __u64           mne_version;    <span class="comment">/* table version of this entry */</span>
<a name="l02978"></a>02978         __u32           mne_instance;   <span class="comment">/* target instance # */</span>
<a name="l02979"></a>02979         __u32           mne_index;      <span class="comment">/* target index */</span>
<a name="l02980"></a>02980         __u32           mne_length;     <span class="comment">/* length of this entry - by bytes */</span>
<a name="l02981"></a>02981         __u8            mne_type;       <span class="comment">/* target type LDD_F_SV_TYPE_OST/MDT */</span>
<a name="l02982"></a>02982         __u8            mne_nid_type;   <span class="comment">/* type of nid(mbz). for ipv6. */</span>
<a name="l02983"></a>02983         __u8            mne_nid_size;   <span class="comment">/* size of each NID, by bytes */</span>
<a name="l02984"></a>02984         __u8            mne_nid_count;  <span class="comment">/* # of NIDs in buffer */</span>
<a name="l02985"></a>02985         <span class="keyword">union </span>{
<a name="l02986"></a>02986                 <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nids[0];     <span class="comment">/* variable size buffer for NIDs. */</span>
<a name="l02987"></a>02987         } u;
<a name="l02988"></a>02988 };
<a name="l02989"></a>02989 
<a name="l02990"></a><a class="code" href="structmgs__config__body.html">02990</a> <span class="keyword">struct </span><a class="code" href="structmgs__config__body.html">mgs_config_body</a> {
<a name="l02991"></a>02991         <span class="keywordtype">char</span>     mcb_name[MTI_NAME_MAXLEN]; <span class="comment">/* logname */</span>
<a name="l02992"></a>02992         __u64    mcb_offset;    <span class="comment">/* next index of config log to request */</span>
<a name="l02993"></a>02993         __u16    mcb_type;      <span class="comment">/* type of log: CONFIG_T_[CONFIG|RECOVER] */</span>
<a name="l02994"></a>02994         __u8     mcb_reserved;
<a name="l02995"></a>02995         __u8     mcb_bits;      <span class="comment">/* bits unit size of config log */</span>
<a name="l02996"></a>02996         __u32    mcb_units;     <span class="comment">/* # of units for bulk transfer */</span>
<a name="l02997"></a>02997 };
<a name="l02998"></a>02998 
<a name="l02999"></a><a class="code" href="structmgs__config__res.html">02999</a> <span class="keyword">struct </span><a class="code" href="structmgs__config__res.html">mgs_config_res</a> {
<a name="l03000"></a>03000         __u64    mcr_offset;    <span class="comment">/* index of last config log */</span>
<a name="l03001"></a>03001         __u64    mcr_size;      <span class="comment">/* size of the log */</span>
<a name="l03002"></a>03002 };
<a name="l03003"></a>03003 
<a name="l03004"></a>03004 <span class="comment">/* Config marker flags (in config log) */</span>
<a name="l03005"></a>03005 <span class="preprocessor">#define CM_START       0x01</span>
<a name="l03006"></a>03006 <span class="preprocessor"></span><span class="preprocessor">#define CM_END         0x02</span>
<a name="l03007"></a>03007 <span class="preprocessor"></span><span class="preprocessor">#define CM_SKIP        0x04</span>
<a name="l03008"></a>03008 <span class="preprocessor"></span><span class="preprocessor">#define CM_UPGRADE146  0x08</span>
<a name="l03009"></a>03009 <span class="preprocessor"></span><span class="preprocessor">#define CM_EXCLUDE     0x10</span>
<a name="l03010"></a>03010 <span class="preprocessor"></span><span class="preprocessor">#define CM_START_SKIP (CM_START | CM_SKIP)</span>
<a name="l03011"></a>03011 <span class="preprocessor"></span>
<a name="l03012"></a><a class="code" href="structcfg__marker.html">03012</a> <span class="keyword">struct </span><a class="code" href="structcfg__marker.html">cfg_marker</a> {
<a name="l03013"></a>03013         __u32   cm_step;       <span class="comment">/* aka config version */</span>
<a name="l03014"></a>03014         __u32   cm_flags;
<a name="l03015"></a>03015         __u32   cm_vers;       <span class="comment">/* lustre release version number */</span>
<a name="l03016"></a>03016         __u32   cm_padding;    <span class="comment">/* 64 bit align */</span>
<a name="l03017"></a>03017         __s64   cm_createtime; <span class="comment">/*when this record was first created */</span>
<a name="l03018"></a>03018         __s64   cm_canceltime; <span class="comment">/*when this record is no longer valid*/</span>
<a name="l03019"></a>03019         <span class="keywordtype">char</span>    cm_tgtname[MTI_NAME_MAXLEN];
<a name="l03020"></a>03020         <span class="keywordtype">char</span>    cm_comment[MTI_NAME_MAXLEN];
<a name="l03021"></a>03021 };
<a name="l03022"></a>03022 
<a name="l03023"></a>03023 <span class="comment">/*</span>
<a name="l03024"></a>03024 <span class="comment"> * Opcodes for multiple servers.</span>
<a name="l03025"></a>03025 <span class="comment"> */</span>
<a name="l03026"></a>03026 
<a name="l03027"></a>03027 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l03028"></a>03028         OBD_PING = 400,
<a name="l03029"></a>03029         OBD_LOG_CANCEL,
<a name="l03030"></a>03030         OBD_QC_CALLBACK, <span class="comment">/* not used since 2.4 */</span>
<a name="l03031"></a>03031         OBD_IDX_READ,
<a name="l03032"></a>03032         OBD_LAST_OPC
<a name="l03033"></a>03033 } obd_cmd_t;
<a name="l03034"></a>03034 <span class="preprocessor">#define OBD_FIRST_OPC OBD_PING</span>
<a name="l03035"></a>03035 <span class="preprocessor"></span>
<a name="l03043"></a><a class="code" href="group__lustreidl.html#gaedddc461eb6cbba1f4f39241cabf24f1">03043</a> <span class="keyword">enum</span> <a class="code" href="group__lustreidl.html#gaedddc461eb6cbba1f4f39241cabf24f1" title="llog contexts indices.">llog_ctxt_id</a> {
<a name="l03044"></a>03044         LLOG_CONFIG_ORIG_CTXT  =  0,
<a name="l03045"></a>03045         LLOG_CONFIG_REPL_CTXT = 1,
<a name="l03046"></a>03046         LLOG_MDS_OST_ORIG_CTXT = 2,
<a name="l03047"></a>03047         LLOG_MDS_OST_REPL_CTXT = 3, <span class="comment">/* kept just to avoid re-assignment */</span>
<a name="l03048"></a>03048         LLOG_SIZE_ORIG_CTXT = 4,
<a name="l03049"></a>03049         LLOG_SIZE_REPL_CTXT = 5,
<a name="l03050"></a>03050         LLOG_TEST_ORIG_CTXT = 8,
<a name="l03051"></a>03051         LLOG_TEST_REPL_CTXT = 9, <span class="comment">/* kept just to avoid re-assignment */</span>
<a name="l03052"></a><a class="code" href="group__lustreidl.html#ggaedddc461eb6cbba1f4f39241cabf24f1a41464bd8c4b12353cb8ba20d3909b70c">03052</a>         <a class="code" href="group__lustreidl.html#ggaedddc461eb6cbba1f4f39241cabf24f1a41464bd8c4b12353cb8ba20d3909b70c" title="changelog generation on mdd">LLOG_CHANGELOG_ORIG_CTXT</a> = 12, 
<a name="l03053"></a><a class="code" href="group__lustreidl.html#ggaedddc461eb6cbba1f4f39241cabf24f1a48c3e8ac73a4d4b480a93cdf51b86c60">03053</a>         <a class="code" href="group__lustreidl.html#ggaedddc461eb6cbba1f4f39241cabf24f1a48c3e8ac73a4d4b480a93cdf51b86c60" title="changelog access on clients">LLOG_CHANGELOG_REPL_CTXT</a> = 13, 
<a name="l03054"></a>03054         <span class="comment">/* for multiple changelog consumers */</span>
<a name="l03055"></a>03055         LLOG_CHANGELOG_USER_ORIG_CTXT = 14,
<a name="l03056"></a><a class="code" href="group__lustreidl.html#ggaedddc461eb6cbba1f4f39241cabf24f1a2954ceb36259e9b4d7f5ad60350fcdc0">03056</a>         <a class="code" href="group__lustreidl.html#ggaedddc461eb6cbba1f4f39241cabf24f1a2954ceb36259e9b4d7f5ad60350fcdc0" title="agent requests generation on cdt">LLOG_AGENT_ORIG_CTXT</a> = 15, 
<a name="l03057"></a>03057         LLOG_UPDATELOG_ORIG_CTXT = 16, <span class="comment">/* update log */</span>
<a name="l03058"></a>03058         LLOG_UPDATELOG_REPL_CTXT = 17, <span class="comment">/* update log */</span>
<a name="l03059"></a>03059         LLOG_MAX_CTXTS
<a name="l03060"></a>03060 };
<a name="l03061"></a>03061 
<a name="l03063"></a><a class="code" href="structllog__logid.html">03063</a> <span class="keyword">struct </span><a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a> {
<a name="l03064"></a>03064         <span class="keyword">struct </span><a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a>           lgl_oi;
<a name="l03065"></a>03065         __u32                   lgl_ogen;
<a name="l03066"></a>03066 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03067"></a>03067 
<a name="l03069"></a><a class="code" href="group__lustreidl.html#ga617d8516fe0e8f8919abdf7616c540e2">03069</a> <span class="preprocessor">#define CATLIST &quot;CATALOGS&quot;</span>
<a name="l03070"></a><a class="code" href="structllog__catid.html">03070</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structllog__catid.html">llog_catid</a> {
<a name="l03071"></a>03071         <span class="keyword">struct </span><a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a>       lci_logid;
<a name="l03072"></a>03072         __u32                   lci_padding1;
<a name="l03073"></a>03073         __u32                   lci_padding2;
<a name="l03074"></a>03074         __u32                   lci_padding3;
<a name="l03075"></a>03075 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03076"></a>03076 
<a name="l03077"></a>03077 <span class="comment">/* Log data record types - there is no specific reason that these need to</span>
<a name="l03078"></a>03078 <span class="comment"> * be related to the RPC opcodes, but no reason not to (may be handy later?)</span>
<a name="l03079"></a>03079 <span class="comment"> */</span>
<a name="l03080"></a>03080 <span class="preprocessor">#define LLOG_OP_MAGIC 0x10600000</span>
<a name="l03081"></a>03081 <span class="preprocessor"></span><span class="preprocessor">#define LLOG_OP_MASK  0xfff00000</span>
<a name="l03082"></a>03082 <span class="preprocessor"></span>
<a name="l03083"></a>03083 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l03084"></a>03084         LLOG_PAD_MAGIC          = LLOG_OP_MAGIC | 0x00000,
<a name="l03085"></a>03085         OST_SZ_REC              = LLOG_OP_MAGIC | 0x00f00,
<a name="l03086"></a>03086         <span class="comment">/* OST_RAID1_REC        = LLOG_OP_MAGIC | 0x01000, never used */</span>
<a name="l03087"></a>03087         MDS_UNLINK_REC          = LLOG_OP_MAGIC | 0x10000 | (MDS_REINT &lt;&lt; 8) |
<a name="l03088"></a>03088                                   REINT_UNLINK, <span class="comment">/* obsolete after 2.5.0 */</span>
<a name="l03089"></a>03089         MDS_UNLINK64_REC        = LLOG_OP_MAGIC | 0x90000 | (MDS_REINT &lt;&lt; 8) |
<a name="l03090"></a>03090                                   REINT_UNLINK,
<a name="l03091"></a>03091         <span class="comment">/* MDS_SETATTR_REC      = LLOG_OP_MAGIC | 0x12401, obsolete 1.8.0 */</span>
<a name="l03092"></a>03092         MDS_SETATTR64_REC       = LLOG_OP_MAGIC | 0x90000 | (MDS_REINT &lt;&lt; 8) |
<a name="l03093"></a>03093                                   REINT_SETATTR,
<a name="l03094"></a>03094         OBD_CFG_REC             = LLOG_OP_MAGIC | 0x20000,
<a name="l03095"></a>03095         <span class="comment">/* PTL_CFG_REC          = LLOG_OP_MAGIC | 0x30000, obsolete 1.4.0 */</span>
<a name="l03096"></a>03096         LLOG_GEN_REC            = LLOG_OP_MAGIC | 0x40000,
<a name="l03097"></a>03097         <span class="comment">/* LLOG_JOIN_REC        = LLOG_OP_MAGIC | 0x50000, obsolete  1.8.0 */</span>
<a name="l03098"></a>03098         CHANGELOG_REC           = LLOG_OP_MAGIC | 0x60000,
<a name="l03099"></a>03099         CHANGELOG_USER_REC      = LLOG_OP_MAGIC | 0x70000,
<a name="l03100"></a>03100         HSM_AGENT_REC           = LLOG_OP_MAGIC | 0x80000,
<a name="l03101"></a>03101         UPDATE_REC              = LLOG_OP_MAGIC | 0xa0000,
<a name="l03102"></a>03102         LLOG_HDR_MAGIC          = LLOG_OP_MAGIC | 0x45539,
<a name="l03103"></a>03103         LLOG_LOGID_MAGIC        = LLOG_OP_MAGIC | 0x4553b,
<a name="l03104"></a>03104 } llog_op_type;
<a name="l03105"></a>03105 
<a name="l03106"></a>03106 <span class="preprocessor">#define LLOG_REC_HDR_NEEDS_SWABBING(r) \</span>
<a name="l03107"></a>03107 <span class="preprocessor">        (((r)-&gt;lrh_type &amp; __swab32(LLOG_OP_MASK)) == __swab32(LLOG_OP_MAGIC))</span>
<a name="l03108"></a>03108 <span class="preprocessor"></span>
<a name="l03113"></a><a class="code" href="structllog__rec__hdr.html">03113</a> <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> {
<a name="l03114"></a>03114         __u32   lrh_len;
<a name="l03115"></a>03115         __u32   lrh_index;
<a name="l03116"></a>03116         __u32   lrh_type;
<a name="l03117"></a>03117         __u32   lrh_id;
<a name="l03118"></a>03118 };
<a name="l03119"></a>03119 
<a name="l03120"></a><a class="code" href="structllog__rec__tail.html">03120</a> <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a> {
<a name="l03121"></a>03121         __u32   lrt_len;
<a name="l03122"></a>03122         __u32   lrt_index;
<a name="l03123"></a>03123 };
<a name="l03124"></a>03124 
<a name="l03125"></a>03125 <span class="comment">/* Where data follow just after header */</span>
<a name="l03126"></a>03126 <span class="preprocessor">#define REC_DATA(ptr)                                           \</span>
<a name="l03127"></a>03127 <span class="preprocessor">        ((void *)((char *)ptr + sizeof(struct llog_rec_hdr)))</span>
<a name="l03128"></a>03128 <span class="preprocessor"></span>
<a name="l03129"></a>03129 <span class="preprocessor">#define REC_DATA_LEN(rec)                                       \</span>
<a name="l03130"></a>03130 <span class="preprocessor">        (rec-&gt;lrh_len - sizeof(struct llog_rec_hdr) -           \</span>
<a name="l03131"></a>03131 <span class="preprocessor">         sizeof(struct llog_rec_tail))</span>
<a name="l03132"></a>03132 <span class="preprocessor"></span>
<a name="l03133"></a>03133 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> *rec_tail(<span class="keyword">struct</span> <a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a> *rec)
<a name="l03134"></a>03134 {
<a name="l03135"></a>03135         <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)((<span class="keywordtype">char</span> *)rec + rec-&gt;lrh_len -
<a name="l03136"></a>03136                         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>));
<a name="l03137"></a>03137 }
<a name="l03138"></a>03138 
<a name="l03139"></a><a class="code" href="structllog__logid__rec.html">03139</a> <span class="keyword">struct </span><a class="code" href="structllog__logid__rec.html">llog_logid_rec</a> {
<a name="l03140"></a>03140         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     lid_hdr;
<a name="l03141"></a>03141         <span class="keyword">struct </span><a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a>       lid_id;
<a name="l03142"></a>03142         __u32                   lid_padding1;
<a name="l03143"></a>03143         __u64                   lid_padding2;
<a name="l03144"></a>03144         __u64                   lid_padding3;
<a name="l03145"></a>03145         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>    lid_tail;
<a name="l03146"></a>03146 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03147"></a>03147 
<a name="l03148"></a><a class="code" href="structllog__unlink__rec.html">03148</a> <span class="keyword">struct </span><a class="code" href="structllog__unlink__rec.html">llog_unlink_rec</a> {
<a name="l03149"></a>03149         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     lur_hdr;
<a name="l03150"></a>03150         __u64                   lur_oid;
<a name="l03151"></a>03151         __u32                   lur_oseq;
<a name="l03152"></a>03152         __u32                   lur_count;
<a name="l03153"></a>03153         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>    lur_tail;
<a name="l03154"></a>03154 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03155"></a>03155 
<a name="l03156"></a><a class="code" href="structllog__unlink64__rec.html">03156</a> <span class="keyword">struct </span><a class="code" href="structllog__unlink64__rec.html">llog_unlink64_rec</a> {
<a name="l03157"></a>03157         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     lur_hdr;
<a name="l03158"></a>03158         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           lur_fid;
<a name="l03159"></a>03159         __u32                   lur_count; <span class="comment">/* to destroy the lost precreated */</span>
<a name="l03160"></a>03160         __u32                   lur_padding1;
<a name="l03161"></a>03161         __u64                   lur_padding2;
<a name="l03162"></a>03162         __u64                   lur_padding3;
<a name="l03163"></a>03163         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>    lur_tail;
<a name="l03164"></a>03164 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03165"></a>03165 
<a name="l03166"></a><a class="code" href="structllog__setattr64__rec.html">03166</a> <span class="keyword">struct </span><a class="code" href="structllog__setattr64__rec.html">llog_setattr64_rec</a> {
<a name="l03167"></a>03167         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     lsr_hdr;
<a name="l03168"></a>03168         <span class="keyword">struct </span><a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a>           lsr_oi;
<a name="l03169"></a>03169         __u32                   lsr_uid;
<a name="l03170"></a>03170         __u32                   lsr_uid_h;
<a name="l03171"></a>03171         __u32                   lsr_gid;
<a name="l03172"></a>03172         __u32                   lsr_gid_h;
<a name="l03173"></a>03173         __u64                   lsr_valid;
<a name="l03174"></a>03174         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>    lsr_tail;
<a name="l03175"></a>03175 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03176"></a>03176 
<a name="l03177"></a><a class="code" href="structllog__size__change__rec.html">03177</a> <span class="keyword">struct </span><a class="code" href="structllog__size__change__rec.html">llog_size_change_rec</a> {
<a name="l03178"></a>03178         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     lsc_hdr;
<a name="l03179"></a>03179         <span class="keyword">struct </span><a class="code" href="structll__fid.html">ll_fid</a>           lsc_fid;
<a name="l03180"></a>03180         __u32                   lsc_ioepoch;
<a name="l03181"></a>03181         __u32                   lsc_padding1;
<a name="l03182"></a>03182         __u64                   lsc_padding2;
<a name="l03183"></a>03183         __u64                   lsc_padding3;
<a name="l03184"></a>03184         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>    lsc_tail;
<a name="l03185"></a>03185 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03186"></a>03186 
<a name="l03187"></a>03187 <span class="preprocessor">#define CHANGELOG_MAGIC 0xca103000</span>
<a name="l03188"></a>03188 <span class="preprocessor"></span>
<a name="l03190"></a><a class="code" href="group__lustreidl.html#ga371e8e020949692f6fa1475fdadccd38">03190</a> <span class="preprocessor">#define CHANGELOG_MINMASK (1 &lt;&lt; CL_MARK)</span>
<a name="l03191"></a>03191 <span class="preprocessor"></span>
<a name="l03192"></a><a class="code" href="group__lustreidl.html#ga556f68ff421fbdfca92dcb039da85861">03192</a> <span class="preprocessor">#define CHANGELOG_ALLMASK 0XFFFFFFFF</span>
<a name="l03193"></a>03193 <span class="preprocessor"></span>
<a name="l03196"></a><a class="code" href="group__lustreidl.html#ga68b98346e8b37da419837c537d7ee5b0">03196</a> <span class="preprocessor">#define CHANGELOG_DEFMASK (CHANGELOG_ALLMASK &amp; ~(1 &lt;&lt; CL_ATIME))</span>
<a name="l03197"></a>03197 <span class="preprocessor"></span>
<a name="l03198"></a>03198 <span class="comment">/* changelog llog name, needed by client replicators */</span>
<a name="l03199"></a>03199 <span class="preprocessor">#define CHANGELOG_CATALOG &quot;changelog_catalog&quot;</span>
<a name="l03200"></a>03200 <span class="preprocessor"></span>
<a name="l03201"></a><a class="code" href="structchangelog__setinfo.html">03201</a> <span class="keyword">struct </span><a class="code" href="structchangelog__setinfo.html">changelog_setinfo</a> {
<a name="l03202"></a>03202         __u64 cs_recno;
<a name="l03203"></a>03203         __u32 cs_id;
<a name="l03204"></a>03204 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03205"></a>03205 
<a name="l03207"></a><a class="code" href="structllog__changelog__rec.html">03207</a> <span class="keyword">struct </span><a class="code" href="structllog__changelog__rec.html" title="changelog record">llog_changelog_rec</a> {
<a name="l03208"></a>03208         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>  cr_hdr;
<a name="l03209"></a><a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf">03209</a>         <span class="keyword">struct </span><a class="code" href="structchangelog__rec.html">changelog_rec</a> <a class="code" href="structllog__changelog__rec.html#afc0e0b0bc7f0c0e937c6f91221434ebf" title="Variable length field.">cr</a>; 
<a name="l03210"></a><a class="code" href="structllog__changelog__rec.html#a0e38e809585e0273f29e968c2489fa2b">03210</a>         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a> <a class="code" href="structllog__changelog__rec.html#a0e38e809585e0273f29e968c2489fa2b" title="for_sizeof_only">cr_do_not_use</a>; 
<a name="l03211"></a>03211 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03212"></a>03212 
<a name="l03213"></a>03213 <span class="preprocessor">#define CHANGELOG_USER_PREFIX &quot;cl&quot;</span>
<a name="l03214"></a>03214 <span class="preprocessor"></span>
<a name="l03215"></a><a class="code" href="structllog__changelog__user__rec.html">03215</a> <span class="keyword">struct </span><a class="code" href="structllog__changelog__user__rec.html">llog_changelog_user_rec</a> {
<a name="l03216"></a>03216         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>   cur_hdr;
<a name="l03217"></a>03217         __u32                 cur_id;
<a name="l03218"></a>03218         __u32                 cur_padding;
<a name="l03219"></a>03219         __u64                 cur_endrec;
<a name="l03220"></a>03220         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>  cur_tail;
<a name="l03221"></a>03221 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03222"></a>03222 
<a name="l03223"></a>03223 <span class="keyword">enum</span> agent_req_status {
<a name="l03224"></a>03224         ARS_WAITING,
<a name="l03225"></a>03225         ARS_STARTED,
<a name="l03226"></a>03226         ARS_FAILED,
<a name="l03227"></a>03227         ARS_CANCELED,
<a name="l03228"></a>03228         ARS_SUCCEED,
<a name="l03229"></a>03229 };
<a name="l03230"></a>03230 
<a name="l03231"></a>03231 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *agent_req_status2name(<span class="keyword">enum</span> agent_req_status ars)
<a name="l03232"></a>03232 {
<a name="l03233"></a>03233         <span class="keywordflow">switch</span> (ars) {
<a name="l03234"></a>03234         <span class="keywordflow">case</span> ARS_WAITING:
<a name="l03235"></a>03235                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;WAITING&quot;</span>;
<a name="l03236"></a>03236         <span class="keywordflow">case</span> ARS_STARTED:
<a name="l03237"></a>03237                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;STARTED&quot;</span>;
<a name="l03238"></a>03238         <span class="keywordflow">case</span> ARS_FAILED:
<a name="l03239"></a>03239                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;FAILED&quot;</span>;
<a name="l03240"></a>03240         <span class="keywordflow">case</span> ARS_CANCELED:
<a name="l03241"></a>03241                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;CANCELED&quot;</span>;
<a name="l03242"></a>03242         <span class="keywordflow">case</span> ARS_SUCCEED:
<a name="l03243"></a>03243                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;SUCCEED&quot;</span>;
<a name="l03244"></a>03244         <span class="keywordflow">default</span>:
<a name="l03245"></a>03245                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;UNKNOWN&quot;</span>;
<a name="l03246"></a>03246         }
<a name="l03247"></a>03247 }
<a name="l03248"></a>03248 
<a name="l03249"></a>03249 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> agent_req_in_final_state(<span class="keyword">enum</span> agent_req_status ars)
<a name="l03250"></a>03250 {
<a name="l03251"></a>03251         <span class="keywordflow">return</span> ((ars == ARS_SUCCEED) || (ars == ARS_FAILED) ||
<a name="l03252"></a>03252                 (ars == ARS_CANCELED));
<a name="l03253"></a>03253 }
<a name="l03254"></a>03254 
<a name="l03255"></a><a class="code" href="structllog__agent__req__rec.html">03255</a> <span class="keyword">struct </span><a class="code" href="structllog__agent__req__rec.html">llog_agent_req_rec</a> {
<a name="l03256"></a><a class="code" href="structllog__agent__req__rec.html#a34ae75edf7f12f1a090ebcd21829b1b8">03256</a>         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     <a class="code" href="structllog__agent__req__rec.html#a34ae75edf7f12f1a090ebcd21829b1b8" title="record header">arr_hdr</a>;        
<a name="l03257"></a><a class="code" href="structllog__agent__req__rec.html#a48c91e2b08016be8dda07b75a1701ae6">03257</a>         __u32                   <a class="code" href="structllog__agent__req__rec.html#a48c91e2b08016be8dda07b75a1701ae6" title="status of the request">arr_status</a>;     
<a name="l03258"></a>03258                                                 <span class="comment">/* must match enum</span>
<a name="l03259"></a>03259 <span class="comment">                                                 * agent_req_status */</span>
<a name="l03260"></a><a class="code" href="structllog__agent__req__rec.html#abb8e5e6ce6bc5cadf028136194e07e37">03260</a>         __u32                   <a class="code" href="structllog__agent__req__rec.html#abb8e5e6ce6bc5cadf028136194e07e37" title="backend archive number">arr_archive_id</a>; 
<a name="l03261"></a><a class="code" href="structllog__agent__req__rec.html#a5b38f10add623ffa40c33e4ed859d225">03261</a>         __u64                   <a class="code" href="structllog__agent__req__rec.html#a5b38f10add623ffa40c33e4ed859d225" title="req flags">arr_flags</a>;      
<a name="l03262"></a><a class="code" href="structllog__agent__req__rec.html#a17ed8766450a0a9b00017b4b7c09c564">03262</a>         __u64                   <a class="code" href="structllog__agent__req__rec.html#a17ed8766450a0a9b00017b4b7c09c564" title="compound cookie">arr_compound_id</a>;        
<a name="l03263"></a><a class="code" href="structllog__agent__req__rec.html#a7de2d49a616d8af267a0dc54529e3d28">03263</a>         __u64                   <a class="code" href="structllog__agent__req__rec.html#a7de2d49a616d8af267a0dc54529e3d28" title="req.">arr_req_create</a>; 
<a name="l03264"></a><a class="code" href="structllog__agent__req__rec.html#a0172d56922046ed764f78ef3746430f9">03264</a>         __u64                   <a class="code" href="structllog__agent__req__rec.html#a0172d56922046ed764f78ef3746430f9" title="req.">arr_req_change</a>; 
<a name="l03265"></a><a class="code" href="structllog__agent__req__rec.html#a82aedcd3b85aa90baf16fd8b3beaf355">03265</a>         <span class="keyword">struct </span><a class="code" href="structhsm__action__item.html">hsm_action_item</a>  <a class="code" href="structllog__agent__req__rec.html#a82aedcd3b85aa90baf16fd8b3beaf355" title="req.">arr_hai</a>;        
<a name="l03266"></a><a class="code" href="structllog__agent__req__rec.html#abb3296b355948b3b8cc20b4e5bc3a8bd">03266</a>         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>    <a class="code" href="structllog__agent__req__rec.html#abb3296b355948b3b8cc20b4e5bc3a8bd" title="record tail for_sizezof_only">arr_tail</a>; 
<a name="l03267"></a>03267 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03268"></a>03268 
<a name="l03269"></a>03269 <span class="comment">/* Old llog gen for compatibility */</span>
<a name="l03270"></a><a class="code" href="structllog__gen.html">03270</a> <span class="keyword">struct </span><a class="code" href="structllog__gen.html">llog_gen</a> {
<a name="l03271"></a>03271         __u64 mnt_cnt;
<a name="l03272"></a>03272         __u64 conn_cnt;
<a name="l03273"></a>03273 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03274"></a>03274 
<a name="l03275"></a><a class="code" href="structllog__gen__rec.html">03275</a> <span class="keyword">struct </span><a class="code" href="structllog__gen__rec.html">llog_gen_rec</a> {
<a name="l03276"></a>03276         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     lgr_hdr;
<a name="l03277"></a>03277         <span class="keyword">struct </span><a class="code" href="structllog__gen.html">llog_gen</a>         lgr_gen;
<a name="l03278"></a>03278         __u64                   padding1;
<a name="l03279"></a>03279         __u64                   padding2;
<a name="l03280"></a>03280         __u64                   padding3;
<a name="l03281"></a>03281         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>    lgr_tail;
<a name="l03282"></a>03282 };
<a name="l03283"></a>03283 
<a name="l03284"></a>03284 <span class="comment">/* flags for the logs */</span>
<a name="l03285"></a>03285 <span class="keyword">enum</span> llog_flag {
<a name="l03286"></a>03286         LLOG_F_ZAP_WHEN_EMPTY   = 0x1,
<a name="l03287"></a>03287         LLOG_F_IS_CAT           = 0x2,
<a name="l03288"></a>03288         LLOG_F_IS_PLAIN         = 0x4,
<a name="l03289"></a>03289         LLOG_F_EXT_JOBID        = 0x8,
<a name="l03290"></a>03290         LLOG_F_IS_FIXSIZE       = 0x10,
<a name="l03291"></a>03291 
<a name="l03292"></a>03292         <span class="comment">/* Note: Flags covered by LLOG_F_EXT_MASK will be inherited from</span>
<a name="l03293"></a>03293 <span class="comment">         * catlog to plain log, so do not add LLOG_F_IS_FIXSIZE here,</span>
<a name="l03294"></a>03294 <span class="comment">         * because the catlog record is usually fixed size, but its plain</span>
<a name="l03295"></a>03295 <span class="comment">         * log record can be variable */</span>
<a name="l03296"></a>03296         LLOG_F_EXT_MASK = LLOG_F_EXT_JOBID,
<a name="l03297"></a>03297 };
<a name="l03298"></a>03298 
<a name="l03299"></a>03299 <span class="comment">/* On-disk header structure of each log object, stored in little endian order */</span>
<a name="l03300"></a>03300 <span class="preprocessor">#define LLOG_MIN_CHUNK_SIZE     8192</span>
<a name="l03301"></a>03301 <span class="preprocessor"></span><span class="preprocessor">#define LLOG_HEADER_SIZE        (96) </span><span class="comment">/* sizeof (llog_log_hdr) + sizeof(llh_tail)</span>
<a name="l03302"></a>03302 <span class="comment">                                      * - sizeof(llh_bitmap) */</span>
<a name="l03303"></a>03303 <span class="preprocessor">#define LLOG_BITMAP_BYTES       (LLOG_MIN_CHUNK_SIZE - LLOG_HEADER_SIZE)</span>
<a name="l03304"></a>03304 <span class="preprocessor"></span><span class="preprocessor">#define LLOG_MIN_REC_SIZE       (24) </span><span class="comment">/* round(llog_rec_hdr + llog_rec_tail) */</span>
<a name="l03305"></a>03305 
<a name="l03306"></a><a class="code" href="structllog__log__hdr.html">03306</a> <span class="keyword">struct </span><a class="code" href="structllog__log__hdr.html">llog_log_hdr</a> {
<a name="l03307"></a>03307         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     llh_hdr;
<a name="l03308"></a>03308         __s64                   llh_timestamp;
<a name="l03309"></a>03309         __u32                   llh_count;
<a name="l03310"></a>03310         __u32                   llh_bitmap_offset;
<a name="l03311"></a>03311         __u32                   llh_size;
<a name="l03312"></a>03312         __u32                   llh_flags;
<a name="l03313"></a>03313         <span class="comment">/* for a catalog the first/oldest and still in-use plain slot is just</span>
<a name="l03314"></a>03314 <span class="comment">         * next to it. It will serve as the upper limit after Catalog has</span>
<a name="l03315"></a>03315 <span class="comment">         * wrapped around */</span>
<a name="l03316"></a>03316         __u32                   llh_cat_idx;
<a name="l03317"></a>03317         <span class="keyword">struct </span><a class="code" href="structobd__uuid.html">obd_uuid</a>         llh_tgtuuid;
<a name="l03318"></a>03318         __u32                   llh_reserved[LLOG_HEADER_SIZE/<span class="keyword">sizeof</span>(__u32)-23];
<a name="l03319"></a>03319         <span class="comment">/* These fields must always be at the end of the llog_log_hdr.</span>
<a name="l03320"></a>03320 <span class="comment">         * Note: llh_bitmap size is variable because llog chunk size could be</span>
<a name="l03321"></a>03321 <span class="comment">         * bigger than LLOG_MIN_CHUNK_SIZE, i.e. sizeof(llog_log_hdr) &gt; 8192</span>
<a name="l03322"></a>03322 <span class="comment">         * bytes, and the real size is stored in llh_hdr.lrh_len, which means</span>
<a name="l03323"></a>03323 <span class="comment">         * llh_tail should only be refered by LLOG_HDR_TAIL().</span>
<a name="l03324"></a>03324 <span class="comment">         * But this structure is also used by client/server llog interface</span>
<a name="l03325"></a>03325 <span class="comment">         * (see llog_client.c), it will be kept in its original way to avoid</span>
<a name="l03326"></a>03326 <span class="comment">         * compatiblity issue. */</span>
<a name="l03327"></a>03327         __u32                   llh_bitmap[LLOG_BITMAP_BYTES / <span class="keyword">sizeof</span>(__u32)];
<a name="l03328"></a>03328         <span class="keyword">struct </span><a class="code" href="structllog__rec__tail.html">llog_rec_tail</a>    llh_tail;
<a name="l03329"></a>03329 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03330"></a>03330 <span class="preprocessor">#undef LLOG_HEADER_SIZE</span>
<a name="l03331"></a>03331 <span class="preprocessor"></span><span class="preprocessor">#undef LLOG_BITMAP_BYTES</span>
<a name="l03332"></a>03332 <span class="preprocessor"></span>
<a name="l03333"></a>03333 <span class="preprocessor">#define LLOG_HDR_BITMAP_SIZE(llh)       (__u32)((llh-&gt;llh_hdr.lrh_len - \</span>
<a name="l03334"></a>03334 <span class="preprocessor">                                         llh-&gt;llh_bitmap_offset -       \</span>
<a name="l03335"></a>03335 <span class="preprocessor">                                         sizeof(llh-&gt;llh_tail)) * 8)</span>
<a name="l03336"></a>03336 <span class="preprocessor"></span><span class="preprocessor">#define LLOG_HDR_BITMAP(llh)    (__u32 *)((char *)(llh) +               \</span>
<a name="l03337"></a>03337 <span class="preprocessor">                                          (llh)-&gt;llh_bitmap_offset)</span>
<a name="l03338"></a>03338 <span class="preprocessor"></span><span class="preprocessor">#define LLOG_HDR_TAIL(llh)      ((struct llog_rec_tail *)((char *)llh + \</span>
<a name="l03339"></a>03339 <span class="preprocessor">                                                 llh-&gt;llh_hdr.lrh_len - \</span>
<a name="l03340"></a>03340 <span class="preprocessor">                                                 sizeof(llh-&gt;llh_tail)))</span>
<a name="l03341"></a>03341 <span class="preprocessor"></span>
<a name="l03343"></a><a class="code" href="structllog__cookie.html">03343</a> <span class="keyword">struct </span><a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a> {
<a name="l03344"></a>03344         <span class="keyword">struct </span><a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a>       lgc_lgl;
<a name="l03345"></a>03345         __u32                   lgc_subsys;
<a name="l03346"></a>03346         __u32                   lgc_index;
<a name="l03347"></a>03347         __u32                   lgc_padding;
<a name="l03348"></a>03348 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03349"></a>03349 
<a name="l03351"></a><a class="code" href="group__lustreidl.html#ga2a2d75590edc3195aa83aa7390c66cb4">03351</a> <span class="keyword">enum</span> <a class="code" href="group__lustreidl.html#ga2a2d75590edc3195aa83aa7390c66cb4" title="llog protocol">llogd_rpc_ops</a> {
<a name="l03352"></a>03352         LLOG_ORIGIN_HANDLE_CREATE       = 501,
<a name="l03353"></a>03353         LLOG_ORIGIN_HANDLE_NEXT_BLOCK   = 502,
<a name="l03354"></a>03354         LLOG_ORIGIN_HANDLE_READ_HEADER  = 503,
<a name="l03355"></a>03355         LLOG_ORIGIN_HANDLE_WRITE_REC    = 504,
<a name="l03356"></a>03356         LLOG_ORIGIN_HANDLE_CLOSE        = 505,
<a name="l03357"></a>03357         LLOG_ORIGIN_CONNECT             = 506,
<a name="l03358"></a>03358         LLOG_CATINFO                    = 507,  <span class="comment">/* deprecated */</span>
<a name="l03359"></a>03359         LLOG_ORIGIN_HANDLE_PREV_BLOCK   = 508,
<a name="l03360"></a>03360         LLOG_ORIGIN_HANDLE_DESTROY      = 509,  <span class="comment">/* for destroy llog object*/</span>
<a name="l03361"></a>03361         LLOG_LAST_OPC,
<a name="l03362"></a>03362         LLOG_FIRST_OPC                  = LLOG_ORIGIN_HANDLE_CREATE
<a name="l03363"></a>03363 };
<a name="l03364"></a>03364 
<a name="l03365"></a><a class="code" href="structllogd__body.html">03365</a> <span class="keyword">struct </span><a class="code" href="structllogd__body.html">llogd_body</a> {
<a name="l03366"></a>03366         <span class="keyword">struct </span><a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a>  lgd_logid;
<a name="l03367"></a>03367         __u32 lgd_ctxt_idx;
<a name="l03368"></a>03368         __u32 lgd_llh_flags;
<a name="l03369"></a>03369         __u32 lgd_index;
<a name="l03370"></a>03370         __u32 lgd_saved_index;
<a name="l03371"></a>03371         __u32 lgd_len;
<a name="l03372"></a>03372         __u64 lgd_cur_offset;
<a name="l03373"></a>03373 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03374"></a>03374 
<a name="l03375"></a><a class="code" href="structllogd__conn__body.html">03375</a> <span class="keyword">struct </span><a class="code" href="structllogd__conn__body.html">llogd_conn_body</a> {
<a name="l03376"></a>03376         <span class="keyword">struct </span><a class="code" href="structllog__gen.html">llog_gen</a>         lgdc_gen;
<a name="l03377"></a>03377         <span class="keyword">struct </span><a class="code" href="structllog__logid.html" title="Identifier for a single log object.">llog_logid</a>       lgdc_logid;
<a name="l03378"></a>03378         __u32                   lgdc_ctxt_idx;
<a name="l03379"></a>03379 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03380"></a>03380 
<a name="l03381"></a>03381 <span class="comment">/* Note: 64-bit types are 64-bit aligned in structure */</span>
<a name="l03382"></a><a class="code" href="structobdo.html">03382</a> <span class="keyword">struct </span><a class="code" href="structobdo.html">obdo</a> {
<a name="l03383"></a>03383         __u64                   o_valid;        <span class="comment">/* hot fields in this obdo */</span>
<a name="l03384"></a>03384         <span class="keyword">struct </span><a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a>           o_oi;
<a name="l03385"></a>03385         __u64                   o_parent_seq;
<a name="l03386"></a>03386         __u64                   o_size;         <span class="comment">/* o_size-o_blocks == ost_lvb */</span>
<a name="l03387"></a>03387         __s64                   o_mtime;
<a name="l03388"></a>03388         __s64                   o_atime;
<a name="l03389"></a>03389         __s64                   o_ctime;
<a name="l03390"></a>03390         __u64                   o_blocks;       <span class="comment">/* brw: cli sent cached bytes */</span>
<a name="l03391"></a>03391         __u64                   o_grant;
<a name="l03392"></a>03392 
<a name="l03393"></a>03393         <span class="comment">/* 32-bit fields start here: keep an even number of them via padding */</span>
<a name="l03394"></a>03394         __u32                   o_blksize;      <span class="comment">/* optimal IO blocksize */</span>
<a name="l03395"></a>03395         __u32                   o_mode;         <span class="comment">/* brw: cli sent cache remain */</span>
<a name="l03396"></a>03396         __u32                   o_uid;
<a name="l03397"></a>03397         __u32                   o_gid;
<a name="l03398"></a>03398         __u32                   o_flags;
<a name="l03399"></a>03399         __u32                   o_nlink;        <span class="comment">/* brw: checksum */</span>
<a name="l03400"></a>03400         __u32                   o_parent_oid;
<a name="l03401"></a>03401         __u32                   o_misc;         <span class="comment">/* brw: o_dropped */</span>
<a name="l03402"></a>03402 
<a name="l03403"></a>03403         __u64                   o_ioepoch;      <span class="comment">/* epoch in ost writes */</span>
<a name="l03404"></a>03404         __u32                   o_stripe_idx;   <span class="comment">/* holds stripe idx */</span>
<a name="l03405"></a>03405         __u32                   o_parent_ver;
<a name="l03406"></a>03406         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    o_handle;       <span class="comment">/* brw: lock handle to prolong</span>
<a name="l03407"></a>03407 <span class="comment">                                                 * locks */</span>
<a name="l03408"></a>03408         <span class="keyword">struct </span><a class="code" href="structllog__cookie.html" title="log cookies are used to reference a specific log file and a record therein">llog_cookie</a>      o_lcookie;      <span class="comment">/* destroy: unlink cookie from</span>
<a name="l03409"></a>03409 <span class="comment">                                                 * MDS, obsolete in 2.8, reused</span>
<a name="l03410"></a>03410 <span class="comment">                                                 * in OSP */</span>
<a name="l03411"></a>03411         __u32                   o_uid_h;
<a name="l03412"></a>03412         __u32                   o_gid_h;
<a name="l03413"></a>03413 
<a name="l03414"></a>03414         __u64                   o_data_version; <span class="comment">/* getattr: sum of iversion for</span>
<a name="l03415"></a>03415 <span class="comment">                                                 * each stripe.</span>
<a name="l03416"></a>03416 <span class="comment">                                                 * brw: grant space consumed on</span>
<a name="l03417"></a>03417 <span class="comment">                                                 * the client for the write */</span>
<a name="l03418"></a>03418         __u64                   o_padding_4;
<a name="l03419"></a>03419         __u64                   o_padding_5;
<a name="l03420"></a>03420         __u64                   o_padding_6;
<a name="l03421"></a>03421 };
<a name="l03422"></a>03422 
<a name="l03423"></a>03423 <span class="preprocessor">#define o_dirty   o_blocks</span>
<a name="l03424"></a>03424 <span class="preprocessor"></span><span class="preprocessor">#define o_undirty o_mode</span>
<a name="l03425"></a>03425 <span class="preprocessor"></span><span class="preprocessor">#define o_dropped o_misc</span>
<a name="l03426"></a>03426 <span class="preprocessor"></span><span class="preprocessor">#define o_cksum   o_nlink</span>
<a name="l03427"></a>03427 <span class="preprocessor"></span><span class="preprocessor">#define o_grant_used o_data_version</span>
<a name="l03428"></a>03428 <span class="preprocessor"></span>
<a name="l03429"></a><a class="code" href="structlfsck__request.html">03429</a> <span class="keyword">struct </span><a class="code" href="structlfsck__request.html">lfsck_request</a> {
<a name="l03430"></a>03430         __u32           lr_event;
<a name="l03431"></a>03431         __u32           lr_index;
<a name="l03432"></a>03432         __u32           lr_flags;
<a name="l03433"></a>03433         __u32           lr_valid;
<a name="l03434"></a>03434         <span class="keyword">union </span>{
<a name="l03435"></a>03435                 __u32   lr_speed;
<a name="l03436"></a>03436                 __u32   lr_status;
<a name="l03437"></a>03437                 __u32   lr_type;
<a name="l03438"></a>03438         };
<a name="l03439"></a>03439         __u16           lr_version;
<a name="l03440"></a>03440         __u16           lr_active;
<a name="l03441"></a>03441         __u16           lr_param;
<a name="l03442"></a>03442         __u16           lr_async_windows;
<a name="l03443"></a>03443         __u32           lr_flags2;
<a name="l03444"></a>03444         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   lr_fid;
<a name="l03445"></a>03445         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   lr_fid2;
<a name="l03446"></a>03446         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   lr_fid3;
<a name="l03447"></a>03447         __u64           lr_padding_1;
<a name="l03448"></a>03448         __u64           lr_padding_2;
<a name="l03449"></a>03449 };
<a name="l03450"></a>03450 
<a name="l03451"></a><a class="code" href="structlfsck__reply.html">03451</a> <span class="keyword">struct </span><a class="code" href="structlfsck__reply.html">lfsck_reply</a> {
<a name="l03452"></a>03452         __u32           lr_status;
<a name="l03453"></a>03453         __u32           lr_padding_1;
<a name="l03454"></a>03454         __u64           lr_repaired;
<a name="l03455"></a>03455 };
<a name="l03456"></a>03456 
<a name="l03457"></a>03457 <span class="keyword">enum</span> lfsck_events {
<a name="l03458"></a>03458         LE_LASTID_REBUILDING    = 1,
<a name="l03459"></a>03459         LE_LASTID_REBUILT       = 2,
<a name="l03460"></a>03460         LE_PHASE1_DONE          = 3,
<a name="l03461"></a>03461         LE_PHASE2_DONE          = 4,
<a name="l03462"></a>03462         LE_START                = 5,
<a name="l03463"></a>03463         LE_STOP                 = 6,
<a name="l03464"></a>03464         LE_QUERY                = 7,
<a name="l03465"></a>03465         LE_FID_ACCESSED         = 8,
<a name="l03466"></a>03466         LE_PEER_EXIT            = 9,
<a name="l03467"></a>03467         LE_CONDITIONAL_DESTROY  = 10,
<a name="l03468"></a>03468         LE_PAIRS_VERIFY         = 11,
<a name="l03469"></a>03469         LE_SKIP_NLINK_DECLARE   = 13,
<a name="l03470"></a>03470         LE_SKIP_NLINK           = 14,
<a name="l03471"></a>03471         LE_SET_LMV_MASTER       = 15,
<a name="l03472"></a>03472         LE_SET_LMV_SLAVE        = 16,
<a name="l03473"></a>03473 };
<a name="l03474"></a>03474 
<a name="l03475"></a>03475 <span class="keyword">enum</span> lfsck_event_flags {
<a name="l03476"></a>03476         LEF_TO_OST              = 0x00000001,
<a name="l03477"></a>03477         LEF_FROM_OST            = 0x00000002,
<a name="l03478"></a>03478         LEF_SET_LMV_HASH        = 0x00000004,
<a name="l03479"></a>03479         LEF_SET_LMV_ALL         = 0x00000008,
<a name="l03480"></a>03480         LEF_RECHECK_NAME_HASH   = 0x00000010,
<a name="l03481"></a>03481         LEF_QUERY_ALL           = 0x00000020,
<a name="l03482"></a>03482 };
<a name="l03483"></a>03483 
<a name="l03484"></a>03484 <span class="comment">/* request structure for OST&apos;s */</span>
<a name="l03485"></a><a class="code" href="structost__body.html">03485</a> <span class="keyword">struct </span><a class="code" href="structost__body.html">ost_body</a> {
<a name="l03486"></a>03486         <span class="keyword">struct </span><a class="code" href="structobdo.html">obdo</a> oa;
<a name="l03487"></a>03487 };
<a name="l03488"></a>03488 
<a name="l03489"></a>03489 <span class="comment">/* Key for FIEMAP to be used in get_info calls */</span>
<a name="l03490"></a><a class="code" href="structll__fiemap__info__key.html">03490</a> <span class="keyword">struct </span><a class="code" href="structll__fiemap__info__key.html">ll_fiemap_info_key</a> {
<a name="l03491"></a>03491         <span class="keywordtype">char</span>            lfik_name[8];
<a name="l03492"></a>03492         <span class="keyword">struct </span><a class="code" href="structobdo.html">obdo</a>     lfik_oa;
<a name="l03493"></a>03493         <span class="keyword">struct </span>fiemap   lfik_fiemap;
<a name="l03494"></a>03494 };
<a name="l03495"></a>03495 
<a name="l03496"></a>03496 <span class="keywordtype">void</span> lustre_print_user_md(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level, <span class="keyword">struct</span> lov_user_md *lum,
<a name="l03497"></a>03497                           <span class="keyword">const</span> <span class="keywordtype">char</span> *msg);
<a name="l03498"></a>03498 
<a name="l03499"></a>03499 <span class="comment">/* Functions for dumping PTLRPC fields */</span>
<a name="l03500"></a>03500 <span class="keywordtype">void</span> dump_rniobuf(<span class="keyword">struct</span> <a class="code" href="structniobuf__remote.html">niobuf_remote</a> *rnb);
<a name="l03501"></a>03501 <span class="keywordtype">void</span> dump_ioo(<span class="keyword">struct</span> <a class="code" href="structobd__ioobj.html">obd_ioobj</a> *nb);
<a name="l03502"></a>03502 <span class="keywordtype">void</span> dump_ost_body(<span class="keyword">struct</span> <a class="code" href="structost__body.html">ost_body</a> *ob);
<a name="l03503"></a>03503 <span class="keywordtype">void</span> dump_rcs(__u32 *rc);
<a name="l03504"></a>03504 
<a name="l03505"></a>03505 <span class="preprocessor">#define IDX_INFO_MAGIC 0x3D37CC37</span>
<a name="l03506"></a>03506 <span class="preprocessor"></span>
<a name="l03507"></a>03507 <span class="comment">/* Index file transfer through the network. The server serializes the index into</span>
<a name="l03508"></a>03508 <span class="comment"> * a byte stream which is sent to the client via a bulk transfer */</span>
<a name="l03509"></a><a class="code" href="structidx__info.html">03509</a> <span class="keyword">struct </span><a class="code" href="structidx__info.html">idx_info</a> {
<a name="l03510"></a>03510         __u32           ii_magic;
<a name="l03511"></a>03511 
<a name="l03512"></a>03512         <span class="comment">/* reply: see idx_info_flags below */</span>
<a name="l03513"></a>03513         __u32           ii_flags;
<a name="l03514"></a>03514 
<a name="l03515"></a>03515         <span class="comment">/* request &amp; reply: number of lu_idxpage (to be) transferred */</span>
<a name="l03516"></a>03516         __u16           ii_count;
<a name="l03517"></a>03517         __u16           ii_pad0;
<a name="l03518"></a>03518 
<a name="l03519"></a>03519         <span class="comment">/* request: requested attributes passed down to the iterator API */</span>
<a name="l03520"></a>03520         __u32           ii_attrs;
<a name="l03521"></a>03521 
<a name="l03522"></a>03522         <span class="comment">/* request &amp; reply: index file identifier (FID) */</span>
<a name="l03523"></a>03523         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   ii_fid;
<a name="l03524"></a>03524 
<a name="l03525"></a>03525         <span class="comment">/* reply: version of the index file before starting to walk the index.</span>
<a name="l03526"></a>03526 <span class="comment">         * Please note that the version can be modified at any time during the</span>
<a name="l03527"></a>03527 <span class="comment">         * transfer */</span>
<a name="l03528"></a>03528         __u64           ii_version;
<a name="l03529"></a>03529 
<a name="l03530"></a>03530         <span class="comment">/* request: hash to start with:</span>
<a name="l03531"></a>03531 <span class="comment">         * reply: hash of the first entry of the first lu_idxpage and hash</span>
<a name="l03532"></a>03532 <span class="comment">         *        of the entry to read next if any */</span>
<a name="l03533"></a>03533         __u64           ii_hash_start;
<a name="l03534"></a>03534         __u64           ii_hash_end;
<a name="l03535"></a>03535 
<a name="l03536"></a>03536         <span class="comment">/* reply: size of keys in lu_idxpages, minimal one if II_FL_VARKEY is</span>
<a name="l03537"></a>03537 <span class="comment">         * set */</span>
<a name="l03538"></a>03538         __u16           ii_keysize;
<a name="l03539"></a>03539 
<a name="l03540"></a>03540         <span class="comment">/* reply: size of records in lu_idxpages, minimal one if II_FL_VARREC</span>
<a name="l03541"></a>03541 <span class="comment">         * is set */</span>
<a name="l03542"></a>03542         __u16           ii_recsize;
<a name="l03543"></a>03543 
<a name="l03544"></a>03544         __u32           ii_pad1;
<a name="l03545"></a>03545         __u64           ii_pad2;
<a name="l03546"></a>03546         __u64           ii_pad3;
<a name="l03547"></a>03547 };
<a name="l03548"></a>03548 
<a name="l03549"></a>03549 <span class="preprocessor">#define II_END_OFF      MDS_DIR_END_OFF </span><span class="comment">/* all entries have been read */</span>
<a name="l03550"></a>03550 
<a name="l03551"></a>03551 <span class="comment">/* List of flags used in idx_info::ii_flags */</span>
<a name="l03552"></a>03552 <span class="keyword">enum</span> idx_info_flags {
<a name="l03553"></a>03553         II_FL_NOHASH    = 1 &lt;&lt; 0, <span class="comment">/* client doesn&apos;t care about hash value */</span>
<a name="l03554"></a>03554         II_FL_VARKEY    = 1 &lt;&lt; 1, <span class="comment">/* keys can be of variable size */</span>
<a name="l03555"></a>03555         II_FL_VARREC    = 1 &lt;&lt; 2, <span class="comment">/* records can be of variable size */</span>
<a name="l03556"></a>03556         II_FL_NONUNQ    = 1 &lt;&lt; 3, <span class="comment">/* index supports non-unique keys */</span>
<a name="l03557"></a>03557         II_FL_NOKEY     = 1 &lt;&lt; 4, <span class="comment">/* client doesn&apos;t care about key */</span>
<a name="l03558"></a>03558 };
<a name="l03559"></a>03559 
<a name="l03560"></a>03560 <span class="preprocessor">#define LIP_MAGIC 0x8A6D6B6C</span>
<a name="l03561"></a>03561 <span class="preprocessor"></span>
<a name="l03562"></a>03562 <span class="comment">/* 4KB (= LU_PAGE_SIZE) container gathering key/record pairs */</span>
<a name="l03563"></a><a class="code" href="structlu__idxpage.html">03563</a> <span class="keyword">struct </span><a class="code" href="structlu__idxpage.html">lu_idxpage</a> {
<a name="l03564"></a>03564         <span class="comment">/* 16-byte header */</span>
<a name="l03565"></a>03565         __u32   lip_magic;
<a name="l03566"></a>03566         __u16   lip_flags;
<a name="l03567"></a>03567         __u16   lip_nr;   <span class="comment">/* number of entries in the container */</span>
<a name="l03568"></a>03568         __u64   lip_pad0; <span class="comment">/* additional padding for future use */</span>
<a name="l03569"></a>03569 
<a name="l03570"></a>03570         <span class="comment">/* key/record pairs are stored in the remaining 4080 bytes.</span>
<a name="l03571"></a>03571 <span class="comment">         * depending upon the flags in idx_info::ii_flags, each key/record</span>
<a name="l03572"></a>03572 <span class="comment">         * pair might be preceded by:</span>
<a name="l03573"></a>03573 <span class="comment">         * - a hash value</span>
<a name="l03574"></a>03574 <span class="comment">         * - the key size (II_FL_VARKEY is set)</span>
<a name="l03575"></a>03575 <span class="comment">         * - the record size (II_FL_VARREC is set)</span>
<a name="l03576"></a>03576 <span class="comment">         *</span>
<a name="l03577"></a>03577 <span class="comment">         * For the time being, we only support fixed-size key &amp; record. */</span>
<a name="l03578"></a>03578         <span class="keywordtype">char</span>    lip_entries[0];
<a name="l03579"></a>03579 };
<a name="l03580"></a>03580 
<a name="l03581"></a>03581 <span class="preprocessor">#define LIP_HDR_SIZE (offsetof(struct lu_idxpage, lip_entries))</span>
<a name="l03582"></a>03582 <span class="preprocessor"></span>
<a name="l03583"></a>03583 <span class="comment">/* Gather all possible type associated with a 4KB container */</span>
<a name="l03584"></a><a class="code" href="unionlu__page.html">03584</a> <span class="keyword">union </span><a class="code" href="unionlu__page.html">lu_page</a> {
<a name="l03585"></a>03585         <span class="keyword">struct </span><a class="code" href="structlu__dirpage.html">lu_dirpage</a>       lp_dir; <span class="comment">/* for MDS_READPAGE */</span>
<a name="l03586"></a>03586         <span class="keyword">struct </span><a class="code" href="structlu__idxpage.html">lu_idxpage</a>       lp_idx; <span class="comment">/* for OBD_IDX_READ */</span>
<a name="l03587"></a>03587         <span class="keywordtype">char</span>                    lp_array[LU_PAGE_SIZE];
<a name="l03588"></a>03588 };
<a name="l03589"></a>03589 
<a name="l03590"></a>03590 <span class="comment">/* security opcodes */</span>
<a name="l03591"></a>03591 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l03592"></a>03592         SEC_CTX_INIT            = 801,
<a name="l03593"></a>03593         SEC_CTX_INIT_CONT       = 802,
<a name="l03594"></a>03594         SEC_CTX_FINI            = 803,
<a name="l03595"></a>03595         SEC_LAST_OPC,
<a name="l03596"></a>03596         SEC_FIRST_OPC           = SEC_CTX_INIT
<a name="l03597"></a>03597 } sec_cmd_t;
<a name="l03598"></a>03598 
<a name="l03599"></a>03599 <span class="comment">/*</span>
<a name="l03600"></a>03600 <span class="comment"> * capa related definitions</span>
<a name="l03601"></a>03601 <span class="comment"> */</span>
<a name="l03602"></a>03602 <span class="preprocessor">#define CAPA_HMAC_MAX_LEN       64</span>
<a name="l03603"></a>03603 <span class="preprocessor"></span><span class="preprocessor">#define CAPA_HMAC_KEY_MAX_LEN   56</span>
<a name="l03604"></a>03604 <span class="preprocessor"></span>
<a name="l03605"></a>03605 <span class="comment">/* NB take care when changing the sequence of elements this struct,</span>
<a name="l03606"></a>03606 <span class="comment"> * because the offset info is used in find_capa() */</span>
<a name="l03607"></a><a class="code" href="structlustre__capa.html">03607</a> <span class="keyword">struct </span><a class="code" href="structlustre__capa.html">lustre_capa</a> {
<a name="l03608"></a>03608         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   lc_fid;         
<a name="l03609"></a><a class="code" href="structlustre__capa.html#a3c8a934723757fdff76cbdcf57e98081">03609</a>         __u64           <a class="code" href="structlustre__capa.html#a3c8a934723757fdff76cbdcf57e98081" title="fid">lc_opc</a>;         
<a name="l03610"></a><a class="code" href="structlustre__capa.html#ad23343416034ff9d6c87470b735e885f">03610</a>         __u64           <a class="code" href="structlustre__capa.html#ad23343416034ff9d6c87470b735e885f" title="operations allowed">lc_uid</a>;         
<a name="l03611"></a><a class="code" href="structlustre__capa.html#aab30292d592a4457f0265d835cb9947a">03611</a>         __u64           <a class="code" href="structlustre__capa.html#aab30292d592a4457f0265d835cb9947a" title="file owner">lc_gid</a>;         
<a name="l03612"></a><a class="code" href="structlustre__capa.html#ae8ce626abaa10c91db7d97364cc4120c">03612</a>         __u32           <a class="code" href="structlustre__capa.html#ae8ce626abaa10c91db7d97364cc4120c" title="file group">lc_flags</a>;       
<a name="l03613"></a><a class="code" href="structlustre__capa.html#abdbc84a651e041754fb3d482b0454c46">03613</a>         __u32           <a class="code" href="structlustre__capa.html#abdbc84a651e041754fb3d482b0454c46" title="HMAC algorithm &amp;amp; flags.">lc_keyid</a>;       
<a name="l03614"></a><a class="code" href="structlustre__capa.html#aefe24f64adc6af336c8b5e1381d74893">03614</a>         __u32           <a class="code" href="structlustre__capa.html#aefe24f64adc6af336c8b5e1381d74893" title="key# used for the capability">lc_timeout</a>;     
<a name="l03615"></a><a class="code" href="structlustre__capa.html#a4dbc96478c2d7bcc08f948540811e5c4">03615</a>         __u32           <a class="code" href="structlustre__capa.html#a4dbc96478c2d7bcc08f948540811e5c4" title="capa timeout value (sec)">lc_expiry</a>;      
<a name="l03616"></a><a class="code" href="structlustre__capa.html#a346a2be351543eb3f0607f9e47e93703">03616</a>         __u8            <a class="code" href="structlustre__capa.html#a346a2be351543eb3f0607f9e47e93703" title="expiry time (sec)">lc_hmac</a>[CAPA_HMAC_MAX_LEN];   
<a name="l03617"></a>03617 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03618"></a>03618 
<a name="l03620"></a>03620 <span class="keyword">enum</span> {
<a name="l03621"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181faa7a9dd0dc7d6379cdb02ae5ef99b22b7">03621</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181faa7a9dd0dc7d6379cdb02ae5ef99b22b7" title="write object data">CAPA_OPC_BODY_WRITE</a>   = 1&lt;&lt;0,  
<a name="l03622"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa733f97e5d3613df5d34383fe8cdf093d">03622</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa733f97e5d3613df5d34383fe8cdf093d" title="read object data">CAPA_OPC_BODY_READ</a>    = 1&lt;&lt;1,  
<a name="l03623"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fac17de419c843923a0f7a9f753ab6459d">03623</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fac17de419c843923a0f7a9f753ab6459d" title="lookup object fid">CAPA_OPC_INDEX_LOOKUP</a> = 1&lt;&lt;2,  
<a name="l03624"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fafc8d115f699e0ba82a3a70deed659abf">03624</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fafc8d115f699e0ba82a3a70deed659abf" title="insert object fid">CAPA_OPC_INDEX_INSERT</a> = 1&lt;&lt;3,  
<a name="l03625"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa3c098388950b20de2ca26bd8801e2de7">03625</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa3c098388950b20de2ca26bd8801e2de7" title="delete object fid">CAPA_OPC_INDEX_DELETE</a> = 1&lt;&lt;4,  
<a name="l03626"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa667ee92b8de866096746722b54659542">03626</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa667ee92b8de866096746722b54659542" title="write oss object data">CAPA_OPC_OSS_WRITE</a>    = 1&lt;&lt;5,  
<a name="l03627"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa69b17abcba8a5eafd1aad2d634d2780a">03627</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa69b17abcba8a5eafd1aad2d634d2780a" title="read oss object data">CAPA_OPC_OSS_READ</a>     = 1&lt;&lt;6,  
<a name="l03628"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa47502b60956db2ce5fd1569fe9b131af">03628</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa47502b60956db2ce5fd1569fe9b131af" title="truncate oss object">CAPA_OPC_OSS_TRUNC</a>    = 1&lt;&lt;7,  
<a name="l03629"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa92f3992d62328eaa6a24071f4c92c665">03629</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa92f3992d62328eaa6a24071f4c92c665" title="destroy oss object">CAPA_OPC_OSS_DESTROY</a>  = 1&lt;&lt;8,  
<a name="l03630"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa197c8502e167a44f157185ec6eff1535">03630</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fa197c8502e167a44f157185ec6eff1535" title="write object meta data">CAPA_OPC_META_WRITE</a>   = 1&lt;&lt;9,  
<a name="l03631"></a><a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fad9ed3b88c8a9ea393510bda56889f182">03631</a>         <a class="code" href="group__lustreidl.html#gga5d76b81b0ad4c19007a781d4edb8181fad9ed3b88c8a9ea393510bda56889f182" title="read object meta data">CAPA_OPC_META_READ</a>    = 1&lt;&lt;10, 
<a name="l03632"></a>03632 };
<a name="l03633"></a>03633 
<a name="l03634"></a>03634 <span class="preprocessor">#define CAPA_OPC_OSS_RW (CAPA_OPC_OSS_READ | CAPA_OPC_OSS_WRITE)</span>
<a name="l03635"></a>03635 <span class="preprocessor"></span><span class="preprocessor">#define CAPA_OPC_MDS_ONLY                                                   \</span>
<a name="l03636"></a>03636 <span class="preprocessor">        (CAPA_OPC_BODY_WRITE | CAPA_OPC_BODY_READ | CAPA_OPC_INDEX_LOOKUP | \</span>
<a name="l03637"></a>03637 <span class="preprocessor">         CAPA_OPC_INDEX_INSERT | CAPA_OPC_INDEX_DELETE)</span>
<a name="l03638"></a>03638 <span class="preprocessor"></span><span class="preprocessor">#define CAPA_OPC_OSS_ONLY                                                   \</span>
<a name="l03639"></a>03639 <span class="preprocessor">        (CAPA_OPC_OSS_WRITE | CAPA_OPC_OSS_READ | CAPA_OPC_OSS_TRUNC |      \</span>
<a name="l03640"></a>03640 <span class="preprocessor">         CAPA_OPC_OSS_DESTROY)</span>
<a name="l03641"></a>03641 <span class="preprocessor"></span><span class="preprocessor">#define CAPA_OPC_MDS_DEFAULT ~CAPA_OPC_OSS_ONLY</span>
<a name="l03642"></a>03642 <span class="preprocessor"></span><span class="preprocessor">#define CAPA_OPC_OSS_DEFAULT ~(CAPA_OPC_MDS_ONLY | CAPA_OPC_OSS_ONLY)</span>
<a name="l03643"></a>03643 <span class="preprocessor"></span>
<a name="l03644"></a>03644 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> lovea_slot_is_dummy(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlov__ost__data__v1.html">lov_ost_data_v1</a> *obj)
<a name="l03645"></a>03645 {
<a name="l03646"></a>03646         <span class="comment">/* zero area does not care about the bytes-order. */</span>
<a name="l03647"></a>03647         <span class="keywordflow">if</span> (obj-&gt;l_ost_oi.oi.oi_id == 0 &amp;&amp; obj-&gt;l_ost_oi.oi.oi_seq == 0 &amp;&amp;
<a name="l03648"></a>03648             obj-&gt;l_ost_idx == 0 &amp;&amp; obj-&gt;l_ost_gen == 0)
<a name="l03649"></a>03649                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03650"></a>03650 
<a name="l03651"></a>03651         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03652"></a>03652 }
<a name="l03653"></a>03653 
<a name="l03654"></a>03654 <span class="comment">/* lustre_capa::lc_hmac_alg */</span>
<a name="l03655"></a>03655 <span class="keyword">enum</span> {
<a name="l03656"></a><a class="code" href="group__lustreidl.html#ggaac34dfe6c6b73b43a4656c9dce041034a6122b41fa01740b9c48d367a23150847">03656</a>         <a class="code" href="group__lustreidl.html#ggaac34dfe6c6b73b43a4656c9dce041034a6122b41fa01740b9c48d367a23150847" title="sha1 algorithm">CAPA_HMAC_ALG_SHA1</a> = 1, 
<a name="l03657"></a>03657         CAPA_HMAC_ALG_MAX,
<a name="l03658"></a>03658 };
<a name="l03659"></a>03659 
<a name="l03660"></a>03660 <span class="preprocessor">#define CAPA_FL_MASK            0x00ffffff</span>
<a name="l03661"></a>03661 <span class="preprocessor"></span><span class="preprocessor">#define CAPA_HMAC_ALG_MASK      0xff000000</span>
<a name="l03662"></a>03662 <span class="preprocessor"></span>
<a name="l03663"></a><a class="code" href="structlustre__capa__key.html">03663</a> <span class="keyword">struct </span><a class="code" href="structlustre__capa__key.html">lustre_capa_key</a> {
<a name="l03664"></a><a class="code" href="structlustre__capa__key.html#a66b2a9f0deeb906d774b4fdc187cc75e">03664</a>         __u64   <a class="code" href="structlustre__capa__key.html#a66b2a9f0deeb906d774b4fdc187cc75e" title="mds#">lk_seq</a>;       
<a name="l03665"></a><a class="code" href="structlustre__capa__key.html#a5e0170a1da4e009e6962d65836f5ec53">03665</a>         __u32   <a class="code" href="structlustre__capa__key.html#a5e0170a1da4e009e6962d65836f5ec53" title="key#">lk_keyid</a>;     
<a name="l03666"></a>03666         __u32   lk_padding;
<a name="l03667"></a><a class="code" href="structlustre__capa__key.html#a16e960cd4c7f6fe0a830763f52629096">03667</a>         __u8    <a class="code" href="structlustre__capa__key.html#a16e960cd4c7f6fe0a830763f52629096" title="key">lk_key</a>[CAPA_HMAC_KEY_MAX_LEN];    
<a name="l03668"></a>03668 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03669"></a>03669 
<a name="l03671"></a><a class="code" href="group__lustreidl.html#gae31093a0ed66ab78162b36145638a2a0">03671</a> <span class="preprocessor">#define LINK_EA_MAGIC 0x11EAF1DFUL</span>
<a name="l03672"></a><a class="code" href="structlink__ea__header.html">03672</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structlink__ea__header.html">link_ea_header</a> {
<a name="l03673"></a>03673         __u32 leh_magic;
<a name="l03674"></a>03674         __u32 leh_reccount;
<a name="l03675"></a>03675         __u64 leh_len;      <span class="comment">/* total size */</span>
<a name="l03676"></a>03676         <span class="comment">/* future use */</span>
<a name="l03677"></a>03677         __u32 padding1;
<a name="l03678"></a>03678         __u32 padding2;
<a name="l03679"></a>03679 };
<a name="l03680"></a>03680 
<a name="l03684"></a><a class="code" href="structlink__ea__entry.html">03684</a> <span class="keyword">struct </span><a class="code" href="structlink__ea__entry.html" title="Hardlink data is name and parent fid.">link_ea_entry</a> {
<a name="l03686"></a><a class="code" href="structlink__ea__entry.html#ac329c586a9a51a478d70ac9d3694bf2a">03686</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>      <a class="code" href="structlink__ea__entry.html#ac329c586a9a51a478d70ac9d3694bf2a" title="__u16 stored big-endian, unaligned">lee_reclen</a>[2];
<a name="l03687"></a>03687         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>      lee_parent_fid[<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>)];
<a name="l03688"></a>03688         <span class="keywordtype">char</span>               lee_name[0];
<a name="l03689"></a>03689 }__attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03690"></a>03690 
<a name="l03692"></a><a class="code" href="structgetinfo__fid2path.html">03692</a> <span class="keyword">struct </span><a class="code" href="structgetinfo__fid2path.html" title="fid2path request/reply structure">getinfo_fid2path</a> {
<a name="l03693"></a>03693         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   gf_fid;
<a name="l03694"></a>03694         __u64           gf_recno;
<a name="l03695"></a>03695         __u32           gf_linkno;
<a name="l03696"></a>03696         __u32           gf_pathlen;
<a name="l03697"></a>03697         <span class="keyword">union </span>{
<a name="l03698"></a>03698                 <span class="keywordtype">char</span>            gf_path[0];
<a name="l03699"></a>03699                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   gf_root_fid[0];
<a name="l03700"></a>03700         } gf_u;
<a name="l03701"></a>03701 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03702"></a>03702 
<a name="l03704"></a><a class="code" href="structgetparent.html">03704</a> <span class="keyword">struct </span><a class="code" href="structgetparent.html" title="path2parent request/reply structures">getparent</a> {
<a name="l03705"></a><a class="code" href="structgetparent.html#a6612847ce0e2a2ba08995d36e22cfb0e">03705</a>         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   <a class="code" href="structgetparent.html#a6612847ce0e2a2ba08995d36e22cfb0e" title="parent FID">gp_fid</a>;         
<a name="l03706"></a><a class="code" href="structgetparent.html#a05dbdc02fc7084cb7e823399e9f03609">03706</a>         __u32           <a class="code" href="structgetparent.html#a05dbdc02fc7084cb7e823399e9f03609" title="hardlink number">gp_linkno</a>;      
<a name="l03707"></a><a class="code" href="structgetparent.html#a9cb02d74dfc853f58a5bca0587a46964">03707</a>         __u32           <a class="code" href="structgetparent.html#a9cb02d74dfc853f58a5bca0587a46964" title="size of the name field">gp_name_size</a>;   
<a name="l03708"></a><a class="code" href="structgetparent.html#a5e77c308b670177b24442832290f1293">03708</a>         <span class="keywordtype">char</span>            <a class="code" href="structgetparent.html#a5e77c308b670177b24442832290f1293" title="zero-terminated link name">gp_name</a>[0];     
<a name="l03709"></a>03709 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03710"></a>03710 
<a name="l03711"></a>03711 <span class="keyword">enum</span> {
<a name="l03712"></a>03712         LAYOUT_INTENT_ACCESS    = 0,
<a name="l03713"></a>03713         LAYOUT_INTENT_READ      = 1,
<a name="l03714"></a>03714         LAYOUT_INTENT_WRITE     = 2,
<a name="l03715"></a>03715         LAYOUT_INTENT_GLIMPSE   = 3,
<a name="l03716"></a>03716         LAYOUT_INTENT_TRUNC     = 4,
<a name="l03717"></a>03717         LAYOUT_INTENT_RELEASE   = 5,
<a name="l03718"></a>03718         LAYOUT_INTENT_RESTORE   = 6
<a name="l03719"></a>03719 };
<a name="l03720"></a>03720 
<a name="l03721"></a>03721 <span class="comment">/* enqueue layout lock with intent */</span>
<a name="l03722"></a><a class="code" href="structlayout__intent.html">03722</a> <span class="keyword">struct </span><a class="code" href="structlayout__intent.html">layout_intent</a> {
<a name="l03723"></a>03723         __u32 li_opc; <span class="comment">/* intent operation for enqueue, read, write etc */</span>
<a name="l03724"></a>03724         __u32 li_flags;
<a name="l03725"></a>03725         __u64 li_start;
<a name="l03726"></a>03726         __u64 li_end;
<a name="l03727"></a>03727 };
<a name="l03728"></a>03728 
<a name="l03734"></a><a class="code" href="structhsm__progress__kernel.html">03734</a> <span class="keyword">struct </span><a class="code" href="structhsm__progress__kernel.html" title="On the wire version of hsm_progress structure.">hsm_progress_kernel</a> {
<a name="l03735"></a>03735         <span class="comment">/* Field taken from struct hsm_progress */</span>
<a name="l03736"></a>03736         <a class="code" href="structlu__fid.html" title="File IDentifier.">lustre_fid</a>              hpk_fid;
<a name="l03737"></a>03737         __u64                   hpk_cookie;
<a name="l03738"></a>03738         <span class="keyword">struct </span><a class="code" href="structhsm__extent.html">hsm_extent</a>       hpk_extent;
<a name="l03739"></a>03739         __u16                   hpk_flags;
<a name="l03740"></a>03740         __u16                   hpk_errval; <span class="comment">/* positive val */</span>
<a name="l03741"></a>03741         __u32                   hpk_padding1;
<a name="l03742"></a>03742         <span class="comment">/* Additional fields */</span>
<a name="l03743"></a>03743         __u64                   hpk_data_version;
<a name="l03744"></a>03744         __u64                   hpk_padding2;
<a name="l03745"></a>03745 } __attribute__((<a class="code" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb" title="Identifier for a single log object.">packed</a>));
<a name="l03746"></a>03746 
<a name="l03783"></a><a class="code" href="group__lustreidl.html#ga2d1a90f202540bfbcbd72a8c0f94b586">03783</a> <span class="keyword">enum</span> <a class="code" href="group__lustreidl.html#ga2d1a90f202540bfbcbd72a8c0f94b586" title="OUT_UPDATE RPC Format.">update_type</a> {
<a name="l03784"></a>03784         OUT_START               = 0,
<a name="l03785"></a>03785         OUT_CREATE              = 1,
<a name="l03786"></a>03786         OUT_DESTROY             = 2,
<a name="l03787"></a>03787         OUT_REF_ADD             = 3,
<a name="l03788"></a>03788         OUT_REF_DEL             = 4,
<a name="l03789"></a>03789         OUT_ATTR_SET            = 5,
<a name="l03790"></a>03790         OUT_ATTR_GET            = 6,
<a name="l03791"></a>03791         OUT_XATTR_SET           = 7,
<a name="l03792"></a>03792         OUT_XATTR_GET           = 8,
<a name="l03793"></a>03793         OUT_INDEX_LOOKUP        = 9,
<a name="l03794"></a>03794         OUT_INDEX_INSERT        = 10,
<a name="l03795"></a>03795         OUT_INDEX_DELETE        = 11,
<a name="l03796"></a>03796         OUT_WRITE               = 12,
<a name="l03797"></a>03797         OUT_XATTR_DEL           = 13,
<a name="l03798"></a>03798         OUT_PUNCH               = 14,
<a name="l03799"></a>03799         OUT_READ                = 15,
<a name="l03800"></a>03800         OUT_NOOP                = 16,
<a name="l03801"></a>03801         OUT_LAST
<a name="l03802"></a>03802 };
<a name="l03803"></a>03803 
<a name="l03804"></a>03804 <span class="keyword">enum</span> update_flag {
<a name="l03805"></a>03805         UPDATE_FL_OST           = 0x00000001,   <span class="comment">/* op from OST (not MDT) */</span>
<a name="l03806"></a>03806         UPDATE_FL_SYNC          = 0x00000002,   <span class="comment">/* commit before replying */</span>
<a name="l03807"></a>03807         UPDATE_FL_COMMITTED     = 0x00000004,   <span class="comment">/* op committed globally */</span>
<a name="l03808"></a>03808         UPDATE_FL_NOLOG         = 0x00000008    <span class="comment">/* for idempotent updates */</span>
<a name="l03809"></a>03809 };
<a name="l03810"></a>03810 
<a name="l03811"></a><a class="code" href="structobject__update__param.html">03811</a> <span class="keyword">struct </span><a class="code" href="structobject__update__param.html">object_update_param</a> {
<a name="l03812"></a>03812         __u16   oup_len;        <span class="comment">/* length of this parameter */</span>
<a name="l03813"></a>03813         __u16   oup_padding;
<a name="l03814"></a>03814         __u32   oup_padding2;
<a name="l03815"></a>03815         <span class="keywordtype">char</span>    oup_buf[0];
<a name="l03816"></a>03816 };
<a name="l03817"></a>03817 
<a name="l03818"></a>03818 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span>
<a name="l03819"></a>03819 object_update_param_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobject__update__param.html">object_update_param</a> *param)
<a name="l03820"></a>03820 {
<a name="l03821"></a>03821         <span class="keywordflow">return</span> cfs_size_round(<span class="keyword">sizeof</span>(*param) + param-&gt;oup_len);
<a name="l03822"></a>03822 }
<a name="l03823"></a>03823 
<a name="l03824"></a>03824 <span class="comment">/* object update */</span>
<a name="l03825"></a><a class="code" href="structobject__update.html">03825</a> <span class="keyword">struct </span><a class="code" href="structobject__update.html">object_update</a> {
<a name="l03826"></a>03826         __u16           ou_type;                <span class="comment">/* enum update_type */</span>
<a name="l03827"></a>03827         __u16           ou_params_count;        <span class="comment">/* update parameters count */</span>
<a name="l03828"></a>03828         __u32           ou_result_size;         <span class="comment">/* how many bytes can return */</span>
<a name="l03829"></a>03829         __u32           ou_flags;               <span class="comment">/* enum update_flag */</span>
<a name="l03830"></a>03830         __u32           ou_padding1;            <span class="comment">/* padding 1 */</span>
<a name="l03831"></a>03831         __u64           ou_batchid;             <span class="comment">/* op transno on master */</span>
<a name="l03832"></a>03832         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   ou_fid;                 <span class="comment">/* object to be updated */</span>
<a name="l03833"></a>03833         <span class="keyword">struct </span><a class="code" href="structobject__update__param.html">object_update_param</a> ou_params[0]; <span class="comment">/* update params */</span>
<a name="l03834"></a>03834 };
<a name="l03835"></a>03835 
<a name="l03836"></a>03836 <span class="preprocessor">#define UPDATE_REQUEST_MAGIC_V1 0xBDDE0001</span>
<a name="l03837"></a>03837 <span class="preprocessor"></span><span class="preprocessor">#define UPDATE_REQUEST_MAGIC_V2 0xBDDE0002</span>
<a name="l03838"></a>03838 <span class="preprocessor"></span><span class="preprocessor">#define UPDATE_REQUEST_MAGIC    UPDATE_REQUEST_MAGIC_V2</span>
<a name="l03839"></a>03839 <span class="preprocessor"></span><span class="comment">/* Hold object_updates sending to the remote OUT in single RPC */</span>
<a name="l03840"></a><a class="code" href="structobject__update__request.html">03840</a> <span class="keyword">struct </span><a class="code" href="structobject__update__request.html">object_update_request</a> {
<a name="l03841"></a>03841         __u32                   ourq_magic;
<a name="l03842"></a>03842         __u16                   ourq_count;     <span class="comment">/* number of ourq_updates[] */</span>
<a name="l03843"></a>03843         __u16                   ourq_padding;
<a name="l03844"></a>03844         <span class="keyword">struct </span><a class="code" href="structobject__update.html">object_update</a>    ourq_updates[0];
<a name="l03845"></a>03845 };
<a name="l03846"></a>03846 
<a name="l03847"></a>03847 <span class="preprocessor">#define OUT_UPDATE_HEADER_MAGIC         0xBDDF0001</span>
<a name="l03848"></a>03848 <span class="preprocessor"></span><span class="preprocessor">#define OUT_UPDATE_MAX_INLINE_SIZE      4096</span>
<a name="l03849"></a>03849 <span class="preprocessor"></span><span class="comment">/* Header for updates request between MDTs */</span>
<a name="l03850"></a><a class="code" href="structout__update__header.html">03850</a> <span class="keyword">struct </span><a class="code" href="structout__update__header.html">out_update_header</a> {
<a name="l03851"></a>03851         __u32           ouh_magic;
<a name="l03852"></a>03852         __u32           ouh_count;
<a name="l03853"></a>03853         __u32           ouh_inline_length;
<a name="l03854"></a>03854         __u32           ouh_reply_size;
<a name="l03855"></a>03855         __u32           ouh_inline_data[0];
<a name="l03856"></a>03856 };
<a name="l03857"></a>03857 
<a name="l03858"></a><a class="code" href="structout__update__buffer.html">03858</a> <span class="keyword">struct </span><a class="code" href="structout__update__buffer.html">out_update_buffer</a> {
<a name="l03859"></a>03859         __u32   oub_size;
<a name="l03860"></a>03860         __u32   oub_padding;
<a name="l03861"></a>03861 };
<a name="l03862"></a>03862 
<a name="l03863"></a>03863 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span>
<a name="l03864"></a>03864 object_update_params_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobject__update.html">object_update</a> *update)
<a name="l03865"></a>03865 {
<a name="l03866"></a>03866         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structobject__update__param.html">object_update_param</a> *param;
<a name="l03867"></a>03867         <span class="keywordtype">size_t</span>                           total_size = 0;
<a name="l03868"></a>03868         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     i;
<a name="l03869"></a>03869 
<a name="l03870"></a>03870         param = &amp;update-&gt;ou_params[0];
<a name="l03871"></a>03871         <span class="keywordflow">for</span> (i = 0; i &lt; update-&gt;ou_params_count; i++) {
<a name="l03872"></a>03872                 <span class="keywordtype">size_t</span> size = object_update_param_size(param);
<a name="l03873"></a>03873 
<a name="l03874"></a>03874                 param = (<span class="keyword">struct </span><a class="code" href="structobject__update__param.html">object_update_param</a> *)((<span class="keywordtype">char</span> *)param + size);
<a name="l03875"></a>03875                 total_size += size;
<a name="l03876"></a>03876         }
<a name="l03877"></a>03877 
<a name="l03878"></a>03878         <span class="keywordflow">return</span> total_size;
<a name="l03879"></a>03879 }
<a name="l03880"></a>03880 
<a name="l03881"></a>03881 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span>
<a name="l03882"></a>03882 object_update_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobject__update.html">object_update</a> *update)
<a name="l03883"></a>03883 {
<a name="l03884"></a>03884         <span class="keywordflow">return</span> offsetof(<span class="keyword">struct</span> <a class="code" href="structobject__update.html">object_update</a>, ou_params[0]) +
<a name="l03885"></a>03885                object_update_params_size(update);
<a name="l03886"></a>03886 }
<a name="l03887"></a>03887 
<a name="l03888"></a>03888 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structobject__update.html">object_update</a> *
<a name="l03889"></a>03889 object_update_request_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobject__update__request.html">object_update_request</a> *our,
<a name="l03890"></a>03890                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index, <span class="keywordtype">size_t</span> *size)
<a name="l03891"></a>03891 {
<a name="l03892"></a>03892         <span class="keywordtype">void</span>    *ptr;
<a name="l03893"></a>03893         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l03894"></a>03894 
<a name="l03895"></a>03895         <span class="keywordflow">if</span> (index &gt;= our-&gt;ourq_count)
<a name="l03896"></a>03896                 <span class="keywordflow">return</span> NULL;
<a name="l03897"></a>03897 
<a name="l03898"></a>03898         ptr = (<span class="keywordtype">void</span> *)&amp;our-&gt;ourq_updates[0];
<a name="l03899"></a>03899         for (i = 0; i &lt; index; i++)
<a name="l03900"></a>03900                 ptr += object_update_size(ptr);
<a name="l03901"></a>03901 
<a name="l03902"></a>03902         <span class="keywordflow">if</span> (size != NULL)
<a name="l03903"></a>03903                 *size = object_update_size(ptr);
<a name="l03904"></a>03904 
<a name="l03905"></a>03905         <span class="keywordflow">return</span> ptr;
<a name="l03906"></a>03906 }
<a name="l03907"></a>03907 
<a name="l03908"></a>03908 
<a name="l03909"></a>03909 <span class="comment">/* the result of object update */</span>
<a name="l03910"></a><a class="code" href="structobject__update__result.html">03910</a> <span class="keyword">struct </span><a class="code" href="structobject__update__result.html">object_update_result</a> {
<a name="l03911"></a>03911         __u32   our_rc;
<a name="l03912"></a>03912         __u16   our_datalen;
<a name="l03913"></a>03913         __u16   our_padding;
<a name="l03914"></a>03914         __u32   our_data[0];
<a name="l03915"></a>03915 };
<a name="l03916"></a>03916 
<a name="l03917"></a>03917 <span class="preprocessor">#define UPDATE_REPLY_MAGIC_V1   0x00BD0001</span>
<a name="l03918"></a>03918 <span class="preprocessor"></span><span class="preprocessor">#define UPDATE_REPLY_MAGIC_V2   0x00BD0002</span>
<a name="l03919"></a>03919 <span class="preprocessor"></span><span class="preprocessor">#define UPDATE_REPLY_MAGIC      UPDATE_REPLY_MAGIC_V2</span>
<a name="l03920"></a>03920 <span class="preprocessor"></span><span class="comment">/* Hold object_update_results being replied from the remote OUT. */</span>
<a name="l03921"></a><a class="code" href="structobject__update__reply.html">03921</a> <span class="keyword">struct </span><a class="code" href="structobject__update__reply.html">object_update_reply</a> {
<a name="l03922"></a>03922         __u32   ourp_magic;
<a name="l03923"></a>03923         __u16   ourp_count;
<a name="l03924"></a>03924         __u16   ourp_padding;
<a name="l03925"></a>03925         __u16   ourp_lens[0];
<a name="l03926"></a>03926 };
<a name="l03927"></a>03927 
<a name="l03928"></a>03928 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structobject__update__result.html">object_update_result</a> *
<a name="l03929"></a>03929 object_update_result_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobject__update__reply.html">object_update_reply</a> *reply,
<a name="l03930"></a>03930                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index, <span class="keywordtype">size_t</span> *size)
<a name="l03931"></a>03931 {
<a name="l03932"></a>03932         __u16 count = reply-&gt;ourp_count;
<a name="l03933"></a>03933         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l03934"></a>03934         <span class="keywordtype">void</span> *ptr;
<a name="l03935"></a>03935 
<a name="l03936"></a>03936         <span class="keywordflow">if</span> (index &gt;= count)
<a name="l03937"></a>03937                 <span class="keywordflow">return</span> NULL;
<a name="l03938"></a>03938 
<a name="l03939"></a>03939         ptr = (<span class="keywordtype">char</span> *)reply +
<a name="l03940"></a>03940               cfs_size_round(offsetof(<span class="keyword">struct</span> <a class="code" href="structobject__update__reply.html">object_update_reply</a>,
<a name="l03941"></a>03941                                       ourp_lens[count]));
<a name="l03942"></a>03942         <span class="keywordflow">for</span> (i = 0; i &lt; index; i++) {
<a name="l03943"></a>03943                 <span class="keywordflow">if</span> (reply-&gt;ourp_lens[i] == 0)
<a name="l03944"></a>03944                         <span class="keywordflow">return</span> NULL;
<a name="l03945"></a>03945 
<a name="l03946"></a>03946                 ptr += cfs_size_round(reply-&gt;ourp_lens[i]);
<a name="l03947"></a>03947         }
<a name="l03948"></a>03948 
<a name="l03949"></a>03949         <span class="keywordflow">if</span> (size != NULL)
<a name="l03950"></a>03950                 *size = reply-&gt;ourp_lens[index];
<a name="l03951"></a>03951 
<a name="l03952"></a>03952         <span class="keywordflow">return</span> ptr;
<a name="l03953"></a>03953 }
<a name="l03954"></a>03954 
<a name="l03955"></a>03955 <span class="comment">/* read update result */</span>
<a name="l03956"></a><a class="code" href="structout__read__reply.html">03956</a> <span class="keyword">struct </span><a class="code" href="structout__read__reply.html">out_read_reply</a> {
<a name="l03957"></a>03957         __u32   orr_size;
<a name="l03958"></a>03958         __u32   orr_padding;
<a name="l03959"></a>03959         __u64   orr_offset;
<a name="l03960"></a>03960         <span class="keywordtype">char</span>    orr_data[0];
<a name="l03961"></a>03961 };
<a name="l03962"></a>03962 
<a name="l03963"></a>03963 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> orr_cpu_to_le(<span class="keyword">struct</span> <a class="code" href="structout__read__reply.html">out_read_reply</a> *orr_dst,
<a name="l03964"></a>03964                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structout__read__reply.html">out_read_reply</a> *orr_src)
<a name="l03965"></a>03965 {
<a name="l03966"></a>03966         orr_dst-&gt;orr_size = cpu_to_le32(orr_src-&gt;orr_size);
<a name="l03967"></a>03967         orr_dst-&gt;orr_padding = cpu_to_le32(orr_src-&gt;orr_padding);
<a name="l03968"></a>03968         orr_dst-&gt;orr_offset = cpu_to_le64(orr_dst-&gt;orr_offset);
<a name="l03969"></a>03969 }
<a name="l03970"></a>03970 
<a name="l03971"></a>03971 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> orr_le_to_cpu(<span class="keyword">struct</span> <a class="code" href="structout__read__reply.html">out_read_reply</a> *orr_dst,
<a name="l03972"></a>03972                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structout__read__reply.html">out_read_reply</a> *orr_src)
<a name="l03973"></a>03973 {
<a name="l03974"></a>03974         orr_dst-&gt;orr_size = le32_to_cpu(orr_src-&gt;orr_size);
<a name="l03975"></a>03975         orr_dst-&gt;orr_padding = le32_to_cpu(orr_src-&gt;orr_padding);
<a name="l03976"></a>03976         orr_dst-&gt;orr_offset = le64_to_cpu(orr_dst-&gt;orr_offset);
<a name="l03977"></a>03977 }
<a name="l03978"></a>03978 
<a name="l03982"></a><a class="code" href="structmdc__swap__layouts.html">03982</a> <span class="keyword">struct </span><a class="code" href="structmdc__swap__layouts.html" title="layout swap request structure fid1 and fid2 are in mdt_body">mdc_swap_layouts</a> {
<a name="l03983"></a>03983         __u64           msl_flags;
<a name="l03984"></a>03984 } <a class="code" href="group__lustreidl.html#ga662a50376fb91b79a9f099cea7dffb26" title="layout swap request structure fid1 and fid2 are in mdt_body">__packed</a>;
<a name="l03985"></a>03985 
<a name="l03986"></a><a class="code" href="structclose__data.html">03986</a> <span class="keyword">struct </span><a class="code" href="structclose__data.html">close_data</a> {
<a name="l03987"></a>03987         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    cd_handle;
<a name="l03988"></a>03988         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           cd_fid;
<a name="l03989"></a>03989         __u64                   cd_data_version;
<a name="l03990"></a>03990         __u64                   cd_reserved[8];
<a name="l03991"></a>03991 };
<a name="l03992"></a>03992 
<a name="l03993"></a>03993 <span class="comment">/* Update llog format */</span>
<a name="l03994"></a><a class="code" href="structupdate__op.html">03994</a> <span class="keyword">struct </span><a class="code" href="structupdate__op.html">update_op</a> {
<a name="l03995"></a>03995         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>   uop_fid;
<a name="l03996"></a>03996         __u16           uop_type;
<a name="l03997"></a>03997         __u16           uop_param_count;
<a name="l03998"></a>03998         __u16           uop_params_off[0];
<a name="l03999"></a>03999 };
<a name="l04000"></a>04000 
<a name="l04001"></a><a class="code" href="structupdate__ops.html">04001</a> <span class="keyword">struct </span><a class="code" href="structupdate__ops.html">update_ops</a> {
<a name="l04002"></a>04002         <span class="keyword">struct </span><a class="code" href="structupdate__op.html">update_op</a>        uops_op[0];
<a name="l04003"></a>04003 };
<a name="l04004"></a>04004 
<a name="l04005"></a><a class="code" href="structupdate__params.html">04005</a> <span class="keyword">struct </span><a class="code" href="structupdate__params.html">update_params</a> {
<a name="l04006"></a>04006         <span class="keyword">struct </span><a class="code" href="structobject__update__param.html">object_update_param</a>      up_params[0];
<a name="l04007"></a>04007 };
<a name="l04008"></a>04008 
<a name="l04009"></a>04009 <span class="keyword">enum</span> update_records_flag {
<a name="l04010"></a>04010         UPDATE_RECORD_CONTINUE = 1 &gt;&gt; 0,
<a name="l04011"></a>04011 };
<a name="l04012"></a>04012 <span class="comment">/*</span>
<a name="l04013"></a>04013 <span class="comment"> * This is the update record format used to store the updates in</span>
<a name="l04014"></a>04014 <span class="comment"> * disk. All updates of the operation will be stored in ur_ops.</span>
<a name="l04015"></a>04015 <span class="comment"> * All of parameters for updates of the operation will be stored</span>
<a name="l04016"></a>04016 <span class="comment"> * in ur_params.</span>
<a name="l04017"></a>04017 <span class="comment"> * To save the space of the record, parameters in ur_ops will only</span>
<a name="l04018"></a>04018 <span class="comment"> * remember their offset in ur_params, so to avoid storing duplicate</span>
<a name="l04019"></a>04019 <span class="comment"> * parameters in ur_params, which can help us save a lot space for</span>
<a name="l04020"></a>04020 <span class="comment"> * operation like creating striped directory.</span>
<a name="l04021"></a>04021 <span class="comment"> */</span>
<a name="l04022"></a><a class="code" href="structupdate__records.html">04022</a> <span class="keyword">struct </span><a class="code" href="structupdate__records.html">update_records</a> {
<a name="l04023"></a>04023         __u64                   ur_master_transno;
<a name="l04024"></a>04024         __u64                   ur_batchid;
<a name="l04025"></a>04025         __u32                   ur_flags;
<a name="l04026"></a>04026         <span class="comment">/* If the operation includes multiple updates, then ur_index</span>
<a name="l04027"></a>04027 <span class="comment">         * means the index of the update inside the whole updates. */</span>
<a name="l04028"></a>04028         __u32                   ur_index;
<a name="l04029"></a>04029         __u32                   ur_update_count;
<a name="l04030"></a>04030         __u32                   ur_param_count;
<a name="l04031"></a>04031         <span class="keyword">struct </span><a class="code" href="structupdate__ops.html">update_ops</a>       ur_ops;
<a name="l04032"></a>04032          <span class="comment">/* Note ur_ops has a variable size, so comment out</span>
<a name="l04033"></a>04033 <span class="comment">          * the following ur_params, in case some use it directly</span>
<a name="l04034"></a>04034 <span class="comment">          * update_records-&gt;ur_params</span>
<a name="l04035"></a>04035 <span class="comment">          *</span>
<a name="l04036"></a>04036 <span class="comment">          * struct update_params        ur_params;</span>
<a name="l04037"></a>04037 <span class="comment">          */</span>
<a name="l04038"></a>04038 };
<a name="l04039"></a>04039 
<a name="l04040"></a><a class="code" href="structllog__update__record.html">04040</a> <span class="keyword">struct </span><a class="code" href="structllog__update__record.html">llog_update_record</a> {
<a name="l04041"></a>04041         <span class="keyword">struct </span><a class="code" href="structllog__rec__hdr.html" title="Log record header - stored in little endian order.">llog_rec_hdr</a>     lur_hdr;
<a name="l04042"></a>04042         <span class="keyword">struct </span><a class="code" href="structupdate__records.html">update_records</a>   lur_update_rec;
<a name="l04043"></a>04043         <span class="comment">/* Note ur_update_rec has a variable size, so comment out</span>
<a name="l04044"></a>04044 <span class="comment">        * the following ur_tail, in case someone use it directly</span>
<a name="l04045"></a>04045 <span class="comment">        *</span>
<a name="l04046"></a>04046 <span class="comment">        * struct llog_rec_tail lur_tail;</span>
<a name="l04047"></a>04047 <span class="comment">        */</span>
<a name="l04048"></a>04048 };
<a name="l04049"></a>04049 
<a name="l04050"></a>04050 <span class="comment">/* nodemap records, uses 32 byte record length */</span>
<a name="l04051"></a>04051 <span class="preprocessor">#define LUSTRE_NODEMAP_NAME_LENGTH 16</span>
<a name="l04052"></a><a class="code" href="structnodemap__cluster__rec.html">04052</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structnodemap__cluster__rec.html">nodemap_cluster_rec</a> {
<a name="l04053"></a>04053         <span class="keywordtype">char</span>    ncr_name[LUSTRE_NODEMAP_NAME_LENGTH + 1];
<a name="l04054"></a>04054         __u8    ncr_flags;
<a name="l04055"></a>04055         __u16   ncr_padding1;
<a name="l04056"></a>04056         __u32   ncr_padding2;
<a name="l04057"></a>04057         __u32   ncr_squash_uid;
<a name="l04058"></a>04058         __u32   ncr_squash_gid;
<a name="l04059"></a>04059 };
<a name="l04060"></a>04060 
<a name="l04061"></a>04061 <span class="comment">/* lnet_nid_t is 8 bytes */</span>
<a name="l04062"></a><a class="code" href="structnodemap__range__rec.html">04062</a> <span class="keyword">struct </span><a class="code" href="structnodemap__range__rec.html">nodemap_range_rec</a> {
<a name="l04063"></a>04063         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>      nrr_start_nid;
<a name="l04064"></a>04064         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>      nrr_end_nid;
<a name="l04065"></a>04065         __u64           nrr_padding1;
<a name="l04066"></a>04066         __u64           nrr_padding2;
<a name="l04067"></a>04067 };
<a name="l04068"></a>04068 
<a name="l04069"></a><a class="code" href="structnodemap__id__rec.html">04069</a> <span class="keyword">struct </span><a class="code" href="structnodemap__id__rec.html">nodemap_id_rec</a> {
<a name="l04070"></a>04070         __u32   nir_id_fs;
<a name="l04071"></a>04071         __u32   nir_padding1;
<a name="l04072"></a>04072         __u64   nir_padding2;
<a name="l04073"></a>04073         __u64   nir_padding3;
<a name="l04074"></a>04074         __u64   nir_padding4;
<a name="l04075"></a>04075 };
<a name="l04076"></a>04076 
<a name="l04077"></a><a class="code" href="structnodemap__global__rec.html">04077</a> <span class="keyword">struct </span><a class="code" href="structnodemap__global__rec.html">nodemap_global_rec</a> {
<a name="l04078"></a>04078         __u8    ngr_is_active;
<a name="l04079"></a>04079         __u8    ngr_padding1;
<a name="l04080"></a>04080         __u16   ngr_padding2;
<a name="l04081"></a>04081         __u32   ngr_padding3;
<a name="l04082"></a>04082         __u64   ngr_padding4;
<a name="l04083"></a>04083         __u64   ngr_padding5;
<a name="l04084"></a>04084         __u64   ngr_padding6;
<a name="l04085"></a>04085 };
<a name="l04086"></a>04086 
<a name="l04087"></a><a class="code" href="unionnodemap__rec.html">04087</a> <span class="keyword">union </span><a class="code" href="unionnodemap__rec.html">nodemap_rec</a> {
<a name="l04088"></a>04088         <span class="keyword">struct </span><a class="code" href="structnodemap__cluster__rec.html">nodemap_cluster_rec</a> ncr;
<a name="l04089"></a>04089         <span class="keyword">struct </span><a class="code" href="structnodemap__range__rec.html">nodemap_range_rec</a> nrr;
<a name="l04090"></a>04090         <span class="keyword">struct </span><a class="code" href="structnodemap__id__rec.html">nodemap_id_rec</a> nir;
<a name="l04091"></a>04091         <span class="keyword">struct </span><a class="code" href="structnodemap__global__rec.html">nodemap_global_rec</a> ngr;
<a name="l04092"></a>04092 };
<a name="l04093"></a>04093 
<a name="l04094"></a>04094 <span class="preprocessor">#endif</span>
<a name="l04095"></a>04095 <span class="preprocessor"></span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:13 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
