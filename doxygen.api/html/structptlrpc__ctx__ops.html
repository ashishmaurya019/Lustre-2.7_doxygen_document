<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: ptlrpc_ctx_ops Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ptlrpc_ctx_ops Struct Reference<br/>
<small>
[<a class="el" href="group__sptlrpc.html">sptlrpc</a>]</small>
</h1><!-- doxytag: class="ptlrpc_ctx_ops" --><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01fd4f091d29feea575abfe2253cebc9"></a><!-- doxytag: member="ptlrpc_ctx_ops::match" ref="a01fd4f091d29feea575abfe2253cebc9" args=")(struct ptlrpc_cli_ctx *ctx, struct vfs_cred *vcred)" -->
int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#a01fd4f091d29feea575abfe2253cebc9">match</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structvfs__cred.html">vfs_cred</a> *vcred)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To determine whether it's suitable to use the <em>ctx</em> for <em>vcred</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2d600893d9bf038f602916ca9419eb8"></a><!-- doxytag: member="ptlrpc_ctx_ops::refresh" ref="ad2d600893d9bf038f602916ca9419eb8" args=")(struct ptlrpc_cli_ctx *ctx)" -->
int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#ad2d600893d9bf038f602916ca9419eb8">refresh</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To bring the <em>ctx</em> uptodate. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb5726f0e6c01064d509932276136255"></a><!-- doxytag: member="ptlrpc_ctx_ops::validate" ref="aeb5726f0e6c01064d509932276136255" args=")(struct ptlrpc_cli_ctx *ctx)" -->
int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255">validate</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Validate the <em>ctx</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87347673c61d50fb34d358829bcff5ae"></a><!-- doxytag: member="ptlrpc_ctx_ops::die" ref="a87347673c61d50fb34d358829bcff5ae" args=")(struct ptlrpc_cli_ctx *ctx, int grace)" -->
void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#a87347673c61d50fb34d358829bcff5ae">die</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, int grace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force the <em>ctx</em> to die. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d9c404d51041475c25f3ca166342dcb"></a><!-- doxytag: member="ptlrpc_ctx_ops::display" ref="a6d9c404d51041475c25f3ca166342dcb" args=")(struct ptlrpc_cli_ctx *ctx, char *buf, int bufsize)" -->
int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>display</b> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, char *buf, int bufsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#a56a7044b0eb1b542f387d61fb0f2c2c9">sign</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sign the request message using <em>ctx</em>.  <a href="#a56a7044b0eb1b542f387d61fb0f2c2c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#af81c94560ecbdcb48151bd89767d9f75">verify</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verify the reply message using <em>ctx</em>.  <a href="#af81c94560ecbdcb48151bd89767d9f75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#a21b8b702790d8794111c70b0d81529dc">seal</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encrypt the request message using <em>ctx</em>.  <a href="#a21b8b702790d8794111c70b0d81529dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#adfd6f5c19365d9e9d49f6e52ca55be61">unseal</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrypt the reply message using <em>ctx</em>.  <a href="#adfd6f5c19365d9e9d49f6e52ca55be61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#a1440abe65b4eac150d2f52c160582631">wrap_bulk</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrap bulk request data.  <a href="#a1440abe65b4eac150d2f52c160582631"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e">unwrap_bulk</a> )(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unwrap bulk reply data.  <a href="#a3e676304ef422332412950003073eb4e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>

<p>Definition at line <a class="el" href="lustre__sec_8h_source.html#l00396">396</a> of file <a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a21b8b702790d8794111c70b0d81529dc"></a><!-- doxytag: member="ptlrpc_ctx_ops::seal" ref="a21b8b702790d8794111c70b0d81529dc" args=")(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__ctx__ops.html#a21b8b702790d8794111c70b0d81529dc">ptlrpc_ctx_ops::seal</a>)(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encrypt the request message using <em>ctx</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_reqmsg point to request message in clear text. </dd>
<dd>
req-&gt;rq_reqlen is the request message length. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>req-&gt;rq_reqbuf point to request message. </dd>
<dd>
req-&gt;rq_reqdata_len is set to the final request message size.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>gss_cli_ctx_seal(). </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l00978">sptlrpc_cli_wrap_request()</a>.</p>

</div>
</div>
<a class="anchor" id="a56a7044b0eb1b542f387d61fb0f2c2c9"></a><!-- doxytag: member="ptlrpc_ctx_ops::sign" ref="a56a7044b0eb1b542f387d61fb0f2c2c9" args=")(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__ctx__ops.html#a56a7044b0eb1b542f387d61fb0f2c2c9">ptlrpc_ctx_ops::sign</a>)(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sign the request message using <em>ctx</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_reqmsg point to request message. </dd>
<dd>
req-&gt;rq_reqlen is the request message length. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>req-&gt;rq_reqbuf point to request message with signature. </dd>
<dd>
req-&gt;rq_reqdata_len is set to the final request message size.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>null_ctx_sign(), plain_ctx_sign(), gss_cli_ctx_sign(). </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l00978">sptlrpc_cli_wrap_request()</a>.</p>

</div>
</div>
<a class="anchor" id="adfd6f5c19365d9e9d49f6e52ca55be61"></a><!-- doxytag: member="ptlrpc_ctx_ops::unseal" ref="adfd6f5c19365d9e9d49f6e52ca55be61" args=")(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__ctx__ops.html#adfd6f5c19365d9e9d49f6e52ca55be61">ptlrpc_ctx_ops::unseal</a>)(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrypt the reply message using <em>ctx</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_repdata point to encrypted reply message. </dd>
<dd>
req-&gt;rq_repdata_len is the total cipher text length. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>req-&gt;rq_repmsg point to reply message in clear text. </dd>
<dd>
req-&gt;rq_replen is the reply message length in clear text.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>gss_cli_ctx_unseal(). </dd></dl>

</div>
</div>
<a class="anchor" id="a3e676304ef422332412950003073eb4e"></a><!-- doxytag: member="ptlrpc_ctx_ops::unwrap_bulk" ref="a3e676304ef422332412950003073eb4e" args=")(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req, struct ptlrpc_bulk_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e">ptlrpc_ctx_ops::unwrap_bulk</a>)(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwrap bulk reply data. </p>
<p>This is called after wrapping RPC reply message.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>bulk buffer is descripted by desc-&gt;bd_iov/desc-&gt;bd_enc_iov and desc-&gt;bd_iov_count, according to <a class="el" href="structptlrpc__ctx__ops.html#a1440abe65b4eac150d2f52c160582631" title="Wrap bulk request data.">wrap_bulk()</a>. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>final bulk data in clear text is placed in buffer described by desc-&gt;bd_iov and desc-&gt;bd_iov_count. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>+ve nob of actual bulk data in clear text. </dd>
<dd>
-ve error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>plain_cli_unwrap_bulk(), gss_cli_ctx_unwrap_bulk(). </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l02286">sptlrpc_cli_unwrap_bulk_read()</a>, and <a class="el" href="sec_8c_source.html#l02312">sptlrpc_cli_unwrap_bulk_write()</a>.</p>

</div>
</div>
<a class="anchor" id="af81c94560ecbdcb48151bd89767d9f75"></a><!-- doxytag: member="ptlrpc_ctx_ops::verify" ref="af81c94560ecbdcb48151bd89767d9f75" args=")(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__ctx__ops.html#af81c94560ecbdcb48151bd89767d9f75">ptlrpc_ctx_ops::verify</a>)(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verify the reply message using <em>ctx</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>req-&gt;rq_repdata point to reply message with signature. </dd>
<dd>
req-&gt;rq_repdata_len is the total reply message length. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>req-&gt;rq_repmsg point to reply message without signature. </dd>
<dd>
req-&gt;rq_replen is the reply message length.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>null_ctx_verify(), plain_ctx_verify(), gss_cli_ctx_verify(). </dd></dl>

</div>
</div>
<a class="anchor" id="a1440abe65b4eac150d2f52c160582631"></a><!-- doxytag: member="ptlrpc_ctx_ops::wrap_bulk" ref="a1440abe65b4eac150d2f52c160582631" args=")(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req, struct ptlrpc_bulk_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__ctx__ops.html#a1440abe65b4eac150d2f52c160582631">ptlrpc_ctx_ops::wrap_bulk</a>)(struct <a class="el" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrap bulk request data. </p>
<p>This is called before wrapping RPC request message.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>bulk buffer is descripted by desc-&gt;bd_iov and desc-&gt;bd_iov_count. note for read it's just buffer, no data need to be sent; for write it contains data in clear text. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>when necessary, <a class="el" href="structptlrpc__bulk__sec__desc.html">ptlrpc_bulk_sec_desc</a> was properly prepared (usually inside of RPC request message).<ul>
<li>encryption: cipher text bulk buffer is descripted by desc-&gt;bd_enc_iov and desc-&gt;bd_iov_count (currently assume iov count remains the same).</li>
<li>otherwise: bulk buffer is still desc-&gt;bd_iov and desc-&gt;bd_iov_count.</li>
</ul>
</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0: success. </dd>
<dd>
-ev: error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>plain_cli_wrap_bulk(), gss_cli_ctx_wrap_bulk(). </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l02265">sptlrpc_cli_wrap_bulk()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 21:06:37 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
