<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: Network Request Scheduler</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Network Request Scheduler<br/>
<small>
[<a class="el" href="group__net.html">net</a>]</small>
</h1>
<p>Service compatibility function; the policy is compatible with all services.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Network Request Scheduler:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__nrs.png" border="0" alt="" usemap="#group____nrs_map"/>
<map name="group____nrs_map" id="group____nrs">
<area shape="rect" id="node1" href="group__net.html" title="net" alt="" coords="7,5,52,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html">ptlrpc_nrs_pol_ops</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NRS policy operations.  <a href="structptlrpc__nrs__pol__ops.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NRS head.  <a href="structptlrpc__nrs.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NRS policy registering descriptor.  <a href="structptlrpc__nrs__pol__desc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__info.html">ptlrpc_nrs_pol_info</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NRS policy information.  <a href="structptlrpc__nrs__pol__info.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NRS policy.  <a href="structptlrpc__nrs__policy.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NRS resource.  <a href="structptlrpc__nrs__resource.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NRS request.  <a href="structptlrpc__nrs__request.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b62bacadc4bb1dd50a3ec89faf25e48"></a><!-- doxytag: member="nrs::NRS_POL_NAME_MAX" ref="ga6b62bacadc4bb1dd50a3ec89faf25e48" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>NRS_POL_NAME_MAX</b>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga352850be609f28c94c8969d5ff9f1fe8"></a><!-- doxytag: member="nrs::NRS_POL_ARG_MAX" ref="ga352850be609f28c94c8969d5ff9f1fe8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>NRS_POL_ARG_MAX</b>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#ga105d7800dea02f8936595c3bb231d065">nrs_pol_desc_compat_t</a> )(const struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc, const struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Service compatibility predicate; this determines whether a policy is adequate for handling RPCs of a particular PTLRPC service.  <a href="#ga105d7800dea02f8936595c3bb231d065"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a> { <a class="el" href="group__nrs.html#ggaa3db631148675f8074864fa452691540a321baf9361db3da24cdfa83280bad032">PTLRPC_NRS_CTL_INVALID</a>, 
<a class="el" href="group__nrs.html#ggaa3db631148675f8074864fa452691540acd5d2cd7790ab425869163314eae0e70">PTLRPC_NRS_CTL_START</a>, 
<a class="el" href="group__nrs.html#ggaa3db631148675f8074864fa452691540a23993a7a787dd0c72c216e7a4b7531e5">PTLRPC_NRS_CTL_STOP</a>, 
<a class="el" href="group__nrs.html#ggaa3db631148675f8074864fa452691540a543ec0e517ec44e1af95c5137d28f80b">PTLRPC_NRS_CTL_1ST_POL_SPEC</a> =  0x20
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>NRS control operations. </p>
 <a href="group__nrs.html#gaa3db631148675f8074864fa452691540">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#ga6ea16220314a76d72e40776a753ad5e8">nrs_policy_flags</a> { <a class="el" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8ad327b4b9e26d26b5620cfdb682ca0b4c">PTLRPC_NRS_FL_FALLBACK</a> =  (1 &lt;&lt; 0), 
<a class="el" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8a274b96449b8debe8a3aadf811d78b8aa">PTLRPC_NRS_FL_REG_START</a> =  (1 &lt;&lt; 1), 
<a class="el" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8a35947833fd282bc0e5a01eb24fc3791a">PTLRPC_NRS_FL_REG_EXTERN</a> =  (1 &lt;&lt; 2)
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Policy flags. </p>
 <a href="group__nrs.html#ga6ea16220314a76d72e40776a753ad5e8">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#ga79e63c48a144326744316f397c52a883">ptlrpc_nrs_queue_type</a> { <b>PTLRPC_NRS_QUEUE_REG</b> =  (1 &lt;&lt; 0), 
<b>PTLRPC_NRS_QUEUE_HP</b> =  (1 &lt;&lt; 1), 
<b>PTLRPC_NRS_QUEUE_BOTH</b> =  (PTLRPC_NRS_QUEUE_REG | PTLRPC_NRS_QUEUE_HP)
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>NRS queue type. </p>
 <a href="group__nrs.html#ga79e63c48a144326744316f397c52a883">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#ga843285b91fa9672fdf0fcc93b4387971">ptlrpc_nrs_pol_state</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a2ef3aa72b5e4987d1c4e789c31dffdba">NRS_POL_STATE_INVALID</a>, 
<a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a60ca6b44260cb20198b1d5d4747a6257">NRS_POL_STATE_STOPPED</a>, 
<a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a3e737ea7aa14781899e40eb0343c9a39">NRS_POL_STATE_STOPPING</a>, 
<a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a6198482c4c72e590f9009efb54f424ec">NRS_POL_STATE_STARTING</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a8da4904dfb7ba56810332673912a76cb">NRS_POL_STATE_STARTED</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>NRS policy state. </p>
 <a href="group__nrs.html#ga843285b91fa9672fdf0fcc93b4387971">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>NRS_RES_FALLBACK</b>, 
<b>NRS_RES_PRIMARY</b>, 
<b>NRS_RES_MAX</b>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#ga5de7e78460dcd401c48a46cf67ac9851">ptlrpc_nrs_policy_register</a> (struct <a class="el" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a new policy with NRS core.  <a href="#ga5de7e78460dcd401c48a46cf67ac9851"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#gafa9c71a2f34f3e56750abaeba0d358f8">ptlrpc_nrs_policy_unregister</a> (struct <a class="el" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters a previously registered policy with NRS core.  <a href="#gafa9c71a2f34f3e56750abaeba0d358f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#gae517dc74ee0bcadf3b53f6ed4c57e6de">ptlrpc_nrs_req_hp_move</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves request <em>req</em> from the regular to the high-priority NRS head.  <a href="#gae517dc74ee0bcadf3b53f6ed4c57e6de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2834dc010aa5a515daaa07672450184"></a><!-- doxytag: member="nrs::nrs_policy_get_info_locked" ref="gaa2834dc010aa5a515daaa07672450184" args="(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_pol_info *info)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>nrs_policy_get_info_locked</b> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__pol__info.html">ptlrpc_nrs_pol_info</a> *info)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga87c0b624fd16e1aaaac107f6d71e0fd1"></a><!-- doxytag: member="nrs::sr_nrq" ref="ga87c0b624fd16e1aaaac107f6d71e0fd1" args="" -->
struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#ga87c0b624fd16e1aaaac107f6d71e0fd1">ptlrpc_srv_req::sr_nrq</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">stub for NRS request <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Service compatibility function; the policy is compatible with all services. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svc</em>&nbsp;</td><td>The service the policy is attempting to register with. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The policy descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The policy is compatible with the service</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structptlrpc__nrs__pol__desc.html#a7c57c75713e6367abb8433ab580d1db4" title="Service compatibility predicate.">ptlrpc_nrs_pol_desc::pd_compat()</a> </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga105d7800dea02f8936595c3bb231d065"></a><!-- doxytag: member="lustre_nrs.h::nrs_pol_desc_compat_t" ref="ga105d7800dea02f8936595c3bb231d065" args=")(const struct ptlrpc_service *svc, const struct ptlrpc_nrs_pol_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="group__nrs.html#ga105d7800dea02f8936595c3bb231d065">nrs_pol_desc_compat_t</a>)(const struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc, const struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a> *desc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Service compatibility predicate; this determines whether a policy is adequate for handling RPCs of a particular PTLRPC service. </p>
<p>XXX:This should give the same result during policy registration and unregistration, and for all partitions of a service; so the result should not depend on temporal service or other properties, that may influence the result. </p>

<p>Definition at line <a class="el" href="lustre__nrs_8h_source.html#l00396">396</a> of file <a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga6ea16220314a76d72e40776a753ad5e8"></a><!-- doxytag: member="lustre_nrs.h::nrs_policy_flags" ref="ga6ea16220314a76d72e40776a753ad5e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrs.html#ga6ea16220314a76d72e40776a753ad5e8">nrs_policy_flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Policy flags. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga6ea16220314a76d72e40776a753ad5e8ad327b4b9e26d26b5620cfdb682ca0b4c"></a><!-- doxytag: member="PTLRPC_NRS_FL_FALLBACK" ref="gga6ea16220314a76d72e40776a753ad5e8ad327b4b9e26d26b5620cfdb682ca0b4c" args="" -->PTLRPC_NRS_FL_FALLBACK</em>&nbsp;</td><td>
<p>Fallback policy, use this flag only on a single supported policy per service. </p>
<p>The flag cannot be used on policies that use <em>PTLRPC_NRS_FL_REG_EXTERN</em> </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ea16220314a76d72e40776a753ad5e8a274b96449b8debe8a3aadf811d78b8aa"></a><!-- doxytag: member="PTLRPC_NRS_FL_REG_START" ref="gga6ea16220314a76d72e40776a753ad5e8a274b96449b8debe8a3aadf811d78b8aa" args="" -->PTLRPC_NRS_FL_REG_START</em>&nbsp;</td><td>
<p>Start policy immediately after registering. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga6ea16220314a76d72e40776a753ad5e8a35947833fd282bc0e5a01eb24fc3791a"></a><!-- doxytag: member="PTLRPC_NRS_FL_REG_EXTERN" ref="gga6ea16220314a76d72e40776a753ad5e8a35947833fd282bc0e5a01eb24fc3791a" args="" -->PTLRPC_NRS_FL_REG_EXTERN</em>&nbsp;</td><td>
<p>This is a policy registering from a module different to the one NRS core ships in (currently ptlrpc). </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lustre__nrs_8h_source.html#l00266">266</a> of file <a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00266"></a>00266                       {
<a name="l00272"></a>00272         <a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8ad327b4b9e26d26b5620cfdb682ca0b4c" title="Fallback policy, use this flag only on a single supported policy per service.">PTLRPC_NRS_FL_FALLBACK</a>          = (1 &lt;&lt; 0),
<a name="l00276"></a>00276         <a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8a274b96449b8debe8a3aadf811d78b8aa" title="Start policy immediately after registering.">PTLRPC_NRS_FL_REG_START</a>         = (1 &lt;&lt; 1),
<a name="l00281"></a>00281         <a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8a35947833fd282bc0e5a01eb24fc3791a" title="This is a policy registering from a module different to the one NRS core ships in...">PTLRPC_NRS_FL_REG_EXTERN</a>        = (1 &lt;&lt; 2),
<a name="l00282"></a>00282 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa3db631148675f8074864fa452691540"></a><!-- doxytag: member="lustre_nrs.h::ptlrpc_nrs_ctl" ref="gaa3db631148675f8074864fa452691540" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NRS control operations. </p>
<p>These are common for all policies. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaa3db631148675f8074864fa452691540a321baf9361db3da24cdfa83280bad032"></a><!-- doxytag: member="PTLRPC_NRS_CTL_INVALID" ref="ggaa3db631148675f8074864fa452691540a321baf9361db3da24cdfa83280bad032" args="" -->PTLRPC_NRS_CTL_INVALID</em>&nbsp;</td><td>
<p>Not a valid opcode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa3db631148675f8074864fa452691540acd5d2cd7790ab425869163314eae0e70"></a><!-- doxytag: member="PTLRPC_NRS_CTL_START" ref="ggaa3db631148675f8074864fa452691540acd5d2cd7790ab425869163314eae0e70" args="" -->PTLRPC_NRS_CTL_START</em>&nbsp;</td><td>
<p>Activate the policy. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa3db631148675f8074864fa452691540a23993a7a787dd0c72c216e7a4b7531e5"></a><!-- doxytag: member="PTLRPC_NRS_CTL_STOP" ref="ggaa3db631148675f8074864fa452691540a23993a7a787dd0c72c216e7a4b7531e5" args="" -->PTLRPC_NRS_CTL_STOP</em>&nbsp;</td><td>
<p>Reserved for multiple primary policies, which may be a possibility in the future. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa3db631148675f8074864fa452691540a543ec0e517ec44e1af95c5137d28f80b"></a><!-- doxytag: member="PTLRPC_NRS_CTL_1ST_POL_SPEC" ref="ggaa3db631148675f8074864fa452691540a543ec0e517ec44e1af95c5137d28f80b" args="" -->PTLRPC_NRS_CTL_1ST_POL_SPEC</em>&nbsp;</td><td>
<p>Policies can start using opcodes from this value and onwards for their own purposes; the assigned value itself is arbitrary. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lustre__nrs_8h_source.html#l00048">48</a> of file <a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00048"></a>00048                     {
<a name="l00052"></a>00052         <a class="code" href="group__nrs.html#ggaa3db631148675f8074864fa452691540a321baf9361db3da24cdfa83280bad032" title="Not a valid opcode.">PTLRPC_NRS_CTL_INVALID</a>,
<a name="l00056"></a>00056         <a class="code" href="group__nrs.html#ggaa3db631148675f8074864fa452691540acd5d2cd7790ab425869163314eae0e70" title="Activate the policy.">PTLRPC_NRS_CTL_START</a>,
<a name="l00061"></a>00061         <a class="code" href="group__nrs.html#ggaa3db631148675f8074864fa452691540a23993a7a787dd0c72c216e7a4b7531e5" title="Reserved for multiple primary policies, which may be a possibility in the future...">PTLRPC_NRS_CTL_STOP</a>,
<a name="l00066"></a>00066         <a class="code" href="group__nrs.html#ggaa3db631148675f8074864fa452691540a543ec0e517ec44e1af95c5137d28f80b" title="Policies can start using opcodes from this value and onwards for their own purposes;...">PTLRPC_NRS_CTL_1ST_POL_SPEC</a> = 0x20,
<a name="l00067"></a>00067 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga843285b91fa9672fdf0fcc93b4387971"></a><!-- doxytag: member="lustre_nrs.h::ptlrpc_nrs_pol_state" ref="ga843285b91fa9672fdf0fcc93b4387971" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrs.html#ga843285b91fa9672fdf0fcc93b4387971">ptlrpc_nrs_pol_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NRS policy state. </p>
<p>Policies transition from one state to the other during their lifetime </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga843285b91fa9672fdf0fcc93b4387971a2ef3aa72b5e4987d1c4e789c31dffdba"></a><!-- doxytag: member="NRS_POL_STATE_INVALID" ref="gga843285b91fa9672fdf0fcc93b4387971a2ef3aa72b5e4987d1c4e789c31dffdba" args="" -->NRS_POL_STATE_INVALID</em>&nbsp;</td><td>
<p>Not a valid policy state. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga843285b91fa9672fdf0fcc93b4387971a60ca6b44260cb20198b1d5d4747a6257"></a><!-- doxytag: member="NRS_POL_STATE_STOPPED" ref="gga843285b91fa9672fdf0fcc93b4387971a60ca6b44260cb20198b1d5d4747a6257" args="" -->NRS_POL_STATE_STOPPED</em>&nbsp;</td><td>
<p>Policies are at this state either at the start of their life, or transition here when the user selects a different policy to act as the primary one. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga843285b91fa9672fdf0fcc93b4387971a3e737ea7aa14781899e40eb0343c9a39"></a><!-- doxytag: member="NRS_POL_STATE_STOPPING" ref="gga843285b91fa9672fdf0fcc93b4387971a3e737ea7aa14781899e40eb0343c9a39" args="" -->NRS_POL_STATE_STOPPING</em>&nbsp;</td><td>
<p>Policy is progress of stopping. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga843285b91fa9672fdf0fcc93b4387971a6198482c4c72e590f9009efb54f424ec"></a><!-- doxytag: member="NRS_POL_STATE_STARTING" ref="gga843285b91fa9672fdf0fcc93b4387971a6198482c4c72e590f9009efb54f424ec" args="" -->NRS_POL_STATE_STARTING</em>&nbsp;</td><td>
<p>Policy is in progress of starting. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga843285b91fa9672fdf0fcc93b4387971a8da4904dfb7ba56810332673912a76cb"></a><!-- doxytag: member="NRS_POL_STATE_STARTED" ref="gga843285b91fa9672fdf0fcc93b4387971a8da4904dfb7ba56810332673912a76cb" args="" -->NRS_POL_STATE_STARTED</em>&nbsp;</td><td>
<p>A policy is in this state in two cases:</p>
<ul>
<li>it is the fallback policy, which is always in this state. </li>
</ul>
<ul>
<li>it has been activated by the user; i.e. it is the primary policy, </li>
</ul>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lustre__nrs_8h_source.html#l00515">515</a> of file <a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00515"></a>00515                           {
<a name="l00519"></a>00519         <a class="code" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a2ef3aa72b5e4987d1c4e789c31dffdba" title="Not a valid policy state.">NRS_POL_STATE_INVALID</a>,
<a name="l00525"></a>00525         <a class="code" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a60ca6b44260cb20198b1d5d4747a6257" title="Policies are at this state either at the start of their life, or transition here...">NRS_POL_STATE_STOPPED</a>,
<a name="l00529"></a>00529         <a class="code" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a3e737ea7aa14781899e40eb0343c9a39" title="Policy is progress of stopping.">NRS_POL_STATE_STOPPING</a>,
<a name="l00533"></a>00533         <a class="code" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a6198482c4c72e590f9009efb54f424ec" title="Policy is in progress of starting.">NRS_POL_STATE_STARTING</a>,
<a name="l00539"></a>00539         <a class="code" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a8da4904dfb7ba56810332673912a76cb" title="A policy is in this state in two cases:it is the fallback policy, which is always...">NRS_POL_STATE_STARTED</a>,
<a name="l00540"></a>00540 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga79e63c48a144326744316f397c52a883"></a><!-- doxytag: member="lustre_nrs.h::ptlrpc_nrs_queue_type" ref="ga79e63c48a144326744316f397c52a883" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrs.html#ga79e63c48a144326744316f397c52a883">ptlrpc_nrs_queue_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NRS queue type. </p>
<p>Denotes whether an NRS instance is for handling normal or high-priority RPCs, or whether an operation pertains to one or both of the NRS instances in a service. </p>

<p>Definition at line <a class="el" href="lustre__nrs_8h_source.html#l00291">291</a> of file <a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00291"></a>00291                            {
<a name="l00292"></a>00292         PTLRPC_NRS_QUEUE_REG    = (1 &lt;&lt; 0),
<a name="l00293"></a>00293         PTLRPC_NRS_QUEUE_HP     = (1 &lt;&lt; 1),
<a name="l00294"></a>00294         PTLRPC_NRS_QUEUE_BOTH   = (PTLRPC_NRS_QUEUE_REG | PTLRPC_NRS_QUEUE_HP)
<a name="l00295"></a>00295 };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga5de7e78460dcd401c48a46cf67ac9851"></a><!-- doxytag: member="lustre_net.h::ptlrpc_nrs_policy_register" ref="ga5de7e78460dcd401c48a46cf67ac9851" args="(struct ptlrpc_nrs_pol_conf *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_nrs_policy_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a new policy with NRS core. </p>
<p>The function will only succeed if policy registration with all compatible service partitions (if any) is successful.</p>
<p>N.B. This function should be called either at ptlrpc module initialization time when registering a policy that ships with NRS core, or in a module's init() function for policies registering from other modules.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>conf</em>&nbsp;</td><td>configuration information for the new policy to register</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
  </table>
  </dd>
</dl>

<p><p>External policies are not allowed to start immediately upon registration, as there is a relatively higher chance that their registration might fail. In such a case, some policy instances may already have requests queued wen unregistration needs to happen as part o cleanup; since there is currently no way to drain requests from a policy unless the service is unregistering, we just disallow this.</p>
<p>For policies that are held in the same module as NRS (currently ptlrpc), do not register the policy with all compatible services, as the services will not have started at this point, since we are calling from ptlrpc module initialization code. In such cases each service will register all compatible policies later, via ptlrpc_service_nrs_setup().</p>
<p>Register the new policy on all compatible services</p>
<p>Should not fail at this point</p>
<p>No need to take a reference to other modules here, as we will be calling from the module's init() function.</p>
<p>Should not fail at this point</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01165">1165</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="lustre__nrs_8h_source.html#l00411">ptlrpc_nrs_pol_conf::nc_compat</a>, <a class="el" href="lustre__nrs_8h_source.html#l00418">ptlrpc_nrs_pol_conf::nc_compat_svc_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00428">ptlrpc_nrs_pol_conf::nc_flags</a>, <a class="el" href="lustre__nrs_8h_source.html#l00403">ptlrpc_nrs_pol_conf::nc_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00407">ptlrpc_nrs_pol_conf::nc_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00424">ptlrpc_nrs_pol_conf::nc_owner</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#ad81393abaf1277b8fdebc3f67903c55a">ptlrpc_nrs_pol_ops::op_lprocfs_init</a>, <a class="el" href="lustre__nrs_8h_source.html#l00453">ptlrpc_nrs_pol_desc::pd_compat</a>, <a class="el" href="lustre__nrs_8h_source.html#l00459">ptlrpc_nrs_pol_desc::pd_compat_svc_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00503">ptlrpc_nrs_pol_desc::pd_flags</a>, <a class="el" href="lustre__nrs_8h_source.html#l00445">ptlrpc_nrs_pol_desc::pd_list</a>, <a class="el" href="lustre__nrs_8h_source.html#l00441">ptlrpc_nrs_pol_desc::pd_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00499">ptlrpc_nrs_pol_desc::pd_owner</a>, <a class="el" href="lustre__nrs_8h_source.html#l00507">ptlrpc_nrs_pol_desc::pd_refs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00272">PTLRPC_NRS_FL_FALLBACK</a>, <a class="el" href="lustre__nrs_8h_source.html#l00281">PTLRPC_NRS_FL_REG_EXTERN</a>, <a class="el" href="lustre__nrs_8h_source.html#l00276">PTLRPC_NRS_FL_REG_START</a>, and <a class="el" href="lustre__net_8h_source.html#l01713">ptlrpc_service::srv_is_stopping</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01166"></a>01166 {
<a name="l01167"></a>01167         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>          *svc;
<a name="l01168"></a>01168         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__pol__desc.html" title="NRS policy registering descriptor.">ptlrpc_nrs_pol_desc</a>     *desc;
<a name="l01169"></a>01169         <span class="keywordtype">int</span>                             rc = 0;
<a name="l01170"></a>01170         ENTRY;
<a name="l01171"></a>01171 
<a name="l01172"></a>01172         LASSERT(conf != NULL);
<a name="l01173"></a>01173         LASSERT(conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a136951aaf0b0881f052bba941bd8150b" title="NRS operations for this policy.">nc_ops</a> != NULL);
<a name="l01174"></a>01174         LASSERT(conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a4fa85169be78022f3f010e5b0ddfeec9" title="Service compatibility predicate.">nc_compat</a> != NULL);
<a name="l01175"></a>01175         LASSERT(ergo(conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a4fa85169be78022f3f010e5b0ddfeec9" title="Service compatibility predicate.">nc_compat</a> == nrs_policy_compat_one,
<a name="l01176"></a>01176                 conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a3e2c40464d2a870a742fc9c534f4aea4" title="Set for policies that support a single ptlrpc service, i.e.">nc_compat_svc_name</a> != NULL));
<a name="l01177"></a>01177         LASSERT(ergo((conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a69b1cdbbca3e5ed5089636bf424ca94c" title="Policy registration flags; a bitmast of nrs_policy_flags.">nc_flags</a> &amp; <a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8a35947833fd282bc0e5a01eb24fc3791a" title="This is a policy registering from a module different to the one NRS core ships in...">PTLRPC_NRS_FL_REG_EXTERN</a>) != 0,
<a name="l01178"></a>01178                      conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#ac29223e1e21fbf8c1eeb857b3bb39a87" title="Owner module for this policy descriptor; policies registering from a different module...">nc_owner</a> != NULL));
<a name="l01179"></a>01179 
<a name="l01180"></a>01180         conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>[NRS_POL_NAME_MAX - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01181"></a>01181 
<a name="l01191"></a>01191         <span class="keywordflow">if</span> ((conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a69b1cdbbca3e5ed5089636bf424ca94c" title="Policy registration flags; a bitmast of nrs_policy_flags.">nc_flags</a> &amp; <a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8a35947833fd282bc0e5a01eb24fc3791a" title="This is a policy registering from a module different to the one NRS core ships in...">PTLRPC_NRS_FL_REG_EXTERN</a>) &amp;&amp;
<a name="l01192"></a>01192             (conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a69b1cdbbca3e5ed5089636bf424ca94c" title="Policy registration flags; a bitmast of nrs_policy_flags.">nc_flags</a> &amp; (<a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8ad327b4b9e26d26b5620cfdb682ca0b4c" title="Fallback policy, use this flag only on a single supported policy per service.">PTLRPC_NRS_FL_FALLBACK</a> |
<a name="l01193"></a>01193                                <a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8a274b96449b8debe8a3aadf811d78b8aa" title="Start policy immediately after registering.">PTLRPC_NRS_FL_REG_START</a>))) {
<a name="l01194"></a>01194                 CERROR(<span class="stringliteral">&quot;NRS: failing to register policy %s. Please check &quot;</span>
<a name="l01195"></a>01195                        <span class="stringliteral">&quot;policy flags; external policies cannot act as fallback &quot;</span>
<a name="l01196"></a>01196                        <span class="stringliteral">&quot;policies, or be started immediately upon registration &quot;</span>
<a name="l01197"></a>01197                        <span class="stringliteral">&quot;without interaction with lprocfs\n&quot;</span>, conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>);
<a name="l01198"></a>01198                 RETURN(-EINVAL);
<a name="l01199"></a>01199         }
<a name="l01200"></a>01200 
<a name="l01201"></a>01201         mutex_lock(&amp;<a class="code" href="structnrs__core.html" title="NRS core object.">nrs_core</a>.nrs_mutex);
<a name="l01202"></a>01202 
<a name="l01203"></a>01203         <span class="keywordflow">if</span> (nrs_policy_find_desc_locked(conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>) != NULL) {
<a name="l01204"></a>01204                 CERROR(<span class="stringliteral">&quot;NRS: failing to register policy %s which has already &quot;</span>
<a name="l01205"></a>01205                        <span class="stringliteral">&quot;been registered with NRS core!\n&quot;</span>,
<a name="l01206"></a>01206                        conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>);
<a name="l01207"></a>01207                 GOTO(fail, rc = -EEXIST);
<a name="l01208"></a>01208         }
<a name="l01209"></a>01209 
<a name="l01210"></a>01210         OBD_ALLOC_PTR(desc);
<a name="l01211"></a>01211         <span class="keywordflow">if</span> (desc == NULL)
<a name="l01212"></a>01212                 GOTO(fail, rc = -ENOMEM);
<a name="l01213"></a>01213 
<a name="l01214"></a>01214         <span class="keywordflow">if</span> (strlcpy(desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>, conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>, <span class="keyword">sizeof</span>(desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>)) &gt;=
<a name="l01215"></a>01215             <span class="keyword">sizeof</span>(desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>)) {
<a name="l01216"></a>01216                 OBD_FREE_PTR(desc);
<a name="l01217"></a>01217                 GOTO(fail, rc = -E2BIG);
<a name="l01218"></a>01218         }
<a name="l01219"></a>01219         desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#aba233e96277bf84fded13e672d63322e" title="NRS operations for this policy.">pd_ops</a>             = conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a136951aaf0b0881f052bba941bd8150b" title="NRS operations for this policy.">nc_ops</a>;
<a name="l01220"></a>01220         desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a7c57c75713e6367abb8433ab580d1db4" title="Service compatibility predicate.">pd_compat</a>          = conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a4fa85169be78022f3f010e5b0ddfeec9" title="Service compatibility predicate.">nc_compat</a>;
<a name="l01221"></a>01221         desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#aa6f674582366294297bfed84b1b14581" title="Set for policies that are compatible with only one PTLRPC service.">pd_compat_svc_name</a> = conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a3e2c40464d2a870a742fc9c534f4aea4" title="Set for policies that support a single ptlrpc service, i.e.">nc_compat_svc_name</a>;
<a name="l01222"></a>01222         <span class="keywordflow">if</span> ((conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a69b1cdbbca3e5ed5089636bf424ca94c" title="Policy registration flags; a bitmast of nrs_policy_flags.">nc_flags</a> &amp; <a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8a35947833fd282bc0e5a01eb24fc3791a" title="This is a policy registering from a module different to the one NRS core ships in...">PTLRPC_NRS_FL_REG_EXTERN</a>) != 0)
<a name="l01223"></a>01223                 desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#ae12d56d85fa4f85a79e9ad185ecd2bd1" title="Owner module for this policy descriptor.">pd_owner</a>   = conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#ac29223e1e21fbf8c1eeb857b3bb39a87" title="Owner module for this policy descriptor; policies registering from a different module...">nc_owner</a>;
<a name="l01224"></a>01224         desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#aef6e239311b38cd4cd3bb5265ef9e3a4" title="Bitmask of nrs_policy_flags.">pd_flags</a>           = conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a69b1cdbbca3e5ed5089636bf424ca94c" title="Policy registration flags; a bitmast of nrs_policy_flags.">nc_flags</a>;
<a name="l01225"></a>01225         atomic_set(&amp;desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a74a94ee35dc2e2bf50b4a85e8c0bf291" title="# of references on this descriptor">pd_refs</a>, 0);
<a name="l01226"></a>01226 
<a name="l01235"></a>01235         <span class="keywordflow">if</span> ((conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a69b1cdbbca3e5ed5089636bf424ca94c" title="Policy registration flags; a bitmast of nrs_policy_flags.">nc_flags</a> &amp; <a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8a35947833fd282bc0e5a01eb24fc3791a" title="This is a policy registering from a module different to the one NRS core ships in...">PTLRPC_NRS_FL_REG_EXTERN</a>) == 0)
<a name="l01236"></a>01236                 <span class="keywordflow">goto</span> <span class="keyword">internal</span>;
<a name="l01237"></a>01237 
<a name="l01241"></a>01241         mutex_lock(&amp;ptlrpc_all_services_mutex);
<a name="l01242"></a>01242 
<a name="l01243"></a>01243         list_for_each_entry(svc, &amp;ptlrpc_all_services, srv_list) {
<a name="l01244"></a>01244                 <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>     *svcpt;
<a name="l01245"></a>01245                 <span class="keywordtype">int</span>                             i;
<a name="l01246"></a>01246                 <span class="keywordtype">int</span>                             rc2;
<a name="l01247"></a>01247 
<a name="l01248"></a>01248                 <span class="keywordflow">if</span> (!nrs_policy_compatible(svc, desc) ||
<a name="l01249"></a>01249                     unlikely(svc-&gt;<a class="code" href="structptlrpc__service.html#a356fa84033571129333ab81646a283df" title="under unregister_service">srv_is_stopping</a>))
<a name="l01250"></a>01250                         <span class="keywordflow">continue</span>;
<a name="l01251"></a>01251 
<a name="l01252"></a>01252                 ptlrpc_service_for_each_part(svcpt, i, svc) {
<a name="l01253"></a>01253                         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs.html" title="NRS head.">ptlrpc_nrs</a>      *nrs;
<a name="l01254"></a>01254                         <span class="keywordtype">bool</span>                    hp = <span class="keyword">false</span>;
<a name="l01255"></a>01255 again:
<a name="l01256"></a>01256                         nrs = nrs_svcpt2nrs(svcpt, hp);
<a name="l01257"></a>01257                         rc = nrs_policy_register(nrs, desc);
<a name="l01258"></a>01258                         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01259"></a>01259                                 CERROR(<span class="stringliteral">&quot;Failed to register NRS policy %s for &quot;</span>
<a name="l01260"></a>01260                                        <span class="stringliteral">&quot;partition %d of service %s: %d\n&quot;</span>,
<a name="l01261"></a>01261                                        desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">pd_name</a>, svcpt-&gt;scp_cpt,
<a name="l01262"></a>01262                                        svcpt-&gt;scp_service-&gt;srv_name, rc);
<a name="l01263"></a>01263 
<a name="l01264"></a>01264                                 rc2 = nrs_policy_unregister_locked(desc);
<a name="l01268"></a>01268                                 LASSERT(rc2 == 0);
<a name="l01269"></a>01269                                 mutex_unlock(&amp;ptlrpc_all_services_mutex);
<a name="l01270"></a>01270                                 OBD_FREE_PTR(desc);
<a name="l01271"></a>01271                                 GOTO(fail, rc);
<a name="l01272"></a>01272                         }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274                         <span class="keywordflow">if</span> (!hp &amp;&amp; nrs_svc_has_hp(svc)) {
<a name="l01275"></a>01275                                 hp = <span class="keyword">true</span>;
<a name="l01276"></a>01276                                 <span class="keywordflow">goto</span> again;
<a name="l01277"></a>01277                         }
<a name="l01278"></a>01278                 }
<a name="l01279"></a>01279 
<a name="l01284"></a>01284                 <span class="keywordflow">if</span> (desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#aba233e96277bf84fded13e672d63322e" title="NRS operations for this policy.">pd_ops</a>-&gt;<a class="code" href="structptlrpc__nrs__pol__ops.html#ad81393abaf1277b8fdebc3f67903c55a" title="Registers the policy&amp;#39;s lprocfs interface with a PTLRPC service.">op_lprocfs_init</a> != NULL) {
<a name="l01285"></a>01285                         rc = desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#aba233e96277bf84fded13e672d63322e" title="NRS operations for this policy.">pd_ops</a>-&gt;<a class="code" href="structptlrpc__nrs__pol__ops.html#ad81393abaf1277b8fdebc3f67903c55a" title="Registers the policy&amp;#39;s lprocfs interface with a PTLRPC service.">op_lprocfs_init</a>(svc);
<a name="l01286"></a>01286                         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01287"></a>01287                                 rc2 = nrs_policy_unregister_locked(desc);
<a name="l01291"></a>01291                                 LASSERT(rc2 == 0);
<a name="l01292"></a>01292                                 mutex_unlock(&amp;ptlrpc_all_services_mutex);
<a name="l01293"></a>01293                                 OBD_FREE_PTR(desc);
<a name="l01294"></a>01294                                 GOTO(fail, rc);
<a name="l01295"></a>01295                         }
<a name="l01296"></a>01296                 }
<a name="l01297"></a>01297         }
<a name="l01298"></a>01298 
<a name="l01299"></a>01299         mutex_unlock(&amp;ptlrpc_all_services_mutex);
<a name="l01300"></a>01300 <span class="keyword">internal</span>:
<a name="l01301"></a>01301         list_add_tail(&amp;desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a94e6539f58dfde2244c2c957d624433d" title="Link into nrs_core::nrs_policies.">pd_list</a>, &amp;<a class="code" href="structnrs__core.html" title="NRS core object.">nrs_core</a>.nrs_policies);
<a name="l01302"></a>01302 fail:
<a name="l01303"></a>01303         mutex_unlock(&amp;<a class="code" href="structnrs__core.html" title="NRS core object.">nrs_core</a>.nrs_mutex);
<a name="l01304"></a>01304 
<a name="l01305"></a>01305         RETURN(rc);
<a name="l01306"></a>01306 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gafa9c71a2f34f3e56750abaeba0d358f8"></a><!-- doxytag: member="lustre_net.h::ptlrpc_nrs_policy_unregister" ref="gafa9c71a2f34f3e56750abaeba0d358f8" args="(struct ptlrpc_nrs_pol_conf *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_nrs_policy_unregister </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters a previously registered policy with NRS core. </p>
<p>All instances of the policy on all NRS heads of all supported services are removed.</p>
<p>N.B. This function should only be called from a module's exit() function. Although it can be used for policies that ship alongside NRS core, the function is primarily intended for policies that register externally, from other modules.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>conf</em>&nbsp;</td><td>configuration information for the policy to unregister</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01323">1323</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="lustre__nrs_8h_source.html#l00428">ptlrpc_nrs_pol_conf::nc_flags</a>, <a class="el" href="lustre__nrs_8h_source.html#l00403">ptlrpc_nrs_pol_conf::nc_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00445">ptlrpc_nrs_pol_desc::pd_list</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00272">PTLRPC_NRS_FL_FALLBACK</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01324"></a>01324 {
<a name="l01325"></a>01325         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__pol__desc.html" title="NRS policy registering descriptor.">ptlrpc_nrs_pol_desc</a>      *desc;
<a name="l01326"></a>01326         <span class="keywordtype">int</span>                              rc;
<a name="l01327"></a>01327         ENTRY;
<a name="l01328"></a>01328 
<a name="l01329"></a>01329         LASSERT(conf != NULL);
<a name="l01330"></a>01330 
<a name="l01331"></a>01331         <span class="keywordflow">if</span> (conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#a69b1cdbbca3e5ed5089636bf424ca94c" title="Policy registration flags; a bitmast of nrs_policy_flags.">nc_flags</a> &amp; <a class="code" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8ad327b4b9e26d26b5620cfdb682ca0b4c" title="Fallback policy, use this flag only on a single supported policy per service.">PTLRPC_NRS_FL_FALLBACK</a>) {
<a name="l01332"></a>01332                 CERROR(<span class="stringliteral">&quot;Unable to unregister a fallback policy, unless the &quot;</span>
<a name="l01333"></a>01333                        <span class="stringliteral">&quot;PTLRPC service is stopping.\n&quot;</span>);
<a name="l01334"></a>01334                 RETURN(-EPERM);
<a name="l01335"></a>01335         }
<a name="l01336"></a>01336 
<a name="l01337"></a>01337         conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>[NRS_POL_NAME_MAX - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01338"></a>01338 
<a name="l01339"></a>01339         mutex_lock(&amp;<a class="code" href="structnrs__core.html" title="NRS core object.">nrs_core</a>.nrs_mutex);
<a name="l01340"></a>01340 
<a name="l01341"></a>01341         desc = nrs_policy_find_desc_locked(conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>);
<a name="l01342"></a>01342         <span class="keywordflow">if</span> (desc == NULL) {
<a name="l01343"></a>01343                 CERROR(<span class="stringliteral">&quot;Failing to unregister NRS policy %s which has &quot;</span>
<a name="l01344"></a>01344                        <span class="stringliteral">&quot;not been registered with NRS core!\n&quot;</span>,
<a name="l01345"></a>01345                        conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>);
<a name="l01346"></a>01346                 GOTO(not_exist, rc = -ENOENT);
<a name="l01347"></a>01347         }
<a name="l01348"></a>01348 
<a name="l01349"></a>01349         mutex_lock(&amp;ptlrpc_all_services_mutex);
<a name="l01350"></a>01350 
<a name="l01351"></a>01351         rc = nrs_policy_unregister_locked(desc);
<a name="l01352"></a>01352         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01353"></a>01353                 <span class="keywordflow">if</span> (rc == -EBUSY)
<a name="l01354"></a>01354                         CERROR(<span class="stringliteral">&quot;Please first stop policy %s on all service &quot;</span>
<a name="l01355"></a>01355                                <span class="stringliteral">&quot;partitions and then retry to unregister the &quot;</span>
<a name="l01356"></a>01356                                <span class="stringliteral">&quot;policy.\n&quot;</span>, conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>);
<a name="l01357"></a>01357                 GOTO(fail, rc);
<a name="l01358"></a>01358         }
<a name="l01359"></a>01359 
<a name="l01360"></a>01360         CDEBUG(D_INFO, <span class="stringliteral">&quot;Unregistering policy %s from NRS core.\n&quot;</span>,
<a name="l01361"></a>01361                conf-&gt;<a class="code" href="structptlrpc__nrs__pol__conf.html#adfa0b0c120aa315b1becf8ad47bfa497" title="Human-readable policy name.">nc_name</a>);
<a name="l01362"></a>01362 
<a name="l01363"></a>01363         list_del(&amp;desc-&gt;<a class="code" href="structptlrpc__nrs__pol__desc.html#a94e6539f58dfde2244c2c957d624433d" title="Link into nrs_core::nrs_policies.">pd_list</a>);
<a name="l01364"></a>01364         OBD_FREE_PTR(desc);
<a name="l01365"></a>01365 
<a name="l01366"></a>01366 fail:
<a name="l01367"></a>01367         mutex_unlock(&amp;ptlrpc_all_services_mutex);
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 not_exist:
<a name="l01370"></a>01370         mutex_unlock(&amp;<a class="code" href="structnrs__core.html" title="NRS core object.">nrs_core</a>.nrs_mutex);
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         RETURN(rc);
<a name="l01373"></a>01373 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae517dc74ee0bcadf3b53f6ed4c57e6de"></a><!-- doxytag: member="lustre_net.h::ptlrpc_nrs_req_hp_move" ref="gae517dc74ee0bcadf3b53f6ed4c57e6de" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_nrs_req_hp_move </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves request <em>req</em> from the regular to the high-priority NRS head. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>req</em>&nbsp;</td><td>the request to move </td></tr>
  </table>
  </dd>
</dl>

<p><p>Obtain the high-priority NRS head resources.</p>
<p>Release either the regular NRS head resources if we moved the request, or the high-priority NRS head resources if we took a reference earlier in this function and ptlrpc_nrs_req_can_move() returned false.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01673">1673</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="lustre__nrs_8h_source.html#l00691">ptlrpc_nrs_request::nr_res_ptrs</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01674"></a>01674 {
<a name="l01675"></a>01675         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *svcpt = req-&gt;rq_rqbd-&gt;rqbd_svcpt;
<a name="l01676"></a>01676         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__request.html" title="NRS request.">ptlrpc_nrs_request</a>       *nrq = &amp;req-&gt;rq_nrq;
<a name="l01677"></a>01677         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__resource.html" title="NRS resource.">ptlrpc_nrs_resource</a>      *res1[NRS_RES_MAX];
<a name="l01678"></a>01678         <span class="keyword">struct </span><a class="code" href="structptlrpc__nrs__resource.html" title="NRS resource.">ptlrpc_nrs_resource</a>      *res2[NRS_RES_MAX];
<a name="l01679"></a>01679         ENTRY;
<a name="l01680"></a>01680 
<a name="l01684"></a>01684         nrs_resource_get_safe(nrs_svcpt2nrs(svcpt, <span class="keyword">true</span>), nrq, res1, <span class="keyword">true</span>);
<a name="l01685"></a>01685 
<a name="l01686"></a>01686         spin_lock(&amp;svcpt-&gt;scp_req_lock);
<a name="l01687"></a>01687 
<a name="l01688"></a>01688         <span class="keywordflow">if</span> (!ptlrpc_nrs_req_can_move(req))
<a name="l01689"></a>01689                 <span class="keywordflow">goto</span> out;
<a name="l01690"></a>01690 
<a name="l01691"></a>01691         ptlrpc_nrs_req_del_nolock(req);
<a name="l01692"></a>01692 
<a name="l01693"></a>01693         memcpy(res2, nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#aff495a9624df874a4d9bf643ad1b4d20" title="The request&amp;#39;s resource hierarchy.">nr_res_ptrs</a>, NRS_RES_MAX * <span class="keyword">sizeof</span>(res2[0]));
<a name="l01694"></a>01694         memcpy(nrq-&gt;<a class="code" href="structptlrpc__nrs__request.html#aff495a9624df874a4d9bf643ad1b4d20" title="The request&amp;#39;s resource hierarchy.">nr_res_ptrs</a>, res1, NRS_RES_MAX * <span class="keyword">sizeof</span>(res1[0]));
<a name="l01695"></a>01695 
<a name="l01696"></a>01696         ptlrpc_nrs_hpreq_add_nolock(req);
<a name="l01697"></a>01697 
<a name="l01698"></a>01698         memcpy(res1, res2, NRS_RES_MAX * <span class="keyword">sizeof</span>(res1[0]));
<a name="l01699"></a>01699 out:
<a name="l01700"></a>01700         spin_unlock(&amp;svcpt-&gt;scp_req_lock);
<a name="l01701"></a>01701 
<a name="l01708"></a>01708         nrs_resource_put_safe(res1);
<a name="l01709"></a>01709         EXIT;
<a name="l01710"></a>01710 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:45 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
