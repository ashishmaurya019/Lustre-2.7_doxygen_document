<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lnet/klnds/gnilnd/gnilnd_conn.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lnet/klnds/gnilnd/gnilnd_conn.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (C) 2012 Cray, Inc.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (c) 2014, Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *   Author: Nic Henke &lt;nic@cray.com&gt;</span>
<a name="l00007"></a>00007 <span class="comment"> *   Author: James Shimek &lt;jshimek@cray.com&gt;</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *   This file is part of Lustre, http://www.lustre.org.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> *   Lustre is free software; you can redistribute it and/or</span>
<a name="l00012"></a>00012 <span class="comment"> *   modify it under the terms of version 2 of the GNU General Public</span>
<a name="l00013"></a>00013 <span class="comment"> *   License as published by the Free Software Foundation.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> *   Lustre is distributed in the hope that it will be useful,</span>
<a name="l00016"></a>00016 <span class="comment"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00017"></a>00017 <span class="comment"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00018"></a>00018 <span class="comment"> *   GNU General Public License for more details.</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> *   You should have received a copy of the GNU General Public License</span>
<a name="l00021"></a>00021 <span class="comment"> *   along with Lustre; if not, write to the Free Software</span>
<a name="l00022"></a>00022 <span class="comment"> *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> */</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;gnilnd.h&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="keywordtype">void</span>
<a name="l00029"></a>00029 kgnilnd_setup_smsg_attr(<a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a> *smsg_attr)
<a name="l00030"></a>00030 {
<a name="l00031"></a>00031         smsg_attr-&gt;mbox_maxcredit = *kgnilnd_tunables.kgn_mbox_credits;
<a name="l00032"></a>00032         smsg_attr-&gt;msg_maxsize = GNILND_MAX_MSG_SIZE;
<a name="l00033"></a>00033         smsg_attr-&gt;msg_type = GNI_SMSG_TYPE_MBOX_AUTO_RETRANSMIT;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keywordtype">int</span>
<a name="l00037"></a>00037 kgnilnd_map_fmablk(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device, <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a> *fma_blk)
<a name="l00038"></a>00038 {
<a name="l00039"></a>00039         gni_return_t            rrc;
<a name="l00040"></a>00040         __u32                   flags = GNI_MEM_READWRITE;
<a name="l00041"></a>00041         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>    reg_to;
<a name="l00042"></a>00042         <span class="keywordtype">int</span>                     rfto = *kgnilnd_tunables.kgn_reg_fail_timeout;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_state == GNILND_FMABLK_PHYS) {
<a name="l00045"></a>00045                 flags |= GNI_MEM_PHYS_CONT;
<a name="l00046"></a>00046         }
<a name="l00047"></a>00047 
<a name="l00048"></a>00048         fma_blk-&gt;gnm_hold_timeout = 0;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050         <span class="comment">/* make sure we are mapping a clean block */</span>
<a name="l00051"></a>00051         LASSERTF(fma_blk-&gt;gnm_hndl.qword1 == 0UL, <span class="stringliteral">&quot;fma_blk %p dirty\n&quot;</span>, fma_blk);
<a name="l00052"></a>00052 
<a name="l00053"></a>00053         rrc = kgnilnd_mem_register(device-&gt;gnd_handle, (__u64)fma_blk-&gt;gnm_block,
<a name="l00054"></a>00054                                    fma_blk-&gt;gnm_blk_size, device-&gt;gnd_rcv_fma_cqh,
<a name="l00055"></a>00055                                    flags, &amp;fma_blk-&gt;gnm_hndl);
<a name="l00056"></a>00056         <span class="keywordflow">if</span> (rrc != GNI_RC_SUCCESS) {
<a name="l00057"></a>00057                 <span class="keywordflow">if</span> (rfto != GNILND_REGFAILTO_DISABLE) {
<a name="l00058"></a>00058                         <span class="keywordflow">if</span> (reg_to == 0) {
<a name="l00059"></a>00059                                 reg_to = jiffies + cfs_time_seconds(rfto);
<a name="l00060"></a>00060                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (time_after(jiffies, reg_to)) {
<a name="l00061"></a>00061                                 CERROR(<span class="stringliteral">&quot;FATAL:fmablk registration has failed &quot;</span>
<a name="l00062"></a>00062                                        <span class="stringliteral">&quot;for %ld seconds.\n&quot;</span>,
<a name="l00063"></a>00063                                        cfs_duration_sec(jiffies - reg_to) +
<a name="l00064"></a>00064                                                 rfto);
<a name="l00065"></a>00065                                 LBUG();
<a name="l00066"></a>00066                         }
<a name="l00067"></a>00067                 }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069                 CNETERR(<span class="stringliteral">&quot;register fmablk failed 0x%p mbox_size %d flags %u\n&quot;</span>,
<a name="l00070"></a>00070                         fma_blk, fma_blk-&gt;gnm_mbox_size, flags);
<a name="l00071"></a>00071                 RETURN(-ENOMEM);
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         reg_to = 0;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <span class="comment">/* PHYS_CONT memory isn&apos;t really mapped, at least not in GART -</span>
<a name="l00077"></a>00077 <span class="comment">         *  but all mappings chew up a MDD</span>
<a name="l00078"></a>00078 <span class="comment">         */</span>
<a name="l00079"></a>00079         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_state != GNILND_FMABLK_PHYS) {
<a name="l00080"></a>00080                 atomic64_add(fma_blk-&gt;gnm_blk_size, &amp;device-&gt;gnd_nbytes_map);
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         atomic_inc(&amp;device-&gt;gnd_n_mdd);
<a name="l00084"></a>00084         <span class="comment">/* nfmablk is live (mapped) blocks */</span>
<a name="l00085"></a>00085         atomic_inc(&amp;device-&gt;gnd_nfmablk);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087         RETURN(0);
<a name="l00088"></a>00088 }
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="keywordtype">int</span>
<a name="l00091"></a>00091 kgnilnd_alloc_fmablk(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device, <span class="keywordtype">int</span> use_phys)
<a name="l00092"></a>00092 {
<a name="l00093"></a>00093         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00094"></a>00094         <span class="keywordtype">int</span>                     num_mbox;
<a name="l00095"></a>00095         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>     *fma_blk;
<a name="l00096"></a>00096         <a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a>         smsg_attr;
<a name="l00097"></a>00097         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>           fmablk_vers;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="preprocessor">#if defined(CONFIG_CRAY_XT) &amp;&amp; !defined(CONFIG_CRAY_COMPUTE)</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>        <span class="comment">/* We allocate large blocks of memory here potentially leading</span>
<a name="l00101"></a>00101 <span class="comment">         * to memory exhaustion during massive reconnects during a network</span>
<a name="l00102"></a>00102 <span class="comment">         * outage. Limit the amount of fma blocks to use by always keeping</span>
<a name="l00103"></a>00103 <span class="comment">         * a percent of pages free initially set to 25% of total memory. */</span>
<a name="l00104"></a>00104         <span class="keywordflow">if</span> (global_page_state(NR_FREE_PAGES) &lt; kgnilnd_data.free_pages_limit) {
<a name="l00105"></a>00105                 LCONSOLE_INFO(<span class="stringliteral">&quot;Exceeding free page limit of %ld. &quot;</span>
<a name="l00106"></a>00106                               <span class="stringliteral">&quot;Free pages available %ld\n&quot;</span>,
<a name="l00107"></a>00107                               kgnilnd_data.free_pages_limit,
<a name="l00108"></a>00108                               global_page_state(NR_FREE_PAGES));
<a name="l00109"></a>00109                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111 <span class="preprocessor">#endif</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>        <span class="comment">/* we&apos;ll use fmablk_vers and the gnd_fmablk_mutex to gate access</span>
<a name="l00113"></a>00113 <span class="comment">         * to this allocation code. Everyone will sample the version</span>
<a name="l00114"></a>00114 <span class="comment">         * before and after getting the mutex. If it has changed,</span>
<a name="l00115"></a>00115 <span class="comment">         * we&apos;ll bail out to check the lists again - this indicates that</span>
<a name="l00116"></a>00116 <span class="comment">         * some sort of change was made to the lists and it is possible</span>
<a name="l00117"></a>00117 <span class="comment">         * that there is a mailbox for us to find now. This should prevent</span>
<a name="l00118"></a>00118 <span class="comment">         * a ton of spinning in the case where there are lots of threads</span>
<a name="l00119"></a>00119 <span class="comment">         * that need a yet-to-be-allocated mailbox for a connection. */</span>
<a name="l00120"></a>00120 
<a name="l00121"></a>00121         fmablk_vers = atomic_read(&amp;device-&gt;gnd_fmablk_vers);
<a name="l00122"></a>00122         mutex_lock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         <span class="keywordflow">if</span> (fmablk_vers != atomic_read(&amp;device-&gt;gnd_fmablk_vers)) {
<a name="l00125"></a>00125                 <span class="comment">/* version changed while we were waiting for semaphore,</span>
<a name="l00126"></a>00126 <span class="comment">                 * we&apos;ll recheck the lists assuming something nice happened */</span>
<a name="l00127"></a>00127                 mutex_unlock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00128"></a>00128                 <span class="keywordflow">return</span> 0;
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         LIBCFS_ALLOC(fma_blk, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>));
<a name="l00132"></a>00132         <span class="keywordflow">if</span> (fma_blk == NULL) {
<a name="l00133"></a>00133                 CNETERR(<span class="stringliteral">&quot;could not allocate fma block descriptor\n&quot;</span>);
<a name="l00134"></a>00134                 rc = -ENOMEM;
<a name="l00135"></a>00135                 GOTO(out, rc);
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         INIT_LIST_HEAD(&amp;fma_blk-&gt;gnm_bufflist);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         kgnilnd_setup_smsg_attr(&amp;smsg_attr);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142         gni_smsg_buff_size_needed(&amp;smsg_attr, &amp;fma_blk-&gt;gnm_mbox_size);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144         LASSERTF(fma_blk-&gt;gnm_mbox_size, <span class="stringliteral">&quot;mbox size %d\n&quot;</span>, fma_blk-&gt;gnm_mbox_size);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         <span class="comment">/* gni_smsg_buff_size_needed calculates the base mailbox size and since</span>
<a name="l00147"></a>00147 <span class="comment">         * we want to hold kgn_peer_credits worth of messages in both directions,</span>
<a name="l00148"></a>00148 <span class="comment">         * we add PAYLOAD to grow the mailbox size</span>
<a name="l00149"></a>00149 <span class="comment">         */</span>
<a name="l00150"></a>00150 
<a name="l00151"></a>00151         fma_blk-&gt;gnm_mbox_size += GNILND_MBOX_PAYLOAD;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153         <span class="comment">/* we&apos;ll only use physical during preallocate at startup -- this keeps it nice and</span>
<a name="l00154"></a>00154 <span class="comment">         * clean for runtime decisions. We&apos;ll keep the PHYS ones around until shutdown</span>
<a name="l00155"></a>00155 <span class="comment">         * as reallocating them is tough if there is memory fragmentation */</span>
<a name="l00156"></a>00156 
<a name="l00157"></a>00157         <span class="keywordflow">if</span> (use_phys) {
<a name="l00158"></a>00158                 fma_blk-&gt;gnm_block = kmem_cache_alloc(kgnilnd_data.kgn_mbox_cache, GFP_ATOMIC);
<a name="l00159"></a>00159                 <span class="keywordflow">if</span> (fma_blk-&gt;gnm_block == NULL) {
<a name="l00160"></a>00160                         CNETERR(<span class="stringliteral">&quot;could not allocate physical SMSG mailbox memory\n&quot;</span>);
<a name="l00161"></a>00161                         rc = -ENOMEM;
<a name="l00162"></a>00162                         GOTO(free_desc, rc);
<a name="l00163"></a>00163                 }
<a name="l00164"></a>00164                 fma_blk-&gt;gnm_blk_size = KMALLOC_MAX_SIZE;
<a name="l00165"></a>00165                 num_mbox = fma_blk-&gt;gnm_blk_size / fma_blk-&gt;gnm_mbox_size;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167                 LASSERTF(num_mbox &gt;= 1,
<a name="l00168"></a>00168                          <span class="stringliteral">&quot;num_mbox %d blk_size %u mbox_size %d\n&quot;</span>,
<a name="l00169"></a>00169                           num_mbox, fma_blk-&gt;gnm_blk_size, fma_blk-&gt;gnm_mbox_size);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171                 fma_blk-&gt;gnm_state = GNILND_FMABLK_PHYS;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         } <span class="keywordflow">else</span> {
<a name="l00174"></a>00174                 num_mbox = *kgnilnd_tunables.kgn_mbox_per_block;
<a name="l00175"></a>00175                 fma_blk-&gt;gnm_blk_size = num_mbox * fma_blk-&gt;gnm_mbox_size;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177                 LASSERTF(num_mbox &gt;= 1 &amp;&amp; num_mbox &gt;= *kgnilnd_tunables.kgn_mbox_per_block,
<a name="l00178"></a>00178                          <span class="stringliteral">&quot;num_mbox %d blk_size %u mbox_size %d tunable %d\n&quot;</span>,
<a name="l00179"></a>00179                          num_mbox, fma_blk-&gt;gnm_blk_size, fma_blk-&gt;gnm_mbox_size,
<a name="l00180"></a>00180                          *kgnilnd_tunables.kgn_mbox_per_block);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182                 fma_blk-&gt;gnm_block = kgnilnd_vzalloc(fma_blk-&gt;gnm_blk_size);
<a name="l00183"></a>00183                 <span class="keywordflow">if</span> (fma_blk-&gt;gnm_block == NULL) {
<a name="l00184"></a>00184                         CNETERR(<span class="stringliteral">&quot;could not allocate virtual SMSG mailbox memory, %d bytes\n&quot;</span>, fma_blk-&gt;gnm_blk_size);
<a name="l00185"></a>00185                         rc = -ENOMEM;
<a name="l00186"></a>00186                         GOTO(free_desc, rc);
<a name="l00187"></a>00187                 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189                 fma_blk-&gt;gnm_state = GNILND_FMABLK_VIRT;
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         <span class="comment">/* allocate just enough space for the bits to track the mailboxes */</span>
<a name="l00193"></a>00193         LIBCFS_ALLOC(fma_blk-&gt;gnm_bit_array, BITS_TO_LONGS(num_mbox) * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>));
<a name="l00194"></a>00194         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_bit_array == NULL) {
<a name="l00195"></a>00195                 CNETERR(<span class="stringliteral">&quot;could not allocate mailbox bitmask, %lu bytes for %d mbox\n&quot;</span>,
<a name="l00196"></a>00196                        <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) * BITS_TO_LONGS(num_mbox), num_mbox);
<a name="l00197"></a>00197                 rc = -ENOMEM;
<a name="l00198"></a>00198                 GOTO(free_blk, rc);
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200         bitmap_zero(fma_blk-&gt;gnm_bit_array, num_mbox);
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="comment">/* now that the num_mbox is set based on allocation type, get debug info setup */</span>
<a name="l00203"></a>00203         LIBCFS_ALLOC(fma_blk-&gt;gnm_mbox_info, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>) * num_mbox);
<a name="l00204"></a>00204         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_mbox_info == NULL) {
<a name="l00205"></a>00205                 CNETERR(<span class="stringliteral">&quot;could not allocate mailbox debug, %lu bytes for %d mbox\n&quot;</span>,
<a name="l00206"></a>00206                        <span class="keyword">sizeof</span>(<a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>) * num_mbox, num_mbox);
<a name="l00207"></a>00207                 rc = -ENOMEM;
<a name="l00208"></a>00208                 GOTO(free_bit, rc);
<a name="l00209"></a>00209         }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         rc = kgnilnd_map_fmablk(device, fma_blk);
<a name="l00212"></a>00212         <span class="keywordflow">if</span> (rc) {
<a name="l00213"></a>00213                 GOTO(free_info, rc);
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         fma_blk-&gt;gnm_next_avail_mbox = 0;
<a name="l00217"></a>00217         fma_blk-&gt;gnm_avail_mboxs = fma_blk-&gt;gnm_num_mboxs = num_mbox;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         CDEBUG(D_MALLOC, <span class="stringliteral">&quot;alloc fmablk 0x%p num %d msg_maxsize %d credits %d &quot;</span>
<a name="l00220"></a>00220                 <span class="stringliteral">&quot;mbox_size %d MDD &quot;</span>LPX64<span class="stringliteral">&quot;.&quot;</span>LPX64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00221"></a>00221                 fma_blk, num_mbox, smsg_attr.msg_maxsize, smsg_attr.mbox_maxcredit,
<a name="l00222"></a>00222                 fma_blk-&gt;gnm_mbox_size, fma_blk-&gt;gnm_hndl.qword1,
<a name="l00223"></a>00223                 fma_blk-&gt;gnm_hndl.qword2);
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         <span class="comment">/* lock Is protecting data structures, not semaphore */</span>
<a name="l00226"></a>00226 
<a name="l00227"></a>00227         spin_lock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00228"></a>00228         list_add_tail(&amp;fma_blk-&gt;gnm_bufflist, &amp;device-&gt;gnd_fma_buffs);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230         <span class="comment">/* toggle under the lock so once they change the list is also</span>
<a name="l00231"></a>00231 <span class="comment">         * ready for others to traverse */</span>
<a name="l00232"></a>00232         atomic_inc(&amp;device-&gt;gnd_fmablk_vers);
<a name="l00233"></a>00233 
<a name="l00234"></a>00234         spin_unlock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         mutex_unlock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         <span class="keywordflow">return</span> 0;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 free_info:
<a name="l00241"></a>00241         LIBCFS_FREE(fma_blk-&gt;gnm_mbox_info, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>)*num_mbox);
<a name="l00242"></a>00242 free_bit:
<a name="l00243"></a>00243         LIBCFS_FREE(fma_blk-&gt;gnm_bit_array, BITS_TO_LONGS(num_mbox) * <span class="keyword">sizeof</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>));
<a name="l00244"></a>00244 free_blk:
<a name="l00245"></a>00245         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_state == GNILND_FMABLK_VIRT) {
<a name="l00246"></a>00246                 LIBCFS_FREE(fma_blk-&gt;gnm_block, fma_blk-&gt;gnm_blk_size);
<a name="l00247"></a>00247         } <span class="keywordflow">else</span> {
<a name="l00248"></a>00248                 kmem_cache_free(kgnilnd_data.kgn_mbox_cache, fma_blk-&gt;gnm_block);
<a name="l00249"></a>00249         }
<a name="l00250"></a>00250 free_desc:
<a name="l00251"></a>00251         LIBCFS_FREE(fma_blk, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>));
<a name="l00252"></a>00252 out:
<a name="l00253"></a>00253         mutex_unlock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00254"></a>00254         <span class="keywordflow">return</span> rc;
<a name="l00255"></a>00255 }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keywordtype">void</span>
<a name="l00258"></a>00258 kgnilnd_unmap_fmablk(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a> *fma_blk)
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260         gni_return_t            rrc;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         <span class="comment">/* if some held, set hold_timeout from conn timeouts used in this block</span>
<a name="l00263"></a>00263 <span class="comment">         * but not during shutdown, then just nuke and pave</span>
<a name="l00264"></a>00264 <span class="comment">         * During a stack reset, we need to deregister with a hold timeout</span>
<a name="l00265"></a>00265 <span class="comment">         * set so we don&apos;t use the same mdd after reset is complete */</span>
<a name="l00266"></a>00266         <span class="keywordflow">if</span> ((fma_blk-&gt;gnm_held_mboxs &amp;&amp; !kgnilnd_data.kgn_shutdown) ||
<a name="l00267"></a>00267             kgnilnd_data.kgn_in_reset) {
<a name="l00268"></a>00268                 fma_blk-&gt;gnm_hold_timeout = GNILND_TIMEOUT2DEADMAN;
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271         <span class="comment">/* we are changing the state of a block, tickle version to tell</span>
<a name="l00272"></a>00272 <span class="comment">         * proc code list is stale now */</span>
<a name="l00273"></a>00273         atomic_inc(&amp;dev-&gt;gnd_fmablk_vers);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         rrc = kgnilnd_mem_deregister(dev-&gt;gnd_handle, &amp;fma_blk-&gt;gnm_hndl, fma_blk-&gt;gnm_hold_timeout);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         CDEBUG(rrc == GNI_RC_SUCCESS ? D_MALLOC : D_CONSOLE|D_NETERROR,
<a name="l00278"></a>00278                <span class="stringliteral">&quot;unmap fmablk 0x%p@%s sz %u total %d avail %d held %d mbox_size %d &quot;</span>
<a name="l00279"></a>00279                 <span class="stringliteral">&quot;hold_timeout %d\n&quot;</span>,
<a name="l00280"></a>00280                fma_blk, kgnilnd_fmablk_state2str(fma_blk-&gt;gnm_state),
<a name="l00281"></a>00281                fma_blk-&gt;gnm_blk_size, fma_blk-&gt;gnm_num_mboxs,
<a name="l00282"></a>00282                fma_blk-&gt;gnm_avail_mboxs, fma_blk-&gt;gnm_held_mboxs,
<a name="l00283"></a>00283                fma_blk-&gt;gnm_mbox_size, fma_blk-&gt;gnm_hold_timeout);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285         LASSERTF(rrc == GNI_RC_SUCCESS,
<a name="l00286"></a>00286                 <span class="stringliteral">&quot;tried to double unmap or something bad, fma_blk %p (rrc %d)\n&quot;</span>,
<a name="l00287"></a>00287                 fma_blk, rrc);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_hold_timeout &amp;&amp;
<a name="l00290"></a>00290             !(kgnilnd_data.kgn_in_reset &amp;&amp;
<a name="l00291"></a>00291               fma_blk-&gt;gnm_state == GNILND_FMABLK_PHYS)) {
<a name="l00292"></a>00292                 atomic_inc(&amp;dev-&gt;gnd_n_mdd_held);
<a name="l00293"></a>00293         } <span class="keywordflow">else</span> {
<a name="l00294"></a>00294                 atomic_dec(&amp;dev-&gt;gnd_n_mdd);
<a name="l00295"></a>00295         }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297         <span class="comment">/* PHYS blocks don&apos;t get mapped */</span>
<a name="l00298"></a>00298         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_state != GNILND_FMABLK_PHYS) {
<a name="l00299"></a>00299                 atomic64_sub(fma_blk-&gt;gnm_blk_size, &amp;dev-&gt;gnd_nbytes_map);
<a name="l00300"></a>00300                 fma_blk-&gt;gnm_state = GNILND_FMABLK_IDLE;
<a name="l00301"></a>00301         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kgnilnd_data.kgn_in_reset) {
<a name="l00302"></a>00302                 <span class="comment">/* in stack reset, clear MDD handle for PHYS blocks, as we&apos;ll</span>
<a name="l00303"></a>00303 <span class="comment">                 * re-use the fma_blk after reset so we don&apos;t have to drop/allocate</span>
<a name="l00304"></a>00304 <span class="comment">                 * all of those physical blocks */</span>
<a name="l00305"></a>00305                 fma_blk-&gt;gnm_hndl.qword1 = fma_blk-&gt;gnm_hndl.qword2 = 0UL;
<a name="l00306"></a>00306         }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308         <span class="comment">/* Decrement here as this is the # of mapped blocks */</span>
<a name="l00309"></a>00309         atomic_dec(&amp;dev-&gt;gnd_nfmablk);
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="comment">/* needs lock on gnd_fmablk_lock to cover gnd_fma_buffs */</span>
<a name="l00314"></a>00314 <span class="keywordtype">void</span>
<a name="l00315"></a>00315 kgnilnd_free_fmablk_locked(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a> *fma_blk)
<a name="l00316"></a>00316 {
<a name="l00317"></a>00317         LASSERTF(fma_blk-&gt;gnm_avail_mboxs == fma_blk-&gt;gnm_num_mboxs,
<a name="l00318"></a>00318                  <span class="stringliteral">&quot;fma_blk %p@%d free in bad state (%d): blk total %d avail %d held %d\n&quot;</span>,
<a name="l00319"></a>00319                  fma_blk, fma_blk-&gt;gnm_state, fma_blk-&gt;gnm_hold_timeout, fma_blk-&gt;gnm_num_mboxs,
<a name="l00320"></a>00320                 fma_blk-&gt;gnm_avail_mboxs, fma_blk-&gt;gnm_held_mboxs);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322         atomic_inc(&amp;dev-&gt;gnd_fmablk_vers);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_hold_timeout) {
<a name="l00325"></a>00325                 CDEBUG(D_MALLOC, <span class="stringliteral">&quot;mdd release fmablk 0x%p sz %u avail %d held %d &quot;</span>
<a name="l00326"></a>00326                         <span class="stringliteral">&quot;mbox_size %d\n&quot;</span>,
<a name="l00327"></a>00327                         fma_blk, fma_blk-&gt;gnm_blk_size, fma_blk-&gt;gnm_avail_mboxs,
<a name="l00328"></a>00328                         fma_blk-&gt;gnm_held_mboxs, fma_blk-&gt;gnm_mbox_size);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330                 <span class="comment">/* We leave MDD dangling over stack reset */</span>
<a name="l00331"></a>00331                 <span class="keywordflow">if</span> (!kgnilnd_data.kgn_in_reset) {
<a name="l00332"></a>00332                         kgnilnd_mem_mdd_release(dev-&gt;gnd_handle, &amp;fma_blk-&gt;gnm_hndl);
<a name="l00333"></a>00333                 }
<a name="l00334"></a>00334                 <span class="comment">/* ignoring the return code - if kgni/ghal can&apos;t find it</span>
<a name="l00335"></a>00335 <span class="comment">                 * it must be released already */</span>
<a name="l00336"></a>00336                 atomic_dec(&amp;dev-&gt;gnd_n_mdd_held);
<a name="l00337"></a>00337                 atomic_dec(&amp;dev-&gt;gnd_n_mdd);
<a name="l00338"></a>00338         }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         <span class="comment">/* we cant&apos; free the gnm_block until all the conns have released their</span>
<a name="l00341"></a>00341 <span class="comment">         * purgatory holds. While we have purgatory holds, we might check the conn</span>
<a name="l00342"></a>00342 <span class="comment">         * RX mailbox during the CLOSING process. It is possible that kgni might</span>
<a name="l00343"></a>00343 <span class="comment">         * try to look into the RX side for credits when sending the CLOSE msg too */</span>
<a name="l00344"></a>00344         CDEBUG(D_MALLOC, <span class="stringliteral">&quot;fmablk %p free buffer %p mbox_size %d\n&quot;</span>,
<a name="l00345"></a>00345                 fma_blk, fma_blk-&gt;gnm_block, fma_blk-&gt;gnm_mbox_size);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_state == GNILND_FMABLK_PHYS) {
<a name="l00348"></a>00348                 kmem_cache_free(kgnilnd_data.kgn_mbox_cache, fma_blk-&gt;gnm_block);
<a name="l00349"></a>00349         } <span class="keywordflow">else</span> {
<a name="l00350"></a>00350                 LIBCFS_FREE(fma_blk-&gt;gnm_block, fma_blk-&gt;gnm_blk_size);
<a name="l00351"></a>00351         }
<a name="l00352"></a>00352         fma_blk-&gt;gnm_state = GNILND_FMABLK_FREED;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354         list_del(&amp;fma_blk-&gt;gnm_bufflist);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         LIBCFS_FREE(fma_blk-&gt;gnm_mbox_info, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>)*fma_blk-&gt;gnm_num_mboxs);
<a name="l00357"></a>00357         LIBCFS_FREE(fma_blk-&gt;gnm_bit_array, BITS_TO_LONGS(fma_blk-&gt;gnm_num_mboxs) * sizeof (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>));
<a name="l00358"></a>00358         LIBCFS_FREE(fma_blk, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>));
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 <span class="keywordtype">void</span>
<a name="l00362"></a>00362 kgnilnd_find_free_mbox(<a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn)
<a name="l00363"></a>00363 {
<a name="l00364"></a>00364         <a class="code" href="structkgn__device.html">kgn_device_t</a>            *dev = conn-&gt;gnc_device;
<a name="l00365"></a>00365         <a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a>         *smsg_attr = &amp;conn-&gt;gnpr_smsg_attr;
<a name="l00366"></a>00366         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>      *fma_blk;
<a name="l00367"></a>00367         <a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>         *mbox = NULL;
<a name="l00368"></a>00368         <span class="keywordtype">int</span>                     id;
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         spin_lock(&amp;dev-&gt;gnd_fmablk_lock);
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         list_for_each_entry(fma_blk, &amp;conn-&gt;gnc_device-&gt;gnd_fma_buffs,
<a name="l00373"></a>00373                             gnm_bufflist) {
<a name="l00374"></a>00374                 <span class="keywordflow">if</span> (fma_blk-&gt;gnm_avail_mboxs &lt;= 0 ||
<a name="l00375"></a>00375                     fma_blk-&gt;gnm_state &lt;= GNILND_FMABLK_IDLE) {
<a name="l00376"></a>00376                         <span class="keywordflow">continue</span>;
<a name="l00377"></a>00377                 }
<a name="l00378"></a>00378                 <span class="comment">/* look in bitarray for available mailbox */</span>
<a name="l00379"></a>00379                 <span class="keywordflow">do</span> {
<a name="l00380"></a>00380                         <span class="keywordtype">id</span> = find_next_zero_bit(
<a name="l00381"></a>00381                                 fma_blk-&gt;gnm_bit_array,
<a name="l00382"></a>00382                                 fma_blk-&gt;gnm_num_mboxs,
<a name="l00383"></a>00383                                 fma_blk-&gt;gnm_next_avail_mbox);
<a name="l00384"></a>00384                       <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == fma_blk-&gt;gnm_num_mboxs &amp;&amp;
<a name="l00385"></a>00385                           fma_blk-&gt;gnm_next_avail_mbox != 0) {
<a name="l00386"></a>00386                                 <span class="comment">/* wrap around */</span>
<a name="l00387"></a>00387                                 fma_blk-&gt;gnm_next_avail_mbox = 0;
<a name="l00388"></a>00388                         } <span class="keywordflow">else</span> {
<a name="l00389"></a>00389                                 <span class="keywordflow">break</span>;
<a name="l00390"></a>00390                         }
<a name="l00391"></a>00391                 } <span class="keywordflow">while</span> (1);
<a name="l00392"></a>00392 
<a name="l00393"></a>00393                 LASSERTF(id &lt; fma_blk-&gt;gnm_num_mboxs, <span class="stringliteral">&quot;id %d max %d\n&quot;</span>,
<a name="l00394"></a>00394                          <span class="keywordtype">id</span>, fma_blk-&gt;gnm_num_mboxs);
<a name="l00395"></a>00395                 set_bit(<span class="keywordtype">id</span>, (<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)fma_blk-&gt;gnm_bit_array);
<a name="l00396"></a>00396                 conn-&gt;gnc_mbox_id = id;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398                 fma_blk-&gt;gnm_next_avail_mbox =
<a name="l00399"></a>00399                         (<span class="keywordtype">id</span> == (fma_blk-&gt;gnm_num_mboxs - 1)) ? 0 : (<span class="keywordtype">id</span> + 1);
<a name="l00400"></a>00400                 fma_blk-&gt;gnm_avail_mboxs--;
<a name="l00401"></a>00401                 conn-&gt;gnc_fma_blk = fma_blk;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403                 kgnilnd_setup_smsg_attr(smsg_attr);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405                 smsg_attr-&gt;msg_buffer = fma_blk-&gt;gnm_block;
<a name="l00406"></a>00406                 smsg_attr-&gt;mbox_offset = fma_blk-&gt;gnm_mbox_size * id;
<a name="l00407"></a>00407                 smsg_attr-&gt;mem_hndl = fma_blk-&gt;gnm_hndl;
<a name="l00408"></a>00408                 smsg_attr-&gt;buff_size = fma_blk-&gt;gnm_mbox_size;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410                 <span class="comment">/* We&apos;ll set the hndl to zero for PHYS blocks unmapped during stack</span>
<a name="l00411"></a>00411 <span class="comment">                 * reset and re-use the same fma_blk after stack reset. This ensures we&apos;ve</span>
<a name="l00412"></a>00412 <span class="comment">                 * properly mapped it before we use it */</span>
<a name="l00413"></a>00413                 LASSERTF(fma_blk-&gt;gnm_hndl.qword1 != 0UL, <span class="stringliteral">&quot;unmapped fma_blk %p, state %d\n&quot;</span>,
<a name="l00414"></a>00414                          fma_blk, fma_blk-&gt;gnm_state);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416                 CDEBUG(D_NET, <span class="stringliteral">&quot;conn %p smsg %p fmablk %p &quot;</span>
<a name="l00417"></a>00417                         <span class="stringliteral">&quot;allocating SMSG mbox %d buf %p &quot;</span>
<a name="l00418"></a>00418                         <span class="stringliteral">&quot;offset %u hndl &quot;</span>LPX64<span class="stringliteral">&quot;.&quot;</span>LPX64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00419"></a>00419                         conn, smsg_attr, fma_blk, <span class="keywordtype">id</span>,
<a name="l00420"></a>00420                         smsg_attr-&gt;msg_buffer, smsg_attr-&gt;mbox_offset,
<a name="l00421"></a>00421                         fma_blk-&gt;gnm_hndl.qword1,
<a name="l00422"></a>00422                         fma_blk-&gt;gnm_hndl.qword2);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424                 mbox = &amp;fma_blk-&gt;gnm_mbox_info[id];
<a name="l00425"></a>00425                 mbox-&gt;mbx_create_conn_memset = jiffies;
<a name="l00426"></a>00426                 mbox-&gt;mbx_nallocs++;
<a name="l00427"></a>00427                 mbox-&gt;mbx_nallocs_total++;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429                 <span class="comment">/* zero mbox to remove any old data from our last use.</span>
<a name="l00430"></a>00430 <span class="comment">                 * this better be safe, if not our purgatory timers</span>
<a name="l00431"></a>00431 <span class="comment">                 * are too short or a peer really is misbehaving */</span>
<a name="l00432"></a>00432                 memset(smsg_attr-&gt;msg_buffer + smsg_attr-&gt;mbox_offset,
<a name="l00433"></a>00433                        0, smsg_attr-&gt;buff_size);
<a name="l00434"></a>00434                 <span class="keywordflow">break</span>;
<a name="l00435"></a>00435         }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         spin_unlock(&amp;dev-&gt;gnd_fmablk_lock);
<a name="l00438"></a>00438 }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="keywordtype">int</span>
<a name="l00441"></a>00441 kgnilnd_setup_mbox(<a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443         <a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a>         *smsg_attr = &amp;conn-&gt;gnpr_smsg_attr;
<a name="l00444"></a>00444         <span class="keywordtype">int</span>                      err = 0;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446         smsg_attr-&gt;msg_buffer = NULL;
<a name="l00447"></a>00447         <span class="comment">/* Look for available mbox */</span>
<a name="l00448"></a>00448         <span class="keywordflow">do</span> {
<a name="l00449"></a>00449                 kgnilnd_find_free_mbox(conn);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451                 <span class="comment">/* nothing in the existing buffers, make a new one */</span>
<a name="l00452"></a>00452                 <span class="keywordflow">if</span> (smsg_attr-&gt;msg_buffer == NULL) {
<a name="l00453"></a>00453                         <span class="comment">/* for runtime allocations, we only want vmalloc */</span>
<a name="l00454"></a>00454                         err = kgnilnd_alloc_fmablk(conn-&gt;gnc_device, 0);
<a name="l00455"></a>00455                         <span class="keywordflow">if</span> (err) {
<a name="l00456"></a>00456                                 <span class="keywordflow">break</span>;
<a name="l00457"></a>00457                         }
<a name="l00458"></a>00458                 }
<a name="l00459"></a>00459         } <span class="keywordflow">while</span> (smsg_attr-&gt;msg_buffer == NULL);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (err)
<a name="l00462"></a>00462                 CNETERR(<span class="stringliteral">&quot;couldn&apos;t allocate SMSG mbox for conn %p Error: %d\n&quot;</span>,
<a name="l00463"></a>00463                         conn, err);
<a name="l00464"></a>00464         <span class="keywordflow">return</span> err;
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keywordtype">void</span>
<a name="l00468"></a>00468 kgnilnd_release_mbox(<a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn, <span class="keywordtype">int</span> purgatory_hold)
<a name="l00469"></a>00469 {
<a name="l00470"></a>00470         <a class="code" href="structkgn__device.html">kgn_device_t</a>           *dev = conn-&gt;gnc_device;
<a name="l00471"></a>00471         <a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a>        *smsg_attr = &amp;conn-&gt;gnpr_smsg_attr;
<a name="l00472"></a>00472         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>     *fma_blk = NULL;
<a name="l00473"></a>00473         <a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>        *mbox = NULL;
<a name="l00474"></a>00474         <span class="keywordtype">int</span>                     found = 0;
<a name="l00475"></a>00475         <span class="keywordtype">int</span>                     id;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         <span class="comment">/* if we failed to setup mbox and now destroying conn */</span>
<a name="l00478"></a>00478         <span class="keywordflow">if</span> (smsg_attr-&gt;msg_buffer == NULL) {
<a name="l00479"></a>00479                 <span class="keywordflow">return</span>;
<a name="l00480"></a>00480         }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482         <span class="keywordtype">id</span> = conn-&gt;gnc_mbox_id;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         spin_lock(&amp;dev-&gt;gnd_fmablk_lock);
<a name="l00485"></a>00485         <span class="comment">/* make sure our conn points at a valid fma_blk</span>
<a name="l00486"></a>00486 <span class="comment">         * We use this instead of a mem block search out of smsg_attr</span>
<a name="l00487"></a>00487 <span class="comment">         * because we could have freed a block for fma_blk #1 but the fma_blk</span>
<a name="l00488"></a>00488 <span class="comment">         * is still in the list for a purgatory hold. This would induce a false</span>
<a name="l00489"></a>00489 <span class="comment">         * match if that same block gets reallocated to fma_blk #2 */</span>
<a name="l00490"></a>00490         list_for_each_entry(fma_blk, &amp;dev-&gt;gnd_fma_buffs, gnm_bufflist) {
<a name="l00491"></a>00491                 <span class="keywordflow">if</span> (fma_blk == conn-&gt;gnc_fma_blk) {
<a name="l00492"></a>00492                         found = 1;
<a name="l00493"></a>00493                         <span class="keywordflow">break</span>;
<a name="l00494"></a>00494                 }
<a name="l00495"></a>00495         }
<a name="l00496"></a>00496         LASSERTF(found, <span class="stringliteral">&quot;unable to find conn 0x%p with gnc_fma_blk %p &quot;</span>
<a name="l00497"></a>00497                  <span class="stringliteral">&quot;anywhere in the world\n&quot;</span>, conn, conn-&gt;gnc_fma_blk);
<a name="l00498"></a>00498 
<a name="l00499"></a>00499         LASSERTF(id &lt; fma_blk-&gt;gnm_num_mboxs,
<a name="l00500"></a>00500                 <span class="stringliteral">&quot;bad id %d max %d\n&quot;</span>,
<a name="l00501"></a>00501                 <span class="keywordtype">id</span>, fma_blk-&gt;gnm_num_mboxs);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503         <span class="comment">/* &lt; 0 - was held, now free it</span>
<a name="l00504"></a>00504 <span class="comment">         * == 0 - just free it</span>
<a name="l00505"></a>00505 <span class="comment">         * &gt; 0 - hold it for now */</span>
<a name="l00506"></a>00506         <span class="keywordflow">if</span> (purgatory_hold == 0) {
<a name="l00507"></a>00507                 CDEBUG(D_NET, <span class="stringliteral">&quot;conn %p smsg %p fmablk %p freeing SMSG mbox %d &quot;</span>
<a name="l00508"></a>00508                         <span class="stringliteral">&quot;hndl &quot;</span>LPX64<span class="stringliteral">&quot;.&quot;</span>LPX64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00509"></a>00509                         conn, smsg_attr, fma_blk, <span class="keywordtype">id</span>,
<a name="l00510"></a>00510                         fma_blk-&gt;gnm_hndl.qword1, fma_blk-&gt;gnm_hndl.qword2);
<a name="l00511"></a>00511                 fma_blk-&gt;gnm_avail_mboxs++;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (purgatory_hold &gt; 0) {
<a name="l00514"></a>00514                 CDEBUG(D_NET, <span class="stringliteral">&quot;conn %p smsg %p fmablk %p holding SMSG mbox %d &quot;</span>
<a name="l00515"></a>00515                         <span class="stringliteral">&quot;hndl &quot;</span>LPX64<span class="stringliteral">&quot;.&quot;</span>LPX64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00516"></a>00516                         conn, smsg_attr, fma_blk, <span class="keywordtype">id</span>,
<a name="l00517"></a>00517                         fma_blk-&gt;gnm_hndl.qword1, fma_blk-&gt;gnm_hndl.qword2);
<a name="l00518"></a>00518 
<a name="l00519"></a>00519                 fma_blk-&gt;gnm_held_mboxs++;
<a name="l00520"></a>00520                 fma_blk-&gt;gnm_max_timeout = MAX(fma_blk-&gt;gnm_max_timeout,
<a name="l00521"></a>00521                                                 conn-&gt;gnc_timeout);
<a name="l00522"></a>00522         } <span class="keywordflow">else</span> {
<a name="l00523"></a>00523                 CDEBUG(D_NET, <span class="stringliteral">&quot;conn %p smsg %p fmablk %p release SMSG mbox %d &quot;</span>
<a name="l00524"></a>00524                         <span class="stringliteral">&quot;hndl &quot;</span>LPX64<span class="stringliteral">&quot;.&quot;</span>LPX64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00525"></a>00525                         conn, smsg_attr, fma_blk, <span class="keywordtype">id</span>,
<a name="l00526"></a>00526                         fma_blk-&gt;gnm_hndl.qword1, fma_blk-&gt;gnm_hndl.qword2);
<a name="l00527"></a>00527 
<a name="l00528"></a>00528                 fma_blk-&gt;gnm_held_mboxs--;
<a name="l00529"></a>00529                 fma_blk-&gt;gnm_avail_mboxs++;
<a name="l00530"></a>00530         }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         <span class="keywordflow">if</span> (purgatory_hold &lt;= 0) {
<a name="l00533"></a>00533                 <span class="comment">/* if kgni is retransmitting, freeing the smsg block before the EP</span>
<a name="l00534"></a>00534 <span class="comment">                 * is destroyed gets messy. Bug 768295. */</span>
<a name="l00535"></a>00535                 LASSERTF(conn-&gt;gnc_ephandle == NULL,
<a name="l00536"></a>00536                          <span class="stringliteral">&quot;can&apos;t release mbox before EP is nuked. conn 0x%p\n&quot;</span>, conn);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538                 mbox = &amp;fma_blk-&gt;gnm_mbox_info[id];
<a name="l00539"></a>00539                 mbox-&gt;mbx_release_from_purgatory = jiffies;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541                 <span class="comment">/* clear conn gnc_fmablk if it is gone - this allows us to</span>
<a name="l00542"></a>00542 <span class="comment">                 * not worry about state so much in kgnilnd_destroy_conn</span>
<a name="l00543"></a>00543 <span class="comment">                 * and makes the guaranteed cleanup of the resources easier */</span>
<a name="l00544"></a>00544                 LASSERTF(test_and_clear_bit(<span class="keywordtype">id</span>, fma_blk-&gt;gnm_bit_array),
<a name="l00545"></a>00545                         <span class="stringliteral">&quot;conn %p bit %d already cleared in fma_blk %p\n&quot;</span>,
<a name="l00546"></a>00546                          conn, <span class="keywordtype">id</span>, fma_blk);
<a name="l00547"></a>00547                 conn-&gt;gnc_fma_blk = NULL;
<a name="l00548"></a>00548                 mbox-&gt;mbx_nallocs--;
<a name="l00549"></a>00549         }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_FMABLK_AVAIL)) {
<a name="l00552"></a>00552                 CERROR(<span class="stringliteral">&quot;LBUGs in your future: forcibly marking fma_blk %p &quot;</span>
<a name="l00553"></a>00553                        <span class="stringliteral">&quot;as mapped\n&quot;</span>, fma_blk);
<a name="l00554"></a>00554                 fma_blk-&gt;gnm_state = GNILND_FMABLK_VIRT;
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         <span class="comment">/* we don&apos;t release or unmap PHYS blocks as part of the normal cycle --</span>
<a name="l00558"></a>00558 <span class="comment">         * those are controlled manually from startup/shutdown */</span>
<a name="l00559"></a>00559         <span class="keywordflow">if</span> (fma_blk-&gt;gnm_state != GNILND_FMABLK_PHYS) {
<a name="l00560"></a>00560                 <span class="comment">/* we can unmap once all are unused (held or avail)</span>
<a name="l00561"></a>00561 <span class="comment">                 * but check hold_timeout to make sure we are not trying to double</span>
<a name="l00562"></a>00562 <span class="comment">                 * unmap this buffer. If there was no hold_timeout set due to</span>
<a name="l00563"></a>00563 <span class="comment">                 * held_mboxs, we&apos;ll free the mobx here shortly and won&apos;t have to</span>
<a name="l00564"></a>00564 <span class="comment">                 * worry about catching a double free for a &apos;clean&apos; fma_blk */</span>
<a name="l00565"></a>00565                 <span class="keywordflow">if</span> (((fma_blk-&gt;gnm_avail_mboxs + fma_blk-&gt;gnm_held_mboxs) == fma_blk-&gt;gnm_num_mboxs) &amp;&amp;
<a name="l00566"></a>00566                     (!fma_blk-&gt;gnm_hold_timeout)) {
<a name="l00567"></a>00567                         kgnilnd_unmap_fmablk(dev, fma_blk);
<a name="l00568"></a>00568                 }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570                 <span class="comment">/* But we can only free once they are all avail */</span>
<a name="l00571"></a>00571                 <span class="keywordflow">if</span> (fma_blk-&gt;gnm_avail_mboxs == fma_blk-&gt;gnm_num_mboxs &amp;&amp;
<a name="l00572"></a>00572                     fma_blk-&gt;gnm_held_mboxs == 0) {
<a name="l00573"></a>00573                         <span class="comment">/* all mailboxes are released, free fma_blk */</span>
<a name="l00574"></a>00574                         kgnilnd_free_fmablk_locked(dev, fma_blk);
<a name="l00575"></a>00575                 }
<a name="l00576"></a>00576         }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         spin_unlock(&amp;dev-&gt;gnd_fmablk_lock);
<a name="l00579"></a>00579 }
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="keywordtype">int</span>
<a name="l00582"></a>00582 kgnilnd_count_phys_mbox(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00583"></a>00583 {
<a name="l00584"></a>00584         <span class="keywordtype">int</span>                     i = 0;
<a name="l00585"></a>00585         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>     *fma_blk;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587         spin_lock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589         list_for_each_entry(fma_blk, &amp;device-&gt;gnd_fma_buffs, gnm_bufflist) {
<a name="l00590"></a>00590                 <span class="keywordflow">if</span> (fma_blk-&gt;gnm_state == GNILND_FMABLK_PHYS)
<a name="l00591"></a>00591                         i += fma_blk-&gt;gnm_num_mboxs;
<a name="l00592"></a>00592         }
<a name="l00593"></a>00593         spin_unlock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         RETURN(i);
<a name="l00596"></a>00596 }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="keywordtype">int</span>
<a name="l00599"></a>00599 kgnilnd_allocate_phys_fmablk(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601         <span class="keywordtype">int</span>     rc;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603         <span class="keywordflow">while</span> (kgnilnd_count_phys_mbox(device) &lt; *kgnilnd_tunables.kgn_nphys_mbox) {
<a name="l00604"></a>00604 
<a name="l00605"></a>00605                 rc = kgnilnd_alloc_fmablk(device, 1);
<a name="l00606"></a>00606                 <span class="keywordflow">if</span> (rc) {
<a name="l00607"></a>00607                         CERROR(<span class="stringliteral">&quot;failed phys mbox allocation, stopping at %d, rc %d\n&quot;</span>,
<a name="l00608"></a>00608                                 kgnilnd_count_phys_mbox(device), rc);
<a name="l00609"></a>00609                         RETURN(rc);
<a name="l00610"></a>00610                 }
<a name="l00611"></a>00611         }
<a name="l00612"></a>00612         RETURN(0);
<a name="l00613"></a>00613 }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="keywordtype">int</span>
<a name="l00616"></a>00616 kgnilnd_map_phys_fmablk(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00617"></a>00617 {
<a name="l00618"></a>00618 
<a name="l00619"></a>00619         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00620"></a>00620         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>     *fma_blk;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622         <span class="comment">/* use mutex to gate access to single thread, just in case */</span>
<a name="l00623"></a>00623         mutex_lock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00624"></a>00624 
<a name="l00625"></a>00625         spin_lock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00626"></a>00626 
<a name="l00627"></a>00627         list_for_each_entry(fma_blk, &amp;device-&gt;gnd_fma_buffs, gnm_bufflist) {
<a name="l00628"></a>00628                 <span class="keywordflow">if</span> (fma_blk-&gt;gnm_state == GNILND_FMABLK_PHYS) {
<a name="l00629"></a>00629                         rc = kgnilnd_map_fmablk(device, fma_blk);
<a name="l00630"></a>00630                         <span class="keywordflow">if</span> (rc)
<a name="l00631"></a>00631                                 <span class="keywordflow">break</span>;
<a name="l00632"></a>00632                 }
<a name="l00633"></a>00633         }
<a name="l00634"></a>00634         spin_unlock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         mutex_unlock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         RETURN(rc);
<a name="l00639"></a>00639 }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 <span class="keywordtype">void</span>
<a name="l00642"></a>00642 kgnilnd_unmap_fma_blocks(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00643"></a>00643 {
<a name="l00644"></a>00644 
<a name="l00645"></a>00645         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>      *fma_blk;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647         <span class="comment">/* use mutex to gate access to single thread, just in case */</span>
<a name="l00648"></a>00648         mutex_lock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         spin_lock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00651"></a>00651 
<a name="l00652"></a>00652         list_for_each_entry(fma_blk, &amp;device-&gt;gnd_fma_buffs, gnm_bufflist) {
<a name="l00653"></a>00653                 kgnilnd_unmap_fmablk(device, fma_blk);
<a name="l00654"></a>00654         }
<a name="l00655"></a>00655         spin_unlock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         mutex_unlock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00658"></a>00658 }
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="keywordtype">void</span>
<a name="l00661"></a>00661 kgnilnd_free_phys_fmablk(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00662"></a>00662 {
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>      *fma_blk, *fma_blkN;
<a name="l00665"></a>00665 
<a name="l00666"></a>00666         <span class="comment">/* use mutex to gate access to single thread, just in case */</span>
<a name="l00667"></a>00667         mutex_lock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669         spin_lock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671         list_for_each_entry_safe(fma_blk, fma_blkN, &amp;device-&gt;gnd_fma_buffs, gnm_bufflist) {
<a name="l00672"></a>00672                 <span class="keywordflow">if</span> (fma_blk-&gt;gnm_state == GNILND_FMABLK_PHYS)
<a name="l00673"></a>00673                         kgnilnd_free_fmablk_locked(device, fma_blk);
<a name="l00674"></a>00674         }
<a name="l00675"></a>00675         spin_unlock(&amp;device-&gt;gnd_fmablk_lock);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677         mutex_unlock(&amp;device-&gt;gnd_fmablk_mutex);
<a name="l00678"></a>00678 }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 <span class="comment">/* kgnilnd dgram nid-&gt;struct managment */</span>
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *
<a name="l00683"></a>00683 kgnilnd_nid2dgramlist(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid)
<a name="l00684"></a>00684 {
<a name="l00685"></a>00685         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = ((<span class="keywordtype">unsigned</span> int)nid) % *kgnilnd_tunables.kgn_peer_hash_size;
<a name="l00686"></a>00686 
<a name="l00687"></a>00687         RETURN(&amp;dev-&gt;gnd_dgrams[hash]);
<a name="l00688"></a>00688 }
<a name="l00689"></a>00689 
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="comment">/* needs dev-&gt;gnd_dgram_lock held */</span>
<a name="l00692"></a>00692 <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *
<a name="l00693"></a>00693 kgnilnd_find_dgram_locked(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dst_nid)
<a name="l00694"></a>00694 {
<a name="l00695"></a>00695         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *dgram_list = kgnilnd_nid2dgramlist(dev, dst_nid);
<a name="l00696"></a>00696         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>      *dgram;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         list_for_each_entry(dgram, dgram_list, gndg_list) {
<a name="l00699"></a>00699 
<a name="l00700"></a>00700                 <span class="comment">/* if state &gt; POSTED, we are already handling cancel/completion */</span>
<a name="l00701"></a>00701                 <span class="keywordflow">if</span> ((dgram-&gt;gndg_conn_out.gncr_dstnid != dst_nid) ||
<a name="l00702"></a>00702                      dgram-&gt;gndg_state &gt; GNILND_DGRAM_POSTED)
<a name="l00703"></a>00703                         <span class="keywordflow">continue</span>;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705                 CDEBUG(D_NET, <span class="stringliteral">&quot;got dgram [%p] -&gt; %s\n&quot;</span>,
<a name="l00706"></a>00706                        dgram, libcfs_nid2str(dst_nid));
<a name="l00707"></a>00707                 <span class="keywordflow">return</span> dgram;
<a name="l00708"></a>00708         }
<a name="l00709"></a>00709         <span class="keywordflow">return</span> NULL;
<a name="l00710"></a>00710 }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <span class="keywordtype">int</span>
<a name="l00713"></a>00713 kgnilnd_find_and_cancel_dgram(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dst_nid)
<a name="l00714"></a>00714 {
<a name="l00715"></a>00715         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>     *dgram;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         spin_lock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l00718"></a>00718         dgram = kgnilnd_find_dgram_locked(dev, dst_nid);
<a name="l00719"></a>00719 
<a name="l00720"></a>00720         <span class="keywordflow">if</span> (dgram) {
<a name="l00721"></a>00721                 kgnilnd_cancel_dgram_locked(dgram);
<a name="l00722"></a>00722         }
<a name="l00723"></a>00723         spin_unlock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725         RETURN(!!(dgram == NULL));
<a name="l00726"></a>00726 }
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 <span class="keywordtype">int</span>
<a name="l00729"></a>00729 kgnilnd_pack_connreq(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a> *connreq, <a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn,
<a name="l00730"></a>00730                      <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> srcnid, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dstnid,
<a name="l00731"></a>00731                      kgn_connreq_type_t type)
<a name="l00732"></a>00732 {
<a name="l00733"></a>00733         <span class="keywordtype">int</span> err = 0;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         <span class="comment">/* ensure we haven&apos;t violated max datagram size */</span>
<a name="l00736"></a>00736         CLASSERT(<span class="keyword">sizeof</span>(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>) &lt;= GNI_DATAGRAM_MAXSIZE);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         <span class="comment">/* no need to zero out, we do that when allocating dgram */</span>
<a name="l00739"></a>00739         connreq-&gt;gncr_magic     = GNILND_MSG_MAGIC;
<a name="l00740"></a>00740 
<a name="l00741"></a>00741         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_PACK_SRCNID)) {
<a name="l00742"></a>00742                 srcnid = 0xABADBABE;
<a name="l00743"></a>00743         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_PACK_DSTNID)) {
<a name="l00744"></a>00744                 dstnid = 0xDEFEC8ED;
<a name="l00745"></a>00745         }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         connreq-&gt;gncr_srcnid    = srcnid;
<a name="l00748"></a>00748         connreq-&gt;gncr_dstnid    = dstnid;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_CONNREQ_PROTO)) {
<a name="l00751"></a>00751                 connreq-&gt;gncr_version = 99;
<a name="l00752"></a>00752         } <span class="keywordflow">else</span> {
<a name="l00753"></a>00753                 connreq-&gt;gncr_version   = GNILND_CONNREQ_VERSION;
<a name="l00754"></a>00754         }
<a name="l00755"></a>00755         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_CONNREQ_PROTO)) {
<a name="l00756"></a>00756                 connreq-&gt;gncr_type = 99;
<a name="l00757"></a>00757         } <span class="keywordflow">else</span> {
<a name="l00758"></a>00758                 connreq-&gt;gncr_type      = type;
<a name="l00759"></a>00759         }
<a name="l00760"></a>00760         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_CONNREQ_PROTO)) {
<a name="l00761"></a>00761                 connreq-&gt;gncr_peerstamp = 0;
<a name="l00762"></a>00762         } <span class="keywordflow">else</span> {
<a name="l00763"></a>00763                 connreq-&gt;gncr_peerstamp = kgnilnd_data.kgn_peerstamp;
<a name="l00764"></a>00764         }
<a name="l00765"></a>00765         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_CONNREQ_PROTO)) {
<a name="l00766"></a>00766                 connreq-&gt;gncr_connstamp = 0;
<a name="l00767"></a>00767         } <span class="keywordflow">else</span> {
<a name="l00768"></a>00768                 connreq-&gt;gncr_connstamp = conn-&gt;gnc_my_connstamp;
<a name="l00769"></a>00769         }
<a name="l00770"></a>00770         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_CONNREQ_PROTO)) {
<a name="l00771"></a>00771                 connreq-&gt;gncr_timeout = 0;
<a name="l00772"></a>00772         } <span class="keywordflow">else</span> {
<a name="l00773"></a>00773                 connreq-&gt;gncr_timeout   = conn-&gt;gnc_timeout;
<a name="l00774"></a>00774         }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         <span class="comment">/* the rest pack the data into the payload in other places */</span>
<a name="l00777"></a>00777         <span class="keywordflow">if</span> (type == GNILND_CONNREQ_REQ) {
<a name="l00778"></a>00778                 <a class="code" href="structkgn__gniparams.html">kgn_gniparams_t</a>       *req_params = &amp;connreq-&gt;gncr_gnparams;
<a name="l00779"></a>00779                 req_params-&gt;gnpr_host_id = conn-&gt;gnc_device-&gt;gnd_host_id;
<a name="l00780"></a>00780                 req_params-&gt;gnpr_cqid = conn-&gt;gnc_cqid;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782                 <span class="comment">/* allocate mailbox for this connection */</span>
<a name="l00783"></a>00783                 err = kgnilnd_setup_mbox(conn);
<a name="l00784"></a>00784                 <span class="keywordflow">if</span> (err != 0) {
<a name="l00785"></a>00785                         CERROR(<span class="stringliteral">&quot;Failed to setup FMA mailbox (%d)\n&quot;</span>, err);
<a name="l00786"></a>00786                 }
<a name="l00787"></a>00787                 req_params-&gt;gnpr_smsg_attr = conn-&gt;gnpr_smsg_attr;
<a name="l00788"></a>00788         }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790         <span class="comment">/* XXX Nic: TBD - checksum computation */</span>
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         <span class="keywordflow">return</span> err;
<a name="l00793"></a>00793 }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795 <span class="keywordtype">int</span>
<a name="l00796"></a>00796 kgnilnd_unpack_connreq(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l00797"></a>00797 {
<a name="l00798"></a>00798         <a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>           *connreq = &amp;dgram-&gt;gndg_conn_in;
<a name="l00799"></a>00799         <span class="keywordtype">int</span>                      swab, rc = 0;
<a name="l00800"></a>00800         <a class="code" href="structkgn__net.html">kgn_net_t</a>               *net;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802         <span class="comment">/* the following fields must be handled in a backwards compatible</span>
<a name="l00803"></a>00803 <span class="comment">         * manner to ensure we can always send and interpret NAKs */</span>
<a name="l00804"></a>00804 
<a name="l00805"></a>00805         <span class="keywordflow">if</span> (connreq-&gt;gncr_magic != GNILND_MSG_MAGIC &amp;&amp;
<a name="l00806"></a>00806             connreq-&gt;gncr_magic != __swab32(GNILND_MSG_MAGIC)) {
<a name="l00807"></a>00807                 <span class="comment">/* Unexpected magic! */</span>
<a name="l00808"></a>00808                 CERROR(<span class="stringliteral">&quot;Unexpected magic %08x\n&quot;</span>,
<a name="l00809"></a>00809                        connreq-&gt;gncr_magic);
<a name="l00810"></a>00810                 <span class="keywordflow">return</span> -EBADF;
<a name="l00811"></a>00811         }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813         swab = (connreq-&gt;gncr_magic == __swab32(GNILND_MSG_MAGIC));
<a name="l00814"></a>00814         <span class="keywordflow">if</span> (swab) {
<a name="l00815"></a>00815                 __swab32s(&amp;connreq-&gt;gncr_magic);
<a name="l00816"></a>00816                 __swab32s(&amp;connreq-&gt;gncr_cksum);
<a name="l00817"></a>00817                 __swab16s(&amp;connreq-&gt;gncr_type);
<a name="l00818"></a>00818                 __swab16s(&amp;connreq-&gt;gncr_version);
<a name="l00819"></a>00819                 __swab32s(&amp;connreq-&gt;gncr_timeout);
<a name="l00820"></a>00820                 __swab64s(&amp;connreq-&gt;gncr_srcnid);
<a name="l00821"></a>00821                 __swab64s(&amp;connreq-&gt;gncr_dstnid);
<a name="l00822"></a>00822                 __swab64s(&amp;connreq-&gt;gncr_peerstamp);
<a name="l00823"></a>00823                 __swab64s(&amp;connreq-&gt;gncr_connstamp);
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826         <span class="comment">/* Do NOT return anything but -EBADF before we munge</span>
<a name="l00827"></a>00827 <span class="comment">         * connreq-&gt;gncr_srcnid - we need that to send the nak */</span>
<a name="l00828"></a>00828 
<a name="l00829"></a>00829         <span class="keywordflow">if</span> (dgram-&gt;gndg_conn_out.gncr_dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l00830"></a>00830                 <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>      incoming = connreq-&gt;gncr_srcnid;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832                 <span class="comment">/* even if the incoming packet is hosed, we know who we sent</span>
<a name="l00833"></a>00833 <span class="comment">                 * the original and can set the srcnid so that we can properly</span>
<a name="l00834"></a>00834 <span class="comment">                 * look up our peer to close the loop on this connreq. We still use</span>
<a name="l00835"></a>00835 <span class="comment">                 * -EBADF to prevent a NAK - just in case there are issues with</span>
<a name="l00836"></a>00836 <span class="comment">                 * the payload coming from a random spot, etc. */</span>
<a name="l00837"></a>00837                 connreq-&gt;gncr_srcnid = dgram-&gt;gndg_conn_out.gncr_dstnid;
<a name="l00838"></a>00838 
<a name="l00839"></a>00839                 <span class="keywordflow">if</span> (LNET_NIDADDR(dgram-&gt;gndg_conn_out.gncr_dstnid) !=
<a name="l00840"></a>00840                                 LNET_NIDADDR(incoming)) {
<a name="l00841"></a>00841                         <span class="comment">/* we got a datagram match for the wrong nid... */</span>
<a name="l00842"></a>00842                         CERROR(<span class="stringliteral">&quot;matched datagram 0x%p with srcnid %s &quot;</span>
<a name="l00843"></a>00843                                 <span class="stringliteral">&quot;(%x), expecting %s (%x)\n&quot;</span>,
<a name="l00844"></a>00844                                 dgram,
<a name="l00845"></a>00845                                 libcfs_nid2str(incoming),
<a name="l00846"></a>00846                                 LNET_NIDADDR(incoming),
<a name="l00847"></a>00847                                 libcfs_nid2str(dgram-&gt;gndg_conn_out.gncr_dstnid),
<a name="l00848"></a>00848                                 LNET_NIDADDR(dgram-&gt;gndg_conn_out.gncr_dstnid));
<a name="l00849"></a>00849                         <span class="keywordflow">return</span> -EBADF;
<a name="l00850"></a>00850                 }
<a name="l00851"></a>00851         } <span class="keywordflow">else</span> {
<a name="l00852"></a>00852                 <span class="comment">/* if we have a wildcard datagram it should match an</span>
<a name="l00853"></a>00853 <span class="comment">                 * incoming &quot;active&quot; datagram that should have a fully formed</span>
<a name="l00854"></a>00854 <span class="comment">                 * srcnid and dstnid. If we couldn&apos;t unpack it, we drop as</span>
<a name="l00855"></a>00855 <span class="comment">                 * corrupted packet, otherwise we&apos;ll just verify that the dstnid</span>
<a name="l00856"></a>00856 <span class="comment">                 * matches the NID for the NET that the dgram was posted */</span>
<a name="l00857"></a>00857 
<a name="l00858"></a>00858                 <span class="comment">/* make sure their wildcard didn&apos;t match ours, that is unpossible */</span>
<a name="l00859"></a>00859                 LASSERTF(connreq-&gt;gncr_dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>,
<a name="l00860"></a>00860                          <span class="stringliteral">&quot;dgram 0x%p from %s, connreq 0x%p; &quot;</span>
<a name="l00861"></a>00861                          <span class="stringliteral">&quot;wildcard matched wildcard \n&quot;</span>, dgram,
<a name="l00862"></a>00862                          libcfs_nid2str(connreq-&gt;gncr_srcnid), connreq);
<a name="l00863"></a>00863 
<a name="l00864"></a>00864                 rc = kgnilnd_find_net(connreq-&gt;gncr_dstnid, &amp;net);
<a name="l00865"></a>00865 
<a name="l00866"></a>00866                 <span class="keywordflow">if</span> (rc == -ESHUTDOWN) {
<a name="l00867"></a>00867                         CERROR(<span class="stringliteral">&quot;Looking up network: device is in shutdown&quot;</span>);
<a name="l00868"></a>00868                         <span class="keywordflow">return</span> rc;
<a name="l00869"></a>00869                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == -ENONET) {
<a name="l00870"></a>00870                         CERROR(<span class="stringliteral">&quot;Connection data from %s: she sent &quot;</span>
<a name="l00871"></a>00871                         <span class="stringliteral">&quot;dst_nid %s, but net lookup failed on &quot;</span>
<a name="l00872"></a>00872                         <span class="stringliteral">&quot;dgram 0x%p@%s\n&quot;</span>,
<a name="l00873"></a>00873                         libcfs_nid2str(connreq-&gt;gncr_srcnid),
<a name="l00874"></a>00874                         libcfs_nid2str(connreq-&gt;gncr_dstnid),
<a name="l00875"></a>00875                         dgram, kgnilnd_dgram_type2str(dgram));
<a name="l00876"></a>00876                         <span class="keywordflow">return</span> rc;
<a name="l00877"></a>00877                 }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879                 <span class="keywordflow">if</span> (net-&gt;gnn_ni-&gt;ni_nid != connreq-&gt;gncr_dstnid) {
<a name="l00880"></a>00880                         CERROR(<span class="stringliteral">&quot;Bad connection data from %s: she sent &quot;</span>
<a name="l00881"></a>00881                                <span class="stringliteral">&quot;dst_nid %s, but I am %s with dgram 0x%p@%s\n&quot;</span>,
<a name="l00882"></a>00882                                libcfs_nid2str(connreq-&gt;gncr_srcnid),
<a name="l00883"></a>00883                                libcfs_nid2str(connreq-&gt;gncr_dstnid),
<a name="l00884"></a>00884                                libcfs_nid2str(net-&gt;gnn_ni-&gt;ni_nid),
<a name="l00885"></a>00885                                dgram, kgnilnd_dgram_type2str(dgram));
<a name="l00886"></a>00886                         kgnilnd_net_decref(net);
<a name="l00887"></a>00887                         <span class="keywordflow">return</span> -EBADSLT;
<a name="l00888"></a>00888                 }
<a name="l00889"></a>00889 
<a name="l00890"></a>00890                 <span class="comment">/* kgnilnd_find_net takes a ref on the net it finds, You need to decref it when not needed. */</span>
<a name="l00891"></a>00891                 kgnilnd_net_decref(net);
<a name="l00892"></a>00892         }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         <span class="keywordflow">if</span> (connreq-&gt;gncr_version != GNILND_CONNREQ_VERSION) {
<a name="l00895"></a>00895                 CERROR(<span class="stringliteral">&quot;Unexpected version %d\n&quot;</span>, connreq-&gt;gncr_version);
<a name="l00896"></a>00896                 <span class="keywordflow">return</span> -EPROTO;
<a name="l00897"></a>00897         }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899         <span class="comment">/* XXX Nic: TBD - checksum validation */</span>
<a name="l00900"></a>00900         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_CONNREQ_DROP)) {
<a name="l00901"></a>00901                 <span class="keywordflow">return</span> -EBADF;
<a name="l00902"></a>00902         }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904         <span class="keywordflow">if</span> (swab &amp;&amp; connreq-&gt;gncr_type == GNILND_CONNREQ_REQ) {
<a name="l00905"></a>00905                 __u64 msg_addr = (__u64) connreq-&gt;gncr_gnparams.gnpr_smsg_attr.msg_buffer;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907                 __swab32s(&amp;connreq-&gt;gncr_gnparams.gnpr_host_id);
<a name="l00908"></a>00908                 __swab32s(&amp;connreq-&gt;gncr_gnparams.gnpr_cqid);
<a name="l00909"></a>00909                 __swab32s(&amp;connreq-&gt;gncr_gnparams.gnpr_smsg_attr.buff_size);
<a name="l00910"></a>00910                 __swab16s(&amp;connreq-&gt;gncr_gnparams.gnpr_smsg_attr.mbox_maxcredit);
<a name="l00911"></a>00911                 __swab32s(&amp;connreq-&gt;gncr_gnparams.gnpr_smsg_attr.mbox_offset);
<a name="l00912"></a>00912                 __swab64s(&amp;connreq-&gt;gncr_gnparams.gnpr_smsg_attr.mem_hndl.qword1);
<a name="l00913"></a>00913                 __swab64s(&amp;connreq-&gt;gncr_gnparams.gnpr_smsg_attr.mem_hndl.qword2);
<a name="l00914"></a>00914                 __swab64s(&amp;msg_addr);
<a name="l00915"></a>00915                 __swab32s(&amp;connreq-&gt;gncr_gnparams.gnpr_smsg_attr.msg_maxsize);
<a name="l00916"></a>00916                 __swab32s(&amp;connreq-&gt;gncr_gnparams.gnpr_smsg_attr.msg_type);
<a name="l00917"></a>00917         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (swab &amp;&amp; connreq-&gt;gncr_type == GNILND_CONNREQ_NAK) {
<a name="l00918"></a>00918                 __swab32s(&amp;connreq-&gt;gncr_nakdata.gnnd_errno);
<a name="l00919"></a>00919         }
<a name="l00920"></a>00920 
<a name="l00921"></a>00921         <span class="comment">/* since we use a unique instance ID for each network, the driver</span>
<a name="l00922"></a>00922 <span class="comment">         * will take care of dropping datagrams if we don&apos;t have that network.</span>
<a name="l00923"></a>00923 <span class="comment">         */</span>
<a name="l00924"></a>00924 
<a name="l00925"></a>00925         <span class="comment">/* few more idiot software or configuration checks */</span>
<a name="l00926"></a>00926 
<a name="l00927"></a>00927         <span class="keywordflow">switch</span> (connreq-&gt;gncr_type) {
<a name="l00928"></a>00928         <span class="keywordflow">case</span> GNILND_CONNREQ_REQ:
<a name="l00929"></a>00929                 <span class="comment">/* wire up EP and SMSG block - this will check the incoming data</span>
<a name="l00930"></a>00930 <span class="comment">                 * and barf a NAK back if need to */</span>
<a name="l00931"></a>00931                 rc = kgnilnd_set_conn_params(dgram);
<a name="l00932"></a>00932                 <span class="keywordflow">if</span> (rc)
<a name="l00933"></a>00933                         <span class="keywordflow">return</span> rc;
<a name="l00934"></a>00934                 <span class="keywordflow">break</span>;
<a name="l00935"></a>00935         <span class="keywordflow">case</span> GNILND_CONNREQ_NAK:
<a name="l00936"></a>00936         <span class="keywordflow">case</span> GNILND_CONNREQ_CLOSE:
<a name="l00937"></a>00937                 <span class="keywordflow">break</span>;
<a name="l00938"></a>00938         <span class="keywordflow">default</span>:
<a name="l00939"></a>00939                 CERROR(<span class="stringliteral">&quot;unknown connreq packet type %d\n&quot;</span>, connreq-&gt;gncr_type);
<a name="l00940"></a>00940                 <span class="keywordflow">return</span> -EPROTO;
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <span class="keywordflow">if</span> (connreq-&gt;gncr_peerstamp == 0 || connreq-&gt;gncr_connstamp == 0) {
<a name="l00944"></a>00944                 CERROR(<span class="stringliteral">&quot;Recived bad timestamps peer &quot;</span>LPU64<span class="stringliteral">&quot; conn &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00945"></a>00945                 connreq-&gt;gncr_peerstamp, connreq-&gt;gncr_connstamp);
<a name="l00946"></a>00946                 <span class="keywordflow">return</span> -EPROTO;
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         <span class="keywordflow">if</span> (connreq-&gt;gncr_timeout &lt; GNILND_MIN_TIMEOUT) {
<a name="l00950"></a>00950                 CERROR(<span class="stringliteral">&quot;Received timeout %d &lt; MIN %d\n&quot;</span>,
<a name="l00951"></a>00951                        connreq-&gt;gncr_timeout, GNILND_MIN_TIMEOUT);
<a name="l00952"></a>00952                 <span class="keywordflow">return</span> -EPROTO;
<a name="l00953"></a>00953         }
<a name="l00954"></a>00954 
<a name="l00955"></a>00955         <span class="keywordflow">return</span> 0;
<a name="l00956"></a>00956 }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="keywordtype">int</span>
<a name="l00959"></a>00959 kgnilnd_alloc_dgram(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> **dgramp, <a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, kgn_dgram_type_t type)
<a name="l00960"></a>00960 {
<a name="l00961"></a>00961         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>         *dgram;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963         dgram = kmem_cache_alloc(kgnilnd_data.kgn_dgram_cache, GFP_ATOMIC);
<a name="l00964"></a>00964         <span class="keywordflow">if</span> (dgram == NULL)
<a name="l00965"></a>00965                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00966"></a>00966 
<a name="l00967"></a>00967         <span class="comment">/* cache alloc&apos;d memory is not zeroed */</span>
<a name="l00968"></a>00968         memset((<span class="keywordtype">void</span> *)dgram, 0, <span class="keyword">sizeof</span>(*dgram)) ;
<a name="l00969"></a>00969 
<a name="l00970"></a>00970         INIT_LIST_HEAD(&amp;dgram-&gt;gndg_list);
<a name="l00971"></a>00971         dgram-&gt;gndg_state = GNILND_DGRAM_USED;
<a name="l00972"></a>00972         dgram-&gt;gndg_type = type;
<a name="l00973"></a>00973         dgram-&gt;gndg_magic = GNILND_DGRAM_MAGIC;
<a name="l00974"></a>00974 
<a name="l00975"></a>00975         atomic_inc(&amp;dev-&gt;gnd_ndgrams);
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         CDEBUG(D_MALLOC|D_NETTRACE, <span class="stringliteral">&quot;slab-alloced &apos;dgram&apos;: %lu at %p %s ndgrams&quot;</span>
<a name="l00978"></a>00978                 <span class="stringliteral">&quot; %d\n&quot;</span>,
<a name="l00979"></a>00979                 <span class="keyword">sizeof</span>(*dgram), dgram, kgnilnd_dgram_type2str(dgram),
<a name="l00980"></a>00980                 atomic_read(&amp;dev-&gt;gnd_ndgrams));
<a name="l00981"></a>00981 
<a name="l00982"></a>00982         *dgramp = dgram;
<a name="l00983"></a>00983         <span class="keywordflow">return</span> 0;
<a name="l00984"></a>00984 }
<a name="l00985"></a>00985 
<a name="l00986"></a>00986 <span class="comment">/* call this on a dgram that came back from kgnilnd_ep_postdata_test_by_id</span>
<a name="l00987"></a>00987 <span class="comment"> * returns &lt; 0 on dgram to be cleaned up</span>
<a name="l00988"></a>00988 <span class="comment"> * &gt; 0 on dgram that isn&apos;t done yet</span>
<a name="l00989"></a>00989 <span class="comment"> * == 0 on dgram that is ok and needs connreq processing */</span>
<a name="l00990"></a>00990 <span class="keywordtype">int</span>
<a name="l00991"></a>00991 kgnilnd_process_dgram(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram, gni_post_state_t post_state)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993         <span class="keywordtype">int</span> rc = 0;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995         <span class="keywordflow">switch</span> (post_state) {
<a name="l00996"></a>00996         <span class="keywordflow">case</span> GNI_POST_COMPLETED:
<a name="l00997"></a>00997                 <span class="comment">/* normal state for dgrams that need actual processing */</span>
<a name="l00998"></a>00998                 <span class="comment">/* GOTO to avoid processing dgram as canceled/done */</span>
<a name="l00999"></a>00999                 GOTO(process_out, rc);
<a name="l01000"></a>01000 
<a name="l01001"></a>01001         <span class="keywordflow">case</span> GNI_POST_PENDING:
<a name="l01002"></a>01002                 <span class="comment">/* we should only see this if we are testing a WC dgram after a</span>
<a name="l01003"></a>01003 <span class="comment">                 * cancel - it means that it needs a full cycle of waiting</span>
<a name="l01004"></a>01004 <span class="comment">                 * for kgni_sm_task to finish moving it to TERMINATED */</span>
<a name="l01005"></a>01005                 LASSERTF((dgram-&gt;gndg_type == GNILND_DGRAM_WC_REQ) &amp;&amp;
<a name="l01006"></a>01006                           (dgram-&gt;gndg_state == GNILND_DGRAM_CANCELED),
<a name="l01007"></a>01007                          <span class="stringliteral">&quot;POST_PENDING dgram 0x%p with bad type %d(%s) or state %d(%s)\n&quot;</span>,
<a name="l01008"></a>01008                          dgram, dgram-&gt;gndg_type, kgnilnd_dgram_type2str(dgram),
<a name="l01009"></a>01009                          dgram-&gt;gndg_state, kgnilnd_dgram_state2str(dgram));
<a name="l01010"></a>01010 
<a name="l01011"></a>01011                 <span class="comment">/* positive RC as this dgram isn&apos;t done yet */</span>
<a name="l01012"></a>01012                 rc = EINPROGRESS;
<a name="l01013"></a>01013 
<a name="l01014"></a>01014                 <span class="comment">/* GOTO as this isn&apos;t done yet */</span>
<a name="l01015"></a>01015                 GOTO(process_out, rc);
<a name="l01016"></a>01016                 <span class="keywordflow">break</span>;
<a name="l01017"></a>01017 
<a name="l01018"></a>01018         <span class="keywordflow">case</span> GNI_POST_TERMINATED:
<a name="l01019"></a>01019                 <span class="comment">/* we&apos;ve called cancel and it is done or remote guy called cancel and</span>
<a name="l01020"></a>01020 <span class="comment">                 * we&apos;ve receved it on a WC dgram */</span>
<a name="l01021"></a>01021 <span class="preprocessor">#if 0</span>
<a name="l01022"></a>01022 <span class="preprocessor"></span>                <span class="comment">/* we are seeing weird terminations on non WC dgrams when we have not</span>
<a name="l01023"></a>01023 <span class="comment">                 * canceled them */</span>
<a name="l01024"></a>01024 
<a name="l01025"></a>01025                 LASSERTF(dgram-&gt;gndg_state == GNILND_DGRAM_CANCELED ||
<a name="l01026"></a>01026                          dgram-&gt;gndg_conn_out.gncr_dstnid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>,
<a name="l01027"></a>01027                         <span class="stringliteral">&quot;dgram 0x%p with bad state %d(%s) or dst nid %s\n&quot;</span>,
<a name="l01028"></a>01028                         dgram, dgram-&gt;gndg_state, kgnilnd_dgram_state2str(dgram),
<a name="l01029"></a>01029                         libcfs_nid2str(dgram-&gt;gndg_conn_out.gncr_dstnid));
<a name="l01030"></a>01030 <span class="preprocessor">#endif</span>
<a name="l01031"></a>01031 <span class="preprocessor"></span>
<a name="l01032"></a>01032                 CDEBUG(D_NETTRACE, <span class="stringliteral">&quot;dgram 0x%p saw %s, cleaning it up\n&quot;</span>, dgram,
<a name="l01033"></a>01033                        dgram-&gt;gndg_state == GNILND_DGRAM_CANCELED ?  <span class="stringliteral">&quot;canceled&quot;</span> : <span class="stringliteral">&quot;terminated&quot;</span>);
<a name="l01034"></a>01034 
<a name="l01035"></a>01035                 rc =  -ECANCELED;
<a name="l01036"></a>01036                 <span class="keywordflow">break</span>;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038         <span class="keywordflow">case</span> GNI_POST_TIMEOUT:
<a name="l01039"></a>01039                 <span class="comment">/* we could have a timeout on a wildcard dgram too - if</span>
<a name="l01040"></a>01040 <span class="comment">                 * we got the incoming request but the remote node beefed</span>
<a name="l01041"></a>01041 <span class="comment">                 * before kgni could send the match data back. We&apos;ll just error</span>
<a name="l01042"></a>01042 <span class="comment">                 * on the active case and bail out gracefully */</span>
<a name="l01043"></a>01043                 <span class="keywordflow">if</span> (dgram-&gt;gndg_conn_out.gncr_dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01044"></a>01044                         CNETERR(<span class="stringliteral">&quot;hardware timeout for connect to &quot;</span>
<a name="l01045"></a>01045                                <span class="stringliteral">&quot;%s after %lu seconds. Is node dead?\n&quot;</span>,
<a name="l01046"></a>01046                                libcfs_nid2str(dgram-&gt;gndg_conn_out.gncr_dstnid),
<a name="l01047"></a>01047                                cfs_duration_sec(jiffies - dgram-&gt;gndg_post_time));
<a name="l01048"></a>01048                 }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050                 rc = -ETIMEDOUT;
<a name="l01051"></a>01051                 <span class="keywordflow">break</span>;
<a name="l01052"></a>01052 
<a name="l01053"></a>01053         <span class="keywordflow">default</span>:
<a name="l01054"></a>01054                 CERROR(<span class="stringliteral">&quot;dgram 0x%p with bad post_state %d\n&quot;</span>, dgram, post_state);
<a name="l01055"></a>01055                 LBUG();
<a name="l01056"></a>01056         }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058         <span class="comment">/* now finish cleaning up a dgram that is canceled/terminated and needs to</span>
<a name="l01059"></a>01059 <span class="comment">         * go away */</span>
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         <span class="comment">/* If this was actively canceled, drop the count now that we are processing */</span>
<a name="l01062"></a>01062         <span class="keywordflow">if</span> (dgram-&gt;gndg_state == GNILND_DGRAM_CANCELED) {
<a name="l01063"></a>01063                 atomic_dec(&amp;dgram-&gt;gndg_conn-&gt;gnc_device-&gt;gnd_canceled_dgrams);
<a name="l01064"></a>01064                 <span class="comment">/* caller responsible for gndg_list removal */</span>
<a name="l01065"></a>01065         }
<a name="l01066"></a>01066 
<a name="l01067"></a>01067 process_out:
<a name="l01068"></a>01068 
<a name="l01069"></a>01069         RETURN(rc);
<a name="l01070"></a>01070 }
<a name="l01071"></a>01071 
<a name="l01072"></a>01072 <span class="comment">/* needs dev-&gt;gnd_dgram_lock held */</span>
<a name="l01073"></a>01073 <span class="keywordtype">void</span>
<a name="l01074"></a>01074 kgnilnd_cancel_dgram_locked(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01075"></a>01075 {
<a name="l01076"></a>01076         gni_return_t            grc;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078         <span class="keywordflow">if</span> (dgram-&gt;gndg_state != GNILND_DGRAM_POSTED) {
<a name="l01079"></a>01079                 <span class="keywordflow">return</span>;
<a name="l01080"></a>01080         }
<a name="l01081"></a>01081 
<a name="l01082"></a>01082         LASSERTF(dgram-&gt;gndg_conn != NULL,
<a name="l01083"></a>01083                  <span class="stringliteral">&quot;dgram 0x%p with NULL conn\n&quot;</span>, dgram);
<a name="l01084"></a>01084 
<a name="l01085"></a>01085         <span class="comment">/* C.E - WC dgrams could be canceled immediately but</span>
<a name="l01086"></a>01086 <span class="comment">         * if there was some match pending, we need to call</span>
<a name="l01087"></a>01087 <span class="comment">         * test_by_id to clear it out. If that test returns</span>
<a name="l01088"></a>01088 <span class="comment">         * POST_PENDING, it is half done and needs to go along</span>
<a name="l01089"></a>01089 <span class="comment">         * with the rest of dgrams and go through a kgni_sm_task cycle</span>
<a name="l01090"></a>01090 <span class="comment">         * and deliver a GNI_POST_TERMINATED event before they</span>
<a name="l01091"></a>01091 <span class="comment">         * are actually canceled */</span>
<a name="l01092"></a>01092 
<a name="l01093"></a>01093         dgram-&gt;gndg_state = GNILND_DGRAM_CANCELED;
<a name="l01094"></a>01094 
<a name="l01095"></a>01095         <span class="keywordflow">if</span> (dgram-&gt;gndg_conn-&gt;gnc_state &gt;= GNILND_CONN_ESTABLISHED) {
<a name="l01096"></a>01096                 <span class="comment">/* we don&apos;t need to cancel_by_id if the datagram was good */</span>
<a name="l01097"></a>01097                 <span class="keywordflow">return</span>;
<a name="l01098"></a>01098         }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100         <span class="comment">/* let folks know there are outstanding cancels */</span>
<a name="l01101"></a>01101         atomic_inc(&amp;dgram-&gt;gndg_conn-&gt;gnc_device-&gt;gnd_canceled_dgrams);
<a name="l01102"></a>01102         <span class="comment">/* leave on nid list until cancel is done for debugging fun */</span>
<a name="l01103"></a>01103         grc = kgnilnd_ep_postdata_cancel_by_id(dgram-&gt;gndg_conn-&gt;gnc_ephandle, (__u64) dgram);
<a name="l01104"></a>01104 
<a name="l01105"></a>01105         <span class="comment">/* if we don&apos;t get success here, we have hosed up the dgram tracking</span>
<a name="l01106"></a>01106 <span class="comment">         * code and need to bail out */</span>
<a name="l01107"></a>01107         LASSERTF(grc == GNI_RC_SUCCESS,
<a name="l01108"></a>01108                  <span class="stringliteral">&quot;postdata_cancel returned %d for conn 0x%p to %s\n&quot;</span>,
<a name="l01109"></a>01109                  grc, dgram-&gt;gndg_conn,
<a name="l01110"></a>01110                  dgram-&gt;gndg_conn-&gt;gnc_peer ?
<a name="l01111"></a>01111                   libcfs_nid2str(dgram-&gt;gndg_conn-&gt;gnc_peer-&gt;gnp_nid)
<a name="l01112"></a>01112                   : <span class="stringliteral">&quot;&lt;?&gt;&quot;</span>);
<a name="l01113"></a>01113 
<a name="l01114"></a>01114         CDEBUG(D_NETTRACE,
<a name="l01115"></a>01115                 <span class="stringliteral">&quot;canceled dgram 0x%p conn 0x%p ephandle 0x%p\n&quot;</span>,
<a name="l01116"></a>01116                 dgram, dgram-&gt;gndg_conn,
<a name="l01117"></a>01117                 dgram-&gt;gndg_conn-&gt;gnc_ephandle);
<a name="l01118"></a>01118 
<a name="l01119"></a>01119         <span class="keywordflow">if</span> (dgram-&gt;gndg_type == GNILND_DGRAM_WC_REQ) {
<a name="l01120"></a>01120                 gni_post_state_t         post_state;
<a name="l01121"></a>01121                 <span class="keywordtype">int</span>                      rc = 0;
<a name="l01122"></a>01122                 __u32                    remote_addr = 0, remote_id = 0;
<a name="l01123"></a>01123 
<a name="l01124"></a>01124                 grc = kgnilnd_ep_postdata_test_by_id(dgram-&gt;gndg_conn-&gt;gnc_ephandle,
<a name="l01125"></a>01125                                                      (__u64)dgram, &amp;post_state,
<a name="l01126"></a>01126                                                      &amp;remote_addr, &amp;remote_id);
<a name="l01127"></a>01127 
<a name="l01128"></a>01128                 LASSERTF(grc == GNI_RC_NO_MATCH || grc == GNI_RC_SUCCESS,
<a name="l01129"></a>01129                          <span class="stringliteral">&quot;bad grc %d from test_by_id on dgram 0x%p\n&quot;</span>,
<a name="l01130"></a>01130                         grc, dgram);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132                 <span class="comment">/* if WC was canceled immediately, we get NO_MATCH, if needs to go</span>
<a name="l01133"></a>01133 <span class="comment">                 * through full cycle, we get SUCCESS and need to parse post_state */</span>
<a name="l01134"></a>01134 
<a name="l01135"></a>01135                 CDEBUG(D_NET, <span class="stringliteral">&quot;grc %d dgram 0x%p type %s post_state %d &quot;</span>
<a name="l01136"></a>01136                         <span class="stringliteral">&quot;remote_addr %u remote_id %u\n&quot;</span>, grc, dgram,
<a name="l01137"></a>01137                         kgnilnd_dgram_type2str(dgram),
<a name="l01138"></a>01138                         post_state, remote_addr, remote_id);
<a name="l01139"></a>01139 
<a name="l01140"></a>01140                 <span class="keywordflow">if</span> (grc == GNI_RC_NO_MATCH) {
<a name="l01141"></a>01141                         <span class="comment">/* she&apos;s gone, reduce count and move along */</span>
<a name="l01142"></a>01142                         dgram-&gt;gndg_state = GNILND_DGRAM_DONE;
<a name="l01143"></a>01143                         atomic_dec(&amp;dgram-&gt;gndg_conn-&gt;gnc_device-&gt;gnd_canceled_dgrams);
<a name="l01144"></a>01144                         RETURN_EXIT;
<a name="l01145"></a>01145                 }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147                 rc = kgnilnd_process_dgram(dgram, post_state);
<a name="l01148"></a>01148 
<a name="l01149"></a>01149                 <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l01150"></a>01150                         <span class="comment">/* if for some weird reason we get a valid dgram back, just mark as done</span>
<a name="l01151"></a>01151 <span class="comment">                         * so we can drop it and move along.</span>
<a name="l01152"></a>01152 <span class="comment">                         * C.E - if it was completed, we&apos;ll just release the conn/mbox</span>
<a name="l01153"></a>01153 <span class="comment">                         * back into the pool and it&apos;ll get reused. That said, we should only</span>
<a name="l01154"></a>01154 <span class="comment">                         * be canceling a WC dgram on stack rest or shutdown, so that is moot */</span>
<a name="l01155"></a>01155                         dgram-&gt;gndg_state = GNILND_DGRAM_DONE;
<a name="l01156"></a>01156                         atomic_dec(&amp;dgram-&gt;gndg_conn-&gt;gnc_device-&gt;gnd_canceled_dgrams);
<a name="l01157"></a>01157 
<a name="l01158"></a>01158                         <span class="comment">/* caller context responsible for calling kgnilnd_release_dgram() */</span>
<a name="l01159"></a>01159                 } <span class="keywordflow">else</span> {
<a name="l01160"></a>01160                         <span class="comment">/* still pending, let it simmer until golden brown and delicious */</span>
<a name="l01161"></a>01161                 }
<a name="l01162"></a>01162         }
<a name="l01163"></a>01163 
<a name="l01164"></a>01164         <span class="comment">/* for non WC dgrams, they are still on the nid list but marked canceled waiting</span>
<a name="l01165"></a>01165 <span class="comment">         * for kgni to return their ID to us via probe - that is when we&apos;ll complete their</span>
<a name="l01166"></a>01166 <span class="comment">         * cancel processing */</span>
<a name="l01167"></a>01167 }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169 <span class="keywordtype">void</span>
<a name="l01170"></a>01170 kgnilnd_cleanup_dgram(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01171"></a>01171 {
<a name="l01172"></a>01172         <span class="comment">/* release the dgram ref on conn */</span>
<a name="l01173"></a>01173         <span class="keywordflow">if</span> (dgram-&gt;gndg_conn) {
<a name="l01174"></a>01174                 kgnilnd_conn_decref(dgram-&gt;gndg_conn);
<a name="l01175"></a>01175                 dgram-&gt;gndg_conn = NULL;
<a name="l01176"></a>01176         }
<a name="l01177"></a>01177 }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179 <span class="keywordtype">void</span>
<a name="l01180"></a>01180 kgnilnd_free_dgram(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01181"></a>01181 {
<a name="l01182"></a>01182         LASSERTF(dgram-&gt;gndg_state == GNILND_DGRAM_USED ||
<a name="l01183"></a>01183                  dgram-&gt;gndg_state == GNILND_DGRAM_DONE,
<a name="l01184"></a>01184                  <span class="stringliteral">&quot;dgram 0x%p with bad state %s\n&quot;</span>,
<a name="l01185"></a>01185                  dgram, kgnilnd_dgram_state2str(dgram));
<a name="l01186"></a>01186 
<a name="l01187"></a>01187         <span class="comment">/* bit of poisoning to help detect bad driver data */</span>
<a name="l01188"></a>01188         dgram-&gt;gndg_magic = 0x6f5a6b5f;
<a name="l01189"></a>01189         atomic_dec(&amp;dev-&gt;gnd_ndgrams);
<a name="l01190"></a>01190 
<a name="l01191"></a>01191         kmem_cache_free(kgnilnd_data.kgn_dgram_cache, dgram);
<a name="l01192"></a>01192         CDEBUG(D_MALLOC|D_NETTRACE, <span class="stringliteral">&quot;slab-freed &apos;dgram&apos;: %lu at %p %s&quot;</span>
<a name="l01193"></a>01193                <span class="stringliteral">&quot; ndgrams %d\n&quot;</span>,
<a name="l01194"></a>01194                <span class="keyword">sizeof</span>(*dgram), dgram, kgnilnd_dgram_type2str(dgram),
<a name="l01195"></a>01195                atomic_read(&amp;dev-&gt;gnd_ndgrams));
<a name="l01196"></a>01196 }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198 <span class="keywordtype">int</span>
<a name="l01199"></a>01199 kgnilnd_post_dgram(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dstnid, kgn_connreq_type_t type,
<a name="l01200"></a>01200                    <span class="keywordtype">int</span> data_rc)
<a name="l01201"></a>01201 {
<a name="l01202"></a>01202         <span class="keywordtype">int</span>              rc = 0;
<a name="l01203"></a>01203         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>     *dgram = NULL;
<a name="l01204"></a>01204         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>     *tmpdgram;
<a name="l01205"></a>01205         kgn_dgram_type_t dgtype;
<a name="l01206"></a>01206         gni_return_t     grc;
<a name="l01207"></a>01207         __u64            srcnid;
<a name="l01208"></a>01208         ENTRY;
<a name="l01209"></a>01209 
<a name="l01210"></a>01210         <span class="keywordflow">switch</span> (type) {
<a name="l01211"></a>01211         <span class="keywordflow">case</span> GNILND_CONNREQ_REQ:
<a name="l01212"></a>01212                 <span class="keywordflow">if</span> (dstnid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>)
<a name="l01213"></a>01213                         dgtype = GNILND_DGRAM_WC_REQ;
<a name="l01214"></a>01214                 <span class="keywordflow">else</span>
<a name="l01215"></a>01215                         dgtype = GNILND_DGRAM_REQ;
<a name="l01216"></a>01216                 <span class="keywordflow">break</span>;
<a name="l01217"></a>01217         <span class="keywordflow">case</span> GNILND_CONNREQ_NAK:
<a name="l01218"></a>01218                 LASSERTF(dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, <span class="stringliteral">&quot;can&apos;t NAK to LNET_NID_ANY\n&quot;</span>);
<a name="l01219"></a>01219                 dgtype = GNILND_DGRAM_NAK;
<a name="l01220"></a>01220                 <span class="keywordflow">break</span>;
<a name="l01221"></a>01221         <span class="keywordflow">default</span>:
<a name="l01222"></a>01222                 CERROR(<span class="stringliteral">&quot;unknown connreq type %d\n&quot;</span>, type);
<a name="l01223"></a>01223                 LBUG();
<a name="l01224"></a>01224         }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226         rc = kgnilnd_alloc_dgram(&amp;dgram, dev, dgtype);
<a name="l01227"></a>01227         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01228"></a>01228                 rc = -ENOMEM;
<a name="l01229"></a>01229                 GOTO(post_failed, rc);
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         rc = kgnilnd_create_conn(&amp;dgram-&gt;gndg_conn, dev);
<a name="l01233"></a>01233         <span class="keywordflow">if</span> (rc) {
<a name="l01234"></a>01234                 GOTO(post_failed, rc);
<a name="l01235"></a>01235         }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237         <span class="keywordflow">if</span> (dgram-&gt;gndg_type == GNILND_DGRAM_WC_REQ) {
<a name="l01238"></a>01238                 <span class="comment">/* clear buffer for sanity on reuse of wildcard */</span>
<a name="l01239"></a>01239                 memset(&amp;dgram-&gt;gndg_conn_in, 0, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>));
<a name="l01240"></a>01240         }
<a name="l01241"></a>01241 
<a name="l01242"></a>01242         <span class="keywordflow">if</span> (dstnid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01243"></a>01243                 <span class="comment">/* set here to reset any dgram re-use */</span>
<a name="l01244"></a>01244                 dgram-&gt;gndg_conn-&gt;gnc_state = GNILND_CONN_LISTEN;
<a name="l01245"></a>01245         } <span class="keywordflow">else</span> {
<a name="l01246"></a>01246                 __u32            host_id;
<a name="l01247"></a>01247 
<a name="l01248"></a>01248                 rc = kgnilnd_nid_to_nicaddrs(LNET_NIDADDR(dstnid), 1, &amp;host_id);
<a name="l01249"></a>01249                 <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l01250"></a>01250                         rc = -ESRCH;
<a name="l01251"></a>01251                         GOTO(post_failed, rc);
<a name="l01252"></a>01252                 }
<a name="l01253"></a>01253 
<a name="l01254"></a>01254                 dgram-&gt;gndg_conn-&gt;gnc_state = GNILND_CONN_CONNECTING;
<a name="l01255"></a>01255 
<a name="l01256"></a>01256                 <span class="comment">/* don&apos;t need to serialize, there are no CQs for the dgram</span>
<a name="l01257"></a>01257 <span class="comment">                 * EP on the kgn_net_t */</span>
<a name="l01258"></a>01258                 grc = kgnilnd_ep_bind(dgram-&gt;gndg_conn-&gt;gnc_ephandle, host_id, dev-&gt;gnd_id);
<a name="l01259"></a>01259 
<a name="l01260"></a>01260                 <span class="keywordflow">if</span> (grc != GNI_RC_SUCCESS) {
<a name="l01261"></a>01261                         rc = -ECONNABORTED;
<a name="l01262"></a>01262                         GOTO(post_failed, rc);
<a name="l01263"></a>01263                 }
<a name="l01264"></a>01264 
<a name="l01265"></a>01265         }
<a name="l01266"></a>01266 
<a name="l01267"></a>01267         <span class="comment">/* If we are posting wildcards post using a net of 0, otherwise we&apos;ll use the</span>
<a name="l01268"></a>01268 <span class="comment">         * net of the destination node.</span>
<a name="l01269"></a>01269 <span class="comment">         */</span>
<a name="l01270"></a>01270 
<a name="l01271"></a>01271         <span class="keywordflow">if</span> (dstnid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01272"></a>01272                 srcnid = LNET_MKNID(LNET_MKNET(GNILND, 0), dev-&gt;gnd_nid);
<a name="l01273"></a>01273         } <span class="keywordflow">else</span> {
<a name="l01274"></a>01274                 srcnid = LNET_MKNID(LNET_NIDNET(dstnid), dev-&gt;gnd_nid);
<a name="l01275"></a>01275         }
<a name="l01276"></a>01276 
<a name="l01277"></a>01277         rc = kgnilnd_pack_connreq(&amp;dgram-&gt;gndg_conn_out, dgram-&gt;gndg_conn,
<a name="l01278"></a>01278                                   srcnid, dstnid, type);
<a name="l01279"></a>01279         <span class="keywordflow">if</span> (rc) {
<a name="l01280"></a>01280                 GOTO(post_failed, rc);
<a name="l01281"></a>01281         }
<a name="l01282"></a>01282 
<a name="l01283"></a>01283         <span class="keywordflow">if</span> (type == GNILND_CONNREQ_NAK)
<a name="l01284"></a>01284                 dgram-&gt;gndg_conn_out.gncr_nakdata.gnnd_errno = data_rc;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286         dgram-&gt;gndg_post_time = jiffies;
<a name="l01287"></a>01287 
<a name="l01288"></a>01288         <span class="comment">/* XXX Nic: here is where we&apos;d add in logical network multiplexing */</span>
<a name="l01289"></a>01289 
<a name="l01290"></a>01290         CDEBUG(D_NETTRACE, <span class="stringliteral">&quot;dgram 0x%p type %s %s-&gt;%s cdm %d\n&quot;</span>,
<a name="l01291"></a>01291                dgram, kgnilnd_dgram_type2str(dgram),
<a name="l01292"></a>01292                libcfs_nid2str(srcnid),
<a name="l01293"></a>01293                libcfs_nid2str(dstnid), dev-&gt;gnd_id);
<a name="l01294"></a>01294 
<a name="l01295"></a>01295         <span class="comment">/* this allocates memory, can&apos;t hold locks across */</span>
<a name="l01296"></a>01296         grc = kgnilnd_ep_postdata_w_id(dgram-&gt;gndg_conn-&gt;gnc_ephandle,
<a name="l01297"></a>01297                                    &amp;dgram-&gt;gndg_conn_out, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>),
<a name="l01298"></a>01298                                    &amp;dgram-&gt;gndg_conn_in, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>),
<a name="l01299"></a>01299                                    (__u64)dgram);
<a name="l01300"></a>01300 
<a name="l01301"></a>01301         <span class="keywordflow">if</span> (grc != GNI_RC_SUCCESS) {
<a name="l01302"></a>01302                 CNETERR(<span class="stringliteral">&quot;dropping failed dgram post id 0x%p type %s&quot;</span>
<a name="l01303"></a>01303                         <span class="stringliteral">&quot; reqtype %s to %s: rc %d\n&quot;</span>,
<a name="l01304"></a>01304                         dgram, kgnilnd_dgram_type2str(dgram),
<a name="l01305"></a>01305                         kgnilnd_connreq_type2str(&amp;dgram-&gt;gndg_conn_out),
<a name="l01306"></a>01306                         libcfs_nid2str(dstnid), grc);
<a name="l01307"></a>01307                 rc = (grc == GNI_RC_ERROR_NOMEM) ? -ENOMEM : -EBADR;
<a name="l01308"></a>01308                 GOTO(post_failed, rc);
<a name="l01309"></a>01309         }
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         <span class="comment">/* we don&apos;t need to add earlier - if someone does del_peer during post,</span>
<a name="l01312"></a>01312 <span class="comment">         * that peer will get marked as unlinked and the callers wil take care of it.</span>
<a name="l01313"></a>01313 <span class="comment">         * The dgram code is largely kgn_peer_t ignorant, so at worst, we&apos;ll just drop</span>
<a name="l01314"></a>01314 <span class="comment">         * the completed dgram later when we cant find a peer to stuff it into */</span>
<a name="l01315"></a>01315 
<a name="l01316"></a>01316         spin_lock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01317"></a>01317 
<a name="l01318"></a>01318         <span class="comment">/* make sure we are not double posting targeted dgrams</span>
<a name="l01319"></a>01319 <span class="comment">         * - we can multiple post WC dgrams to help with processing speed */</span>
<a name="l01320"></a>01320         <span class="keywordflow">if</span> (dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01321"></a>01321                 tmpdgram = kgnilnd_find_dgram_locked(dev, dstnid);
<a name="l01322"></a>01322 
<a name="l01323"></a>01323                 LASSERTF(tmpdgram == NULL,
<a name="l01324"></a>01324                         <span class="stringliteral">&quot;dgram 0x%p-&gt;%s already posted\n&quot;</span>,
<a name="l01325"></a>01325                          dgram, libcfs_nid2str(dstnid));
<a name="l01326"></a>01326         }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328         <span class="comment">/* unmunge dstnid to help processing code cope... */</span>
<a name="l01329"></a>01329         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_PACK_DSTNID)) {
<a name="l01330"></a>01330                 dgram-&gt;gndg_conn_out.gncr_dstnid = dstnid;
<a name="l01331"></a>01331         }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333         list_add_tail(&amp;dgram-&gt;gndg_list, kgnilnd_nid2dgramlist(dev, dstnid));
<a name="l01334"></a>01334         dgram-&gt;gndg_state = GNILND_DGRAM_POSTED;
<a name="l01335"></a>01335         spin_unlock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337 post_failed:
<a name="l01338"></a>01338         <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; dgram != NULL) {
<a name="l01339"></a>01339                 kgnilnd_cleanup_dgram(dgram);
<a name="l01340"></a>01340                 kgnilnd_free_dgram(dev, dgram);
<a name="l01341"></a>01341         }
<a name="l01342"></a>01342 
<a name="l01343"></a>01343         RETURN(rc);
<a name="l01344"></a>01344 }
<a name="l01345"></a>01345 
<a name="l01346"></a>01346 <span class="comment">/* The shutdown flag is set from the shutdown and stack reset threads. */</span>
<a name="l01347"></a>01347 <span class="keywordtype">void</span>
<a name="l01348"></a>01348 kgnilnd_release_dgram(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram, <span class="keywordtype">int</span> shutdown)
<a name="l01349"></a>01349 {
<a name="l01350"></a>01350         <span class="comment">/* The conns of canceled active dgrams need to be put in purgatory so</span>
<a name="l01351"></a>01351 <span class="comment">         * we don&apos;t reuse the mailbox */</span>
<a name="l01352"></a>01352         <span class="keywordflow">if</span> (unlikely(dgram-&gt;gndg_state == GNILND_DGRAM_CANCELED)) {
<a name="l01353"></a>01353                 <a class="code" href="structkgn__peer.html">kgn_peer_t</a> *peer;
<a name="l01354"></a>01354                 <a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn = dgram-&gt;gndg_conn;
<a name="l01355"></a>01355                 <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid = dgram-&gt;gndg_conn_out.gncr_dstnid;
<a name="l01356"></a>01356 
<a name="l01357"></a>01357                 dgram-&gt;gndg_state = GNILND_DGRAM_DONE;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359                 <span class="comment">/* During shutdown we&apos;ve already removed the peer so we don&apos;t</span>
<a name="l01360"></a>01360 <span class="comment">                 * need to add a peer. During stack reset we don&apos;t care about</span>
<a name="l01361"></a>01361 <span class="comment">                 * MDDs since they are all released. */</span>
<a name="l01362"></a>01362                 <span class="keywordflow">if</span> (!shutdown) {
<a name="l01363"></a>01363                         write_lock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01364"></a>01364                         peer = kgnilnd_find_peer_locked(nid);
<a name="l01365"></a>01365 
<a name="l01366"></a>01366                         <span class="keywordflow">if</span> (peer != NULL) {
<a name="l01367"></a>01367                                 CDEBUG(D_NET, <span class="stringliteral">&quot;adding peer&apos;s conn with nid %s &quot;</span>
<a name="l01368"></a>01368                                         <span class="stringliteral">&quot;to purgatory\n&quot;</span>, libcfs_nid2str(nid));
<a name="l01369"></a>01369                                 kgnilnd_conn_addref(conn);
<a name="l01370"></a>01370                                 conn-&gt;gnc_peer = peer;
<a name="l01371"></a>01371                                 kgnilnd_peer_addref(peer);
<a name="l01372"></a>01372                                 kgnilnd_admin_addref(conn-&gt;gnc_peer-&gt;gnp_dirty_eps);
<a name="l01373"></a>01373                                 conn-&gt;gnc_state = GNILND_CONN_CLOSED;
<a name="l01374"></a>01374                                 list_add_tail(&amp;conn-&gt;gnc_list,
<a name="l01375"></a>01375                                               &amp;peer-&gt;gnp_conns);
<a name="l01376"></a>01376                                 kgnilnd_add_purgatory_locked(conn,
<a name="l01377"></a>01377                                                              conn-&gt;gnc_peer);
<a name="l01378"></a>01378                                 kgnilnd_schedule_conn(conn);
<a name="l01379"></a>01379                         }
<a name="l01380"></a>01380                         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01381"></a>01381                 }
<a name="l01382"></a>01382         }
<a name="l01383"></a>01383 
<a name="l01384"></a>01384         spin_lock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01385"></a>01385         kgnilnd_cancel_dgram_locked(dgram);
<a name="l01386"></a>01386         spin_unlock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01387"></a>01387 
<a name="l01388"></a>01388         kgnilnd_cleanup_dgram(dgram);
<a name="l01389"></a>01389 
<a name="l01390"></a>01390         <span class="comment">/* if the dgram is &apos;canceled&apos; it needs to be wait until the event</span>
<a name="l01391"></a>01391 <span class="comment">         * comes up from kgni that tells us it is safe to release */</span>
<a name="l01392"></a>01392         <span class="keywordflow">if</span> (dgram-&gt;gndg_state != GNILND_DGRAM_CANCELED) {
<a name="l01393"></a>01393                 dgram-&gt;gndg_state = GNILND_DGRAM_DONE;
<a name="l01394"></a>01394 
<a name="l01395"></a>01395                 LASSERTF(list_empty(&amp;dgram-&gt;gndg_list), <span class="stringliteral">&quot;dgram 0x%p on list\n&quot;</span>, dgram);
<a name="l01396"></a>01396 
<a name="l01397"></a>01397                 <span class="comment">/* if it is a wildcard and we are in an appropriate state, repost</span>
<a name="l01398"></a>01398 <span class="comment">                 * the wildcard */</span>
<a name="l01399"></a>01399 
<a name="l01400"></a>01400                 <span class="keywordflow">if</span> ((dgram-&gt;gndg_type == GNILND_DGRAM_WC_REQ) &amp;&amp;
<a name="l01401"></a>01401                     (!kgnilnd_data.kgn_wc_kill &amp;&amp; !kgnilnd_data.kgn_in_reset)) {
<a name="l01402"></a>01402                         <span class="keywordtype">int</span>     rerc;
<a name="l01403"></a>01403 
<a name="l01404"></a>01404                         rerc = kgnilnd_post_dgram(dev, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, GNILND_CONNREQ_REQ, 0);
<a name="l01405"></a>01405                         <span class="keywordflow">if</span> (rerc != 0) {
<a name="l01406"></a>01406                                 <span class="comment">/* We failed to repost the WC dgram for some reason</span>
<a name="l01407"></a>01407 <span class="comment">                                 * mark it so the repost system attempts to repost */</span>
<a name="l01408"></a>01408                                 kgnilnd_admin_addref(dev-&gt;gnd_nwcdgrams);
<a name="l01409"></a>01409                         }
<a name="l01410"></a>01410                 }
<a name="l01411"></a>01411 
<a name="l01412"></a>01412                 <span class="comment">/* always free the old dgram */</span>
<a name="l01413"></a>01413                 kgnilnd_free_dgram(dev, dgram);
<a name="l01414"></a>01414         }
<a name="l01415"></a>01415 }
<a name="l01416"></a>01416 
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 <span class="keywordtype">int</span>
<a name="l01419"></a>01419 kgnilnd_probe_for_dgram(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> **dgramp)
<a name="l01420"></a>01420 {
<a name="l01421"></a>01421         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>             *dgram = NULL;
<a name="l01422"></a>01422         gni_post_state_t         post_state;
<a name="l01423"></a>01423         gni_return_t             grc;
<a name="l01424"></a>01424         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01425"></a>01425         __u64                    readyid;
<a name="l01426"></a>01426         __u32                    remote_addr = 0, remote_id = 0;
<a name="l01427"></a>01427         ENTRY;
<a name="l01428"></a>01428 
<a name="l01429"></a>01429         <span class="comment">/* Probe with the lock held. That way if we get a dgram we dont have it canceled</span>
<a name="l01430"></a>01430 <span class="comment">         * between finding the ready dgram and grabbing the lock to remove it from the</span>
<a name="l01431"></a>01431 <span class="comment">         * list. Otherwise we could be left in an inconsistent state. We own the dgram</span>
<a name="l01432"></a>01432 <span class="comment">         * once its off the list so we don&apos;t need to worry about others changing it at</span>
<a name="l01433"></a>01433 <span class="comment">         * that point. */</span>
<a name="l01434"></a>01434         spin_lock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01435"></a>01435         grc = kgnilnd_postdata_probe_by_id(dev-&gt;gnd_handle, &amp;readyid);
<a name="l01436"></a>01436         <span class="keywordflow">if</span> (grc != GNI_RC_SUCCESS) {
<a name="l01437"></a>01437                 spin_unlock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01438"></a>01438                 <span class="comment">/* return 0 to indicate nothing happened */</span>
<a name="l01439"></a>01439                 RETURN(0);
<a name="l01440"></a>01440         }
<a name="l01441"></a>01441 
<a name="l01442"></a>01442         CDEBUG(D_NET, <span class="stringliteral">&quot;ready &quot;</span>LPX64<span class="stringliteral">&quot; on device 0x%p\n&quot;</span>,
<a name="l01443"></a>01443                 readyid, dev);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445         dgram = (<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *)readyid;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447         LASSERTF(dgram-&gt;gndg_magic == GNILND_DGRAM_MAGIC,
<a name="l01448"></a>01448                  <span class="stringliteral">&quot;dgram 0x%p from id &quot;</span>LPX64<span class="stringliteral">&quot; with bad magic %x\n&quot;</span>,
<a name="l01449"></a>01449                  dgram, readyid, dgram-&gt;gndg_magic);
<a name="l01450"></a>01450 
<a name="l01451"></a>01451         LASSERTF(dgram-&gt;gndg_state == GNILND_DGRAM_POSTED ||
<a name="l01452"></a>01452                  dgram-&gt;gndg_state == GNILND_DGRAM_CANCELED,
<a name="l01453"></a>01453                  <span class="stringliteral">&quot;dgram 0x%p with bad state %s\n&quot;</span>,
<a name="l01454"></a>01454                  dgram, kgnilnd_dgram_state2str(dgram));
<a name="l01455"></a>01455 
<a name="l01456"></a>01456         LASSERTF(!list_empty(&amp;dgram-&gt;gndg_list),
<a name="l01457"></a>01457                  <span class="stringliteral">&quot;dgram 0x%p with bad list state %s type %s\n&quot;</span>,
<a name="l01458"></a>01458                  dgram, kgnilnd_dgram_state2str(dgram),
<a name="l01459"></a>01459                  kgnilnd_dgram_type2str(dgram));
<a name="l01460"></a>01460 
<a name="l01461"></a>01461         <span class="comment">/* now we know that the datagram structure is ok, so pull off list */</span>
<a name="l01462"></a>01462         list_del_init(&amp;dgram-&gt;gndg_list);
<a name="l01463"></a>01463 
<a name="l01464"></a>01464         <span class="comment">/* while we have the gnn_dgram_lock and BEFORE we call test_by_id</span>
<a name="l01465"></a>01465 <span class="comment">         * change the state from POSTED to PROCESSING to ensure that</span>
<a name="l01466"></a>01466 <span class="comment">         * nobody cancels it after we&apos;ve pulled it from the wire */</span>
<a name="l01467"></a>01467         <span class="keywordflow">if</span> (dgram-&gt;gndg_state == GNILND_DGRAM_POSTED) {
<a name="l01468"></a>01468                 dgram-&gt;gndg_state = GNILND_DGRAM_PROCESSING;
<a name="l01469"></a>01469         }
<a name="l01470"></a>01470 
<a name="l01471"></a>01471         LASSERTF(dgram-&gt;gndg_conn != NULL,
<a name="l01472"></a>01472                 <span class="stringliteral">&quot;dgram 0x%p with NULL conn\n&quot;</span>, dgram);
<a name="l01473"></a>01473 
<a name="l01474"></a>01474         grc = kgnilnd_ep_postdata_test_by_id(dgram-&gt;gndg_conn-&gt;gnc_ephandle,
<a name="l01475"></a>01475                                              (__u64)dgram, &amp;post_state,
<a name="l01476"></a>01476                                              &amp;remote_addr, &amp;remote_id);
<a name="l01477"></a>01477 
<a name="l01478"></a>01478         <span class="comment">/* we now &quot;own&quot; this datagram */</span>
<a name="l01479"></a>01479         spin_unlock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01480"></a>01480 
<a name="l01481"></a>01481         LASSERTF(grc != GNI_RC_NO_MATCH, <span class="stringliteral">&quot;kgni lied! probe_by_id told us that&quot;</span>
<a name="l01482"></a>01482                  <span class="stringliteral">&quot; id &quot;</span>LPU64<span class="stringliteral">&quot; was ready\n&quot;</span>, readyid);
<a name="l01483"></a>01483 
<a name="l01484"></a>01484         CDEBUG(D_NET, <span class="stringliteral">&quot;grc %d dgram 0x%p type %s post_state %d &quot;</span>
<a name="l01485"></a>01485                 <span class="stringliteral">&quot;remote_addr %u remote_id %u\n&quot;</span>, grc, dgram,
<a name="l01486"></a>01486                 kgnilnd_dgram_type2str(dgram),
<a name="l01487"></a>01487                 post_state, remote_addr, remote_id);
<a name="l01488"></a>01488 
<a name="l01489"></a>01489         <span class="keywordflow">if</span> (unlikely(grc != GNI_RC_SUCCESS)) {
<a name="l01490"></a>01490                 CNETERR(<span class="stringliteral">&quot;getting data for dgram 0x%p-&gt;%s failed rc %d. Dropping it\n&quot;</span>,
<a name="l01491"></a>01491                         dgram, libcfs_nid2str(dgram-&gt;gndg_conn_out.gncr_dstnid),
<a name="l01492"></a>01492                         grc);
<a name="l01493"></a>01493                 rc = -EINVAL;
<a name="l01494"></a>01494                 GOTO(probe_for_out, rc);
<a name="l01495"></a>01495         }
<a name="l01496"></a>01496 
<a name="l01497"></a>01497         rc = kgnilnd_process_dgram(dgram, post_state);
<a name="l01498"></a>01498 
<a name="l01499"></a>01499         <span class="comment">/* we should never get probe finding a dgram for us and then it</span>
<a name="l01500"></a>01500 <span class="comment">         * being a WC dgram that is still in the middle of processing */</span>
<a name="l01501"></a>01501         LASSERTF(rc &lt;= 0, <span class="stringliteral">&quot;bad rc %d from process_dgram 0x%p state %d\n&quot;</span>,
<a name="l01502"></a>01502                  rc, dgram, post_state);
<a name="l01503"></a>01503 
<a name="l01504"></a>01504         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01505"></a>01505                 <span class="comment">/* dgram is good enough for the data to be used */</span>
<a name="l01506"></a>01506                 dgram-&gt;gndg_state = GNILND_DGRAM_PROCESSING;
<a name="l01507"></a>01507                 <span class="comment">/* fake rc to mark that we&apos;ve done something */</span>
<a name="l01508"></a>01508                 rc = 1;
<a name="l01509"></a>01509         } <span class="keywordflow">else</span> {
<a name="l01510"></a>01510                 <span class="comment">/* let kgnilnd_release_dgram take care of canceled dgrams */</span>
<a name="l01511"></a>01511                 <span class="keywordflow">if</span> (dgram-&gt;gndg_state != GNILND_DGRAM_CANCELED) {
<a name="l01512"></a>01512                         dgram-&gt;gndg_state = GNILND_DGRAM_DONE;
<a name="l01513"></a>01513                 }
<a name="l01514"></a>01514         }
<a name="l01515"></a>01515 
<a name="l01516"></a>01516         *dgramp = dgram;
<a name="l01517"></a>01517         RETURN(rc);
<a name="l01518"></a>01518 
<a name="l01519"></a>01519 probe_for_out:
<a name="l01520"></a>01520 
<a name="l01521"></a>01521         kgnilnd_release_dgram(dev, dgram, 0);
<a name="l01522"></a>01522         RETURN(rc);
<a name="l01523"></a>01523 }
<a name="l01524"></a>01524 
<a name="l01525"></a>01525 <span class="keywordtype">int</span>
<a name="l01526"></a>01526 kgnilnd_setup_wildcard_dgram(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l01527"></a>01527 {
<a name="l01528"></a>01528         <span class="comment">/* if kgn_wildcard is zero, return error */</span>
<a name="l01529"></a>01529         <span class="keywordtype">int</span>     rc = -ENOENT, i;
<a name="l01530"></a>01530         ENTRY;
<a name="l01531"></a>01531 
<a name="l01532"></a>01532         <span class="keywordflow">for</span> (i = 0; i &lt; *kgnilnd_tunables.kgn_nwildcard; i++) {
<a name="l01533"></a>01533                 rc = kgnilnd_post_dgram(dev, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, GNILND_CONNREQ_REQ, 0);
<a name="l01534"></a>01534                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01535"></a>01535                         CERROR(<span class="stringliteral">&quot;error %d: could not post wildcard datagram # %d\n&quot;</span>,
<a name="l01536"></a>01536                                 rc, i);
<a name="l01537"></a>01537                         rc = -EINVAL;
<a name="l01538"></a>01538                         GOTO(failed, rc);
<a name="l01539"></a>01539                 }
<a name="l01540"></a>01540         }
<a name="l01541"></a>01541 
<a name="l01542"></a>01542 failed:
<a name="l01543"></a>01543         RETURN(rc);
<a name="l01544"></a>01544 }
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 <span class="keywordtype">int</span>
<a name="l01547"></a>01547 kgnilnd_cancel_net_dgrams(<a class="code" href="structkgn__net.html">kgn_net_t</a> *net)
<a name="l01548"></a>01548 {
<a name="l01549"></a>01549         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>            *dg, *dgN;
<a name="l01550"></a>01550         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        zombies;
<a name="l01551"></a>01551         <span class="keywordtype">int</span>                     i;
<a name="l01552"></a>01552         ENTRY;
<a name="l01553"></a>01553 
<a name="l01554"></a>01554         <span class="comment">/* we want to cancel any outstanding dgrams - we don&apos;t want to rely</span>
<a name="l01555"></a>01555 <span class="comment">         * on del_peer_or_conn catching all of them. This helps protect us in cases</span>
<a name="l01556"></a>01556 <span class="comment">         * where we don&apos;t quite keep the peer-&gt;dgram mapping in sync due to some</span>
<a name="l01557"></a>01557 <span class="comment">         * race conditions */</span>
<a name="l01558"></a>01558 
<a name="l01559"></a>01559         LASSERTF(net-&gt;gnn_shutdown || kgnilnd_data.kgn_in_reset,
<a name="l01560"></a>01560                  <span class="stringliteral">&quot;called with LND invalid state: net shutdown %d &quot;</span>
<a name="l01561"></a>01561                  <span class="stringliteral">&quot;in reset %d\n&quot;</span>, net-&gt;gnn_shutdown,
<a name="l01562"></a>01562                  kgnilnd_data.kgn_in_reset);
<a name="l01563"></a>01563 
<a name="l01564"></a>01564         INIT_LIST_HEAD(&amp;zombies);
<a name="l01565"></a>01565 
<a name="l01566"></a>01566         spin_lock(&amp;net-&gt;gnn_dev-&gt;gnd_dgram_lock);
<a name="l01567"></a>01567 
<a name="l01568"></a>01568         <span class="keywordflow">for</span> (i = 0; i &lt; *kgnilnd_tunables.kgn_peer_hash_size; i++) {
<a name="l01569"></a>01569                 list_for_each_entry_safe(dg, dgN, &amp;net-&gt;gnn_dev-&gt;gnd_dgrams[i], gndg_list) {
<a name="l01570"></a>01570 
<a name="l01571"></a>01571                         <span class="comment">/* skip nids not on our net or are wildcards */</span>
<a name="l01572"></a>01572 
<a name="l01573"></a>01573 
<a name="l01574"></a>01574                         <span class="keywordflow">if</span> (dg-&gt;gndg_type == GNILND_DGRAM_WC_REQ ||
<a name="l01575"></a>01575                                 net-&gt;gnn_netnum != LNET_NETNUM(LNET_NIDNET(dg-&gt;gndg_conn_out.gncr_dstnid)))
<a name="l01576"></a>01576                                 <span class="keywordflow">continue</span>;
<a name="l01577"></a>01577 
<a name="l01578"></a>01578                         kgnilnd_cancel_dgram_locked(dg);
<a name="l01579"></a>01579                 }
<a name="l01580"></a>01580         }
<a name="l01581"></a>01581 
<a name="l01582"></a>01582         spin_unlock(&amp;net-&gt;gnn_dev-&gt;gnd_dgram_lock);
<a name="l01583"></a>01583 
<a name="l01584"></a>01584         RETURN(0);
<a name="l01585"></a>01585 }
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 <span class="keywordtype">int</span>
<a name="l01588"></a>01588 kgnilnd_cancel_wc_dgrams(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l01589"></a>01589 {
<a name="l01590"></a>01590         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dg, *dgN;
<a name="l01591"></a>01591         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> zombies;
<a name="l01592"></a>01592         ENTRY;
<a name="l01593"></a>01593 
<a name="l01594"></a>01594         <span class="comment">/* Time to kill the outstanding WC&apos;s</span>
<a name="l01595"></a>01595 <span class="comment">         * WC&apos;s exist on net 0 only but match on any net...</span>
<a name="l01596"></a>01596 <span class="comment">         */</span>
<a name="l01597"></a>01597 
<a name="l01598"></a>01598         LASSERTF(kgnilnd_data.kgn_in_reset || kgnilnd_data.kgn_wc_kill,
<a name="l01599"></a>01599                 <span class="stringliteral">&quot;called with LND invalid state: WC shutdown %d &quot;</span>
<a name="l01600"></a>01600                 <span class="stringliteral">&quot;in reset %d\n&quot;</span>, kgnilnd_data.kgn_wc_kill,
<a name="l01601"></a>01601                 kgnilnd_data.kgn_in_reset);
<a name="l01602"></a>01602 
<a name="l01603"></a>01603         INIT_LIST_HEAD(&amp;zombies);
<a name="l01604"></a>01604         spin_lock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01605"></a>01605 
<a name="l01606"></a>01606         <span class="keywordflow">do</span> {
<a name="l01607"></a>01607                 dg = kgnilnd_find_dgram_locked(dev, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>);
<a name="l01608"></a>01608                 <span class="keywordflow">if</span> (dg != NULL) {
<a name="l01609"></a>01609                         LASSERTF(dg-&gt;gndg_type == GNILND_DGRAM_WC_REQ,
<a name="l01610"></a>01610                                  <span class="stringliteral">&quot;dgram 0x%p-&gt;%s with bad type %d (%s)\n&quot;</span>,
<a name="l01611"></a>01611                                 dg, libcfs_nid2str(dg-&gt;gndg_conn_out.gncr_dstnid),
<a name="l01612"></a>01612                                 dg-&gt;gndg_type, kgnilnd_dgram_type2str(dg));
<a name="l01613"></a>01613 
<a name="l01614"></a>01614                         kgnilnd_cancel_dgram_locked(dg);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616                         <span class="comment">/* WC could be DONE already, check and if so add to list to be released */</span>
<a name="l01617"></a>01617                         <span class="keywordflow">if</span> (dg-&gt;gndg_state == GNILND_DGRAM_DONE) {
<a name="l01618"></a>01618                                 list_del_init(&amp;dg-&gt;gndg_list);
<a name="l01619"></a>01619                                 list_add_tail(&amp;dg-&gt;gndg_list, &amp;zombies);
<a name="l01620"></a>01620                         }
<a name="l01621"></a>01621                 }
<a name="l01622"></a>01622         } <span class="keywordflow">while</span> (dg != NULL);
<a name="l01623"></a>01623 
<a name="l01624"></a>01624         spin_unlock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01625"></a>01625 
<a name="l01626"></a>01626         list_for_each_entry_safe(dg, dgN, &amp;zombies, gndg_list) {
<a name="l01627"></a>01627                 list_del_init(&amp;dg-&gt;gndg_list);
<a name="l01628"></a>01628                 kgnilnd_release_dgram(dev, dg, 1);
<a name="l01629"></a>01629         }
<a name="l01630"></a>01630         RETURN(0);
<a name="l01631"></a>01631 
<a name="l01632"></a>01632 }
<a name="l01633"></a>01633 
<a name="l01634"></a>01634 <span class="keywordtype">int</span>
<a name="l01635"></a>01635 kgnilnd_cancel_dgrams(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l01636"></a>01636 {
<a name="l01637"></a>01637         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dg, *dgN;
<a name="l01638"></a>01638         <span class="keywordtype">int</span> i;
<a name="l01639"></a>01639         ENTRY;
<a name="l01640"></a>01640 
<a name="l01641"></a>01641         <span class="comment">/* Cancel any outstanding non wildcard datagrams regardless</span>
<a name="l01642"></a>01642 <span class="comment">         * of which net they are on as we are in base shutdown and</span>
<a name="l01643"></a>01643 <span class="comment">         * dont care about connecting anymore.</span>
<a name="l01644"></a>01644 <span class="comment">         */</span>
<a name="l01645"></a>01645 
<a name="l01646"></a>01646         LASSERTF(kgnilnd_data.kgn_wc_kill == 1,<span class="stringliteral">&quot;We didnt get called from base shutdown\n&quot;</span>);
<a name="l01647"></a>01647 
<a name="l01648"></a>01648         spin_lock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01649"></a>01649 
<a name="l01650"></a>01650         <span class="keywordflow">for</span> (i = 0; i &lt; (*kgnilnd_tunables.kgn_peer_hash_size -1); i++) {
<a name="l01651"></a>01651                 list_for_each_entry_safe(dg, dgN, &amp;dev-&gt;gnd_dgrams[i], gndg_list) {
<a name="l01652"></a>01652                         <span class="keywordflow">if</span> (dg-&gt;gndg_type != GNILND_DGRAM_WC_REQ)
<a name="l01653"></a>01653                                 kgnilnd_cancel_dgram_locked(dg);
<a name="l01654"></a>01654                 }
<a name="l01655"></a>01655         }
<a name="l01656"></a>01656 
<a name="l01657"></a>01657         spin_unlock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l01658"></a>01658 
<a name="l01659"></a>01659         RETURN(0);
<a name="l01660"></a>01660 }
<a name="l01661"></a>01661 
<a name="l01662"></a>01662 
<a name="l01663"></a>01663 <span class="keywordtype">void</span>
<a name="l01664"></a>01664 kgnilnd_wait_for_canceled_dgrams(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l01665"></a>01665 {
<a name="l01666"></a>01666         <span class="keywordtype">int</span>             i = 4;
<a name="l01667"></a>01667         <span class="keywordtype">int</span>             rc;
<a name="l01668"></a>01668         gni_return_t    grc;
<a name="l01669"></a>01669         __u64           readyid;
<a name="l01670"></a>01670         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>    *dgram;
<a name="l01671"></a>01671 
<a name="l01672"></a>01672         <span class="comment">/* use do while to get at least one check run to allow</span>
<a name="l01673"></a>01673 <span class="comment">         * regression test for 762072 to hit bug if there */</span>
<a name="l01674"></a>01674 
<a name="l01675"></a>01675         <span class="comment">/* This function races with the dgram mover during shutdown so it is possible for</span>
<a name="l01676"></a>01676 <span class="comment">         * a dgram to be seen in kgnilnd_postdata_probe_wait_by_id but be handled in the</span>
<a name="l01677"></a>01677 <span class="comment">         * dgram mover thread instead of inside of this function.</span>
<a name="l01678"></a>01678 <span class="comment">         */</span>
<a name="l01679"></a>01679 
<a name="l01680"></a>01680         <span class="comment">/* This should only be called from within shutdown, baseshutdown, or stack reset.</span>
<a name="l01681"></a>01681 <span class="comment">         * there are no assertions here to verify since base_shutdown has nothing in it we can check</span>
<a name="l01682"></a>01682 <span class="comment">         * the net is gone by then.</span>
<a name="l01683"></a>01683 <span class="comment">         */</span>
<a name="l01684"></a>01684 
<a name="l01685"></a>01685         <span class="keywordflow">do</span> {
<a name="l01686"></a>01686                 i++;
<a name="l01687"></a>01687                 CDEBUG(((i &amp; (-i)) == i) ? D_WARNING : D_NET,
<a name="l01688"></a>01688                         <span class="stringliteral">&quot;Waiting for %d canceled datagrams to clear on device %d\n&quot;</span>,
<a name="l01689"></a>01689                         atomic_read(&amp;dev-&gt;gnd_canceled_dgrams), dev-&gt;gnd_id);
<a name="l01690"></a>01690 
<a name="l01691"></a>01691                 <span class="comment">/* check once a second */</span>
<a name="l01692"></a>01692                 grc = kgnilnd_postdata_probe_wait_by_id(dev-&gt;gnd_handle,
<a name="l01693"></a>01693                        250, &amp;readyid);
<a name="l01694"></a>01694 
<a name="l01695"></a>01695                 <span class="keywordflow">if</span> (grc != GNI_RC_SUCCESS)
<a name="l01696"></a>01696                         <span class="keywordflow">continue</span>;
<a name="l01697"></a>01697 
<a name="l01698"></a>01698                 CDEBUG(D_NET, <span class="stringliteral">&quot;ready &quot;</span>LPX64<span class="stringliteral">&quot; on device %d-&gt;0x%p\n&quot;</span>,
<a name="l01699"></a>01699                         readyid, dev-&gt;gnd_id, dev);
<a name="l01700"></a>01700 
<a name="l01701"></a>01701                 rc = kgnilnd_probe_for_dgram(dev, &amp;dgram);
<a name="l01702"></a>01702                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01703"></a>01703                         <span class="comment">/* if we got a valid dgram or one that is now done, clean up */</span>
<a name="l01704"></a>01704                         kgnilnd_release_dgram(dev, dgram, 1);
<a name="l01705"></a>01705                 }
<a name="l01706"></a>01706         } <span class="keywordflow">while</span> (atomic_read(&amp;dev-&gt;gnd_canceled_dgrams));
<a name="l01707"></a>01707 }
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 <span class="keywordtype">int</span>
<a name="l01710"></a>01710 kgnilnd_start_connect(<a class="code" href="structkgn__peer.html">kgn_peer_t</a> *peer)
<a name="l01711"></a>01711 {
<a name="l01712"></a>01712         <span class="keywordtype">int</span>              rc = 0;
<a name="l01713"></a>01713         <span class="comment">/* sync point for kgnilnd_del_peer_locked - do an early check to</span>
<a name="l01714"></a>01714 <span class="comment">         * catch the most common hits where del_peer is done by the</span>
<a name="l01715"></a>01715 <span class="comment">         * time we get here */</span>
<a name="l01716"></a>01716         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_GNP_CONNECTING1)) {
<a name="l01717"></a>01717                 <span class="keywordflow">while</span> (CFS_FAIL_TIMEOUT(CFS_FAIL_GNI_GNP_CONNECTING1, 1)) {};
<a name="l01718"></a>01718         }
<a name="l01719"></a>01719 
<a name="l01720"></a>01720         write_lock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01721"></a>01721         <span class="keywordflow">if</span> (!kgnilnd_peer_active(peer) || peer-&gt;gnp_connecting != GNILND_PEER_CONNECT) {
<a name="l01722"></a>01722                 <span class="comment">/* raced with peer getting unlinked */</span>
<a name="l01723"></a>01723                 write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01724"></a>01724                 rc = ESTALE;
<a name="l01725"></a>01725                 GOTO(out, rc);
<a name="l01726"></a>01726         }
<a name="l01727"></a>01727         peer-&gt;gnp_connecting = GNILND_PEER_POSTING;
<a name="l01728"></a>01728         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01729"></a>01729 
<a name="l01730"></a>01730         set_mb(peer-&gt;gnp_last_dgram_time, jiffies);
<a name="l01731"></a>01731         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_GNP_CONNECTING2)) {
<a name="l01732"></a>01732                 <span class="keywordflow">while</span> (CFS_FAIL_TIMEOUT(CFS_FAIL_GNI_GNP_CONNECTING2, 1)) {};
<a name="l01733"></a>01733         }
<a name="l01734"></a>01734 
<a name="l01735"></a>01735         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_GNP_CONNECTING3)) {
<a name="l01736"></a>01736                 <span class="keywordflow">while</span> (CFS_FAIL_TIMEOUT(CFS_FAIL_GNI_GNP_CONNECTING3, 1)) {};
<a name="l01737"></a>01737                 rc = cfs_fail_val ? cfs_fail_val : -ENOMEM;
<a name="l01738"></a>01738         } <span class="keywordflow">else</span> {
<a name="l01739"></a>01739                 rc = kgnilnd_post_dgram(peer-&gt;gnp_net-&gt;gnn_dev,
<a name="l01740"></a>01740                                         peer-&gt;gnp_nid, GNILND_CONNREQ_REQ, 0);
<a name="l01741"></a>01741         }
<a name="l01742"></a>01742         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01743"></a>01743                 set_mb(peer-&gt;gnp_last_dgram_errno, rc);
<a name="l01744"></a>01744                 GOTO(failed, rc);
<a name="l01745"></a>01745         }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747         <span class="comment">/* while we&apos;re posting someone could have decided this peer/dgram needed to</span>
<a name="l01748"></a>01748 <span class="comment">         * die a quick death, so we check for state change and process accordingly */</span>
<a name="l01749"></a>01749 
<a name="l01750"></a>01750         write_lock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01751"></a>01751         <span class="keywordflow">if</span> (!kgnilnd_peer_active(peer) || peer-&gt;gnp_connecting == GNILND_PEER_NEEDS_DEATH) {
<a name="l01752"></a>01752                 <span class="keywordflow">if</span> (peer-&gt;gnp_connecting == GNILND_PEER_NEEDS_DEATH) {
<a name="l01753"></a>01753                         peer-&gt;gnp_connecting = GNILND_PEER_KILL;
<a name="l01754"></a>01754                 }
<a name="l01755"></a>01755                 write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01756"></a>01756                 <span class="comment">/* positive RC to avoid dgram cleanup - we&apos;ll have to</span>
<a name="l01757"></a>01757 <span class="comment">                 * wait for the kgni GNI_POST_TERMINATED event to</span>
<a name="l01758"></a>01758 <span class="comment">                 * finish cleaning up */</span>
<a name="l01759"></a>01759                 rc = ESTALE;
<a name="l01760"></a>01760                 kgnilnd_find_and_cancel_dgram(peer-&gt;gnp_net-&gt;gnn_dev, peer-&gt;gnp_nid);
<a name="l01761"></a>01761                 GOTO(out, rc);
<a name="l01762"></a>01762         }
<a name="l01763"></a>01763         peer-&gt;gnp_connecting = GNILND_PEER_POSTED;
<a name="l01764"></a>01764         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01765"></a>01765         <span class="comment">/* reaper thread will take care of any timeouts */</span>
<a name="l01766"></a>01766         CDEBUG(D_NET, <span class="stringliteral">&quot;waiting for connect to finish to %s rc %d\n&quot;</span>,
<a name="l01767"></a>01767                libcfs_nid2str(peer-&gt;gnp_nid), rc);
<a name="l01768"></a>01768 
<a name="l01769"></a>01769         RETURN(rc);
<a name="l01770"></a>01770 
<a name="l01771"></a>01771 failed:
<a name="l01772"></a>01772         CDEBUG(D_NET, <span class="stringliteral">&quot;connect to %s failed: rc %d \n&quot;</span>,
<a name="l01773"></a>01773                libcfs_nid2str(peer-&gt;gnp_nid), rc);
<a name="l01774"></a>01774 out:
<a name="l01775"></a>01775         RETURN(rc);
<a name="l01776"></a>01776 }
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 <span class="keywordtype">int</span>
<a name="l01779"></a>01779 kgnilnd_finish_connect(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01780"></a>01780 {
<a name="l01781"></a>01781         <a class="code" href="structkgn__conn.html">kgn_conn_t</a>        *conn = dgram-&gt;gndg_conn;
<a name="l01782"></a>01782         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>         her_nid = dgram-&gt;gndg_conn_in.gncr_srcnid;
<a name="l01783"></a>01783         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>        *new_peer, *peer = NULL;
<a name="l01784"></a>01784         <a class="code" href="structkgn__tx.html">kgn_tx_t</a>          *tx;
<a name="l01785"></a>01785         <a class="code" href="structkgn__tx.html">kgn_tx_t</a>          *txn;
<a name="l01786"></a>01786         <a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>   *mbox;
<a name="l01787"></a>01787         <span class="keywordtype">int</span>                rc;
<a name="l01788"></a>01788         <span class="keywordtype">int</span>                nstale;
<a name="l01789"></a>01789 
<a name="l01790"></a>01790         <span class="comment">/* try to find a peer that matches the nid we got in the connreq</span>
<a name="l01791"></a>01791 <span class="comment">         * kgnilnd_unpack_connreq makes sure that conn_in.gncr_srcnid is</span>
<a name="l01792"></a>01792 <span class="comment">         * HER and conn_out.gncr_srcnid is ME for both active and WC dgrams */</span>
<a name="l01793"></a>01793 
<a name="l01794"></a>01794         <span class="comment">/* assume this is a new peer  - it makes locking cleaner when it isn&apos;t */</span>
<a name="l01795"></a>01795         <span class="comment">/* no holding kgn_net_rw_sem - already are at the kgnilnd_dgram_mover level */</span>
<a name="l01796"></a>01796 
<a name="l01797"></a>01797         rc = kgnilnd_create_peer_safe(&amp;new_peer, her_nid, NULL, GNILND_RCA_NODE_UP);
<a name="l01798"></a>01798         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01799"></a>01799                 CERROR(<span class="stringliteral">&quot;Can&apos;t create peer for %s\n&quot;</span>, libcfs_nid2str(her_nid));
<a name="l01800"></a>01800                 <span class="keywordflow">return</span> rc;
<a name="l01801"></a>01801         }
<a name="l01802"></a>01802 
<a name="l01803"></a>01803         write_lock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01804"></a>01804 
<a name="l01805"></a>01805         <span class="comment">/* this transfers ref from create_peer to the kgn_peer table */</span>
<a name="l01806"></a>01806         kgnilnd_add_peer_locked(her_nid, new_peer, &amp;peer);
<a name="l01807"></a>01807 
<a name="l01808"></a>01808         <span class="comment">/* if we found an existing peer, is it really ready for a new conn ? */</span>
<a name="l01809"></a>01809         <span class="keywordflow">if</span> (peer != new_peer) {
<a name="l01810"></a>01810                 <span class="comment">/* if this was an active connect attempt but we can&apos;t find a peer waiting for it</span>
<a name="l01811"></a>01811 <span class="comment">                 * we will dump in the trash */</span>
<a name="l01812"></a>01812 
<a name="l01813"></a>01813                 <span class="keywordflow">if</span> (peer-&gt;gnp_connecting == GNILND_PEER_IDLE &amp;&amp; dgram-&gt;gndg_conn_out.gncr_dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01814"></a>01814                         CDEBUG(D_NET, <span class="stringliteral">&quot;dropping completed connreq for %s peer 0x%p-&gt;%s\n&quot;</span>,
<a name="l01815"></a>01815                                libcfs_nid2str(her_nid), peer, libcfs_nid2str(peer-&gt;gnp_nid));
<a name="l01816"></a>01816                         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01817"></a>01817                         rc = ECANCELED;
<a name="l01818"></a>01818                         GOTO(out, rc);
<a name="l01819"></a>01819                 }
<a name="l01820"></a>01820 
<a name="l01821"></a>01821                 <span class="comment">/* check to see if we can catch a connecting peer before it is</span>
<a name="l01822"></a>01822 <span class="comment">                 * removed from the connd_peers list - if not, we need to</span>
<a name="l01823"></a>01823 <span class="comment">                 * let the connreqs race and be handled by kgnilnd_conn_isdup_locked() */</span>
<a name="l01824"></a>01824                 <span class="keywordflow">if</span> (peer-&gt;gnp_connecting != GNILND_PEER_IDLE) {
<a name="l01825"></a>01825                         spin_lock(&amp;peer-&gt;gnp_net-&gt;gnn_dev-&gt;gnd_connd_lock);
<a name="l01826"></a>01826                         <span class="keywordflow">if</span> (!list_empty(&amp;peer-&gt;gnp_connd_list)) {
<a name="l01827"></a>01827                                 list_del_init(&amp;peer-&gt;gnp_connd_list);
<a name="l01828"></a>01828                                 <span class="comment">/* drop connd ref */</span>
<a name="l01829"></a>01829                                 kgnilnd_peer_decref(peer);
<a name="l01830"></a>01830                         }
<a name="l01831"></a>01831                         spin_unlock(&amp;peer-&gt;gnp_net-&gt;gnn_dev-&gt;gnd_connd_lock);
<a name="l01832"></a>01832                         <span class="comment">/* clear rc to make sure we don&apos;t have fake error */</span>
<a name="l01833"></a>01833                         rc = 0;
<a name="l01834"></a>01834                 }
<a name="l01835"></a>01835 
<a name="l01836"></a>01836                 <span class="comment">/* no matter what, we are no longer waiting to connect this peer now */</span>
<a name="l01837"></a>01837                 peer-&gt;gnp_connecting = GNILND_PEER_IDLE;
<a name="l01838"></a>01838 
<a name="l01839"></a>01839                 <span class="comment">/* Refuse to duplicate an existing connection (both sides might try to</span>
<a name="l01840"></a>01840 <span class="comment">                 * connect at once).  NB we return success!  We _are_ connected so we</span>
<a name="l01841"></a>01841 <span class="comment">                 * _don&apos;t_ have any blocked txs to complete with failure. */</span>
<a name="l01842"></a>01842                 rc = kgnilnd_conn_isdup_locked(peer, conn);
<a name="l01843"></a>01843                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01844"></a>01844                         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01845"></a>01845                         CDEBUG(D_NET, <span class="stringliteral">&quot;Not creating duplicate connection to %s: %d\n&quot;</span>,
<a name="l01846"></a>01846                               libcfs_nid2str(her_nid), rc);
<a name="l01847"></a>01847                         rc = EALREADY;
<a name="l01848"></a>01848                         GOTO(out, rc);
<a name="l01849"></a>01849                 }
<a name="l01850"></a>01850         }
<a name="l01851"></a>01851 
<a name="l01852"></a>01852         <span class="keywordflow">if</span> (peer-&gt;gnp_down == GNILND_RCA_NODE_DOWN) {
<a name="l01853"></a>01853                 CNETERR(<span class="stringliteral">&quot;Received connection request from down nid %s\n&quot;</span>,
<a name="l01854"></a>01854                         libcfs_nid2str(her_nid));
<a name="l01855"></a>01855                 peer-&gt;gnp_down = GNILND_RCA_NODE_UP;
<a name="l01856"></a>01856         }
<a name="l01857"></a>01857 
<a name="l01858"></a>01858         nstale = kgnilnd_close_stale_conns_locked(peer, conn);
<a name="l01859"></a>01859 
<a name="l01860"></a>01860         <span class="comment">/* either way with peer (new or existing), we are ok with ref counts here as the</span>
<a name="l01861"></a>01861 <span class="comment">         * kgnilnd_add_peer_locked will use our ref on new_peer (from create_peer_safe) as the</span>
<a name="l01862"></a>01862 <span class="comment">         * ref for the peer table. */</span>
<a name="l01863"></a>01863 
<a name="l01864"></a>01864         <span class="comment">/* at this point, the connection request is a winner */</span>
<a name="l01865"></a>01865 
<a name="l01866"></a>01866         <span class="comment">/* mark &apos;DONE&apos; to avoid cancel being called from release */</span>
<a name="l01867"></a>01867         dgram-&gt;gndg_state = GNILND_DGRAM_DONE;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869         <span class="comment">/* initialise timestamps before reaper looks at them */</span>
<a name="l01870"></a>01870         conn-&gt;gnc_last_rx = conn-&gt;gnc_last_rx_cq = jiffies;
<a name="l01871"></a>01871 
<a name="l01872"></a>01872         <span class="comment">/* last_tx is initialized to jiffies - (keepalive*2) so that if the NOOP fails it will</span>
<a name="l01873"></a>01873 <span class="comment">         * immediatly send a NOOP in the reaper thread during the call to</span>
<a name="l01874"></a>01874 <span class="comment">         * kgnilnd_check_conn_timeouts_locked</span>
<a name="l01875"></a>01875 <span class="comment">         */</span>
<a name="l01876"></a>01876         conn-&gt;gnc_last_tx = jiffies - (cfs_time_seconds(GNILND_TO2KA(conn-&gt;gnc_timeout)) * 2);
<a name="l01877"></a>01877         conn-&gt;gnc_state = GNILND_CONN_ESTABLISHED;
<a name="l01878"></a>01878 
<a name="l01879"></a>01879         <span class="comment">/* save the dgram type used to establish this connection */</span>
<a name="l01880"></a>01880         conn-&gt;gnc_dgram_type = dgram-&gt;gndg_type;
<a name="l01881"></a>01881 
<a name="l01882"></a>01882         <span class="comment">/* refs are not transferred from dgram to tables, so increment to</span>
<a name="l01883"></a>01883 <span class="comment">         * take ownership */</span>
<a name="l01884"></a>01884         kgnilnd_conn_addref(conn);
<a name="l01885"></a>01885         kgnilnd_peer_addref(peer);
<a name="l01886"></a>01886         conn-&gt;gnc_peer = peer;
<a name="l01887"></a>01887         list_add_tail(&amp;conn-&gt;gnc_list, &amp;peer-&gt;gnp_conns);
<a name="l01888"></a>01888 
<a name="l01889"></a>01889         kgnilnd_conn_addref(conn);               <span class="comment">/* +1 ref for conn table */</span>
<a name="l01890"></a>01890         list_add_tail(&amp;conn-&gt;gnc_hashlist,
<a name="l01891"></a>01891                       kgnilnd_cqid2connlist(conn-&gt;gnc_cqid));
<a name="l01892"></a>01892         kgnilnd_data.kgn_conn_version++;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894         <span class="comment">/* Dont send NOOP if fail_loc is set</span>
<a name="l01895"></a>01895 <span class="comment">         */</span>
<a name="l01896"></a>01896         <span class="keywordflow">if</span> (!CFS_FAIL_CHECK(CFS_FAIL_GNI_ONLY_NOOP)) {
<a name="l01897"></a>01897                 tx = kgnilnd_new_tx_msg(GNILND_MSG_NOOP, peer-&gt;gnp_net-&gt;gnn_ni-&gt;ni_nid);
<a name="l01898"></a>01898                 <span class="keywordflow">if</span> (tx == NULL) {
<a name="l01899"></a>01899                         CNETERR(<span class="stringliteral">&quot;can&apos;t get TX to initiate NOOP to %s\n&quot;</span>,
<a name="l01900"></a>01900                                 libcfs_nid2str(peer-&gt;gnp_nid));
<a name="l01901"></a>01901                 } <span class="keywordflow">else</span> {
<a name="l01902"></a>01902                         kgnilnd_queue_tx(conn, tx);
<a name="l01903"></a>01903                 }
<a name="l01904"></a>01904         }
<a name="l01905"></a>01905 
<a name="l01906"></a>01906         <span class="comment">/* Schedule all packets blocking for a connection */</span>
<a name="l01907"></a>01907         list_for_each_entry_safe(tx, txn, &amp;peer-&gt;gnp_tx_queue, tx_list) {
<a name="l01908"></a>01908                 <span class="comment">/* lock held here is the peer_conn lock */</span>
<a name="l01909"></a>01909                 kgnilnd_tx_del_state_locked(tx, peer, NULL, GNILND_TX_ALLOCD);
<a name="l01910"></a>01910                 kgnilnd_queue_tx(conn, tx);
<a name="l01911"></a>01911         }
<a name="l01912"></a>01912 
<a name="l01913"></a>01913         <span class="comment">/* If this is an active connection lets mark its timestamp on the MBoX */</span>
<a name="l01914"></a>01914         <span class="keywordflow">if</span> (dgram-&gt;gndg_conn_out.gncr_dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01915"></a>01915                 mbox = &amp;conn-&gt;gnc_fma_blk-&gt;gnm_mbox_info[conn-&gt;gnc_mbox_id];
<a name="l01916"></a>01916                 <span class="comment">/* conn-&gt;gnc_last_rx is jiffies it better exist as it was just set */</span>
<a name="l01917"></a>01917                 mbox-&gt;mbx_release_purg_active_dgram = conn-&gt;gnc_last_rx;
<a name="l01918"></a>01918         }
<a name="l01919"></a>01919 
<a name="l01920"></a>01920         <span class="comment">/* Bug 765042: wake up scheduler for a race with finish_connect and</span>
<a name="l01921"></a>01921 <span class="comment">         * complete_conn_closed with a conn in purgatory</span>
<a name="l01922"></a>01922 <span class="comment">         * since we can&apos;t use CFS_RACE due to mutex_holds in kgnilnd_process_conns,</span>
<a name="l01923"></a>01923 <span class="comment">         * we just check for set and then clear */</span>
<a name="l01924"></a>01924         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_FINISH_PURG)) {
<a name="l01925"></a>01925                 cfs_fail_loc = 0x0;
<a name="l01926"></a>01926                 <span class="comment">/* get scheduler thread moving again */</span>
<a name="l01927"></a>01927                 kgnilnd_schedule_device(conn-&gt;gnc_device);
<a name="l01928"></a>01928         }
<a name="l01929"></a>01929 
<a name="l01930"></a>01930         CDEBUG(D_NET, <span class="stringliteral">&quot;New conn 0x%p-&gt;%s dev %d\n&quot;</span>,
<a name="l01931"></a>01931                conn, libcfs_nid2str(her_nid), conn-&gt;gnc_device-&gt;gnd_id);
<a name="l01932"></a>01932 
<a name="l01933"></a>01933         <span class="comment">/* make sure we reset peer reconnect interval now that we have a good conn */</span>
<a name="l01934"></a>01934         kgnilnd_peer_alive(peer);
<a name="l01935"></a>01935         peer-&gt;gnp_reconnect_interval = 0;
<a name="l01936"></a>01936 
<a name="l01937"></a>01937         <span class="comment">/* clear the unlink attribute if we dont clear it kgnilnd_del_conn_or_peer will wait</span>
<a name="l01938"></a>01938 <span class="comment">         * on the atomic forever</span>
<a name="l01939"></a>01939 <span class="comment">         */</span>
<a name="l01940"></a>01940         <span class="keywordflow">if</span> (peer-&gt;gnp_pending_unlink) {
<a name="l01941"></a>01941                 peer-&gt;gnp_pending_unlink = 0;
<a name="l01942"></a>01942                 kgnilnd_admin_decref(kgnilnd_data.kgn_npending_unlink);
<a name="l01943"></a>01943                 CDEBUG(D_NET, <span class="stringliteral">&quot;Clearing peer unlink %p\n&quot;</span>,peer);
<a name="l01944"></a>01944         }
<a name="l01945"></a>01945 
<a name="l01946"></a>01946         <span class="comment">/* add ref to make it hang around until after we drop the lock */</span>
<a name="l01947"></a>01947         kgnilnd_conn_addref(conn);
<a name="l01948"></a>01948 
<a name="l01949"></a>01949         <span class="comment">/* Once the peer_conn lock is dropped, the conn could actually move into</span>
<a name="l01950"></a>01950 <span class="comment">         * CLOSING-&gt;CLOSED-&gt;DONE in the scheduler thread, so hold the</span>
<a name="l01951"></a>01951 <span class="comment">         * lock until we are really done */</span>
<a name="l01952"></a>01952         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01953"></a>01953 
<a name="l01954"></a>01954         <span class="comment">/* Notify LNET that we now have a working connection to this peer.</span>
<a name="l01955"></a>01955 <span class="comment">         * This is a Cray extension to the &quot;standard&quot; LND behavior. */</span>
<a name="l01956"></a>01956         lnet_notify(peer-&gt;gnp_net-&gt;gnn_ni, peer-&gt;gnp_nid,
<a name="l01957"></a>01957                      1, cfs_time_current());
<a name="l01958"></a>01958 
<a name="l01959"></a>01959         <span class="comment">/* drop our &apos;hold&apos; ref */</span>
<a name="l01960"></a>01960         kgnilnd_conn_decref(conn);
<a name="l01961"></a>01961 
<a name="l01962"></a>01962 out:
<a name="l01963"></a>01963         RETURN(rc);
<a name="l01964"></a>01964 }
<a name="l01965"></a>01965 
<a name="l01966"></a>01966 <span class="keywordtype">void</span>
<a name="l01967"></a>01967 kgnilnd_send_nak(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dst_nid, <span class="keywordtype">int</span> error)
<a name="l01968"></a>01968 {
<a name="l01969"></a>01969         <span class="keywordtype">int</span>              rc = 0;
<a name="l01970"></a>01970         ENTRY;
<a name="l01971"></a>01971 
<a name="l01972"></a>01972         LASSERTF(dst_nid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, <span class="stringliteral">&quot;bad dst_nid %s\n&quot;</span>, libcfs_nid2str(dst_nid));
<a name="l01973"></a>01973 
<a name="l01974"></a>01974         CDEBUG(D_NET, <span class="stringliteral">&quot;NAK to %s errno %d\n&quot;</span>, libcfs_nid2str(dst_nid), error);
<a name="l01975"></a>01975 
<a name="l01976"></a>01976         rc = kgnilnd_post_dgram(dev, dst_nid, GNILND_CONNREQ_NAK, error);
<a name="l01977"></a>01977 
<a name="l01978"></a>01978         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01979"></a>01979                 CDEBUG(D_NET, <span class="stringliteral">&quot;NAK to %s failed: rc %d \n&quot;</span>, libcfs_nid2str(dst_nid), rc);
<a name="l01980"></a>01980         }
<a name="l01981"></a>01981         EXIT;
<a name="l01982"></a>01982 }
<a name="l01983"></a>01983 
<a name="l01984"></a>01984 <span class="keywordtype">int</span>
<a name="l01985"></a>01985 kgnilnd_process_nak(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01986"></a>01986 {
<a name="l01987"></a>01987         <a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>     *connreq = &amp;dgram-&gt;gndg_conn_in;
<a name="l01988"></a>01988         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>         src_nid = connreq-&gt;gncr_srcnid;
<a name="l01989"></a>01989         <span class="keywordtype">int</span>                errno = connreq-&gt;gncr_nakdata.gnnd_errno;
<a name="l01990"></a>01990         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>        *peer;
<a name="l01991"></a>01991         <span class="keywordtype">int</span>                rc = 0;
<a name="l01992"></a>01992 
<a name="l01993"></a>01993         write_lock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l01994"></a>01994 
<a name="l01995"></a>01995         peer = kgnilnd_find_peer_locked(src_nid);
<a name="l01996"></a>01996         <span class="keywordflow">if</span> (peer == NULL) {
<a name="l01997"></a>01997                 <span class="comment">/* we likely dropped him from bad data when we processed</span>
<a name="l01998"></a>01998 <span class="comment">                 * the original REQ */</span>
<a name="l01999"></a>01999                 write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l02000"></a>02000                 <span class="keywordflow">return</span> -EBADSLT;
<a name="l02001"></a>02001         }
<a name="l02002"></a>02002 
<a name="l02003"></a>02003         <span class="comment">/* need to check peerstamp/connstamp against the ones we find</span>
<a name="l02004"></a>02004 <span class="comment">         * to make sure we don&apos;t close new (and good?) conns that we</span>
<a name="l02005"></a>02005 <span class="comment">         * formed after this connreq failed */</span>
<a name="l02006"></a>02006         <span class="keywordflow">if</span> (peer-&gt;gnp_connecting == GNILND_PEER_IDLE) {
<a name="l02007"></a>02007                 <a class="code" href="structkgn__conn.html">kgn_conn_t</a>        conn;
<a name="l02008"></a>02008 
<a name="l02009"></a>02009                 <span class="keywordflow">if</span> (list_empty(&amp;peer-&gt;gnp_conns)) {
<a name="l02010"></a>02010                         <span class="comment">/* assume already procced datagram and it barfed up</span>
<a name="l02011"></a>02011 <span class="comment">                         * on this side too */</span>
<a name="l02012"></a>02012                         CDEBUG(D_NET, <span class="stringliteral">&quot;dropping NAK from %s; &quot;</span>
<a name="l02013"></a>02013                                <span class="stringliteral">&quot;peer %s is already not connected\n&quot;</span>,
<a name="l02014"></a>02014                                 libcfs_nid2str(connreq-&gt;gncr_srcnid),
<a name="l02015"></a>02015                                 libcfs_nid2str(connreq-&gt;gncr_dstnid));
<a name="l02016"></a>02016                         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l02017"></a>02017                         <span class="keywordflow">return</span> 0;
<a name="l02018"></a>02018                 }
<a name="l02019"></a>02019 
<a name="l02020"></a>02020                 <span class="comment">/* stub up a connection with the connreq XXX_stamps to allow</span>
<a name="l02021"></a>02021 <span class="comment">                 * use to use close_stale_conns_locked */</span>
<a name="l02022"></a>02022                 conn.gnc_peerstamp = connreq-&gt;gncr_peerstamp;
<a name="l02023"></a>02023                 conn.gnc_my_connstamp = connreq-&gt;gncr_connstamp;
<a name="l02024"></a>02024                 conn.gnc_peer_connstamp = connreq-&gt;gncr_connstamp;
<a name="l02025"></a>02025                 conn.gnc_device = peer-&gt;gnp_net-&gt;gnn_dev;
<a name="l02026"></a>02026 
<a name="l02027"></a>02027                 rc = kgnilnd_close_stale_conns_locked(peer, &amp;conn);
<a name="l02028"></a>02028 
<a name="l02029"></a>02029                 LCONSOLE_INFO(<span class="stringliteral">&quot;Received NAK from %s for %s errno %d; &quot;</span>
<a name="l02030"></a>02030                         <span class="stringliteral">&quot;closed %d connections\n&quot;</span>,
<a name="l02031"></a>02031                         libcfs_nid2str(connreq-&gt;gncr_srcnid),
<a name="l02032"></a>02032                         libcfs_nid2str(connreq-&gt;gncr_dstnid), errno, rc);
<a name="l02033"></a>02033         } <span class="keywordflow">else</span> {
<a name="l02034"></a>02034                 spin_lock(&amp;dgram-&gt;gndg_conn-&gt;gnc_device-&gt;gnd_connd_lock);
<a name="l02035"></a>02035 
<a name="l02036"></a>02036                 <span class="keywordflow">if</span> (list_empty(&amp;peer-&gt;gnp_connd_list)) {
<a name="l02037"></a>02037                         <span class="comment">/* if peer isn&apos;t on waiting list, try to find one to nuke */</span>
<a name="l02038"></a>02038                         rc = kgnilnd_find_and_cancel_dgram(peer-&gt;gnp_net-&gt;gnn_dev,
<a name="l02039"></a>02039                                                            peer-&gt;gnp_nid);
<a name="l02040"></a>02040 
<a name="l02041"></a>02041                         <span class="keywordflow">if</span> (rc) {
<a name="l02042"></a>02042                                 LCONSOLE_INFO(<span class="stringliteral">&quot;Received NAK from %s for %s errno %d; &quot;</span>
<a name="l02043"></a>02043                                         <span class="stringliteral">&quot;canceled pending connect request\n&quot;</span>,
<a name="l02044"></a>02044                                         libcfs_nid2str(connreq-&gt;gncr_srcnid),
<a name="l02045"></a>02045                                         libcfs_nid2str(connreq-&gt;gncr_dstnid), errno);
<a name="l02046"></a>02046                         }
<a name="l02047"></a>02047 
<a name="l02048"></a>02048                         <span class="comment">/* if we can&apos;t find a waiting dgram, we just drop the nak - the conn</span>
<a name="l02049"></a>02049 <span class="comment">                         * connect must have failed (didn&apos;t find conn above and clear connecting</span>
<a name="l02050"></a>02050 <span class="comment">                         * -- so nothing to do besides drop */</span>
<a name="l02051"></a>02051                 } <span class="keywordflow">else</span> {
<a name="l02052"></a>02052                         <span class="comment">/* peer is on list, meaning it is a new connect attempt from the one</span>
<a name="l02053"></a>02053 <span class="comment">                         * we started that generated the NAK - so just drop NAK */</span>
<a name="l02054"></a>02054 
<a name="l02055"></a>02055                         <span class="comment">/* use negative to prevent error message */</span>
<a name="l02056"></a>02056                         rc = -EAGAIN;
<a name="l02057"></a>02057                 }
<a name="l02058"></a>02058                 spin_unlock(&amp;dgram-&gt;gndg_conn-&gt;gnc_device-&gt;gnd_connd_lock);
<a name="l02059"></a>02059         }
<a name="l02060"></a>02060 
<a name="l02061"></a>02061         <span class="comment">/* success! we found a peer and at least marked pending_nak */</span>
<a name="l02062"></a>02062         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l02063"></a>02063 
<a name="l02064"></a>02064         <span class="keywordflow">return</span> rc;
<a name="l02065"></a>02065 }
<a name="l02066"></a>02066 
<a name="l02067"></a>02067 <span class="keywordtype">int</span>
<a name="l02068"></a>02068 kgnilnd_process_connreq(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram, <span class="keywordtype">int</span> *needs_nak)
<a name="l02069"></a>02069 {
<a name="l02070"></a>02070         <span class="keywordtype">int</span>                      rc;
<a name="l02071"></a>02071 
<a name="l02072"></a>02072         rc = kgnilnd_unpack_connreq(dgram);
<a name="l02073"></a>02073         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02074"></a>02074                 <span class="keywordflow">if</span> (rc != -EBADF) {
<a name="l02075"></a>02075                         <span class="comment">/* only NAK if we have good srcnid to use */</span>
<a name="l02076"></a>02076                         *needs_nak = 1;
<a name="l02077"></a>02077                 }
<a name="l02078"></a>02078                 <span class="keywordflow">goto</span> connreq_out;
<a name="l02079"></a>02079         }
<a name="l02080"></a>02080 
<a name="l02081"></a>02081         <span class="keywordflow">switch</span> (dgram-&gt;gndg_conn_in.gncr_type) {
<a name="l02082"></a>02082         <span class="keywordflow">case</span> GNILND_CONNREQ_REQ:
<a name="l02083"></a>02083                 <span class="comment">/* wire up peer &amp; conn, send queued TX */</span>
<a name="l02084"></a>02084                 rc = kgnilnd_finish_connect(dgram);
<a name="l02085"></a>02085 
<a name="l02086"></a>02086                 <span class="comment">/* don&apos;t nak when the nid is hosed */</span>
<a name="l02087"></a>02087                 <span class="keywordflow">if</span> ((rc &lt; 0)) {
<a name="l02088"></a>02088                         *needs_nak = 1;
<a name="l02089"></a>02089                 }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091                 <span class="keywordflow">break</span>;
<a name="l02092"></a>02092         <span class="keywordflow">case</span> GNILND_CONNREQ_NAK:
<a name="l02093"></a>02093                 rc = kgnilnd_process_nak(dgram);
<a name="l02094"></a>02094                 <span class="comment">/* return early to prevent reconnect bump */</span>
<a name="l02095"></a>02095                 <span class="keywordflow">return</span> rc;
<a name="l02096"></a>02096         <span class="keywordflow">default</span>:
<a name="l02097"></a>02097                 CERROR(<span class="stringliteral">&quot;unexpected connreq type %s (%d) from %s\n&quot;</span>,
<a name="l02098"></a>02098                         kgnilnd_connreq_type2str(&amp;dgram-&gt;gndg_conn_in),
<a name="l02099"></a>02099                         dgram-&gt;gndg_conn_in.gncr_type,
<a name="l02100"></a>02100                         libcfs_nid2str(dgram-&gt;gndg_conn_in.gncr_srcnid));
<a name="l02101"></a>02101                 rc = -EINVAL;
<a name="l02102"></a>02102                 *needs_nak = 1;
<a name="l02103"></a>02103                 <span class="keywordflow">break</span>;
<a name="l02104"></a>02104         }
<a name="l02105"></a>02105 
<a name="l02106"></a>02106 connreq_out:
<a name="l02107"></a>02107         RETURN(rc);
<a name="l02108"></a>02108 }
<a name="l02109"></a>02109 
<a name="l02110"></a>02110 <span class="keywordtype">int</span>
<a name="l02111"></a>02111 kgnilnd_probe_and_process_dgram(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l02112"></a>02112 {
<a name="l02113"></a>02113         <span class="keywordtype">int</span>                      rc;
<a name="l02114"></a>02114         <span class="keywordtype">int</span>                      needs_nak = 0;
<a name="l02115"></a>02115         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>               nak_dstnid = <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>;
<a name="l02116"></a>02116         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>               orig_dstnid;
<a name="l02117"></a>02117         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>             *dgram = NULL;
<a name="l02118"></a>02118         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>              *peer;
<a name="l02119"></a>02119         ENTRY;
<a name="l02120"></a>02120 
<a name="l02121"></a>02121         <span class="keywordflow">if</span> (CFS_FAIL_CHECK(CFS_FAIL_GNI_PAUSE_DGRAM_COMP)) {
<a name="l02122"></a>02122                 rc = 0;
<a name="l02123"></a>02123         } <span class="keywordflow">else</span> {
<a name="l02124"></a>02124                 rc = kgnilnd_probe_for_dgram(dev, &amp;dgram);
<a name="l02125"></a>02125         }
<a name="l02126"></a>02126 
<a name="l02127"></a>02127         <span class="keywordflow">if</span> (rc == 0) {
<a name="l02128"></a>02128                 RETURN(0);
<a name="l02129"></a>02129         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02130"></a>02130                 GOTO(inform_peer, rc);
<a name="l02131"></a>02131         } <span class="keywordflow">else</span> {
<a name="l02132"></a>02132                 <span class="comment">/* rc &gt; 1 means it did something, reset for this func  */</span>
<a name="l02133"></a>02133                 rc = 0;
<a name="l02134"></a>02134         }
<a name="l02135"></a>02135 
<a name="l02136"></a>02136         <span class="keywordflow">switch</span> (dgram-&gt;gndg_type) {
<a name="l02137"></a>02137         <span class="keywordflow">case</span> GNILND_DGRAM_WC_REQ:
<a name="l02138"></a>02138         <span class="keywordflow">case</span> GNILND_DGRAM_REQ:
<a name="l02139"></a>02139                 rc = kgnilnd_process_connreq(dgram, &amp;needs_nak);
<a name="l02140"></a>02140                 <span class="keywordflow">break</span>;
<a name="l02141"></a>02141         <span class="keywordflow">case</span> GNILND_DGRAM_NAK:
<a name="l02142"></a>02142                 CDEBUG(D_NETTRACE, <span class="stringliteral">&quot;NAK to %s done\n&quot;</span>,
<a name="l02143"></a>02143                         libcfs_nid2str(dgram-&gt;gndg_conn_out.gncr_dstnid));
<a name="l02144"></a>02144                 <span class="keywordflow">break</span>;
<a name="l02145"></a>02145         <span class="keywordflow">default</span>:
<a name="l02146"></a>02146                 CERROR(<span class="stringliteral">&quot;unknown datagram type %s (%d)\n&quot;</span>,
<a name="l02147"></a>02147                        kgnilnd_dgram_type2str(dgram), dgram-&gt;gndg_type);
<a name="l02148"></a>02148                 <span class="keywordflow">break</span>;
<a name="l02149"></a>02149         }
<a name="l02150"></a>02150 
<a name="l02151"></a>02151         <span class="comment">/* stash data to use after releasing current datagram */</span>
<a name="l02152"></a>02152         <span class="comment">/* don&apos;t stash net - we are operating on a net already,</span>
<a name="l02153"></a>02153 <span class="comment">         * so the lock on rw_net_lock is sufficient */</span>
<a name="l02154"></a>02154 
<a name="l02155"></a>02155         nak_dstnid = dgram-&gt;gndg_conn_in.gncr_srcnid;
<a name="l02156"></a>02156 
<a name="l02157"></a>02157 inform_peer:
<a name="l02158"></a>02158         LASSERTF(dgram != NULL, <span class="stringliteral">&quot;dgram 0x%p rc %d needs_nak %d\n&quot;</span>, dgram, rc, needs_nak);
<a name="l02159"></a>02159 
<a name="l02160"></a>02160         orig_dstnid = dgram-&gt;gndg_conn_out.gncr_dstnid;
<a name="l02161"></a>02161 
<a name="l02162"></a>02162         kgnilnd_release_dgram(dev, dgram, 0);
<a name="l02163"></a>02163 
<a name="l02164"></a>02164         CDEBUG(D_NET, <span class="stringliteral">&quot;cleaning up dgram to %s, rc %d\n&quot;</span>,
<a name="l02165"></a>02165                libcfs_nid2str(orig_dstnid), rc);
<a name="l02166"></a>02166 
<a name="l02167"></a>02167         <span class="comment">/* if this was a WC_REQ that matched an existing peer, it&apos;ll get marked done</span>
<a name="l02168"></a>02168 <span class="comment">         * in kgnilnd_finish_connect - if errors are from before we get to there,</span>
<a name="l02169"></a>02169 <span class="comment">         * we just drop as it is a WC_REQ - the peer CAN&apos;T be waiting for it */</span>
<a name="l02170"></a>02170         <span class="keywordflow">if</span> ((orig_dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) &amp;&amp; (rc &lt; 0)) {
<a name="l02171"></a>02171                 <span class="comment">/* if we have a negative rc, we want to find a peer to inform about</span>
<a name="l02172"></a>02172 <span class="comment">                 * the bad connection attempt. Sorry buddy, better luck next time! */</span>
<a name="l02173"></a>02173 
<a name="l02174"></a>02174                 write_lock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l02175"></a>02175                 peer = kgnilnd_find_peer_locked(orig_dstnid);
<a name="l02176"></a>02176 
<a name="l02177"></a>02177                 <span class="keywordflow">if</span> (peer != NULL) {
<a name="l02178"></a>02178                         <span class="comment">/* add ref to make sure he stays around past the possible unlink</span>
<a name="l02179"></a>02179 <span class="comment">                         * so we can tell LNet about him */</span>
<a name="l02180"></a>02180                         kgnilnd_peer_addref(peer);
<a name="l02181"></a>02181 
<a name="l02182"></a>02182                         <span class="comment">/* if he still cares about the outstanding connect */</span>
<a name="l02183"></a>02183                         <span class="keywordflow">if</span> (peer-&gt;gnp_connecting &gt;= GNILND_PEER_CONNECT) {
<a name="l02184"></a>02184                                 <span class="comment">/* check if he is on the connd list and remove.. */</span>
<a name="l02185"></a>02185                                 spin_lock(&amp;peer-&gt;gnp_net-&gt;gnn_dev-&gt;gnd_connd_lock);
<a name="l02186"></a>02186                                 <span class="keywordflow">if</span> (!list_empty(&amp;peer-&gt;gnp_connd_list)) {
<a name="l02187"></a>02187                                         list_del_init(&amp;peer-&gt;gnp_connd_list);
<a name="l02188"></a>02188                                         <span class="comment">/* drop connd ref */</span>
<a name="l02189"></a>02189                                         kgnilnd_peer_decref(peer);
<a name="l02190"></a>02190                                 }
<a name="l02191"></a>02191                                 spin_unlock(&amp;peer-&gt;gnp_net-&gt;gnn_dev-&gt;gnd_connd_lock);
<a name="l02192"></a>02192 
<a name="l02193"></a>02193                                 <span class="comment">/* clear gnp_connecting so we don&apos;t have a non-connecting peer</span>
<a name="l02194"></a>02194 <span class="comment">                                 * on gnd_connd_list */</span>
<a name="l02195"></a>02195                                 peer-&gt;gnp_connecting = GNILND_PEER_IDLE;
<a name="l02196"></a>02196 
<a name="l02197"></a>02197                                 set_mb(peer-&gt;gnp_last_dgram_errno, rc);
<a name="l02198"></a>02198 
<a name="l02199"></a>02199                                 kgnilnd_peer_increase_reconnect_locked(peer);
<a name="l02200"></a>02200                         }
<a name="l02201"></a>02201                 }
<a name="l02202"></a>02202                 write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l02203"></a>02203 
<a name="l02204"></a>02204                 <span class="comment">/* now that we are outside the lock, tell Mommy */</span>
<a name="l02205"></a>02205                 <span class="keywordflow">if</span> (peer != NULL) {
<a name="l02206"></a>02206                         kgnilnd_peer_notify(peer, rc, 0);
<a name="l02207"></a>02207                         kgnilnd_peer_decref(peer);
<a name="l02208"></a>02208                 }
<a name="l02209"></a>02209         }
<a name="l02210"></a>02210 
<a name="l02211"></a>02211         <span class="keywordflow">if</span> (needs_nak) {
<a name="l02212"></a>02212                 kgnilnd_send_nak(dev, nak_dstnid, rc);
<a name="l02213"></a>02213         }
<a name="l02214"></a>02214 
<a name="l02215"></a>02215         RETURN(1);
<a name="l02216"></a>02216 }
<a name="l02217"></a>02217 
<a name="l02218"></a>02218 <span class="keywordtype">void</span>
<a name="l02219"></a>02219 kgnilnd_reaper_dgram_check(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l02220"></a>02220 {
<a name="l02221"></a>02221         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>    *dgram, *tmp;
<a name="l02222"></a>02222         <span class="keywordtype">int</span>             i;
<a name="l02223"></a>02223 
<a name="l02224"></a>02224         spin_lock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l02225"></a>02225 
<a name="l02226"></a>02226         <span class="keywordflow">for</span> (i = 0; i &lt; (*kgnilnd_tunables.kgn_peer_hash_size - 1); i++) {
<a name="l02227"></a>02227                 list_for_each_entry_safe(dgram, tmp, &amp;dev-&gt;gnd_dgrams[i], gndg_list) {
<a name="l02228"></a>02228                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            now = jiffies;
<a name="l02229"></a>02229                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            timeout;
<a name="l02230"></a>02230 
<a name="l02231"></a>02231                         <span class="comment">/* don&apos;t timeout stuff if the network is mucked or shutting down */</span>
<a name="l02232"></a>02232                         <span class="keywordflow">if</span> (kgnilnd_check_hw_quiesce()) {
<a name="l02233"></a>02233                                 <span class="keywordflow">break</span>;
<a name="l02234"></a>02234                         }
<a name="l02235"></a>02235 
<a name="l02236"></a>02236                         <span class="keywordflow">if</span> ((dgram-&gt;gndg_state != GNILND_DGRAM_POSTED) ||
<a name="l02237"></a>02237                             (dgram-&gt;gndg_type == GNILND_DGRAM_WC_REQ)) {
<a name="l02238"></a>02238                                 <span class="keywordflow">continue</span>;
<a name="l02239"></a>02239                         }
<a name="l02240"></a>02240                         CDEBUG(D_NETTRACE, <span class="stringliteral">&quot;checking dgram 0x%p type %s &quot;</span>
<a name="l02241"></a>02241                                 <span class="stringliteral">&quot;state %s conn 0x%p to %s age %lus\n&quot;</span>,
<a name="l02242"></a>02242                                 dgram, kgnilnd_dgram_type2str(dgram),
<a name="l02243"></a>02243                                 kgnilnd_dgram_state2str(dgram), dgram-&gt;gndg_conn,
<a name="l02244"></a>02244                                 libcfs_nid2str(dgram-&gt;gndg_conn_out.gncr_dstnid),
<a name="l02245"></a>02245                                 cfs_duration_sec(now - dgram-&gt;gndg_post_time));
<a name="l02246"></a>02246 
<a name="l02247"></a>02247                         timeout = cfs_time_seconds(*kgnilnd_tunables.kgn_timeout);
<a name="l02248"></a>02248 
<a name="l02249"></a>02249                         <span class="keywordflow">if</span> (time_before(now, (dgram-&gt;gndg_post_time + timeout)))
<a name="l02250"></a>02250                                 <span class="keywordflow">continue</span>;
<a name="l02251"></a>02251 
<a name="l02252"></a>02252                         CNETERR(<span class="stringliteral">&quot;%s datagram to %s timed out @ %lus dgram &quot;</span>
<a name="l02253"></a>02253                                 <span class="stringliteral">&quot;0x%p state %s conn 0x%p\n&quot;</span>,
<a name="l02254"></a>02254                                 kgnilnd_dgram_type2str(dgram),
<a name="l02255"></a>02255                                 libcfs_nid2str(dgram-&gt;gndg_conn_out.gncr_dstnid),
<a name="l02256"></a>02256                                 cfs_duration_sec(now - dgram-&gt;gndg_post_time),
<a name="l02257"></a>02257                                 dgram, kgnilnd_dgram_state2str(dgram),
<a name="l02258"></a>02258                                 dgram-&gt;gndg_conn);
<a name="l02259"></a>02259 
<a name="l02260"></a>02260                         kgnilnd_cancel_dgram_locked(dgram);
<a name="l02261"></a>02261                 }
<a name="l02262"></a>02262         }
<a name="l02263"></a>02263         spin_unlock(&amp;dev-&gt;gnd_dgram_lock);
<a name="l02264"></a>02264 }
<a name="l02265"></a>02265 
<a name="l02266"></a>02266 
<a name="l02267"></a>02267 <span class="comment">/* use a thread for the possibly long-blocking wait_by_id to prevent</span>
<a name="l02268"></a>02268 <span class="comment"> * stalling the global workqueues */</span>
<a name="l02269"></a>02269 <span class="keywordtype">int</span>
<a name="l02270"></a>02270 kgnilnd_dgram_waitq(<span class="keywordtype">void</span> *arg)
<a name="l02271"></a>02271 {
<a name="l02272"></a>02272         <a class="code" href="structkgn__device.html">kgn_device_t</a>     *dev = (<a class="code" href="structkgn__device.html">kgn_device_t</a> *) arg;
<a name="l02273"></a>02273         <span class="keywordtype">char</span>              name[16];
<a name="l02274"></a>02274         gni_return_t      grc;
<a name="l02275"></a>02275         __u64             readyid;
<a name="l02276"></a>02276         DEFINE_WAIT(mover_done);
<a name="l02277"></a>02277 
<a name="l02278"></a>02278         snprintf(name, <span class="keyword">sizeof</span>(name), <span class="stringliteral">&quot;kgnilnd_dgn_%02d&quot;</span>, dev-&gt;gnd_id);
<a name="l02279"></a>02279         cfs_block_allsigs();
<a name="l02280"></a>02280 
<a name="l02281"></a>02281         <span class="comment">/* all gnilnd threads need to run fairly urgently */</span>
<a name="l02282"></a>02282         set_user_nice(current, *kgnilnd_tunables.kgn_nice);
<a name="l02283"></a>02283 
<a name="l02284"></a>02284         <span class="comment">/* we dont shut down until the device shuts down ... */</span>
<a name="l02285"></a>02285         <span class="keywordflow">while</span> (!kgnilnd_data.kgn_shutdown) {
<a name="l02286"></a>02286                 <span class="comment">/* to quiesce or to not quiesce, that is the question */</span>
<a name="l02287"></a>02287                 <span class="keywordflow">if</span> (unlikely(kgnilnd_data.kgn_quiesce_trigger)) {
<a name="l02288"></a>02288                         KGNILND_SPIN_QUIESCE;
<a name="l02289"></a>02289                 }
<a name="l02290"></a>02290 
<a name="l02291"></a>02291                 <span class="keywordflow">while</span> (CFS_FAIL_TIMEOUT(CFS_FAIL_GNI_PAUSE_DGRAM_COMP, 1)) {}
<a name="l02292"></a>02292 
<a name="l02293"></a>02293                 <span class="comment">/* check once a second */</span>
<a name="l02294"></a>02294                 grc = kgnilnd_postdata_probe_wait_by_id(dev-&gt;gnd_handle,
<a name="l02295"></a>02295                                                        1000, &amp;readyid);
<a name="l02296"></a>02296 
<a name="l02297"></a>02297                 <span class="keywordflow">if</span> (grc == GNI_RC_SUCCESS) {
<a name="l02298"></a>02298                         CDEBUG(D_INFO, <span class="stringliteral">&quot;waking up dgram mover thread\n&quot;</span>);
<a name="l02299"></a>02299                         kgnilnd_schedule_dgram(dev);
<a name="l02300"></a>02300 
<a name="l02301"></a>02301                         <span class="comment">/* wait for dgram thread to ping us before spinning again */</span>
<a name="l02302"></a>02302                         prepare_to_wait(&amp;dev-&gt;gnd_dgping_waitq, &amp;mover_done,
<a name="l02303"></a>02303                                         TASK_INTERRUPTIBLE);
<a name="l02304"></a>02304 
<a name="l02305"></a>02305                         <span class="comment">/* don&apos;t sleep if we need to quiesce */</span>
<a name="l02306"></a>02306                         <span class="keywordflow">if</span> (likely(!kgnilnd_data.kgn_quiesce_trigger)) {
<a name="l02307"></a>02307                                 schedule();
<a name="l02308"></a>02308                         }
<a name="l02309"></a>02309                         finish_wait(&amp;dev-&gt;gnd_dgping_waitq, &amp;mover_done);
<a name="l02310"></a>02310                 }
<a name="l02311"></a>02311         }
<a name="l02312"></a>02312 
<a name="l02313"></a>02313         kgnilnd_thread_fini();
<a name="l02314"></a>02314         <span class="keywordflow">return</span> 0;
<a name="l02315"></a>02315 }
<a name="l02316"></a>02316 
<a name="l02317"></a>02317 <span class="keywordtype">int</span>
<a name="l02318"></a>02318 kgnilnd_start_outbound_dgrams(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> deadline)
<a name="l02319"></a>02319 {
<a name="l02320"></a>02320         <span class="keywordtype">int</span>                      did_something = 0, rc;
<a name="l02321"></a>02321         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>              *peer = NULL;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323         spin_lock(&amp;dev-&gt;gnd_connd_lock);
<a name="l02324"></a>02324 
<a name="l02325"></a>02325         <span class="comment">/* Active connect - we added this in kgnilnd_launch_tx */</span>
<a name="l02326"></a>02326         <span class="keywordflow">while</span> (!list_empty(&amp;dev-&gt;gnd_connd_peers) &amp;&amp; time_before(jiffies, deadline)) {
<a name="l02327"></a>02327                 peer = list_first_entry(&amp;dev-&gt;gnd_connd_peers,
<a name="l02328"></a>02328                                         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>, gnp_connd_list);
<a name="l02329"></a>02329 
<a name="l02330"></a>02330                 <span class="comment">/* ref for connd removed in if/else below */</span>
<a name="l02331"></a>02331                list_del_init(&amp;peer-&gt;gnp_connd_list);
<a name="l02332"></a>02332 
<a name="l02333"></a>02333                 <span class="comment">/* gnp_connecting and membership on gnd_connd_peers should be</span>
<a name="l02334"></a>02334 <span class="comment">                 * done coherently to avoid double adding, etc */</span>
<a name="l02335"></a>02335                 <span class="comment">/* don&apos;t need kgnilnd_data.kgn_peer_conn_lock here as that is only needed</span>
<a name="l02336"></a>02336 <span class="comment">                 * to get the peer to gnp_connecting in the first place. We just need to</span>
<a name="l02337"></a>02337 <span class="comment">                 * rely on gnd_connd_lock to serialize someone pulling him from the list</span>
<a name="l02338"></a>02338 <span class="comment">                 * BEFORE clearing gnp_connecting */</span>
<a name="l02339"></a>02339                 LASSERTF(peer-&gt;gnp_connecting != GNILND_PEER_IDLE, <span class="stringliteral">&quot;peer 0x%p-&gt;%s not connecting\n&quot;</span>,
<a name="l02340"></a>02340                          peer, libcfs_nid2str(peer-&gt;gnp_nid));
<a name="l02341"></a>02341 
<a name="l02342"></a>02342                 spin_unlock(&amp;dev-&gt;gnd_connd_lock);
<a name="l02343"></a>02343 
<a name="l02344"></a>02344                 CDEBUG(D_NET, <span class="stringliteral">&quot;processing connect to %s\n&quot;</span>,
<a name="l02345"></a>02345                        libcfs_nid2str(peer-&gt;gnp_nid));
<a name="l02346"></a>02346 
<a name="l02347"></a>02347                 did_something += 1;
<a name="l02348"></a>02348                 rc = kgnilnd_start_connect(peer);
<a name="l02349"></a>02349 
<a name="l02350"></a>02350                 <span class="keywordflow">if</span> (likely(rc &gt;= 0)) {
<a name="l02351"></a>02351                         <span class="comment">/* 0 on success, positive on &apos;just drop peer&apos; errors */</span>
<a name="l02352"></a>02352                         kgnilnd_peer_decref(peer);
<a name="l02353"></a>02353                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == -ENOMEM) {
<a name="l02354"></a>02354                         <span class="comment">/* if we are out of wildcards, add back to</span>
<a name="l02355"></a>02355 <span class="comment">                         * connd_list - then break out and we&apos;ll try later</span>
<a name="l02356"></a>02356 <span class="comment">                         * if other errors, we&apos;ll bail &amp; cancel pending tx */</span>
<a name="l02357"></a>02357                         write_lock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l02358"></a>02358                         <span class="keywordflow">if</span> (peer-&gt;gnp_connecting == GNILND_PEER_POSTING) {
<a name="l02359"></a>02359                                 peer-&gt;gnp_connecting = GNILND_PEER_CONNECT;
<a name="l02360"></a>02360                                 spin_lock(&amp;dev-&gt;gnd_connd_lock);
<a name="l02361"></a>02361                                 list_add_tail(&amp;peer-&gt;gnp_connd_list,
<a name="l02362"></a>02362                                               &amp;dev-&gt;gnd_connd_peers);
<a name="l02363"></a>02363                         } <span class="keywordflow">else</span> {
<a name="l02364"></a>02364                                 <span class="comment">/* connecting changed while we were posting */</span>
<a name="l02365"></a>02365 
<a name="l02366"></a>02366                                 LASSERTF(peer-&gt;gnp_connecting == GNILND_PEER_NEEDS_DEATH, <span class="stringliteral">&quot;Peer is in invalid&quot;</span>
<a name="l02367"></a>02367                                         <span class="stringliteral">&quot; state 0x%p-&gt;%s, connecting %d\n&quot;</span>,
<a name="l02368"></a>02368                                         peer, libcfs_nid2str(peer-&gt;gnp_nid), peer-&gt;gnp_connecting);
<a name="l02369"></a>02369                                 peer-&gt;gnp_connecting = GNILND_PEER_KILL;
<a name="l02370"></a>02370                                 spin_lock(&amp;dev-&gt;gnd_connd_lock);
<a name="l02371"></a>02371                                 <span class="comment">/* remove the peer ref frrom the cond list */</span>
<a name="l02372"></a>02372                                 kgnilnd_peer_decref(peer);
<a name="l02373"></a>02373                                 <span class="comment">/* let the system handle itself */</span>
<a name="l02374"></a>02374                         }
<a name="l02375"></a>02375                         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l02376"></a>02376                         <span class="comment">/* the datagrams are a global pool,</span>
<a name="l02377"></a>02377 <span class="comment">                         * so break out of trying and hope some free</span>
<a name="l02378"></a>02378 <span class="comment">                         * up soon */</span>
<a name="l02379"></a>02379                         did_something -= 1;
<a name="l02380"></a>02380                         <span class="keywordflow">break</span>;
<a name="l02381"></a>02381                 } <span class="keywordflow">else</span> {
<a name="l02382"></a>02382                         <span class="comment">/* something bad happened, you lose */</span>
<a name="l02383"></a>02383                         CNETERR(<span class="stringliteral">&quot;could not start connecting to %s &quot;</span>
<a name="l02384"></a>02384                                 <span class="stringliteral">&quot;rc %d: Will retry until TX timeout\n&quot;</span>,
<a name="l02385"></a>02385                                libcfs_nid2str(peer-&gt;gnp_nid), rc);
<a name="l02386"></a>02386                         <span class="comment">/* It didnt post so just set connecting back to zero now.</span>
<a name="l02387"></a>02387 <span class="comment">                         * The reaper will reattempt the connection if it needs too.</span>
<a name="l02388"></a>02388 <span class="comment">                         * If the peer needs death set it so the reaper will cleanup.</span>
<a name="l02389"></a>02389 <span class="comment">                         */</span>
<a name="l02390"></a>02390                         write_lock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l02391"></a>02391                         <span class="keywordflow">if</span> (peer-&gt;gnp_connecting == GNILND_PEER_POSTING) {
<a name="l02392"></a>02392                                 peer-&gt;gnp_connecting = GNILND_PEER_IDLE;
<a name="l02393"></a>02393                                 kgnilnd_peer_increase_reconnect_locked(peer);
<a name="l02394"></a>02394                         } <span class="keywordflow">else</span> {
<a name="l02395"></a>02395                                 LASSERTF(peer-&gt;gnp_connecting == GNILND_PEER_NEEDS_DEATH, <span class="stringliteral">&quot;Peer is in invalid&quot;</span>
<a name="l02396"></a>02396                                         <span class="stringliteral">&quot; state 0x%p-&gt;%s, connecting %d\n&quot;</span>,
<a name="l02397"></a>02397                                         peer, libcfs_nid2str(peer-&gt;gnp_nid), peer-&gt;gnp_connecting);
<a name="l02398"></a>02398                                 peer-&gt;gnp_connecting = GNILND_PEER_KILL;
<a name="l02399"></a>02399                         }
<a name="l02400"></a>02400                         write_unlock(&amp;kgnilnd_data.kgn_peer_conn_lock);
<a name="l02401"></a>02401 
<a name="l02402"></a>02402                         <span class="comment">/* hold onto ref until we are really done - if it was</span>
<a name="l02403"></a>02403 <span class="comment">                         * unlinked this could result in a destroy */</span>
<a name="l02404"></a>02404                         kgnilnd_peer_decref(peer);
<a name="l02405"></a>02405                 }
<a name="l02406"></a>02406                 spin_lock(&amp;dev-&gt;gnd_connd_lock);
<a name="l02407"></a>02407         }
<a name="l02408"></a>02408 
<a name="l02409"></a>02409         spin_unlock(&amp;dev-&gt;gnd_connd_lock);
<a name="l02410"></a>02410         RETURN(did_something);
<a name="l02411"></a>02411 }
<a name="l02412"></a>02412 
<a name="l02413"></a>02413 <span class="keywordtype">int</span>
<a name="l02414"></a>02414 kgnilnd_repost_wc_dgrams(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l02415"></a>02415 {
<a name="l02416"></a>02416         <span class="keywordtype">int</span> did_something = 0, to_repost, i;
<a name="l02417"></a>02417         to_repost = atomic_read(&amp;dev-&gt;gnd_nwcdgrams);
<a name="l02418"></a>02418         ENTRY;
<a name="l02419"></a>02419 
<a name="l02420"></a>02420         <span class="keywordflow">for</span> (i = 0; i &lt; to_repost; ++i) {
<a name="l02421"></a>02421                 <span class="keywordtype">int</span>     rerc;
<a name="l02422"></a>02422                 rerc = kgnilnd_post_dgram(dev, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, GNILND_CONNREQ_REQ, 0);
<a name="l02423"></a>02423                 <span class="keywordflow">if</span> (rerc == 0) {
<a name="l02424"></a>02424                         kgnilnd_admin_decref(dev-&gt;gnd_nwcdgrams);
<a name="l02425"></a>02425                         did_something += 1;
<a name="l02426"></a>02426                 } <span class="keywordflow">else</span> {
<a name="l02427"></a>02427                         CDEBUG(D_NETERROR, <span class="stringliteral">&quot;error %d: dev %d could not post wildcard datagram\n&quot;</span>,
<a name="l02428"></a>02428                                 rerc, dev-&gt;gnd_id);
<a name="l02429"></a>02429                         <span class="keywordflow">break</span>;
<a name="l02430"></a>02430                 }
<a name="l02431"></a>02431         }
<a name="l02432"></a>02432 
<a name="l02433"></a>02433         RETURN(did_something);
<a name="l02434"></a>02434 }
<a name="l02435"></a>02435 
<a name="l02436"></a>02436 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02437"></a>02437 kgnilnd_dgram_poke_with_stick(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
<a name="l02438"></a>02438 {
<a name="l02439"></a>02439         <span class="keywordtype">int</span>             dev_id = arg;
<a name="l02440"></a>02440         <a class="code" href="structkgn__device.html">kgn_device_t</a>    *dev = &amp;kgnilnd_data.kgn_devices[dev_id];
<a name="l02441"></a>02441 
<a name="l02442"></a>02442         wake_up(&amp;dev-&gt;gnd_dgram_waitq);
<a name="l02443"></a>02443 }
<a name="l02444"></a>02444 
<a name="l02445"></a>02445 <span class="comment">/* use single thread for dgrams - should be sufficient for performance */</span>
<a name="l02446"></a>02446 <span class="keywordtype">int</span>
<a name="l02447"></a>02447 kgnilnd_dgram_mover(<span class="keywordtype">void</span> *arg)
<a name="l02448"></a>02448 {
<a name="l02449"></a>02449         <a class="code" href="structkgn__device.html">kgn_device_t</a>            *dev = (<a class="code" href="structkgn__device.html">kgn_device_t</a> *)arg;
<a name="l02450"></a>02450         <span class="keywordtype">char</span>                     name[16];
<a name="l02451"></a>02451         <span class="keywordtype">int</span>                      rc, did_something;
<a name="l02452"></a>02452         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            next_purge_check = jiffies - 1;
<a name="l02453"></a>02453         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            timeout;
<a name="l02454"></a>02454         <span class="keyword">struct </span>timer_list        timer;
<a name="l02455"></a>02455         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            deadline = 0;
<a name="l02456"></a>02456         DEFINE_WAIT(wait);
<a name="l02457"></a>02457 
<a name="l02458"></a>02458         snprintf(name, <span class="keyword">sizeof</span>(name), <span class="stringliteral">&quot;kgnilnd_dg_%02d&quot;</span>, dev-&gt;gnd_id);
<a name="l02459"></a>02459         cfs_block_allsigs();
<a name="l02460"></a>02460         <span class="comment">/* all gnilnd threads need to run fairly urgently */</span>
<a name="l02461"></a>02461         set_user_nice(current, *kgnilnd_tunables.kgn_nice);
<a name="l02462"></a>02462 
<a name="l02463"></a>02463         <span class="comment">/* we are ok not locking for these variables as the dgram waitq threads</span>
<a name="l02464"></a>02464 <span class="comment">         * will block both due to tying up net (kgn_shutdown) and the completion</span>
<a name="l02465"></a>02465 <span class="comment">         * event for the dgram_waitq (kgn_quiesce_trigger) */</span>
<a name="l02466"></a>02466         deadline = jiffies + cfs_time_seconds(*kgnilnd_tunables.kgn_dgram_timeout);
<a name="l02467"></a>02467         <span class="keywordflow">while</span> (!kgnilnd_data.kgn_shutdown) {
<a name="l02468"></a>02468                 <span class="comment">/* Safe: kgn_shutdown only set when quiescent */</span>
<a name="l02469"></a>02469 
<a name="l02470"></a>02470                 <span class="comment">/* race with stack reset - we want to hold off seeing any new incoming dgrams</span>
<a name="l02471"></a>02471 <span class="comment">                 * so we can force a dirty WC dgram for Bug 762072 - put right before</span>
<a name="l02472"></a>02472 <span class="comment">                 * quiesce check so that it&apos;ll go right into that and not do any</span>
<a name="l02473"></a>02473 <span class="comment">                 * dgram mucking */</span>
<a name="l02474"></a>02474                 CFS_RACE(CFS_FAIL_GNI_WC_DGRAM_FREE);
<a name="l02475"></a>02475 
<a name="l02476"></a>02476                 <span class="comment">/* to quiesce or to not quiesce, that is the question */</span>
<a name="l02477"></a>02477                 <span class="keywordflow">if</span> (unlikely(kgnilnd_data.kgn_quiesce_trigger)) {
<a name="l02478"></a>02478                         KGNILND_SPIN_QUIESCE;
<a name="l02479"></a>02479                 }
<a name="l02480"></a>02480                 did_something = 0;
<a name="l02481"></a>02481 
<a name="l02482"></a>02482                 CFS_RACE(CFS_FAIL_GNI_QUIESCE_RACE);
<a name="l02483"></a>02483 
<a name="l02484"></a>02484                 <span class="comment">/* process any newly completed dgrams */</span>
<a name="l02485"></a>02485                 down_read(&amp;kgnilnd_data.kgn_net_rw_sem);
<a name="l02486"></a>02486 
<a name="l02487"></a>02487                 rc = kgnilnd_probe_and_process_dgram(dev);
<a name="l02488"></a>02488                 <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l02489"></a>02489                         did_something += rc;
<a name="l02490"></a>02490                 }
<a name="l02491"></a>02491 
<a name="l02492"></a>02492                 up_read(&amp;kgnilnd_data.kgn_net_rw_sem);
<a name="l02493"></a>02493 
<a name="l02494"></a>02494                 CFS_FAIL_TIMEOUT(CFS_FAIL_GNI_DGRAM_DEADLINE,
<a name="l02495"></a>02495                         (*kgnilnd_tunables.kgn_dgram_timeout + 1));
<a name="l02496"></a>02496                 <span class="comment">/* start new outbound dgrams */</span>
<a name="l02497"></a>02497                 did_something += kgnilnd_start_outbound_dgrams(dev, deadline);
<a name="l02498"></a>02498 
<a name="l02499"></a>02499                 <span class="comment">/* find dead dgrams */</span>
<a name="l02500"></a>02500                 <span class="keywordflow">if</span> (time_after_eq(jiffies, next_purge_check)) {
<a name="l02501"></a>02501                         <span class="comment">/* these don&apos;t need to be checked that often */</span>
<a name="l02502"></a>02502                         kgnilnd_reaper_dgram_check(dev);
<a name="l02503"></a>02503 
<a name="l02504"></a>02504                         next_purge_check = (long) jiffies +
<a name="l02505"></a>02505                                       cfs_time_seconds(kgnilnd_data.kgn_new_min_timeout / 4);
<a name="l02506"></a>02506                 }
<a name="l02507"></a>02507 
<a name="l02508"></a>02508                 did_something += kgnilnd_repost_wc_dgrams(dev);
<a name="l02509"></a>02509 
<a name="l02510"></a>02510                 <span class="comment">/* careful with the jiffy wrap... */</span>
<a name="l02511"></a>02511                 timeout = (long)(next_purge_check - jiffies);
<a name="l02512"></a>02512 
<a name="l02513"></a>02513                 CDEBUG(D_INFO, <span class="stringliteral">&quot;did %d timeout %lu next %lu jiffies %lu\n&quot;</span>,
<a name="l02514"></a>02514                        did_something, timeout, next_purge_check, jiffies);
<a name="l02515"></a>02515 
<a name="l02516"></a>02516                 <span class="keywordflow">if</span> ((did_something || timeout &lt;= 0) &amp;&amp; time_before(jiffies, deadline)) {
<a name="l02517"></a>02517                         did_something = 0;
<a name="l02518"></a>02518                         <span class="keywordflow">continue</span>;
<a name="l02519"></a>02519                 }
<a name="l02520"></a>02520 
<a name="l02521"></a>02521                 prepare_to_wait(&amp;dev-&gt;gnd_dgram_waitq, &amp;wait, TASK_INTERRUPTIBLE);
<a name="l02522"></a>02522 
<a name="l02523"></a>02523                 setup_timer(&amp;timer, kgnilnd_dgram_poke_with_stick, dev-&gt;gnd_id);
<a name="l02524"></a>02524                 mod_timer(&amp;timer, (<span class="keywordtype">long</span>) jiffies + timeout);
<a name="l02525"></a>02525 
<a name="l02526"></a>02526                 <span class="comment">/* last second chance for others to poke us */</span>
<a name="l02527"></a>02527                 did_something += xchg(&amp;dev-&gt;gnd_dgram_ready, GNILND_DGRAM_IDLE);
<a name="l02528"></a>02528 
<a name="l02529"></a>02529                 <span class="comment">/* check flag variables before committing even if we</span>
<a name="l02530"></a>02530 <span class="comment">                 * did something; if we are after the deadline call</span>
<a name="l02531"></a>02531 <span class="comment">                 * schedule */</span>
<a name="l02532"></a>02532                 <span class="keywordflow">if</span> ((!did_something || time_after(jiffies, deadline)) &amp;&amp;
<a name="l02533"></a>02533                     !kgnilnd_data.kgn_shutdown &amp;&amp;
<a name="l02534"></a>02534                     !kgnilnd_data.kgn_quiesce_trigger) {
<a name="l02535"></a>02535                         CDEBUG(D_INFO, <span class="stringliteral">&quot;schedule timeout %ld (%lu sec)\n&quot;</span>,
<a name="l02536"></a>02536                                timeout, cfs_duration_sec(timeout));
<a name="l02537"></a>02537                         wake_up_all(&amp;dev-&gt;gnd_dgping_waitq);
<a name="l02538"></a>02538                         schedule();
<a name="l02539"></a>02539                         CDEBUG(D_INFO, <span class="stringliteral">&quot;awake after schedule\n&quot;</span>);
<a name="l02540"></a>02540                         deadline = jiffies + cfs_time_seconds(*kgnilnd_tunables.kgn_dgram_timeout);
<a name="l02541"></a>02541                 }
<a name="l02542"></a>02542 
<a name="l02543"></a>02543                 del_singleshot_timer_sync(&amp;timer);
<a name="l02544"></a>02544                 finish_wait(&amp;dev-&gt;gnd_dgram_waitq, &amp;wait);
<a name="l02545"></a>02545         }
<a name="l02546"></a>02546 
<a name="l02547"></a>02547         kgnilnd_thread_fini();
<a name="l02548"></a>02548         <span class="keywordflow">return</span> 0;
<a name="l02549"></a>02549 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:11 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
