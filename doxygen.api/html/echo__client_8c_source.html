<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/obdecho/echo_client.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/obdecho/echo_client.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> */</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_ECHO</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;linux/user_namespace.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#ifdef HAVE_UIDGID_HEADER</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor"># include &lt;linux/uidgid.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#endif</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#include &lt;libcfs/libcfs.h&gt;</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;obd.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;obd_support.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;lustre_debug.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;lprocfs_status.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;cl_object.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;lustre_fid.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;lustre_acl.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;lustre_ioctl.h&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;lustre_net.h&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor"># include &lt;md_object.h&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;echo_internal.h&quot;</span>
<a name="l00060"></a>00060 
<a name="l00065"></a>00065 <span class="keyword">struct </span>echo_device {
<a name="l00066"></a>00066         <span class="keyword">struct </span><a class="code" href="structcl__device.html" title="Device in the client stack.">cl_device</a>          ed_cl;
<a name="l00067"></a>00067         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a>   *ed_ec;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         <span class="keyword">struct </span><a class="code" href="structcl__site.html" title="Client-side site.">cl_site</a>            ed_site_myself;
<a name="l00070"></a>00070         <span class="keyword">struct </span><a class="code" href="structlu__site.html" title="lu_site is a &amp;quot;compartment&amp;quot; within which objects are unique, and LRU discipline...">lu_site</a>           *ed_site;
<a name="l00071"></a>00071         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>         *ed_next;
<a name="l00072"></a>00072         <span class="keywordtype">int</span>                       ed_next_ismd;
<a name="l00073"></a>00073         <span class="keyword">struct </span><a class="code" href="structlu__client__seq.html">lu_client_seq</a>     *ed_cl_seq;
<a name="l00074"></a>00074 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structlocal__oid__storage.html">local_oid_storage</a> *ed_los;
<a name="l00076"></a>00076         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             ed_root_fid;
<a name="l00077"></a>00077 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
<a name="l00078"></a>00078 };
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keyword">struct </span>echo_object {
<a name="l00081"></a>00081         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>        eo_cl;
<a name="l00082"></a>00082         <span class="keyword">struct </span><a class="code" href="structcl__object__header.html" title="Extended header for client object.">cl_object_header</a> eo_hdr;
<a name="l00083"></a>00083         <span class="keyword">struct </span>echo_device     *eo_dev;
<a name="l00084"></a>00084         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        eo_obj_chain;
<a name="l00085"></a>00085         <span class="keyword">struct </span><a class="code" href="structlov__oinfo.html">lov_oinfo</a>       *eo_oinfo;
<a name="l00086"></a>00086         atomic_t                eo_npages;
<a name="l00087"></a>00087         <span class="keywordtype">int</span>                     eo_deleted;
<a name="l00088"></a>00088 };
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="keyword">struct </span>echo_object_conf {
<a name="l00091"></a>00091         <span class="keyword">struct </span><a class="code" href="structcl__object__conf.html" title="Description of the client object configuration.">cl_object_conf</a>   eoc_cl;
<a name="l00092"></a>00092         <span class="keyword">struct </span><a class="code" href="structlov__oinfo.html">lov_oinfo</a>      **eoc_oinfo;
<a name="l00093"></a>00093 };
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="keyword">struct </span>echo_page {
<a name="l00096"></a>00096         <span class="keyword">struct </span><a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a>    ep_cl;
<a name="l00097"></a>00097         <span class="keyword">struct </span>mutex            ep_lock;
<a name="l00098"></a>00098 };
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="keyword">struct </span>echo_lock {
<a name="l00101"></a>00101         <span class="keyword">struct </span><a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a>    el_cl;
<a name="l00102"></a>00102         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        el_chain;
<a name="l00103"></a>00103         <span class="keyword">struct </span>echo_object     *el_object;
<a name="l00104"></a>00104         __u64                   el_cookie;
<a name="l00105"></a>00105         atomic_t                el_refcount;
<a name="l00106"></a>00106 };
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> echo_md_root_dir_name[] = <span class="stringliteral">&quot;ROOT_ECHO&quot;</span>;
<a name="l00110"></a>00110 
<a name="l00115"></a>00115 <span class="keyword">struct </span>echo_md_device {
<a name="l00116"></a>00116         <span class="keyword">struct </span><a class="code" href="structmd__device.html">md_device</a>                 emd_md_dev;
<a name="l00117"></a>00117         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>               *emd_child_exp;
<a name="l00118"></a>00118         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *emd_child;
<a name="l00119"></a>00119         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *emd_bottom;
<a name="l00120"></a>00120         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>                    emd_root_fid;
<a name="l00121"></a>00121         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>                    emd_local_root_fid;
<a name="l00122"></a>00122 };
<a name="l00123"></a>00123 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_client_setup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00126"></a>00126                              <span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev,
<a name="l00127"></a>00127                              <span class="keyword">struct</span> <a class="code" href="structlustre__cfg.html">lustre_cfg</a> *lcfg);
<a name="l00128"></a>00128 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_client_cleanup(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 
<a name="l00134"></a>00134 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>echo_device *cl2echo_dev(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__device.html" title="Device in the client stack.">cl_device</a> *dev)
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136         <span class="keywordflow">return</span> container_of0(dev, <span class="keyword">struct</span> echo_device, ed_cl);
<a name="l00137"></a>00137 }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structcl__device.html" title="Device in the client stack.">cl_device</a> *echo_dev2cl(<span class="keyword">struct</span> echo_device *d)
<a name="l00140"></a>00140 {
<a name="l00141"></a>00141         <span class="keywordflow">return</span> &amp;d-&gt;ed_cl;
<a name="l00142"></a>00142 }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>echo_device *obd2echo_dev(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd)
<a name="l00145"></a>00145 {
<a name="l00146"></a>00146         <span class="keywordflow">return</span> cl2echo_dev(lu2cl_dev(obd-&gt;obd_lu_dev));
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *echo_obj2cl(<span class="keyword">struct</span> echo_object *eco)
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151         <span class="keywordflow">return</span> &amp;eco-&gt;eo_cl;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>echo_object *cl2echo_obj(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *o)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156         <span class="keywordflow">return</span> container_of(o, <span class="keyword">struct</span> echo_object, eo_cl);
<a name="l00157"></a>00157 }
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>echo_page *cl2echo_page(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *s)
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161         <span class="keywordflow">return</span> container_of(s, <span class="keyword">struct</span> echo_page, ep_cl);
<a name="l00162"></a>00162 }
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>echo_lock *cl2echo_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *s)
<a name="l00165"></a>00165 {
<a name="l00166"></a>00166         <span class="keywordflow">return</span> container_of(s, <span class="keyword">struct</span> echo_lock, el_cl);
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *echo_lock2cl(<span class="keyword">const</span> <span class="keyword">struct</span> echo_lock *ecl)
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171         <span class="keywordflow">return</span> ecl-&gt;el_cl.cls_lock;
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> echo_thread_key;
<a name="l00175"></a>00175 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>echo_thread_info *echo_env_info(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l00176"></a>00176 {
<a name="l00177"></a>00177         <span class="keyword">struct </span>echo_thread_info *info;
<a name="l00178"></a>00178         info = <a class="code" href="group__lu.html#ga8fcebe57d8fb288a73a39144693074af" title="Return value associated with key key in context ctx.">lu_context_key_get</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>, &amp;echo_thread_key);
<a name="l00179"></a>00179         LASSERT(info != NULL);
<a name="l00180"></a>00180         <span class="keywordflow">return</span> info;
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00184"></a>00184 <span class="keyword">struct </span>echo_object_conf *cl2echo_conf(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__object__conf.html" title="Description of the client object configuration.">cl_object_conf</a> *c)
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186         <span class="keywordflow">return</span> container_of(c, <span class="keyword">struct</span> echo_object_conf, eoc_cl);
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>echo_md_device *lu2emd_dev(<span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *d)
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192         <span class="keywordflow">return</span> container_of0(d, <span class="keyword">struct</span> echo_md_device, emd_md_dev.md_lu_dev);
<a name="l00193"></a>00193 }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *emd2lu_dev(<span class="keyword">struct</span> echo_md_device *d)
<a name="l00196"></a>00196 {
<a name="l00197"></a>00197         <span class="keywordflow">return</span> &amp;d-&gt;emd_md_dev.md_lu_dev;
<a name="l00198"></a>00198 }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structseq__server__site.html">seq_server_site</a> *echo_md_seq_site(<span class="keyword">struct</span> echo_md_device *d)
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202         <span class="keywordflow">return</span> emd2lu_dev(d)-&gt;ld_site-&gt;ld_seq_site;
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *emd2obd_dev(<span class="keyword">struct</span> echo_md_device *d)
<a name="l00206"></a>00206 {
<a name="l00207"></a>00207         <span class="keywordflow">return</span> d-&gt;emd_md_dev.md_lu_dev.ld_obd;
<a name="l00208"></a>00208 }
<a name="l00209"></a>00209 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
<a name="l00210"></a>00210 
<a name="l00213"></a>00213 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_echo_object_put(<span class="keyword">struct</span> echo_object *eco);
<a name="l00214"></a>00214 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_echo_object_brw(<span class="keyword">struct</span> echo_object *eco, <span class="keywordtype">int</span> rw, u64 offset,
<a name="l00215"></a>00215                               <span class="keyword">struct</span> page **pages, <span class="keywordtype">int</span> npages, <span class="keywordtype">int</span> async);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="keyword">struct </span>echo_thread_info {
<a name="l00218"></a>00218         <span class="keyword">struct </span>echo_object_conf eti_conf;
<a name="l00219"></a>00219         <span class="keyword">struct </span><a class="code" href="structlustre__md.html">lustre_md</a>        eti_md;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         <span class="keyword">struct </span><a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a>        eti_queue;
<a name="l00222"></a>00222         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>            eti_io;
<a name="l00223"></a>00223         <span class="keyword">struct </span><a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>          eti_lock;
<a name="l00224"></a>00224         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           eti_fid;
<a name="l00225"></a>00225         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           eti_fid2;
<a name="l00226"></a>00226 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a>       eti_spec;
<a name="l00228"></a>00228         <span class="keyword">struct </span><a class="code" href="structlov__mds__md__v3.html">lov_mds_md_v3</a>    eti_lmm;
<a name="l00229"></a>00229         <span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a>   eti_lum;
<a name="l00230"></a>00230         <span class="keyword">struct </span><a class="code" href="structmd__attr.html">md_attr</a>          eti_ma;
<a name="l00231"></a>00231         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          eti_lname;
<a name="l00232"></a>00232         <span class="comment">/* per-thread values, can be re-used */</span>
<a name="l00233"></a>00233         <span class="keywordtype">void</span>                    *eti_big_lmm; <span class="comment">/* may be vmalloc&apos;d */</span>
<a name="l00234"></a>00234         <span class="keywordtype">int</span>                     eti_big_lmmsize;
<a name="l00235"></a>00235         <span class="keywordtype">char</span>                    eti_name[20];
<a name="l00236"></a>00236         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           eti_buf;
<a name="l00237"></a>00237         <span class="keywordtype">char</span>                    eti_xattr_buf[LUSTRE_POSIX_ACL_MAX_SIZE];
<a name="l00238"></a>00238 <span class="preprocessor">#endif</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span>};
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="comment">/* No session used right now */</span>
<a name="l00242"></a>00242 <span class="keyword">struct </span>echo_session_info {
<a name="l00243"></a>00243         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy;
<a name="l00244"></a>00244 };
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="keyword">static</span> <span class="keyword">struct </span>kmem_cache *echo_lock_kmem;
<a name="l00247"></a>00247 <span class="keyword">static</span> <span class="keyword">struct </span>kmem_cache *echo_object_kmem;
<a name="l00248"></a>00248 <span class="keyword">static</span> <span class="keyword">struct </span>kmem_cache *echo_thread_kmem;
<a name="l00249"></a>00249 <span class="keyword">static</span> <span class="keyword">struct </span>kmem_cache *echo_session_kmem;
<a name="l00250"></a>00250 <span class="comment">/* static struct kmem_cache *echo_req_kmem; */</span>
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__kmem__descr.html">lu_kmem_descr</a> echo_caches[] = {
<a name="l00253"></a>00253         {
<a name="l00254"></a>00254                 .ckd_cache = &amp;echo_lock_kmem,
<a name="l00255"></a>00255                 .ckd_name  = <span class="stringliteral">&quot;echo_lock_kmem&quot;</span>,
<a name="l00256"></a>00256                 .ckd_size  = <span class="keyword">sizeof</span> (<span class="keyword">struct </span>echo_lock)
<a name="l00257"></a>00257         },
<a name="l00258"></a>00258         {
<a name="l00259"></a>00259                 .ckd_cache = &amp;echo_object_kmem,
<a name="l00260"></a>00260                 .ckd_name  = <span class="stringliteral">&quot;echo_object_kmem&quot;</span>,
<a name="l00261"></a>00261                 .ckd_size  = <span class="keyword">sizeof</span> (<span class="keyword">struct </span>echo_object)
<a name="l00262"></a>00262         },
<a name="l00263"></a>00263         {
<a name="l00264"></a>00264                 .ckd_cache = &amp;echo_thread_kmem,
<a name="l00265"></a>00265                 .ckd_name  = <span class="stringliteral">&quot;echo_thread_kmem&quot;</span>,
<a name="l00266"></a>00266                 .ckd_size  = <span class="keyword">sizeof</span> (<span class="keyword">struct </span>echo_thread_info)
<a name="l00267"></a>00267         },
<a name="l00268"></a>00268         {
<a name="l00269"></a>00269                 .ckd_cache = &amp;echo_session_kmem,
<a name="l00270"></a>00270                 .ckd_name  = <span class="stringliteral">&quot;echo_session_kmem&quot;</span>,
<a name="l00271"></a>00271                 .ckd_size  = <span class="keyword">sizeof</span> (<span class="keyword">struct </span>echo_session_info)
<a name="l00272"></a>00272         },
<a name="l00273"></a>00273         {
<a name="l00274"></a>00274                 .ckd_cache = NULL
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276 };
<a name="l00277"></a>00277 
<a name="l00284"></a>00284 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_page_own(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00285"></a>00285                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice,
<a name="l00286"></a>00286                          <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keywordtype">int</span> nonblock)
<a name="l00287"></a>00287 {
<a name="l00288"></a>00288         <span class="keyword">struct </span>echo_page *ep = cl2echo_page(slice);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         <span class="keywordflow">if</span> (!nonblock)
<a name="l00291"></a>00291                 mutex_lock(&amp;ep-&gt;ep_lock);
<a name="l00292"></a>00292         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!mutex_trylock(&amp;ep-&gt;ep_lock))
<a name="l00293"></a>00293                 <span class="keywordflow">return</span> -EAGAIN;
<a name="l00294"></a>00294         <span class="keywordflow">return</span> 0;
<a name="l00295"></a>00295 }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_page_disown(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00298"></a>00298                              <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice,
<a name="l00299"></a>00299                              <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00300"></a>00300 {
<a name="l00301"></a>00301         <span class="keyword">struct </span>echo_page *ep = cl2echo_page(slice);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303         LASSERT(mutex_is_locked(&amp;ep-&gt;ep_lock));
<a name="l00304"></a>00304         mutex_unlock(&amp;ep-&gt;ep_lock);
<a name="l00305"></a>00305 }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_page_discard(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00308"></a>00308                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice,
<a name="l00309"></a>00309                               <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *unused)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311         <a class="code" href="group__cl__page.html#ga55a51f6efaa6effc3b5b3d045d4ee432" title="Called when a decision is made to throw page out of memory.">cl_page_delete</a>(env, slice-&gt;cpl_page);
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_page_is_vmlocked(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00315"></a>00315                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice)
<a name="l00316"></a>00316 {
<a name="l00317"></a>00317         <span class="keywordflow">if</span> (mutex_is_locked(&amp;cl2echo_page(slice)-&gt;ep_lock))
<a name="l00318"></a>00318                 <span class="keywordflow">return</span> -EBUSY;
<a name="l00319"></a>00319         <span class="keywordflow">return</span> -ENODATA;
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_page_completion(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00323"></a>00323                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice,
<a name="l00324"></a>00324                                  <span class="keywordtype">int</span> ioret)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326         LASSERT(slice-&gt;cpl_page-&gt;<a class="code" href="structcl__page.html#a9fee0561b08bf01258f9824f0c2b62d2" title="Assigned if doing a sync_io.">cp_sync_io</a> != NULL);
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_page_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00330"></a>00330                            <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice)
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332         <span class="keyword">struct </span>echo_object *eco = cl2echo_obj(slice-&gt;<a class="code" href="structcl__page__slice.html#a71c54d2bf9c69b3a66df261412d0ba78" title="Object slice corresponding to this page slice.">cpl_obj</a>);
<a name="l00333"></a>00333         ENTRY;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335         atomic_dec(&amp;eco-&gt;eo_npages);
<a name="l00336"></a>00336         page_cache_release(slice-&gt;cpl_page-&gt;<a class="code" href="structcl__page.html#a9a4e391a7b741652812a451580176c9a" title="vmpage">cp_vmpage</a>);
<a name="l00337"></a>00337         EXIT;
<a name="l00338"></a>00338 }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_page_prep(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00341"></a>00341                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice,
<a name="l00342"></a>00342                           <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *unused)
<a name="l00343"></a>00343 {
<a name="l00344"></a>00344         <span class="keywordflow">return</span> 0;
<a name="l00345"></a>00345 }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_page_print(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00348"></a>00348                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__page__slice.html" title="Per-layer part of cl_page.">cl_page_slice</a> *slice,
<a name="l00349"></a>00349                            <span class="keywordtype">void</span> *cookie, <a class="code" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc" title="Type of &amp;quot;printer&amp;quot; function used by lu_object_operations::loo_object_print()...">lu_printer_t</a> printer)
<a name="l00350"></a>00350 {
<a name="l00351"></a>00351         <span class="keyword">struct </span>echo_page *ep = cl2echo_page(slice);
<a name="l00352"></a>00352 
<a name="l00353"></a>00353         (*printer)(env, cookie, LUSTRE_ECHO_CLIENT_NAME<span class="stringliteral">&quot;-page@%p %d vm@%p\n&quot;</span>,
<a name="l00354"></a>00354                    ep, mutex_is_locked(&amp;ep-&gt;ep_lock),
<a name="l00355"></a>00355                    slice-&gt;cpl_page-&gt;<a class="code" href="structcl__page.html#a9a4e391a7b741652812a451580176c9a" title="vmpage">cp_vmpage</a>);
<a name="l00356"></a>00356         <span class="keywordflow">return</span> 0;
<a name="l00357"></a>00357 }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__page__operations.html" title="Per-layer page operations.">cl_page_operations</a> echo_page_ops = {
<a name="l00360"></a>00360         .<a class="code" href="structcl__page__operations.html#afb6338fcddde30623c66ad280f8bff83" title="cl_page&amp;lt;-&amp;gt;struct page methods.">cpo_own</a>           = echo_page_own,
<a name="l00361"></a>00361         .cpo_disown        = echo_page_disown,
<a name="l00362"></a>00362         .cpo_discard       = echo_page_discard,
<a name="l00363"></a>00363         .cpo_fini          = echo_page_fini,
<a name="l00364"></a>00364         .cpo_print         = echo_page_print,
<a name="l00365"></a>00365         .cpo_is_vmlocked   = echo_page_is_vmlocked,
<a name="l00366"></a>00366         .io = {
<a name="l00367"></a>00367                 [CRT_READ] = {
<a name="l00368"></a>00368                         .cpo_prep        = echo_page_prep,
<a name="l00369"></a>00369                         .cpo_completion  = echo_page_completion,
<a name="l00370"></a>00370                 },
<a name="l00371"></a>00371                 [CRT_WRITE] = {
<a name="l00372"></a>00372                         .cpo_prep        = echo_page_prep,
<a name="l00373"></a>00373                         .cpo_completion  = echo_page_completion,
<a name="l00374"></a>00374                 }
<a name="l00375"></a>00375         }
<a name="l00376"></a>00376 };
<a name="l00385"></a>00385 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_lock_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00386"></a>00386                            <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice)
<a name="l00387"></a>00387 {
<a name="l00388"></a>00388         <span class="keyword">struct </span>echo_lock *ecl = cl2echo_lock(slice);
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         LASSERT(list_empty(&amp;ecl-&gt;el_chain));
<a name="l00391"></a>00391         OBD_SLAB_FREE_PTR(ecl, echo_lock_kmem);
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcl__lock__operations.html">cl_lock_operations</a> echo_lock_ops = {
<a name="l00395"></a>00395         .<a class="code" href="structcl__lock__operations.html#a4b649544378d50bf50bcb9c65d49795a" title="Destructor.">clo_fini</a>      = echo_lock_fini,
<a name="l00396"></a>00396 };
<a name="l00397"></a>00397 
<a name="l00406"></a>00406 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_page_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00407"></a>00407                           <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page, pgoff_t index)
<a name="l00408"></a>00408 {
<a name="l00409"></a>00409         <span class="keyword">struct </span>echo_page *ep = cl_object_page_slice(obj, page);
<a name="l00410"></a>00410         <span class="keyword">struct </span>echo_object *eco = cl2echo_obj(obj);
<a name="l00411"></a>00411         ENTRY;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413         page_cache_get(page-&gt;<a class="code" href="structcl__page.html#a9a4e391a7b741652812a451580176c9a" title="vmpage">cp_vmpage</a>);
<a name="l00414"></a>00414         mutex_init(&amp;ep-&gt;ep_lock);
<a name="l00415"></a>00415         <a class="code" href="group__clio.html#gaf9c2b2723494e52efc66d52fe2d0b93f" title="Adds page slice to the compound page.">cl_page_slice_add</a>(page, &amp;ep-&gt;ep_cl, obj, index, &amp;echo_page_ops);
<a name="l00416"></a>00416         atomic_inc(&amp;eco-&gt;eo_npages);
<a name="l00417"></a>00417         RETURN(0);
<a name="l00418"></a>00418 }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_io_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00421"></a>00421                         <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l00422"></a>00422 {
<a name="l00423"></a>00423         <span class="keywordflow">return</span> 0;
<a name="l00424"></a>00424 }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_lock_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00427"></a>00427                           <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock,
<a name="l00428"></a>00428                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *unused)
<a name="l00429"></a>00429 {
<a name="l00430"></a>00430         <span class="keyword">struct </span>echo_lock *el;
<a name="l00431"></a>00431         ENTRY;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433         OBD_SLAB_ALLOC_PTR_GFP(el, echo_lock_kmem, GFP_NOFS);
<a name="l00434"></a>00434         <span class="keywordflow">if</span> (el != NULL) {
<a name="l00435"></a>00435                 <a class="code" href="group__clio.html#ga9c2fdf8ae73a6f36bc8df4249459da93" title="Adds lock slice to the compound lock.">cl_lock_slice_add</a>(lock, &amp;el-&gt;el_cl, obj, &amp;echo_lock_ops);
<a name="l00436"></a>00436                 el-&gt;el_object = cl2echo_obj(obj);
<a name="l00437"></a>00437                 INIT_LIST_HEAD(&amp;el-&gt;el_chain);
<a name="l00438"></a>00438                 atomic_set(&amp;el-&gt;el_refcount, 0);
<a name="l00439"></a>00439         }
<a name="l00440"></a>00440         RETURN(el == NULL ? -ENOMEM : 0);
<a name="l00441"></a>00441 }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_conf_set(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj,
<a name="l00444"></a>00444                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__object__conf.html" title="Description of the client object configuration.">cl_object_conf</a> *conf)
<a name="l00445"></a>00445 {
<a name="l00446"></a>00446         <span class="keywordflow">return</span> 0;
<a name="l00447"></a>00447 }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__object__operations.html" title="Operations implemented for each cl object layer.">cl_object_operations</a> echo_cl_obj_ops = {
<a name="l00450"></a>00450         .<a class="code" href="structcl__object__operations.html#a86e603bbbf4c6b1625b8dece6cbb5f32" title="Initialize page slice for this layer.">coo_page_init</a> = echo_page_init,
<a name="l00451"></a>00451         .coo_lock_init = echo_lock_init,
<a name="l00452"></a>00452         .coo_io_init   = echo_io_init,
<a name="l00453"></a>00453         .coo_conf_set  = echo_conf_set
<a name="l00454"></a>00454 };
<a name="l00463"></a>00463 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_object_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj,
<a name="l00464"></a>00464                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object__conf.html" title="Object configuration, describing particulars of object being created.">lu_object_conf</a> *conf)
<a name="l00465"></a>00465 {
<a name="l00466"></a>00466         <span class="keyword">struct </span>echo_device *ed         = cl2echo_dev(lu2cl_dev(obj-&gt;<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>));
<a name="l00467"></a>00467         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a> *ec     = ed-&gt;ed_ec;
<a name="l00468"></a>00468         <span class="keyword">struct </span>echo_object *eco        = cl2echo_obj(lu2cl(obj));
<a name="l00469"></a>00469         ENTRY;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         <span class="keywordflow">if</span> (ed-&gt;ed_next) {
<a name="l00472"></a>00472                 <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>  *below;
<a name="l00473"></a>00473                 <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>  *under;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475                 under = ed-&gt;ed_next;
<a name="l00476"></a>00476                 below = under-&gt;<a class="code" href="structlu__device.html#a4cab097ca33e55a7255ad1d848596827" title="Operation vector for this device.">ld_ops</a>-&gt;<a class="code" href="structlu__device__operations.html#a2d0d0803131da38c837d16ab6f979fb0" title="Allocate object for the given device (without lower-layer parts).">ldo_object_alloc</a>(env, obj-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>,
<a name="l00477"></a>00477                                                         under);
<a name="l00478"></a>00478                 <span class="keywordflow">if</span> (below == NULL)
<a name="l00479"></a>00479                         RETURN(-ENOMEM);
<a name="l00480"></a>00480                 <a class="code" href="group__lu.html#gaa0c00da42f82361409215468e0952e37" title="Add object o as a layer of compound object, going after before.">lu_object_add</a>(obj, below);
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         <span class="keywordflow">if</span> (!ed-&gt;ed_next_ismd) {
<a name="l00484"></a>00484                 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__object__conf.html" title="Description of the client object configuration.">cl_object_conf</a> *cconf = lu2cl_conf(conf);
<a name="l00485"></a>00485                 <span class="keyword">struct </span>echo_object_conf *econf = cl2echo_conf(cconf);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487                 LASSERT(econf-&gt;eoc_oinfo != NULL);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489                 <span class="comment">/* Transfer the oinfo pointer to eco that it won&apos;t be</span>
<a name="l00490"></a>00490 <span class="comment">                 * freed. */</span>
<a name="l00491"></a>00491                 eco-&gt;eo_oinfo = *econf-&gt;eoc_oinfo;
<a name="l00492"></a>00492                 *econf-&gt;eoc_oinfo = NULL;
<a name="l00493"></a>00493         } <span class="keywordflow">else</span> {
<a name="l00494"></a>00494                 eco-&gt;eo_oinfo = NULL;
<a name="l00495"></a>00495         }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         eco-&gt;eo_dev = ed;
<a name="l00498"></a>00498         atomic_set(&amp;eco-&gt;eo_npages, 0);
<a name="l00499"></a>00499         cl_object_page_init(lu2cl(obj), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> echo_page));
<a name="l00500"></a>00500 
<a name="l00501"></a>00501         spin_lock(&amp;ec-&gt;ec_lock);
<a name="l00502"></a>00502         list_add_tail(&amp;eco-&gt;eo_obj_chain, &amp;ec-&gt;ec_objects);
<a name="l00503"></a>00503         spin_unlock(&amp;ec-&gt;ec_lock);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         RETURN(0);
<a name="l00506"></a>00506 }
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_object_free(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj)
<a name="l00509"></a>00509 {
<a name="l00510"></a>00510         <span class="keyword">struct </span>echo_object *eco    = cl2echo_obj(lu2cl(obj));
<a name="l00511"></a>00511         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a> *ec = eco-&gt;eo_dev-&gt;ed_ec;
<a name="l00512"></a>00512         ENTRY;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         LASSERT(atomic_read(&amp;eco-&gt;eo_npages) == 0);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516         spin_lock(&amp;ec-&gt;ec_lock);
<a name="l00517"></a>00517         list_del_init(&amp;eco-&gt;eo_obj_chain);
<a name="l00518"></a>00518         spin_unlock(&amp;ec-&gt;ec_lock);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520         <a class="code" href="group__lu.html#ga0318f3c931fb2457b0cc4365c15611ca" title="Finalize object and release its resources.">lu_object_fini</a>(obj);
<a name="l00521"></a>00521         <a class="code" href="group__lu.html#gad3c4db0a912275b2966df3ab46f01ca5" title="Finalize compound object.">lu_object_header_fini</a>(obj-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         <span class="keywordflow">if</span> (eco-&gt;eo_oinfo != NULL)
<a name="l00524"></a>00524                 OBD_FREE_PTR(eco-&gt;eo_oinfo);
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         OBD_SLAB_FREE_PTR(eco, echo_object_kmem);
<a name="l00527"></a>00527         EXIT;
<a name="l00528"></a>00528 }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_object_print(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">void</span> *cookie,
<a name="l00531"></a>00531                             <a class="code" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc" title="Type of &amp;quot;printer&amp;quot; function used by lu_object_operations::loo_object_print()...">lu_printer_t</a> p, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *o)
<a name="l00532"></a>00532 {
<a name="l00533"></a>00533         <span class="keyword">struct </span>echo_object *obj = cl2echo_obj(lu2cl(o));
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         <span class="keywordflow">return</span> (*p)(env, cookie, <span class="stringliteral">&quot;echoclient-object@%p&quot;</span>, obj);
<a name="l00536"></a>00536 }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__object__operations.html" title="Operations specific for particular lu_object.">lu_object_operations</a> echo_lu_obj_ops = {
<a name="l00539"></a>00539         .<a class="code" href="structlu__object__operations.html#a15b69dd7ca43e31bee4023da49fbb8a8" title="Allocate lower-layer parts of the object by calling lu_device_operations::ldo_object_alloc()...">loo_object_init</a>      = echo_object_init,
<a name="l00540"></a>00540         .loo_object_delete    = NULL,
<a name="l00541"></a>00541         .loo_object_release   = NULL,
<a name="l00542"></a>00542         .loo_object_free      = echo_object_free,
<a name="l00543"></a>00543         .loo_object_print     = echo_object_print,
<a name="l00544"></a>00544         .loo_object_invariant = NULL
<a name="l00545"></a>00545 };
<a name="l00554"></a>00554 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *echo_object_alloc(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00555"></a>00555                                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object__header.html" title="&amp;quot;Compound&amp;quot; object, consisting of multiple layers.">lu_object_header</a> *hdr,
<a name="l00556"></a>00556                                            <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *dev)
<a name="l00557"></a>00557 {
<a name="l00558"></a>00558         <span class="keyword">struct </span>echo_object *eco;
<a name="l00559"></a>00559         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *obj = NULL;
<a name="l00560"></a>00560         ENTRY;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562         <span class="comment">/* we&apos;re the top dev. */</span>
<a name="l00563"></a>00563         LASSERT(hdr == NULL);
<a name="l00564"></a>00564         OBD_SLAB_ALLOC_PTR_GFP(eco, echo_object_kmem, GFP_NOFS);
<a name="l00565"></a>00565         <span class="keywordflow">if</span> (eco != NULL) {
<a name="l00566"></a>00566                 <span class="keyword">struct </span><a class="code" href="structcl__object__header.html" title="Extended header for client object.">cl_object_header</a> *hdr = &amp;eco-&gt;eo_hdr;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568                 obj = &amp;echo_obj2cl(eco)-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>;
<a name="l00569"></a>00569                 <a class="code" href="group__cl__object.html#ga0e1e8f1e195acfd9ad600b33e8f183e7" title="Initialize cl_object_header.">cl_object_header_init</a>(hdr);
<a name="l00570"></a>00570                 hdr-&gt;<a class="code" href="structcl__object__header.html#a96304c00b1664392845e45ee00d20c0e" title="Size of cl_page + page slices.">coh_page_bufsize</a> = cfs_size_round(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>));
<a name="l00571"></a>00571 
<a name="l00572"></a>00572                 <a class="code" href="group__lu.html#ga2ca561880240b82371ba59795e8832a4" title="Initialize object o that is part of compound object h and was created by device d...">lu_object_init</a>(obj, &amp;hdr-&gt;<a class="code" href="structcl__object__header.html#ae1f6b59740d6bf9e0bbc6d8786fbc677" title="Standard lu_object_header.">coh_lu</a>, dev);
<a name="l00573"></a>00573                 <a class="code" href="group__lu.html#gaa83f38d5ed0268b449a3074d350c763d" title="Add object o as first layer of compound object h.">lu_object_add_top</a>(&amp;hdr-&gt;<a class="code" href="structcl__object__header.html#ae1f6b59740d6bf9e0bbc6d8786fbc677" title="Standard lu_object_header.">coh_lu</a>, obj);
<a name="l00574"></a>00574 
<a name="l00575"></a>00575                 eco-&gt;eo_cl.co_ops = &amp;echo_cl_obj_ops;
<a name="l00576"></a>00576                 obj-&gt;<a class="code" href="structlu__object.html#a9a5e60cbf9d474fb4039dbb0d39e0a0f" title="Operations for this object.">lo_ops</a>       = &amp;echo_lu_obj_ops;
<a name="l00577"></a>00577         }
<a name="l00578"></a>00578         RETURN(obj);
<a name="l00579"></a>00579 }
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__device__operations.html" title="Operations common for data and meta-data devices.">lu_device_operations</a> echo_device_lu_ops = {
<a name="l00582"></a>00582         .<a class="code" href="structlu__device__operations.html#a2d0d0803131da38c837d16ab6f979fb0" title="Allocate object for the given device (without lower-layer parts).">ldo_object_alloc</a>   = echo_object_alloc,
<a name="l00583"></a>00583 };
<a name="l00584"></a>00584 
<a name="l00593"></a>00593 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_site_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> echo_device *ed)
<a name="l00594"></a>00594 {
<a name="l00595"></a>00595         <span class="keyword">struct </span><a class="code" href="structcl__site.html" title="Client-side site.">cl_site</a> *site = &amp;ed-&gt;ed_site_myself;
<a name="l00596"></a>00596         <span class="keywordtype">int</span> rc;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598         <span class="comment">/* initialize site */</span>
<a name="l00599"></a>00599         rc = <a class="code" href="group__clio.html#ga57611e1e5715dc94dd0eb503a72a8b33" title="Initialize client site.">cl_site_init</a>(site, &amp;ed-&gt;ed_cl);
<a name="l00600"></a>00600         <span class="keywordflow">if</span> (rc) {
<a name="l00601"></a>00601                 CERROR(<span class="stringliteral">&quot;Cannot initialize site for echo client(%d)\n&quot;</span>, rc);
<a name="l00602"></a>00602                 <span class="keywordflow">return</span> rc;
<a name="l00603"></a>00603         }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605         rc = <a class="code" href="group__lu.html#ga8f089514e7db6f839ca9cb259a1eab14" title="Called when initialization of stack for this site is completed.">lu_site_init_finish</a>(&amp;site-&gt;cs_lu);
<a name="l00606"></a>00606         <span class="keywordflow">if</span> (rc) {
<a name="l00607"></a>00607                 <a class="code" href="group__clio.html#ga5384082c04872b0c11252ead509cdd7a" title="Finalize client site.">cl_site_fini</a>(site);
<a name="l00608"></a>00608                 <span class="keywordflow">return</span> rc;
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         ed-&gt;ed_site = &amp;site-&gt;cs_lu;
<a name="l00612"></a>00612         <span class="keywordflow">return</span> 0;
<a name="l00613"></a>00613 }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_site_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> echo_device *ed)
<a name="l00616"></a>00616 {
<a name="l00617"></a>00617         <span class="keywordflow">if</span> (ed-&gt;ed_site) {
<a name="l00618"></a>00618                 <span class="keywordflow">if</span> (!ed-&gt;ed_next_ismd)
<a name="l00619"></a>00619                         <a class="code" href="group__lu.html#ga91afa048e05c24fbd176d46dbc676f61" title="Finalize s and release its resources.">lu_site_fini</a>(ed-&gt;ed_site);
<a name="l00620"></a>00620                 ed-&gt;ed_site = NULL;
<a name="l00621"></a>00621         }
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 <span class="keyword">static</span> <span class="keywordtype">void</span> *echo_thread_key_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx,
<a name="l00625"></a>00625                                   <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key)
<a name="l00626"></a>00626 {
<a name="l00627"></a>00627         <span class="keyword">struct </span>echo_thread_info *info;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629         OBD_SLAB_ALLOC_PTR_GFP(info, echo_thread_kmem, GFP_NOFS);
<a name="l00630"></a>00630         <span class="keywordflow">if</span> (info == NULL)
<a name="l00631"></a>00631                 info = ERR_PTR(-ENOMEM);
<a name="l00632"></a>00632         <span class="keywordflow">return</span> info;
<a name="l00633"></a>00633 }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_thread_key_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx,
<a name="l00636"></a>00636                          <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key, <span class="keywordtype">void</span> *data)
<a name="l00637"></a>00637 {
<a name="l00638"></a>00638         <span class="keyword">struct </span>echo_thread_info *info = data;
<a name="l00639"></a>00639         OBD_SLAB_FREE_PTR(info, echo_thread_kmem);
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_thread_key_exit(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx,
<a name="l00643"></a>00643                          <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key, <span class="keywordtype">void</span> *data)
<a name="l00644"></a>00644 {
<a name="l00645"></a>00645 }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> echo_thread_key = {
<a name="l00648"></a>00648         .<a class="code" href="structlu__context__key.html#a52c40318e941229b9b102d7b6b8746f6" title="Set of tags for which values of this key are to be instantiated.">lct_tags</a> = <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" title="Thread on client.">LCT_CL_THREAD</a>,
<a name="l00649"></a>00649         .lct_init = echo_thread_key_init,
<a name="l00650"></a>00650         .lct_fini = echo_thread_key_fini,
<a name="l00651"></a>00651         .lct_exit = echo_thread_key_exit
<a name="l00652"></a>00652 };
<a name="l00653"></a>00653 
<a name="l00654"></a>00654 <span class="keyword">static</span> <span class="keywordtype">void</span> *echo_session_key_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx,
<a name="l00655"></a>00655                                   <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key)
<a name="l00656"></a>00656 {
<a name="l00657"></a>00657         <span class="keyword">struct </span>echo_session_info *session;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         OBD_SLAB_ALLOC_PTR_GFP(session, echo_session_kmem, GFP_NOFS);
<a name="l00660"></a>00660         <span class="keywordflow">if</span> (session == NULL)
<a name="l00661"></a>00661                 session = ERR_PTR(-ENOMEM);
<a name="l00662"></a>00662         <span class="keywordflow">return</span> session;
<a name="l00663"></a>00663 }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_session_key_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx,
<a name="l00666"></a>00666                                  <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key, <span class="keywordtype">void</span> *data)
<a name="l00667"></a>00667 {
<a name="l00668"></a>00668         <span class="keyword">struct </span>echo_session_info *session = data;
<a name="l00669"></a>00669         OBD_SLAB_FREE_PTR(session, echo_session_kmem);
<a name="l00670"></a>00670 }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_session_key_exit(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx,
<a name="l00673"></a>00673                                  <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key, <span class="keywordtype">void</span> *data)
<a name="l00674"></a>00674 {
<a name="l00675"></a>00675 }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> echo_session_key = {
<a name="l00678"></a>00678         .<a class="code" href="structlu__context__key.html#a52c40318e941229b9b102d7b6b8746f6" title="Set of tags for which values of this key are to be instantiated.">lct_tags</a> = <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa76aa3f8e745622ced47e2687d27c4b84" title="A per-request session on a server, and a per-system-call session on a client.">LCT_SESSION</a>,
<a name="l00679"></a>00679         .lct_init = echo_session_key_init,
<a name="l00680"></a>00680         .lct_fini = echo_session_key_fini,
<a name="l00681"></a>00681         .lct_exit = echo_session_key_exit
<a name="l00682"></a>00682 };
<a name="l00683"></a>00683 
<a name="l00684"></a>00684 LU_TYPE_INIT_FINI(echo, &amp;echo_thread_key, &amp;echo_session_key);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span><span class="preprocessor"># define ECHO_SEQ_WIDTH 0xffffffff</span>
<a name="l00688"></a>00688 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> echo_fid_init(<span class="keyword">struct</span> echo_device *ed, <span class="keywordtype">char</span> *obd_name,
<a name="l00689"></a>00689                          <span class="keyword">struct</span> <a class="code" href="structseq__server__site.html">seq_server_site</a> *ss)
<a name="l00690"></a>00690 {
<a name="l00691"></a>00691         <span class="keywordtype">char</span> *prefix;
<a name="l00692"></a>00692         <span class="keywordtype">int</span> rc;
<a name="l00693"></a>00693         ENTRY;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695         OBD_ALLOC_PTR(ed-&gt;ed_cl_seq);
<a name="l00696"></a>00696         <span class="keywordflow">if</span> (ed-&gt;ed_cl_seq == NULL)
<a name="l00697"></a>00697                 RETURN(-ENOMEM);
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         OBD_ALLOC(prefix, MAX_OBD_NAME + 5);
<a name="l00700"></a>00700         <span class="keywordflow">if</span> (prefix == NULL)
<a name="l00701"></a>00701                 GOTO(out_free_seq, rc = -ENOMEM);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         snprintf(prefix, MAX_OBD_NAME + 5, <span class="stringliteral">&quot;srv-%s&quot;</span>, obd_name);
<a name="l00704"></a>00704 
<a name="l00705"></a>00705         <span class="comment">/* Init client side sequence-manager */</span>
<a name="l00706"></a>00706         rc = seq_client_init(ed-&gt;ed_cl_seq, NULL,
<a name="l00707"></a>00707                              LUSTRE_SEQ_METADATA,
<a name="l00708"></a>00708                              prefix, ss-&gt;<a class="code" href="structseq__server__site.html#a3214a25cb8293fdbe1a7216eaadef98b" title="Server Seq Manager.">ss_server_seq</a>);
<a name="l00709"></a>00709         ed-&gt;ed_cl_seq-&gt;lcs_width = ECHO_SEQ_WIDTH;
<a name="l00710"></a>00710         OBD_FREE(prefix, MAX_OBD_NAME + 5);
<a name="l00711"></a>00711         <span class="keywordflow">if</span> (rc)
<a name="l00712"></a>00712                 GOTO(out_free_seq, rc);
<a name="l00713"></a>00713 
<a name="l00714"></a>00714         RETURN(0);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 out_free_seq:
<a name="l00717"></a>00717         OBD_FREE_PTR(ed-&gt;ed_cl_seq);
<a name="l00718"></a>00718         ed-&gt;ed_cl_seq = NULL;
<a name="l00719"></a>00719         RETURN(rc);
<a name="l00720"></a>00720 }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_fid_fini(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev)
<a name="l00723"></a>00723 {
<a name="l00724"></a>00724         <span class="keyword">struct </span>echo_device *ed = obd2echo_dev(obddev);
<a name="l00725"></a>00725         ENTRY;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         <span class="keywordflow">if</span> (ed-&gt;ed_cl_seq != NULL) {
<a name="l00728"></a>00728                 seq_client_fini(ed-&gt;ed_cl_seq);
<a name="l00729"></a>00729                 OBD_FREE_PTR(ed-&gt;ed_cl_seq);
<a name="l00730"></a>00730                 ed-&gt;ed_cl_seq = NULL;
<a name="l00731"></a>00731         }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733         RETURN(0);
<a name="l00734"></a>00734 }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_ed_los_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> echo_device *ed)
<a name="l00737"></a>00737 {
<a name="l00738"></a>00738         ENTRY;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740         <span class="keywordflow">if</span> (ed != NULL &amp;&amp; ed-&gt;ed_next_ismd &amp;&amp; ed-&gt;ed_los != NULL) {
<a name="l00741"></a>00741                 local_oid_storage_fini(env, ed-&gt;ed_los);
<a name="l00742"></a>00742                 ed-&gt;ed_los = NULL;
<a name="l00743"></a>00743         }
<a name="l00744"></a>00744 }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00747"></a>00747 echo_md_local_file_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> echo_md_device *emd,
<a name="l00748"></a>00748                           <span class="keyword">struct</span> <a class="code" href="structlocal__oid__storage.html">local_oid_storage</a> *los,
<a name="l00749"></a>00749                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00750"></a>00750                           __u32 mode, <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l00751"></a>00751 {
<a name="l00752"></a>00752         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *parent = NULL;
<a name="l00753"></a>00753         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *dto = NULL;
<a name="l00754"></a>00754         <span class="keywordtype">int</span>                      rc = 0;
<a name="l00755"></a>00755         ENTRY;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         LASSERT(!fid_is_zero(pfid));
<a name="l00758"></a>00758         parent = dt_locate(env, emd-&gt;emd_bottom, pfid);
<a name="l00759"></a>00759         <span class="keywordflow">if</span> (unlikely(IS_ERR(parent)))
<a name="l00760"></a>00760                 RETURN(PTR_ERR(parent));
<a name="l00761"></a>00761 
<a name="l00762"></a>00762         <span class="comment">/* create local file with @fid */</span>
<a name="l00763"></a>00763         dto = local_file_find_or_create_with_fid(env, emd-&gt;emd_bottom, fid,
<a name="l00764"></a>00764                                                  parent, name, mode);
<a name="l00765"></a>00765         <span class="keywordflow">if</span> (IS_ERR(dto))
<a name="l00766"></a>00766                 GOTO(out_put, rc = PTR_ERR(dto));
<a name="l00767"></a>00767 
<a name="l00768"></a>00768         *fid = *lu_object_fid(&amp;dto-&gt;do_lu);
<a name="l00769"></a>00769         <span class="comment">/* since stack is not fully set up the local_storage uses own stack</span>
<a name="l00770"></a>00770 <span class="comment">         * and we should drop its object from cache */</span>
<a name="l00771"></a>00771         <a class="code" href="group__lu.html#ga48ae307342778b2ffb56cae3dad5d012" title="Put object and don&amp;#39;t keep in cache.">lu_object_put_nocache</a>(env, &amp;dto-&gt;do_lu);
<a name="l00772"></a>00772 
<a name="l00773"></a>00773         EXIT;
<a name="l00774"></a>00774 out_put:
<a name="l00775"></a>00775         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, &amp;parent-&gt;do_lu);
<a name="l00776"></a>00776         RETURN(rc);
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00780"></a>00780 echo_md_root_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> echo_md_device *emd,
<a name="l00781"></a>00781                  <span class="keyword">struct</span> echo_device *ed)
<a name="l00782"></a>00782 {
<a name="l00783"></a>00783         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>                    fid;
<a name="l00784"></a>00784         <span class="keywordtype">int</span>                              rc = 0;
<a name="l00785"></a>00785         ENTRY;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         <span class="comment">/* Setup local dirs */</span>
<a name="l00788"></a>00788         fid.<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = FID_SEQ_LOCAL_NAME;
<a name="l00789"></a>00789         fid.f_oid = 1;
<a name="l00790"></a>00790         fid.<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = 0;
<a name="l00791"></a>00791         rc = <a class="code" href="group__dt.html#gacddd08c8c9a92143811432373ca8a057" title="Initialize local OID storage for required sequence.">local_oid_storage_init</a>(env, emd-&gt;emd_bottom, &amp;fid, &amp;ed-&gt;ed_los);
<a name="l00792"></a>00792         <span class="keywordflow">if</span> (rc != 0)
<a name="l00793"></a>00793                 RETURN(rc);
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         lu_echo_root_fid(&amp;fid);
<a name="l00796"></a>00796         <span class="keywordflow">if</span> (echo_md_seq_site(emd)-&gt;ss_node_id == 0) {
<a name="l00797"></a>00797                 rc = echo_md_local_file_create(env, emd, ed-&gt;ed_los,
<a name="l00798"></a>00798                                                &amp;emd-&gt;emd_local_root_fid,
<a name="l00799"></a>00799                                                echo_md_root_dir_name, S_IFDIR |
<a name="l00800"></a>00800                                                S_IRUGO | S_IWUSR | S_IXUGO,
<a name="l00801"></a>00801                                                &amp;fid);
<a name="l00802"></a>00802                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l00803"></a>00803                         CERROR(<span class="stringliteral">&quot;%s: create md echo root fid failed: rc = %d\n&quot;</span>,
<a name="l00804"></a>00804                                emd2obd_dev(emd)-&gt;obd_name, rc);
<a name="l00805"></a>00805                         GOTO(out_los, rc);
<a name="l00806"></a>00806                 }
<a name="l00807"></a>00807         }
<a name="l00808"></a>00808         ed-&gt;ed_root_fid = fid;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810         RETURN(0);
<a name="l00811"></a>00811 out_los:
<a name="l00812"></a>00812         echo_ed_los_fini(env, ed);
<a name="l00813"></a>00813 
<a name="l00814"></a>00814         RETURN(rc);
<a name="l00815"></a>00815 }
<a name="l00816"></a>00816 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *echo_device_alloc(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00819"></a>00819                                            <span class="keyword">struct</span> <a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> *t,
<a name="l00820"></a>00820                                            <span class="keyword">struct</span> <a class="code" href="structlustre__cfg.html">lustre_cfg</a> *cfg)
<a name="l00821"></a>00821 {
<a name="l00822"></a>00822         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>   *next;
<a name="l00823"></a>00823         <span class="keyword">struct </span>echo_device *ed;
<a name="l00824"></a>00824         <span class="keyword">struct </span><a class="code" href="structcl__device.html" title="Device in the client stack.">cl_device</a>   *cd;
<a name="l00825"></a>00825         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a>  *obd = NULL; <span class="comment">/* to keep compiler happy */</span>
<a name="l00826"></a>00826         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a>  *tgt;
<a name="l00827"></a>00827         <span class="keyword">const</span> <span class="keywordtype">char</span> *tgt_type_name;
<a name="l00828"></a>00828         <span class="keywordtype">int</span> rc;
<a name="l00829"></a>00829         <span class="keywordtype">int</span> cleanup = 0;
<a name="l00830"></a>00830         ENTRY;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832         OBD_ALLOC_PTR(ed);
<a name="l00833"></a>00833         <span class="keywordflow">if</span> (ed == NULL)
<a name="l00834"></a>00834                 GOTO(out, rc = -ENOMEM);
<a name="l00835"></a>00835 
<a name="l00836"></a>00836         cleanup = 1;
<a name="l00837"></a>00837         cd = &amp;ed-&gt;ed_cl;
<a name="l00838"></a>00838         rc = cl_device_init(cd, t);
<a name="l00839"></a>00839         <span class="keywordflow">if</span> (rc)
<a name="l00840"></a>00840                 GOTO(out, rc);
<a name="l00841"></a>00841 
<a name="l00842"></a>00842         cd-&gt;<a class="code" href="structcl__device.html#a881ea223a07828242f8c3b02f65792db" title="Super-class.">cd_lu_dev</a>.<a class="code" href="structlu__device.html#a4cab097ca33e55a7255ad1d848596827" title="Operation vector for this device.">ld_ops</a> = &amp;echo_device_lu_ops;
<a name="l00843"></a>00843 
<a name="l00844"></a>00844         cleanup = 2;
<a name="l00845"></a>00845         obd = class_name2obd(lustre_cfg_string(cfg, 0));
<a name="l00846"></a>00846         LASSERT(obd != NULL);
<a name="l00847"></a>00847         LASSERT(env != NULL);
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         tgt = class_name2obd(lustre_cfg_string(cfg, 1));
<a name="l00850"></a>00850         <span class="keywordflow">if</span> (tgt == NULL) {
<a name="l00851"></a>00851                 CERROR(<span class="stringliteral">&quot;Can not find tgt device %s\n&quot;</span>,
<a name="l00852"></a>00852                         lustre_cfg_string(cfg, 1));
<a name="l00853"></a>00853                 GOTO(out, rc = -ENODEV);
<a name="l00854"></a>00854         }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856         next = tgt-&gt;obd_lu_dev;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858         <span class="keywordflow">if</span> (strcmp(tgt-&gt;obd_type-&gt;typ_name, LUSTRE_MDT_NAME) == 0) {
<a name="l00859"></a>00859                 ed-&gt;ed_next_ismd = 1;
<a name="l00860"></a>00860         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(tgt-&gt;obd_type-&gt;typ_name, LUSTRE_OST_NAME) == 0 ||
<a name="l00861"></a>00861                    strcmp(tgt-&gt;obd_type-&gt;typ_name, LUSTRE_OSC_NAME) == 0) {
<a name="l00862"></a>00862                 ed-&gt;ed_next_ismd = 0;
<a name="l00863"></a>00863                 rc = echo_site_init(env, ed);
<a name="l00864"></a>00864                 <span class="keywordflow">if</span> (rc)
<a name="l00865"></a>00865                         GOTO(out, rc);
<a name="l00866"></a>00866         } <span class="keywordflow">else</span> {
<a name="l00867"></a>00867                 GOTO(out, rc = -EINVAL);
<a name="l00868"></a>00868         }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         cleanup = 3;
<a name="l00871"></a>00871 
<a name="l00872"></a>00872         rc = echo_client_setup(env, obd, cfg);
<a name="l00873"></a>00873         <span class="keywordflow">if</span> (rc)
<a name="l00874"></a>00874                 GOTO(out, rc);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         ed-&gt;ed_ec = &amp;obd-&gt;u.echo_client;
<a name="l00877"></a>00877         cleanup = 4;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879         <span class="keywordflow">if</span> (ed-&gt;ed_next_ismd) {
<a name="l00880"></a>00880 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l00881"></a>00881 <span class="preprocessor"></span>                <span class="comment">/* Suppose to connect to some Metadata layer */</span>
<a name="l00882"></a>00882                 <span class="keyword">struct </span><a class="code" href="structlu__site.html" title="lu_site is a &amp;quot;compartment&amp;quot; within which objects are unique, and LRU discipline...">lu_site</a>          *ls = NULL;
<a name="l00883"></a>00883                 <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *ld = NULL;
<a name="l00884"></a>00884                 <span class="keyword">struct </span><a class="code" href="structmd__device.html">md_device</a>        *md = NULL;
<a name="l00885"></a>00885                 <span class="keyword">struct </span>echo_md_device   *emd = NULL;
<a name="l00886"></a>00886                 <span class="keywordtype">int</span>                      found = 0;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888                 <span class="keywordflow">if</span> (next == NULL) {
<a name="l00889"></a>00889                         CERROR(<span class="stringliteral">&quot;%s is not lu device type!\n&quot;</span>,
<a name="l00890"></a>00890                                lustre_cfg_string(cfg, 1));
<a name="l00891"></a>00891                         GOTO(out, rc = -EINVAL);
<a name="l00892"></a>00892                 }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894                 tgt_type_name = lustre_cfg_string(cfg, 2);
<a name="l00895"></a>00895                 <span class="keywordflow">if</span> (!tgt_type_name) {
<a name="l00896"></a>00896                         CERROR(<span class="stringliteral">&quot;%s no type name for echo %s setup\n&quot;</span>,
<a name="l00897"></a>00897                                 lustre_cfg_string(cfg, 1),
<a name="l00898"></a>00898                                 tgt-&gt;obd_type-&gt;typ_name);
<a name="l00899"></a>00899                         GOTO(out, rc = -EINVAL);
<a name="l00900"></a>00900                 }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902                 ls = next-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>;
<a name="l00903"></a>00903 
<a name="l00904"></a>00904                 spin_lock(&amp;ls-&gt;ls_ld_lock);
<a name="l00905"></a>00905                 list_for_each_entry(ld, &amp;ls-&gt;<a class="code" href="structlu__site.html#a47f65957d7bceeb1e8d4ef896b146131" title="List for lu device for this site, protected by ls_ld_lock.">ls_ld_linkage</a>, ld_linkage) {
<a name="l00906"></a>00906                         <span class="keywordflow">if</span> (strcmp(ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>-&gt;<a class="code" href="structlu__device__type.html#ac5c39275e94aa3eb256a0d6ed6d2ccd2" title="Name of this class.">ldt_name</a>, tgt_type_name) == 0) {
<a name="l00907"></a>00907                                 found = 1;
<a name="l00908"></a>00908                                 <span class="keywordflow">break</span>;
<a name="l00909"></a>00909                         }
<a name="l00910"></a>00910                 }
<a name="l00911"></a>00911                 spin_unlock(&amp;ls-&gt;ls_ld_lock);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913                 <span class="keywordflow">if</span> (found == 0) {
<a name="l00914"></a>00914                         CERROR(<span class="stringliteral">&quot;%s is not lu device type!\n&quot;</span>,
<a name="l00915"></a>00915                                lustre_cfg_string(cfg, 1));
<a name="l00916"></a>00916                         GOTO(out, rc = -EINVAL);
<a name="l00917"></a>00917                 }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919                 next = ld;
<a name="l00920"></a>00920                 <span class="comment">/* For MD echo client, it will use the site in MDS stack */</span>
<a name="l00921"></a>00921                 ed-&gt;ed_site = ls;
<a name="l00922"></a>00922                 ed-&gt;ed_cl.cd_lu_dev.ld_site = ls;
<a name="l00923"></a>00923                 rc = echo_fid_init(ed, obd-&gt;obd_name, lu_site2seq(ls));
<a name="l00924"></a>00924                 <span class="keywordflow">if</span> (rc) {
<a name="l00925"></a>00925                         CERROR(<span class="stringliteral">&quot;echo fid init error %d\n&quot;</span>, rc);
<a name="l00926"></a>00926                         GOTO(out, rc);
<a name="l00927"></a>00927                 }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929                 md = lu2md_dev(next);
<a name="l00930"></a>00930                 emd = lu2emd_dev(&amp;md-&gt;md_lu_dev);
<a name="l00931"></a>00931                 rc = echo_md_root_get(env, emd, ed);
<a name="l00932"></a>00932                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l00933"></a>00933                         CERROR(<span class="stringliteral">&quot;%s: get root error: rc = %d\n&quot;</span>,
<a name="l00934"></a>00934                                 emd2obd_dev(emd)-&gt;obd_name, rc);
<a name="l00935"></a>00935                         GOTO(out, rc);
<a name="l00936"></a>00936                 }
<a name="l00937"></a>00937 <span class="preprocessor">#else </span><span class="comment">/* !HAVE_SERVER_SUPPORT */</span>
<a name="l00938"></a>00938                 CERROR(<span class="stringliteral">&quot;Local operations are NOT supported on client side. &quot;</span>
<a name="l00939"></a>00939                        <span class="stringliteral">&quot;Only remote operations are supported. Metadata client &quot;</span>
<a name="l00940"></a>00940                        <span class="stringliteral">&quot;must be run on server side.\n&quot;</span>);
<a name="l00941"></a>00941                 GOTO(out, rc = -EOPNOTSUPP);
<a name="l00942"></a>00942 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
<a name="l00943"></a>00943         } <span class="keywordflow">else</span> {
<a name="l00944"></a>00944                  <span class="comment">/* if echo client is to be stacked upon ost device, the next is</span>
<a name="l00945"></a>00945 <span class="comment">                  * NULL since ost is not a clio device so far */</span>
<a name="l00946"></a>00946                 <span class="keywordflow">if</span> (next != NULL &amp;&amp; !lu_device_is_cl(next))
<a name="l00947"></a>00947                         next = NULL;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949                 tgt_type_name = tgt-&gt;obd_type-&gt;typ_name;
<a name="l00950"></a>00950                 <span class="keywordflow">if</span> (next != NULL) {
<a name="l00951"></a>00951                         LASSERT(next != NULL);
<a name="l00952"></a>00952                         <span class="keywordflow">if</span> (next-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a> != NULL)
<a name="l00953"></a>00953                                 GOTO(out, rc = -EBUSY);
<a name="l00954"></a>00954 
<a name="l00955"></a>00955                         next-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a> = ed-&gt;ed_site;
<a name="l00956"></a>00956                         rc = next-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>-&gt;<a class="code" href="structlu__device__type.html#a13b6c99cdcbae4f8eeb9e707d32ee8be" title="Operations for this type.">ldt_ops</a>-&gt;<a class="code" href="structlu__device__type__operations.html#a27dbad7b517189e4de4d3cafb00f3056" title="Initialize the devices after allocation.">ldto_device_init</a>(env, next,
<a name="l00957"></a>00957                                                      next-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>-&gt;<a class="code" href="structlu__device__type.html#ac5c39275e94aa3eb256a0d6ed6d2ccd2" title="Name of this class.">ldt_name</a>,
<a name="l00958"></a>00958                                                      NULL);
<a name="l00959"></a>00959                         <span class="keywordflow">if</span> (rc)
<a name="l00960"></a>00960                                 GOTO(out, rc);
<a name="l00961"></a>00961                 } <span class="keywordflow">else</span>
<a name="l00962"></a>00962                         LASSERT(strcmp(tgt_type_name, LUSTRE_OST_NAME) == 0);
<a name="l00963"></a>00963         }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965         ed-&gt;ed_next = next;
<a name="l00966"></a>00966         RETURN(&amp;cd-&gt;<a class="code" href="structcl__device.html#a881ea223a07828242f8c3b02f65792db" title="Super-class.">cd_lu_dev</a>);
<a name="l00967"></a>00967 out:
<a name="l00968"></a>00968         <span class="keywordflow">switch</span>(cleanup) {
<a name="l00969"></a>00969         <span class="keywordflow">case</span> 4: {
<a name="l00970"></a>00970                 <span class="keywordtype">int</span> rc2;
<a name="l00971"></a>00971                 rc2 = echo_client_cleanup(obd);
<a name="l00972"></a>00972                 <span class="keywordflow">if</span> (rc2)
<a name="l00973"></a>00973                         CERROR(<span class="stringliteral">&quot;Cleanup obd device %s error(%d)\n&quot;</span>,
<a name="l00974"></a>00974                                obd-&gt;obd_name, rc2);
<a name="l00975"></a>00975         }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         <span class="keywordflow">case</span> 3:
<a name="l00978"></a>00978                 echo_site_fini(env, ed);
<a name="l00979"></a>00979         <span class="keywordflow">case</span> 2:
<a name="l00980"></a>00980                 cl_device_fini(&amp;ed-&gt;ed_cl);
<a name="l00981"></a>00981         <span class="keywordflow">case</span> 1:
<a name="l00982"></a>00982                 OBD_FREE_PTR(ed);
<a name="l00983"></a>00983         <span class="keywordflow">case</span> 0:
<a name="l00984"></a>00984         <span class="keywordflow">default</span>:
<a name="l00985"></a>00985                 <span class="keywordflow">break</span>;
<a name="l00986"></a>00986         }
<a name="l00987"></a>00987         <span class="keywordflow">return</span>(ERR_PTR(rc));
<a name="l00988"></a>00988 }
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_device_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *d,
<a name="l00991"></a>00991                           <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *next)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993         LBUG();
<a name="l00994"></a>00994         <span class="keywordflow">return</span> 0;
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *echo_device_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00998"></a>00998                                           <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *d)
<a name="l00999"></a>00999 {
<a name="l01000"></a>01000         <span class="keyword">struct </span>echo_device *ed = cl2echo_dev(lu2cl_dev(d));
<a name="l01001"></a>01001         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *next = ed-&gt;ed_next;
<a name="l01002"></a>01002 
<a name="l01003"></a>01003         <span class="keywordflow">while</span> (next &amp;&amp; !ed-&gt;ed_next_ismd)
<a name="l01004"></a>01004                 next = next-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>-&gt;<a class="code" href="structlu__device__type.html#a13b6c99cdcbae4f8eeb9e707d32ee8be" title="Operations for this type.">ldt_ops</a>-&gt;<a class="code" href="structlu__device__type__operations.html#a9195fd4ea14e00bbe2d9318d60694263" title="Finalize device.">ldto_device_fini</a>(env, next);
<a name="l01005"></a>01005         <span class="keywordflow">return</span> NULL;
<a name="l01006"></a>01006 }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_lock_release(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01009"></a>01009                               <span class="keyword">struct</span> echo_lock *ecl,
<a name="l01010"></a>01010                               <span class="keywordtype">int</span> still_used)
<a name="l01011"></a>01011 {
<a name="l01012"></a>01012         <span class="keyword">struct </span><a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *clk = echo_lock2cl(ecl);
<a name="l01013"></a>01013 
<a name="l01014"></a>01014         <a class="code" href="group__cl__lock.html#ga4e8069a400c6a75342649a6fc04fa2c3" title="Releases a hold and a reference on a lock, obtained by cl_lock_hold().">cl_lock_release</a>(env, clk);
<a name="l01015"></a>01015 }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *echo_device_free(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01018"></a>01018                                           <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *d)
<a name="l01019"></a>01019 {
<a name="l01020"></a>01020         <span class="keyword">struct </span>echo_device     *ed   = cl2echo_dev(lu2cl_dev(d));
<a name="l01021"></a>01021         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a> *ec   = ed-&gt;ed_ec;
<a name="l01022"></a>01022         <span class="keyword">struct </span>echo_object     *eco;
<a name="l01023"></a>01023         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>       *next = ed-&gt;ed_next;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025         CDEBUG(D_INFO, <span class="stringliteral">&quot;echo device:%p is going to be freed, next = %p\n&quot;</span>,
<a name="l01026"></a>01026                ed, next);
<a name="l01027"></a>01027 
<a name="l01028"></a>01028         <a class="code" href="group__lu.html#ga00642c90cffacaa9db84e3bb03188f0d" title="Free nr objects from the cold end of the site LRU list.">lu_site_purge</a>(env, ed-&gt;ed_site, -1);
<a name="l01029"></a>01029 
<a name="l01030"></a>01030         <span class="comment">/* check if there are objects still alive.</span>
<a name="l01031"></a>01031 <span class="comment">         * It shouldn&apos;t have any object because lu_site_purge would cleanup</span>
<a name="l01032"></a>01032 <span class="comment">         * all of cached objects. Anyway, probably the echo device is being</span>
<a name="l01033"></a>01033 <span class="comment">         * parallelly accessed.</span>
<a name="l01034"></a>01034 <span class="comment">         */</span>
<a name="l01035"></a>01035         spin_lock(&amp;ec-&gt;ec_lock);
<a name="l01036"></a>01036         list_for_each_entry(eco, &amp;ec-&gt;ec_objects, eo_obj_chain)
<a name="l01037"></a>01037                 eco-&gt;eo_deleted = 1;
<a name="l01038"></a>01038         spin_unlock(&amp;ec-&gt;ec_lock);
<a name="l01039"></a>01039 
<a name="l01040"></a>01040         <span class="comment">/* purge again */</span>
<a name="l01041"></a>01041         <a class="code" href="group__lu.html#ga00642c90cffacaa9db84e3bb03188f0d" title="Free nr objects from the cold end of the site LRU list.">lu_site_purge</a>(env, ed-&gt;ed_site, -1);
<a name="l01042"></a>01042 
<a name="l01043"></a>01043         CDEBUG(D_INFO,
<a name="l01044"></a>01044                &quot;Waiting for the reference of echo <span class="keywordtype">object</span> to be dropped\n&quot;);
<a name="l01045"></a>01045 
<a name="l01046"></a>01046         <span class="comment">/* Wait for the last reference to be dropped. */</span>
<a name="l01047"></a>01047         spin_lock(&amp;ec-&gt;ec_lock);
<a name="l01048"></a>01048         while (!list_empty(&amp;ec-&gt;ec_objects)) {
<a name="l01049"></a>01049                 spin_unlock(&amp;ec-&gt;ec_lock);
<a name="l01050"></a>01050                 CERROR(<span class="stringliteral">&quot;echo_client still has objects at cleanup time, &quot;</span>
<a name="l01051"></a>01051                        <span class="stringliteral">&quot;wait for 1 second\n&quot;</span>);
<a name="l01052"></a>01052                 set_current_state(TASK_UNINTERRUPTIBLE);
<a name="l01053"></a>01053                 schedule_timeout(cfs_time_seconds(1));
<a name="l01054"></a>01054                 <a class="code" href="group__lu.html#ga00642c90cffacaa9db84e3bb03188f0d" title="Free nr objects from the cold end of the site LRU list.">lu_site_purge</a>(env, ed-&gt;ed_site, -1);
<a name="l01055"></a>01055                 spin_lock(&amp;ec-&gt;ec_lock);
<a name="l01056"></a>01056         }
<a name="l01057"></a>01057         spin_unlock(&amp;ec-&gt;ec_lock);
<a name="l01058"></a>01058 
<a name="l01059"></a>01059         LASSERT(list_empty(&amp;ec-&gt;ec_locks));
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         CDEBUG(D_INFO, <span class="stringliteral">&quot;No object exists, exiting...\n&quot;</span>);
<a name="l01062"></a>01062 
<a name="l01063"></a>01063         echo_client_cleanup(d-&gt;<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>);
<a name="l01064"></a>01064 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l01065"></a>01065 <span class="preprocessor"></span>        echo_fid_fini(d-&gt;<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>);
<a name="l01066"></a>01066         echo_ed_los_fini(env, ed);
<a name="l01067"></a>01067 <span class="preprocessor">#endif</span>
<a name="l01068"></a>01068 <span class="preprocessor"></span>        <span class="keywordflow">while</span> (next &amp;&amp; !ed-&gt;ed_next_ismd)
<a name="l01069"></a>01069                 next = next-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>-&gt;<a class="code" href="structlu__device__type.html#a13b6c99cdcbae4f8eeb9e707d32ee8be" title="Operations for this type.">ldt_ops</a>-&gt;<a class="code" href="structlu__device__type__operations.html#a190c1198c588f2ed23ab58052f4001bf" title="Free device.">ldto_device_free</a>(env, next);
<a name="l01070"></a>01070 
<a name="l01071"></a>01071         LASSERT(ed-&gt;ed_site == d-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>);
<a name="l01072"></a>01072         echo_site_fini(env, ed);
<a name="l01073"></a>01073         cl_device_fini(&amp;ed-&gt;ed_cl);
<a name="l01074"></a>01074         OBD_FREE_PTR(ed);
<a name="l01075"></a>01075 
<a name="l01076"></a>01076         <span class="keywordflow">return</span> NULL;
<a name="l01077"></a>01077 }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__device__type__operations.html" title="Operations on a device type.">lu_device_type_operations</a> echo_device_type_ops = {
<a name="l01080"></a>01080         .<a class="code" href="structlu__device__type__operations.html#ad70bdc25eecd723bc16a4c3112397168" title="Initialize device type.">ldto_init</a> = echo_type_init,
<a name="l01081"></a>01081         .ldto_fini = echo_type_fini,
<a name="l01082"></a>01082 
<a name="l01083"></a>01083         .ldto_start = echo_type_start,
<a name="l01084"></a>01084         .ldto_stop  = echo_type_stop,
<a name="l01085"></a>01085 
<a name="l01086"></a>01086         .ldto_device_alloc = echo_device_alloc,
<a name="l01087"></a>01087         .ldto_device_free  = echo_device_free,
<a name="l01088"></a>01088         .ldto_device_init  = echo_device_init,
<a name="l01089"></a>01089         .ldto_device_fini  = echo_device_fini
<a name="l01090"></a>01090 };
<a name="l01091"></a>01091 
<a name="l01092"></a>01092 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> echo_device_type = {
<a name="l01093"></a>01093         .<a class="code" href="structlu__device__type.html#a80155fcf424540e70733a04e2a099c0c" title="Tag bits.">ldt_tags</a>     = <a class="code" href="group__lu.html#ggaa318f5b20c40de1d564f59dd72726345a6950d6daf539cb6aa3902679e6232783" title="data device in the client stack">LU_DEVICE_CL</a>,
<a name="l01094"></a>01094         .ldt_name     = LUSTRE_ECHO_CLIENT_NAME,
<a name="l01095"></a>01095         .ldt_ops      = &amp;echo_device_type_ops,
<a name="l01096"></a>01096         .ldt_ctx_tags = <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" title="Thread on client.">LCT_CL_THREAD</a> | <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa51f264f8e3ea36a381cf8aaaa9672752" title="Thread on md server.">LCT_MD_THREAD</a> | <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f" title="Thread on dt server.">LCT_DT_THREAD</a>,
<a name="l01097"></a>01097 };
<a name="l01107"></a>01107 <span class="comment">/* Interfaces to echo client obd device */</span>
<a name="l01108"></a>01108 <span class="keyword">static</span> <span class="keyword">struct </span>echo_object *
<a name="l01109"></a>01109 cl_echo_object_find(<span class="keyword">struct</span> echo_device *d, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi)
<a name="l01110"></a>01110 {
<a name="l01111"></a>01111         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01112"></a>01112         <span class="keyword">struct </span>echo_thread_info *info;
<a name="l01113"></a>01113         <span class="keyword">struct </span>echo_object_conf *conf;
<a name="l01114"></a>01114         <span class="keyword">struct </span>echo_object *eco;
<a name="l01115"></a>01115         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj;
<a name="l01116"></a>01116         <span class="keyword">struct </span><a class="code" href="structlov__oinfo.html">lov_oinfo</a> *oinfo = NULL;
<a name="l01117"></a>01117         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid;
<a name="l01118"></a>01118         __u16  refcheck;
<a name="l01119"></a>01119         <span class="keywordtype">int</span> rc;
<a name="l01120"></a>01120         ENTRY;
<a name="l01121"></a>01121 
<a name="l01122"></a>01122         LASSERTF(ostid_id(oi) != 0, DOSTID<span class="stringliteral">&quot;\n&quot;</span>, POSTID(oi));
<a name="l01123"></a>01123         LASSERTF(ostid_seq(oi) == FID_SEQ_ECHO, DOSTID<span class="stringliteral">&quot;\n&quot;</span>, POSTID(oi));
<a name="l01124"></a>01124 
<a name="l01125"></a>01125         <span class="comment">/* Never return an object if the obd is to be freed. */</span>
<a name="l01126"></a>01126         <span class="keywordflow">if</span> (echo_dev2cl(d)-&gt;cd_lu_dev.ld_obd-&gt;obd_stopping)
<a name="l01127"></a>01127                 RETURN(ERR_PTR(-ENODEV));
<a name="l01128"></a>01128 
<a name="l01129"></a>01129         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01130"></a>01130         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01131"></a>01131                 RETURN((<span class="keywordtype">void</span> *)env);
<a name="l01132"></a>01132 
<a name="l01133"></a>01133         info = echo_env_info(env);
<a name="l01134"></a>01134         conf = &amp;info-&gt;eti_conf;
<a name="l01135"></a>01135         <span class="keywordflow">if</span> (d-&gt;ed_next) {
<a name="l01136"></a>01136                 OBD_ALLOC_PTR(oinfo);
<a name="l01137"></a>01137                 <span class="keywordflow">if</span> (oinfo == NULL)
<a name="l01138"></a>01138                         GOTO(out, eco = ERR_PTR(-ENOMEM));
<a name="l01139"></a>01139 
<a name="l01140"></a>01140                 oinfo-&gt;loi_oi = *oi;
<a name="l01141"></a>01141                 conf-&gt;eoc_cl.u.coc_oinfo = oinfo;
<a name="l01142"></a>01142         }
<a name="l01143"></a>01143 
<a name="l01144"></a>01144         <span class="comment">/* If echo_object_init() is successful then ownership of oinfo</span>
<a name="l01145"></a>01145 <span class="comment">         * is transferred to the object. */</span>
<a name="l01146"></a>01146         conf-&gt;eoc_oinfo = &amp;oinfo;
<a name="l01147"></a>01147 
<a name="l01148"></a>01148         fid = &amp;info-&gt;eti_fid;
<a name="l01149"></a>01149         rc = ostid_to_fid(fid, oi, 0);
<a name="l01150"></a>01150         <span class="keywordflow">if</span> (rc != 0)
<a name="l01151"></a>01151                 GOTO(out, eco = ERR_PTR(rc));
<a name="l01152"></a>01152 
<a name="l01153"></a>01153         <span class="comment">/* In the function below, .hs_keycmp resolves to</span>
<a name="l01154"></a>01154 <span class="comment">         * lu_obj_hop_keycmp() */</span>
<a name="l01155"></a>01155         <span class="comment">/* coverity[overrun-buffer-val] */</span>
<a name="l01156"></a>01156         obj = <a class="code" href="group__cl__object.html#gacc02a64c0c65d5fab9a6fafc83771acd" title="Returns a cl_object with a given fid.">cl_object_find</a>(env, echo_dev2cl(d), fid, &amp;conf-&gt;eoc_cl);
<a name="l01157"></a>01157         <span class="keywordflow">if</span> (IS_ERR(obj))
<a name="l01158"></a>01158                 GOTO(out, eco = (<span class="keywordtype">void</span>*)obj);
<a name="l01159"></a>01159 
<a name="l01160"></a>01160         eco = cl2echo_obj(obj);
<a name="l01161"></a>01161         <span class="keywordflow">if</span> (eco-&gt;eo_deleted) {
<a name="l01162"></a>01162                 <a class="code" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put</a>(env, obj);
<a name="l01163"></a>01163                 eco = ERR_PTR(-EAGAIN);
<a name="l01164"></a>01164         }
<a name="l01165"></a>01165 
<a name="l01166"></a>01166 out:
<a name="l01167"></a>01167         <span class="keywordflow">if</span> (oinfo != NULL)
<a name="l01168"></a>01168                 OBD_FREE_PTR(oinfo);
<a name="l01169"></a>01169 
<a name="l01170"></a>01170         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01171"></a>01171         RETURN(eco);
<a name="l01172"></a>01172 }
<a name="l01173"></a>01173 
<a name="l01174"></a>01174 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_echo_object_put(<span class="keyword">struct</span> echo_object *eco)
<a name="l01175"></a>01175 {
<a name="l01176"></a>01176         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01177"></a>01177         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj = echo_obj2cl(eco);
<a name="l01178"></a>01178         __u16  refcheck;
<a name="l01179"></a>01179         ENTRY;
<a name="l01180"></a>01180 
<a name="l01181"></a>01181         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01182"></a>01182         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01183"></a>01183                 RETURN(PTR_ERR(env));
<a name="l01184"></a>01184 
<a name="l01185"></a>01185         <span class="comment">/* an external function to kill an object? */</span>
<a name="l01186"></a>01186         <span class="keywordflow">if</span> (eco-&gt;eo_deleted) {
<a name="l01187"></a>01187                 <span class="keyword">struct </span><a class="code" href="structlu__object__header.html" title="&amp;quot;Compound&amp;quot; object, consisting of multiple layers.">lu_object_header</a> *loh = obj-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>;
<a name="l01188"></a>01188                 LASSERT(&amp;eco-&gt;eo_hdr == luh2coh(loh));
<a name="l01189"></a>01189                 set_bit(<a class="code" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985aca9a04f530d5436e7996a1ff142d01d0" title="Don&amp;#39;t keep this object in cache.">LU_OBJECT_HEARD_BANSHEE</a>, &amp;loh-&gt;<a class="code" href="structlu__object__header.html#a85952a1c723e48ffa0bb7024438ac08f" title="Object flags from enum lu_object_header_flags.">loh_flags</a>);
<a name="l01190"></a>01190         }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192         <a class="code" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put</a>(env, obj);
<a name="l01193"></a>01193         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01194"></a>01194         RETURN(0);
<a name="l01195"></a>01195 }
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_echo_enqueue0(<span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> echo_object *eco,
<a name="l01198"></a>01198                             u64 start, u64 end, <span class="keywordtype">int</span> mode,
<a name="l01199"></a>01199                             __u64 *cookie , __u32 enqflags)
<a name="l01200"></a>01200 {
<a name="l01201"></a>01201         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io;
<a name="l01202"></a>01202         <span class="keyword">struct </span><a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lck;
<a name="l01203"></a>01203         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj;
<a name="l01204"></a>01204         <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *descr;
<a name="l01205"></a>01205         <span class="keyword">struct </span>echo_thread_info *info;
<a name="l01206"></a>01206         <span class="keywordtype">int</span> rc = -ENOMEM;
<a name="l01207"></a>01207         ENTRY;
<a name="l01208"></a>01208 
<a name="l01209"></a>01209         info = echo_env_info(env);
<a name="l01210"></a>01210         io = &amp;info-&gt;eti_io;
<a name="l01211"></a>01211         lck = &amp;info-&gt;eti_lock;
<a name="l01212"></a>01212         obj = echo_obj2cl(eco);
<a name="l01213"></a>01213 
<a name="l01214"></a>01214         memset(lck, 0, <span class="keyword">sizeof</span>(*lck));
<a name="l01215"></a>01215         descr = &amp;lck-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>;
<a name="l01216"></a>01216         descr-&gt;<a class="code" href="structcl__lock__descr.html#a4364f7ff8f5675436ccb006540452752" title="Object this lock is granted for.">cld_obj</a>   = obj;
<a name="l01217"></a>01217         descr-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a> = <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(obj, start);
<a name="l01218"></a>01218         descr-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>   = <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(obj, end);
<a name="l01219"></a>01219         descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a>  = mode == LCK_PW ? CLM_WRITE : CLM_READ;
<a name="l01220"></a>01220         descr-&gt;<a class="code" href="structcl__lock__descr.html#a7e923c851e4a58e9e561a3b4e2d85a2e" title="flags to enqueue lock.">cld_enq_flags</a> = enqflags;
<a name="l01221"></a>01221         io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a> = obj;
<a name="l01222"></a>01222 
<a name="l01223"></a>01223         rc = <a class="code" href="group__cl__lock.html#ga4afe671873f4a7343d9c50c574557fd6" title="Main high-level entry point of cl_lock interface that finds existing or enqueues...">cl_lock_request</a>(env, io, lck);
<a name="l01224"></a>01224         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01225"></a>01225                 <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a> *ec = eco-&gt;eo_dev-&gt;ed_ec;
<a name="l01226"></a>01226                 <span class="keyword">struct </span>echo_lock *el;
<a name="l01227"></a>01227 
<a name="l01228"></a>01228                 el = cl2echo_lock(<a class="code" href="group__cl__lock.html#ga9b59ad7624c11fcecf6eadb1a58f6f8b" title="Returns a slice with a lock, corresponding to the given layer in the device stack...">cl_lock_at</a>(lck, &amp;echo_device_type));
<a name="l01229"></a>01229                 spin_lock(&amp;ec-&gt;ec_lock);
<a name="l01230"></a>01230                 <span class="keywordflow">if</span> (list_empty(&amp;el-&gt;el_chain)) {
<a name="l01231"></a>01231                         list_add(&amp;el-&gt;el_chain, &amp;ec-&gt;ec_locks);
<a name="l01232"></a>01232                         el-&gt;el_cookie = ++ec-&gt;ec_unique;
<a name="l01233"></a>01233                 }
<a name="l01234"></a>01234                 atomic_inc(&amp;el-&gt;el_refcount);
<a name="l01235"></a>01235                 *cookie = el-&gt;el_cookie;
<a name="l01236"></a>01236                 spin_unlock(&amp;ec-&gt;ec_lock);
<a name="l01237"></a>01237         }
<a name="l01238"></a>01238         RETURN(rc);
<a name="l01239"></a>01239 }
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_echo_cancel0(<span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> echo_device *ed,
<a name="l01242"></a>01242                            __u64 cookie)
<a name="l01243"></a>01243 {
<a name="l01244"></a>01244         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a> *ec = ed-&gt;ed_ec;
<a name="l01245"></a>01245         <span class="keyword">struct </span>echo_lock       *ecl = NULL;
<a name="l01246"></a>01246         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *el;
<a name="l01247"></a>01247         <span class="keywordtype">int</span> found = 0, still_used = 0;
<a name="l01248"></a>01248         ENTRY;
<a name="l01249"></a>01249 
<a name="l01250"></a>01250         LASSERT(ec != NULL);
<a name="l01251"></a>01251         spin_lock(&amp;ec-&gt;ec_lock);
<a name="l01252"></a>01252         list_for_each(el, &amp;ec-&gt;ec_locks) {
<a name="l01253"></a>01253                 ecl = list_entry(el, <span class="keyword">struct</span> echo_lock, el_chain);
<a name="l01254"></a>01254                 CDEBUG(D_INFO, <span class="stringliteral">&quot;ecl: %p, cookie: &quot;</span>LPX64<span class="stringliteral">&quot;\n&quot;</span>, ecl, ecl-&gt;el_cookie);
<a name="l01255"></a>01255                 found = (ecl-&gt;el_cookie == cookie);
<a name="l01256"></a>01256                 <span class="keywordflow">if</span> (found) {
<a name="l01257"></a>01257                         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;ecl-&gt;el_refcount))
<a name="l01258"></a>01258                                 list_del_init(&amp;ecl-&gt;el_chain);
<a name="l01259"></a>01259                         <span class="keywordflow">else</span>
<a name="l01260"></a>01260                                 still_used = 1;
<a name="l01261"></a>01261                         <span class="keywordflow">break</span>;
<a name="l01262"></a>01262                 }
<a name="l01263"></a>01263         }
<a name="l01264"></a>01264         spin_unlock(&amp;ec-&gt;ec_lock);
<a name="l01265"></a>01265 
<a name="l01266"></a>01266         <span class="keywordflow">if</span> (!found)
<a name="l01267"></a>01267                 RETURN(-ENOENT);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269         echo_lock_release(env, ecl, still_used);
<a name="l01270"></a>01270         RETURN(0);
<a name="l01271"></a>01271 }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_commit_callback(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l01274"></a>01274                                 <span class="keyword">struct</span> <a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page)
<a name="l01275"></a>01275 {
<a name="l01276"></a>01276         <span class="keyword">struct </span>echo_thread_info *info;
<a name="l01277"></a>01277         <span class="keyword">struct </span><a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a>        *queue;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279         info = echo_env_info(env);
<a name="l01280"></a>01280         LASSERT(io == &amp;info-&gt;eti_io);
<a name="l01281"></a>01281 
<a name="l01282"></a>01282         queue = &amp;info-&gt;eti_queue;
<a name="l01283"></a>01283         <a class="code" href="group__cl__page__list.html#ga78d782095ec6f5d72e432d0ef0b35b3a" title="Adds a page to a page list.">cl_page_list_add</a>(&amp;queue-&gt;c2_qout, page);
<a name="l01284"></a>01284 }
<a name="l01285"></a>01285 
<a name="l01286"></a>01286 <span class="keyword">static</span> <span class="keywordtype">int</span> cl_echo_object_brw(<span class="keyword">struct</span> echo_object *eco, <span class="keywordtype">int</span> rw, u64 offset,
<a name="l01287"></a>01287                               <span class="keyword">struct</span> page **pages, <span class="keywordtype">int</span> npages, <span class="keywordtype">int</span> async)
<a name="l01288"></a>01288 {
<a name="l01289"></a>01289         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>           *env;
<a name="l01290"></a>01290         <span class="keyword">struct </span>echo_thread_info *info;
<a name="l01291"></a>01291         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>        *obj = echo_obj2cl(eco);
<a name="l01292"></a>01292         <span class="keyword">struct </span>echo_device      *ed  = eco-&gt;eo_dev;
<a name="l01293"></a>01293         <span class="keyword">struct </span><a class="code" href="structcl__2queue.html" title="A 2-queue of pages.">cl_2queue</a>        *queue;
<a name="l01294"></a>01294         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>            *io;
<a name="l01295"></a>01295         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>          *clp;
<a name="l01296"></a>01296         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    lh = { 0 };
<a name="l01297"></a>01297         <span class="keywordtype">int</span> page_size = cl_page_size(obj);
<a name="l01298"></a>01298         <span class="keywordtype">int</span> rc;
<a name="l01299"></a>01299         <span class="keywordtype">int</span> i;
<a name="l01300"></a>01300         __u16 refcheck;
<a name="l01301"></a>01301         ENTRY;
<a name="l01302"></a>01302 
<a name="l01303"></a>01303         LASSERT((offset &amp; ~PAGE_MASK) == 0);
<a name="l01304"></a>01304         LASSERT(ed-&gt;ed_next != NULL);
<a name="l01305"></a>01305         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01306"></a>01306         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01307"></a>01307                 RETURN(PTR_ERR(env));
<a name="l01308"></a>01308 
<a name="l01309"></a>01309         info    = echo_env_info(env);
<a name="l01310"></a>01310         io      = &amp;info-&gt;eti_io;
<a name="l01311"></a>01311         queue   = &amp;info-&gt;eti_queue;
<a name="l01312"></a>01312 
<a name="l01313"></a>01313         <a class="code" href="group__cl__page__list.html#ga395aaa5cb5dec21f83d8b07101b2aef0" title="Initialize dual page queue.">cl_2queue_init</a>(queue);
<a name="l01314"></a>01314 
<a name="l01315"></a>01315         io-&gt;<a class="code" href="structcl__io.html#a5d6c1c346a6203b03bf6fb768c6799da" title="to not refresh layout - the IO issuer knows that the layout won&amp;#39;t change(page...">ci_ignore_layout</a> = 1;
<a name="l01316"></a>01316         rc = <a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_init</a>(env, io, <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ab21ff138f79ef4d41a40950879bf1e3c" title="Miscellaneous io.">CIT_MISC</a>, obj);
<a name="l01317"></a>01317         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01318"></a>01318                 GOTO(out, rc);
<a name="l01319"></a>01319         LASSERT(rc == 0);
<a name="l01320"></a>01320 
<a name="l01321"></a>01321 
<a name="l01322"></a>01322         rc = cl_echo_enqueue0(env, eco, offset,
<a name="l01323"></a>01323                               offset + npages * PAGE_CACHE_SIZE - 1,
<a name="l01324"></a>01324                               rw == READ ? LCK_PR : LCK_PW, &amp;lh.cookie,
<a name="l01325"></a>01325                               <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a0a16d738d6f6b4a50693501adc8e310d" title="tell the sub layers that never request a `real&amp;#39; lock.">CEF_NEVER</a>);
<a name="l01326"></a>01326         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01327"></a>01327                 GOTO(error_lock, rc);
<a name="l01328"></a>01328 
<a name="l01329"></a>01329         <span class="keywordflow">for</span> (i = 0; i &lt; npages; i++) {
<a name="l01330"></a>01330                 LASSERT(pages[i]);
<a name="l01331"></a>01331                 clp = <a class="code" href="group__cl__page.html#ga448fbdaea940886c756e4a2d659982ba" title="Returns a cl_page with index idx at the object o, and associated with the VM page...">cl_page_find</a>(env, obj, <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(obj, offset),
<a name="l01332"></a>01332                                    pages[i], <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d" title="Transient page, the transient cl_page is used to bind a cl_page to vmpage which is...">CPT_TRANSIENT</a>);
<a name="l01333"></a>01333                 <span class="keywordflow">if</span> (IS_ERR(clp)) {
<a name="l01334"></a>01334                         rc = PTR_ERR(clp);
<a name="l01335"></a>01335                         <span class="keywordflow">break</span>;
<a name="l01336"></a>01336                 }
<a name="l01337"></a>01337                 LASSERT(clp-&gt;<a class="code" href="structcl__page.html#a5b1df421c69f4dd003decae6bfa71467" title="Page type.">cp_type</a> == <a class="code" href="group__cl__page.html#gga04ed60b0572c2fcfa6c2590aac97f92dacfb8e99cf8a8fdf6b00ffeb86a9cdb0d" title="Transient page, the transient cl_page is used to bind a cl_page to vmpage which is...">CPT_TRANSIENT</a>);
<a name="l01338"></a>01338 
<a name="l01339"></a>01339                 rc = <a class="code" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own</a>(env, io, clp);
<a name="l01340"></a>01340                 <span class="keywordflow">if</span> (rc) {
<a name="l01341"></a>01341                         LASSERT(clp-&gt;<a class="code" href="structcl__page.html#a96e9addda3754eb5551faaa00f94e903" title="Page state.">cp_state</a> == <a class="code" href="group__cl__page.html#gga762f808d1d3ac30a12a132d0344f1f39a77531f34ed93e3ddd0ab7c013cdd87d8" title="Page is being destroyed.">CPS_FREEING</a>);
<a name="l01342"></a>01342                         <a class="code" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1" title="Releases a reference to a page.">cl_page_put</a>(env, clp);
<a name="l01343"></a>01343                         <span class="keywordflow">break</span>;
<a name="l01344"></a>01344                 }
<a name="l01345"></a>01345 
<a name="l01346"></a>01346                 <a class="code" href="group__cl__page__list.html#ga55b5a5a4118185f0a7212299f2a65fac" title="Add a page to the incoming page list of 2-queue.">cl_2queue_add</a>(queue, clp);
<a name="l01347"></a>01347 
<a name="l01348"></a>01348                 <span class="comment">/* drop the reference count for cl_page_find, so that the page</span>
<a name="l01349"></a>01349 <span class="comment">                 * will be freed in cl_2queue_fini. */</span>
<a name="l01350"></a>01350                 <a class="code" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1" title="Releases a reference to a page.">cl_page_put</a>(env, clp);
<a name="l01351"></a>01351                 <a class="code" href="group__cl__page.html#ga2218cff8efc343a14d1c312f64e15e1f" title="Tells transfer engine that only part of a page is to be transmitted.">cl_page_clip</a>(env, clp, 0, page_size);
<a name="l01352"></a>01352 
<a name="l01353"></a>01353                 offset += page_size;
<a name="l01354"></a>01354         }
<a name="l01355"></a>01355 
<a name="l01356"></a>01356         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01357"></a>01357                 <span class="keyword">enum</span> <a class="code" href="group__cl__page.html#ga419215a2ca4eeab85983de8ca5a16a02" title="Requested transfer type.">cl_req_type</a> typ = rw == READ ? CRT_READ : CRT_WRITE;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359                 async = async &amp;&amp; (typ == CRT_WRITE);
<a name="l01360"></a>01360                 <span class="keywordflow">if</span> (async)
<a name="l01361"></a>01361                         rc = <a class="code" href="group__cl__io.html#gac830ac176054e906a54a4db48fbf45bb" title="Commit a list of contiguous pages into writeback cache.">cl_io_commit_async</a>(env, io, &amp;queue-&gt;c2_qin,
<a name="l01362"></a>01362                                                 0, PAGE_SIZE,
<a name="l01363"></a>01363                                                 echo_commit_callback);
<a name="l01364"></a>01364                 <span class="keywordflow">else</span>
<a name="l01365"></a>01365                         rc = <a class="code" href="group__cl__io.html#ga575a43e2ec65ba4aa6c926cf5e49fe70" title="Submit a sync_io and wait for the IO to be finished, or error happens.">cl_io_submit_sync</a>(env, io, typ, queue, 0);
<a name="l01366"></a>01366                 CDEBUG(D_INFO, <span class="stringliteral">&quot;echo_client %s write returns %d\n&quot;</span>,
<a name="l01367"></a>01367                        async ? <span class="stringliteral">&quot;async&quot;</span> : <span class="stringliteral">&quot;sync&quot;</span>, rc);
<a name="l01368"></a>01368         }
<a name="l01369"></a>01369 
<a name="l01370"></a>01370         cl_echo_cancel0(env, ed, lh.cookie);
<a name="l01371"></a>01371         EXIT;
<a name="l01372"></a>01372 error_lock:
<a name="l01373"></a>01373         <a class="code" href="group__cl__page__list.html#gab47261ab07f2e439b306dccb18a0980e" title="Discard (truncate) pages in both lists of a 2-queue.">cl_2queue_discard</a>(env, io, queue);
<a name="l01374"></a>01374         <a class="code" href="group__cl__page__list.html#ga70c6911b231ec808fedc50b9e27e2699" title="Disown pages in both lists of a 2-queue.">cl_2queue_disown</a>(env, io, queue);
<a name="l01375"></a>01375         <a class="code" href="group__cl__page__list.html#gafce330d7c8aa93047c5716cba8f4f379" title="Finalize both page lists of a 2-queue.">cl_2queue_fini</a>(env, queue);
<a name="l01376"></a>01376         <a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>(env, io);
<a name="l01377"></a>01377 out:
<a name="l01378"></a>01378         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01379"></a>01379         <span class="keywordflow">return</span> rc;
<a name="l01380"></a>01380 }
<a name="l01384"></a>01384 <span class="keyword">static</span> u64 last_object_id;
<a name="l01385"></a>01385 
<a name="l01386"></a>01386 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l01387"></a>01387 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> echo_md_build_name(<span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname, <span class="keywordtype">char</span> *name,
<a name="l01388"></a>01388                                       __u64 <span class="keywordtype">id</span>)
<a name="l01389"></a>01389 {
<a name="l01390"></a>01390         sprintf(name, LPU64, <span class="keywordtype">id</span>);
<a name="l01391"></a>01391         lname-&gt;ln_name = name;
<a name="l01392"></a>01392         lname-&gt;ln_namelen = strlen(name);
<a name="l01393"></a>01393 }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395 <span class="comment">/* similar to mdt_attr_get_complex */</span>
<a name="l01396"></a>01396 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_big_lmm_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *o,
<a name="l01397"></a>01397                             <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l01398"></a>01398 {
<a name="l01399"></a>01399         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01400"></a>01400         <span class="keywordtype">int</span>                      rc;
<a name="l01401"></a>01401 
<a name="l01402"></a>01402         ENTRY;
<a name="l01403"></a>01403 
<a name="l01404"></a>01404         LASSERT(ma-&gt;ma_lmm_size &gt; 0);
<a name="l01405"></a>01405 
<a name="l01406"></a>01406         rc = mo_xattr_get(env, o, &amp;<a class="code" href="group__lu.html#ga3daaf59b14be927dc4227c6fc6635c6d" title="null buffer">LU_BUF_NULL</a>, XATTR_NAME_LOV);
<a name="l01407"></a>01407         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01408"></a>01408                 RETURN(rc);
<a name="l01409"></a>01409 
<a name="l01410"></a>01410         <span class="comment">/* big_lmm may need to be grown */</span>
<a name="l01411"></a>01411         <span class="keywordflow">if</span> (info-&gt;eti_big_lmmsize &lt; rc) {
<a name="l01412"></a>01412                 <span class="keywordtype">int</span> size = size_roundup_power2(rc);
<a name="l01413"></a>01413 
<a name="l01414"></a>01414                 <span class="keywordflow">if</span> (info-&gt;eti_big_lmmsize &gt; 0) {
<a name="l01415"></a>01415                         <span class="comment">/* free old buffer */</span>
<a name="l01416"></a>01416                         LASSERT(info-&gt;eti_big_lmm);
<a name="l01417"></a>01417                         OBD_FREE_LARGE(info-&gt;eti_big_lmm,
<a name="l01418"></a>01418                                        info-&gt;eti_big_lmmsize);
<a name="l01419"></a>01419                         info-&gt;eti_big_lmm = NULL;
<a name="l01420"></a>01420                         info-&gt;eti_big_lmmsize = 0;
<a name="l01421"></a>01421                 }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423                 OBD_ALLOC_LARGE(info-&gt;eti_big_lmm, size);
<a name="l01424"></a>01424                 <span class="keywordflow">if</span> (info-&gt;eti_big_lmm == NULL)
<a name="l01425"></a>01425                         RETURN(-ENOMEM);
<a name="l01426"></a>01426                 info-&gt;eti_big_lmmsize = size;
<a name="l01427"></a>01427         }
<a name="l01428"></a>01428         LASSERT(info-&gt;eti_big_lmmsize &gt;= rc);
<a name="l01429"></a>01429 
<a name="l01430"></a>01430         info-&gt;eti_buf.lb_buf = info-&gt;eti_big_lmm;
<a name="l01431"></a>01431         info-&gt;eti_buf.lb_len = info-&gt;eti_big_lmmsize;
<a name="l01432"></a>01432         rc = mo_xattr_get(env, o, &amp;info-&gt;eti_buf, XATTR_NAME_LOV);
<a name="l01433"></a>01433         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01434"></a>01434                 RETURN(rc);
<a name="l01435"></a>01435 
<a name="l01436"></a>01436         ma-&gt;ma_valid |= MA_LOV;
<a name="l01437"></a>01437         ma-&gt;ma_lmm = info-&gt;eti_big_lmm;
<a name="l01438"></a>01438         ma-&gt;ma_lmm_size = rc;
<a name="l01439"></a>01439 
<a name="l01440"></a>01440         RETURN(0);
<a name="l01441"></a>01441 }
<a name="l01442"></a>01442 
<a name="l01443"></a>01443 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_attr_get_complex(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01444"></a>01444                                  <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *next,
<a name="l01445"></a>01445                                  <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l01446"></a>01446 {
<a name="l01447"></a>01447         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01448"></a>01448         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           *buf = &amp;info-&gt;eti_buf;
<a name="l01449"></a>01449         umode_t          mode = lu_object_attr(&amp;next-&gt;mo_lu);
<a name="l01450"></a>01450         <span class="keywordtype">int</span>                      need = ma-&gt;ma_need;
<a name="l01451"></a>01451         <span class="keywordtype">int</span>                      rc = 0, rc2;
<a name="l01452"></a>01452 
<a name="l01453"></a>01453         ENTRY;
<a name="l01454"></a>01454 
<a name="l01455"></a>01455         ma-&gt;ma_valid = 0;
<a name="l01456"></a>01456 
<a name="l01457"></a>01457         <span class="keywordflow">if</span> (need &amp; MA_INODE) {
<a name="l01458"></a>01458                 ma-&gt;ma_need = MA_INODE;
<a name="l01459"></a>01459                 rc = mo_attr_get(env, next, ma);
<a name="l01460"></a>01460                 <span class="keywordflow">if</span> (rc)
<a name="l01461"></a>01461                         GOTO(out, rc);
<a name="l01462"></a>01462                 ma-&gt;ma_valid |= MA_INODE;
<a name="l01463"></a>01463         }
<a name="l01464"></a>01464 
<a name="l01465"></a>01465         <span class="keywordflow">if</span> (need &amp; MA_LOV) {
<a name="l01466"></a>01466                 <span class="keywordflow">if</span> (S_ISREG(mode) || S_ISDIR(mode)) {
<a name="l01467"></a>01467                         LASSERT(ma-&gt;ma_lmm_size &gt; 0);
<a name="l01468"></a>01468                         buf-&gt;lb_buf = ma-&gt;ma_lmm;
<a name="l01469"></a>01469                         buf-&gt;lb_len = ma-&gt;ma_lmm_size;
<a name="l01470"></a>01470                         rc2 = mo_xattr_get(env, next, buf, XATTR_NAME_LOV);
<a name="l01471"></a>01471                         <span class="keywordflow">if</span> (rc2 &gt; 0) {
<a name="l01472"></a>01472                                 ma-&gt;ma_lmm_size = rc2;
<a name="l01473"></a>01473                                 ma-&gt;ma_valid |= MA_LOV;
<a name="l01474"></a>01474                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc2 == -ENODATA) {
<a name="l01475"></a>01475                                 <span class="comment">/* no LOV EA */</span>
<a name="l01476"></a>01476                                 ma-&gt;ma_lmm_size = 0;
<a name="l01477"></a>01477                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc2 == -ERANGE) {
<a name="l01478"></a>01478                                 rc2 = echo_big_lmm_get(env, next, ma);
<a name="l01479"></a>01479                                 <span class="keywordflow">if</span> (rc2 &lt; 0)
<a name="l01480"></a>01480                                         GOTO(out, rc = rc2);
<a name="l01481"></a>01481                         } <span class="keywordflow">else</span> {
<a name="l01482"></a>01482                                 GOTO(out, rc = rc2);
<a name="l01483"></a>01483                         }
<a name="l01484"></a>01484                 }
<a name="l01485"></a>01485         }
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 <span class="preprocessor">#ifdef CONFIG_FS_POSIX_ACL</span>
<a name="l01488"></a>01488 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (need &amp; MA_ACL_DEF &amp;&amp; S_ISDIR(mode)) {
<a name="l01489"></a>01489                 buf-&gt;lb_buf = ma-&gt;ma_acl;
<a name="l01490"></a>01490                 buf-&gt;lb_len = ma-&gt;ma_acl_size;
<a name="l01491"></a>01491                 rc2 = mo_xattr_get(env, next, buf, XATTR_NAME_ACL_DEFAULT);
<a name="l01492"></a>01492                 <span class="keywordflow">if</span> (rc2 &gt; 0) {
<a name="l01493"></a>01493                         ma-&gt;ma_acl_size = rc2;
<a name="l01494"></a>01494                         ma-&gt;ma_valid |= MA_ACL_DEF;
<a name="l01495"></a>01495                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc2 == -ENODATA) {
<a name="l01496"></a>01496                         <span class="comment">/* no ACLs */</span>
<a name="l01497"></a>01497                         ma-&gt;ma_acl_size = 0;
<a name="l01498"></a>01498                 } <span class="keywordflow">else</span> {
<a name="l01499"></a>01499                         GOTO(out, rc = rc2);
<a name="l01500"></a>01500                 }
<a name="l01501"></a>01501         }
<a name="l01502"></a>01502 <span class="preprocessor">#endif</span>
<a name="l01503"></a>01503 <span class="preprocessor"></span>out:
<a name="l01504"></a>01504         ma-&gt;ma_need = need;
<a name="l01505"></a>01505         CDEBUG(D_INODE, <span class="stringliteral">&quot;after getattr rc = %d, ma_valid = &quot;</span>LPX64<span class="stringliteral">&quot; ma_lmm=%p\n&quot;</span>,
<a name="l01506"></a>01506                rc, ma-&gt;ma_valid, ma-&gt;ma_lmm);
<a name="l01507"></a>01507         RETURN(rc);
<a name="l01508"></a>01508 }
<a name="l01509"></a>01509 
<a name="l01510"></a>01510 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01511"></a>01511 echo_md_create_internal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> echo_device *ed,
<a name="l01512"></a>01512                         <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *parent, <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l01513"></a>01513                         <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname, <span class="keyword">struct</span> <a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a> *spec,
<a name="l01514"></a>01514                         <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l01515"></a>01515 {
<a name="l01516"></a>01516         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *ec_child, *child;
<a name="l01517"></a>01517         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *ld = ed-&gt;ed_next;
<a name="l01518"></a>01518         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01519"></a>01519         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           *fid2 = &amp;info-&gt;eti_fid2;
<a name="l01520"></a>01520         <span class="keyword">struct </span><a class="code" href="structlu__object__conf.html" title="Object configuration, describing particulars of object being created.">lu_object_conf</a>    conf = { .loc_flags = LOC_F_NEW };
<a name="l01521"></a>01521         <span class="keywordtype">int</span>                      rc;
<a name="l01522"></a>01522 
<a name="l01523"></a>01523         ENTRY;
<a name="l01524"></a>01524 
<a name="l01525"></a>01525         rc = mdo_lookup(env, parent, lname, fid2, spec);
<a name="l01526"></a>01526         <span class="keywordflow">if</span> (rc == 0)
<a name="l01527"></a>01527                 <span class="keywordflow">return</span> -EEXIST;
<a name="l01528"></a>01528         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENOENT)
<a name="l01529"></a>01529                 <span class="keywordflow">return</span> rc;
<a name="l01530"></a>01530 
<a name="l01531"></a>01531         ec_child = <a class="code" href="group__lu.html#gad0df5edda743e3ab2a9165faecb8656b" title="Much like lu_object_find(), but top level device of object is specifically dev rather...">lu_object_find_at</a>(env, &amp;ed-&gt;ed_cl.cd_lu_dev,
<a name="l01532"></a>01532                                      fid, &amp;conf);
<a name="l01533"></a>01533         <span class="keywordflow">if</span> (IS_ERR(ec_child)) {
<a name="l01534"></a>01534                 CERROR(<span class="stringliteral">&quot;Can not find the child &quot;</span>DFID<span class="stringliteral">&quot;: rc = %ld\n&quot;</span>, PFID(fid),
<a name="l01535"></a>01535                         PTR_ERR(ec_child));
<a name="l01536"></a>01536                 RETURN(PTR_ERR(ec_child));
<a name="l01537"></a>01537         }
<a name="l01538"></a>01538 
<a name="l01539"></a>01539         child = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(ec_child-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l01540"></a>01540         <span class="keywordflow">if</span> (child == NULL) {
<a name="l01541"></a>01541                 CERROR(<span class="stringliteral">&quot;Can not locate the child &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>, PFID(fid));
<a name="l01542"></a>01542                 GOTO(out_put, rc = -EINVAL);
<a name="l01543"></a>01543         }
<a name="l01544"></a>01544 
<a name="l01545"></a>01545         CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;Start creating object &quot;</span>DFID<span class="stringliteral">&quot; %s %p\n&quot;</span>,
<a name="l01546"></a>01546                PFID(lu_object_fid(&amp;parent-&gt;mo_lu)), lname-&gt;ln_name, parent);
<a name="l01547"></a>01547 
<a name="l01548"></a>01548         <span class="comment">/*</span>
<a name="l01549"></a>01549 <span class="comment">         * Do not perform lookup sanity check. We know that name does not exist.</span>
<a name="l01550"></a>01550 <span class="comment">         */</span>
<a name="l01551"></a>01551         spec-&gt;sp_cr_lookup = 0;
<a name="l01552"></a>01552         rc = mdo_create(env, parent, lname, lu2md(child), spec, ma);
<a name="l01553"></a>01553         <span class="keywordflow">if</span> (rc) {
<a name="l01554"></a>01554                 CERROR(<span class="stringliteral">&quot;Can not create child &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>, PFID(fid), rc);
<a name="l01555"></a>01555                 GOTO(out_put, rc);
<a name="l01556"></a>01556         }
<a name="l01557"></a>01557         CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;End creating object &quot;</span>DFID<span class="stringliteral">&quot; %s %p rc  = %d\n&quot;</span>,
<a name="l01558"></a>01558                PFID(lu_object_fid(&amp;parent-&gt;mo_lu)), lname-&gt;ln_name, parent, rc);
<a name="l01559"></a>01559         EXIT;
<a name="l01560"></a>01560 out_put:
<a name="l01561"></a>01561         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, ec_child);
<a name="l01562"></a>01562         <span class="keywordflow">return</span> rc;
<a name="l01563"></a>01563 }
<a name="l01564"></a>01564 
<a name="l01565"></a>01565 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_set_lmm_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *ld,
<a name="l01566"></a>01566                              <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l01567"></a>01567 {
<a name="l01568"></a>01568         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01569"></a>01569 
<a name="l01570"></a>01570         <span class="keywordflow">if</span> (strcmp(ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>-&gt;<a class="code" href="structlu__device__type.html#ac5c39275e94aa3eb256a0d6ed6d2ccd2" title="Name of this class.">ldt_name</a>, LUSTRE_MDD_NAME)) {
<a name="l01571"></a>01571                 ma-&gt;ma_lmm = (<span class="keywordtype">void</span> *)&amp;info-&gt;eti_lmm;
<a name="l01572"></a>01572                 ma-&gt;ma_lmm_size = <span class="keyword">sizeof</span>(info-&gt;eti_lmm);
<a name="l01573"></a>01573         } <span class="keywordflow">else</span> {
<a name="l01574"></a>01574                 LASSERT(info-&gt;eti_big_lmmsize);
<a name="l01575"></a>01575                 ma-&gt;ma_lmm = info-&gt;eti_big_lmm;
<a name="l01576"></a>01576                 ma-&gt;ma_lmm_size = info-&gt;eti_big_lmmsize;
<a name="l01577"></a>01577         }
<a name="l01578"></a>01578 
<a name="l01579"></a>01579         <span class="keywordflow">return</span> 0;
<a name="l01580"></a>01580 }
<a name="l01581"></a>01581 
<a name="l01582"></a>01582 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_create_md_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01583"></a>01583                                  <span class="keyword">struct</span> echo_device *ed,
<a name="l01584"></a>01584                                  <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *ec_parent,
<a name="l01585"></a>01585                                  <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l01586"></a>01586                                  <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> namelen,
<a name="l01587"></a>01587                                  __u64 <span class="keywordtype">id</span>, __u32 mode, <span class="keywordtype">int</span> count,
<a name="l01588"></a>01588                                  <span class="keywordtype">int</span> stripe_count, <span class="keywordtype">int</span> stripe_offset)
<a name="l01589"></a>01589 {
<a name="l01590"></a>01590         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *parent;
<a name="l01591"></a>01591         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01592"></a>01592         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          *lname = &amp;info-&gt;eti_lname;
<a name="l01593"></a>01593         <span class="keyword">struct </span><a class="code" href="structmd__op__spec.html" title="Additional parameters for create.">md_op_spec</a>       *spec = &amp;info-&gt;eti_spec;
<a name="l01594"></a>01594         <span class="keyword">struct </span><a class="code" href="structmd__attr.html">md_attr</a>          *ma = &amp;info-&gt;eti_ma;
<a name="l01595"></a>01595         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *ld = ed-&gt;ed_next;
<a name="l01596"></a>01596         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01597"></a>01597         <span class="keywordtype">int</span>                      i;
<a name="l01598"></a>01598 
<a name="l01599"></a>01599         ENTRY;
<a name="l01600"></a>01600 
<a name="l01601"></a>01601         <span class="keywordflow">if</span> (ec_parent == NULL)
<a name="l01602"></a>01602                 <span class="keywordflow">return</span> -1;
<a name="l01603"></a>01603         parent = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(ec_parent-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l01604"></a>01604         <span class="keywordflow">if</span> (parent == NULL)
<a name="l01605"></a>01605                 RETURN(-ENXIO);
<a name="l01606"></a>01606 
<a name="l01607"></a>01607         memset(ma, 0, <span class="keyword">sizeof</span>(*ma));
<a name="l01608"></a>01608         memset(spec, 0, <span class="keyword">sizeof</span>(*spec));
<a name="l01609"></a>01609         <span class="keywordflow">if</span> (stripe_count != 0) {
<a name="l01610"></a>01610                 spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> |= FMODE_WRITE;
<a name="l01611"></a>01611                 echo_set_lmm_size(env, ld, ma);
<a name="l01612"></a>01612                 <span class="keywordflow">if</span> (stripe_count != -1) {
<a name="l01613"></a>01613                         <span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a> *lum = &amp;info-&gt;eti_lum;
<a name="l01614"></a>01614 
<a name="l01615"></a>01615                         lum-&gt;lmm_magic = LOV_USER_MAGIC_V3;
<a name="l01616"></a>01616                         lum-&gt;lmm_stripe_count = stripe_count;
<a name="l01617"></a>01617                         lum-&gt;lmm_stripe_offset = stripe_offset;
<a name="l01618"></a>01618                         lum-&gt;lmm_pattern = 0;
<a name="l01619"></a>01619                         spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadata = lum;
<a name="l01620"></a>01620                         spec-&gt;u.<a class="code" href="structmd__op__spec.html#ad74c1d49e024fdbc5a44e764a5a82c05" title="eadata for regular files">sp_ea</a>.eadatalen = <span class="keyword">sizeof</span>(*lum);
<a name="l01621"></a>01621                         spec-&gt;<a class="code" href="structmd__op__spec.html#a09fbf609da36e688e8d3d8ba8cf39ea4" title="Create flag from client: such as MDS_OPEN_CREAT, and others.">sp_cr_flags</a> |= MDS_OPEN_HAS_EA;
<a name="l01622"></a>01622                 }
<a name="l01623"></a>01623         }
<a name="l01624"></a>01624 
<a name="l01625"></a>01625         ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> = mode;
<a name="l01626"></a>01626         ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME | LA_MODE;
<a name="l01627"></a>01627         ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = cfs_time_current_64();
<a name="l01628"></a>01628 
<a name="l01629"></a>01629         <span class="keywordflow">if</span> (name != NULL) {
<a name="l01630"></a>01630                 lname-&gt;ln_name = name;
<a name="l01631"></a>01631                 lname-&gt;ln_namelen = namelen;
<a name="l01632"></a>01632                 <span class="comment">/* If name is specified, only create one object by name */</span>
<a name="l01633"></a>01633                 rc = echo_md_create_internal(env, ed, lu2md(parent), fid, lname,
<a name="l01634"></a>01634                                              spec, ma);
<a name="l01635"></a>01635                 RETURN(rc);
<a name="l01636"></a>01636         }
<a name="l01637"></a>01637 
<a name="l01638"></a>01638         <span class="comment">/* Create multiple object sequenced by id */</span>
<a name="l01639"></a>01639         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
<a name="l01640"></a>01640                 <span class="keywordtype">char</span> *tmp_name = info-&gt;eti_name;
<a name="l01641"></a>01641 
<a name="l01642"></a>01642                 echo_md_build_name(lname, tmp_name, <span class="keywordtype">id</span>);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644                 rc = echo_md_create_internal(env, ed, lu2md(parent), fid, lname,
<a name="l01645"></a>01645                                              spec, ma);
<a name="l01646"></a>01646                 <span class="keywordflow">if</span> (rc) {
<a name="l01647"></a>01647                         CERROR(<span class="stringliteral">&quot;Can not create child %s: rc = %d\n&quot;</span>, tmp_name,
<a name="l01648"></a>01648                                 rc);
<a name="l01649"></a>01649                         <span class="keywordflow">break</span>;
<a name="l01650"></a>01650                 }
<a name="l01651"></a>01651                 <span class="keywordtype">id</span>++;
<a name="l01652"></a>01652                 fid-&gt;f_oid++;
<a name="l01653"></a>01653         }
<a name="l01654"></a>01654 
<a name="l01655"></a>01655         RETURN(rc);
<a name="l01656"></a>01656 }
<a name="l01657"></a>01657 
<a name="l01658"></a>01658 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *echo_md_lookup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01659"></a>01659                                         <span class="keyword">struct</span> echo_device *ed,
<a name="l01660"></a>01660                                         <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *parent,
<a name="l01661"></a>01661                                         <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname)
<a name="l01662"></a>01662 {
<a name="l01663"></a>01663         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01664"></a>01664         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           *fid = &amp;info-&gt;eti_fid;
<a name="l01665"></a>01665         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *child;
<a name="l01666"></a>01666         <span class="keywordtype">int</span>    rc;
<a name="l01667"></a>01667         ENTRY;
<a name="l01668"></a>01668 
<a name="l01669"></a>01669         CDEBUG(D_INFO, <span class="stringliteral">&quot;lookup %s in parent &quot;</span>DFID<span class="stringliteral">&quot; %p\n&quot;</span>, lname-&gt;ln_name,
<a name="l01670"></a>01670                PFID(fid), parent);
<a name="l01671"></a>01671         rc = mdo_lookup(env, parent, lname, fid, NULL);
<a name="l01672"></a>01672         <span class="keywordflow">if</span> (rc) {
<a name="l01673"></a>01673                 CERROR(<span class="stringliteral">&quot;lookup %s: rc = %d\n&quot;</span>, lname-&gt;ln_name, rc);
<a name="l01674"></a>01674                 RETURN(ERR_PTR(rc));
<a name="l01675"></a>01675         }
<a name="l01676"></a>01676 
<a name="l01677"></a>01677         <span class="comment">/* In the function below, .hs_keycmp resolves to</span>
<a name="l01678"></a>01678 <span class="comment">         * lu_obj_hop_keycmp() */</span>
<a name="l01679"></a>01679         <span class="comment">/* coverity[overrun-buffer-val] */</span>
<a name="l01680"></a>01680         child = <a class="code" href="group__lu.html#gad0df5edda743e3ab2a9165faecb8656b" title="Much like lu_object_find(), but top level device of object is specifically dev rather...">lu_object_find_at</a>(env, &amp;ed-&gt;ed_cl.cd_lu_dev, fid, NULL);
<a name="l01681"></a>01681 
<a name="l01682"></a>01682         RETURN(child);
<a name="l01683"></a>01683 }
<a name="l01684"></a>01684 
<a name="l01685"></a>01685 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_setattr_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01686"></a>01686                                <span class="keyword">struct</span> echo_device *ed,
<a name="l01687"></a>01687                                <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *ec_parent,
<a name="l01688"></a>01688                                __u64 <span class="keywordtype">id</span>, <span class="keywordtype">int</span> count)
<a name="l01689"></a>01689 {
<a name="l01690"></a>01690         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *parent;
<a name="l01691"></a>01691         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01692"></a>01692         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          *lname = &amp;info-&gt;eti_lname;
<a name="l01693"></a>01693         <span class="keywordtype">char</span>                    *name = info-&gt;eti_name;
<a name="l01694"></a>01694         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *ld = ed-&gt;ed_next;
<a name="l01695"></a>01695         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           *buf = &amp;info-&gt;eti_buf;
<a name="l01696"></a>01696         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01697"></a>01697         <span class="keywordtype">int</span>                      i;
<a name="l01698"></a>01698 
<a name="l01699"></a>01699         ENTRY;
<a name="l01700"></a>01700 
<a name="l01701"></a>01701         <span class="keywordflow">if</span> (ec_parent == NULL)
<a name="l01702"></a>01702                 <span class="keywordflow">return</span> -1;
<a name="l01703"></a>01703         parent = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(ec_parent-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l01704"></a>01704         <span class="keywordflow">if</span> (parent == NULL)
<a name="l01705"></a>01705                 RETURN(-ENXIO);
<a name="l01706"></a>01706 
<a name="l01707"></a>01707         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
<a name="l01708"></a>01708                 <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *ec_child, *child;
<a name="l01709"></a>01709 
<a name="l01710"></a>01710                 echo_md_build_name(lname, name, <span class="keywordtype">id</span>);
<a name="l01711"></a>01711 
<a name="l01712"></a>01712                 ec_child = echo_md_lookup(env, ed, lu2md(parent), lname);
<a name="l01713"></a>01713                 <span class="keywordflow">if</span> (IS_ERR(ec_child)) {
<a name="l01714"></a>01714                         CERROR(<span class="stringliteral">&quot;Can&apos;t find child %s: rc = %ld\n&quot;</span>,
<a name="l01715"></a>01715                                 lname-&gt;ln_name, PTR_ERR(ec_child));
<a name="l01716"></a>01716                         RETURN(PTR_ERR(ec_child));
<a name="l01717"></a>01717                 }
<a name="l01718"></a>01718 
<a name="l01719"></a>01719                 child = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(ec_child-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l01720"></a>01720                 <span class="keywordflow">if</span> (child == NULL) {
<a name="l01721"></a>01721                         CERROR(<span class="stringliteral">&quot;Can not locate the child %s\n&quot;</span>, lname-&gt;ln_name);
<a name="l01722"></a>01722                         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, ec_child);
<a name="l01723"></a>01723                         rc = -EINVAL;
<a name="l01724"></a>01724                         <span class="keywordflow">break</span>;
<a name="l01725"></a>01725                 }
<a name="l01726"></a>01726 
<a name="l01727"></a>01727                 CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;Start setattr object &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01728"></a>01728                        PFID(lu_object_fid(child)));
<a name="l01729"></a>01729 
<a name="l01730"></a>01730                 buf-&gt;lb_buf = info-&gt;eti_xattr_buf;
<a name="l01731"></a>01731                 buf-&gt;lb_len = <span class="keyword">sizeof</span>(info-&gt;eti_xattr_buf);
<a name="l01732"></a>01732 
<a name="l01733"></a>01733                 sprintf(name, <span class="stringliteral">&quot;%s.test1&quot;</span>, XATTR_USER_PREFIX);
<a name="l01734"></a>01734                 rc = mo_xattr_set(env, lu2md(child), buf, name,
<a name="l01735"></a>01735                                   LU_XATTR_CREATE);
<a name="l01736"></a>01736                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01737"></a>01737                         CERROR(<span class="stringliteral">&quot;Can not setattr child &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l01738"></a>01738                                 PFID(lu_object_fid(child)), rc);
<a name="l01739"></a>01739                         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, ec_child);
<a name="l01740"></a>01740                         <span class="keywordflow">break</span>;
<a name="l01741"></a>01741                 }
<a name="l01742"></a>01742                 CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;End setattr object &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01743"></a>01743                        PFID(lu_object_fid(child)));
<a name="l01744"></a>01744                 <span class="keywordtype">id</span>++;
<a name="l01745"></a>01745                 <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, ec_child);
<a name="l01746"></a>01746         }
<a name="l01747"></a>01747         RETURN(rc);
<a name="l01748"></a>01748 }
<a name="l01749"></a>01749 
<a name="l01750"></a>01750 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_getattr_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01751"></a>01751                                <span class="keyword">struct</span> echo_device *ed,
<a name="l01752"></a>01752                                <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *ec_parent,
<a name="l01753"></a>01753                                __u64 <span class="keywordtype">id</span>, <span class="keywordtype">int</span> count)
<a name="l01754"></a>01754 {
<a name="l01755"></a>01755         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *parent;
<a name="l01756"></a>01756         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01757"></a>01757         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          *lname = &amp;info-&gt;eti_lname;
<a name="l01758"></a>01758         <span class="keywordtype">char</span>                    *name = info-&gt;eti_name;
<a name="l01759"></a>01759         <span class="keyword">struct </span><a class="code" href="structmd__attr.html">md_attr</a>          *ma = &amp;info-&gt;eti_ma;
<a name="l01760"></a>01760         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *ld = ed-&gt;ed_next;
<a name="l01761"></a>01761         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01762"></a>01762         <span class="keywordtype">int</span>                      i;
<a name="l01763"></a>01763 
<a name="l01764"></a>01764         ENTRY;
<a name="l01765"></a>01765 
<a name="l01766"></a>01766         <span class="keywordflow">if</span> (ec_parent == NULL)
<a name="l01767"></a>01767                 <span class="keywordflow">return</span> -1;
<a name="l01768"></a>01768         parent = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(ec_parent-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l01769"></a>01769         <span class="keywordflow">if</span> (parent == NULL)
<a name="l01770"></a>01770                 RETURN(-ENXIO);
<a name="l01771"></a>01771 
<a name="l01772"></a>01772         memset(ma, 0, <span class="keyword">sizeof</span>(*ma));
<a name="l01773"></a>01773         ma-&gt;ma_need |= MA_INODE | MA_LOV | MA_PFID | MA_HSM | MA_ACL_DEF;
<a name="l01774"></a>01774         ma-&gt;ma_acl = info-&gt;eti_xattr_buf;
<a name="l01775"></a>01775         ma-&gt;ma_acl_size = <span class="keyword">sizeof</span>(info-&gt;eti_xattr_buf);
<a name="l01776"></a>01776 
<a name="l01777"></a>01777         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
<a name="l01778"></a>01778                 <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *ec_child, *child;
<a name="l01779"></a>01779 
<a name="l01780"></a>01780                 ma-&gt;ma_valid = 0;
<a name="l01781"></a>01781                 echo_md_build_name(lname, name, <span class="keywordtype">id</span>);
<a name="l01782"></a>01782                 echo_set_lmm_size(env, ld, ma);
<a name="l01783"></a>01783 
<a name="l01784"></a>01784                 ec_child = echo_md_lookup(env, ed, lu2md(parent), lname);
<a name="l01785"></a>01785                 <span class="keywordflow">if</span> (IS_ERR(ec_child)) {
<a name="l01786"></a>01786                         CERROR(<span class="stringliteral">&quot;Can&apos;t find child %s: rc = %ld\n&quot;</span>,
<a name="l01787"></a>01787                                lname-&gt;ln_name, PTR_ERR(ec_child));
<a name="l01788"></a>01788                         RETURN(PTR_ERR(ec_child));
<a name="l01789"></a>01789                 }
<a name="l01790"></a>01790 
<a name="l01791"></a>01791                 child = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(ec_child-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l01792"></a>01792                 <span class="keywordflow">if</span> (child == NULL) {
<a name="l01793"></a>01793                         CERROR(<span class="stringliteral">&quot;Can not locate the child %s\n&quot;</span>, lname-&gt;ln_name);
<a name="l01794"></a>01794                         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, ec_child);
<a name="l01795"></a>01795                         RETURN(-EINVAL);
<a name="l01796"></a>01796                 }
<a name="l01797"></a>01797 
<a name="l01798"></a>01798                 CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;Start getattr object &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01799"></a>01799                        PFID(lu_object_fid(child)));
<a name="l01800"></a>01800                 rc = echo_attr_get_complex(env, lu2md(child), ma);
<a name="l01801"></a>01801                 <span class="keywordflow">if</span> (rc) {
<a name="l01802"></a>01802                         CERROR(<span class="stringliteral">&quot;Can not getattr child &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l01803"></a>01803                                 PFID(lu_object_fid(child)), rc);
<a name="l01804"></a>01804                         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, ec_child);
<a name="l01805"></a>01805                         <span class="keywordflow">break</span>;
<a name="l01806"></a>01806                 }
<a name="l01807"></a>01807                 CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;End getattr object &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01808"></a>01808                        PFID(lu_object_fid(child)));
<a name="l01809"></a>01809                 <span class="keywordtype">id</span>++;
<a name="l01810"></a>01810                 <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, ec_child);
<a name="l01811"></a>01811         }
<a name="l01812"></a>01812 
<a name="l01813"></a>01813         RETURN(rc);
<a name="l01814"></a>01814 }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_lookup_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01817"></a>01817                               <span class="keyword">struct</span> echo_device *ed,
<a name="l01818"></a>01818                               <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *ec_parent,
<a name="l01819"></a>01819                               __u64 <span class="keywordtype">id</span>, <span class="keywordtype">int</span> count)
<a name="l01820"></a>01820 {
<a name="l01821"></a>01821         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *parent;
<a name="l01822"></a>01822         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01823"></a>01823         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          *lname = &amp;info-&gt;eti_lname;
<a name="l01824"></a>01824         <span class="keywordtype">char</span>                    *name = info-&gt;eti_name;
<a name="l01825"></a>01825         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           *fid = &amp;info-&gt;eti_fid;
<a name="l01826"></a>01826         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *ld = ed-&gt;ed_next;
<a name="l01827"></a>01827         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01828"></a>01828         <span class="keywordtype">int</span>                      i;
<a name="l01829"></a>01829 
<a name="l01830"></a>01830         <span class="keywordflow">if</span> (ec_parent == NULL)
<a name="l01831"></a>01831                 <span class="keywordflow">return</span> -1;
<a name="l01832"></a>01832         parent = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(ec_parent-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l01833"></a>01833         <span class="keywordflow">if</span> (parent == NULL)
<a name="l01834"></a>01834                 <span class="keywordflow">return</span> -ENXIO;
<a name="l01835"></a>01835 
<a name="l01836"></a>01836         <span class="comment">/*prepare the requests*/</span>
<a name="l01837"></a>01837         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
<a name="l01838"></a>01838                 echo_md_build_name(lname, name, <span class="keywordtype">id</span>);
<a name="l01839"></a>01839 
<a name="l01840"></a>01840                 CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;Start lookup object &quot;</span>DFID<span class="stringliteral">&quot; %s %p\n&quot;</span>,
<a name="l01841"></a>01841                        PFID(lu_object_fid(parent)), lname-&gt;ln_name, parent);
<a name="l01842"></a>01842 
<a name="l01843"></a>01843                 rc = mdo_lookup(env, lu2md(parent), lname, fid, NULL);
<a name="l01844"></a>01844                 <span class="keywordflow">if</span> (rc) {
<a name="l01845"></a>01845                         CERROR(<span class="stringliteral">&quot;Can not lookup child %s: rc = %d\n&quot;</span>, name, rc);
<a name="l01846"></a>01846                         <span class="keywordflow">break</span>;
<a name="l01847"></a>01847                 }
<a name="l01848"></a>01848                 CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;End lookup object &quot;</span>DFID<span class="stringliteral">&quot; %s %p\n&quot;</span>,
<a name="l01849"></a>01849                        PFID(lu_object_fid(parent)), lname-&gt;ln_name, parent);
<a name="l01850"></a>01850 
<a name="l01851"></a>01851                 <span class="keywordtype">id</span>++;
<a name="l01852"></a>01852         }
<a name="l01853"></a>01853         <span class="keywordflow">return</span> rc;
<a name="l01854"></a>01854 }
<a name="l01855"></a>01855 
<a name="l01856"></a>01856 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_md_destroy_internal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01857"></a>01857                                     <span class="keyword">struct</span> echo_device *ed,
<a name="l01858"></a>01858                                     <span class="keyword">struct</span> <a class="code" href="structmd__object.html">md_object</a> *parent,
<a name="l01859"></a>01859                                     <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *lname,
<a name="l01860"></a>01860                                     <span class="keyword">struct</span> <a class="code" href="structmd__attr.html">md_attr</a> *ma)
<a name="l01861"></a>01861 {
<a name="l01862"></a>01862         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>   *ld = ed-&gt;ed_next;
<a name="l01863"></a>01863         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>   *ec_child;
<a name="l01864"></a>01864         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>   *child;
<a name="l01865"></a>01865         <span class="keywordtype">int</span>                 rc;
<a name="l01866"></a>01866 
<a name="l01867"></a>01867         ENTRY;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869         ec_child = echo_md_lookup(env, ed, parent, lname);
<a name="l01870"></a>01870         <span class="keywordflow">if</span> (IS_ERR(ec_child)) {
<a name="l01871"></a>01871                 CERROR(<span class="stringliteral">&quot;Can&apos;t find child %s: rc = %ld\n&quot;</span>, lname-&gt;ln_name,
<a name="l01872"></a>01872                         PTR_ERR(ec_child));
<a name="l01873"></a>01873                 RETURN(PTR_ERR(ec_child));
<a name="l01874"></a>01874         }
<a name="l01875"></a>01875 
<a name="l01876"></a>01876         child = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(ec_child-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l01877"></a>01877         <span class="keywordflow">if</span> (child == NULL) {
<a name="l01878"></a>01878                 CERROR(<span class="stringliteral">&quot;Can not locate the child %s\n&quot;</span>, lname-&gt;ln_name);
<a name="l01879"></a>01879                 GOTO(out_put, rc = -EINVAL);
<a name="l01880"></a>01880         }
<a name="l01881"></a>01881 
<a name="l01882"></a>01882         <span class="keywordflow">if</span> (<a class="code" href="group__lu.html#ga3f1244491405504cc9adcc3b6ce78a91" title="Check whether object on the remote storage.">lu_object_remote</a>(child)) {
<a name="l01883"></a>01883                 CERROR(<span class="stringliteral">&quot;Can not destroy remote object %s: rc = %d\n&quot;</span>,
<a name="l01884"></a>01884                        lname-&gt;ln_name, -EPERM);
<a name="l01885"></a>01885                 GOTO(out_put, rc = -EPERM);
<a name="l01886"></a>01886         }
<a name="l01887"></a>01887         CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;Start destroy object &quot;</span>DFID<span class="stringliteral">&quot; %s %p\n&quot;</span>,
<a name="l01888"></a>01888                PFID(lu_object_fid(&amp;parent-&gt;mo_lu)), lname-&gt;ln_name, parent);
<a name="l01889"></a>01889 
<a name="l01890"></a>01890         rc = mdo_unlink(env, parent, lu2md(child), lname, ma, 0);
<a name="l01891"></a>01891         <span class="keywordflow">if</span> (rc) {
<a name="l01892"></a>01892                 CERROR(<span class="stringliteral">&quot;Can not unlink child %s: rc = %d\n&quot;</span>,
<a name="l01893"></a>01893                         lname-&gt;ln_name, rc);
<a name="l01894"></a>01894                 GOTO(out_put, rc);
<a name="l01895"></a>01895         }
<a name="l01896"></a>01896         CDEBUG(D_RPCTRACE, <span class="stringliteral">&quot;End destroy object &quot;</span>DFID<span class="stringliteral">&quot; %s %p\n&quot;</span>,
<a name="l01897"></a>01897                PFID(lu_object_fid(&amp;parent-&gt;mo_lu)), lname-&gt;ln_name, parent);
<a name="l01898"></a>01898 out_put:
<a name="l01899"></a>01899         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, ec_child);
<a name="l01900"></a>01900         <span class="keywordflow">return</span> rc;
<a name="l01901"></a>01901 }
<a name="l01902"></a>01902 
<a name="l01903"></a>01903 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_destroy_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01904"></a>01904                                <span class="keyword">struct</span> echo_device *ed,
<a name="l01905"></a>01905                                <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *ec_parent,
<a name="l01906"></a>01906                                <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> namelen,
<a name="l01907"></a>01907                                __u64 <span class="keywordtype">id</span>, __u32 mode,
<a name="l01908"></a>01908                                <span class="keywordtype">int</span> count)
<a name="l01909"></a>01909 {
<a name="l01910"></a>01910         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01911"></a>01911         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          *lname = &amp;info-&gt;eti_lname;
<a name="l01912"></a>01912         <span class="keyword">struct </span><a class="code" href="structmd__attr.html">md_attr</a>          *ma = &amp;info-&gt;eti_ma;
<a name="l01913"></a>01913         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *ld = ed-&gt;ed_next;
<a name="l01914"></a>01914         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *parent;
<a name="l01915"></a>01915         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01916"></a>01916         <span class="keywordtype">int</span>                      i;
<a name="l01917"></a>01917         ENTRY;
<a name="l01918"></a>01918 
<a name="l01919"></a>01919         parent = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(ec_parent-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l01920"></a>01920         <span class="keywordflow">if</span> (parent == NULL)
<a name="l01921"></a>01921                 RETURN(-EINVAL);
<a name="l01922"></a>01922 
<a name="l01923"></a>01923         memset(ma, 0, <span class="keyword">sizeof</span>(*ma));
<a name="l01924"></a>01924         ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> = mode;
<a name="l01925"></a>01925         ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l01926"></a>01926         ma-&gt;ma_attr.<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = cfs_time_current_64();
<a name="l01927"></a>01927         ma-&gt;ma_need = MA_INODE;
<a name="l01928"></a>01928         ma-&gt;ma_valid = 0;
<a name="l01929"></a>01929 
<a name="l01930"></a>01930         <span class="keywordflow">if</span> (name != NULL) {
<a name="l01931"></a>01931                 lname-&gt;ln_name = name;
<a name="l01932"></a>01932                 lname-&gt;ln_namelen = namelen;
<a name="l01933"></a>01933                 rc = echo_md_destroy_internal(env, ed, lu2md(parent), lname,
<a name="l01934"></a>01934                                               ma);
<a name="l01935"></a>01935                 RETURN(rc);
<a name="l01936"></a>01936         }
<a name="l01937"></a>01937 
<a name="l01938"></a>01938         <span class="comment">/*prepare the requests*/</span>
<a name="l01939"></a>01939         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
<a name="l01940"></a>01940                 <span class="keywordtype">char</span> *tmp_name = info-&gt;eti_name;
<a name="l01941"></a>01941 
<a name="l01942"></a>01942                 ma-&gt;ma_valid = 0;
<a name="l01943"></a>01943                 echo_md_build_name(lname, tmp_name, <span class="keywordtype">id</span>);
<a name="l01944"></a>01944 
<a name="l01945"></a>01945                 rc = echo_md_destroy_internal(env, ed, lu2md(parent), lname,
<a name="l01946"></a>01946                                               ma);
<a name="l01947"></a>01947                 <span class="keywordflow">if</span> (rc) {
<a name="l01948"></a>01948                         CERROR(<span class="stringliteral">&quot;Can not unlink child %s: rc = %d\n&quot;</span>, name, rc);
<a name="l01949"></a>01949                         <span class="keywordflow">break</span>;
<a name="l01950"></a>01950                 }
<a name="l01951"></a>01951                 <span class="keywordtype">id</span>++;
<a name="l01952"></a>01952         }
<a name="l01953"></a>01953 
<a name="l01954"></a>01954         RETURN(rc);
<a name="l01955"></a>01955 }
<a name="l01956"></a>01956 
<a name="l01957"></a>01957 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *echo_resolve_path(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01958"></a>01958                                            <span class="keyword">struct</span> echo_device *ed, <span class="keywordtype">char</span> *path,
<a name="l01959"></a>01959                                            <span class="keywordtype">int</span> path_len)
<a name="l01960"></a>01960 {
<a name="l01961"></a>01961         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *ld = ed-&gt;ed_next;
<a name="l01962"></a>01962         <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l01963"></a>01963         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           *fid = &amp;info-&gt;eti_fid;
<a name="l01964"></a>01964         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          *lname = &amp;info-&gt;eti_lname;
<a name="l01965"></a>01965         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *parent = NULL;
<a name="l01966"></a>01966         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *child = NULL;
<a name="l01967"></a>01967         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01968"></a>01968         ENTRY;
<a name="l01969"></a>01969 
<a name="l01970"></a>01970         *fid = ed-&gt;ed_root_fid;
<a name="l01971"></a>01971 
<a name="l01972"></a>01972         <span class="comment">/* In the function below, .hs_keycmp resolves to</span>
<a name="l01973"></a>01973 <span class="comment">         * lu_obj_hop_keycmp() */</span>
<a name="l01974"></a>01974         <span class="comment">/* coverity[overrun-buffer-val] */</span>
<a name="l01975"></a>01975         parent = <a class="code" href="group__lu.html#gad0df5edda743e3ab2a9165faecb8656b" title="Much like lu_object_find(), but top level device of object is specifically dev rather...">lu_object_find_at</a>(env, &amp;ed-&gt;ed_cl.cd_lu_dev, fid, NULL);
<a name="l01976"></a>01976         <span class="keywordflow">if</span> (IS_ERR(parent)) {
<a name="l01977"></a>01977                 CERROR(<span class="stringliteral">&quot;Can not find the parent &quot;</span>DFID<span class="stringliteral">&quot;: rc = %ld\n&quot;</span>,
<a name="l01978"></a>01978                         PFID(fid), PTR_ERR(parent));
<a name="l01979"></a>01979                 RETURN(parent);
<a name="l01980"></a>01980         }
<a name="l01981"></a>01981 
<a name="l01982"></a>01982         <span class="keywordflow">while</span> (1) {
<a name="l01983"></a>01983                 <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *ld_parent;
<a name="l01984"></a>01984                 <span class="keywordtype">char</span> *e;
<a name="l01985"></a>01985 
<a name="l01986"></a>01986                 e = strsep(&amp;path, <span class="stringliteral">&quot;/&quot;</span>);
<a name="l01987"></a>01987                 <span class="keywordflow">if</span> (e == NULL)
<a name="l01988"></a>01988                         <span class="keywordflow">break</span>;
<a name="l01989"></a>01989 
<a name="l01990"></a>01990                 <span class="keywordflow">if</span> (e[0] == 0) {
<a name="l01991"></a>01991                         <span class="keywordflow">if</span> (!path || path[0] == <span class="charliteral">&apos;\0&apos;</span>)
<a name="l01992"></a>01992                                 <span class="keywordflow">break</span>;
<a name="l01993"></a>01993                         <span class="keywordflow">continue</span>;
<a name="l01994"></a>01994                 }
<a name="l01995"></a>01995 
<a name="l01996"></a>01996                 lname-&gt;ln_name = e;
<a name="l01997"></a>01997                 lname-&gt;ln_namelen = strlen(e);
<a name="l01998"></a>01998 
<a name="l01999"></a>01999                 ld_parent = <a class="code" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189" title="Given a compound object, find its slice, corresponding to the device type dtype.">lu_object_locate</a>(parent-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>);
<a name="l02000"></a>02000                 <span class="keywordflow">if</span> (ld_parent == NULL) {
<a name="l02001"></a>02001                         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, parent);
<a name="l02002"></a>02002                         rc = -EINVAL;
<a name="l02003"></a>02003                         <span class="keywordflow">break</span>;
<a name="l02004"></a>02004                 }
<a name="l02005"></a>02005 
<a name="l02006"></a>02006                 child = echo_md_lookup(env, ed, lu2md(ld_parent), lname);
<a name="l02007"></a>02007                 <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, parent);
<a name="l02008"></a>02008                 <span class="keywordflow">if</span> (IS_ERR(child)) {
<a name="l02009"></a>02009                         rc = (int)PTR_ERR(child);
<a name="l02010"></a>02010                         CERROR(<span class="stringliteral">&quot;lookup %s under parent &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l02011"></a>02011                                 lname-&gt;ln_name, PFID(lu_object_fid(ld_parent)),
<a name="l02012"></a>02012                                 rc);
<a name="l02013"></a>02013                         <span class="keywordflow">break</span>;
<a name="l02014"></a>02014                 }
<a name="l02015"></a>02015                 parent = child;
<a name="l02016"></a>02016         }
<a name="l02017"></a>02017         <span class="keywordflow">if</span> (rc)
<a name="l02018"></a>02018                 RETURN(ERR_PTR(rc));
<a name="l02019"></a>02019 
<a name="l02020"></a>02020         RETURN(parent);
<a name="l02021"></a>02021 }
<a name="l02022"></a>02022 
<a name="l02023"></a>02023 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_ucred_init(<span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l02024"></a>02024 {
<a name="l02025"></a>02025         <span class="keyword">struct </span><a class="code" href="structlu__ucred.html">lu_ucred</a> *ucred = <a class="code" href="group__md.html#ga891ea36420f73975ab3f7cc8bd1b3802" title="Get ucred key if session exists and ucred key is allocated on it.">lu_ucred</a>(env);
<a name="l02026"></a>02026 
<a name="l02027"></a>02027         ucred-&gt;uc_valid = UCRED_INVALID;
<a name="l02028"></a>02028 
<a name="l02029"></a>02029         ucred-&gt;uc_suppgids[0] = -1;
<a name="l02030"></a>02030         ucred-&gt;uc_suppgids[1] = -1;
<a name="l02031"></a>02031 
<a name="l02032"></a>02032         ucred-&gt;uc_uid = ucred-&gt;uc_o_uid  =
<a name="l02033"></a>02033                                 from_kuid(&amp;init_user_ns, current_uid());
<a name="l02034"></a>02034         ucred-&gt;uc_gid = ucred-&gt;uc_o_gid  =
<a name="l02035"></a>02035                                 from_kgid(&amp;init_user_ns, current_gid());
<a name="l02036"></a>02036         ucred-&gt;uc_fsuid = ucred-&gt;uc_o_fsuid =
<a name="l02037"></a>02037                                 from_kuid(&amp;init_user_ns, current_fsuid());
<a name="l02038"></a>02038         ucred-&gt;uc_fsgid = ucred-&gt;uc_o_fsgid =
<a name="l02039"></a>02039                                 from_kgid(&amp;init_user_ns, current_fsgid());
<a name="l02040"></a>02040         ucred-&gt;uc_cap = cfs_curproc_cap_pack();
<a name="l02041"></a>02041 
<a name="l02042"></a>02042         <span class="comment">/* remove fs privilege for non-root user. */</span>
<a name="l02043"></a>02043         <span class="keywordflow">if</span> (ucred-&gt;uc_fsuid)
<a name="l02044"></a>02044                 ucred-&gt;uc_cap &amp;= ~CFS_CAP_FS_MASK;
<a name="l02045"></a>02045         ucred-&gt;uc_valid = UCRED_NEW;
<a name="l02046"></a>02046 }
<a name="l02047"></a>02047 
<a name="l02048"></a>02048 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_ucred_fini(<span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env)
<a name="l02049"></a>02049 {
<a name="l02050"></a>02050         <span class="keyword">struct </span><a class="code" href="structlu__ucred.html">lu_ucred</a> *ucred = <a class="code" href="group__md.html#ga891ea36420f73975ab3f7cc8bd1b3802" title="Get ucred key if session exists and ucred key is allocated on it.">lu_ucred</a>(env);
<a name="l02051"></a>02051         ucred-&gt;uc_valid = UCRED_INIT;
<a name="l02052"></a>02052 }
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 <span class="preprocessor">#define ECHO_MD_CTX_TAG (LCT_REMEMBER | LCT_MD_THREAD)</span>
<a name="l02055"></a>02055 <span class="preprocessor"></span><span class="preprocessor">#define ECHO_MD_SES_TAG (LCT_REMEMBER | LCT_SESSION | LCT_SERVER_SESSION)</span>
<a name="l02056"></a>02056 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> echo_md_handler(<span class="keyword">struct</span> echo_device *ed, <span class="keywordtype">int</span> command,
<a name="l02057"></a>02057                            <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> path_len, __u64 <span class="keywordtype">id</span>, <span class="keywordtype">int</span> count,
<a name="l02058"></a>02058                            <span class="keyword">struct</span> <a class="code" href="structobd__ioctl__data.html">obd_ioctl_data</a> *data)
<a name="l02059"></a>02059 {
<a name="l02060"></a>02060         <span class="keyword">struct </span>echo_thread_info *info;
<a name="l02061"></a>02061         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>      *ld = ed-&gt;ed_next;
<a name="l02062"></a>02062         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>         *env;
<a name="l02063"></a>02063         __u16                  refcheck;
<a name="l02064"></a>02064         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>      *parent;
<a name="l02065"></a>02065         <span class="keywordtype">char</span>                  *name = NULL;
<a name="l02066"></a>02066         <span class="keywordtype">int</span>                    namelen = data-&gt;ioc_plen2;
<a name="l02067"></a>02067         <span class="keywordtype">int</span>                    rc = 0;
<a name="l02068"></a>02068         ENTRY;
<a name="l02069"></a>02069 
<a name="l02070"></a>02070         <span class="keywordflow">if</span> (ld == NULL) {
<a name="l02071"></a>02071                 CERROR(<span class="stringliteral">&quot;MD echo client is not being initialized properly\n&quot;</span>);
<a name="l02072"></a>02072                 RETURN(-EINVAL);
<a name="l02073"></a>02073         }
<a name="l02074"></a>02074 
<a name="l02075"></a>02075         <span class="keywordflow">if</span> (strcmp(ld-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>-&gt;<a class="code" href="structlu__device__type.html#ac5c39275e94aa3eb256a0d6ed6d2ccd2" title="Name of this class.">ldt_name</a>, LUSTRE_MDD_NAME)) {
<a name="l02076"></a>02076                 CERROR(<span class="stringliteral">&quot;Only support MDD layer right now!\n&quot;</span>);
<a name="l02077"></a>02077                 RETURN(-EINVAL);
<a name="l02078"></a>02078         }
<a name="l02079"></a>02079 
<a name="l02080"></a>02080         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l02081"></a>02081         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l02082"></a>02082                 RETURN(PTR_ERR(env));
<a name="l02083"></a>02083 
<a name="l02084"></a>02084         rc = <a class="code" href="group__lu.html#gae86c05e9998dce0a3860d0456394c559" title="Currently, this API will only be used by echo client.">lu_env_refill_by_tags</a>(env, ECHO_MD_CTX_TAG, ECHO_MD_SES_TAG);
<a name="l02085"></a>02085         <span class="keywordflow">if</span> (rc != 0)
<a name="l02086"></a>02086                 GOTO(out_env, rc);
<a name="l02087"></a>02087 
<a name="l02088"></a>02088         <span class="comment">/* init big_lmm buffer */</span>
<a name="l02089"></a>02089         info = echo_env_info(env);
<a name="l02090"></a>02090         LASSERT(info-&gt;eti_big_lmm == NULL);
<a name="l02091"></a>02091         OBD_ALLOC_LARGE(info-&gt;eti_big_lmm, MIN_MD_SIZE);
<a name="l02092"></a>02092         <span class="keywordflow">if</span> (info-&gt;eti_big_lmm == NULL)
<a name="l02093"></a>02093                 GOTO(out_env, rc = -ENOMEM);
<a name="l02094"></a>02094         info-&gt;eti_big_lmmsize = MIN_MD_SIZE;
<a name="l02095"></a>02095 
<a name="l02096"></a>02096         parent = echo_resolve_path(env, ed, path, path_len);
<a name="l02097"></a>02097         <span class="keywordflow">if</span> (IS_ERR(parent)) {
<a name="l02098"></a>02098                 CERROR(<span class="stringliteral">&quot;Can not resolve the path %s: rc = %ld\n&quot;</span>, path,
<a name="l02099"></a>02099                         PTR_ERR(parent));
<a name="l02100"></a>02100                 GOTO(out_free, rc = PTR_ERR(parent));
<a name="l02101"></a>02101         }
<a name="l02102"></a>02102 
<a name="l02103"></a>02103         <span class="keywordflow">if</span> (namelen &gt; 0) {
<a name="l02104"></a>02104                 OBD_ALLOC(name, namelen + 1);
<a name="l02105"></a>02105                 <span class="keywordflow">if</span> (name == NULL)
<a name="l02106"></a>02106                         GOTO(out_put, rc = -ENOMEM);
<a name="l02107"></a>02107                 <span class="keywordflow">if</span> (copy_from_user(name, data-&gt;ioc_pbuf2, namelen))
<a name="l02108"></a>02108                         GOTO(out_name, rc = -EFAULT);
<a name="l02109"></a>02109         }
<a name="l02110"></a>02110 
<a name="l02111"></a>02111         echo_ucred_init(env);
<a name="l02112"></a>02112 
<a name="l02113"></a>02113         <span class="keywordflow">switch</span> (command) {
<a name="l02114"></a>02114         <span class="keywordflow">case</span> ECHO_MD_CREATE:
<a name="l02115"></a>02115         <span class="keywordflow">case</span> ECHO_MD_MKDIR: {
<a name="l02116"></a>02116                 <span class="keyword">struct </span>echo_thread_info *info = echo_env_info(env);
<a name="l02117"></a>02117                 __u32 mode = data-&gt;ioc_obdo2.o_mode;
<a name="l02118"></a>02118                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid = &amp;info-&gt;eti_fid;
<a name="l02119"></a>02119                 <span class="keywordtype">int</span> stripe_count = (int)data-&gt;ioc_obdo2.o_misc;
<a name="l02120"></a>02120                 <span class="keywordtype">int</span> stripe_index = (<span class="keywordtype">int</span>)data-&gt;ioc_obdo2.o_stripe_idx;
<a name="l02121"></a>02121 
<a name="l02122"></a>02122                 rc = ostid_to_fid(fid, &amp;data-&gt;ioc_obdo1.o_oi, 0);
<a name="l02123"></a>02123                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02124"></a>02124                         <span class="keywordflow">break</span>;
<a name="l02125"></a>02125 
<a name="l02126"></a>02126                 <span class="comment">/* In the function below, .hs_keycmp resolves to</span>
<a name="l02127"></a>02127 <span class="comment">                 * lu_obj_hop_keycmp() */</span>
<a name="l02128"></a>02128                 <span class="comment">/* coverity[overrun-buffer-val] */</span>
<a name="l02129"></a>02129                 rc = echo_create_md_object(env, ed, parent, fid, name, namelen,
<a name="l02130"></a>02130                                            <span class="keywordtype">id</span>, mode, count, stripe_count,
<a name="l02131"></a>02131                                            stripe_index);
<a name="l02132"></a>02132                 <span class="keywordflow">break</span>;
<a name="l02133"></a>02133         }
<a name="l02134"></a>02134         <span class="keywordflow">case</span> ECHO_MD_DESTROY:
<a name="l02135"></a>02135         <span class="keywordflow">case</span> ECHO_MD_RMDIR: {
<a name="l02136"></a>02136                 __u32 mode = data-&gt;ioc_obdo2.o_mode;
<a name="l02137"></a>02137 
<a name="l02138"></a>02138                 rc = echo_destroy_object(env, ed, parent, name, namelen,
<a name="l02139"></a>02139                                          <span class="keywordtype">id</span>, mode, count);
<a name="l02140"></a>02140                 <span class="keywordflow">break</span>;
<a name="l02141"></a>02141         }
<a name="l02142"></a>02142         <span class="keywordflow">case</span> ECHO_MD_LOOKUP:
<a name="l02143"></a>02143                 rc = echo_lookup_object(env, ed, parent, <span class="keywordtype">id</span>, count);
<a name="l02144"></a>02144                 <span class="keywordflow">break</span>;
<a name="l02145"></a>02145         <span class="keywordflow">case</span> ECHO_MD_GETATTR:
<a name="l02146"></a>02146                 rc = echo_getattr_object(env, ed, parent, <span class="keywordtype">id</span>, count);
<a name="l02147"></a>02147                 <span class="keywordflow">break</span>;
<a name="l02148"></a>02148         <span class="keywordflow">case</span> ECHO_MD_SETATTR:
<a name="l02149"></a>02149                 rc = echo_setattr_object(env, ed, parent, <span class="keywordtype">id</span>, count);
<a name="l02150"></a>02150                 <span class="keywordflow">break</span>;
<a name="l02151"></a>02151         <span class="keywordflow">default</span>:
<a name="l02152"></a>02152                 CERROR(<span class="stringliteral">&quot;unknown command %d\n&quot;</span>, command);
<a name="l02153"></a>02153                 rc = -EINVAL;
<a name="l02154"></a>02154                 <span class="keywordflow">break</span>;
<a name="l02155"></a>02155         }
<a name="l02156"></a>02156         echo_ucred_fini(env);
<a name="l02157"></a>02157 
<a name="l02158"></a>02158 out_name:
<a name="l02159"></a>02159         <span class="keywordflow">if</span> (name != NULL)
<a name="l02160"></a>02160                 OBD_FREE(name, namelen + 1);
<a name="l02161"></a>02161 out_put:
<a name="l02162"></a>02162         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, parent);
<a name="l02163"></a>02163 out_free:
<a name="l02164"></a>02164         LASSERT(info-&gt;eti_big_lmm);
<a name="l02165"></a>02165         OBD_FREE_LARGE(info-&gt;eti_big_lmm, info-&gt;eti_big_lmmsize);
<a name="l02166"></a>02166         info-&gt;eti_big_lmm = NULL;
<a name="l02167"></a>02167         info-&gt;eti_big_lmmsize = 0;
<a name="l02168"></a>02168 out_env:
<a name="l02169"></a>02169         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l02170"></a>02170         <span class="keywordflow">return</span> rc;
<a name="l02171"></a>02171 }
<a name="l02172"></a>02172 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
<a name="l02173"></a>02173 
<a name="l02174"></a>02174 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_create_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> echo_device *ed,
<a name="l02175"></a>02175                               <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa)
<a name="l02176"></a>02176 {
<a name="l02177"></a>02177         <span class="keyword">struct </span>echo_object      *eco;
<a name="l02178"></a>02178         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a>  *ec = ed-&gt;ed_ec;
<a name="l02179"></a>02179         <span class="keywordtype">int</span> created = 0;
<a name="l02180"></a>02180         <span class="keywordtype">int</span> rc;
<a name="l02181"></a>02181         ENTRY;
<a name="l02182"></a>02182 
<a name="l02183"></a>02183         <span class="keywordflow">if</span> (!(oa-&gt;o_valid &amp; OBD_MD_FLID) ||
<a name="l02184"></a>02184             !(oa-&gt;o_valid &amp; OBD_MD_FLGROUP) ||
<a name="l02185"></a>02185             !fid_seq_is_echo(ostid_seq(&amp;oa-&gt;o_oi))) {
<a name="l02186"></a>02186                 CERROR(<span class="stringliteral">&quot;invalid oid &quot;</span>DOSTID<span class="stringliteral">&quot;\n&quot;</span>, POSTID(&amp;oa-&gt;o_oi));
<a name="l02187"></a>02187                 RETURN(-EINVAL);
<a name="l02188"></a>02188         }
<a name="l02189"></a>02189 
<a name="l02190"></a>02190         <span class="keywordflow">if</span> (ostid_id(&amp;oa-&gt;o_oi) == 0)
<a name="l02191"></a>02191                 ostid_set_id(&amp;oa-&gt;o_oi, ++last_object_id);
<a name="l02192"></a>02192 
<a name="l02193"></a>02193         rc = obd_create(env, ec-&gt;ec_exp, oa);
<a name="l02194"></a>02194         <span class="keywordflow">if</span> (rc != 0) {
<a name="l02195"></a>02195                 CERROR(<span class="stringliteral">&quot;Cannot create objects: rc = %d\n&quot;</span>, rc);
<a name="l02196"></a>02196                 GOTO(failed, rc);
<a name="l02197"></a>02197         }
<a name="l02198"></a>02198 
<a name="l02199"></a>02199         created = 1;
<a name="l02200"></a>02200 
<a name="l02201"></a>02201         oa-&gt;o_valid |= OBD_MD_FLID;
<a name="l02202"></a>02202 
<a name="l02203"></a>02203         eco = cl_echo_object_find(ed, &amp;oa-&gt;o_oi);
<a name="l02204"></a>02204         <span class="keywordflow">if</span> (IS_ERR(eco))
<a name="l02205"></a>02205                 GOTO(failed, rc = PTR_ERR(eco));
<a name="l02206"></a>02206         cl_echo_object_put(eco);
<a name="l02207"></a>02207 
<a name="l02208"></a>02208         CDEBUG(D_INFO, <span class="stringliteral">&quot;oa oid &quot;</span>DOSTID<span class="stringliteral">&quot;\n&quot;</span>, POSTID(&amp;oa-&gt;o_oi));
<a name="l02209"></a>02209         EXIT;
<a name="l02210"></a>02210 
<a name="l02211"></a>02211 failed:
<a name="l02212"></a>02212         <span class="keywordflow">if</span> (created &amp;&amp; rc != 0)
<a name="l02213"></a>02213                 obd_destroy(env, ec-&gt;ec_exp, oa);
<a name="l02214"></a>02214 
<a name="l02215"></a>02215         <span class="keywordflow">if</span> (rc != 0)
<a name="l02216"></a>02216                 CERROR(<span class="stringliteral">&quot;create object failed with: rc = %d\n&quot;</span>, rc);
<a name="l02217"></a>02217 
<a name="l02218"></a>02218         <span class="keywordflow">return</span> rc;
<a name="l02219"></a>02219 }
<a name="l02220"></a>02220 
<a name="l02221"></a>02221 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_get_object(<span class="keyword">struct</span> echo_object **ecop, <span class="keyword">struct</span> echo_device *ed,
<a name="l02222"></a>02222                            <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa)
<a name="l02223"></a>02223 {
<a name="l02224"></a>02224         <span class="keyword">struct </span>echo_object *eco;
<a name="l02225"></a>02225         <span class="keywordtype">int</span> rc;
<a name="l02226"></a>02226         ENTRY;
<a name="l02227"></a>02227 
<a name="l02228"></a>02228         <span class="keywordflow">if</span> (!(oa-&gt;o_valid &amp; OBD_MD_FLID) ||
<a name="l02229"></a>02229             !(oa-&gt;o_valid &amp; OBD_MD_FLGROUP) ||
<a name="l02230"></a>02230             ostid_id(&amp;oa-&gt;o_oi) == 0) {
<a name="l02231"></a>02231                 CERROR(<span class="stringliteral">&quot;invalid oid &quot;</span>DOSTID<span class="stringliteral">&quot;\n&quot;</span>, POSTID(&amp;oa-&gt;o_oi));
<a name="l02232"></a>02232                 RETURN(-EINVAL);
<a name="l02233"></a>02233         }
<a name="l02234"></a>02234 
<a name="l02235"></a>02235         rc = 0;
<a name="l02236"></a>02236         eco = cl_echo_object_find(ed, &amp;oa-&gt;o_oi);
<a name="l02237"></a>02237         <span class="keywordflow">if</span> (!IS_ERR(eco))
<a name="l02238"></a>02238                 *ecop = eco;
<a name="l02239"></a>02239         <span class="keywordflow">else</span>
<a name="l02240"></a>02240                 rc = PTR_ERR(eco);
<a name="l02241"></a>02241 
<a name="l02242"></a>02242         RETURN(rc);
<a name="l02243"></a>02243 }
<a name="l02244"></a>02244 
<a name="l02245"></a>02245 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_put_object(<span class="keyword">struct</span> echo_object *eco)
<a name="l02246"></a>02246 {
<a name="l02247"></a>02247         <span class="keywordtype">int</span> rc;
<a name="l02248"></a>02248 
<a name="l02249"></a>02249         rc = cl_echo_object_put(eco);
<a name="l02250"></a>02250         <span class="keywordflow">if</span> (rc)
<a name="l02251"></a>02251                 CERROR(<span class="stringliteral">&quot;%s: echo client drop an object failed: rc = %d\n&quot;</span>,
<a name="l02252"></a>02252                        eco-&gt;eo_dev-&gt;ed_ec-&gt;ec_exp-&gt;exp_obd-&gt;obd_name, rc);
<a name="l02253"></a>02253 }
<a name="l02254"></a>02254 
<a name="l02255"></a>02255 <span class="keyword">static</span> <span class="keywordtype">void</span> echo_client_page_debug_setup(<span class="keyword">struct</span> page *page, <span class="keywordtype">int</span> rw, u64 <span class="keywordtype">id</span>,
<a name="l02256"></a>02256                                          u64 offset, u64 count)
<a name="l02257"></a>02257 {
<a name="l02258"></a>02258         <span class="keywordtype">char</span>    *addr;
<a name="l02259"></a>02259         u64      stripe_off;
<a name="l02260"></a>02260         u64      stripe_id;
<a name="l02261"></a>02261         <span class="keywordtype">int</span>      delta;
<a name="l02262"></a>02262 
<a name="l02263"></a>02263         <span class="comment">/* no partial pages on the client */</span>
<a name="l02264"></a>02264         LASSERT(count == PAGE_CACHE_SIZE);
<a name="l02265"></a>02265 
<a name="l02266"></a>02266         addr = kmap(page);
<a name="l02267"></a>02267 
<a name="l02268"></a>02268         <span class="keywordflow">for</span> (delta = 0; delta &lt; PAGE_CACHE_SIZE; delta += OBD_ECHO_BLOCK_SIZE) {
<a name="l02269"></a>02269                 <span class="keywordflow">if</span> (rw == OBD_BRW_WRITE) {
<a name="l02270"></a>02270                         stripe_off = offset + delta;
<a name="l02271"></a>02271                         stripe_id = id;
<a name="l02272"></a>02272                 } <span class="keywordflow">else</span> {
<a name="l02273"></a>02273                         stripe_off = 0xdeadbeef00c0ffeeULL;
<a name="l02274"></a>02274                         stripe_id = 0xdeadbeef00c0ffeeULL;
<a name="l02275"></a>02275                 }
<a name="l02276"></a>02276                 block_debug_setup(addr + delta, OBD_ECHO_BLOCK_SIZE,
<a name="l02277"></a>02277                                   stripe_off, stripe_id);
<a name="l02278"></a>02278         }
<a name="l02279"></a>02279 
<a name="l02280"></a>02280         kunmap(page);
<a name="l02281"></a>02281 }
<a name="l02282"></a>02282 
<a name="l02283"></a>02283 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02284"></a>02284 echo_client_page_debug_check(<span class="keyword">struct</span> page *page, u64 <span class="keywordtype">id</span>, u64 offset, u64 count)
<a name="l02285"></a>02285 {
<a name="l02286"></a>02286         u64      stripe_off;
<a name="l02287"></a>02287         u64      stripe_id;
<a name="l02288"></a>02288         <span class="keywordtype">char</span>   *addr;
<a name="l02289"></a>02289         <span class="keywordtype">int</span>     delta;
<a name="l02290"></a>02290         <span class="keywordtype">int</span>     rc;
<a name="l02291"></a>02291         <span class="keywordtype">int</span>     rc2;
<a name="l02292"></a>02292 
<a name="l02293"></a>02293         <span class="comment">/* no partial pages on the client */</span>
<a name="l02294"></a>02294         LASSERT(count == PAGE_CACHE_SIZE);
<a name="l02295"></a>02295 
<a name="l02296"></a>02296         addr = kmap(page);
<a name="l02297"></a>02297 
<a name="l02298"></a>02298         <span class="keywordflow">for</span> (rc = delta = 0; delta &lt; PAGE_CACHE_SIZE; delta += OBD_ECHO_BLOCK_SIZE) {
<a name="l02299"></a>02299                 stripe_off = offset + delta;
<a name="l02300"></a>02300                 stripe_id = id;
<a name="l02301"></a>02301 
<a name="l02302"></a>02302                 rc2 = block_debug_check(<span class="stringliteral">&quot;test_brw&quot;</span>,
<a name="l02303"></a>02303                                         addr + delta, OBD_ECHO_BLOCK_SIZE,
<a name="l02304"></a>02304                                         stripe_off, stripe_id);
<a name="l02305"></a>02305                 <span class="keywordflow">if</span> (rc2 != 0) {
<a name="l02306"></a>02306                         CERROR (<span class="stringliteral">&quot;Error in echo object &quot;</span>LPX64<span class="stringliteral">&quot;\n&quot;</span>, <span class="keywordtype">id</span>);
<a name="l02307"></a>02307                         rc = rc2;
<a name="l02308"></a>02308                 }
<a name="l02309"></a>02309         }
<a name="l02310"></a>02310 
<a name="l02311"></a>02311         kunmap(page);
<a name="l02312"></a>02312         <span class="keywordflow">return</span> rc;
<a name="l02313"></a>02313 }
<a name="l02314"></a>02314 
<a name="l02315"></a>02315 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_client_kbrw(<span class="keyword">struct</span> echo_device *ed, <span class="keywordtype">int</span> rw, <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa,
<a name="l02316"></a>02316                             <span class="keyword">struct</span> echo_object *eco, u64 offset,
<a name="l02317"></a>02317                             u64 count, <span class="keywordtype">int</span> async)
<a name="l02318"></a>02318 {
<a name="l02319"></a>02319         <span class="keywordtype">size_t</span>                  npages;
<a name="l02320"></a>02320         <span class="keyword">struct </span><a class="code" href="structbrw__page.html">brw_page</a>        *pga;
<a name="l02321"></a>02321         <span class="keyword">struct </span><a class="code" href="structbrw__page.html">brw_page</a>        *pgp;
<a name="l02322"></a>02322         <span class="keyword">struct </span>page            **pages;
<a name="l02323"></a>02323         u64                      off;
<a name="l02324"></a>02324         <span class="keywordtype">size_t</span>                  i;
<a name="l02325"></a>02325         <span class="keywordtype">int</span>                     rc;
<a name="l02326"></a>02326         <span class="keywordtype">int</span>                     verify;
<a name="l02327"></a>02327         gfp_t                   gfp_mask;
<a name="l02328"></a>02328         u32                     brw_flags = 0;
<a name="l02329"></a>02329         ENTRY;
<a name="l02330"></a>02330 
<a name="l02331"></a>02331         verify = (ostid_id(&amp;oa-&gt;o_oi) != ECHO_PERSISTENT_OBJID &amp;&amp;
<a name="l02332"></a>02332                   (oa-&gt;o_valid &amp; OBD_MD_FLFLAGS) != 0 &amp;&amp;
<a name="l02333"></a>02333                   (oa-&gt;o_flags &amp; OBD_FL_DEBUG_CHECK) != 0);
<a name="l02334"></a>02334 
<a name="l02335"></a>02335         gfp_mask = ((ostid_id(&amp;oa-&gt;o_oi) &amp; 2) == 0) ? GFP_KERNEL : GFP_HIGHUSER;
<a name="l02336"></a>02336 
<a name="l02337"></a>02337         LASSERT(rw == OBD_BRW_WRITE || rw == OBD_BRW_READ);
<a name="l02338"></a>02338 
<a name="l02339"></a>02339         <span class="keywordflow">if</span> ((count &amp; (~PAGE_MASK)) != 0)
<a name="l02340"></a>02340                 RETURN(-EINVAL);
<a name="l02341"></a>02341 
<a name="l02342"></a>02342         <span class="comment">/* XXX think again with misaligned I/O */</span>
<a name="l02343"></a>02343         npages = count &gt;&gt; PAGE_CACHE_SHIFT;
<a name="l02344"></a>02344 
<a name="l02345"></a>02345         <span class="keywordflow">if</span> (rw == OBD_BRW_WRITE)
<a name="l02346"></a>02346                 brw_flags = OBD_BRW_ASYNC;
<a name="l02347"></a>02347 
<a name="l02348"></a>02348         OBD_ALLOC(pga, npages * <span class="keyword">sizeof</span>(*pga));
<a name="l02349"></a>02349         <span class="keywordflow">if</span> (pga == NULL)
<a name="l02350"></a>02350                 RETURN(-ENOMEM);
<a name="l02351"></a>02351 
<a name="l02352"></a>02352         OBD_ALLOC(pages, npages * <span class="keyword">sizeof</span>(*pages));
<a name="l02353"></a>02353         <span class="keywordflow">if</span> (pages == NULL) {
<a name="l02354"></a>02354                 OBD_FREE(pga, npages * <span class="keyword">sizeof</span>(*pga));
<a name="l02355"></a>02355                 RETURN(-ENOMEM);
<a name="l02356"></a>02356         }
<a name="l02357"></a>02357 
<a name="l02358"></a>02358         <span class="keywordflow">for</span> (i = 0, pgp = pga, off = offset;
<a name="l02359"></a>02359              i &lt; npages;
<a name="l02360"></a>02360              i++, pgp++, off += PAGE_CACHE_SIZE) {
<a name="l02361"></a>02361 
<a name="l02362"></a>02362                 LASSERT(pgp-&gt;pg == NULL);       <span class="comment">/* for cleanup */</span>
<a name="l02363"></a>02363 
<a name="l02364"></a>02364                 rc = -ENOMEM;
<a name="l02365"></a>02365                 pgp-&gt;pg = alloc_page(gfp_mask);
<a name="l02366"></a>02366                 <span class="keywordflow">if</span> (pgp-&gt;pg == NULL)
<a name="l02367"></a>02367                         <span class="keywordflow">goto</span> out;
<a name="l02368"></a>02368 
<a name="l02369"></a>02369                 pages[i] = pgp-&gt;pg;
<a name="l02370"></a>02370                 pgp-&gt;count = PAGE_CACHE_SIZE;
<a name="l02371"></a>02371                 pgp-&gt;off = off;
<a name="l02372"></a>02372                 pgp-&gt;flag = brw_flags;
<a name="l02373"></a>02373 
<a name="l02374"></a>02374                 <span class="keywordflow">if</span> (verify)
<a name="l02375"></a>02375                         echo_client_page_debug_setup(pgp-&gt;pg, rw,
<a name="l02376"></a>02376                                                      ostid_id(&amp;oa-&gt;o_oi), off,
<a name="l02377"></a>02377                                                      pgp-&gt;count);
<a name="l02378"></a>02378         }
<a name="l02379"></a>02379 
<a name="l02380"></a>02380         <span class="comment">/* brw mode can only be used at client */</span>
<a name="l02381"></a>02381         LASSERT(ed-&gt;ed_next != NULL);
<a name="l02382"></a>02382         rc = cl_echo_object_brw(eco, rw, offset, pages, npages, async);
<a name="l02383"></a>02383 
<a name="l02384"></a>02384  out:
<a name="l02385"></a>02385         <span class="keywordflow">if</span> (rc != 0 || rw != OBD_BRW_READ)
<a name="l02386"></a>02386                 verify = 0;
<a name="l02387"></a>02387 
<a name="l02388"></a>02388         <span class="keywordflow">for</span> (i = 0, pgp = pga; i &lt; npages; i++, pgp++) {
<a name="l02389"></a>02389                 <span class="keywordflow">if</span> (pgp-&gt;pg == NULL)
<a name="l02390"></a>02390                         <span class="keywordflow">continue</span>;
<a name="l02391"></a>02391 
<a name="l02392"></a>02392                 <span class="keywordflow">if</span> (verify) {
<a name="l02393"></a>02393                         <span class="keywordtype">int</span> vrc;
<a name="l02394"></a>02394                         vrc = echo_client_page_debug_check(pgp-&gt;pg,
<a name="l02395"></a>02395                                                            ostid_id(&amp;oa-&gt;o_oi),
<a name="l02396"></a>02396                                                            pgp-&gt;off, pgp-&gt;count);
<a name="l02397"></a>02397                         <span class="keywordflow">if</span> (vrc != 0 &amp;&amp; rc == 0)
<a name="l02398"></a>02398                                 rc = vrc;
<a name="l02399"></a>02399                 }
<a name="l02400"></a>02400                 __free_page(pgp-&gt;pg);
<a name="l02401"></a>02401         }
<a name="l02402"></a>02402         OBD_FREE(pga, npages * <span class="keyword">sizeof</span>(*pga));
<a name="l02403"></a>02403         OBD_FREE(pages, npages * <span class="keyword">sizeof</span>(*pages));
<a name="l02404"></a>02404         RETURN(rc);
<a name="l02405"></a>02405 }
<a name="l02406"></a>02406 
<a name="l02407"></a>02407 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_client_prep_commit(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02408"></a>02408                                    <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp, <span class="keywordtype">int</span> rw,
<a name="l02409"></a>02409                                    <span class="keyword">struct</span> <a class="code" href="structobdo.html">obdo</a> *oa, <span class="keyword">struct</span> echo_object *eco,
<a name="l02410"></a>02410                                    u64 offset, u64 count,
<a name="l02411"></a>02411                                    u64 batch, <span class="keywordtype">int</span> async)
<a name="l02412"></a>02412 {
<a name="l02413"></a>02413         <span class="keyword">struct </span><a class="code" href="structobd__ioobj.html">obd_ioobj</a>         ioo;
<a name="l02414"></a>02414         <span class="keyword">struct </span><a class="code" href="structniobuf__local.html">niobuf_local</a>     *lnb;
<a name="l02415"></a>02415         <span class="keyword">struct </span><a class="code" href="structniobuf__remote.html">niobuf_remote</a>     rnb;
<a name="l02416"></a>02416         u64                      off;
<a name="l02417"></a>02417         u64                      npages, tot_pages, apc;
<a name="l02418"></a>02418         <span class="keywordtype">int</span> i, ret = 0, brw_flags = 0;
<a name="l02419"></a>02419 
<a name="l02420"></a>02420         ENTRY;
<a name="l02421"></a>02421 
<a name="l02422"></a>02422         <span class="keywordflow">if</span> (count &lt;= 0 || (count &amp; ~PAGE_CACHE_MASK) != 0)
<a name="l02423"></a>02423                 RETURN(-EINVAL);
<a name="l02424"></a>02424 
<a name="l02425"></a>02425         apc = npages = batch &gt;&gt; PAGE_CACHE_SHIFT;
<a name="l02426"></a>02426         tot_pages = count &gt;&gt; PAGE_CACHE_SHIFT;
<a name="l02427"></a>02427 
<a name="l02428"></a>02428         OBD_ALLOC(lnb, apc * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structniobuf__local.html">niobuf_local</a>));
<a name="l02429"></a>02429         <span class="keywordflow">if</span> (lnb == NULL)
<a name="l02430"></a>02430                 RETURN(-ENOMEM);
<a name="l02431"></a>02431 
<a name="l02432"></a>02432         <span class="keywordflow">if</span> (rw == OBD_BRW_WRITE &amp;&amp; async)
<a name="l02433"></a>02433                 brw_flags |= OBD_BRW_ASYNC;
<a name="l02434"></a>02434 
<a name="l02435"></a>02435         obdo_to_ioobj(oa, &amp;ioo);
<a name="l02436"></a>02436 
<a name="l02437"></a>02437         off = offset;
<a name="l02438"></a>02438 
<a name="l02439"></a>02439         <span class="keywordflow">for</span> (; tot_pages &gt; 0; tot_pages -= npages) {
<a name="l02440"></a>02440                 <span class="keywordtype">int</span> lpages;
<a name="l02441"></a>02441 
<a name="l02442"></a>02442                 <span class="keywordflow">if</span> (tot_pages &lt; npages)
<a name="l02443"></a>02443                         npages = tot_pages;
<a name="l02444"></a>02444 
<a name="l02445"></a>02445                 rnb.rnb_offset = off;
<a name="l02446"></a>02446                 rnb.rnb_len = npages * PAGE_CACHE_SIZE;
<a name="l02447"></a>02447                 rnb.rnb_flags = brw_flags;
<a name="l02448"></a>02448                 ioo.ioo_bufcnt = 1;
<a name="l02449"></a>02449                 off += npages * PAGE_CACHE_SIZE;
<a name="l02450"></a>02450 
<a name="l02451"></a>02451                 lpages = npages;
<a name="l02452"></a>02452                 ret = obd_preprw(env, rw, exp, oa, 1, &amp;ioo, &amp;rnb, &amp;lpages, lnb);
<a name="l02453"></a>02453                 <span class="keywordflow">if</span> (ret != 0)
<a name="l02454"></a>02454                         GOTO(out, ret);
<a name="l02455"></a>02455 
<a name="l02456"></a>02456                 <span class="keywordflow">for</span> (i = 0; i &lt; lpages; i++) {
<a name="l02457"></a>02457                         <span class="keyword">struct </span>page *page = lnb[i].lnb_page;
<a name="l02458"></a>02458 
<a name="l02459"></a>02459                         <span class="comment">/* read past eof? */</span>
<a name="l02460"></a>02460                         <span class="keywordflow">if</span> (page == NULL &amp;&amp; lnb[i].lnb_rc == 0)
<a name="l02461"></a>02461                                 <span class="keywordflow">continue</span>;
<a name="l02462"></a>02462 
<a name="l02463"></a>02463                         <span class="keywordflow">if</span> (async)
<a name="l02464"></a>02464                                 lnb[i].lnb_flags |= OBD_BRW_ASYNC;
<a name="l02465"></a>02465 
<a name="l02466"></a>02466                         <span class="keywordflow">if</span> (ostid_id(&amp;oa-&gt;o_oi) == ECHO_PERSISTENT_OBJID ||
<a name="l02467"></a>02467                             (oa-&gt;o_valid &amp; OBD_MD_FLFLAGS) == 0 ||
<a name="l02468"></a>02468                             (oa-&gt;o_flags &amp; OBD_FL_DEBUG_CHECK) == 0)
<a name="l02469"></a>02469                                 <span class="keywordflow">continue</span>;
<a name="l02470"></a>02470 
<a name="l02471"></a>02471                         <span class="keywordflow">if</span> (rw == OBD_BRW_WRITE)
<a name="l02472"></a>02472                                 echo_client_page_debug_setup(page, rw,
<a name="l02473"></a>02473                                                         ostid_id(&amp;oa-&gt;o_oi),
<a name="l02474"></a>02474                                                         lnb[i].lnb_file_offset,
<a name="l02475"></a>02475                                                         lnb[i].lnb_len);
<a name="l02476"></a>02476                         <span class="keywordflow">else</span>
<a name="l02477"></a>02477                                 echo_client_page_debug_check(page,
<a name="l02478"></a>02478                                                         ostid_id(&amp;oa-&gt;o_oi),
<a name="l02479"></a>02479                                                         lnb[i].lnb_file_offset,
<a name="l02480"></a>02480                                                         lnb[i].lnb_len);
<a name="l02481"></a>02481                 }
<a name="l02482"></a>02482 
<a name="l02483"></a>02483                 ret = obd_commitrw(env, rw, exp, oa, 1, &amp;ioo, &amp;rnb, npages, lnb,
<a name="l02484"></a>02484                                    ret);
<a name="l02485"></a>02485                 <span class="keywordflow">if</span> (ret != 0)
<a name="l02486"></a>02486                         <span class="keywordflow">break</span>;
<a name="l02487"></a>02487 
<a name="l02488"></a>02488                 <span class="comment">/* Reuse env context. */</span>
<a name="l02489"></a>02489                 <a class="code" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit</a>((<span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *)&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l02490"></a>02490                 <a class="code" href="group__lu.html#gaf86fb0a5bf6a1dadec88844694e2ad31" title="Called before entering context.">lu_context_enter</a>((<span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *)&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l02491"></a>02491         }
<a name="l02492"></a>02492 
<a name="l02493"></a>02493 out:
<a name="l02494"></a>02494         OBD_FREE(lnb, apc * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structniobuf__local.html">niobuf_local</a>));
<a name="l02495"></a>02495 
<a name="l02496"></a>02496         RETURN(ret);
<a name="l02497"></a>02497 }
<a name="l02498"></a>02498 
<a name="l02499"></a>02499 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_client_brw_ioctl(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">int</span> rw,
<a name="l02500"></a>02500                                  <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,
<a name="l02501"></a>02501                                  <span class="keyword">struct</span> <a class="code" href="structobd__ioctl__data.html">obd_ioctl_data</a> *data)
<a name="l02502"></a>02502 {
<a name="l02503"></a>02503         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd = class_exp2obd(exp);
<a name="l02504"></a>02504         <span class="keyword">struct </span>echo_device *ed = obd2echo_dev(obd);
<a name="l02505"></a>02505         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a> *ec = ed-&gt;ed_ec;
<a name="l02506"></a>02506         <span class="keyword">struct </span><a class="code" href="structobdo.html">obdo</a> *oa = &amp;data-&gt;ioc_obdo1;
<a name="l02507"></a>02507         <span class="keyword">struct </span>echo_object *eco;
<a name="l02508"></a>02508         <span class="keywordtype">int</span> rc;
<a name="l02509"></a>02509         <span class="keywordtype">int</span> async = 0;
<a name="l02510"></a>02510         <span class="keywordtype">long</span> test_mode;
<a name="l02511"></a>02511         ENTRY;
<a name="l02512"></a>02512 
<a name="l02513"></a>02513         LASSERT(oa-&gt;o_valid &amp; OBD_MD_FLGROUP);
<a name="l02514"></a>02514 
<a name="l02515"></a>02515         rc = echo_get_object(&amp;eco, ed, oa);
<a name="l02516"></a>02516         <span class="keywordflow">if</span> (rc)
<a name="l02517"></a>02517                 RETURN(rc);
<a name="l02518"></a>02518 
<a name="l02519"></a>02519         oa-&gt;o_valid &amp;= ~OBD_MD_FLHANDLE;
<a name="l02520"></a>02520 
<a name="l02521"></a>02521         <span class="comment">/* OFD/obdfilter works only via prep/commit */</span>
<a name="l02522"></a>02522         test_mode = (long)data-&gt;ioc_pbuf1;
<a name="l02523"></a>02523         if (ed-&gt;ed_next == NULL &amp;&amp; test_mode != 3) {
<a name="l02524"></a>02524                 test_mode = 3;
<a name="l02525"></a>02525                 data-&gt;ioc_plen1 = data-&gt;ioc_count;
<a name="l02526"></a>02526         }
<a name="l02527"></a>02527 
<a name="l02528"></a>02528         <span class="keywordflow">if</span> (test_mode == 3)
<a name="l02529"></a>02529                 async = 1;
<a name="l02530"></a>02530 
<a name="l02531"></a>02531         <span class="comment">/* Truncate batch size to maximum */</span>
<a name="l02532"></a>02532         <span class="keywordflow">if</span> (data-&gt;ioc_plen1 &gt; PTLRPC_MAX_BRW_SIZE)
<a name="l02533"></a>02533                 data-&gt;ioc_plen1 = PTLRPC_MAX_BRW_SIZE;
<a name="l02534"></a>02534 
<a name="l02535"></a>02535         <span class="keywordflow">switch</span> (test_mode) {
<a name="l02536"></a>02536         <span class="keywordflow">case</span> 1:
<a name="l02537"></a>02537                 <span class="comment">/* fall through */</span>
<a name="l02538"></a>02538         <span class="keywordflow">case</span> 2:
<a name="l02539"></a>02539                 rc = echo_client_kbrw(ed, rw, oa, eco, data-&gt;ioc_offset,
<a name="l02540"></a>02540                                       data-&gt;ioc_count, async);
<a name="l02541"></a>02541                 <span class="keywordflow">break</span>;
<a name="l02542"></a>02542         <span class="keywordflow">case</span> 3:
<a name="l02543"></a>02543                 rc = echo_client_prep_commit(env, ec-&gt;ec_exp, rw, oa, eco,
<a name="l02544"></a>02544                                              data-&gt;ioc_offset, data-&gt;ioc_count,
<a name="l02545"></a>02545                                              data-&gt;ioc_plen1, async);
<a name="l02546"></a>02546                 <span class="keywordflow">break</span>;
<a name="l02547"></a>02547         <span class="keywordflow">default</span>:
<a name="l02548"></a>02548                 rc = -EINVAL;
<a name="l02549"></a>02549         }
<a name="l02550"></a>02550 
<a name="l02551"></a>02551         echo_put_object(eco);
<a name="l02552"></a>02552 
<a name="l02553"></a>02553         RETURN(rc);
<a name="l02554"></a>02554 }
<a name="l02555"></a>02555 
<a name="l02556"></a>02556 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02557"></a>02557 echo_client_iocontrol(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd, <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp, <span class="keywordtype">int</span> len,
<a name="l02558"></a>02558                       <span class="keywordtype">void</span> *karg, <span class="keywordtype">void</span> __user *uarg)
<a name="l02559"></a>02559 {
<a name="l02560"></a>02560 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02561"></a>02561 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structtgt__session__info.html">tgt_session_info</a> *tsi;
<a name="l02562"></a>02562 <span class="preprocessor">#endif</span>
<a name="l02563"></a>02563 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a>      *obd = exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>;
<a name="l02564"></a>02564         <span class="keyword">struct </span>echo_device     *ed = obd2echo_dev(obd);
<a name="l02565"></a>02565         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a> *ec = ed-&gt;ed_ec;
<a name="l02566"></a>02566         <span class="keyword">struct </span>echo_object     *eco;
<a name="l02567"></a>02567         <span class="keyword">struct </span><a class="code" href="structobd__ioctl__data.html">obd_ioctl_data</a>  *data = karg;
<a name="l02568"></a>02568         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>          *env;
<a name="l02569"></a>02569         <span class="keyword">struct </span><a class="code" href="structobdo.html">obdo</a>            *oa;
<a name="l02570"></a>02570         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           fid;
<a name="l02571"></a>02571         <span class="keywordtype">int</span>                     rw = OBD_BRW_READ;
<a name="l02572"></a>02572         <span class="keywordtype">int</span>                     rc = 0;
<a name="l02573"></a>02573 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02574"></a>02574 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structlu__context.html" title="lu_context.">lu_context</a>        echo_session;
<a name="l02575"></a>02575 <span class="preprocessor">#endif</span>
<a name="l02576"></a>02576 <span class="preprocessor"></span>        ENTRY;
<a name="l02577"></a>02577 
<a name="l02578"></a>02578         oa = &amp;data-&gt;ioc_obdo1;
<a name="l02579"></a>02579         <span class="keywordflow">if</span> (!(oa-&gt;o_valid &amp; OBD_MD_FLGROUP)) {
<a name="l02580"></a>02580                 oa-&gt;o_valid |= OBD_MD_FLGROUP;
<a name="l02581"></a>02581                 ostid_set_seq_echo(&amp;oa-&gt;o_oi);
<a name="l02582"></a>02582         }
<a name="l02583"></a>02583 
<a name="l02584"></a>02584         <span class="comment">/* This FID is unpacked just for validation at this point */</span>
<a name="l02585"></a>02585         rc = ostid_to_fid(&amp;fid, &amp;oa-&gt;o_oi, 0);
<a name="l02586"></a>02586         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02587"></a>02587                 RETURN(rc);
<a name="l02588"></a>02588 
<a name="l02589"></a>02589         OBD_ALLOC_PTR(env);
<a name="l02590"></a>02590         <span class="keywordflow">if</span> (env == NULL)
<a name="l02591"></a>02591                 RETURN(-ENOMEM);
<a name="l02592"></a>02592 
<a name="l02593"></a>02593         rc = lu_env_init(env, <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f" title="Thread on dt server.">LCT_DT_THREAD</a>);
<a name="l02594"></a>02594         <span class="keywordflow">if</span> (rc)
<a name="l02595"></a>02595                 GOTO(out_alloc, rc = -ENOMEM);
<a name="l02596"></a>02596 
<a name="l02597"></a>02597 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02598"></a>02598 <span class="preprocessor"></span>        env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a> = &amp;echo_session;
<a name="l02599"></a>02599         rc = <a class="code" href="group__lu.html#ga952ae50ec5c4d109d2afecbb90c59a5c" title="Initialize context data-structure.">lu_context_init</a>(env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>, <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aabaed253be3089b461b48756c519b654a" title="session for server thread">LCT_SERVER_SESSION</a> | <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084" title="Don&amp;#39;t add references for modules creating key values in that context.">LCT_NOREF</a>);
<a name="l02600"></a>02600         <span class="keywordflow">if</span> (unlikely(rc &lt; 0))
<a name="l02601"></a>02601                 GOTO(out_env, rc);
<a name="l02602"></a>02602         <a class="code" href="group__lu.html#gaf86fb0a5bf6a1dadec88844694e2ad31" title="Called before entering context.">lu_context_enter</a>(env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>);
<a name="l02603"></a>02603 
<a name="l02604"></a>02604         tsi = tgt_ses_info(env);
<a name="l02605"></a>02605         tsi-&gt;tsi_exp = ec-&gt;ec_exp;
<a name="l02606"></a>02606         tsi-&gt;tsi_jobid = NULL;
<a name="l02607"></a>02607 <span class="preprocessor">#endif</span>
<a name="l02608"></a>02608 <span class="preprocessor"></span>        <span class="keywordflow">switch</span> (cmd) {
<a name="l02609"></a>02609         <span class="keywordflow">case</span> OBD_IOC_CREATE:                    <span class="comment">/* may create echo object */</span>
<a name="l02610"></a>02610                 <span class="keywordflow">if</span> (!cfs_capable(CFS_CAP_SYS_ADMIN))
<a name="l02611"></a>02611                         GOTO (out, rc = -EPERM);
<a name="l02612"></a>02612 
<a name="l02613"></a>02613                 rc = echo_create_object(env, ed, oa);
<a name="l02614"></a>02614                 GOTO(out, rc);
<a name="l02615"></a>02615 
<a name="l02616"></a>02616 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02617"></a>02617 <span class="preprocessor"></span>        <span class="keywordflow">case</span> OBD_IOC_ECHO_MD: {
<a name="l02618"></a>02618                 <span class="keywordtype">int</span> count;
<a name="l02619"></a>02619                 <span class="keywordtype">int</span> cmd;
<a name="l02620"></a>02620                 <span class="keywordtype">char</span> *dir = NULL;
<a name="l02621"></a>02621                 <span class="keywordtype">int</span> dirlen;
<a name="l02622"></a>02622                 __u64 id;
<a name="l02623"></a>02623 
<a name="l02624"></a>02624                 <span class="keywordflow">if</span> (!cfs_capable(CFS_CAP_SYS_ADMIN))
<a name="l02625"></a>02625                         GOTO(out, rc = -EPERM);
<a name="l02626"></a>02626 
<a name="l02627"></a>02627                 count = data-&gt;ioc_count;
<a name="l02628"></a>02628                 cmd = data-&gt;ioc_command;
<a name="l02629"></a>02629 
<a name="l02630"></a>02630                 <span class="keywordtype">id</span> = data-&gt;ioc_obdo2.o_oi.oi.oi_id;
<a name="l02631"></a>02631                 dirlen = data-&gt;ioc_plen1;
<a name="l02632"></a>02632                 OBD_ALLOC(dir, dirlen + 1);
<a name="l02633"></a>02633                 <span class="keywordflow">if</span> (dir == NULL)
<a name="l02634"></a>02634                         GOTO(out, rc = -ENOMEM);
<a name="l02635"></a>02635 
<a name="l02636"></a>02636                 <span class="keywordflow">if</span> (copy_from_user(dir, data-&gt;ioc_pbuf1, dirlen)) {
<a name="l02637"></a>02637                         OBD_FREE(dir, data-&gt;ioc_plen1 + 1);
<a name="l02638"></a>02638                         GOTO(out, rc = -EFAULT);
<a name="l02639"></a>02639                 }
<a name="l02640"></a>02640 
<a name="l02641"></a>02641                 rc = echo_md_handler(ed, cmd, dir, dirlen, <span class="keywordtype">id</span>, count, data);
<a name="l02642"></a>02642                 OBD_FREE(dir, dirlen + 1);
<a name="l02643"></a>02643                 GOTO(out, rc);
<a name="l02644"></a>02644         }
<a name="l02645"></a>02645         <span class="keywordflow">case</span> OBD_IOC_ECHO_ALLOC_SEQ: {
<a name="l02646"></a>02646                 <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>   *cl_env;
<a name="l02647"></a>02647                 __u16            refcheck;
<a name="l02648"></a>02648                 __u64            seq;
<a name="l02649"></a>02649                 <span class="keywordtype">int</span>              max_count;
<a name="l02650"></a>02650 
<a name="l02651"></a>02651                 <span class="keywordflow">if</span> (!cfs_capable(CFS_CAP_SYS_ADMIN))
<a name="l02652"></a>02652                         GOTO(out, rc = -EPERM);
<a name="l02653"></a>02653 
<a name="l02654"></a>02654                 cl_env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l02655"></a>02655                 <span class="keywordflow">if</span> (IS_ERR(cl_env))
<a name="l02656"></a>02656                         GOTO(out, rc = PTR_ERR(cl_env));
<a name="l02657"></a>02657 
<a name="l02658"></a>02658                 rc = <a class="code" href="group__lu.html#gae86c05e9998dce0a3860d0456394c559" title="Currently, this API will only be used by echo client.">lu_env_refill_by_tags</a>(cl_env, ECHO_MD_CTX_TAG,
<a name="l02659"></a>02659                                             ECHO_MD_SES_TAG);
<a name="l02660"></a>02660                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l02661"></a>02661                         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(cl_env, &amp;refcheck);
<a name="l02662"></a>02662                         GOTO(out, rc);
<a name="l02663"></a>02663                 }
<a name="l02664"></a>02664 
<a name="l02665"></a>02665                 rc = <a class="code" href="group__fid.html#ga0a7ccab3c63c79337efa4a044b929d4e" title="Allocate the whole seq to the caller.">seq_client_get_seq</a>(cl_env, ed-&gt;ed_cl_seq, &amp;seq);
<a name="l02666"></a>02666                 <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(cl_env, &amp;refcheck);
<a name="l02667"></a>02667                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02668"></a>02668                         CERROR(<span class="stringliteral">&quot;%s: Can not alloc seq: rc = %d\n&quot;</span>,
<a name="l02669"></a>02669                                obd-&gt;obd_name, rc);
<a name="l02670"></a>02670                         GOTO(out, rc);
<a name="l02671"></a>02671                 }
<a name="l02672"></a>02672 
<a name="l02673"></a>02673                 <span class="keywordflow">if</span> (copy_to_user(data-&gt;ioc_pbuf1, &amp;seq, data-&gt;ioc_plen1))
<a name="l02674"></a>02674                         <span class="keywordflow">return</span> -EFAULT;
<a name="l02675"></a>02675 
<a name="l02676"></a>02676                 max_count = LUSTRE_METADATA_SEQ_MAX_WIDTH;
<a name="l02677"></a>02677                 <span class="keywordflow">if</span> (copy_to_user(data-&gt;ioc_pbuf2, &amp;max_count,
<a name="l02678"></a>02678                                      data-&gt;ioc_plen2))
<a name="l02679"></a>02679                         <span class="keywordflow">return</span> -EFAULT;
<a name="l02680"></a>02680                 GOTO(out, rc);
<a name="l02681"></a>02681         }
<a name="l02682"></a>02682 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
<a name="l02683"></a>02683         <span class="keywordflow">case</span> OBD_IOC_DESTROY:
<a name="l02684"></a>02684                 <span class="keywordflow">if</span> (!cfs_capable(CFS_CAP_SYS_ADMIN))
<a name="l02685"></a>02685                         GOTO (out, rc = -EPERM);
<a name="l02686"></a>02686 
<a name="l02687"></a>02687                 rc = echo_get_object(&amp;eco, ed, oa);
<a name="l02688"></a>02688                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l02689"></a>02689                         rc = obd_destroy(env, ec-&gt;ec_exp, oa);
<a name="l02690"></a>02690                         <span class="keywordflow">if</span> (rc == 0)
<a name="l02691"></a>02691                                 eco-&gt;eo_deleted = 1;
<a name="l02692"></a>02692                         echo_put_object(eco);
<a name="l02693"></a>02693                 }
<a name="l02694"></a>02694                 GOTO(out, rc);
<a name="l02695"></a>02695 
<a name="l02696"></a>02696         <span class="keywordflow">case</span> OBD_IOC_GETATTR:
<a name="l02697"></a>02697                 rc = echo_get_object(&amp;eco, ed, oa);
<a name="l02698"></a>02698                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l02699"></a>02699                         rc = obd_getattr(env, ec-&gt;ec_exp, oa);
<a name="l02700"></a>02700                         echo_put_object(eco);
<a name="l02701"></a>02701                 }
<a name="l02702"></a>02702                 GOTO(out, rc);
<a name="l02703"></a>02703 
<a name="l02704"></a>02704         <span class="keywordflow">case</span> OBD_IOC_SETATTR:
<a name="l02705"></a>02705                 <span class="keywordflow">if</span> (!cfs_capable(CFS_CAP_SYS_ADMIN))
<a name="l02706"></a>02706                         GOTO (out, rc = -EPERM);
<a name="l02707"></a>02707 
<a name="l02708"></a>02708                 rc = echo_get_object(&amp;eco, ed, oa);
<a name="l02709"></a>02709                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l02710"></a>02710                         rc = obd_setattr(env, ec-&gt;ec_exp, oa);
<a name="l02711"></a>02711                         echo_put_object(eco);
<a name="l02712"></a>02712                 }
<a name="l02713"></a>02713                 GOTO(out, rc);
<a name="l02714"></a>02714 
<a name="l02715"></a>02715         <span class="keywordflow">case</span> OBD_IOC_BRW_WRITE:
<a name="l02716"></a>02716                 <span class="keywordflow">if</span> (!cfs_capable(CFS_CAP_SYS_ADMIN))
<a name="l02717"></a>02717                         GOTO (out, rc = -EPERM);
<a name="l02718"></a>02718 
<a name="l02719"></a>02719                 rw = OBD_BRW_WRITE;
<a name="l02720"></a>02720                 <span class="comment">/* fall through */</span>
<a name="l02721"></a>02721         <span class="keywordflow">case</span> OBD_IOC_BRW_READ:
<a name="l02722"></a>02722                 rc = echo_client_brw_ioctl(env, rw, exp, data);
<a name="l02723"></a>02723                 GOTO(out, rc);
<a name="l02724"></a>02724 
<a name="l02725"></a>02725         <span class="keywordflow">default</span>:
<a name="l02726"></a>02726                 CERROR (<span class="stringliteral">&quot;echo_ioctl(): unrecognised ioctl %#x\n&quot;</span>, cmd);
<a name="l02727"></a>02727                 GOTO (out, rc = -ENOTTY);
<a name="l02728"></a>02728         }
<a name="l02729"></a>02729 
<a name="l02730"></a>02730         EXIT;
<a name="l02731"></a>02731 out:
<a name="l02732"></a>02732 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02733"></a>02733 <span class="preprocessor"></span>        <a class="code" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit</a>(env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>);
<a name="l02734"></a>02734         <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>);
<a name="l02735"></a>02735 out_env:
<a name="l02736"></a>02736 <span class="preprocessor">#endif</span>
<a name="l02737"></a>02737 <span class="preprocessor"></span>        lu_env_fini(env);
<a name="l02738"></a>02738 out_alloc:
<a name="l02739"></a>02739         OBD_FREE_PTR(env);
<a name="l02740"></a>02740 
<a name="l02741"></a>02741         <span class="keywordflow">return</span> rc;
<a name="l02742"></a>02742 }
<a name="l02743"></a>02743 
<a name="l02744"></a>02744 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_client_setup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02745"></a>02745                              <span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev, <span class="keyword">struct</span> <a class="code" href="structlustre__cfg.html">lustre_cfg</a> *lcfg)
<a name="l02746"></a>02746 {
<a name="l02747"></a>02747         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a> *ec = &amp;obddev-&gt;u.echo_client;
<a name="l02748"></a>02748         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *tgt;
<a name="l02749"></a>02749         <span class="keyword">struct </span><a class="code" href="structobd__uuid.html">obd_uuid</a> echo_uuid = { <span class="stringliteral">&quot;ECHO_UUID&quot;</span> };
<a name="l02750"></a>02750         <span class="keyword">struct </span><a class="code" href="structobd__connect__data.html">obd_connect_data</a> *ocd = NULL;
<a name="l02751"></a>02751         <span class="keywordtype">int</span> rc;
<a name="l02752"></a>02752         ENTRY;
<a name="l02753"></a>02753 
<a name="l02754"></a>02754         <span class="keywordflow">if</span> (lcfg-&gt;lcfg_bufcount &lt; 2 || LUSTRE_CFG_BUFLEN(lcfg, 1) &lt; 1) {
<a name="l02755"></a>02755                 CERROR(<span class="stringliteral">&quot;requires a TARGET OBD name\n&quot;</span>);
<a name="l02756"></a>02756                 RETURN(-EINVAL);
<a name="l02757"></a>02757         }
<a name="l02758"></a>02758 
<a name="l02759"></a>02759         tgt = class_name2obd(lustre_cfg_string(lcfg, 1));
<a name="l02760"></a>02760         <span class="keywordflow">if</span> (!tgt || !tgt-&gt;obd_attached || !tgt-&gt;obd_set_up) {
<a name="l02761"></a>02761                 CERROR(<span class="stringliteral">&quot;device not attached or not set up (%s)\n&quot;</span>,
<a name="l02762"></a>02762                        lustre_cfg_string(lcfg, 1));
<a name="l02763"></a>02763                 RETURN(-EINVAL);
<a name="l02764"></a>02764         }
<a name="l02765"></a>02765 
<a name="l02766"></a>02766         spin_lock_init(&amp;ec-&gt;ec_lock);
<a name="l02767"></a>02767         INIT_LIST_HEAD(&amp;ec-&gt;ec_objects);
<a name="l02768"></a>02768         INIT_LIST_HEAD(&amp;ec-&gt;ec_locks);
<a name="l02769"></a>02769         ec-&gt;ec_unique = 0;
<a name="l02770"></a>02770 
<a name="l02771"></a>02771         <span class="keywordflow">if</span> (!strcmp(tgt-&gt;obd_type-&gt;typ_name, LUSTRE_MDT_NAME)) {
<a name="l02772"></a>02772 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02773"></a>02773 <span class="preprocessor"></span>                lu_context_tags_update(ECHO_MD_CTX_TAG);
<a name="l02774"></a>02774                 lu_session_tags_update(ECHO_MD_SES_TAG);
<a name="l02775"></a>02775 <span class="preprocessor">#else</span>
<a name="l02776"></a>02776 <span class="preprocessor"></span>                CERROR(<span class="stringliteral">&quot;Local operations are NOT supported on client side. &quot;</span>
<a name="l02777"></a>02777                        <span class="stringliteral">&quot;Only remote operations are supported. Metadata client &quot;</span>
<a name="l02778"></a>02778                        <span class="stringliteral">&quot;must be run on server side.\n&quot;</span>);
<a name="l02779"></a>02779 <span class="preprocessor">#endif</span>
<a name="l02780"></a>02780 <span class="preprocessor"></span>                RETURN(0);
<a name="l02781"></a>02781         }
<a name="l02782"></a>02782 
<a name="l02783"></a>02783         OBD_ALLOC(ocd, <span class="keyword">sizeof</span>(*ocd));
<a name="l02784"></a>02784         <span class="keywordflow">if</span> (ocd == NULL) {
<a name="l02785"></a>02785                 CERROR(<span class="stringliteral">&quot;Can&apos;t alloc ocd connecting to %s\n&quot;</span>,
<a name="l02786"></a>02786                        lustre_cfg_string(lcfg, 1));
<a name="l02787"></a>02787                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l02788"></a>02788         }
<a name="l02789"></a>02789 
<a name="l02790"></a>02790         ocd-&gt;ocd_connect_flags = OBD_CONNECT_VERSION | OBD_CONNECT_REQPORTAL |
<a name="l02791"></a>02791                                  OBD_CONNECT_BRW_SIZE |
<a name="l02792"></a>02792                                  OBD_CONNECT_GRANT | OBD_CONNECT_FULL20 |
<a name="l02793"></a>02793                                  OBD_CONNECT_64BITHASH | OBD_CONNECT_LVB_TYPE |
<a name="l02794"></a>02794                                  OBD_CONNECT_FID;
<a name="l02795"></a>02795         ocd-&gt;ocd_brw_size = DT_MAX_BRW_SIZE;
<a name="l02796"></a>02796         ocd-&gt;ocd_version = LUSTRE_VERSION_CODE;
<a name="l02797"></a>02797         ocd-&gt;ocd_group = FID_SEQ_ECHO;
<a name="l02798"></a>02798 
<a name="l02799"></a>02799         rc = obd_connect(env, &amp;ec-&gt;ec_exp, tgt, &amp;echo_uuid, ocd, NULL);
<a name="l02800"></a>02800         <span class="keywordflow">if</span> (rc == 0) {
<a name="l02801"></a>02801                 <span class="comment">/* Turn off pinger because it connects to tgt obd directly. */</span>
<a name="l02802"></a>02802                 spin_lock(&amp;tgt-&gt;obd_dev_lock);
<a name="l02803"></a>02803                 list_del_init(&amp;ec-&gt;ec_exp-&gt;<a class="code" href="structobd__export.html#a6bb9ba26dcffde196c0e80178558ced2" title="last_rcvd clt gen hash">exp_obd_chain_timed</a>);
<a name="l02804"></a>02804                 spin_unlock(&amp;tgt-&gt;obd_dev_lock);
<a name="l02805"></a>02805         }
<a name="l02806"></a>02806 
<a name="l02807"></a>02807         OBD_FREE(ocd, <span class="keyword">sizeof</span>(*ocd));
<a name="l02808"></a>02808 
<a name="l02809"></a>02809         <span class="keywordflow">if</span> (rc != 0) {
<a name="l02810"></a>02810                 CERROR(<span class="stringliteral">&quot;fail to connect to device %s\n&quot;</span>,
<a name="l02811"></a>02811                        lustre_cfg_string(lcfg, 1));
<a name="l02812"></a>02812                 <span class="keywordflow">return</span> (rc);
<a name="l02813"></a>02813         }
<a name="l02814"></a>02814 
<a name="l02815"></a>02815         RETURN(rc);
<a name="l02816"></a>02816 }
<a name="l02817"></a>02817 
<a name="l02818"></a>02818 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_client_cleanup(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obddev)
<a name="l02819"></a>02819 {
<a name="l02820"></a>02820         <span class="keyword">struct </span>echo_device *ed = obd2echo_dev(obddev);
<a name="l02821"></a>02821         <span class="keyword">struct </span><a class="code" href="structecho__client__obd.html">echo_client_obd</a> *ec = &amp;obddev-&gt;u.echo_client;
<a name="l02822"></a>02822         <span class="keywordtype">int</span> rc;
<a name="l02823"></a>02823         ENTRY;
<a name="l02824"></a>02824 
<a name="l02825"></a>02825         <span class="comment">/*Do nothing for Metadata echo client*/</span>
<a name="l02826"></a>02826         <span class="keywordflow">if</span> (ed == NULL )
<a name="l02827"></a>02827                 RETURN(0);
<a name="l02828"></a>02828 
<a name="l02829"></a>02829         <span class="keywordflow">if</span> (ed-&gt;ed_next_ismd) {
<a name="l02830"></a>02830 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02831"></a>02831 <span class="preprocessor"></span>                lu_context_tags_clear(ECHO_MD_CTX_TAG);
<a name="l02832"></a>02832                 lu_session_tags_clear(ECHO_MD_SES_TAG);
<a name="l02833"></a>02833 <span class="preprocessor">#else</span>
<a name="l02834"></a>02834 <span class="preprocessor"></span>                CERROR(<span class="stringliteral">&quot;This is client-side only module, does not support &quot;</span>
<a name="l02835"></a>02835                         <span class="stringliteral">&quot;metadata echo client.\n&quot;</span>);
<a name="l02836"></a>02836 <span class="preprocessor">#endif</span>
<a name="l02837"></a>02837 <span class="preprocessor"></span>                RETURN(0);
<a name="l02838"></a>02838         }
<a name="l02839"></a>02839 
<a name="l02840"></a>02840         <span class="keywordflow">if</span> (!list_empty(&amp;obddev-&gt;obd_exports)) {
<a name="l02841"></a>02841                 CERROR(<span class="stringliteral">&quot;still has clients!\n&quot;</span>);
<a name="l02842"></a>02842                 RETURN(-EBUSY);
<a name="l02843"></a>02843         }
<a name="l02844"></a>02844 
<a name="l02845"></a>02845         LASSERT(atomic_read(&amp;ec-&gt;ec_exp-&gt;exp_refcount) &gt; 0);
<a name="l02846"></a>02846         rc = obd_disconnect(ec-&gt;ec_exp);
<a name="l02847"></a>02847         <span class="keywordflow">if</span> (rc != 0)
<a name="l02848"></a>02848                 CERROR(<span class="stringliteral">&quot;fail to disconnect device: %d\n&quot;</span>, rc);
<a name="l02849"></a>02849 
<a name="l02850"></a>02850         RETURN(rc);
<a name="l02851"></a>02851 }
<a name="l02852"></a>02852 
<a name="l02853"></a>02853 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_client_connect(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02854"></a>02854                                <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> **exp,
<a name="l02855"></a>02855                                <span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *src, <span class="keyword">struct</span> <a class="code" href="structobd__uuid.html">obd_uuid</a> *cluuid,
<a name="l02856"></a>02856                                <span class="keyword">struct</span> <a class="code" href="structobd__connect__data.html">obd_connect_data</a> *data, <span class="keywordtype">void</span> *localdata)
<a name="l02857"></a>02857 {
<a name="l02858"></a>02858         <span class="keywordtype">int</span>                rc;
<a name="l02859"></a>02859         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> conn = { 0 };
<a name="l02860"></a>02860 
<a name="l02861"></a>02861         ENTRY;
<a name="l02862"></a>02862         rc = class_connect(&amp;conn, src, cluuid);
<a name="l02863"></a>02863         <span class="keywordflow">if</span> (rc == 0) {
<a name="l02864"></a>02864                 *exp = class_conn2export(&amp;conn);
<a name="l02865"></a>02865         }
<a name="l02866"></a>02866 
<a name="l02867"></a>02867         RETURN (rc);
<a name="l02868"></a>02868 }
<a name="l02869"></a>02869 
<a name="l02870"></a>02870 <span class="keyword">static</span> <span class="keywordtype">int</span> echo_client_disconnect(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp)
<a name="l02871"></a>02871 {
<a name="l02872"></a>02872         <span class="keywordtype">int</span>                     rc;
<a name="l02873"></a>02873         ENTRY;
<a name="l02874"></a>02874 
<a name="l02875"></a>02875         <span class="keywordflow">if</span> (exp == NULL)
<a name="l02876"></a>02876                 GOTO(out, rc = -EINVAL);
<a name="l02877"></a>02877 
<a name="l02878"></a>02878         rc = class_disconnect(exp);
<a name="l02879"></a>02879         GOTO(out, rc);
<a name="l02880"></a>02880  out:
<a name="l02881"></a>02881         <span class="keywordflow">return</span> rc;
<a name="l02882"></a>02882 }
<a name="l02883"></a>02883 
<a name="l02884"></a>02884 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structobd__ops.html">obd_ops</a> echo_client_obd_ops = {
<a name="l02885"></a>02885         .o_owner       = THIS_MODULE,
<a name="l02886"></a>02886         .o_iocontrol   = echo_client_iocontrol,
<a name="l02887"></a>02887         .o_connect     = echo_client_connect,
<a name="l02888"></a>02888         .o_disconnect  = echo_client_disconnect
<a name="l02889"></a>02889 };
<a name="l02890"></a>02890 
<a name="l02891"></a>02891 <span class="keyword">static</span> <span class="keywordtype">int</span> __init obdecho_init(<span class="keywordtype">void</span>)
<a name="l02892"></a>02892 {
<a name="l02893"></a>02893         <span class="keywordtype">int</span> rc;
<a name="l02894"></a>02894 
<a name="l02895"></a>02895         ENTRY;
<a name="l02896"></a>02896         LCONSOLE_INFO(<span class="stringliteral">&quot;Echo OBD driver; http://www.lustre.org/\n&quot;</span>);
<a name="l02897"></a>02897 
<a name="l02898"></a>02898         LASSERT(PAGE_CACHE_SIZE % OBD_ECHO_BLOCK_SIZE == 0);
<a name="l02899"></a>02899 
<a name="l02900"></a>02900 <span class="preprocessor"># ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02901"></a>02901 <span class="preprocessor"></span>        rc = echo_persistent_pages_init();
<a name="l02902"></a>02902         <span class="keywordflow">if</span> (rc != 0)
<a name="l02903"></a>02903                 <span class="keywordflow">goto</span> failed_0;
<a name="l02904"></a>02904 
<a name="l02905"></a>02905         rc = class_register_type(&amp;echo_obd_ops, NULL, <span class="keyword">true</span>, NULL,
<a name="l02906"></a>02906                                  LUSTRE_ECHO_NAME, NULL);
<a name="l02907"></a>02907         <span class="keywordflow">if</span> (rc != 0)
<a name="l02908"></a>02908                 <span class="keywordflow">goto</span> failed_1;
<a name="l02909"></a>02909 <span class="preprocessor"># endif</span>
<a name="l02910"></a>02910 <span class="preprocessor"></span>
<a name="l02911"></a>02911         rc = <a class="code" href="group__lu.html#ga42de365ae8cbdaa97c604434937a4822" title="Helper function to initialize a number of kmem slab caches at once.">lu_kmem_init</a>(echo_caches);
<a name="l02912"></a>02912         <span class="keywordflow">if</span> (rc == 0) {
<a name="l02913"></a>02913                 rc = class_register_type(&amp;echo_client_obd_ops, NULL, <span class="keyword">true</span>, NULL,
<a name="l02914"></a>02914                                          LUSTRE_ECHO_CLIENT_NAME,
<a name="l02915"></a>02915                                          &amp;echo_device_type);
<a name="l02916"></a>02916                 <span class="keywordflow">if</span> (rc)
<a name="l02917"></a>02917                         <a class="code" href="group__lu.html#gac3834e0d4bd35c8a02d1003bf0f4331e" title="Helper function to finalize a number of kmem slab cached at once.">lu_kmem_fini</a>(echo_caches);
<a name="l02918"></a>02918         }
<a name="l02919"></a>02919 
<a name="l02920"></a>02920 <span class="preprocessor"># ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02921"></a>02921 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (rc == 0)
<a name="l02922"></a>02922                 RETURN(0);
<a name="l02923"></a>02923 
<a name="l02924"></a>02924         class_unregister_type(LUSTRE_ECHO_NAME);
<a name="l02925"></a>02925 failed_1:
<a name="l02926"></a>02926         echo_persistent_pages_fini();
<a name="l02927"></a>02927 failed_0:
<a name="l02928"></a>02928 <span class="preprocessor"># endif</span>
<a name="l02929"></a>02929 <span class="preprocessor"></span>        RETURN(rc);
<a name="l02930"></a>02930 }
<a name="l02931"></a>02931 
<a name="l02932"></a>02932 <span class="keyword">static</span> <span class="keywordtype">void</span> __exit obdecho_exit(<span class="keywordtype">void</span>)
<a name="l02933"></a>02933 {
<a name="l02934"></a>02934         class_unregister_type(LUSTRE_ECHO_CLIENT_NAME);
<a name="l02935"></a>02935         <a class="code" href="group__lu.html#gac3834e0d4bd35c8a02d1003bf0f4331e" title="Helper function to finalize a number of kmem slab cached at once.">lu_kmem_fini</a>(echo_caches);
<a name="l02936"></a>02936 
<a name="l02937"></a>02937 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02938"></a>02938 <span class="preprocessor"></span>        class_unregister_type(LUSTRE_ECHO_NAME);
<a name="l02939"></a>02939         echo_persistent_pages_fini();
<a name="l02940"></a>02940 <span class="preprocessor">#endif</span>
<a name="l02941"></a>02941 <span class="preprocessor"></span>}
<a name="l02942"></a>02942 
<a name="l02943"></a>02943 MODULE_AUTHOR(<span class="stringliteral">&quot;OpenSFS, Inc. &lt;http://www.lustre.org/&gt;&quot;</span>);
<a name="l02944"></a>02944 MODULE_DESCRIPTION(<span class="stringliteral">&quot;Lustre Echo Client test driver&quot;</span>);
<a name="l02945"></a>02945 MODULE_VERSION(LUSTRE_VERSION_STRING);
<a name="l02946"></a>02946 MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);
<a name="l02947"></a>02947 
<a name="l02948"></a>02948 module_init(obdecho_init);
<a name="l02949"></a>02949 module_exit(obdecho_exit);
<a name="l02950"></a>02950 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:18 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
