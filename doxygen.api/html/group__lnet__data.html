<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: Data movement operations</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Data movement operations<br/>
<small>
[<a class="el" href="group__lnet.html">LNet</a>]</small>
</h1>
<p>The LNet API provides two data movement operations: <a class="el" href="group__lnet__data.html#gaf8261191429eaa8b9290ec056c6d40d2" title="Initiate an asynchronous PUT operation.">LNetPut()</a> and <a class="el" href="group__lnet__data.html#ga85a33eba7b0992e1924a3ced45ccb017" title="Initiate an asynchronous GET operation.">LNetGet()</a>.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Data movement operations:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__lnet__data.png" border="0" alt="" usemap="#group____lnet____data_map"/>
<map name="group____lnet____data_map" id="group____lnet____data">
<area shape="rect" id="node1" href="group__lnet.html" title="The Lustre Networking subsystem." alt="" coords="5,5,61,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__data.html#ga7a9fb861289ab6d6f5a555de5a16222d">lnet_ack_req_t</a> { <a class="el" href="group__lnet__data.html#gga7a9fb861289ab6d6f5a555de5a16222dab6ed367929aa2ddaaee1e6027eb0bba6">LNET_ACK_REQ</a>, 
<a class="el" href="group__lnet__data.html#gga7a9fb861289ab6d6f5a555de5a16222daf7554f6ed5ff24f4ab2058283eeffc97">LNET_NOACK_REQ</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Specify whether an acknowledgment should be sent by target when the PUT operation completes (i.e., when the data has been written to a MD of the target process). </p>
 <a href="group__lnet__data.html#ga7a9fb861289ab6d6f5a555de5a16222d">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__data.html#gaf8261191429eaa8b9290ec056c6d40d2">LNetPut</a> (<a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> self, <a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a> md_in, <a class="el" href="group__lnet__data.html#ga7a9fb861289ab6d6f5a555de5a16222d">lnet_ack_req_t</a> ack_req_in, <a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a> target_in, unsigned int portal_in, __u64 match_bits_in, unsigned int offset_in, __u64 hdr_data_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiate an asynchronous PUT operation.  <a href="#gaf8261191429eaa8b9290ec056c6d40d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__data.html#ga85a33eba7b0992e1924a3ced45ccb017">LNetGet</a> (<a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a> self, <a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a> md_in, <a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a> target_in, unsigned int portal_in, __u64 match_bits_in, unsigned int offset_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiate an asynchronous GET operation.  <a href="#ga85a33eba7b0992e1924a3ced45ccb017"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The LNet API provides two data movement operations: <a class="el" href="group__lnet__data.html#gaf8261191429eaa8b9290ec056c6d40d2" title="Initiate an asynchronous PUT operation.">LNetPut()</a> and <a class="el" href="group__lnet__data.html#ga85a33eba7b0992e1924a3ced45ccb017" title="Initiate an asynchronous GET operation.">LNetGet()</a>. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga7a9fb861289ab6d6f5a555de5a16222d"></a><!-- doxytag: member="types.h::lnet_ack_req_t" ref="ga7a9fb861289ab6d6f5a555de5a16222d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lnet__data.html#ga7a9fb861289ab6d6f5a555de5a16222d">lnet_ack_req_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify whether an acknowledgment should be sent by target when the PUT operation completes (i.e., when the data has been written to a MD of the target process). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a> for the discussion on <a class="el" href="group__lnet__md.html#ga364d206ea5fb9d05f09871faf1e10bd3" title="See lnet_md_t::options.">LNET_MD_ACK_DISABLE</a> by which acknowledgments can be disabled for a MD. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga7a9fb861289ab6d6f5a555de5a16222dab6ed367929aa2ddaaee1e6027eb0bba6"></a><!-- doxytag: member="LNET_ACK_REQ" ref="gga7a9fb861289ab6d6f5a555de5a16222dab6ed367929aa2ddaaee1e6027eb0bba6" args="" -->LNET_ACK_REQ</em>&nbsp;</td><td>
<p>Request an acknowledgment. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7a9fb861289ab6d6f5a555de5a16222daf7554f6ed5ff24f4ab2058283eeffc97"></a><!-- doxytag: member="LNET_NOACK_REQ" ref="gga7a9fb861289ab6d6f5a555de5a16222daf7554f6ed5ff24f4ab2058283eeffc97" args="" -->LNET_NOACK_REQ</em>&nbsp;</td><td>
<p>Request that no acknowledgment should be generated. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00643">643</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00643"></a>00643              {
<a name="l00645"></a>00645         <a class="code" href="group__lnet__data.html#gga7a9fb861289ab6d6f5a555de5a16222dab6ed367929aa2ddaaee1e6027eb0bba6" title="Request an acknowledgment.">LNET_ACK_REQ</a>,
<a name="l00647"></a>00647         <a class="code" href="group__lnet__data.html#gga7a9fb861289ab6d6f5a555de5a16222daf7554f6ed5ff24f4ab2058283eeffc97" title="Request that no acknowledgment should be generated.">LNET_NOACK_REQ</a>
<a name="l00648"></a>00648 } <a class="code" href="group__lnet__data.html#ga7a9fb861289ab6d6f5a555de5a16222d" title="Specify whether an acknowledgment should be sent by target when the PUT operation...">lnet_ack_req_t</a>;
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga85a33eba7b0992e1924a3ced45ccb017"></a><!-- doxytag: member="api.h::LNetGet" ref="ga85a33eba7b0992e1924a3ced45ccb017" args="(lnet_nid_t self, lnet_handle_md_t md_in, lnet_process_id_t target_in, unsigned int portal_in, __u64 match_bits_in, unsigned int offset_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a>&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a>&nbsp;</td>
          <td class="paramname"> <em>mdh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>match_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate an asynchronous GET operation. </p>
<p>On the initiator node, an LNET_EVENT_SEND is logged when the GET request is sent, and an LNET_EVENT_REPLY is logged when the data returned from the target node in the REPLY has been written to local MD.</p>
<p>On the target node, an LNET_EVENT_GET is logged when the GET request arrives and is accepted into a MD.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self,target,portal,match_bits,offset</em>&nbsp;</td><td>See the discussion in <a class="el" href="group__lnet__data.html#gaf8261191429eaa8b9290ec056c6d40d2" title="Initiate an asynchronous PUT operation.">LNetPut()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mdh</em>&nbsp;</td><td>A handle for the MD that describes the memory into which the requested data will be received. The MD must be "free floating" (See <a class="el" href="group__lnet__md.html#ga07ee1df9cd78eb3f002e76d371a29888" title="Create a &quot;free floating&quot; memory descriptor - a MD that is not associated...">LNetMDBind()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success, and only in this case events will be generated and logged to EQ (if it exists) of the MD. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EIO</em>&nbsp;</td><td>Simulated failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>Memory allocation failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>Invalid MD object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-move_8c_source.html#l02368">2368</a> of file <a class="el" href="lib-move_8c_source.html">lib-move.c</a>.</p>

<p>References <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00533">LNET_EVENT_SEND</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00072">LNET_NID_ANY</a>, and <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00304">lnet_process_id_t::nid</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02371"></a>02371 {
<a name="l02372"></a>02372         <span class="keyword">struct </span><a class="code" href="structlnet__msg.html">lnet_msg</a>         *msg;
<a name="l02373"></a>02373         <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a>       *md;
<a name="l02374"></a>02374         <span class="keywordtype">int</span>                     cpt;
<a name="l02375"></a>02375         <span class="keywordtype">int</span>                     rc;
<a name="l02376"></a>02376 
<a name="l02377"></a>02377         LASSERT (the_lnet.ln_refcount &gt; 0);
<a name="l02378"></a>02378 
<a name="l02379"></a>02379         <span class="keywordflow">if</span> (!list_empty(&amp;the_lnet.ln_test_peers) &amp;&amp;     <span class="comment">/* normally we don&apos;t */</span>
<a name="l02380"></a>02380             fail_peer(target.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>, 1))                   <span class="comment">/* shall we now? */</span>
<a name="l02381"></a>02381         {
<a name="l02382"></a>02382                 CERROR(<span class="stringliteral">&quot;Dropping GET to %s: simulated failure\n&quot;</span>,
<a name="l02383"></a>02383                        libcfs_id2str(target));
<a name="l02384"></a>02384                 <span class="keywordflow">return</span> -EIO;
<a name="l02385"></a>02385         }
<a name="l02386"></a>02386 
<a name="l02387"></a>02387         msg = lnet_msg_alloc();
<a name="l02388"></a>02388         <span class="keywordflow">if</span> (msg == NULL) {
<a name="l02389"></a>02389                 CERROR(<span class="stringliteral">&quot;Dropping GET to %s: ENOMEM on lnet_msg_t\n&quot;</span>,
<a name="l02390"></a>02390                        libcfs_id2str(target));
<a name="l02391"></a>02391                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l02392"></a>02392         }
<a name="l02393"></a>02393 
<a name="l02394"></a>02394         cpt = lnet_cpt_of_cookie(mdh.cookie);
<a name="l02395"></a>02395         lnet_res_lock(cpt);
<a name="l02396"></a>02396 
<a name="l02397"></a>02397         md = lnet_handle2md(&amp;mdh);
<a name="l02398"></a>02398         <span class="keywordflow">if</span> (md == NULL || md-&gt;md_threshold == 0 || md-&gt;md_me != NULL) {
<a name="l02399"></a>02399                 CERROR(<span class="stringliteral">&quot;Dropping GET (&quot;</span>LPU64<span class="stringliteral">&quot;:%d:%s): MD (%d) invalid\n&quot;</span>,
<a name="l02400"></a>02400                        match_bits, portal, libcfs_id2str(target),
<a name="l02401"></a>02401                        md == NULL ? -1 : md-&gt;md_threshold);
<a name="l02402"></a>02402                 <span class="keywordflow">if</span> (md != NULL &amp;&amp; md-&gt;md_me != NULL)
<a name="l02403"></a>02403                         CERROR(<span class="stringliteral">&quot;REPLY MD also attached to portal %d\n&quot;</span>,
<a name="l02404"></a>02404                                md-&gt;md_me-&gt;me_portal);
<a name="l02405"></a>02405 
<a name="l02406"></a>02406                 lnet_res_unlock(cpt);
<a name="l02407"></a>02407 
<a name="l02408"></a>02408                 lnet_msg_free(msg);
<a name="l02409"></a>02409                 <span class="keywordflow">return</span> -ENOENT;
<a name="l02410"></a>02410         }
<a name="l02411"></a>02411 
<a name="l02412"></a>02412         CDEBUG(D_NET, <span class="stringliteral">&quot;LNetGet -&gt; %s\n&quot;</span>, libcfs_id2str(target));
<a name="l02413"></a>02413 
<a name="l02414"></a>02414         lnet_msg_attach_md(msg, md, 0, 0);
<a name="l02415"></a>02415 
<a name="l02416"></a>02416         lnet_prep_send(msg, LNET_MSG_GET, target, 0, 0);
<a name="l02417"></a>02417 
<a name="l02418"></a>02418         msg-&gt;msg_hdr.msg.get.match_bits = cpu_to_le64(match_bits);
<a name="l02419"></a>02419         msg-&gt;msg_hdr.msg.get.ptl_index = cpu_to_le32(portal);
<a name="l02420"></a>02420         msg-&gt;msg_hdr.msg.get.src_offset = cpu_to_le32(offset);
<a name="l02421"></a>02421         msg-&gt;msg_hdr.msg.get.sink_length = cpu_to_le32(md-&gt;md_length);
<a name="l02422"></a>02422 
<a name="l02423"></a>02423         <span class="comment">/* NB handles only looked up by creator (no flips) */</span>
<a name="l02424"></a>02424         msg-&gt;msg_hdr.msg.get.return_wmd.wh_interface_cookie =
<a name="l02425"></a>02425                 the_lnet.ln_interface_cookie;
<a name="l02426"></a>02426         msg-&gt;msg_hdr.msg.get.return_wmd.wh_object_cookie =
<a name="l02427"></a>02427                 md-&gt;md_lh.lh_cookie;
<a name="l02428"></a>02428 
<a name="l02429"></a>02429         lnet_res_unlock(cpt);
<a name="l02430"></a>02430 
<a name="l02431"></a>02431         lnet_build_msg_event(msg, <a class="code" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aaea6bb2f0a78fad06bd24c8d43ab61fa5" title="An outgoing send (PUT or GET) operation has completed.">LNET_EVENT_SEND</a>);
<a name="l02432"></a>02432 
<a name="l02433"></a>02433         rc = lnet_send(<span class="keyword">self</span>, msg, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>);
<a name="l02434"></a>02434         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02435"></a>02435                 CNETERR(<span class="stringliteral">&quot;Error sending GET to %s: %d\n&quot;</span>,
<a name="l02436"></a>02436                         libcfs_id2str(target), rc);
<a name="l02437"></a>02437                 lnet_finalize(NULL, msg, rc);
<a name="l02438"></a>02438         }
<a name="l02439"></a>02439 
<a name="l02440"></a>02440         <span class="comment">/* completion will be signalled by an event */</span>
<a name="l02441"></a>02441         <span class="keywordflow">return</span> 0;
<a name="l02442"></a>02442 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf8261191429eaa8b9290ec056c6d40d2"></a><!-- doxytag: member="api.h::LNetPut" ref="gaf8261191429eaa8b9290ec056c6d40d2" args="(lnet_nid_t self, lnet_handle_md_t md_in, lnet_ack_req_t ack_req_in, lnet_process_id_t target_in, unsigned int portal_in, __u64 match_bits_in, unsigned int offset_in, __u64 hdr_data_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetPut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312">lnet_nid_t</a>&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a>&nbsp;</td>
          <td class="paramname"> <em>mdh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__data.html#ga7a9fb861289ab6d6f5a555de5a16222d">lnet_ack_req_t</a>&nbsp;</td>
          <td class="paramname"> <em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__process__id__t.html">lnet_process_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>match_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>hdr_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate an asynchronous PUT operation. </p>
<p>There are several events associated with a PUT: completion of the send on the initiator node (LNET_EVENT_SEND), and when the send completes successfully, the receipt of an acknowledgment (LNET_EVENT_ACK) indicating that the operation was accepted by the target. The event LNET_EVENT_PUT is used at the target node to indicate the completion of incoming data delivery.</p>
<p>The local events will be logged in the EQ associated with the MD pointed to by <em>mdh</em> handle. Using a MD without an associated EQ results in these events being discarded. In this case, the caller must have another mechanism (e.g., a higher level protocol) for determining when it is safe to modify the memory region associated with the MD.</p>
<p>Note that LNet does not guarantee the order of LNET_EVENT_SEND and LNET_EVENT_ACK, though intuitively ACK should happen after SEND.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td>Indicates the NID of a local interface through which to send the PUT request. Use LNET_NID_ANY to let LNet choose one by itself. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mdh</em>&nbsp;</td><td>A handle for the MD that describes the memory to be sent. The MD must be "free floating" (See <a class="el" href="group__lnet__md.html#ga07ee1df9cd78eb3f002e76d371a29888" title="Create a &quot;free floating&quot; memory descriptor - a MD that is not associated...">LNetMDBind()</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ack</em>&nbsp;</td><td>Controls whether an acknowledgment is requested. Acknowledgments are only sent when they are requested by the initiating process and the target MD enables them. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>A process identifier for the target process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>The index in the <em>target's</em> portal table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>match_bits</em>&nbsp;</td><td>The match bits to use for MD selection at the target process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset into the target MD (only used when the target MD has the LNET_MD_MANAGE_REMOTE option set). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hdr_data</em>&nbsp;</td><td>64 bits of user data that can be included in the message header. This data is written to an event queue entry at the target if an EQ is present on the matching MD.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success, and only in this case events will be generated and logged to EQ (if it exists). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EIO</em>&nbsp;</td><td>Simulated failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>Memory allocation failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>Invalid MD object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structlnet__event__t.html#a142ee04fc4432b020b562a16e3cbc854" title="64 bits of out-of-band user data.">lnet_event_t::hdr_data</a> and <a class="el" href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a" title="Six types of events can be logged in an event queue.">lnet_event_kind_t</a>. </dd></dl>

<p>Definition at line <a class="el" href="lib-move_8c_source.html#l02169">2169</a> of file <a class="el" href="lib-move_8c_source.html">lib-move.c</a>.</p>

<p>References <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00645">LNET_ACK_REQ</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00533">LNET_EVENT_SEND</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00072">LNET_NID_ANY</a>, and <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00304">lnet_process_id_t::nid</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02173"></a>02173 {
<a name="l02174"></a>02174         <span class="keyword">struct </span><a class="code" href="structlnet__msg.html">lnet_msg</a>         *msg;
<a name="l02175"></a>02175         <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a>       *md;
<a name="l02176"></a>02176         <span class="keywordtype">int</span>                     cpt;
<a name="l02177"></a>02177         <span class="keywordtype">int</span>                     rc;
<a name="l02178"></a>02178 
<a name="l02179"></a>02179         LASSERT(the_lnet.ln_refcount &gt; 0);
<a name="l02180"></a>02180 
<a name="l02181"></a>02181         <span class="keywordflow">if</span> (!list_empty(&amp;the_lnet.ln_test_peers) &amp;&amp;     <span class="comment">/* normally we don&apos;t */</span>
<a name="l02182"></a>02182             fail_peer(target.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>, 1)) {                 <span class="comment">/* shall we now? */</span>
<a name="l02183"></a>02183                 CERROR(<span class="stringliteral">&quot;Dropping PUT to %s: simulated failure\n&quot;</span>,
<a name="l02184"></a>02184                        libcfs_id2str(target));
<a name="l02185"></a>02185                 <span class="keywordflow">return</span> -EIO;
<a name="l02186"></a>02186         }
<a name="l02187"></a>02187 
<a name="l02188"></a>02188         msg = lnet_msg_alloc();
<a name="l02189"></a>02189         <span class="keywordflow">if</span> (msg == NULL) {
<a name="l02190"></a>02190                 CERROR(<span class="stringliteral">&quot;Dropping PUT to %s: ENOMEM on lnet_msg_t\n&quot;</span>,
<a name="l02191"></a>02191                        libcfs_id2str(target));
<a name="l02192"></a>02192                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l02193"></a>02193         }
<a name="l02194"></a>02194         msg-&gt;msg_vmflush = !!memory_pressure_get();
<a name="l02195"></a>02195 
<a name="l02196"></a>02196         cpt = lnet_cpt_of_cookie(mdh.cookie);
<a name="l02197"></a>02197         lnet_res_lock(cpt);
<a name="l02198"></a>02198 
<a name="l02199"></a>02199         md = lnet_handle2md(&amp;mdh);
<a name="l02200"></a>02200         <span class="keywordflow">if</span> (md == NULL || md-&gt;md_threshold == 0 || md-&gt;md_me != NULL) {
<a name="l02201"></a>02201                 CERROR(<span class="stringliteral">&quot;Dropping PUT (&quot;</span>LPU64<span class="stringliteral">&quot;:%d:%s): MD (%d) invalid\n&quot;</span>,
<a name="l02202"></a>02202                        match_bits, portal, libcfs_id2str(target),
<a name="l02203"></a>02203                        md == NULL ? -1 : md-&gt;md_threshold);
<a name="l02204"></a>02204                 <span class="keywordflow">if</span> (md != NULL &amp;&amp; md-&gt;md_me != NULL)
<a name="l02205"></a>02205                         CERROR(<span class="stringliteral">&quot;Source MD also attached to portal %d\n&quot;</span>,
<a name="l02206"></a>02206                                md-&gt;md_me-&gt;me_portal);
<a name="l02207"></a>02207                 lnet_res_unlock(cpt);
<a name="l02208"></a>02208 
<a name="l02209"></a>02209                 lnet_msg_free(msg);
<a name="l02210"></a>02210                 <span class="keywordflow">return</span> -ENOENT;
<a name="l02211"></a>02211         }
<a name="l02212"></a>02212 
<a name="l02213"></a>02213         CDEBUG(D_NET, <span class="stringliteral">&quot;LNetPut -&gt; %s\n&quot;</span>, libcfs_id2str(target));
<a name="l02214"></a>02214 
<a name="l02215"></a>02215         lnet_msg_attach_md(msg, md, 0, 0);
<a name="l02216"></a>02216 
<a name="l02217"></a>02217         lnet_prep_send(msg, LNET_MSG_PUT, target, 0, md-&gt;md_length);
<a name="l02218"></a>02218 
<a name="l02219"></a>02219         msg-&gt;msg_hdr.msg.put.match_bits = cpu_to_le64(match_bits);
<a name="l02220"></a>02220         msg-&gt;msg_hdr.msg.put.ptl_index = cpu_to_le32(portal);
<a name="l02221"></a>02221         msg-&gt;msg_hdr.msg.put.offset = cpu_to_le32(offset);
<a name="l02222"></a>02222         msg-&gt;msg_hdr.msg.put.hdr_data = hdr_data;
<a name="l02223"></a>02223 
<a name="l02224"></a>02224         <span class="comment">/* NB handles only looked up by creator (no flips) */</span>
<a name="l02225"></a>02225         <span class="keywordflow">if</span> (ack == <a class="code" href="group__lnet__data.html#gga7a9fb861289ab6d6f5a555de5a16222dab6ed367929aa2ddaaee1e6027eb0bba6" title="Request an acknowledgment.">LNET_ACK_REQ</a>) {
<a name="l02226"></a>02226                 msg-&gt;msg_hdr.msg.put.ack_wmd.wh_interface_cookie =
<a name="l02227"></a>02227                         the_lnet.ln_interface_cookie;
<a name="l02228"></a>02228                 msg-&gt;msg_hdr.msg.put.ack_wmd.wh_object_cookie =
<a name="l02229"></a>02229                         md-&gt;md_lh.lh_cookie;
<a name="l02230"></a>02230         } <span class="keywordflow">else</span> {
<a name="l02231"></a>02231                 msg-&gt;msg_hdr.msg.put.ack_wmd.wh_interface_cookie =
<a name="l02232"></a>02232                         LNET_WIRE_HANDLE_COOKIE_NONE;
<a name="l02233"></a>02233                 msg-&gt;msg_hdr.msg.put.ack_wmd.wh_object_cookie =
<a name="l02234"></a>02234                         LNET_WIRE_HANDLE_COOKIE_NONE;
<a name="l02235"></a>02235         }
<a name="l02236"></a>02236 
<a name="l02237"></a>02237         lnet_res_unlock(cpt);
<a name="l02238"></a>02238 
<a name="l02239"></a>02239         lnet_build_msg_event(msg, <a class="code" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aaea6bb2f0a78fad06bd24c8d43ab61fa5" title="An outgoing send (PUT or GET) operation has completed.">LNET_EVENT_SEND</a>);
<a name="l02240"></a>02240 
<a name="l02241"></a>02241         rc = lnet_send(<span class="keyword">self</span>, msg, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>);
<a name="l02242"></a>02242         <span class="keywordflow">if</span> (rc != 0) {
<a name="l02243"></a>02243                 CNETERR( <span class="stringliteral">&quot;Error sending PUT to %s: %d\n&quot;</span>,
<a name="l02244"></a>02244                        libcfs_id2str(target), rc);
<a name="l02245"></a>02245                 lnet_finalize (NULL, msg, rc);
<a name="l02246"></a>02246         }
<a name="l02247"></a>02247 
<a name="l02248"></a>02248         <span class="comment">/* completion will be signalled by an event */</span>
<a name="l02249"></a>02249         <span class="keywordflow">return</span> 0;
<a name="l02250"></a>02250 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:48 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
