<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: Initialization and cleanup</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Initialization and cleanup<br/>
<small>
[<a class="el" href="group__lnet.html">LNet</a>]</small>
</h1>
<p>The LNet must be properly initialized before any LNet calls can be made.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Initialization and cleanup:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__lnet__init__fini.png" border="0" alt="" usemap="#group____lnet____init____fini_map"/>
<map name="group____lnet____init____fini_map" id="group____lnet____init____fini">
<area shape="rect" id="node1" href="group__lnet.html" title="The Lustre Networking subsystem." alt="" coords="5,5,61,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__init__fini.html#gac11b9424bc9ddaa74eb75eb1f9bbbb3d">LNetNIInit</a> (<a class="el" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd">lnet_pid_t</a> requested_pid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set LNet PID and start LNet interfaces, routing, and forwarding.  <a href="#gac11b9424bc9ddaa74eb75eb1f9bbbb3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__init__fini.html#ga5a90d37fca0c82635bc688957c0008b6">LNetNIFini</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop LNet interfaces, routing, and forwarding.  <a href="#ga5a90d37fca0c82635bc688957c0008b6"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The LNet must be properly initialized before any LNet calls can be made. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga5a90d37fca0c82635bc688957c0008b6"></a><!-- doxytag: member="api.h::LNetNIFini" ref="ga5a90d37fca0c82635bc688957c0008b6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetNIFini </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop LNet interfaces, routing, and forwarding. </p>
<p>Users must call this function once for each successful call to <a class="el" href="group__lnet__init__fini.html#gac11b9424bc9ddaa74eb75eb1f9bbbb3d" title="Set LNet PID and start LNet interfaces, routing, and forwarding.">LNetNIInit()</a>. Once the <a class="el" href="group__lnet__init__fini.html#ga5a90d37fca0c82635bc688957c0008b6" title="Stop LNet interfaces, routing, and forwarding.">LNetNIFini()</a> operation has been started, the results of pending API operations are undefined.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>always 0 for current implementation. </dd></dl>

<p>Definition at line <a class="el" href="api-ni_8c_source.html#l01639">1639</a> of file <a class="el" href="api-ni_8c_source.html">api-ni.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01640"></a>01640 {
<a name="l01641"></a>01641         mutex_lock(&amp;the_lnet.ln_api_mutex);
<a name="l01642"></a>01642 
<a name="l01643"></a>01643         LASSERT (the_lnet.ln_refcount &gt; 0);
<a name="l01644"></a>01644 
<a name="l01645"></a>01645         <span class="keywordflow">if</span> (the_lnet.ln_refcount != 1) {
<a name="l01646"></a>01646                 the_lnet.ln_refcount--;
<a name="l01647"></a>01647         } <span class="keywordflow">else</span> {
<a name="l01648"></a>01648                 LASSERT(!the_lnet.ln_niinit_self);
<a name="l01649"></a>01649 
<a name="l01650"></a>01650                 lnet_fault_fini();
<a name="l01651"></a>01651 
<a name="l01652"></a>01652                 lnet_proc_fini();
<a name="l01653"></a>01653                 lnet_router_checker_stop();
<a name="l01654"></a>01654                 lnet_ping_target_fini();
<a name="l01655"></a>01655 
<a name="l01656"></a>01656                 <span class="comment">/* Teardown fns that use my own API functions BEFORE here */</span>
<a name="l01657"></a>01657                 the_lnet.ln_refcount = 0;
<a name="l01658"></a>01658 
<a name="l01659"></a>01659                 lnet_acceptor_stop();
<a name="l01660"></a>01660                 lnet_destroy_routes();
<a name="l01661"></a>01661                 lnet_shutdown_lndnis();
<a name="l01662"></a>01662                 lnet_unprepare();
<a name="l01663"></a>01663         }
<a name="l01664"></a>01664 
<a name="l01665"></a>01665         mutex_unlock(&amp;the_lnet.ln_api_mutex);
<a name="l01666"></a>01666         <span class="keywordflow">return</span> 0;
<a name="l01667"></a>01667 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac11b9424bc9ddaa74eb75eb1f9bbbb3d"></a><!-- doxytag: member="api.h::LNetNIInit" ref="gac11b9424bc9ddaa74eb75eb1f9bbbb3d" args="(lnet_pid_t requested_pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetNIInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd">lnet_pid_t</a>&nbsp;</td>
          <td class="paramname"> <em>requested_pid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set LNet PID and start LNet interfaces, routing, and forwarding. </p>
<p>Users must call this function at least once before any other functions. For each successful call there must be a corresponding call to <a class="el" href="group__lnet__init__fini.html#ga5a90d37fca0c82635bc688957c0008b6" title="Stop LNet interfaces, routing, and forwarding.">LNetNIFini()</a>. For subsequent calls to <a class="el" href="group__lnet__init__fini.html#gac11b9424bc9ddaa74eb75eb1f9bbbb3d" title="Set LNet PID and start LNet interfaces, routing, and forwarding.">LNetNIInit()</a>, <em>requested_pid</em> is ignored.</p>
<p>The PID used by LNet may be different from the one requested. See <a class="el" href="group__lnet__addr.html#ga8025f01534cbe778aac39b4f2bae2438" title="Retrieve the lnet_process_id_t ID of LNet interface at index.">LNetGetId()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>requested_pid</em>&nbsp;</td><td>PID requested by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;= 0 on success, and &lt; 0 error code on failures. </dd></dl>

<p>Definition at line <a class="el" href="api-ni_8c_source.html#l01516">1516</a> of file <a class="el" href="api-ni_8c_source.html">api-ni.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01517"></a>01517 {
<a name="l01518"></a>01518         <span class="keywordtype">int</span>                     im_a_router = 0;
<a name="l01519"></a>01519         <span class="keywordtype">int</span>                     rc;
<a name="l01520"></a>01520         <span class="keywordtype">int</span>                     ni_count;
<a name="l01521"></a>01521         lnet_ping_info_t        *pinfo;
<a name="l01522"></a>01522         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>        md_handle;
<a name="l01523"></a>01523         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        net_head;
<a name="l01524"></a>01524 
<a name="l01525"></a>01525         INIT_LIST_HEAD(&amp;net_head);
<a name="l01526"></a>01526 
<a name="l01527"></a>01527         mutex_lock(&amp;the_lnet.ln_api_mutex);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529         CDEBUG(D_OTHER, <span class="stringliteral">&quot;refs %d\n&quot;</span>, the_lnet.ln_refcount);
<a name="l01530"></a>01530 
<a name="l01531"></a>01531         <span class="keywordflow">if</span> (the_lnet.ln_refcount &gt; 0) {
<a name="l01532"></a>01532                 rc = the_lnet.ln_refcount++;
<a name="l01533"></a>01533                 mutex_unlock(&amp;the_lnet.ln_api_mutex);
<a name="l01534"></a>01534                 <span class="keywordflow">return</span> rc;
<a name="l01535"></a>01535         }
<a name="l01536"></a>01536 
<a name="l01537"></a>01537         rc = lnet_prepare(requested_pid);
<a name="l01538"></a>01538         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01539"></a>01539                 mutex_unlock(&amp;the_lnet.ln_api_mutex);
<a name="l01540"></a>01540                 <span class="keywordflow">return</span> rc;
<a name="l01541"></a>01541         }
<a name="l01542"></a>01542 
<a name="l01543"></a>01543         <span class="comment">/* Add in the loopback network */</span>
<a name="l01544"></a>01544         <span class="keywordflow">if</span> (lnet_ni_alloc(LNET_MKNET(LOLND, 0), NULL, &amp;net_head) == NULL) {
<a name="l01545"></a>01545                 rc = -ENOMEM;
<a name="l01546"></a>01546                 <span class="keywordflow">goto</span> failed0;
<a name="l01547"></a>01547         }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549         <span class="comment">/* If LNet is being initialized via DLC it is possible</span>
<a name="l01550"></a>01550 <span class="comment">         * that the user requests not to load module parameters (ones which</span>
<a name="l01551"></a>01551 <span class="comment">         * are supported by DLC) on initialization.  Therefore, make sure not</span>
<a name="l01552"></a>01552 <span class="comment">         * to load networks, routes and forwarding from module parameters</span>
<a name="l01553"></a>01553 <span class="comment">         * in this case.  On cleanup in case of failure only clean up</span>
<a name="l01554"></a>01554 <span class="comment">         * routes if it has been loaded */</span>
<a name="l01555"></a>01555         <span class="keywordflow">if</span> (!the_lnet.ln_nis_from_mod_params) {
<a name="l01556"></a>01556                 rc = lnet_parse_networks(&amp;net_head,
<a name="l01557"></a>01557                                          lnet_get_networks());
<a name="l01558"></a>01558                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01559"></a>01559                         <span class="keywordflow">goto</span> failed0;
<a name="l01560"></a>01560         }
<a name="l01561"></a>01561 
<a name="l01562"></a>01562         ni_count = lnet_startup_lndnis(&amp;net_head);
<a name="l01563"></a>01563         <span class="keywordflow">if</span> (ni_count &lt; 0) {
<a name="l01564"></a>01564                 rc = ni_count;
<a name="l01565"></a>01565                 <span class="keywordflow">goto</span> failed0;
<a name="l01566"></a>01566         }
<a name="l01567"></a>01567 
<a name="l01568"></a>01568         <span class="keywordflow">if</span> (!the_lnet.ln_nis_from_mod_params) {
<a name="l01569"></a>01569                 rc = lnet_parse_routes(lnet_get_routes(), &amp;im_a_router);
<a name="l01570"></a>01570                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01571"></a>01571                         <span class="keywordflow">goto</span> failed1;
<a name="l01572"></a>01572 
<a name="l01573"></a>01573                 rc = lnet_check_routes();
<a name="l01574"></a>01574                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01575"></a>01575                         <span class="keywordflow">goto</span> failed2;
<a name="l01576"></a>01576 
<a name="l01577"></a>01577                 rc = lnet_rtrpools_alloc(im_a_router);
<a name="l01578"></a>01578                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01579"></a>01579                         <span class="keywordflow">goto</span> failed2;
<a name="l01580"></a>01580         }
<a name="l01581"></a>01581 
<a name="l01582"></a>01582         rc = lnet_acceptor_start();
<a name="l01583"></a>01583         <span class="keywordflow">if</span> (rc != 0)
<a name="l01584"></a>01584                 <span class="keywordflow">goto</span> failed2;
<a name="l01585"></a>01585         the_lnet.ln_refcount = 1;
<a name="l01586"></a>01586         <span class="comment">/* Now I may use my own API functions... */</span>
<a name="l01587"></a>01587 
<a name="l01588"></a>01588         rc = lnet_ping_info_setup(&amp;pinfo, &amp;md_handle, ni_count, <span class="keyword">true</span>);
<a name="l01589"></a>01589         <span class="keywordflow">if</span> (rc != 0)
<a name="l01590"></a>01590                 <span class="keywordflow">goto</span> failed3;
<a name="l01591"></a>01591 
<a name="l01592"></a>01592         lnet_ping_target_update(pinfo, md_handle);
<a name="l01593"></a>01593 
<a name="l01594"></a>01594         rc = lnet_router_checker_start();
<a name="l01595"></a>01595         <span class="keywordflow">if</span> (rc != 0)
<a name="l01596"></a>01596                 <span class="keywordflow">goto</span> failed4;
<a name="l01597"></a>01597 
<a name="l01598"></a>01598         lnet_fault_init();
<a name="l01599"></a>01599         lnet_proc_init();
<a name="l01600"></a>01600 
<a name="l01601"></a>01601         mutex_unlock(&amp;the_lnet.ln_api_mutex);
<a name="l01602"></a>01602 
<a name="l01603"></a>01603         <span class="keywordflow">return</span> 0;
<a name="l01604"></a>01604 
<a name="l01605"></a>01605 failed4:
<a name="l01606"></a>01606         lnet_ping_target_fini();
<a name="l01607"></a>01607 failed3:
<a name="l01608"></a>01608         the_lnet.ln_refcount = 0;
<a name="l01609"></a>01609         lnet_acceptor_stop();
<a name="l01610"></a>01610 failed2:
<a name="l01611"></a>01611         <span class="keywordflow">if</span> (!the_lnet.ln_nis_from_mod_params)
<a name="l01612"></a>01612                 lnet_destroy_routes();
<a name="l01613"></a>01613 failed1:
<a name="l01614"></a>01614         lnet_shutdown_lndnis();
<a name="l01615"></a>01615 failed0:
<a name="l01616"></a>01616         lnet_unprepare();
<a name="l01617"></a>01617         LASSERT(rc &lt; 0);
<a name="l01618"></a>01618         mutex_unlock(&amp;the_lnet.ln_api_mutex);
<a name="l01619"></a>01619         <span class="keywordflow">while</span> (!list_empty(&amp;net_head)) {
<a name="l01620"></a>01620                 <span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni;
<a name="l01621"></a>01621                 ni = list_entry(net_head.next, <span class="keyword">struct</span> <a class="code" href="structlnet__ni.html">lnet_ni</a>, ni_list);
<a name="l01622"></a>01622                 list_del_init(&amp;ni-&gt;ni_list);
<a name="l01623"></a>01623                 lnet_ni_free(ni);
<a name="l01624"></a>01624         }
<a name="l01625"></a>01625         <span class="keywordflow">return</span> rc;
<a name="l01626"></a>01626 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:47 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
