<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lu_context_key Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lu_context_key Struct Reference<br/>
<small>
[<a class="el" href="group__lu.html">lu</a>]</small>
</h1><!-- doxytag: class="lu_context_key" -->
<p>Key.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lu__object_8h_source.html">lu_object.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for lu_context_key:</div>
<div class="dynsection">
<div class="center"><img src="structlu__context__key__coll__graph.png" border="0" usemap="#lu__context__key_coll__map" alt="Collaboration graph"/></div>
<map name="lu__context__key_coll__map" id="lu__context__key_coll__map">
<area shape="rect" id="node2" href="structlu__ref.html" title="{lu_ref\n||}" alt="" coords="40,5,99,91"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52c40318e941229b9b102d7b6b8746f6"></a><!-- doxytag: member="lu_context_key::lct_tags" ref="a52c40318e941229b9b102d7b6b8746f6" args="" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context__key.html#a52c40318e941229b9b102d7b6b8746f6">lct_tags</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set of tags for which values of this key are to be instantiated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context__key.html#a7f59b1993947e4bb87482fe2db59a0a2">lct_init</a> )(const struct <a class="el" href="structlu__context.html">lu_context</a> *ctx, struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value constructor.  <a href="#a7f59b1993947e4bb87482fe2db59a0a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context__key.html#aaf04b1fb0608ed408ead318f6237fd05">lct_fini</a> )(const struct <a class="el" href="structlu__context.html">lu_context</a> *ctx, struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value destructor.  <a href="#aaf04b1fb0608ed408ead318f6237fd05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context__key.html#ad9470ad16ac47ced77c65d8c70b12e44">lct_exit</a> )(const struct <a class="el" href="structlu__context.html">lu_context</a> *ctx, struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional method called on <a class="el" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit()</a> for all allocated keys.  <a href="#ad9470ad16ac47ced77c65d8c70b12e44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf647842d414d925c7d75134f1c68b73"></a><!-- doxytag: member="lu_context_key::lct_index" ref="abf647842d414d925c7d75134f1c68b73" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context__key.html#abf647842d414d925c7d75134f1c68b73">lct_index</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal implementation detail: index within <a class="el" href="structlu__context.html#a6cc0c22a74a51a7a5a33b8897bd6dce1" title="Pointer to an array with key values.">lu_context::lc_value</a>[] reserved for this key. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f6957a9be54ed17fd9bf071245bd9b3"></a><!-- doxytag: member="lu_context_key::lct_used" ref="a0f6957a9be54ed17fd9bf071245bd9b3" args="" -->
atomic_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context__key.html#a0f6957a9be54ed17fd9bf071245bd9b3">lct_used</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal implementation detail: number of values created for this key. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaa9094d0c7925ce49a5fdc70f4e432f"></a><!-- doxytag: member="lu_context_key::lct_owner" ref="adaa9094d0c7925ce49a5fdc70f4e432f" args="" -->
struct module *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context__key.html#adaa9094d0c7925ce49a5fdc70f4e432f">lct_owner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal implementation detail: module for this key. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__ref.html">lu_ref</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context__key.html#a92f1fcf5a0e9dfd42082ead350795976">lct_reference</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">References to this key.  <a href="#a92f1fcf5a0e9dfd42082ead350795976"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Key. </p>
<p>Represents per-context value slot.</p>
<p>Keys are usually registered when module owning the key is initialized, and de-registered when module is unloaded. Once key is registered, all new contexts with matching tags, will get key value. "Old" contexts, already initialized at the time of key registration, can be forced to get key value by calling <a class="el" href="group__lu.html#ga00d029e31ae6e5f4edc94121d8bc4a45" title="Allocate for context all missing keys that were registered after context creation...">lu_context_refill()</a>.</p>
<p>Every key value is counted in <a class="el" href="structlu__context__key.html#a0f6957a9be54ed17fd9bf071245bd9b3" title="Internal implementation detail: number of values created for this key.">lu_context_key::lct_used</a> and acquires a reference on an owning module. This means, that all key values have to be destroyed before module can be unloaded. This is usually achieved by stopping threads started by the module, that created contexts in their entry functions. Situation is complicated by the threads shared by multiple modules, like ptlrpcd daemon on a client. To work around this problem, contexts, created in such threads, are `remembered' (see LCT_REMEMBER)---i.e., added into a global list. When module is preparing for unloading it does the following:</p>
<ul>
<li>marks its keys as `quiescent' (<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa2ed29d3105c69b17fc8fb72de22cb719" title="Key is being prepared for retiring, don&#39;t create new values for it.">lu_context_tag::LCT_QUIESCENT</a>) preventing new key values from being allocated in the new contexts, and</li>
</ul>
<ul>
<li>scans a list of remembered contexts, destroying values of module keys, thus releasing references to the module.</li>
</ul>
<p>This is done by <a class="el" href="group__lu.html#ga26d0d8d30e9702d38f9d2e372d48002e" title="Destroy key in all remembered contexts.">lu_context_key_quiesce()</a>. If module is re-activated before key has been de-registered, lu_context_key_revive() call clears `quiescent' marker.</p>
<p><a class="el" href="structlu__context.html" title="lu_context.">lu_context</a> code doesn't provide any internal synchronization for these activities---it's assumed that startup (including threads start-up) and shutdown are serialized by some external means.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structlu__context.html" title="lu_context.">lu_context</a> </dd></dl>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01090">1090</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ad9470ad16ac47ced77c65d8c70b12e44"></a><!-- doxytag: member="lu_context_key::lct_exit" ref="ad9470ad16ac47ced77c65d8c70b12e44" args=")(const struct lu_context *ctx, struct lu_context_key *key, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structlu__context__key.html#ad9470ad16ac47ced77c65d8c70b12e44">lu_context_key::lct_exit</a>)(const struct <a class="el" href="structlu__context.html">lu_context</a> *ctx, struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key, void *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optional method called on <a class="el" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit()</a> for all allocated keys. </p>
<p>Can be used by debugging code checking that locks are released, etc. </p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l01786">lu_context_exit()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf04b1fb0608ed408ead318f6237fd05"></a><!-- doxytag: member="lu_context_key::lct_fini" ref="aaf04b1fb0608ed408ead318f6237fd05" args=")(const struct lu_context *ctx, struct lu_context_key *key, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structlu__context__key.html#aaf04b1fb0608ed408ead318f6237fd05">lu_context_key::lct_fini</a>)(const struct <a class="el" href="structlu__context.html">lu_context</a> *ctx, struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key, void *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Value destructor. </p>
<p>Called when context with previously allocated value of this slot is destroyed. <em>data</em> is a value that was returned by a matching call to <a class="el" href="structlu__context__key.html#a7f59b1993947e4bb87482fe2db59a0a2" title="Value constructor.">lu_context_key::lct_init()</a>. </p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l01401">lu_context_key_register()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f59b1993947e4bb87482fe2db59a0a2"></a><!-- doxytag: member="lu_context_key::lct_init" ref="a7f59b1993947e4bb87482fe2db59a0a2" args=")(const struct lu_context *ctx, struct lu_context_key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* <a class="el" href="structlu__context__key.html#a7f59b1993947e4bb87482fe2db59a0a2">lu_context_key::lct_init</a>)(const struct <a class="el" href="structlu__context.html">lu_context</a> *ctx, struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Value constructor. </p>
<p>This is called when new value is created for a context. Returns pointer to new value of error pointer. </p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l01401">lu_context_key_register()</a>.</p>

</div>
</div>
<a class="anchor" id="a92f1fcf5a0e9dfd42082ead350795976"></a><!-- doxytag: member="lu_context_key::lct_reference" ref="a92f1fcf5a0e9dfd42082ead350795976" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__ref.html">lu_ref</a> <a class="el" href="structlu__context__key.html#a92f1fcf5a0e9dfd42082ead350795976">lu_context_key::lct_reference</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References to this key. </p>
<p>For debugging. </p>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01132">1132</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l01455">lu_context_key_degister()</a>, and <a class="el" href="lu__object_8c_source.html#l01401">lu_context_key_register()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="lu__object_8h_source.html">lu_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 21:01:47 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
