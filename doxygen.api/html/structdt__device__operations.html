<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: dt_device_operations Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dt_device_operations Struct Reference<br/>
<small>
[<a class="el" href="group__dt.html">dt</a>]</small>
</h1><!-- doxytag: class="dt_device_operations" -->
<p>Operations on dt device.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dt__object_8h_source.html">dt_object.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for dt_device_operations:</div>
<div class="dynsection">
<div class="center"><img src="structdt__device__operations__coll__graph.png" border="0" usemap="#dt__device__operations_coll__map" alt="Collaboration graph"/></div>
<map name="dt__device__operations_coll__map" id="dt__device__operations_coll__map">
<area shape="rect" id="node4" href="structdt__device.html" title="{dt_device\n|+ dd_lu_dev\l+ dd_ops\l+ dd_txn_callbacks\l+ dd_record_fid_accessed\l|}" alt="" coords="3660,1057,3855,1194"/><area shape="rect" id="node2" href="structthandle.html" title="This is the general purpose transaction handle." alt="" coords="3184,1895,3323,2119"/><area shape="rect" id="node98" href="structlvfs__run__ctxt.html" title="{lvfs_run_ctxt\n|+ pwdmnt\l+ pwd\l+ fs\l+ umask\l+ dt\l+ magic\l|}" alt="" coords="3564,1921,3673,2093"/><area shape="rect" id="node116" href="structlu__target.html" title="{lu_target\n|+ lut_obd\l+ lut_bottom\l+ lut_tdtd\l+ lut_tdtd_commit_thread\l+ lut_slice\l+ lut_reply_fail_id\l+ lut_request_fail_id\l+ lut_sptlrpc_lock\l+ lut_sptlrpc_rset\l+ lut_flags_lock\l+ lut_sec_level\l+ lut_syncjournal\l+ lut_sync_lock_cancel\l+ lut_no_reconstruct\l+ lut_last_rcvd\l+ lut_txn_cb\l+ lut_lsd\l+ lut_last_transno\l+ lut_translock\l+ lut_client_bitmap_lock\l+ lut_client_bitmap\l+ lut_num_clients\l+ lut_client_generation\l+ lut_reply_data\l+ lut_reply_bitmap\l+ lut_sync_count\l|}" alt="" coords="3169,5161,3372,5679"/><area shape="rect" id="node6" href="structlist__head.html" title="{list_head\n|+ next\l+ prev\l|}" alt="" coords="2860,6,2943,109"/><area shape="rect" id="node10" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking." alt="" coords="3432,5317,3557,5523"/><area shape="rect" id="node13" href="structobd__device.html" title="{obd_device\n|+ obd_type\l+ obd_magic\l+ obd_minor\l+ obd_lu_dev\l+ obd_uuid\l+ obd_name\l+ obd_attached\l+ obd_set_up\l+ obd_recovering\l+ obd_abort_recovery\l+ obd_version_recov\l+ obd_replayable\l+ obd_no_transno\l+ obd_no_recov\l+ obd_stopping\l+ obd_starting\l+ obd_force\l+ obd_fail\l+ obd_no_conn\l+ obd_inactive\l+ obd_no_ir\l+ obd_process_conf\l+ obd_uses_nid_stats\l+ obd_recovery_expired\l+ obd_uuid_hash\l+ obd_nid_hash\l+ obd_nid_stats_hash\l+ obd_gen_hash\l+ obd_nid_stats\l+ obd_exports\l+ obd_unlinked_exports\l+ obd_delayed_exports\l+ obd_lwp_list\l+ obd_refcount\l+ obd_num_exports\l+ obd_nid_lock\l+ obd_namespace\l+ obd_ldlm_client\l+ obd_dev_lock\l+ obd_osfs_lock\l+ obd_osfs\l+ obd_osfs_age\l+ obd_last_committed\l+ obd_dev_mutex\l+ obd_lvfs_ctxt\l+ obd_olg\l+ obd_observer\l+ obd_observer_link_sem\l+ obd_upcall\l+ obd_self_export\l+ obd_lwp_export\l+ obd_exports_timed\l+ obd_eviction_timer\l+ obd_max_recoverable_clients\l+ obd_connected_clients\l+ obd_stale_clients\l+ obd_recovery_task_lock\l+ obd_next_recovery_transno\l+ obd_replayed_requests\l+ obd_requests_queued_for_recovery\l+ obd_next_transno_waitq\l+ obd_recovery_timer\l+ obd_recovery_start\l+ obd_recovery_end\l+ obd_recovery_time_hard\l+ obd_recovery_timeout\l+ obd_recovery_ir_factor\l+ obd_replayed_locks\l+ obd_req_replay_clients\l+ obd_lock_replay_clients\l+ obd_recovery_data\l+ obd_req_replay_queue\l+ obd_lock_replay_queue\l+ obd_final_req_queue\l+ cli\l+ echo_client\l+ lov\l+ lmv\l+ u\l+ obd_stats\l+ obd_cntr_base\l+ obd_md_cntr_base\l+ obd_md_stats\l+ obd_proc_entry\l+ obd_proc_exports_entry\l+ obd_svc_procroot\l+ obd_svc_stats\l+ obd_vars\l+ obd_evict_inprogress\l+ obd_evict_inprogress_waitq\l+ obd_evict_list\l+ obd_pool_lock\l+ obd_pool_slv\l+ obd_pool_limit\l+ obd_conn_inprogress\l+ obd_reference\l|}" alt="" coords="1807,2350,2081,4082"/><area shape="rect" id="node15" href="structecho__client__obd.html" title="{echo_client_obd\n|+ ec_exp\l+ ec_lock\l+ ec_objects\l+ ec_locks\l+ ec_unique\l|}" alt="" coords="2032,6683,2163,6837"/><area shape="rect" id="node18" href="structobd__export.html" title="Export structure." alt="" coords="872,4875,1115,5965"/><area shape="rect" id="node24" href="structcfs__workitem.html" title="{cfs_workitem\n|+ wi_list\l+ wi_action\l+ wi_data\l+ wi_running\l+ wi_scheduled\l|}" alt="" coords="2319,220,2444,375"/><area shape="rect" id="node44" href="structobd__type.html" title="{obd_type\n|+ typ_chain\l+ typ_dt_ops\l+ typ_md_ops\l+ typ_procroot\l+ typ_procsym\l+ typ_sym_filter\l+ typ_name\l+ typ_refcnt\l+ typ_lu\l+ obd_type_lock\l|}" alt="" coords="3604,8177,3737,8418"/><area shape="rect" id="node52" href="structlu__device__type.html" title="Type of device." alt="" coords="3608,7720,3733,7909"/><area shape="rect" id="node74" href="structclient__obd.html" title="{client_obd\n|+ cl_sem\l+ cl_target_uuid\l+ cl_import\l+ cl_conn_count\l+ cl_default_mds_easize\l+ cl_max_mds_easize\l+ cl_sp_me\l+ cl_sp_to\l+ cl_flvr_mgc\l+ cl_dirty_pages\l+ cl_dirty_max_pages\l+ cl_dirty_transit\l+ cl_avail_grant\l+ cl_lost_grant\l+ cl_dirty_grant\l+ cl_reserved_grant\l+ cl_cache_waiters\l+ cl_next_shrink_grant\l+ cl_grant_shrink_list\l+ cl_grant_shrink_interval\l+ cl_chunkbits\l+ cl_grant_extent_tax\l+ cl_max_extent_pages\l+ cl_loi_list_lock\l+ cl_loi_ready_list\l+ cl_loi_hp_ready_list\l+ cl_loi_write_list\l+ cl_loi_read_list\l+ cl_r_in_flight\l+ cl_w_in_flight\l+ cl_pending_w_pages\l+ cl_pending_r_pages\l+ cl_max_pages_per_rpc\l+ cl_max_rpcs_in_flight\l+ cl_read_rpc_hist\l+ cl_write_rpc_hist\l+ cl_read_page_hist\l+ cl_write_page_hist\l+ cl_read_offset_hist\l+ cl_write_offset_hist\l+ cl_cache\l+ cl_lru_osc\l+ cl_lru_left\l+ cl_lru_busy\l+ cl_lru_in_list\l+ cl_lru_shrinkers\l+ cl_lru_last_used\l+ cl_lru_reclaim\l+ cl_lru_list\l+ cl_lru_list_lock\l+ cl_unstable_count\l+ cl_shrink_list\l+ cl_destroy_in_flight\l+ cl_destroy_waitq\l+ cl_rpc_lock\l+ cl_mod_rpcs_lock\l+ cl_max_mod_rpcs_in_flight\l+ cl_mod_rpcs_in_flight\l+ cl_close_rpcs_in_flight\l+ cl_mod_rpcs_waitq\l+ cl_mod_tag_bitmap\l+ cl_mod_rpcs_hist\l+ cl_mgc_mutex\l+ cl_mgc_los\l+ cl_mgc_configs_dir\l+ cl_mgc_refcount\l+ cl_mgc_mgsexp\l+ cl_checksum\l+ cl_supp_cksum_types\l+ cl_cksum_type\l+ cl_ar\l+ cl_seq\l+ cl_resends\l+ cl_writeback_work\l+ cl_lru_work\l+ cl_quota_hash\l|}" alt="" coords="531,6067,744,7453"/><area shape="rect" id="node86" href="structldlm__namespace.html" title="LDLM Namespace." alt="" coords="2357,5126,2541,5714"/><area shape="rect" id="node92" href="structlov__obd.html" title="{lov_obd\n|+ desc\l+ lov_tgts\l+ lov_packed\l+ lov_lock\l+ lov_ocd\l+ targets_proc_entry\l+ lov_refcount\l+ lov_death_row\l+ lov_tgt_size\l+ lov_connects\l+ lov_pool_count\l+ lov_pools_hash_body\l+ lov_pool_list\l+ lov_pool_proc_entry\l+ lov_sp_me\l+ lov_cache\l+ lov_notify_lock\l|}" alt="" coords="2397,1825,2571,2188"/><area shape="rect" id="node109" href="structlu__object.html" title="Layer in the layered object." alt="" coords="3953,6683,4057,6837"/><area shape="rect" id="node114" href="structlu__site.html" title="lu_site is a &quot;compartment&quot; within which objects are unique, and LRU discipline..." alt="" coords="3044,6631,3185,6889"/><area shape="rect" id="node118" href="structptlrpc__thread.html" title="Definition of server service thread structure." alt="" coords="3416,1886,3531,2127"/><area shape="rect" id="node121" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data." alt="" coords="345,710,540,1541"/><area shape="rect" id="node125" href="structptlrpc__service.html" title="Definition of PortalRPC service." alt="" coords="189,1747,395,2266"/><area shape="rect" id="node130" href="structptlrpc__nrs.html" title="NRS head." alt="" coords="5,1860,165,2153"/><area shape="rect" id="node134" href="structptlrpc__at__array.html" title="{ptlrpc_at_array\n|+ paa_reqs_array\l+ paa_size\l+ paa_count\l+ paa_deadline\l+ paa_reqs_count\l|}" alt="" coords="297,220,439,375"/><area shape="rect" id="node139" href="structlu__context.html" title="lu_context." alt="" coords="3121,203,3247,392"/><area shape="rect" id="node56" href="structlu__device__type__operations.html" title="Operations on a device type." alt="" coords="3569,6657,3772,6863"/><area shape="rect" id="node102" href="structlmv__obd.html" title="{lmv_obd\n|+ refcount\l+ lmv_fld\l+ lmv_lock\l+ lmv_placement\l+ desc\l+ cluuid\l+ exp\l+ targets_proc_entry\l+ lmv_init_mutex\l+ connected\l+ max_easize\l+ max_def_easize\l+ tgts_size\l+ tgts\l+ conn_data\l|}" alt="" coords="911,6596,1076,6924"/><area shape="rect" id="node152" href="structseq__server__site.html" title="{seq_server_site\n|+ ss_lu\l+ ss_node_id\l+ ss_server_fld\l+ ss_client_fld\l+ ss_server_seq\l+ ss_control_seq\l+ ss_control_exp\l+ ss_client_seq\l|}" alt="" coords="2983,7711,3119,7918"/><area shape="rect" id="node20" href="structcfs__hash.html" title="cfs_hash is a hash&#45;table implementation for general purpose, it can support: ." alt="" coords="2059,892,2221,1359"/><area shape="rect" id="node22" href="unioncfs__hash__lock.html" title="{cfs_hash_lock\n|+ rw\l+ spin\l|}" alt="" coords="196,6,308,109"/><area shape="rect" id="node27" href="structcfs__hash__bucket.html" title="cfs_hash_bucket is a container of:lock, counter ." alt="" coords="1216,211,1349,383"/><area shape="rect" id="node30" href="structcfs__hash__hlist__ops.html" title="{cfs_hash_hlist_ops\n|+ hop_hhead\l+ hop_hhead_size\l+ hop_hnode_add\l+ hop_hnode_del\l|}" alt="" coords="1985,229,2129,366"/><area shape="rect" id="node32" href="structcfs__hash__lock__ops.html" title="{cfs_hash_lock_ops\n|+ hs_lock\l+ hs_unlock\l+ hs_bkt_lock\l+ hs_bkt_unlock\l|}" alt="" coords="2153,229,2295,366"/><area shape="rect" id="node34" href="structcfs__hash__ops.html" title="{cfs_hash_ops\n|+ hs_hash\l+ hs_key\l+ hs_keycpy\l+ hs_keycmp\l+ hs_object\l+ hs_get\l+ hs_put\l+ hs_put_locked\l+ hs_exit\l|}" alt="" coords="1831,185,1961,409"/><area shape="rect" id="node37" href="structadaptive__timeout.html" title="{adaptive_timeout\n|+ at_binstart\l+ at_hist\l+ at_flags\l+ at_current\l+ at_worst_ever\l+ at_worst_time\l+ at_lock\l|}" alt="" coords="629,203,771,392"/><area shape="rect" id="node40" href="structobd__uuid.html" title="{obd_uuid\n|+ uuid\l|}" alt="" coords="645,1964,725,2049"/><area shape="rect" id="node49" href="structobd__ops.html" title="{obd_ops\n|+ o_owner\l+ o_iocontrol\l+ o_get_info\l+ o_set_info_async\l+ o_setup\l+ o_precleanup\l+ o_cleanup\l+ o_process_config\l+ o_postrecov\l+ o_add_conn\l+ o_del_conn\l+ o_connect\l+ o_reconnect\l+ o_disconnect\l+ o_fid_init\l+ o_fid_fini\l+ o_fid_alloc\l+ o_statfs\l+ o_statfs_async\l+ o_create\l+ o_destroy\l+ o_setattr\l+ o_getattr\l+ o_preprw\l+ o_commitrw\l+ o_init_export\l+ o_destroy_export\l+ o_import_event\l+ o_notify\l+ o_health_check\l+ o_get_uuid\l+ o_quotactl\l+ o_ping\l+ o_pool_new\l+ o_pool_del\l+ o_pool_add\l+ o_pool_rem\l+ o_getref\l+ o_putref\l|}" alt="" coords="268,4107,423,4851"/><area shape="rect" id="node47" href="structmd__ops.html" title="{md_ops\n|+ m_close\l+ m_create\l+ m_enqueue\l+ m_getattr\l+ m_intent_lock\l+ m_link\l+ m_rename\l+ m_setattr\l+ m_fsync\l+ m_read_page\l+ m_unlink\l+ m_setxattr\l+ m_getxattr\l+ m_intent_getattr_async\l+ m_revalidate_lock\l+ m_get_root\l+ m_null_inode\l+ m_getattr_name\l+ m_init_ea_size\l+ m_get_lustre_md\l+ m_free_lustre_md\l+ m_merge_attr\l+ m_set_open_replay_data\l+ m_clear_open_replay_data\l+ m_set_lock_data\l+ m_lock_match\l+ m_cancel_unused\l+ m_get_remote_perm\l+ m_get_fid_from_lsm\l+ m_unpackmd\l|}" alt="" coords="4136,7521,4349,8109"/><area shape="rect" id="node59" href="structlprocfs__stats.html" title="{lprocfs_stats\n|+ ls_num\l+ ls_biggest_alloc_num\l+ ls_flags\l+ ls_lock\l+ ls_cnt_header\l+ ls_percpu\l|}" alt="" coords="2605,1039,2781,1211"/><area shape="rect" id="node61" href="structlprocfs__percpu.html" title="{lprocfs_percpu\n|+ lp_cntr\l|}" alt="" coords="2519,255,2636,340"/><area shape="rect" id="node63" href="structlprocfs__counter__header.html" title="{lprocfs_counter_header\n|+ lc_config\l+ lc_name\l+ lc_units\l|}" alt="" coords="2660,237,2839,357"/><area shape="rect" id="node65" href="structobd__notify__upcall.html" title="{obd_notify_upcall\n|+ onu_upcall\l+ onu_owner\l|}" alt="" coords="2057,1955,2193,2058"/><area shape="rect" id="node68" href="structptlrpc__client.html" title="Client definition for PortalRPC." alt="" coords="1143,1947,1297,2067"/><area shape="rect" id="node70" href="structobd__llog__group.html" title="{obd_llog_group\n|+ olg_ctxts\l+ olg_waitq\l+ olg_lock\l+ olg_cat_processing\l|}" alt="" coords="1321,1938,1484,2075"/><area shape="rect" id="node72" href="structlprocfs__vars.html" title="{lprocfs_vars\n|+ name\l+ fops\l+ data\l+ proc_mode\l|}" alt="" coords="1508,1938,1617,2075"/><area shape="rect" id="node80" href="structobd__statfs.html" title="{obd_statfs\n|+ os_type\l+ os_blocks\l+ os_bfree\l+ os_bavail\l+ os_files\l+ os_ffree\l+ os_fsid\l+ os_bsize\l+ os_namelen\l+ os_maxbytes\l+ os_state\l+ os_fprecreated\l+ os_spare2\l+ os_spare3\l+ os_spare4\l+ os_spare5\l+ os_spare6\l+ os_spare7\l+ os_spare8\l+ os_spare9\l|}" alt="" coords="1692,1799,1831,2214"/><area shape="rect" id="node83" href="structlu__ref.html" title="{lu_ref\n||}" alt="" coords="2747,1964,2805,2049"/><area shape="rect" id="node96" href="structtarget__recovery__data.html" title="{target_recovery_data\n|+ trd_recovery_handler\l+ trd_processing_task\l+ trd_starting\l+ trd_finishing\l|}" alt="" coords="1855,1938,2033,2075"/><area shape="rect" id="node107" href="structlu__device__operations.html" title="Operations common for data and meta&#45;data devices." alt="" coords="3829,7746,4024,7883"/><area shape="rect" id="node137" href="structlu__env.html" title="Environment." alt="" coords="3379,1074,3456,1177"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#a5551db7b0deb0d6c07fc738552f445f7">dt_statfs</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structobd__statfs.html">obd_statfs</a> *osfs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return device-wide statistics.  <a href="#a5551db7b0deb0d6c07fc738552f445f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structthandle.html">thandle</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#a06f026899bb291ac5bb915a17dcadb7f">dt_trans_create</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create transaction.  <a href="#a06f026899bb291ac5bb915a17dcadb7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#a9f4532e51dbeefa61d9c0f6a9670ef5b">dt_trans_start</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start transaction.  <a href="#a9f4532e51dbeefa61d9c0f6a9670ef5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#a1a48e37999c62e8d1d2ad6e84572393b">dt_trans_stop</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop transaction.  <a href="#a1a48e37999c62e8d1d2ad6e84572393b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#a977a253aad1d585cf9c316c3f87d801d">dt_trans_cb_add</a> )(struct <a class="el" href="structthandle.html">thandle</a> *th, struct <a class="el" href="structdt__txn__commit__cb.html">dt_txn_commit_cb</a> *dcb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add commit callback to the transaction.  <a href="#a977a253aad1d585cf9c316c3f87d801d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#ad2a831d38be0be73f8a5498112e13b56">dt_root_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structlu__fid.html">lu_fid</a> *f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return FID of root index object.  <a href="#ad2a831d38be0be73f8a5498112e13b56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#a652ff54fee6fbc7f4a5dda78befe5489">dt_conf_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structdt__device__param.html">dt_device_param</a> *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return device configuration data.  <a href="#a652ff54fee6fbc7f4a5dda78befe5489"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#aff03760ef16c08ef22ecfcace4a7afb9">dt_sync</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sync the device.  <a href="#aff03760ef16c08ef22ecfcace4a7afb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#a03deb463a9aebe843829c31bbab1c34d">dt_ro</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make device read-only.  <a href="#a03deb463a9aebe843829c31bbab1c34d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html#ab811b4bbba68f4edcab228e8d9f52d3c">dt_commit_async</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start transaction commit asynchronously.  <a href="#ab811b4bbba68f4edcab228e8d9f52d3c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Operations on dt device. </p>

<p>Definition at line <a class="el" href="dt__object_8h_source.html#l00120">120</a> of file <a class="el" href="dt__object_8h_source.html">dt_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ab811b4bbba68f4edcab228e8d9f52d3c"></a><!-- doxytag: member="dt_device_operations::dt_commit_async" ref="ab811b4bbba68f4edcab228e8d9f52d3c" args=")(const struct lu_env *env, struct dt_device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__device__operations.html#ab811b4bbba68f4edcab228e8d9f52d3c">dt_device_operations::dt_commit_async</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start transaction commit asynchronously. </p>
<p>Provide a hint to the underlying filesystem that it should start committing soon. The control returns immediately. It's up to the layer implementing the method how soon to start committing. Usually this should be throttled to some extent, otherwise the number of aggregated transaction goes too high causing performance drop.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>dt device</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a652ff54fee6fbc7f4a5dda78befe5489"></a><!-- doxytag: member="dt_device_operations::dt_conf_get" ref="a652ff54fee6fbc7f4a5dda78befe5489" args=")(const struct lu_env *env, const struct dt_device *dev, struct dt_device_param *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structdt__device__operations.html#a652ff54fee6fbc7f4a5dda78befe5489">dt_device_operations::dt_conf_get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structdt__device__param.html">dt_device_param</a> *param)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return device configuration data. </p>
<p>Return device (disk fs, actually) specific configuration. The configuration isn't subject to change at runtime. See struct <a class="el" href="structdt__device__param.html">dt_device_param</a> for the details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>dt device </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>param</em>&nbsp;</td><td>configuration parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03deb463a9aebe843829c31bbab1c34d"></a><!-- doxytag: member="dt_device_operations::dt_ro" ref="a03deb463a9aebe843829c31bbab1c34d" args=")(const struct lu_env *env, struct dt_device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__device__operations.html#a03deb463a9aebe843829c31bbab1c34d">dt_device_operations::dt_ro</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make device read-only. </p>
<p>Prevent new modifications to the device. This is a very specific state where all the changes are accepted successfully and the commit callbacks are called, but persistent state never changes. Used only in the tests to simulate power-off scenario.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>dt device</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2a831d38be0be73f8a5498112e13b56"></a><!-- doxytag: member="dt_device_operations::dt_root_get" ref="ad2a831d38be0be73f8a5498112e13b56" args=")(const struct lu_env *env, struct dt_device *dev, struct lu_fid *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__device__operations.html#ad2a831d38be0be73f8a5498112e13b56">dt_device_operations::dt_root_get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structlu__fid.html">lu_fid</a> *f)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return FID of root index object. </p>
<p>Return the FID of the root object in the filesystem. This object is usually provided as a bootstrap point by a disk filesystem. This is up to the implementation which FID to use, though [FID_SEQ_ROOT:1:0] is reserved for this purpose.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>dt device </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>FID of the root object</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5551db7b0deb0d6c07fc738552f445f7"></a><!-- doxytag: member="dt_device_operations::dt_statfs" ref="a5551db7b0deb0d6c07fc738552f445f7" args=")(const struct lu_env *env, struct dt_device *dev, struct obd_statfs *osfs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__device__operations.html#a5551db7b0deb0d6c07fc738552f445f7">dt_device_operations::dt_statfs</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structobd__statfs.html">obd_statfs</a> *osfs)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return device-wide statistics. </p>
<p>Return device-wide stats including block size, total and free blocks, total and free objects, etc. See struct <a class="el" href="structobd__statfs.html">obd_statfs</a> for the details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>dt device </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>osfs</em>&nbsp;</td><td>stats information</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff03760ef16c08ef22ecfcace4a7afb9"></a><!-- doxytag: member="dt_device_operations::dt_sync" ref="aff03760ef16c08ef22ecfcace4a7afb9" args=")(const struct lu_env *env, struct dt_device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__device__operations.html#aff03760ef16c08ef22ecfcace4a7afb9">dt_device_operations::dt_sync</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sync the device. </p>
<p>Sync all the cached state (dirty buffers, pages, etc) to the persistent storage. The method returns control once the sync is complete. This operation may incur significant I/O to disk and should be reserved for cases where a global sync is strictly necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>dt device</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a977a253aad1d585cf9c316c3f87d801d"></a><!-- doxytag: member="dt_device_operations::dt_trans_cb_add" ref="a977a253aad1d585cf9c316c3f87d801d" args=")(struct thandle *th, struct dt_txn_commit_cb *dcb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__device__operations.html#a977a253aad1d585cf9c316c3f87d801d">dt_device_operations::dt_trans_cb_add</a>)(struct <a class="el" href="structthandle.html">thandle</a> *th, struct <a class="el" href="structdt__txn__commit__cb.html">dt_txn_commit_cb</a> *dcb)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add commit callback to the transaction. </p>
<p>Add a commit callback to the given transaction handle. The callback will be called when the associated transaction is stored. I.e. the transaction will survive an event like power off if the callback did run. The number of callbacks isn't limited, but you should note that some disk filesystems do handle the commit callbacks in the thread handling commit/flush of all the transactions, meaning that new transactions are blocked from commit and flush until all the callbacks are done. Also, note multiple callbacks can be running concurrently using multiple CPU cores. The callbacks will be running in a special environment which can not be used to pass data around.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dcb</em>&nbsp;</td><td>commit callback description</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06f026899bb291ac5bb915a17dcadb7f"></a><!-- doxytag: member="dt_device_operations::dt_trans_create" ref="a06f026899bb291ac5bb915a17dcadb7f" args=")(const struct lu_env *env, struct dt_device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structthandle.html">thandle</a>*(* <a class="el" href="structdt__device__operations.html#a06f026899bb291ac5bb915a17dcadb7f">dt_device_operations::dt_trans_create</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev)<code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create transaction. </p>
<p>Create in-memory structure representing the transaction for the caller. The structure returned will be used by the calling thread to specify the transaction the updates belong to. Once created successfully -&gt;<a class="el" href="structdt__device__operations.html#a1a48e37999c62e8d1d2ad6e84572393b" title="Stop transaction.">dt_trans_stop()</a> must be called in any case (with -&gt;<a class="el" href="structdt__device__operations.html#a9f4532e51dbeefa61d9c0f6a9670ef5b" title="Start transaction.">dt_trans_start()</a> and updates or not) so that the transaction handle and other resources can be released by the layers below.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>dt device</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pointer</em>&nbsp;</td><td>to handle if creation succeeds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ERR_PTR(errno)</em>&nbsp;</td><td>if creation fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f4532e51dbeefa61d9c0f6a9670ef5b"></a><!-- doxytag: member="dt_device_operations::dt_trans_start" ref="a9f4532e51dbeefa61d9c0f6a9670ef5b" args=")(const struct lu_env *env, struct dt_device *dev, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__device__operations.html#a9f4532e51dbeefa61d9c0f6a9670ef5b">dt_device_operations::dt_trans_start</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start transaction. </p>
<p>Start the transaction. The transaction described by <em>th</em> can be started only once. Another start is considered as an error. A thread is not supposed to start a transaction while another transaction isn't closed by the thread (though multiple handles can be created). The caller should start the transaction once all possible updates are declared (see the -&gt;do_declare_* methods below) and all the needed resources are reserved.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>dt device </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a48e37999c62e8d1d2ad6e84572393b"></a><!-- doxytag: member="dt_device_operations::dt_trans_stop" ref="a1a48e37999c62e8d1d2ad6e84572393b" args=")(const struct lu_env *env, struct dt_device *dev, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__device__operations.html#a1a48e37999c62e8d1d2ad6e84572393b">dt_device_operations::dt_trans_stop</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop transaction. </p>
<p>Once stopped the transaction described by <em>th</em> is complete (all the needed updates are applied) and further processing such as flushing to disk, sending to another target, etc, is handled by lower layers. The caller can't access this transaction by the handle anymore (except from the commit callbacks, see below).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>dt device </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="dt__object_8h_source.html">dt_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:56:48 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
