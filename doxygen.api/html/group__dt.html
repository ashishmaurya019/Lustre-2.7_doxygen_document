<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: dt</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dt</h1>
<p>Sub-class of <a class="el" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> with methods common for "data" objects in OST stack.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__param.html">dt_device_param</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__txn__commit__cb.html">dt_txn_commit_cb</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device__operations.html">dt_device_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operations on dt device.  <a href="structdt__device__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__features.html">dt_index_features</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__allocation__hint.html">dt_allocation_hint</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a general purpose dt allocation hint.  <a href="structdt__allocation__hint.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__format.html">dt_object_format</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">object format specifier.  <a href="structdt__object__format.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object__operations.html">dt_object_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="structdt__object.html">dt_object</a> provides common operations to create and destroy objects and to manage regular and extended attributes.  <a href="structdt__object__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html">dt_body_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-dt-object operations on "file body" - unstructure raw data.  <a href="structdt__body__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations.html">dt_index_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per-dt-object operations on object as index.  <a href="structdt__index__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__device.html">dt_device</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__object.html">dt_object</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlocal__oid__storage.html">local_oid_storage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthandle.html">thandle</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the general purpose transaction handle.  <a href="structthandle.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__txn__callback.html">dt_txn_callback</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction call-backs.  <a href="structdt__txn__callback.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89459f49f808512a60eea34fdcd5e43f"></a><!-- doxytag: member="dt::TRANS_COMMIT_CB_MAGIC" ref="ga89459f49f808512a60eea34fdcd5e43f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#ga89459f49f808512a60eea34fdcd5e43f">TRANS_COMMIT_CB_MAGIC</a>&nbsp;&nbsp;&nbsp;0xa0a00a0a</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special per-transaction callback for cases when just commit callback is needed and per-device callback are not convenient to use. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga716afbe942a3175836889d7de4f4ded0"></a><!-- doxytag: member="dt::MAX_COMMIT_CB_STR_LEN" ref="ga716afbe942a3175836889d7de4f4ded0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MAX_COMMIT_CB_STR_LEN</b>&nbsp;&nbsp;&nbsp;32</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe394c0aa5524a71fed15e79c362c90c"></a><!-- doxytag: member="dt::DCB_TRANS_STOP" ref="gabe394c0aa5524a71fed15e79c362c90c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DCB_TRANS_STOP</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec8ff01f4e420e9382c70c26413fc647"></a><!-- doxytag: member="dt::DT_OTABLE_IT_FLAGS_SHIFT" ref="gaec8ff01f4e420e9382c70c26413fc647" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DT_OTABLE_IT_FLAGS_SHIFT</b>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6cc78eed330fdd86906b6469acc4342e"></a><!-- doxytag: member="dt::DT_OTABLE_IT_FLAGS_MASK" ref="ga6cc78eed330fdd86906b6469acc4342e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DT_OTABLE_IT_FLAGS_MASK</b>&nbsp;&nbsp;&nbsp;0xffff0000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga60515ba68b99bab0f304687ea2fc45f5"></a><!-- doxytag: member="dt::DT_MAX_PATH" ref="ga60515ba68b99bab0f304687ea2fc45f5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DT_MAX_PATH</b>&nbsp;&nbsp;&nbsp;1024</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba396c991d563511fe88d54364f2dcdd"></a><!-- doxytag: member="dt::dt_cb_t" ref="gaba396c991d563511fe88d54364f2dcdd" args=")(struct lu_env *env, struct thandle *th, struct dt_txn_commit_cb *cb, int err)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_cb_t</b> )(struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structthandle.html">thandle</a> *th, struct <a class="el" href="structdt__txn__commit__cb.html">dt_txn_commit_cb</a> *cb, int err)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad589f42840c693e67e09774b46036250"></a><!-- doxytag: member="dt::dt_obj_version_t" ref="gad589f42840c693e67e09774b46036250" args="" -->
typedef __u64&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_obj_version_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#gaac0ca3702789825e928e3b059d727679">dt_entry_func_t</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const char *name, void *pvt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function used for parsing path.  <a href="#gaac0ca3702789825e928e3b059d727679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5b222f899fba9030ea3dbee259e4c97"></a><!-- doxytag: member="dt::dt_index_page_build_t" ref="gac5b222f899fba9030ea3dbee259e4c97" args=")(const struct lu_env *env, union lu_page *lp, size_t nob, const struct dt_it_ops *iops, struct dt_it *it, __u32 attr, void *arg)" -->
typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_index_page_build_t</b> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, union <a class="el" href="unionlu__page.html">lu_page</a> *lp, size_t nob, const struct dt_it_ops *iops, struct dt_it *it, __u32 attr, void *arg)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>mntopt_t</b> { <b>MNTOPT_USERXATTR</b> =  0x00000001, 
<b>MNTOPT_ACL</b> =  0x00000002
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#gaea9a8b2931d0590dac0d8265121fd073">dt_index_flags</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073aef32729c6e8d2121075e256eabb309dc">DT_IND_VARKEY</a> =  1 &lt;&lt; 0, 
<a class="el" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073a665c80fdf583c3b6fad49b7b2a59a97b">DT_IND_VARREC</a> =  1 &lt;&lt; 1, 
<a class="el" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073a6528f1359f7a4f7626b6e1aa3b0d0eef">DT_IND_UPDATE</a> =  1 &lt;&lt; 2, 
<a class="el" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073a044b89f60c36ae2452a89148297b5494">DT_IND_NONUNQ</a> =  1 &lt;&lt; 3, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073ae8406895b47a49eecdc3a0bae248d20e">DT_IND_RANGE</a> =  1 &lt;&lt; 4
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#ga51d4c45efee77175aa61574dbc46b53e">dt_format_type</a> { <br/>
&nbsp;&nbsp;<b>DFT_REGULAR</b>, 
<b>DFT_DIR</b>, 
<a class="el" href="group__dt.html#gga51d4c45efee77175aa61574dbc46b53ea5ffd82c5e6e58403e141f5ab4867a310">DFT_NODE</a>, 
<a class="el" href="group__dt.html#gga51d4c45efee77175aa61574dbc46b53ead93af9542695653a7e07004064dcfea4">DFT_INDEX</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__dt.html#gga51d4c45efee77175aa61574dbc46b53ea3ff5f1672deeb66303f63fc82b49fd11">DFT_SYM</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>object type specifier. </p>
 <a href="group__dt.html#ga51d4c45efee77175aa61574dbc46b53e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_otable_it_valid</b> { <b>DOIV_ERROR_HANDLE</b> =  0x0001, 
<b>DOIV_DRYRUN</b> =  0x0002
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_otable_it_flags</b> { <b>DOIF_FAILOUT</b> =  0x0001, 
<b>DOIF_RESET</b> =  0x0002, 
<b>DOIF_OUTUSED</b> =  0x0004, 
<b>DOIF_DRYRUN</b> =  0x0008
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6af79a79c8597e18dc8f25db599c70b"></a><!-- doxytag: member="dt::dt_mode_to_dft" ref="gad6af79a79c8597e18dc8f25db599c70b" args="(__u32 mode)" -->
enum <a class="el" href="group__dt.html#ga51d4c45efee77175aa61574dbc46b53e">dt_format_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_mode_to_dft</b> (__u32 mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad1d2b630b21a38187b5eecb9b4d29b89"></a><!-- doxytag: member="dt::dt_device_init" ref="gad1d2b630b21a38187b5eecb9b4d29b89" args="(struct dt_device *dev, struct lu_device_type *t)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_device_init</b> (struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf9f67f064e70f68da4ec7f5cec036e3d"></a><!-- doxytag: member="dt::dt_device_fini" ref="gaf9f67f064e70f68da4ec7f5cec036e3d" args="(struct dt_device *dev)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_device_fini</b> (struct <a class="el" href="structdt__device.html">dt_device</a> *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab437254471f6d77be12dae01799211b5"></a><!-- doxytag: member="dt::dt_object_init" ref="gab437254471f6d77be12dae01799211b5" args="(struct dt_object *obj, struct lu_object_header *h, struct lu_device *d)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_object_init</b> (struct <a class="el" href="structdt__object.html">dt_object</a> *obj, struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *h, struct <a class="el" href="structlu__device.html">lu_device</a> *d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac04cc2235f432634df8442ad735aece3"></a><!-- doxytag: member="dt::dt_object_fini" ref="gac04cc2235f432634df8442ad735aece3" args="(struct dt_object *obj)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_object_fini</b> (struct <a class="el" href="structdt__object.html">dt_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga76707fa4baf06abc78c090c380a8ddeb"></a><!-- doxytag: member="dt::dt_txn_callback_add" ref="ga76707fa4baf06abc78c090c380a8ddeb" args="(struct dt_device *dev, struct dt_txn_callback *cb)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_txn_callback_add</b> (struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structdt__txn__callback.html">dt_txn_callback</a> *cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc5447f062335db101f52e0d49b3fcfc"></a><!-- doxytag: member="dt::dt_txn_callback_del" ref="gabc5447f062335db101f52e0d49b3fcfc" args="(struct dt_device *dev, struct dt_txn_callback *cb)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_txn_callback_del</b> (struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structdt__txn__callback.html">dt_txn_callback</a> *cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga18e7bc758948ecb19fcdcfd520ba847c"></a><!-- doxytag: member="dt::dt_txn_hook_start" ref="ga18e7bc758948ecb19fcdcfd520ba847c" args="(const struct lu_env *env, struct dt_device *dev, struct thandle *txn)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_txn_hook_start</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structthandle.html">thandle</a> *txn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9e95903a047ba895b93af4c87eb86d5"></a><!-- doxytag: member="dt::dt_txn_hook_stop" ref="gab9e95903a047ba895b93af4c87eb86d5" args="(const struct lu_env *env, struct thandle *txn)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_txn_hook_stop</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structthandle.html">thandle</a> *txn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85e22f6184cd57fcb54c388eb64617d4"></a><!-- doxytag: member="dt::dt_txn_hook_commit" ref="ga85e22f6184cd57fcb54c388eb64617d4" args="(struct thandle *txn)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_txn_hook_commit</b> (struct <a class="el" href="structthandle.html">thandle</a> *txn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa687b02c4c10d70a9764c4932ecb6232"></a><!-- doxytag: member="dt::dt_try_as_dir" ref="gaa687b02c4c10d70a9764c4932ecb6232" args="(const struct lu_env *env, struct dt_object *obj)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_try_as_dir</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#gae3f4b97c61841d149a6fa3a10d824494">dt_path_parser</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, char *local, <a class="el" href="group__dt.html#gaac0ca3702789825e928e3b059d727679">dt_entry_func_t</a> entry_func, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract function which parses path name.  <a href="#gae3f4b97c61841d149a6fa3a10d824494"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga470747542773d71588e0917bb8114745"></a><!-- doxytag: member="dt::dt_store_resolve" ref="ga470747542773d71588e0917bb8114745" args="(const struct lu_env *env, struct dt_device *dt, const char *path, struct lu_fid *fid)" -->
struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_store_resolve</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dt, const char *path, struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#ga589d233b6276fc177086429e37221e36">dt_store_open</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dt, const char *dirname, const char *filename, struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open dt object named <em>filename</em> from <em>dirname</em> directory.  <a href="#ga589d233b6276fc177086429e37221e36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4de85f171c1a2ff28eb385480d9298af"></a><!-- doxytag: member="dt::dt_find_or_create" ref="ga4de85f171c1a2ff28eb385480d9298af" args="(const struct lu_env *env, struct dt_device *dt, const struct lu_fid *fid, struct dt_object_format *dof, struct lu_attr *attr)" -->
struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_find_or_create</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dt, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid, struct <a class="el" href="structdt__object__format.html">dt_object_format</a> *dof, struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3389f36463d849430a4f959b7d04f75b"></a><!-- doxytag: member="dt::dt_locate_at" ref="ga3389f36463d849430a4f959b7d04f75b" args="(const struct lu_env *env, struct dt_device *dev, const struct lu_fid *fid, struct lu_device *top_dev, const struct lu_object_conf *conf)" -->
struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_locate_at</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid, struct <a class="el" href="structlu__device.html">lu_device</a> *top_dev, const struct <a class="el" href="structlu__object__conf.html">lu_object_conf</a> *conf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#gacddd08c8c9a92143811432373ca8a057">local_oid_storage_init</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *first_fid, struct <a class="el" href="structlocal__oid__storage.html">local_oid_storage</a> **los)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize local OID storage for required sequence.  <a href="#gacddd08c8c9a92143811432373ca8a057"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc7d279bad6c3cfbef855fcce89af0e2"></a><!-- doxytag: member="dt::local_oid_storage_fini" ref="gafc7d279bad6c3cfbef855fcce89af0e2" args="(const struct lu_env *env, struct local_oid_storage *los)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>local_oid_storage_fini</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlocal__oid__storage.html">local_oid_storage</a> *los)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaecff6d908b2936e4f9c804611204f98f"></a><!-- doxytag: member="dt::local_object_fid_generate" ref="gaecff6d908b2936e4f9c804611204f98f" args="(const struct lu_env *env, struct local_oid_storage *los, struct lu_fid *fid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#gaecff6d908b2936e4f9c804611204f98f">local_object_fid_generate</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlocal__oid__storage.html">local_oid_storage</a> *los, struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">local file fid generation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad041ecb776afdf707f6e829a043e7cc2"></a><!-- doxytag: member="dt::local_object_declare_create" ref="gad041ecb776afdf707f6e829a043e7cc2" args="(const struct lu_env *env, struct local_oid_storage *los, struct dt_object *o, struct lu_attr *attr, struct dt_object_format *dof, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>local_object_declare_create</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlocal__oid__storage.html">local_oid_storage</a> *los, struct <a class="el" href="structdt__object.html">dt_object</a> *o, struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structdt__object__format.html">dt_object_format</a> *dof, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa288349ab34fbd660c1382182b57808b"></a><!-- doxytag: member="dt::local_object_create" ref="gaa288349ab34fbd660c1382182b57808b" args="(const struct lu_env *env, struct local_oid_storage *los, struct dt_object *o, struct lu_attr *attr, struct dt_object_format *dof, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>local_object_create</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlocal__oid__storage.html">local_oid_storage</a> *los, struct <a class="el" href="structdt__object.html">dt_object</a> *o, struct <a class="el" href="structlu__attr.html">lu_attr</a> *attr, struct <a class="el" href="structdt__object__format.html">dt_object_format</a> *dof, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga682bce02955a11f484a63b86a7a84732"></a><!-- doxytag: member="dt::local_file_find_or_create" ref="ga682bce02955a11f484a63b86a7a84732" args="(const struct lu_env *env, struct local_oid_storage *los, struct dt_object *parent, const char *name, __u32 mode)" -->
struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>local_file_find_or_create</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlocal__oid__storage.html">local_oid_storage</a> *los, struct <a class="el" href="structdt__object.html">dt_object</a> *parent, const char *name, __u32 mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70effd2e3f0a0a777bce34020915c1ac"></a><!-- doxytag: member="dt::local_file_find_or_create_with_fid" ref="ga70effd2e3f0a0a777bce34020915c1ac" args="(const struct lu_env *env, struct dt_device *dt, const struct lu_fid *fid, struct dt_object *parent, const char *name, __u32 mode)" -->
struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>local_file_find_or_create_with_fid</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dt, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid, struct <a class="el" href="structdt__object.html">dt_object</a> *parent, const char *name, __u32 mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb72c7a30f9f16095f213dd4241913fd"></a><!-- doxytag: member="dt::local_index_find_or_create" ref="gabb72c7a30f9f16095f213dd4241913fd" args="(const struct lu_env *env, struct local_oid_storage *los, struct dt_object *parent, const char *name, __u32 mode, const struct dt_index_features *ft)" -->
struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>local_index_find_or_create</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlocal__oid__storage.html">local_oid_storage</a> *los, struct <a class="el" href="structdt__object.html">dt_object</a> *parent, const char *name, __u32 mode, const struct <a class="el" href="structdt__index__features.html">dt_index_features</a> *ft)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a424741dd5edb9d58fb11f0a3cd697c"></a><!-- doxytag: member="dt::local_index_find_or_create_with_fid" ref="ga8a424741dd5edb9d58fb11f0a3cd697c" args="(const struct lu_env *env, struct dt_device *dt, const struct lu_fid *fid, struct dt_object *parent, const char *name, __u32 mode, const struct dt_index_features *ft)" -->
struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>local_index_find_or_create_with_fid</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dt, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid, struct <a class="el" href="structdt__object.html">dt_object</a> *parent, const char *name, __u32 mode, const struct <a class="el" href="structdt__index__features.html">dt_index_features</a> *ft)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga53a967f20c05c94ccf6139d1b2122db8"></a><!-- doxytag: member="dt::local_object_unlink" ref="ga53a967f20c05c94ccf6139d1b2122db8" args="(const struct lu_env *env, struct dt_device *dt, struct dt_object *parent, const char *name)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>local_object_unlink</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dt, struct <a class="el" href="structdt__object.html">dt_object</a> *parent, const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c9bbe53e3209cc074409cbfdcb84ef6"></a><!-- doxytag: member="dt::dt_lookup_dir" ref="ga4c9bbe53e3209cc074409cbfdcb84ef6" args="(const struct lu_env *env, struct dt_object *dir, const char *name, struct lu_fid *fid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#ga4c9bbe53e3209cc074409cbfdcb84ef6">dt_lookup_dir</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dir, const char *name, struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lookup fid for object named <em>name</em> in directory <em>dir</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga37e50073474b1f546edc3ca29f3f8255"></a><!-- doxytag: member="dt::dt_declare_version_set" ref="ga37e50073474b1f546edc3ca29f3f8255" args="(const struct lu_env *env, struct dt_object *o, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_declare_version_set</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *o, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5b07b45f6605ea88bfe89d439234504"></a><!-- doxytag: member="dt::dt_version_set" ref="gaa5b07b45f6605ea88bfe89d439234504" args="(const struct lu_env *env, struct dt_object *o, dt_obj_version_t version, struct thandle *th)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_version_set</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *o, dt_obj_version_t version, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac34ed7d5122ae9cfbc5dbe32326e40a0"></a><!-- doxytag: member="dt::dt_version_get" ref="gac34ed7d5122ae9cfbc5dbe32326e40a0" args="(const struct lu_env *env, struct dt_object *o)" -->
dt_obj_version_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_version_get</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#ga43c7a1d7a094f43523d594505c481095">dt_read</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__buf.html">lu_buf</a> *buf, loff_t *pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic read helper.  <a href="#ga43c7a1d7a094f43523d594505c481095"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#ga82d909c9a0d09d6c21420825acb9e40e">dt_record_read</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__buf.html">lu_buf</a> *buf, loff_t *pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read structures of fixed size from storage.  <a href="#ga82d909c9a0d09d6c21420825acb9e40e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1360ed5c302396b9d5bac50fbfd8ae89"></a><!-- doxytag: member="dt::dt_record_write" ref="ga1360ed5c302396b9d5bac50fbfd8ae89" args="(const struct lu_env *env, struct dt_object *dt, const struct lu_buf *buf, loff_t *pos, struct thandle *th)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_record_write</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *buf, loff_t *pos, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f5929118cadd58fb765ab3619c41db9"></a><!-- doxytag: member="dt::dt_index_walk" ref="ga9f5929118cadd58fb765ab3619c41db9" args="(const struct lu_env *env, struct dt_object *obj, const struct lu_rdpg *rdpg, dt_index_page_build_t filler, void *arg)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_index_walk</b> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *obj, const struct <a class="el" href="structlu__rdpg.html">lu_rdpg</a> *rdpg, dt_index_page_build_t filler, void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#ga311aa8b791e51a13353036585b1236a4">dt_index_read</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__device.html">dt_device</a> *dev, struct <a class="el" href="structidx__info.html">idx_info</a> *ii, const struct <a class="el" href="structlu__rdpg.html">lu_rdpg</a> *rdpg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk key/record pairs of an index and copy them into 4KB containers to be transferred over the <a class="el" href="structnetwork.html">network</a>.  <a href="#ga311aa8b791e51a13353036585b1236a4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7c4fc0f51c05675af9609faa67c6cdea"></a><!-- doxytag: member="dt::dt_directory_features" ref="ga7c4fc0f51c05675af9609faa67c6cdea" args="" -->
struct <a class="el" href="structdt__index__features.html">dt_index_features</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dt.html#ga7c4fc0f51c05675af9609faa67c6cdea">dt_directory_features</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Features, required from index to support file system directories (mapping names to fids). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga955be97567cd4f10ba705a48e4819630"></a><!-- doxytag: member="dt::dt_otable_features" ref="ga955be97567cd4f10ba705a48e4819630" args="" -->
struct <a class="el" href="structdt__index__features.html">dt_index_features</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_otable_features</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae13ff083e120116d3a395c63dd819926"></a><!-- doxytag: member="dt::dt_lfsck_orphan_features" ref="gae13ff083e120116d3a395c63dd819926" args="" -->
struct <a class="el" href="structdt__index__features.html">dt_index_features</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_lfsck_orphan_features</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga061e888f6487d5b0d8d257d2281a13bc"></a><!-- doxytag: member="dt::dt_lfsck_features" ref="ga061e888f6487d5b0d8d257d2281a13bc" args="" -->
struct <a class="el" href="structdt__index__features.html">dt_index_features</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_lfsck_features</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad270c9ad2af37e53181636318069fb66"></a><!-- doxytag: member="dt::dt_acct_features" ref="gad270c9ad2af37e53181636318069fb66" args="" -->
struct <a class="el" href="structdt__index__features.html">dt_index_features</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_acct_features</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf4fe33d2b03960e2f36e43a44672110"></a><!-- doxytag: member="dt::dt_quota_glb_features" ref="gacf4fe33d2b03960e2f36e43a44672110" args="" -->
struct <a class="el" href="structdt__index__features.html">dt_index_features</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_quota_glb_features</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3dea828e72a4601418f4ab9e4a4f6daa"></a><!-- doxytag: member="dt::dt_quota_slv_features" ref="ga3dea828e72a4601418f4ab9e4a4f6daa" args="" -->
struct <a class="el" href="structdt__index__features.html">dt_index_features</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_quota_slv_features</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga68904eda04a363ab89709b9a56337f76"></a><!-- doxytag: member="dt::dt_nodemap_features" ref="ga68904eda04a363ab89709b9a56337f76" args="" -->
struct <a class="el" href="structdt__index__features.html">dt_index_features</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>dt_nodemap_features</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Sub-class of <a class="el" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> with methods common for "data" objects in OST stack. </p>
<p>Data objects behave like regular files: you can read/write them, get and set their attributes. Implementation of dt interface is supposed to implement some form of garbage collection, normally reference counting (nlink) based one.</p>
<p>Examples: osd (lustre/osd) is an implementation of dt interface. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaac0ca3702789825e928e3b059d727679"></a><!-- doxytag: member="dt_object.h::dt_entry_func_t" ref="gaac0ca3702789825e928e3b059d727679" args=")(const struct lu_env *env, const char *name, void *pvt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__dt.html#gaac0ca3702789825e928e3b059d727679">dt_entry_func_t</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const char *name, void *pvt)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function used for parsing path. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>llo_store_resolve </dd></dl>

<p>Definition at line <a class="el" href="dt__object_8h_source.html#l01893">1893</a> of file <a class="el" href="dt__object_8h_source.html">dt_object.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga51d4c45efee77175aa61574dbc46b53e"></a><!-- doxytag: member="dt_object.h::dt_format_type" ref="ga51d4c45efee77175aa61574dbc46b53e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__dt.html#ga51d4c45efee77175aa61574dbc46b53e">dt_format_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>object type specifier. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga51d4c45efee77175aa61574dbc46b53ea5ffd82c5e6e58403e141f5ab4867a310"></a><!-- doxytag: member="DFT_NODE" ref="gga51d4c45efee77175aa61574dbc46b53ea5ffd82c5e6e58403e141f5ab4867a310" args="" -->DFT_NODE</em>&nbsp;</td><td>
<p>for mknod </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga51d4c45efee77175aa61574dbc46b53ead93af9542695653a7e07004064dcfea4"></a><!-- doxytag: member="DFT_INDEX" ref="gga51d4c45efee77175aa61574dbc46b53ead93af9542695653a7e07004064dcfea4" args="" -->DFT_INDEX</em>&nbsp;</td><td>
<p>for special index </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga51d4c45efee77175aa61574dbc46b53ea3ff5f1672deeb66303f63fc82b49fd11"></a><!-- doxytag: member="DFT_SYM" ref="gga51d4c45efee77175aa61574dbc46b53ea3ff5f1672deeb66303f63fc82b49fd11" args="" -->DFT_SYM</em>&nbsp;</td><td>
<p>for symbolic link </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="dt__object_8h_source.html#l00380">380</a> of file <a class="el" href="dt__object_8h_source.html">dt_object.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00380"></a>00380                     {
<a name="l00381"></a>00381         DFT_REGULAR,
<a name="l00382"></a>00382         DFT_DIR,
<a name="l00384"></a>00384         <a class="code" href="group__dt.html#gga51d4c45efee77175aa61574dbc46b53ea5ffd82c5e6e58403e141f5ab4867a310" title="for mknod">DFT_NODE</a>,
<a name="l00386"></a>00386         <a class="code" href="group__dt.html#gga51d4c45efee77175aa61574dbc46b53ead93af9542695653a7e07004064dcfea4" title="for special index">DFT_INDEX</a>,
<a name="l00388"></a>00388         <a class="code" href="group__dt.html#gga51d4c45efee77175aa61574dbc46b53ea3ff5f1672deeb66303f63fc82b49fd11" title="for symbolic link">DFT_SYM</a>,
<a name="l00389"></a>00389 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaea9a8b2931d0590dac0d8265121fd073"></a><!-- doxytag: member="dt_object.h::dt_index_flags" ref="gaea9a8b2931d0590dac0d8265121fd073" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__dt.html#gaea9a8b2931d0590dac0d8265121fd073">dt_index_flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaea9a8b2931d0590dac0d8265121fd073aef32729c6e8d2121075e256eabb309dc"></a><!-- doxytag: member="DT_IND_VARKEY" ref="ggaea9a8b2931d0590dac0d8265121fd073aef32729c6e8d2121075e256eabb309dc" args="" -->DT_IND_VARKEY</em>&nbsp;</td><td>
<p>index supports variable sized keys </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaea9a8b2931d0590dac0d8265121fd073a665c80fdf583c3b6fad49b7b2a59a97b"></a><!-- doxytag: member="DT_IND_VARREC" ref="ggaea9a8b2931d0590dac0d8265121fd073a665c80fdf583c3b6fad49b7b2a59a97b" args="" -->DT_IND_VARREC</em>&nbsp;</td><td>
<p>index supports variable sized records </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaea9a8b2931d0590dac0d8265121fd073a6528f1359f7a4f7626b6e1aa3b0d0eef"></a><!-- doxytag: member="DT_IND_UPDATE" ref="ggaea9a8b2931d0590dac0d8265121fd073a6528f1359f7a4f7626b6e1aa3b0d0eef" args="" -->DT_IND_UPDATE</em>&nbsp;</td><td>
<p>index can be modified </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaea9a8b2931d0590dac0d8265121fd073a044b89f60c36ae2452a89148297b5494"></a><!-- doxytag: member="DT_IND_NONUNQ" ref="ggaea9a8b2931d0590dac0d8265121fd073a044b89f60c36ae2452a89148297b5494" args="" -->DT_IND_NONUNQ</em>&nbsp;</td><td>
<p>index supports records with non-unique (duplicate) keys </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaea9a8b2931d0590dac0d8265121fd073ae8406895b47a49eecdc3a0bae248d20e"></a><!-- doxytag: member="DT_IND_RANGE" ref="ggaea9a8b2931d0590dac0d8265121fd073ae8406895b47a49eecdc3a0bae248d20e" args="" -->DT_IND_RANGE</em>&nbsp;</td><td>
<p>index support fixed-size keys sorted with natural numerical way and is able to return left-side value if no exact value found </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="dt__object_8h_source.html#l00327">327</a> of file <a class="el" href="dt__object_8h_source.html">dt_object.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00327"></a>00327                     {
<a name="l00329"></a>00329         <a class="code" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073aef32729c6e8d2121075e256eabb309dc" title="index supports variable sized keys">DT_IND_VARKEY</a> = 1 &lt;&lt; 0,
<a name="l00331"></a>00331         <a class="code" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073a665c80fdf583c3b6fad49b7b2a59a97b" title="index supports variable sized records">DT_IND_VARREC</a> = 1 &lt;&lt; 1,
<a name="l00333"></a>00333         <a class="code" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073a6528f1359f7a4f7626b6e1aa3b0d0eef" title="index can be modified">DT_IND_UPDATE</a> = 1 &lt;&lt; 2,
<a name="l00335"></a>00335         <a class="code" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073a044b89f60c36ae2452a89148297b5494" title="index supports records with non-unique (duplicate) keys">DT_IND_NONUNQ</a> = 1 &lt;&lt; 3,
<a name="l00340"></a>00340         <a class="code" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073ae8406895b47a49eecdc3a0bae248d20e" title="index support fixed-size keys sorted with natural numerical way and is able to return...">DT_IND_RANGE</a> = 1 &lt;&lt; 4,
<a name="l00341"></a>00341 };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga311aa8b791e51a13353036585b1236a4"></a><!-- doxytag: member="dt_object.h::dt_index_read" ref="ga311aa8b791e51a13353036585b1236a4" args="(const struct lu_env *env, struct dt_device *dev, struct idx_info *ii, const struct lu_rdpg *rdpg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dt_index_read </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdt__device.html">dt_device</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structidx__info.html">idx_info</a> *&nbsp;</td>
          <td class="paramname"> <em>ii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlu__rdpg.html">lu_rdpg</a> *&nbsp;</td>
          <td class="paramname"> <em>rdpg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Walk key/record pairs of an index and copy them into 4KB containers to be transferred over the <a class="el" href="structnetwork.html">network</a>. </p>
<p>This is the common handler for OBD_IDX_READ RPC processing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>env</em>&nbsp;</td><td>- is the environment passed by the caller </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>- is the <a class="el" href="structdt__device.html">dt_device</a> storing the index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ii</em>&nbsp;</td><td>- is the <a class="el" href="structidx__info.html">idx_info</a> structure packed by the client in the OBD_IDX_READ request </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rdpg</em>&nbsp;</td><td>- is the <a class="el" href="structlu__rdpg.html" title="input params, should be filled out by mdt">lu_rdpg</a> descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on</em>&nbsp;</td><td>success, return sum (in bytes) of all filled containers </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>appropriate</em>&nbsp;</td><td>error otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dt__object_8c_source.html#l00911">911</a> of file <a class="el" href="dt__object_8c_source.html">dt_object.c</a>.</p>

<p>References <a class="el" href="dt__object_8h_source.html#l00314">dt_index_features::dif_flags</a>, <a class="el" href="dt__object_8h_source.html#l00318">dt_index_features::dif_keysize_max</a>, <a class="el" href="dt__object_8h_source.html#l00322">dt_index_features::dif_recsize_max</a>, <a class="el" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2">dt_object_operations::do_index_try</a>, <a class="el" href="dt__object_8h_source.html#l00335">DT_IND_NONUNQ</a>, <a class="el" href="dt__object_8h_source.html#l00329">DT_IND_VARKEY</a>, <a class="el" href="dt__object_8h_source.html#l00331">DT_IND_VARREC</a>, <a class="el" href="lu__object_8c_source.html#l00097">lu_object_put()</a>, and <a class="el" href="lu__object_8h_source.html#l00899">lu_rdpg::rp_count</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00913"></a>00913 {
<a name="l00914"></a>00914         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__index__features.html">dt_index_features</a>  *feat;
<a name="l00915"></a>00915         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *obj;
<a name="l00916"></a>00916         <span class="keywordtype">int</span>                              rc;
<a name="l00917"></a>00917         ENTRY;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         <span class="comment">/* rp_count shouldn&apos;t be null and should be a multiple of the container</span>
<a name="l00920"></a>00920 <span class="comment">         * size */</span>
<a name="l00921"></a>00921         <span class="keywordflow">if</span> (rdpg-&gt;<a class="code" href="structlu__rdpg.html#a000eaa380df4e2834da549a61e7dada5" title="count in bytes">rp_count</a> == 0 || (rdpg-&gt;<a class="code" href="structlu__rdpg.html#a000eaa380df4e2834da549a61e7dada5" title="count in bytes">rp_count</a> &amp; (LU_PAGE_SIZE - 1)) != 0)
<a name="l00922"></a>00922                 RETURN(-EFAULT);
<a name="l00923"></a>00923 
<a name="l00924"></a>00924         <span class="keywordflow">if</span> (!fid_is_quota(&amp;ii-&gt;ii_fid) &amp;&amp; !fid_is_layout_rbtree(&amp;ii-&gt;ii_fid) &amp;&amp;
<a name="l00925"></a>00925             !fid_is_norm(&amp;ii-&gt;ii_fid))
<a name="l00926"></a>00926                 RETURN(-EOPNOTSUPP);
<a name="l00927"></a>00927 
<a name="l00928"></a>00928         <span class="comment">/* lookup index object subject to the transfer */</span>
<a name="l00929"></a>00929         obj = dt_locate(env, dev, &amp;ii-&gt;ii_fid);
<a name="l00930"></a>00930         <span class="keywordflow">if</span> (IS_ERR(obj))
<a name="l00931"></a>00931                 RETURN(PTR_ERR(obj));
<a name="l00932"></a>00932         <span class="keywordflow">if</span> (dt_object_exists(obj) == 0)
<a name="l00933"></a>00933                 GOTO(out, rc = -ENOENT);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935         <span class="comment">/* fetch index features associated with index object */</span>
<a name="l00936"></a>00936         feat = dt_index_feat_select(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(&amp;ii-&gt;ii_fid),
<a name="l00937"></a>00937                                     lu_object_attr(&amp;obj-&gt;do_lu));
<a name="l00938"></a>00938         <span class="keywordflow">if</span> (IS_ERR(feat))
<a name="l00939"></a>00939                 GOTO(out, rc = PTR_ERR(feat));
<a name="l00940"></a>00940 
<a name="l00941"></a>00941         <span class="comment">/* load index feature if not done already */</span>
<a name="l00942"></a>00942         <span class="keywordflow">if</span> (obj-&gt;do_index_ops == NULL) {
<a name="l00943"></a>00943                 rc = obj-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2" title="Try object as an index.">do_index_try</a>(env, obj, feat);
<a name="l00944"></a>00944                 <span class="keywordflow">if</span> (rc)
<a name="l00945"></a>00945                         GOTO(out, rc);
<a name="l00946"></a>00946         }
<a name="l00947"></a>00947 
<a name="l00948"></a>00948         <span class="comment">/* fill ii_flags with supported index features */</span>
<a name="l00949"></a>00949         ii-&gt;ii_flags &amp;= (II_FL_NOHASH | II_FL_NOKEY | II_FL_VARKEY |
<a name="l00950"></a>00950                          II_FL_VARREC);
<a name="l00951"></a>00951 
<a name="l00952"></a>00952         <span class="keywordflow">if</span> (!(feat-&gt;<a class="code" href="structdt__index__features.html#a6e28f4490776ccf640ebe0cf484fd399" title="required feature flags from enum dt_index_flags">dif_flags</a> &amp; <a class="code" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073aef32729c6e8d2121075e256eabb309dc" title="index supports variable sized keys">DT_IND_VARKEY</a>))
<a name="l00953"></a>00953                 ii-&gt;ii_keysize = feat-&gt;<a class="code" href="structdt__index__features.html#a77a9d510b54a3321beab43f9fd27f72b" title="maximal required key size, 0 if no limit">dif_keysize_max</a>;
<a name="l00954"></a>00954 
<a name="l00955"></a>00955         if (!(feat-&gt;<a class="code" href="structdt__index__features.html#a6e28f4490776ccf640ebe0cf484fd399" title="required feature flags from enum dt_index_flags">dif_flags</a> &amp; <a class="code" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073a665c80fdf583c3b6fad49b7b2a59a97b" title="index supports variable sized records">DT_IND_VARREC</a>))
<a name="l00956"></a>00956                 ii-&gt;ii_recsize = feat-&gt;<a class="code" href="structdt__index__features.html#af2fc6bfffa47d0412407d9290d32655d" title="maximal required record size, 0 if no limit">dif_recsize_max</a>;
<a name="l00957"></a>00957 
<a name="l00958"></a>00958         if (feat-&gt;<a class="code" href="structdt__index__features.html#a6e28f4490776ccf640ebe0cf484fd399" title="required feature flags from enum dt_index_flags">dif_flags</a> &amp; <a class="code" href="group__dt.html#ggaea9a8b2931d0590dac0d8265121fd073a044b89f60c36ae2452a89148297b5494" title="index supports records with non-unique (duplicate) keys">DT_IND_NONUNQ</a>)
<a name="l00959"></a>00959                 <span class="comment">/* key isn&apos;t necessarily unique */</span>
<a name="l00960"></a>00960                 ii-&gt;ii_flags |= II_FL_NONUNQ;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962         <span class="keywordflow">if</span> (!fid_is_layout_rbtree(&amp;ii-&gt;ii_fid)) {
<a name="l00963"></a>00963                 dt_read_lock(env, obj, 0);
<a name="l00964"></a>00964                 <span class="comment">/* fetch object version before walking the index */</span>
<a name="l00965"></a>00965                 ii-&gt;ii_version = dt_version_get(env, obj);
<a name="l00966"></a>00966         }
<a name="l00967"></a>00967 
<a name="l00968"></a>00968         <span class="comment">/* walk the index and fill lu_idxpages with key/record pairs */</span>
<a name="l00969"></a>00969         rc = dt_index_walk(env, obj, rdpg, dt_index_page_build, ii);
<a name="l00970"></a>00970         <span class="keywordflow">if</span> (!fid_is_layout_rbtree(&amp;ii-&gt;ii_fid))
<a name="l00971"></a>00971                 dt_read_unlock(env, obj);
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00974"></a>00974                 <span class="comment">/* index is empty */</span>
<a name="l00975"></a>00975                 LASSERT(ii-&gt;ii_count == 0);
<a name="l00976"></a>00976                 ii-&gt;ii_hash_end = II_END_OFF;
<a name="l00977"></a>00977         }
<a name="l00978"></a>00978 
<a name="l00979"></a>00979         GOTO(out, rc);
<a name="l00980"></a>00980 out:
<a name="l00981"></a>00981         <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, &amp;obj-&gt;do_lu);
<a name="l00982"></a>00982         <span class="keywordflow">return</span> rc;
<a name="l00983"></a>00983 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__dt_ga311aa8b791e51a13353036585b1236a4_cgraph.png" border="0" usemap="#group__dt_ga311aa8b791e51a13353036585b1236a4_cgraph_map" alt=""></div>
<map name="group__dt_ga311aa8b791e51a13353036585b1236a4_cgraph_map" id="group__dt_ga311aa8b791e51a13353036585b1236a4_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object." alt="" coords="171,5,285,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gae3f4b97c61841d149a6fa3a10d824494"></a><!-- doxytag: member="dt_object.h::dt_path_parser" ref="gae3f4b97c61841d149a6fa3a10d824494" args="(const struct lu_env *env, char *local, dt_entry_func_t entry_func, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dt_path_parser </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt.html#gaac0ca3702789825e928e3b059d727679">dt_entry_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>entry_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abstract function which parses path name. </p>
<p>This function feeds path component to <em>entry_func</em>. </p>

<p>Definition at line <a class="el" href="dt__object_8c_source.html#l00286">286</a> of file <a class="el" href="dt__object_8c_source.html">dt_object.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00289"></a>00289 {
<a name="l00290"></a>00290         <span class="keywordtype">char</span> *e;
<a name="l00291"></a>00291         <span class="keywordtype">int</span> rc = 0;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         <span class="keywordflow">while</span> (1) {
<a name="l00294"></a>00294                 e = strsep(&amp;path, <span class="stringliteral">&quot;/&quot;</span>);
<a name="l00295"></a>00295                 <span class="keywordflow">if</span> (e == NULL)
<a name="l00296"></a>00296                         <span class="keywordflow">break</span>;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298                 <span class="keywordflow">if</span> (e[0] == 0) {
<a name="l00299"></a>00299                         <span class="keywordflow">if</span> (!path || path[0] == <span class="charliteral">&apos;\0&apos;</span>)
<a name="l00300"></a>00300                                 <span class="keywordflow">break</span>;
<a name="l00301"></a>00301                         <span class="keywordflow">continue</span>;
<a name="l00302"></a>00302                 }
<a name="l00303"></a>00303                 rc = entry_func(env, e, data);
<a name="l00304"></a>00304                 <span class="keywordflow">if</span> (rc)
<a name="l00305"></a>00305                         <span class="keywordflow">break</span>;
<a name="l00306"></a>00306         }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308         <span class="keywordflow">return</span> rc;
<a name="l00309"></a>00309 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga43c7a1d7a094f43523d594505c481095"></a><!-- doxytag: member="dt_object.h::dt_read" ref="ga43c7a1d7a094f43523d594505c481095" args="(const struct lu_env *env, struct dt_object *dt, struct lu_buf *buf, loff_t *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dt_read </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__buf.html">lu_buf</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t *&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic read helper. </p>
<p>May return an error for partial reads.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>env</em>&nbsp;</td><td>lustre environment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dt</em>&nbsp;</td><td>object to be read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td><a class="el" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> to be filled, with buffer pointer and length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>position to start reading, updated as data is read</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>real</em>&nbsp;</td><td>size of data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>errno on failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dt__object_8c_source.html#l00469">469</a> of file <a class="el" href="dt__object_8c_source.html">dt_object.c</a>.</p>

<p>References <a class="el" href="structdt__body__operations.html#a6d7a363128fd4899b709b2ff18afd54c">dt_body_operations::dbo_read</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00471"></a>00471 {
<a name="l00472"></a>00472         LASSERTF(dt != NULL, <span class="stringliteral">&quot;dt is NULL when we want to read record\n&quot;</span>);
<a name="l00473"></a>00473         <span class="keywordflow">return</span> dt-&gt;do_body_ops-&gt;<a class="code" href="structdt__body__operations.html#a6d7a363128fd4899b709b2ff18afd54c" title="Read data.">dbo_read</a>(env, dt, buf, pos);
<a name="l00474"></a>00474 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga82d909c9a0d09d6c21420825acb9e40e"></a><!-- doxytag: member="dt_object.h::dt_record_read" ref="ga82d909c9a0d09d6c21420825acb9e40e" args="(const struct lu_env *env, struct dt_object *dt, struct lu_buf *buf, loff_t *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dt_record_read </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdt__object.html">dt_object</a> *&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__buf.html">lu_buf</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t *&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read structures of fixed size from storage. </p>
<p>Unlike <a class="el" href="group__dt.html#ga43c7a1d7a094f43523d594505c481095" title="Generic read helper.">dt_read()</a>, using <a class="el" href="group__dt.html#ga82d909c9a0d09d6c21420825acb9e40e" title="Read structures of fixed size from storage.">dt_record_read()</a> will return an error for partial reads.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>env</em>&nbsp;</td><td>lustre environment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dt</em>&nbsp;</td><td>object to be read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td><a class="el" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> to be filled, with buffer pointer and length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>position to start reading, updated as data is read</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on successfully reading full buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EFAULT</em>&nbsp;</td><td>on short read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>errno on failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dt__object_8c_source.html#l00490">490</a> of file <a class="el" href="dt__object_8c_source.html">dt_object.c</a>.</p>

<p>References <a class="el" href="structdt__body__operations.html#a6d7a363128fd4899b709b2ff18afd54c">dt_body_operations::dbo_read</a>.</p>

<p>Referenced by <a class="el" href="llog__osd_8c_source.html#l01913">llog_osd_get_cat_list()</a>, and <a class="el" href="local__storage_8c_source.html#l00803">local_oid_storage_init()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00492"></a>00492 {
<a name="l00493"></a>00493         ssize_t size;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         LASSERTF(dt != NULL, <span class="stringliteral">&quot;dt is NULL when we want to read record\n&quot;</span>);
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         size = dt-&gt;do_body_ops-&gt;<a class="code" href="structdt__body__operations.html#a6d7a363128fd4899b709b2ff18afd54c" title="Read data.">dbo_read</a>(env, dt, buf, pos);
<a name="l00498"></a>00498         <span class="keywordflow">if</span> (size &lt; 0)
<a name="l00499"></a>00499                 <span class="keywordflow">return</span> size;
<a name="l00500"></a>00500         <span class="keywordflow">return</span> (size == (ssize_t)buf-&gt;lb_len) ? 0 : -EFAULT;
<a name="l00501"></a>00501 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__dt_ga82d909c9a0d09d6c21420825acb9e40e_icgraph.png" border="0" usemap="#group__dt_ga82d909c9a0d09d6c21420825acb9e40e_icgraph_map" alt=""></div>
<map name="group__dt_ga82d909c9a0d09d6c21420825acb9e40e_icgraph_map" id="group__dt_ga82d909c9a0d09d6c21420825acb9e40e_icgraph">
<area shape="rect" id="node3" href="group__log.html#gaf0dee2455ecbe5cbeeec044344224613" title="Read the special file which contains the list of llog catalogs IDs." alt="" coords="180,5,343,35"/><area shape="rect" id="node5" href="group__dt.html#gacddd08c8c9a92143811432373ca8a057" title="Initialize local OID storage for required sequence." alt="" coords="179,59,344,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga589d233b6276fc177086429e37221e36"></a><!-- doxytag: member="dt_object.h::dt_store_open" ref="ga589d233b6276fc177086429e37221e36" args="(const struct lu_env *env, struct dt_device *dt, const char *dirname, const char *filename, struct lu_fid *fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structdt__object.html">dt_object</a>* dt_store_open </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdt__device.html">dt_device</a> *&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__fid.html">lu_fid</a> *&nbsp;</td>
          <td class="paramname"> <em>fid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open dt object named <em>filename</em> from <em>dirname</em> directory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dt</em>&nbsp;</td><td>dt device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fid</em>&nbsp;</td><td>on success, object fid is stored in *fid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dt__object_8c_source.html#l00368">368</a> of file <a class="el" href="dt__object_8c_source.html">dt_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8c_source.html#l00097">lu_object_put()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00373"></a>00373 {
<a name="l00374"></a>00374         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *file;
<a name="l00375"></a>00375         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *dir;
<a name="l00376"></a>00376 
<a name="l00377"></a>00377         dir = dt_store_resolve(env, dt, dirname, fid);
<a name="l00378"></a>00378         <span class="keywordflow">if</span> (!IS_ERR(dir)) {
<a name="l00379"></a>00379                 file = dt_reg_open(env, dt, dir,
<a name="l00380"></a>00380                                    filename, fid);
<a name="l00381"></a>00381                 <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, &amp;dir-&gt;do_lu);
<a name="l00382"></a>00382         } <span class="keywordflow">else</span> {
<a name="l00383"></a>00383                 file = dir;
<a name="l00384"></a>00384         }
<a name="l00385"></a>00385         <span class="keywordflow">return</span> file;
<a name="l00386"></a>00386 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__dt_ga589d233b6276fc177086429e37221e36_cgraph.png" border="0" usemap="#group__dt_ga589d233b6276fc177086429e37221e36_cgraph_map" alt=""></div>
<map name="group__dt_ga589d233b6276fc177086429e37221e36_cgraph_map" id="group__dt_ga589d233b6276fc177086429e37221e36_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object." alt="" coords="173,5,288,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gacddd08c8c9a92143811432373ca8a057"></a><!-- doxytag: member="dt_object.h::local_oid_storage_init" ref="gacddd08c8c9a92143811432373ca8a057" args="(const struct lu_env *env, struct dt_device *dev, const struct lu_fid *first_fid, struct local_oid_storage **los)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_oid_storage_init </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdt__device.html">dt_device</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlu__fid.html">lu_fid</a> *&nbsp;</td>
          <td class="paramname"> <em>first_fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlocal__oid__storage.html">local_oid_storage</a> **&nbsp;</td>
          <td class="paramname"> <em>los</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize local OID storage for required sequence. </p>
<p>That may be needed for services that uses local files and requires dynamic OID allocation for them.</p>
<p>Per each sequence we have an object with 'first_fid' identificator containing the counter for OIDs of locally created files with that sequence.</p>
<p>It is used now by llog subsystem and MGS for NID tables</p>
<p>Function gets first_fid to create counter object. All dynamic fids will be generated with the same sequence and incremented OIDs</p>
<p>Returned <a class="el" href="structlocal__oid__storage.html">local_oid_storage</a> is in-memory representaion of OID storage </p>

<p>Definition at line <a class="el" href="local__storage_8c_source.html#l00803">803</a> of file <a class="el" href="local__storage_8c_source.html">local_storage.c</a>.</p>

<p>References <a class="el" href="dt__object_8h_source.html#l00396">dt_object_format::dof_type</a>, <a class="el" href="dt__object_8c_source.html#l00490">dt_record_read()</a>, <a class="el" href="lustre__user_8h_source.html#l00145">lu_fid::f_seq</a>, <a class="el" href="lustre__user_8h_source.html#l00153">lu_fid::f_ver</a>, <a class="el" href="lu__object_8h_source.html#l00419">lu_attr::la_mode</a>, <a class="el" href="lu__object_8h_source.html#l00439">lu_attr::la_valid</a>, <a class="el" href="lu__object_8h_source.html#l00287">lu_device::ld_obd</a>, <a class="el" href="lu__object_8h_source.html#l00472">lu_object::lo_dev</a>, <a class="el" href="lu__object_8c_source.html#l00193">lu_object_put_nocache()</a>, and <a class="el" href="lustre__idl_8h_source.html#l00237">LUSTRE_FID_LASTID_OID</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00806"></a>00806 {
<a name="l00807"></a>00807         <span class="keyword">struct </span><a class="code" href="structdt__thread__info.html">dt_thread_info</a>   *dti = dt_info(env);
<a name="l00808"></a>00808         <span class="keyword">struct </span><a class="code" href="structls__device.html">ls_device</a>        *ls;
<a name="l00809"></a>00809         u64                      lastid;
<a name="l00810"></a>00810         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *o = NULL;
<a name="l00811"></a>00811         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *th;
<a name="l00812"></a>00812         __u32                    first_oid = fid_oid(first_fid);
<a name="l00813"></a>00813         <span class="keywordtype">int</span>                      rc = 0;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815         ENTRY;
<a name="l00816"></a>00816 
<a name="l00817"></a>00817         ls = ls_device_get(dev);
<a name="l00818"></a>00818         <span class="keywordflow">if</span> (IS_ERR(ls))
<a name="l00819"></a>00819                 RETURN(PTR_ERR(ls));
<a name="l00820"></a>00820 
<a name="l00821"></a>00821         mutex_lock(&amp;ls-&gt;ls_los_mutex);
<a name="l00822"></a>00822         *los = dt_los_find(ls, <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(first_fid));
<a name="l00823"></a>00823         <span class="keywordflow">if</span> (*los != NULL)
<a name="l00824"></a>00824                 GOTO(out, rc = 0);
<a name="l00825"></a>00825 
<a name="l00826"></a>00826         <span class="comment">/* not found, then create */</span>
<a name="l00827"></a>00827         OBD_ALLOC_PTR(*los);
<a name="l00828"></a>00828         <span class="keywordflow">if</span> (*los == NULL)
<a name="l00829"></a>00829                 GOTO(out, rc = -ENOMEM);
<a name="l00830"></a>00830 
<a name="l00831"></a>00831         atomic_set(&amp;(*los)-&gt;los_refcount, 1);
<a name="l00832"></a>00832         mutex_init(&amp;(*los)-&gt;los_id_lock);
<a name="l00833"></a>00833         (*los)-&gt;los_dev = &amp;ls-&gt;ls_top_dev;
<a name="l00834"></a>00834         atomic_inc(&amp;ls-&gt;ls_refcount);
<a name="l00835"></a>00835         list_add(&amp;(*los)-&gt;los_list, &amp;ls-&gt;ls_los_list);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837         <span class="comment">/* Use {seq, 0, 0} to create the LAST_ID file for every</span>
<a name="l00838"></a>00838 <span class="comment">         * sequence.  OIDs start at LUSTRE_FID_INIT_OID.</span>
<a name="l00839"></a>00839 <span class="comment">         */</span>
<a name="l00840"></a>00840         dti-&gt;dti_fid.<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(first_fid);
<a name="l00841"></a>00841         dti-&gt;dti_fid.f_oid = <a class="code" href="group__lu__fid.html#gga39fca1837c5ce7715cbf571669660c13a8b43011f1da1d645f997f4750219e307" title="LASTID file has zero OID.">LUSTRE_FID_LASTID_OID</a>;
<a name="l00842"></a>00842         dti-&gt;dti_fid.<a class="code" href="structlu__fid.html#af6a6857838bb5594da2fe4101985242d" title="FID version, used to distinguish different versions (in the sense of snapshots, etc...">f_ver</a> = 0;
<a name="l00843"></a>00843         o = ls_locate(env, ls, &amp;dti-&gt;dti_fid, NULL);
<a name="l00844"></a>00844         <span class="keywordflow">if</span> (IS_ERR(o))
<a name="l00845"></a>00845                 GOTO(out_los, rc = PTR_ERR(o));
<a name="l00846"></a>00846 
<a name="l00847"></a>00847         <span class="keywordflow">if</span> (!dt_object_exists(o)) {
<a name="l00848"></a>00848                 rc = lastid_compat_check(env, dev, <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(first_fid),
<a name="l00849"></a>00849                                          &amp;first_oid, ls);
<a name="l00850"></a>00850                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00851"></a>00851                         GOTO(out_los, rc);
<a name="l00852"></a>00852 
<a name="l00853"></a>00853                 th = dt_trans_create(env, dev);
<a name="l00854"></a>00854                 <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l00855"></a>00855                         GOTO(out_los, rc = PTR_ERR(th));
<a name="l00856"></a>00856 
<a name="l00857"></a>00857                 dti-&gt;dti_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_MODE | LA_TYPE;
<a name="l00858"></a>00858                 dti-&gt;dti_attr.<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> = S_IFREG | S_IRUGO | S_IWUSR;
<a name="l00859"></a>00859                 dti-&gt;dti_dof.<a class="code" href="structdt__object__format.html#a7522bce1087145d78c749b182e10357c" title="type for dt object">dof_type</a> = dt_mode_to_dft(S_IFREG);
<a name="l00860"></a>00860 
<a name="l00861"></a>00861                 rc = dt_declare_create(env, o, &amp;dti-&gt;dti_attr, NULL,
<a name="l00862"></a>00862                                        &amp;dti-&gt;dti_dof, th);
<a name="l00863"></a>00863                 <span class="keywordflow">if</span> (rc)
<a name="l00864"></a>00864                         GOTO(out_trans, rc);
<a name="l00865"></a>00865 
<a name="l00866"></a>00866                 lastid = cpu_to_le64(first_oid);
<a name="l00867"></a>00867 
<a name="l00868"></a>00868                 dti-&gt;dti_off = 0;
<a name="l00869"></a>00869                 dti-&gt;dti_lb.lb_buf = &amp;lastid;
<a name="l00870"></a>00870                 dti-&gt;dti_lb.lb_len = <span class="keyword">sizeof</span>(lastid);
<a name="l00871"></a>00871                 rc = dt_declare_record_write(env, o, &amp;dti-&gt;dti_lb, dti-&gt;dti_off,
<a name="l00872"></a>00872                                              th);
<a name="l00873"></a>00873                 <span class="keywordflow">if</span> (rc)
<a name="l00874"></a>00874                         GOTO(out_trans, rc);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876                 rc = dt_trans_start_local(env, dev, th);
<a name="l00877"></a>00877                 <span class="keywordflow">if</span> (rc)
<a name="l00878"></a>00878                         GOTO(out_trans, rc);
<a name="l00879"></a>00879 
<a name="l00880"></a>00880                 dt_write_lock(env, o, 0);
<a name="l00881"></a>00881                 <span class="keywordflow">if</span> (dt_object_exists(o))
<a name="l00882"></a>00882                         GOTO(out_lock, rc = 0);
<a name="l00883"></a>00883 
<a name="l00884"></a>00884                 rc = dt_create(env, o, &amp;dti-&gt;dti_attr, NULL, &amp;dti-&gt;dti_dof,
<a name="l00885"></a>00885                                th);
<a name="l00886"></a>00886                 <span class="keywordflow">if</span> (rc)
<a name="l00887"></a>00887                         GOTO(out_lock, rc);
<a name="l00888"></a>00888 
<a name="l00889"></a>00889                 rc = dt_record_write(env, o, &amp;dti-&gt;dti_lb, &amp;dti-&gt;dti_off, th);
<a name="l00890"></a>00890                 <span class="keywordflow">if</span> (rc)
<a name="l00891"></a>00891                         GOTO(out_lock, rc);
<a name="l00892"></a>00892 out_lock:
<a name="l00893"></a>00893                 dt_write_unlock(env, o);
<a name="l00894"></a>00894 out_trans:
<a name="l00895"></a>00895                 dt_trans_stop(env, dev, th);
<a name="l00896"></a>00896         } <span class="keywordflow">else</span> {
<a name="l00897"></a>00897                 dti-&gt;dti_off = 0;
<a name="l00898"></a>00898                 dti-&gt;dti_lb.lb_buf = &amp;lastid;
<a name="l00899"></a>00899                 dti-&gt;dti_lb.lb_len = <span class="keyword">sizeof</span>(lastid);
<a name="l00900"></a>00900                 dt_read_lock(env, o, 0);
<a name="l00901"></a>00901                 rc = <a class="code" href="group__dt.html#ga82d909c9a0d09d6c21420825acb9e40e" title="Read structures of fixed size from storage.">dt_record_read</a>(env, o, &amp;dti-&gt;dti_lb, &amp;dti-&gt;dti_off);
<a name="l00902"></a>00902                 dt_read_unlock(env, o);
<a name="l00903"></a>00903                 <span class="keywordflow">if</span> (rc == 0 &amp;&amp; le64_to_cpu(lastid) &gt; OBIF_MAX_OID) {
<a name="l00904"></a>00904                         CERROR(<span class="stringliteral">&quot;%s: bad oid &quot;</span>LPU64<span class="stringliteral">&quot; is read from LAST_ID\n&quot;</span>,
<a name="l00905"></a>00905                                o-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name,
<a name="l00906"></a>00906                                le64_to_cpu(lastid));
<a name="l00907"></a>00907                         rc = -EINVAL;
<a name="l00908"></a>00908                 }
<a name="l00909"></a>00909         }
<a name="l00910"></a>00910 out_los:
<a name="l00911"></a>00911         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00912"></a>00912                 list_del(&amp;(*los)-&gt;los_list);
<a name="l00913"></a>00913                 atomic_dec(&amp;ls-&gt;ls_refcount);
<a name="l00914"></a>00914                 OBD_FREE_PTR(*los);
<a name="l00915"></a>00915                 *los = NULL;
<a name="l00916"></a>00916                 <span class="keywordflow">if</span> (o != NULL &amp;&amp; !IS_ERR(o))
<a name="l00917"></a>00917                         <a class="code" href="group__lu.html#ga48ae307342778b2ffb56cae3dad5d012" title="Put object and don&amp;#39;t keep in cache.">lu_object_put_nocache</a>(env, &amp;o-&gt;do_lu);
<a name="l00918"></a>00918         } <span class="keywordflow">else</span> {
<a name="l00919"></a>00919                 (*los)-&gt;los_seq = <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(first_fid);
<a name="l00920"></a>00920                 (*los)-&gt;los_last_oid = le64_to_cpu(lastid);
<a name="l00921"></a>00921                 (*los)-&gt;los_obj = o;
<a name="l00922"></a>00922                 <span class="comment">/* Read value should not be less than initial one</span>
<a name="l00923"></a>00923 <span class="comment">                 * but possible after upgrade from older fs.</span>
<a name="l00924"></a>00924 <span class="comment">                 * In this case just switch to the first_oid in memory and</span>
<a name="l00925"></a>00925 <span class="comment">                 * it will be updated on disk with first object generated */</span>
<a name="l00926"></a>00926                 <span class="keywordflow">if</span> ((*los)-&gt;los_last_oid &lt; first_oid)
<a name="l00927"></a>00927                         (*los)-&gt;los_last_oid = first_oid;
<a name="l00928"></a>00928         }
<a name="l00929"></a>00929 out:
<a name="l00930"></a>00930         mutex_unlock(&amp;ls-&gt;ls_los_mutex);
<a name="l00931"></a>00931         ls_device_put(env, ls);
<a name="l00932"></a>00932         <span class="keywordflow">return</span> rc;
<a name="l00933"></a>00933 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__dt_gacddd08c8c9a92143811432373ca8a057_cgraph.png" border="0" usemap="#group__dt_gacddd08c8c9a92143811432373ca8a057_cgraph_map" alt=""></div>
<map name="group__dt_gacddd08c8c9a92143811432373ca8a057_cgraph_map" id="group__dt_gacddd08c8c9a92143811432373ca8a057_cgraph">
<area shape="rect" id="node3" href="group__dt.html#ga82d909c9a0d09d6c21420825acb9e40e" title="Read structures of fixed size from storage." alt="" coords="247,5,369,35"/><area shape="rect" id="node5" href="group__lu.html#ga48ae307342778b2ffb56cae3dad5d012" title="Put object and don&#39;t keep in cache." alt="" coords="219,59,397,88"/><area shape="rect" id="node7" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object." alt="" coords="445,59,560,88"/></map>
</div>
</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:38 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
