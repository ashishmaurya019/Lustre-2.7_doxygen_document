<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ptlrpc/sec.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/ptlrpc/sec.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2014, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lustre/ptlrpc/sec.c</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Author: Eric Mei &lt;ericm@clusterfs.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> */</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_SEC</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;linux/user_namespace.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#ifdef HAVE_UIDGID_HEADER</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor"># include &lt;linux/uidgid.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#endif</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/crypto.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;linux/key.h&gt;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;libcfs/libcfs.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;obd.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;obd_support.h&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;lustre_net.h&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;lustre_import.h&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;lustre_dlm.h&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;lustre_sec.h&gt;</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;ptlrpc_internal.h&quot;</span>
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="comment">/***********************************************</span>
<a name="l00062"></a>00062 <span class="comment"> * policy registers                            *</span>
<a name="l00063"></a>00063 <span class="comment"> ***********************************************/</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="keyword">static</span> rwlock_t policy_lock;
<a name="l00066"></a>00066 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policies[SPTLRPC_POLICY_MAX] = {
<a name="l00067"></a>00067         NULL,
<a name="l00068"></a>00068 };
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keywordtype">int</span> sptlrpc_register_policy(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy)
<a name="l00071"></a>00071 {
<a name="l00072"></a>00072         __u16 number = policy-&gt;sp_policy;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         LASSERT(policy-&gt;sp_name);
<a name="l00075"></a>00075         LASSERT(policy-&gt;sp_cops);
<a name="l00076"></a>00076         LASSERT(policy-&gt;sp_sops);
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         <span class="keywordflow">if</span> (number &gt;= SPTLRPC_POLICY_MAX)
<a name="l00079"></a>00079                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081         write_lock(&amp;policy_lock);
<a name="l00082"></a>00082         <span class="keywordflow">if</span> (unlikely(policies[number])) {
<a name="l00083"></a>00083                 write_unlock(&amp;policy_lock);
<a name="l00084"></a>00084                 <span class="keywordflow">return</span> -EALREADY;
<a name="l00085"></a>00085         }
<a name="l00086"></a>00086         policies[number] = policy;
<a name="l00087"></a>00087         write_unlock(&amp;policy_lock);
<a name="l00088"></a>00088 
<a name="l00089"></a>00089         CDEBUG(D_SEC, <span class="stringliteral">&quot;%s: registered\n&quot;</span>, policy-&gt;sp_name);
<a name="l00090"></a>00090         <span class="keywordflow">return</span> 0;
<a name="l00091"></a>00091 }
<a name="l00092"></a>00092 EXPORT_SYMBOL(sptlrpc_register_policy);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="keywordtype">int</span> sptlrpc_unregister_policy(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy)
<a name="l00095"></a>00095 {
<a name="l00096"></a>00096         __u16 number = policy-&gt;sp_policy;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098         LASSERT(number &lt; SPTLRPC_POLICY_MAX);
<a name="l00099"></a>00099 
<a name="l00100"></a>00100         write_lock(&amp;policy_lock);
<a name="l00101"></a>00101         <span class="keywordflow">if</span> (unlikely(policies[number] == NULL)) {
<a name="l00102"></a>00102                 write_unlock(&amp;policy_lock);
<a name="l00103"></a>00103                 CERROR(<span class="stringliteral">&quot;%s: already unregistered\n&quot;</span>, policy-&gt;sp_name);
<a name="l00104"></a>00104                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         LASSERT(policies[number] == policy);
<a name="l00108"></a>00108         policies[number] = NULL;
<a name="l00109"></a>00109         write_unlock(&amp;policy_lock);
<a name="l00110"></a>00110 
<a name="l00111"></a>00111         CDEBUG(D_SEC, <span class="stringliteral">&quot;%s: unregistered\n&quot;</span>, policy-&gt;sp_name);
<a name="l00112"></a>00112         <span class="keywordflow">return</span> 0;
<a name="l00113"></a>00113 }
<a name="l00114"></a>00114 EXPORT_SYMBOL(sptlrpc_unregister_policy);
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="keyword">static</span>
<a name="l00117"></a>00117 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> * sptlrpc_wireflavor2policy(__u32 flavor)
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119         <span class="keyword">static</span> DEFINE_MUTEX(load_mutex);
<a name="l00120"></a>00120         <span class="keyword">static</span> atomic_t           loaded = ATOMIC_INIT(0);
<a name="l00121"></a>00121         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l00122"></a>00122         __u16                     number = SPTLRPC_FLVR_POLICY(flavor);
<a name="l00123"></a>00123         __u16                     flag = 0;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125         <span class="keywordflow">if</span> (number &gt;= SPTLRPC_POLICY_MAX)
<a name="l00126"></a>00126                 <span class="keywordflow">return</span> NULL;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <span class="keywordflow">while</span> (1) {
<a name="l00129"></a>00129                 read_lock(&amp;policy_lock);
<a name="l00130"></a>00130                 policy = policies[number];
<a name="l00131"></a>00131                 <span class="keywordflow">if</span> (policy &amp;&amp; !try_module_get(policy-&gt;sp_owner))
<a name="l00132"></a>00132                         policy = NULL;
<a name="l00133"></a>00133                 <span class="keywordflow">if</span> (policy == NULL)
<a name="l00134"></a>00134                         flag = atomic_read(&amp;loaded);
<a name="l00135"></a>00135                 read_unlock(&amp;policy_lock);
<a name="l00136"></a>00136 
<a name="l00137"></a>00137                 <span class="keywordflow">if</span> (policy != NULL || flag != 0 ||
<a name="l00138"></a>00138                     number != SPTLRPC_POLICY_GSS)
<a name="l00139"></a>00139                         <span class="keywordflow">break</span>;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141                 <span class="comment">/* try to load gss module, once */</span>
<a name="l00142"></a>00142                 mutex_lock(&amp;load_mutex);
<a name="l00143"></a>00143                 <span class="keywordflow">if</span> (atomic_read(&amp;loaded) == 0) {
<a name="l00144"></a>00144                         <span class="keywordflow">if</span> (request_module(<span class="stringliteral">&quot;ptlrpc_gss&quot;</span>) == 0)
<a name="l00145"></a>00145                                 CDEBUG(D_SEC,
<a name="l00146"></a>00146                                        <span class="stringliteral">&quot;module ptlrpc_gss loaded on demand\n&quot;</span>);
<a name="l00147"></a>00147                         <span class="keywordflow">else</span>
<a name="l00148"></a>00148                                 CERROR(<span class="stringliteral">&quot;Unable to load module ptlrpc_gss\n&quot;</span>);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150                         atomic_set(&amp;loaded, 1);
<a name="l00151"></a>00151                 }
<a name="l00152"></a>00152                 mutex_unlock(&amp;load_mutex);
<a name="l00153"></a>00153         }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155         <span class="keywordflow">return</span> policy;
<a name="l00156"></a>00156 }
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 __u32 sptlrpc_name2flavor_base(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l00159"></a>00159 {
<a name="l00160"></a>00160         <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">&quot;null&quot;</span>))
<a name="l00161"></a>00161                 <span class="keywordflow">return</span> SPTLRPC_FLVR_NULL;
<a name="l00162"></a>00162         <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">&quot;plain&quot;</span>))
<a name="l00163"></a>00163                 <span class="keywordflow">return</span> SPTLRPC_FLVR_PLAIN;
<a name="l00164"></a>00164         <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">&quot;gssnull&quot;</span>))
<a name="l00165"></a>00165                 <span class="keywordflow">return</span> SPTLRPC_FLVR_GSSNULL;
<a name="l00166"></a>00166         <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">&quot;krb5n&quot;</span>))
<a name="l00167"></a>00167                 <span class="keywordflow">return</span> SPTLRPC_FLVR_KRB5N;
<a name="l00168"></a>00168         <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">&quot;krb5a&quot;</span>))
<a name="l00169"></a>00169                 <span class="keywordflow">return</span> SPTLRPC_FLVR_KRB5A;
<a name="l00170"></a>00170         <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">&quot;krb5i&quot;</span>))
<a name="l00171"></a>00171                 <span class="keywordflow">return</span> SPTLRPC_FLVR_KRB5I;
<a name="l00172"></a>00172         <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">&quot;krb5p&quot;</span>))
<a name="l00173"></a>00173                 <span class="keywordflow">return</span> SPTLRPC_FLVR_KRB5P;
<a name="l00174"></a>00174         <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">&quot;ski&quot;</span>))
<a name="l00175"></a>00175                 <span class="keywordflow">return</span> SPTLRPC_FLVR_SKI;
<a name="l00176"></a>00176         <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">&quot;skpi&quot;</span>))
<a name="l00177"></a>00177                 <span class="keywordflow">return</span> SPTLRPC_FLVR_SKPI;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         <span class="keywordflow">return</span> SPTLRPC_FLVR_INVALID;
<a name="l00180"></a>00180 }
<a name="l00181"></a>00181 EXPORT_SYMBOL(sptlrpc_name2flavor_base);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keyword">const</span> <span class="keywordtype">char</span> *sptlrpc_flavor2name_base(__u32 flvr)
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185         __u32   base = SPTLRPC_FLVR_BASE(flvr);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <span class="keywordflow">if</span> (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_NULL))
<a name="l00188"></a>00188                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;null&quot;</span>;
<a name="l00189"></a>00189         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_PLAIN))
<a name="l00190"></a>00190                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;plain&quot;</span>;
<a name="l00191"></a>00191         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_GSSNULL))
<a name="l00192"></a>00192                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;gssnull&quot;</span>;
<a name="l00193"></a>00193         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_KRB5N))
<a name="l00194"></a>00194                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;krb5n&quot;</span>;
<a name="l00195"></a>00195         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_KRB5A))
<a name="l00196"></a>00196                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;krb5a&quot;</span>;
<a name="l00197"></a>00197         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_KRB5I))
<a name="l00198"></a>00198                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;krb5i&quot;</span>;
<a name="l00199"></a>00199         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_KRB5P))
<a name="l00200"></a>00200                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;krb5p&quot;</span>;
<a name="l00201"></a>00201         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_SKI))
<a name="l00202"></a>00202                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;ski&quot;</span>;
<a name="l00203"></a>00203         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_SKPI))
<a name="l00204"></a>00204                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;skpi&quot;</span>;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         CERROR(<span class="stringliteral">&quot;invalid wire flavor 0x%x\n&quot;</span>, flvr);
<a name="l00207"></a>00207         <span class="keywordflow">return</span> <span class="stringliteral">&quot;invalid&quot;</span>;
<a name="l00208"></a>00208 }
<a name="l00209"></a>00209 EXPORT_SYMBOL(sptlrpc_flavor2name_base);
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="keywordtype">char</span> *sptlrpc_flavor2name_bulk(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf,
<a name="l00212"></a>00212                                <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize)
<a name="l00213"></a>00213 {
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (SPTLRPC_FLVR_POLICY(sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) == SPTLRPC_POLICY_PLAIN)
<a name="l00215"></a>00215                 snprintf(buf, bufsize, <span class="stringliteral">&quot;hash:%s&quot;</span>,
<a name="l00216"></a>00216                          sptlrpc_get_hash_name(sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a0cec2e241f5c0d8a29621642f73d1a7c" title="bulk flavor specification">u_bulk</a>.hash.hash_alg));
<a name="l00217"></a>00217         <span class="keywordflow">else</span>
<a name="l00218"></a>00218                 snprintf(buf, bufsize, <span class="stringliteral">&quot;%s&quot;</span>,
<a name="l00219"></a>00219                          sptlrpc_flavor2name_base(sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>));
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         buf[bufsize - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00222"></a>00222         <span class="keywordflow">return</span> buf;
<a name="l00223"></a>00223 }
<a name="l00224"></a>00224 EXPORT_SYMBOL(sptlrpc_flavor2name_bulk);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="keywordtype">char</span> *sptlrpc_flavor2name(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize)
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228         snprintf(buf, bufsize, <span class="stringliteral">&quot;%s&quot;</span>, sptlrpc_flavor2name_base(sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>));
<a name="l00229"></a>00229 
<a name="l00230"></a>00230         <span class="comment">/*</span>
<a name="l00231"></a>00231 <span class="comment">         * currently we don&apos;t support customized bulk specification for</span>
<a name="l00232"></a>00232 <span class="comment">         * flavors other than plain</span>
<a name="l00233"></a>00233 <span class="comment">         */</span>
<a name="l00234"></a>00234         <span class="keywordflow">if</span> (SPTLRPC_FLVR_POLICY(sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) == SPTLRPC_POLICY_PLAIN) {
<a name="l00235"></a>00235                 <span class="keywordtype">char</span> bspec[16];
<a name="l00236"></a>00236 
<a name="l00237"></a>00237                 bspec[0] = <span class="charliteral">&apos;-&apos;</span>;
<a name="l00238"></a>00238                 sptlrpc_flavor2name_bulk(sf, &amp;bspec[1], <span class="keyword">sizeof</span>(bspec) - 1);
<a name="l00239"></a>00239                 strncat(buf, bspec, bufsize);
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         buf[bufsize - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00243"></a>00243         <span class="keywordflow">return</span> buf;
<a name="l00244"></a>00244 }
<a name="l00245"></a>00245 EXPORT_SYMBOL(sptlrpc_flavor2name);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="keywordtype">char</span> *sptlrpc_secflags2str(__u32 flags, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize)
<a name="l00248"></a>00248 {
<a name="l00249"></a>00249         buf[0] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251         <span class="keywordflow">if</span> (flags &amp; PTLRPC_SEC_FL_REVERSE)
<a name="l00252"></a>00252                 strlcat(buf, <span class="stringliteral">&quot;reverse,&quot;</span>, bufsize);
<a name="l00253"></a>00253         <span class="keywordflow">if</span> (flags &amp; PTLRPC_SEC_FL_ROOTONLY)
<a name="l00254"></a>00254                 strlcat(buf, <span class="stringliteral">&quot;rootonly,&quot;</span>, bufsize);
<a name="l00255"></a>00255         <span class="keywordflow">if</span> (flags &amp; PTLRPC_SEC_FL_UDESC)
<a name="l00256"></a>00256                 strlcat(buf, <span class="stringliteral">&quot;udesc,&quot;</span>, bufsize);
<a name="l00257"></a>00257         <span class="keywordflow">if</span> (flags &amp; PTLRPC_SEC_FL_BULK)
<a name="l00258"></a>00258                 strlcat(buf, <span class="stringliteral">&quot;bulk,&quot;</span>, bufsize);
<a name="l00259"></a>00259         <span class="keywordflow">if</span> (buf[0] == <span class="charliteral">&apos;\0&apos;</span>)
<a name="l00260"></a>00260                 strlcat(buf, <span class="stringliteral">&quot;-,&quot;</span>, bufsize);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         <span class="keywordflow">return</span> buf;
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 EXPORT_SYMBOL(sptlrpc_secflags2str);
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 <span class="comment">/**************************************************</span>
<a name="l00267"></a>00267 <span class="comment"> * client context APIs                            *</span>
<a name="l00268"></a>00268 <span class="comment"> **************************************************/</span>
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="keyword">static</span>
<a name="l00271"></a>00271 <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *get_my_ctx(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l00272"></a>00272 {
<a name="l00273"></a>00273         <span class="keyword">struct </span><a class="code" href="structvfs__cred.html">vfs_cred</a> vcred;
<a name="l00274"></a>00274         <span class="keywordtype">int</span> create = 1, remove_dead = 1;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276         LASSERT(sec);
<a name="l00277"></a>00277         LASSERT(sec-&gt;ps_policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#ab3722080e66868d83901a114d4ac3897" title="Given vcred, lookup and/or create its context.">lookup_ctx</a>);
<a name="l00278"></a>00278 
<a name="l00279"></a>00279         <span class="keywordflow">if</span> (sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> &amp; (PTLRPC_SEC_FL_REVERSE |
<a name="l00280"></a>00280                                      PTLRPC_SEC_FL_ROOTONLY)) {
<a name="l00281"></a>00281                 vcred.vc_uid = 0;
<a name="l00282"></a>00282                 vcred.vc_gid = 0;
<a name="l00283"></a>00283                 <span class="keywordflow">if</span> (sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> &amp; PTLRPC_SEC_FL_REVERSE) {
<a name="l00284"></a>00284                         create = 0;
<a name="l00285"></a>00285                         remove_dead = 0;
<a name="l00286"></a>00286                 }
<a name="l00287"></a>00287         } <span class="keywordflow">else</span> {
<a name="l00288"></a>00288                 vcred.vc_uid = from_kuid(&amp;init_user_ns, current_uid());
<a name="l00289"></a>00289                 vcred.vc_gid = from_kgid(&amp;init_user_ns, current_gid());
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292         <span class="keywordflow">return</span> sec-&gt;ps_policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#ab3722080e66868d83901a114d4ac3897" title="Given vcred, lookup and/or create its context.">lookup_ctx</a>(sec, &amp;vcred, create,
<a name="l00293"></a>00293                                                    remove_dead);
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *sptlrpc_cli_ctx_get(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00297"></a>00297 {
<a name="l00298"></a>00298         atomic_inc(&amp;ctx-&gt;cc_refcount);
<a name="l00299"></a>00299         <span class="keywordflow">return</span> ctx;
<a name="l00300"></a>00300 }
<a name="l00301"></a>00301 EXPORT_SYMBOL(sptlrpc_cli_ctx_get);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="keywordtype">void</span> sptlrpc_cli_ctx_put(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">int</span> sync)
<a name="l00304"></a>00304 {
<a name="l00305"></a>00305         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec = ctx-&gt;cc_sec;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307         LASSERT(sec);
<a name="l00308"></a>00308         LASSERT_ATOMIC_POS(&amp;ctx-&gt;cc_refcount);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310         <span class="keywordflow">if</span> (!atomic_dec_and_test(&amp;ctx-&gt;cc_refcount))
<a name="l00311"></a>00311                 <span class="keywordflow">return</span>;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313         sec-&gt;ps_policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#aabc06c431b7e2b62d2d81f0707834122" title="Called then the reference of ctx dropped to 0.">release_ctx</a>(sec, ctx, sync);
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 EXPORT_SYMBOL(sptlrpc_cli_ctx_put);
<a name="l00316"></a>00316 
<a name="l00322"></a><a class="code" href="group__sptlrpc.html#ga6c05663895d669f077f0369232b46dad">00322</a> <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga6c05663895d669f077f0369232b46dad" title="Expire the client context immediately.">sptlrpc_cli_ctx_expire</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00323"></a>00323 {
<a name="l00324"></a>00324         LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a87347673c61d50fb34d358829bcff5ae" title="Force the ctx to die.">die</a>);
<a name="l00325"></a>00325         ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a87347673c61d50fb34d358829bcff5ae" title="Force the ctx to die.">die</a>(ctx, 0);
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 EXPORT_SYMBOL(<a class="code" href="group__sptlrpc.html#ga6c05663895d669f077f0369232b46dad" title="Expire the client context immediately.">sptlrpc_cli_ctx_expire</a>);
<a name="l00328"></a>00328 
<a name="l00333"></a><a class="code" href="group__sptlrpc.html#gae8509673f10f3ba05986d960f5b4a20d">00333</a> <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#gae8509673f10f3ba05986d960f5b4a20d" title="To wake up the threads who are waiting for this client context.">sptlrpc_cli_ctx_wakeup</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00334"></a>00334 {
<a name="l00335"></a>00335         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, *next;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337         spin_lock(&amp;ctx-&gt;cc_lock);
<a name="l00338"></a>00338         list_for_each_entry_safe(req, next, &amp;ctx-&gt;cc_req_list,
<a name="l00339"></a>00339                                      rq_ctx_chain) {
<a name="l00340"></a>00340                 list_del_init(&amp;req-&gt;rq_ctx_chain);
<a name="l00341"></a>00341                 ptlrpc_client_wake_req(req);
<a name="l00342"></a>00342         }
<a name="l00343"></a>00343         spin_unlock(&amp;ctx-&gt;cc_lock);
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 EXPORT_SYMBOL(<a class="code" href="group__sptlrpc.html#gae8509673f10f3ba05986d960f5b4a20d" title="To wake up the threads who are waiting for this client context.">sptlrpc_cli_ctx_wakeup</a>);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="keywordtype">int</span> sptlrpc_cli_ctx_display(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize)
<a name="l00348"></a>00348 {
<a name="l00349"></a>00349         LASSERT(ctx-&gt;cc_ops);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351         <span class="keywordflow">if</span> (ctx-&gt;cc_ops-&gt;display == NULL)
<a name="l00352"></a>00352                 <span class="keywordflow">return</span> 0;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354         <span class="keywordflow">return</span> ctx-&gt;cc_ops-&gt;display(ctx, buf, bufsize);
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 <span class="keyword">static</span> <span class="keywordtype">int</span> import_sec_check_expire(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359         <span class="keywordtype">int</span>     adapt = 0;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00362"></a>00362         <span class="keywordflow">if</span> (imp-&gt;imp_sec_expire &amp;&amp;
<a name="l00363"></a>00363             imp-&gt;imp_sec_expire &lt; cfs_time_current_sec()) {
<a name="l00364"></a>00364                 adapt = 1;
<a name="l00365"></a>00365                 imp-&gt;imp_sec_expire = 0;
<a name="l00366"></a>00366         }
<a name="l00367"></a>00367         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00368"></a>00368 
<a name="l00369"></a>00369         <span class="keywordflow">if</span> (!adapt)
<a name="l00370"></a>00370                 <span class="keywordflow">return</span> 0;
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         CDEBUG(D_SEC, <span class="stringliteral">&quot;found delayed sec adapt expired, do it now\n&quot;</span>);
<a name="l00373"></a>00373         <span class="keywordflow">return</span> <a class="code" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration...">sptlrpc_import_sec_adapt</a>(imp, NULL, NULL);
<a name="l00374"></a>00374 }
<a name="l00375"></a>00375 
<a name="l00389"></a>00389 <span class="keyword">static</span> <span class="keywordtype">int</span> import_sec_validate_get(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00390"></a>00390                                    <span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> **sec)
<a name="l00391"></a>00391 {
<a name="l00392"></a>00392         <span class="keywordtype">int</span>     rc;
<a name="l00393"></a>00393 
<a name="l00394"></a>00394         <span class="keywordflow">if</span> (unlikely(imp-&gt;imp_sec_expire)) {
<a name="l00395"></a>00395                 rc = import_sec_check_expire(imp);
<a name="l00396"></a>00396                 <span class="keywordflow">if</span> (rc)
<a name="l00397"></a>00397                         <span class="keywordflow">return</span> rc;
<a name="l00398"></a>00398         }
<a name="l00399"></a>00399 
<a name="l00400"></a>00400         *sec = sptlrpc_import_sec_ref(imp);
<a name="l00401"></a>00401         <span class="comment">/* Only output an error when the import is still active */</span>
<a name="l00402"></a>00402         <span class="keywordflow">if</span> (*sec == NULL) {
<a name="l00403"></a>00403                 <span class="keywordflow">if</span> (list_empty(&amp;imp-&gt;<a class="code" href="structobd__import.html#a2c7d2711792f8c3a958b76afc77fb993" title="List element for linking into chain for destruction.">imp_zombie_chain</a>))
<a name="l00404"></a>00404                         CERROR(<span class="stringliteral">&quot;import %p (%s) with no sec\n&quot;</span>,
<a name="l00405"></a>00405                                 imp, ptlrpc_import_state_name(imp-&gt;<a class="code" href="structobd__import.html#affb65aaaf26d991850c45fda2049f2a5" title="Current import state.">imp_state</a>));
<a name="l00406"></a>00406                 <span class="keywordflow">return</span> -EACCES;
<a name="l00407"></a>00407         }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409         <span class="keywordflow">if</span> (unlikely((*sec)-&gt;ps_dying)) {
<a name="l00410"></a>00410                 CERROR(<span class="stringliteral">&quot;attempt to use dying sec %p\n&quot;</span>, sec);
<a name="l00411"></a>00411                 sptlrpc_sec_put(*sec);
<a name="l00412"></a>00412                 <span class="keywordflow">return</span> -EACCES;
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415         <span class="keywordflow">return</span> 0;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00425"></a><a class="code" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847">00425</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it.">sptlrpc_req_get_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00426"></a>00426 {
<a name="l00427"></a>00427         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>;
<a name="l00428"></a>00428         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec;
<a name="l00429"></a>00429         <span class="keywordtype">int</span>                rc;
<a name="l00430"></a>00430         ENTRY;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432         LASSERT(!req-&gt;rq_cli_ctx);
<a name="l00433"></a>00433         LASSERT(imp);
<a name="l00434"></a>00434 
<a name="l00435"></a>00435         rc = import_sec_validate_get(imp, &amp;sec);
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (rc)
<a name="l00437"></a>00437                 RETURN(rc);
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         req-&gt;rq_cli_ctx = get_my_ctx(sec);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         sptlrpc_sec_put(sec);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443         <span class="keywordflow">if</span> (!req-&gt;rq_cli_ctx) {
<a name="l00444"></a>00444                 CERROR(<span class="stringliteral">&quot;req %p: fail to get context\n&quot;</span>, req);
<a name="l00445"></a>00445                 RETURN(-ECONNREFUSED);
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         RETURN(0);
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 
<a name="l00460"></a><a class="code" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c">00460</a> <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req.">sptlrpc_req_put_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> sync)
<a name="l00461"></a>00461 {
<a name="l00462"></a>00462         ENTRY;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464         LASSERT(req);
<a name="l00465"></a>00465         LASSERT(req-&gt;rq_cli_ctx);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         <span class="comment">/* request might be asked to release earlier while still</span>
<a name="l00468"></a>00468 <span class="comment">         * in the context waiting list.</span>
<a name="l00469"></a>00469 <span class="comment">         */</span>
<a name="l00470"></a>00470         <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;rq_ctx_chain)) {
<a name="l00471"></a>00471                 spin_lock(&amp;req-&gt;rq_cli_ctx-&gt;cc_lock);
<a name="l00472"></a>00472                 list_del_init(&amp;req-&gt;rq_ctx_chain);
<a name="l00473"></a>00473                 spin_unlock(&amp;req-&gt;rq_cli_ctx-&gt;cc_lock);
<a name="l00474"></a>00474         }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476         sptlrpc_cli_ctx_put(req-&gt;rq_cli_ctx, sync);
<a name="l00477"></a>00477         req-&gt;rq_cli_ctx = NULL;
<a name="l00478"></a>00478         EXIT;
<a name="l00479"></a>00479 }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="keyword">static</span>
<a name="l00482"></a>00482 <span class="keywordtype">int</span> sptlrpc_req_ctx_switch(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00483"></a>00483                            <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *oldctx,
<a name="l00484"></a>00484                            <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *newctx)
<a name="l00485"></a>00485 {
<a name="l00486"></a>00486         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a>   old_flvr;
<a name="l00487"></a>00487         <span class="keywordtype">char</span>                   *reqmsg = NULL; <span class="comment">/* to workaround old gcc */</span>
<a name="l00488"></a>00488         <span class="keywordtype">int</span>                     reqmsg_size;
<a name="l00489"></a>00489         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l00492"></a>00492         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a9746010150c167d5b6e62786d61f18df" title="Request length.">rq_reqlen</a>);
<a name="l00493"></a>00493         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#aaa9ba7e7b71ad2057d1650469ab15076" title="Reply length.">rq_replen</a>);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         CDEBUG(D_SEC, <span class="stringliteral">&quot;req %p: switch ctx %p(%u-&gt;%s) -&gt; %p(%u-&gt;%s), &quot;</span>
<a name="l00496"></a>00496                <span class="stringliteral">&quot;switch sec %p(%s) -&gt; %p(%s)\n&quot;</span>, req,
<a name="l00497"></a>00497                oldctx, oldctx-&gt;cc_vcred.vc_uid, sec2target_str(oldctx-&gt;cc_sec),
<a name="l00498"></a>00498                newctx, newctx-&gt;cc_vcred.vc_uid, sec2target_str(newctx-&gt;cc_sec),
<a name="l00499"></a>00499                oldctx-&gt;cc_sec, oldctx-&gt;cc_sec-&gt;ps_policy-&gt;sp_name,
<a name="l00500"></a>00500                newctx-&gt;cc_sec, newctx-&gt;cc_sec-&gt;ps_policy-&gt;sp_name);
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         <span class="comment">/* save flavor */</span>
<a name="l00503"></a>00503         old_flvr = req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>;
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         <span class="comment">/* save request message */</span>
<a name="l00506"></a>00506         reqmsg_size = req-&gt;<a class="code" href="structptlrpc__request.html#a9746010150c167d5b6e62786d61f18df" title="Request length.">rq_reqlen</a>;
<a name="l00507"></a>00507         <span class="keywordflow">if</span> (reqmsg_size != 0) {
<a name="l00508"></a>00508                 OBD_ALLOC_LARGE(reqmsg, reqmsg_size);
<a name="l00509"></a>00509                 <span class="keywordflow">if</span> (reqmsg == NULL)
<a name="l00510"></a>00510                         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00511"></a>00511                 memcpy(reqmsg, req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, reqmsg_size);
<a name="l00512"></a>00512         }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         <span class="comment">/* release old req/rep buf */</span>
<a name="l00515"></a>00515         req-&gt;rq_cli_ctx = oldctx;
<a name="l00516"></a>00516         <a class="code" href="group__sptlrpc.html#ga2f36863ed408b2fc13f7a04eb6280dd4" title="Used by ptlrpc client to free request buffer of req.">sptlrpc_cli_free_reqbuf</a>(req);
<a name="l00517"></a>00517         <a class="code" href="group__sptlrpc.html#ga6cd89bd371e4a81930e260bb1b8c79f8" title="Used by ptlrpc client to free reply buffer of req.">sptlrpc_cli_free_repbuf</a>(req);
<a name="l00518"></a>00518         req-&gt;rq_cli_ctx = newctx;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520         <span class="comment">/* recalculate the flavor */</span>
<a name="l00521"></a>00521         <a class="code" href="group__sptlrpc.html#ga701bf20eebf0fd9d03c94918418f3b31" title="Initialize flavor settings for req, according to opcode.">sptlrpc_req_set_flavor</a>(req, 0);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         <span class="comment">/* alloc new request buffer</span>
<a name="l00524"></a>00524 <span class="comment">         * we don&apos;t need to alloc reply buffer here, leave it to the</span>
<a name="l00525"></a>00525 <span class="comment">         * rest procedure of ptlrpc */</span>
<a name="l00526"></a>00526         <span class="keywordflow">if</span> (reqmsg_size != 0) {
<a name="l00527"></a>00527                 rc = <a class="code" href="group__sptlrpc.html#gaafb426af1f450b0f25952ba1b38f640d" title="Used by ptlrpc client to allocate request buffer of req.">sptlrpc_cli_alloc_reqbuf</a>(req, reqmsg_size);
<a name="l00528"></a>00528                 <span class="keywordflow">if</span> (!rc) {
<a name="l00529"></a>00529                         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l00530"></a>00530                         memcpy(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, reqmsg, reqmsg_size);
<a name="l00531"></a>00531                 } <span class="keywordflow">else</span> {
<a name="l00532"></a>00532                         CWARN(<span class="stringliteral">&quot;failed to alloc reqbuf: %d\n&quot;</span>, rc);
<a name="l00533"></a>00533                         req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a> = old_flvr;
<a name="l00534"></a>00534                 }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536                 OBD_FREE_LARGE(reqmsg, reqmsg_size);
<a name="l00537"></a>00537         }
<a name="l00538"></a>00538         <span class="keywordflow">return</span> rc;
<a name="l00539"></a>00539 }
<a name="l00540"></a>00540 
<a name="l00549"></a><a class="code" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd">00549</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g.">sptlrpc_req_replace_dead_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00550"></a>00550 {
<a name="l00551"></a>00551         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *oldctx = req-&gt;rq_cli_ctx;
<a name="l00552"></a>00552         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *newctx;
<a name="l00553"></a>00553         <span class="keywordtype">int</span>                    rc;
<a name="l00554"></a>00554         ENTRY;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556         LASSERT(oldctx);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         sptlrpc_cli_ctx_get(oldctx);
<a name="l00559"></a>00559         <a class="code" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req.">sptlrpc_req_put_ctx</a>(req, 0);
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         rc = <a class="code" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it.">sptlrpc_req_get_ctx</a>(req);
<a name="l00562"></a>00562         <span class="keywordflow">if</span> (unlikely(rc)) {
<a name="l00563"></a>00563                 LASSERT(!req-&gt;rq_cli_ctx);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565                 <span class="comment">/* restore old ctx */</span>
<a name="l00566"></a>00566                 req-&gt;rq_cli_ctx = oldctx;
<a name="l00567"></a>00567                 RETURN(rc);
<a name="l00568"></a>00568         }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         newctx = req-&gt;rq_cli_ctx;
<a name="l00571"></a>00571         LASSERT(newctx);
<a name="l00572"></a>00572 
<a name="l00573"></a>00573         <span class="keywordflow">if</span> (unlikely(newctx == oldctx &amp;&amp;
<a name="l00574"></a>00574                      test_bit(PTLRPC_CTX_DEAD_BIT, &amp;oldctx-&gt;cc_flags))) {
<a name="l00575"></a>00575                 <span class="comment">/*</span>
<a name="l00576"></a>00576 <span class="comment">                 * still get the old dead ctx, usually means system too busy</span>
<a name="l00577"></a>00577 <span class="comment">                 */</span>
<a name="l00578"></a>00578                 CDEBUG(D_SEC,
<a name="l00579"></a>00579                        <span class="stringliteral">&quot;ctx (%p, fl %lx) doesn&apos;t switch, relax a little bit\n&quot;</span>,
<a name="l00580"></a>00580                        newctx, newctx-&gt;cc_flags);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582                 set_current_state(TASK_INTERRUPTIBLE);
<a name="l00583"></a>00583                 schedule_timeout(msecs_to_jiffies(MSEC_PER_SEC));
<a name="l00584"></a>00584         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (unlikely(test_bit(PTLRPC_CTX_UPTODATE_BIT, &amp;newctx-&gt;cc_flags)
<a name="l00585"></a>00585                             == 0)) {
<a name="l00586"></a>00586                 <span class="comment">/*</span>
<a name="l00587"></a>00587 <span class="comment">                 * new ctx not up to date yet</span>
<a name="l00588"></a>00588 <span class="comment">                 */</span>
<a name="l00589"></a>00589                 CDEBUG(D_SEC,
<a name="l00590"></a>00590                        <span class="stringliteral">&quot;ctx (%p, fl %lx) doesn&apos;t switch, not up to date yet\n&quot;</span>,
<a name="l00591"></a>00591                        newctx, newctx-&gt;cc_flags);
<a name="l00592"></a>00592         } <span class="keywordflow">else</span> {
<a name="l00593"></a>00593                 <span class="comment">/*</span>
<a name="l00594"></a>00594 <span class="comment">                 * it&apos;s possible newctx == oldctx if we&apos;re switching</span>
<a name="l00595"></a>00595 <span class="comment">                 * subflavor with the same sec.</span>
<a name="l00596"></a>00596 <span class="comment">                 */</span>
<a name="l00597"></a>00597                 rc = sptlrpc_req_ctx_switch(req, oldctx, newctx);
<a name="l00598"></a>00598                 <span class="keywordflow">if</span> (rc) {
<a name="l00599"></a>00599                         <span class="comment">/* restore old ctx */</span>
<a name="l00600"></a>00600                         <a class="code" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req.">sptlrpc_req_put_ctx</a>(req, 0);
<a name="l00601"></a>00601                         req-&gt;rq_cli_ctx = oldctx;
<a name="l00602"></a>00602                         RETURN(rc);
<a name="l00603"></a>00603                 }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605                 LASSERT(req-&gt;rq_cli_ctx == newctx);
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         sptlrpc_cli_ctx_put(oldctx, 1);
<a name="l00609"></a>00609         RETURN(0);
<a name="l00610"></a>00610 }
<a name="l00611"></a>00611 EXPORT_SYMBOL(<a class="code" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g.">sptlrpc_req_replace_dead_ctx</a>);
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="keyword">static</span>
<a name="l00614"></a>00614 <span class="keywordtype">int</span> ctx_check_refresh(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00615"></a>00615 {
<a name="l00616"></a>00616         <span class="keywordflow">if</span> (cli_ctx_is_refreshed(ctx))
<a name="l00617"></a>00617                 <span class="keywordflow">return</span> 1;
<a name="l00618"></a>00618         <span class="keywordflow">return</span> 0;
<a name="l00619"></a>00619 }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 <span class="keyword">static</span>
<a name="l00622"></a>00622 <span class="keywordtype">int</span> ctx_refresh_timeout(<span class="keywordtype">void</span> *data)
<a name="l00623"></a>00623 {
<a name="l00624"></a>00624         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = data;
<a name="l00625"></a>00625         <span class="keywordtype">int</span> rc;
<a name="l00626"></a>00626 
<a name="l00627"></a>00627         <span class="comment">/* conn_cnt is needed in expire_one_request */</span>
<a name="l00628"></a>00628         lustre_msg_set_conn_cnt(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;<a class="code" href="structobd__import.html#ac3b8409237b9f6fc17e80bdfed39a1d5" title="Incremented every time we send reconnection request.">imp_conn_cnt</a>);
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         rc = ptlrpc_expire_one_request(req, 1);
<a name="l00631"></a>00631         <span class="comment">/* if we started recovery, we should mark this ctx dead; otherwise</span>
<a name="l00632"></a>00632 <span class="comment">         * in case of lgssd died nobody would retire this ctx, following</span>
<a name="l00633"></a>00633 <span class="comment">         * connecting will still find the same ctx thus cause deadlock.</span>
<a name="l00634"></a>00634 <span class="comment">         * there&apos;s an assumption that expire time of the request should be</span>
<a name="l00635"></a>00635 <span class="comment">         * later than the context refresh expire time.</span>
<a name="l00636"></a>00636 <span class="comment">         */</span>
<a name="l00637"></a>00637         <span class="keywordflow">if</span> (rc == 0)
<a name="l00638"></a>00638                 req-&gt;rq_cli_ctx-&gt;cc_ops-&gt;die(req-&gt;rq_cli_ctx, 0);
<a name="l00639"></a>00639         <span class="keywordflow">return</span> rc;
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="keyword">static</span>
<a name="l00643"></a>00643 <span class="keywordtype">void</span> ctx_refresh_interrupt(<span class="keywordtype">void</span> *data)
<a name="l00644"></a>00644 {
<a name="l00645"></a>00645         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = data;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00648"></a>00648         req-&gt;<a class="code" href="structptlrpc__request.html#a6d4f6fc90fdcc8e2492f4ab902147970" title="client-side flags are serialized by rq_lock">rq_intr</a> = 1;
<a name="l00649"></a>00649         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00650"></a>00650 }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 <span class="keyword">static</span>
<a name="l00653"></a>00653 <span class="keywordtype">void</span> req_off_ctx_list(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00654"></a>00654 {
<a name="l00655"></a>00655         spin_lock(&amp;ctx-&gt;cc_lock);
<a name="l00656"></a>00656         <span class="keywordflow">if</span> (!list_empty(&amp;req-&gt;rq_ctx_chain))
<a name="l00657"></a>00657                 list_del_init(&amp;req-&gt;rq_ctx_chain);
<a name="l00658"></a>00658         spin_unlock(&amp;ctx-&gt;cc_lock);
<a name="l00659"></a>00659 }
<a name="l00660"></a>00660 
<a name="l00675"></a><a class="code" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0">00675</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&amp;#39;s not up-to-date.">sptlrpc_req_refresh_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">long</span> timeout)
<a name="l00676"></a>00676 {
<a name="l00677"></a>00677         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>  *ctx = req-&gt;rq_cli_ctx;
<a name="l00678"></a>00678         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>      *sec;
<a name="l00679"></a>00679         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>      lwi;
<a name="l00680"></a>00680         <span class="keywordtype">int</span>                     rc;
<a name="l00681"></a>00681         ENTRY;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         LASSERT(ctx);
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="keywordflow">if</span> (req-&gt;rq_ctx_init || req-&gt;rq_ctx_fini)
<a name="l00686"></a>00686                 RETURN(0);
<a name="l00687"></a>00687 
<a name="l00688"></a>00688         <span class="comment">/*</span>
<a name="l00689"></a>00689 <span class="comment">         * during the process a request&apos;s context might change type even</span>
<a name="l00690"></a>00690 <span class="comment">         * (e.g. from gss ctx to null ctx), so each loop we need to re-check</span>
<a name="l00691"></a>00691 <span class="comment">         * everything</span>
<a name="l00692"></a>00692 <span class="comment">         */</span>
<a name="l00693"></a>00693 again:
<a name="l00694"></a>00694         rc = import_sec_validate_get(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>, &amp;sec);
<a name="l00695"></a>00695         <span class="keywordflow">if</span> (rc)
<a name="l00696"></a>00696                 RETURN(rc);
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         <span class="keywordflow">if</span> (sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a> != req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) {
<a name="l00699"></a>00699                 CDEBUG(D_SEC, <span class="stringliteral">&quot;req %p: flavor has changed %x -&gt; %x\n&quot;</span>,
<a name="l00700"></a>00700                       req, req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l00701"></a>00701                 req_off_ctx_list(req, ctx);
<a name="l00702"></a>00702                 <a class="code" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g.">sptlrpc_req_replace_dead_ctx</a>(req);
<a name="l00703"></a>00703                 ctx = req-&gt;rq_cli_ctx;
<a name="l00704"></a>00704         }
<a name="l00705"></a>00705         sptlrpc_sec_put(sec);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707         <span class="keywordflow">if</span> (cli_ctx_is_eternal(ctx))
<a name="l00708"></a>00708                 RETURN(0);
<a name="l00709"></a>00709 
<a name="l00710"></a>00710         <span class="keywordflow">if</span> (unlikely(test_bit(PTLRPC_CTX_NEW_BIT, &amp;ctx-&gt;cc_flags))) {
<a name="l00711"></a>00711                 LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#ad2d600893d9bf038f602916ca9419eb8" title="To bring the ctx uptodate.">refresh</a>);
<a name="l00712"></a>00712                 ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#ad2d600893d9bf038f602916ca9419eb8" title="To bring the ctx uptodate.">refresh</a>(ctx);
<a name="l00713"></a>00713         }
<a name="l00714"></a>00714         LASSERT(test_bit(PTLRPC_CTX_NEW_BIT, &amp;ctx-&gt;cc_flags) == 0);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716         LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255" title="Validate the ctx.">validate</a>);
<a name="l00717"></a>00717         <span class="keywordflow">if</span> (ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255" title="Validate the ctx.">validate</a>(ctx) == 0) {
<a name="l00718"></a>00718                 req_off_ctx_list(req, ctx);
<a name="l00719"></a>00719                 RETURN(0);
<a name="l00720"></a>00720         }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722         <span class="keywordflow">if</span> (unlikely(test_bit(PTLRPC_CTX_ERROR_BIT, &amp;ctx-&gt;cc_flags))) {
<a name="l00723"></a>00723                 spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00724"></a>00724                 req-&gt;rq_err = 1;
<a name="l00725"></a>00725                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00726"></a>00726                 req_off_ctx_list(req, ctx);
<a name="l00727"></a>00727                 RETURN(-EPERM);
<a name="l00728"></a>00728         }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="comment">/*</span>
<a name="l00731"></a>00731 <span class="comment">         * There&apos;s a subtle issue for resending RPCs, suppose following</span>
<a name="l00732"></a>00732 <span class="comment">         * situation:</span>
<a name="l00733"></a>00733 <span class="comment">         *  1. the request was sent to server.</span>
<a name="l00734"></a>00734 <span class="comment">         *  2. recovery was kicked start, after finished the request was</span>
<a name="l00735"></a>00735 <span class="comment">         *     marked as resent.</span>
<a name="l00736"></a>00736 <span class="comment">         *  3. resend the request.</span>
<a name="l00737"></a>00737 <span class="comment">         *  4. old reply from server received, we accept and verify the reply.</span>
<a name="l00738"></a>00738 <span class="comment">         *     this has to be success, otherwise the error will be aware</span>
<a name="l00739"></a>00739 <span class="comment">         *     by application.</span>
<a name="l00740"></a>00740 <span class="comment">         *  5. new reply from server received, dropped by LNet.</span>
<a name="l00741"></a>00741 <span class="comment">         *</span>
<a name="l00742"></a>00742 <span class="comment">         * Note the xid of old &amp; new request is the same. We can&apos;t simply</span>
<a name="l00743"></a>00743 <span class="comment">         * change xid for the resent request because the server replies on</span>
<a name="l00744"></a>00744 <span class="comment">         * it for reply reconstruction.</span>
<a name="l00745"></a>00745 <span class="comment">         *</span>
<a name="l00746"></a>00746 <span class="comment">         * Commonly the original context should be uptodate because we</span>
<a name="l00747"></a>00747 <span class="comment">         * have an expiry nice time; server will keep its context because</span>
<a name="l00748"></a>00748 <span class="comment">         * we at least hold a ref of old context which prevent context</span>
<a name="l00749"></a>00749 <span class="comment">         * from destroying RPC being sent. So server still can accept the</span>
<a name="l00750"></a>00750 <span class="comment">         * request and finish the RPC. But if that&apos;s not the case:</span>
<a name="l00751"></a>00751 <span class="comment">         *  1. If server side context has been trimmed, a NO_CONTEXT will</span>
<a name="l00752"></a>00752 <span class="comment">         *     be returned, gss_cli_ctx_verify/unseal will switch to new</span>
<a name="l00753"></a>00753 <span class="comment">         *     context by force.</span>
<a name="l00754"></a>00754 <span class="comment">         *  2. Current context never be refreshed, then we are fine: we</span>
<a name="l00755"></a>00755 <span class="comment">         *     never really send request with old context before.</span>
<a name="l00756"></a>00756 <span class="comment">         */</span>
<a name="l00757"></a>00757         <span class="keywordflow">if</span> (test_bit(PTLRPC_CTX_UPTODATE_BIT, &amp;ctx-&gt;cc_flags) &amp;&amp;
<a name="l00758"></a>00758             unlikely(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp;&amp;
<a name="l00759"></a>00759             lustre_msg_get_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; MSG_RESENT) {
<a name="l00760"></a>00760                 req_off_ctx_list(req, ctx);
<a name="l00761"></a>00761                 RETURN(0);
<a name="l00762"></a>00762         }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764         <span class="keywordflow">if</span> (unlikely(test_bit(PTLRPC_CTX_DEAD_BIT, &amp;ctx-&gt;cc_flags))) {
<a name="l00765"></a>00765                 req_off_ctx_list(req, ctx);
<a name="l00766"></a>00766                 <span class="comment">/*</span>
<a name="l00767"></a>00767 <span class="comment">                 * don&apos;t switch ctx if import was deactivated</span>
<a name="l00768"></a>00768 <span class="comment">                 */</span>
<a name="l00769"></a>00769                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>-&gt;imp_deactive) {
<a name="l00770"></a>00770                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00771"></a>00771                         req-&gt;rq_err = 1;
<a name="l00772"></a>00772                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00773"></a>00773                         RETURN(-EINTR);
<a name="l00774"></a>00774                 }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776                 rc = <a class="code" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g.">sptlrpc_req_replace_dead_ctx</a>(req);
<a name="l00777"></a>00777                 <span class="keywordflow">if</span> (rc) {
<a name="l00778"></a>00778                         LASSERT(ctx == req-&gt;rq_cli_ctx);
<a name="l00779"></a>00779                         CERROR(<span class="stringliteral">&quot;req %p: failed to replace dead ctx %p: %d\n&quot;</span>,
<a name="l00780"></a>00780                                req, ctx, rc);
<a name="l00781"></a>00781                         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00782"></a>00782                         req-&gt;rq_err = 1;
<a name="l00783"></a>00783                         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00784"></a>00784                         RETURN(rc);
<a name="l00785"></a>00785                 }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787                 ctx = req-&gt;rq_cli_ctx;
<a name="l00788"></a>00788                 <span class="keywordflow">goto</span> again;
<a name="l00789"></a>00789         }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791         <span class="comment">/*</span>
<a name="l00792"></a>00792 <span class="comment">         * Now we&apos;re sure this context is during upcall, add myself into</span>
<a name="l00793"></a>00793 <span class="comment">         * waiting list</span>
<a name="l00794"></a>00794 <span class="comment">         */</span>
<a name="l00795"></a>00795         spin_lock(&amp;ctx-&gt;cc_lock);
<a name="l00796"></a>00796         <span class="keywordflow">if</span> (list_empty(&amp;req-&gt;rq_ctx_chain))
<a name="l00797"></a>00797                 list_add(&amp;req-&gt;rq_ctx_chain, &amp;ctx-&gt;cc_req_list);
<a name="l00798"></a>00798         spin_unlock(&amp;ctx-&gt;cc_lock);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800         <span class="keywordflow">if</span> (timeout &lt; 0)
<a name="l00801"></a>00801                 RETURN(-EWOULDBLOCK);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         <span class="comment">/* Clear any flags that may be present from previous sends */</span>
<a name="l00804"></a>00804         LASSERT(req-&gt;rq_receiving_reply == 0);
<a name="l00805"></a>00805         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00806"></a>00806         req-&gt;rq_err = 0;
<a name="l00807"></a>00807         req-&gt;rq_timedout = 0;
<a name="l00808"></a>00808         req-&gt;rq_resend = 0;
<a name="l00809"></a>00809         req-&gt;rq_restart = 0;
<a name="l00810"></a>00810         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812         lwi = LWI_TIMEOUT_INTR(msecs_to_jiffies(timeout * MSEC_PER_SEC),
<a name="l00813"></a>00813                                ctx_refresh_timeout,
<a name="l00814"></a>00814                                ctx_refresh_interrupt, req);
<a name="l00815"></a>00815         rc = l_wait_event(req-&gt;rq_reply_waitq, ctx_check_refresh(ctx), &amp;lwi);
<a name="l00816"></a>00816 
<a name="l00817"></a>00817         <span class="comment">/*</span>
<a name="l00818"></a>00818 <span class="comment">         * following cases could lead us here:</span>
<a name="l00819"></a>00819 <span class="comment">         * - successfully refreshed;</span>
<a name="l00820"></a>00820 <span class="comment">         * - interrupted;</span>
<a name="l00821"></a>00821 <span class="comment">         * - timedout, and we don&apos;t want recover from the failure;</span>
<a name="l00822"></a>00822 <span class="comment">         * - timedout, and waked up upon recovery finished;</span>
<a name="l00823"></a>00823 <span class="comment">         * - someone else mark this ctx dead by force;</span>
<a name="l00824"></a>00824 <span class="comment">         * - someone invalidate the req and call ptlrpc_client_wake_req(),</span>
<a name="l00825"></a>00825 <span class="comment">         *   e.g. ptlrpc_abort_inflight();</span>
<a name="l00826"></a>00826 <span class="comment">         */</span>
<a name="l00827"></a>00827         <span class="keywordflow">if</span> (!cli_ctx_is_refreshed(ctx)) {
<a name="l00828"></a>00828                 <span class="comment">/* timed out or interruptted */</span>
<a name="l00829"></a>00829                 req_off_ctx_list(req, ctx);
<a name="l00830"></a>00830 
<a name="l00831"></a>00831                 LASSERT(rc != 0);
<a name="l00832"></a>00832                 RETURN(rc);
<a name="l00833"></a>00833         }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835         <span class="keywordflow">goto</span> again;
<a name="l00836"></a>00836 }
<a name="l00837"></a>00837 
<a name="l00845"></a><a class="code" href="group__sptlrpc.html#ga701bf20eebf0fd9d03c94918418f3b31">00845</a> <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga701bf20eebf0fd9d03c94918418f3b31" title="Initialize flavor settings for req, according to opcode.">sptlrpc_req_set_flavor</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> opcode)
<a name="l00846"></a>00846 {
<a name="l00847"></a>00847         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec;
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a>);
<a name="l00850"></a>00850         LASSERT(req-&gt;rq_cli_ctx);
<a name="l00851"></a>00851         LASSERT(req-&gt;rq_cli_ctx-&gt;cc_sec);
<a name="l00852"></a>00852         LASSERT(req-&gt;rq_bulk_read == 0 || req-&gt;rq_bulk_write == 0);
<a name="l00853"></a>00853 
<a name="l00854"></a>00854         <span class="comment">/* special security flags accoding to opcode */</span>
<a name="l00855"></a>00855         <span class="keywordflow">switch</span> (opcode) {
<a name="l00856"></a>00856         <span class="keywordflow">case</span> OST_READ:
<a name="l00857"></a>00857         <span class="keywordflow">case</span> MDS_READPAGE:
<a name="l00858"></a>00858         <span class="keywordflow">case</span> MGS_CONFIG_READ:
<a name="l00859"></a>00859         <span class="keywordflow">case</span> OBD_IDX_READ:
<a name="l00860"></a>00860                 req-&gt;rq_bulk_read = 1;
<a name="l00861"></a>00861                 <span class="keywordflow">break</span>;
<a name="l00862"></a>00862         <span class="keywordflow">case</span> OST_WRITE:
<a name="l00863"></a>00863         <span class="keywordflow">case</span> MDS_WRITEPAGE:
<a name="l00864"></a>00864                 req-&gt;rq_bulk_write = 1;
<a name="l00865"></a>00865                 <span class="keywordflow">break</span>;
<a name="l00866"></a>00866         <span class="keywordflow">case</span> SEC_CTX_INIT:
<a name="l00867"></a>00867                 req-&gt;rq_ctx_init = 1;
<a name="l00868"></a>00868                 <span class="keywordflow">break</span>;
<a name="l00869"></a>00869         <span class="keywordflow">case</span> SEC_CTX_FINI:
<a name="l00870"></a>00870                 req-&gt;rq_ctx_fini = 1;
<a name="l00871"></a>00871                 <span class="keywordflow">break</span>;
<a name="l00872"></a>00872         <span class="keywordflow">case</span> 0:
<a name="l00873"></a>00873                 <span class="comment">/* init/fini rpc won&apos;t be resend, so can&apos;t be here */</span>
<a name="l00874"></a>00874                 LASSERT(req-&gt;rq_ctx_init == 0);
<a name="l00875"></a>00875                 LASSERT(req-&gt;rq_ctx_fini == 0);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877                 <span class="comment">/* cleanup flags, which should be recalculated */</span>
<a name="l00878"></a>00878                 req-&gt;rq_pack_udesc = 0;
<a name="l00879"></a>00879                 req-&gt;rq_pack_bulk = 0;
<a name="l00880"></a>00880                 <span class="keywordflow">break</span>;
<a name="l00881"></a>00881         }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883         sec = req-&gt;rq_cli_ctx-&gt;cc_sec;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885         spin_lock(&amp;sec-&gt;ps_lock);
<a name="l00886"></a>00886         req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a> = sec-&gt;ps_flvr;
<a name="l00887"></a>00887         spin_unlock(&amp;sec-&gt;ps_lock);
<a name="l00888"></a>00888 
<a name="l00889"></a>00889         <span class="comment">/* force SVC_NULL for context initiation rpc, SVC_INTG for context</span>
<a name="l00890"></a>00890 <span class="comment">         * destruction rpc */</span>
<a name="l00891"></a>00891         <span class="keywordflow">if</span> (unlikely(req-&gt;rq_ctx_init))
<a name="l00892"></a>00892                 flvr_set_svc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa9962cb9ccc8b90b4c67ada0e7b00210b" title="no security">SPTLRPC_SVC_NULL</a>);
<a name="l00893"></a>00893         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (unlikely(req-&gt;rq_ctx_fini))
<a name="l00894"></a>00894                 flvr_set_svc(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa74b1cc494dcf8dbf001b3a19e8790fd9" title="integrity">SPTLRPC_SVC_INTG</a>);
<a name="l00895"></a>00895 
<a name="l00896"></a>00896         <span class="comment">/* user descriptor flag, null security can&apos;t do it anyway */</span>
<a name="l00897"></a>00897         <span class="keywordflow">if</span> ((sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> &amp; PTLRPC_SEC_FL_UDESC) &amp;&amp;
<a name="l00898"></a>00898             (req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a> != SPTLRPC_FLVR_NULL))
<a name="l00899"></a>00899                 req-&gt;rq_pack_udesc = 1;
<a name="l00900"></a>00900 
<a name="l00901"></a>00901         <span class="comment">/* bulk security flag */</span>
<a name="l00902"></a>00902         <span class="keywordflow">if</span> ((req-&gt;rq_bulk_read || req-&gt;rq_bulk_write) &amp;&amp;
<a name="l00903"></a>00903             sptlrpc_flavor_has_bulk(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>))
<a name="l00904"></a>00904                 req-&gt;rq_pack_bulk = 1;
<a name="l00905"></a>00905 }
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="keywordtype">void</span> sptlrpc_request_out_callback(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00908"></a>00908 {
<a name="l00909"></a>00909         <span class="keywordflow">if</span> (SPTLRPC_FLVR_SVC(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) != <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa1baf868991ad935c71ceb65c53389564" title="privacy">SPTLRPC_SVC_PRIV</a>)
<a name="l00910"></a>00910                 <span class="keywordflow">return</span>;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d" title="only in priv mode">rq_clrbuf</a>);
<a name="l00913"></a>00913         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a> || !req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>)
<a name="l00914"></a>00914                 <span class="keywordflow">return</span>;
<a name="l00915"></a>00915 
<a name="l00916"></a>00916         OBD_FREE(req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>, req-&gt;rq_reqbuf_len);
<a name="l00917"></a>00917         req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> = NULL;
<a name="l00918"></a>00918         req-&gt;rq_reqbuf_len = 0;
<a name="l00919"></a>00919 }
<a name="l00920"></a>00920 
<a name="l00926"></a><a class="code" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5">00926</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gaa43ec50fcb7c93e96d80c8b544da92a5" title="Given an import imp, check whether current user has a valid context or not.">sptlrpc_import_check_ctx</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l00927"></a>00927 {
<a name="l00928"></a>00928         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>     *sec;
<a name="l00929"></a>00929         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx;
<a name="l00930"></a>00930         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = NULL;
<a name="l00931"></a>00931         <span class="keywordtype">int</span> rc;
<a name="l00932"></a>00932         ENTRY;
<a name="l00933"></a>00933 
<a name="l00934"></a>00934         might_sleep();
<a name="l00935"></a>00935 
<a name="l00936"></a>00936         sec = sptlrpc_import_sec_ref(imp);
<a name="l00937"></a>00937         ctx = get_my_ctx(sec);
<a name="l00938"></a>00938         sptlrpc_sec_put(sec);
<a name="l00939"></a>00939 
<a name="l00940"></a>00940         <span class="keywordflow">if</span> (!ctx)
<a name="l00941"></a>00941                 RETURN(-ENOMEM);
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <span class="keywordflow">if</span> (cli_ctx_is_eternal(ctx) ||
<a name="l00944"></a>00944             ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#aeb5726f0e6c01064d509932276136255" title="Validate the ctx.">validate</a>(ctx) == 0) {
<a name="l00945"></a>00945                 sptlrpc_cli_ctx_put(ctx, 1);
<a name="l00946"></a>00946                 RETURN(0);
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         <span class="keywordflow">if</span> (cli_ctx_is_error(ctx)) {
<a name="l00950"></a>00950                 sptlrpc_cli_ctx_put(ctx, 1);
<a name="l00951"></a>00951                 RETURN(-EACCES);
<a name="l00952"></a>00952         }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         req = ptlrpc_request_cache_alloc(GFP_NOFS);
<a name="l00955"></a>00955         <span class="keywordflow">if</span> (!req)
<a name="l00956"></a>00956                 RETURN(-ENOMEM);
<a name="l00957"></a>00957 
<a name="l00958"></a>00958         ptlrpc_cli_req_init(req);
<a name="l00959"></a>00959         atomic_set(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>, 10000);
<a name="l00960"></a>00960 
<a name="l00961"></a>00961         req-&gt;<a class="code" href="structptlrpc__request.html#abce7bb8e7fff373286d1f69a0175dba8" title="import where request is being sent">rq_import</a> = imp;
<a name="l00962"></a>00962         req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a> = sec-&gt;ps_flvr;
<a name="l00963"></a>00963         req-&gt;rq_cli_ctx = ctx;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965         rc = <a class="code" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&amp;#39;s not up-to-date.">sptlrpc_req_refresh_ctx</a>(req, 0);
<a name="l00966"></a>00966         LASSERT(list_empty(&amp;req-&gt;rq_ctx_chain));
<a name="l00967"></a>00967         sptlrpc_cli_ctx_put(req-&gt;rq_cli_ctx, 1);
<a name="l00968"></a>00968         ptlrpc_request_cache_free(req);
<a name="l00969"></a>00969 
<a name="l00970"></a>00970         RETURN(rc);
<a name="l00971"></a>00971 }
<a name="l00972"></a>00972 
<a name="l00978"></a><a class="code" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2">00978</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre-defined security transformation upon the...">sptlrpc_cli_wrap_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00979"></a>00979 {
<a name="l00980"></a>00980         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l00981"></a>00981         <span class="keywordtype">int</span> rc = 0;
<a name="l00982"></a>00982         ENTRY;
<a name="l00983"></a>00983 
<a name="l00984"></a>00984         LASSERT(ctx);
<a name="l00985"></a>00985         LASSERT(ctx-&gt;cc_sec);
<a name="l00986"></a>00986         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> || req-&gt;<a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d" title="only in priv mode">rq_clrbuf</a>);
<a name="l00987"></a>00987 
<a name="l00988"></a>00988         <span class="comment">/* we wrap bulk request here because now we can be sure</span>
<a name="l00989"></a>00989 <span class="comment">         * the context is uptodate.</span>
<a name="l00990"></a>00990 <span class="comment">         */</span>
<a name="l00991"></a>00991         <span class="keywordflow">if</span> (req-&gt;rq_bulk) {
<a name="l00992"></a>00992                 rc = <a class="code" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc.">sptlrpc_cli_wrap_bulk</a>(req, req-&gt;rq_bulk);
<a name="l00993"></a>00993                 <span class="keywordflow">if</span> (rc)
<a name="l00994"></a>00994                         RETURN(rc);
<a name="l00995"></a>00995         }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997         <span class="keywordflow">switch</span> (SPTLRPC_FLVR_SVC(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>)) {
<a name="l00998"></a>00998         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa9962cb9ccc8b90b4c67ada0e7b00210b" title="no security">SPTLRPC_SVC_NULL</a>:
<a name="l00999"></a>00999         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa691acc99dba7191db4f6c2e177331e30" title="authentication only">SPTLRPC_SVC_AUTH</a>:
<a name="l01000"></a>01000         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa74b1cc494dcf8dbf001b3a19e8790fd9" title="integrity">SPTLRPC_SVC_INTG</a>:
<a name="l01001"></a>01001                 LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a56a7044b0eb1b542f387d61fb0f2c2c9" title="Sign the request message using ctx.">sign</a>);
<a name="l01002"></a>01002                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a56a7044b0eb1b542f387d61fb0f2c2c9" title="Sign the request message using ctx.">sign</a>(ctx, req);
<a name="l01003"></a>01003                 <span class="keywordflow">break</span>;
<a name="l01004"></a>01004         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa1baf868991ad935c71ceb65c53389564" title="privacy">SPTLRPC_SVC_PRIV</a>:
<a name="l01005"></a>01005                 LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a21b8b702790d8794111c70b0d81529dc" title="Encrypt the request message using ctx.">seal</a>);
<a name="l01006"></a>01006                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a21b8b702790d8794111c70b0d81529dc" title="Encrypt the request message using ctx.">seal</a>(ctx, req);
<a name="l01007"></a>01007                 <span class="keywordflow">break</span>;
<a name="l01008"></a>01008         <span class="keywordflow">default</span>:
<a name="l01009"></a>01009                 LBUG();
<a name="l01010"></a>01010         }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01013"></a>01013                 LASSERT(req-&gt;rq_reqdata_len);
<a name="l01014"></a>01014                 LASSERT(req-&gt;rq_reqdata_len % 8 == 0);
<a name="l01015"></a>01015                 LASSERT(req-&gt;rq_reqdata_len &lt;= req-&gt;rq_reqbuf_len);
<a name="l01016"></a>01016         }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018         RETURN(rc);
<a name="l01019"></a>01019 }
<a name="l01020"></a>01020 
<a name="l01021"></a>01021 <span class="keyword">static</span> <span class="keywordtype">int</span> do_cli_unwrap_reply(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01022"></a>01022 {
<a name="l01023"></a>01023         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l01024"></a>01024         <span class="keywordtype">int</span>                    rc;
<a name="l01025"></a>01025         ENTRY;
<a name="l01026"></a>01026 
<a name="l01027"></a>01027         LASSERT(ctx);
<a name="l01028"></a>01028         LASSERT(ctx-&gt;cc_sec);
<a name="l01029"></a>01029         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>);
<a name="l01030"></a>01030         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a>);
<a name="l01031"></a>01031         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> == NULL);
<a name="l01032"></a>01032 
<a name="l01033"></a>01033         req-&gt;rq_rep_swab_mask = 0;
<a name="l01034"></a>01034 
<a name="l01035"></a>01035         rc = __lustre_unpack_msg(req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a>, req-&gt;rq_repdata_len);
<a name="l01036"></a>01036         <span class="keywordflow">switch</span> (rc) {
<a name="l01037"></a>01037         <span class="keywordflow">case</span> 1:
<a name="l01038"></a>01038                 lustre_set_rep_swabbed(req, <a class="code" href="group__lustreidl.html#gafa5c71e7497acfe5dea4f5efd14ef8ec" title="only use in req-&amp;gt;rq_{req,rep}_swab_mask">MSG_PTLRPC_HEADER_OFF</a>);
<a name="l01039"></a>01039         <span class="keywordflow">case</span> 0:
<a name="l01040"></a>01040                 <span class="keywordflow">break</span>;
<a name="l01041"></a>01041         <span class="keywordflow">default</span>:
<a name="l01042"></a>01042                 CERROR(<span class="stringliteral">&quot;failed unpack reply: x&quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l01043"></a>01043                 RETURN(-EPROTO);
<a name="l01044"></a>01044         }
<a name="l01045"></a>01045 
<a name="l01046"></a>01046         <span class="keywordflow">if</span> (req-&gt;rq_repdata_len &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> lustre_msg)) {
<a name="l01047"></a>01047                 CERROR(<span class="stringliteral">&quot;replied data length %d too small\n&quot;</span>,
<a name="l01048"></a>01048                        req-&gt;rq_repdata_len);
<a name="l01049"></a>01049                 RETURN(-EPROTO);
<a name="l01050"></a>01050         }
<a name="l01051"></a>01051 
<a name="l01052"></a>01052         <span class="keywordflow">if</span> (SPTLRPC_FLVR_POLICY(req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a>-&gt;lm_secflvr) !=
<a name="l01053"></a>01053             SPTLRPC_FLVR_POLICY(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>)) {
<a name="l01054"></a>01054                 CERROR(<span class="stringliteral">&quot;reply policy %u doesn&apos;t match request policy %u\n&quot;</span>,
<a name="l01055"></a>01055                        SPTLRPC_FLVR_POLICY(req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a>-&gt;lm_secflvr),
<a name="l01056"></a>01056                        SPTLRPC_FLVR_POLICY(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>));
<a name="l01057"></a>01057                 RETURN(-EPROTO);
<a name="l01058"></a>01058         }
<a name="l01059"></a>01059 
<a name="l01060"></a>01060         <span class="keywordflow">switch</span> (SPTLRPC_FLVR_SVC(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>)) {
<a name="l01061"></a>01061         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa9962cb9ccc8b90b4c67ada0e7b00210b" title="no security">SPTLRPC_SVC_NULL</a>:
<a name="l01062"></a>01062         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa691acc99dba7191db4f6c2e177331e30" title="authentication only">SPTLRPC_SVC_AUTH</a>:
<a name="l01063"></a>01063         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa74b1cc494dcf8dbf001b3a19e8790fd9" title="integrity">SPTLRPC_SVC_INTG</a>:
<a name="l01064"></a>01064                 LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#af81c94560ecbdcb48151bd89767d9f75" title="Verify the reply message using ctx.">verify</a>);
<a name="l01065"></a>01065                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#af81c94560ecbdcb48151bd89767d9f75" title="Verify the reply message using ctx.">verify</a>(ctx, req);
<a name="l01066"></a>01066                 <span class="keywordflow">break</span>;
<a name="l01067"></a>01067         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#ggab48fb51b4fb60d481bc12e344e73df3aa1baf868991ad935c71ceb65c53389564" title="privacy">SPTLRPC_SVC_PRIV</a>:
<a name="l01068"></a>01068                 LASSERT(ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#adfd6f5c19365d9e9d49f6e52ca55be61" title="Decrypt the reply message using ctx.">unseal</a>);
<a name="l01069"></a>01069                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#adfd6f5c19365d9e9d49f6e52ca55be61" title="Decrypt the reply message using ctx.">unseal</a>(ctx, req);
<a name="l01070"></a>01070                 <span class="keywordflow">break</span>;
<a name="l01071"></a>01071         <span class="keywordflow">default</span>:
<a name="l01072"></a>01072                 LBUG();
<a name="l01073"></a>01073         }
<a name="l01074"></a>01074         LASSERT(rc || req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> || req-&gt;rq_resend);
<a name="l01075"></a>01075 
<a name="l01076"></a>01076         <span class="keywordflow">if</span> (SPTLRPC_FLVR_POLICY(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) != SPTLRPC_POLICY_NULL &amp;&amp;
<a name="l01077"></a>01077             !req-&gt;rq_ctx_init)
<a name="l01078"></a>01078                 req-&gt;rq_rep_swab_mask = 0;
<a name="l01079"></a>01079         RETURN(rc);
<a name="l01080"></a>01080 }
<a name="l01081"></a>01081 
<a name="l01090"></a><a class="code" href="group__sptlrpc.html#ga4e652d7f03a8727b8eb9c290936aec23">01090</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga4e652d7f03a8727b8eb9c290936aec23" title="Used by ptlrpc client, to perform security transformation upon the reply message...">sptlrpc_cli_unwrap_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01091"></a>01091 {
<a name="l01092"></a>01092         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>);
<a name="l01093"></a>01093         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> == NULL);
<a name="l01094"></a>01094         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> == NULL);
<a name="l01095"></a>01095         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a> + req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a> &lt;= req-&gt;rq_repbuf_len);
<a name="l01096"></a>01096 
<a name="l01097"></a>01097         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a> == 0 &amp;&amp;
<a name="l01098"></a>01098             (lustre_msghdr_get_flags(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; MSGHDR_AT_SUPPORT)) {
<a name="l01099"></a>01099                 CERROR(<span class="stringliteral">&quot;real reply with offset 0\n&quot;</span>);
<a name="l01100"></a>01100                 <span class="keywordflow">return</span> -EPROTO;
<a name="l01101"></a>01101         }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a> % 8 != 0) {
<a name="l01104"></a>01104                 CERROR(<span class="stringliteral">&quot;reply at odd offset %u\n&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a>);
<a name="l01105"></a>01105                 <span class="keywordflow">return</span> -EPROTO;
<a name="l01106"></a>01106         }
<a name="l01107"></a>01107 
<a name="l01108"></a>01108         req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> = (<span class="keyword">struct </span>lustre_msg *)
<a name="l01109"></a>01109                                 (req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a> + req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a>);
<a name="l01110"></a>01110         req-&gt;rq_repdata_len = req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>;
<a name="l01111"></a>01111 
<a name="l01112"></a>01112         <span class="keywordflow">return</span> do_cli_unwrap_reply(req);
<a name="l01113"></a>01113 }
<a name="l01114"></a>01114 
<a name="l01130"></a><a class="code" href="group__sptlrpc.html#ga555969de6cd1c126c5a8887b740e1354">01130</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga555969de6cd1c126c5a8887b740e1354" title="Used by ptlrpc client, to perform security transformation upon the early reply message...">sptlrpc_cli_unwrap_early_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01131"></a>01131                                    <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> **req_ret)
<a name="l01132"></a>01132 {
<a name="l01133"></a>01133         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>  *early_req;
<a name="l01134"></a>01134         <span class="keywordtype">char</span>                   *early_buf;
<a name="l01135"></a>01135         <span class="keywordtype">int</span>                     early_bufsz, early_size;
<a name="l01136"></a>01136         <span class="keywordtype">int</span>                     rc;
<a name="l01137"></a>01137         ENTRY;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         early_req = ptlrpc_request_cache_alloc(GFP_NOFS);
<a name="l01140"></a>01140         <span class="keywordflow">if</span> (early_req == NULL)
<a name="l01141"></a>01141                 RETURN(-ENOMEM);
<a name="l01142"></a>01142 
<a name="l01143"></a>01143         ptlrpc_cli_req_init(early_req);
<a name="l01144"></a>01144 
<a name="l01145"></a>01145         early_size = req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>;
<a name="l01146"></a>01146         early_bufsz = size_roundup_power2(early_size);
<a name="l01147"></a>01147         OBD_ALLOC_LARGE(early_buf, early_bufsz);
<a name="l01148"></a>01148         <span class="keywordflow">if</span> (early_buf == NULL)
<a name="l01149"></a>01149                 GOTO(err_req, rc = -ENOMEM);
<a name="l01150"></a>01150 
<a name="l01151"></a>01151         <span class="comment">/* sanity checkings and copy data out, do it inside spinlock */</span>
<a name="l01152"></a>01152         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01153"></a>01153 
<a name="l01154"></a>01154         <span class="keywordflow">if</span> (req-&gt;rq_replied) {
<a name="l01155"></a>01155                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01156"></a>01156                 GOTO(err_buf, rc = -EALREADY);
<a name="l01157"></a>01157         }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>);
<a name="l01160"></a>01160         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> == NULL);
<a name="l01161"></a>01161         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> == NULL);
<a name="l01162"></a>01162 
<a name="l01163"></a>01163         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a> != 0) {
<a name="l01164"></a>01164                 CERROR(<span class="stringliteral">&quot;early reply with offset %u\n&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#a5863dba869cc1fe8c8fe2455a1223ec1" title="early replies go to offset 0, regular replies go after that">rq_reply_off</a>);
<a name="l01165"></a>01165                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01166"></a>01166                 GOTO(err_buf, rc = -EPROTO);
<a name="l01167"></a>01167         }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a> != early_size) {
<a name="l01170"></a>01170                 <span class="comment">/* even another early arrived the size should be the same */</span>
<a name="l01171"></a>01171                 CERROR(<span class="stringliteral">&quot;data size has changed from %u to %u\n&quot;</span>,
<a name="l01172"></a>01172                        early_size, req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>);
<a name="l01173"></a>01173                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01174"></a>01174                 GOTO(err_buf, rc = -EINVAL);
<a name="l01175"></a>01175         }
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a> &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> lustre_msg)) {
<a name="l01178"></a>01178                 CERROR(<span class="stringliteral">&quot;early reply length %d too small\n&quot;</span>,
<a name="l01179"></a>01179                        req-&gt;<a class="code" href="structptlrpc__request.html#ac1b316efab18615c59503ece32329e2a" title="client-side: !rq_truncate : # reply bytes actually received, rq_truncate : required...">rq_nob_received</a>);
<a name="l01180"></a>01180                 spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01181"></a>01181                 GOTO(err_buf, rc = -EALREADY);
<a name="l01182"></a>01182         }
<a name="l01183"></a>01183 
<a name="l01184"></a>01184         memcpy(early_buf, req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>, early_size);
<a name="l01185"></a>01185         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01186"></a>01186 
<a name="l01187"></a>01187         early_req-&gt;rq_cli_ctx = sptlrpc_cli_ctx_get(req-&gt;rq_cli_ctx);
<a name="l01188"></a>01188         early_req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a> = req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>;
<a name="l01189"></a>01189         early_req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a> = early_buf;
<a name="l01190"></a>01190         early_req-&gt;rq_repbuf_len = early_bufsz;
<a name="l01191"></a>01191         early_req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a> = (<span class="keyword">struct </span>lustre_msg *) early_buf;
<a name="l01192"></a>01192         early_req-&gt;rq_repdata_len = early_size;
<a name="l01193"></a>01193         early_req-&gt;rq_early = 1;
<a name="l01194"></a>01194         early_req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> = req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>;
<a name="l01195"></a>01195 
<a name="l01196"></a>01196         rc = do_cli_unwrap_reply(early_req);
<a name="l01197"></a>01197         <span class="keywordflow">if</span> (rc) {
<a name="l01198"></a>01198                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a>, early_req,
<a name="l01199"></a>01199                           <span class="stringliteral">&quot;error %d unwrap early reply&quot;</span>, rc);
<a name="l01200"></a>01200                 GOTO(err_ctx, rc);
<a name="l01201"></a>01201         }
<a name="l01202"></a>01202 
<a name="l01203"></a>01203         LASSERT(early_req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l01204"></a>01204         *req_ret = early_req;
<a name="l01205"></a>01205         RETURN(0);
<a name="l01206"></a>01206 
<a name="l01207"></a>01207 err_ctx:
<a name="l01208"></a>01208         sptlrpc_cli_ctx_put(early_req-&gt;rq_cli_ctx, 1);
<a name="l01209"></a>01209 err_buf:
<a name="l01210"></a>01210         OBD_FREE_LARGE(early_buf, early_bufsz);
<a name="l01211"></a>01211 err_req:
<a name="l01212"></a>01212         ptlrpc_request_cache_free(early_req);
<a name="l01213"></a>01213         RETURN(rc);
<a name="l01214"></a>01214 }
<a name="l01215"></a>01215 
<a name="l01221"></a><a class="code" href="group__sptlrpc.html#ga9e900c41f0c033d65d6a108d1a1a553c">01221</a> <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga9e900c41f0c033d65d6a108d1a1a553c" title="Used by ptlrpc client, to release a processed early reply early_req.">sptlrpc_cli_finish_early_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *early_req)
<a name="l01222"></a>01222 {
<a name="l01223"></a>01223         LASSERT(early_req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>);
<a name="l01224"></a>01224         LASSERT(early_req-&gt;<a class="code" href="structptlrpc__request.html#a96e6e6bd927aebe9586d64ff54c76ed5" title="rep wrapper msg">rq_repdata</a>);
<a name="l01225"></a>01225         LASSERT(early_req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>);
<a name="l01226"></a>01226 
<a name="l01227"></a>01227         sptlrpc_cli_ctx_put(early_req-&gt;rq_cli_ctx, 1);
<a name="l01228"></a>01228         OBD_FREE_LARGE(early_req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>, early_req-&gt;rq_repbuf_len);
<a name="l01229"></a>01229         ptlrpc_request_cache_free(early_req);
<a name="l01230"></a>01230 }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232 <span class="comment">/**************************************************</span>
<a name="l01233"></a>01233 <span class="comment"> * sec ID                                         *</span>
<a name="l01234"></a>01234 <span class="comment"> **************************************************/</span>
<a name="l01235"></a>01235 
<a name="l01236"></a>01236 <span class="comment">/*</span>
<a name="l01237"></a>01237 <span class="comment"> * &quot;fixed&quot; sec (e.g. null) use sec_id &lt; 0</span>
<a name="l01238"></a>01238 <span class="comment"> */</span>
<a name="l01239"></a>01239 <span class="keyword">static</span> atomic_t sptlrpc_sec_id = ATOMIC_INIT(1);
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="keywordtype">int</span> sptlrpc_get_next_secid(<span class="keywordtype">void</span>)
<a name="l01242"></a>01242 {
<a name="l01243"></a>01243         <span class="keywordflow">return</span> atomic_inc_return(&amp;sptlrpc_sec_id);
<a name="l01244"></a>01244 }
<a name="l01245"></a>01245 EXPORT_SYMBOL(sptlrpc_get_next_secid);
<a name="l01246"></a>01246 
<a name="l01247"></a>01247 <span class="comment">/**************************************************</span>
<a name="l01248"></a>01248 <span class="comment"> * client side high-level security APIs           *</span>
<a name="l01249"></a>01249 <span class="comment"> **************************************************/</span>
<a name="l01250"></a>01250 
<a name="l01251"></a>01251 <span class="keyword">static</span> <span class="keywordtype">int</span> sec_cop_flush_ctx_cache(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec, uid_t uid,
<a name="l01252"></a>01252                                    <span class="keywordtype">int</span> grace, <span class="keywordtype">int</span> force)
<a name="l01253"></a>01253 {
<a name="l01254"></a>01254         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy = sec-&gt;ps_policy;
<a name="l01255"></a>01255 
<a name="l01256"></a>01256         LASSERT(policy-&gt;sp_cops);
<a name="l01257"></a>01257         LASSERT(policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a26e276d2b4143cd7376a9a13b194b51a" title="Flush the context cache.">flush_ctx_cache</a>);
<a name="l01258"></a>01258 
<a name="l01259"></a>01259         <span class="keywordflow">return</span> policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a26e276d2b4143cd7376a9a13b194b51a" title="Flush the context cache.">flush_ctx_cache</a>(sec, uid, grace, force);
<a name="l01260"></a>01260 }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262 <span class="keyword">static</span> <span class="keywordtype">void</span> sec_cop_destroy_sec(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l01263"></a>01263 {
<a name="l01264"></a>01264         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy = sec-&gt;ps_policy;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266         LASSERT_ATOMIC_ZERO(&amp;sec-&gt;ps_refcount);
<a name="l01267"></a>01267         LASSERT_ATOMIC_ZERO(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a9e8ab0f2316d16b984a6452a73df5790" title="statistic only">ps_nctx</a>);
<a name="l01268"></a>01268         LASSERT(policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a53a9874a373d044027d52b2bf118fc00" title="Destructor of ptlrpc_sec.">destroy_sec</a>);
<a name="l01269"></a>01269 
<a name="l01270"></a>01270         CDEBUG(D_SEC, <span class="stringliteral">&quot;%s@%p: being destroied\n&quot;</span>, sec-&gt;ps_policy-&gt;sp_name, sec);
<a name="l01271"></a>01271 
<a name="l01272"></a>01272         policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a53a9874a373d044027d52b2bf118fc00" title="Destructor of ptlrpc_sec.">destroy_sec</a>(sec);
<a name="l01273"></a>01273         sptlrpc_policy_put(policy);
<a name="l01274"></a>01274 }
<a name="l01275"></a>01275 
<a name="l01276"></a>01276 <span class="keywordtype">void</span> sptlrpc_sec_destroy(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l01277"></a>01277 {
<a name="l01278"></a>01278         sec_cop_destroy_sec(sec);
<a name="l01279"></a>01279 }
<a name="l01280"></a>01280 EXPORT_SYMBOL(sptlrpc_sec_destroy);
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 <span class="keyword">static</span> <span class="keywordtype">void</span> sptlrpc_sec_kill(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l01283"></a>01283 {
<a name="l01284"></a>01284         LASSERT_ATOMIC_POS(&amp;sec-&gt;ps_refcount);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286         <span class="keywordflow">if</span> (sec-&gt;ps_policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a08e2b30856f5887883df0abf37c3a5c1" title="Notify that this ptlrpc_sec is going to die.">kill_sec</a>) {
<a name="l01287"></a>01287                 sec-&gt;ps_policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a08e2b30856f5887883df0abf37c3a5c1" title="Notify that this ptlrpc_sec is going to die.">kill_sec</a>(sec);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289                 sec_cop_flush_ctx_cache(sec, -1, 1, 1);
<a name="l01290"></a>01290         }
<a name="l01291"></a>01291 }
<a name="l01292"></a>01292 
<a name="l01293"></a>01293 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sptlrpc_sec_get(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l01294"></a>01294 {
<a name="l01295"></a>01295         <span class="keywordflow">if</span> (sec)
<a name="l01296"></a>01296                 atomic_inc(&amp;sec-&gt;ps_refcount);
<a name="l01297"></a>01297 
<a name="l01298"></a>01298         <span class="keywordflow">return</span> sec;
<a name="l01299"></a>01299 }
<a name="l01300"></a>01300 EXPORT_SYMBOL(sptlrpc_sec_get);
<a name="l01301"></a>01301 
<a name="l01302"></a>01302 <span class="keywordtype">void</span> sptlrpc_sec_put(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l01303"></a>01303 {
<a name="l01304"></a>01304         <span class="keywordflow">if</span> (sec) {
<a name="l01305"></a>01305                 LASSERT_ATOMIC_POS(&amp;sec-&gt;ps_refcount);
<a name="l01306"></a>01306 
<a name="l01307"></a>01307                 <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;sec-&gt;ps_refcount)) {
<a name="l01308"></a>01308                         sptlrpc_gc_del_sec(sec);
<a name="l01309"></a>01309                         sec_cop_destroy_sec(sec);
<a name="l01310"></a>01310                 }
<a name="l01311"></a>01311         }
<a name="l01312"></a>01312 }
<a name="l01313"></a>01313 EXPORT_SYMBOL(sptlrpc_sec_put);
<a name="l01314"></a>01314 
<a name="l01315"></a>01315 <span class="comment">/*</span>
<a name="l01316"></a>01316 <span class="comment"> * policy module is responsible for taking refrence of import</span>
<a name="l01317"></a>01317 <span class="comment"> */</span>
<a name="l01318"></a>01318 <span class="keyword">static</span>
<a name="l01319"></a>01319 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> * sptlrpc_sec_create(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01320"></a>01320                                        <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *svc_ctx,
<a name="l01321"></a>01321                                        <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf,
<a name="l01322"></a>01322                                        <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a> sp)
<a name="l01323"></a>01323 {
<a name="l01324"></a>01324         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l01325"></a>01325         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>        *sec;
<a name="l01326"></a>01326         <span class="keywordtype">char</span>                      str[32];
<a name="l01327"></a>01327         ENTRY;
<a name="l01328"></a>01328 
<a name="l01329"></a>01329         <span class="keywordflow">if</span> (svc_ctx) {
<a name="l01330"></a>01330                 LASSERT(imp-&gt;imp_dlm_fake == 1);
<a name="l01331"></a>01331 
<a name="l01332"></a>01332                 CDEBUG(D_SEC, <span class="stringliteral">&quot;%s %s: reverse sec using flavor %s\n&quot;</span>,
<a name="l01333"></a>01333                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_type-&gt;typ_name,
<a name="l01334"></a>01334                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01335"></a>01335                        sptlrpc_flavor2name(sf, str, <span class="keyword">sizeof</span>(str)));
<a name="l01336"></a>01336 
<a name="l01337"></a>01337                 policy = sptlrpc_policy_get(svc_ctx-&gt;sc_policy);
<a name="l01338"></a>01338                 sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> |= PTLRPC_SEC_FL_REVERSE | PTLRPC_SEC_FL_ROOTONLY;
<a name="l01339"></a>01339         } <span class="keywordflow">else</span> {
<a name="l01340"></a>01340                 LASSERT(imp-&gt;imp_dlm_fake == 0);
<a name="l01341"></a>01341 
<a name="l01342"></a>01342                 CDEBUG(D_SEC, <span class="stringliteral">&quot;%s %s: select security flavor %s\n&quot;</span>,
<a name="l01343"></a>01343                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_type-&gt;typ_name,
<a name="l01344"></a>01344                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01345"></a>01345                        sptlrpc_flavor2name(sf, str, <span class="keyword">sizeof</span>(str)));
<a name="l01346"></a>01346 
<a name="l01347"></a>01347                 policy = sptlrpc_wireflavor2policy(sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01348"></a>01348                 <span class="keywordflow">if</span> (!policy) {
<a name="l01349"></a>01349                         CERROR(<span class="stringliteral">&quot;invalid flavor 0x%x\n&quot;</span>, sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01350"></a>01350                         RETURN(NULL);
<a name="l01351"></a>01351                 }
<a name="l01352"></a>01352         }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354         sec = policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a8bf54ba0627dde53dbce14fd8ddf1808" title="Given an imp, create and initialize a ptlrpc_sec structure.">create_sec</a>(imp, svc_ctx, sf);
<a name="l01355"></a>01355         <span class="keywordflow">if</span> (sec) {
<a name="l01356"></a>01356                 atomic_inc(&amp;sec-&gt;ps_refcount);
<a name="l01357"></a>01357 
<a name="l01358"></a>01358                 sec-&gt;ps_part = sp;
<a name="l01359"></a>01359 
<a name="l01360"></a>01360                 <span class="keywordflow">if</span> (sec-&gt;ps_gc_interval &amp;&amp; policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#ae5fd60f1e3563bd552852ccbc51883d0" title="Called periodically by garbage collector to remove dead contexts from cache.">gc_ctx</a>)
<a name="l01361"></a>01361                         sptlrpc_gc_add_sec(sec);
<a name="l01362"></a>01362         } <span class="keywordflow">else</span> {
<a name="l01363"></a>01363                 sptlrpc_policy_put(policy);
<a name="l01364"></a>01364         }
<a name="l01365"></a>01365 
<a name="l01366"></a>01366         RETURN(sec);
<a name="l01367"></a>01367 }
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sptlrpc_import_sec_ref(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l01370"></a>01370 {
<a name="l01371"></a>01371         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec;
<a name="l01372"></a>01372 
<a name="l01373"></a>01373         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01374"></a>01374         sec = sptlrpc_sec_get(imp-&gt;<a class="code" href="structobd__import.html#aafb0b9080ca250979c2f31495eaf40be" title="some seciruty-related fields">imp_sec</a>);
<a name="l01375"></a>01375         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01376"></a>01376 
<a name="l01377"></a>01377         <span class="keywordflow">return</span> sec;
<a name="l01378"></a>01378 }
<a name="l01379"></a>01379 EXPORT_SYMBOL(sptlrpc_import_sec_ref);
<a name="l01380"></a>01380 
<a name="l01381"></a>01381 <span class="keyword">static</span> <span class="keywordtype">void</span> sptlrpc_import_sec_install(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01382"></a>01382                                        <span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l01383"></a>01383 {
<a name="l01384"></a>01384         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *old_sec;
<a name="l01385"></a>01385 
<a name="l01386"></a>01386         LASSERT_ATOMIC_POS(&amp;sec-&gt;ps_refcount);
<a name="l01387"></a>01387 
<a name="l01388"></a>01388         spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01389"></a>01389         old_sec = imp-&gt;<a class="code" href="structobd__import.html#aafb0b9080ca250979c2f31495eaf40be" title="some seciruty-related fields">imp_sec</a>;
<a name="l01390"></a>01390         imp-&gt;<a class="code" href="structobd__import.html#aafb0b9080ca250979c2f31495eaf40be" title="some seciruty-related fields">imp_sec</a> = sec;
<a name="l01391"></a>01391         spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l01392"></a>01392 
<a name="l01393"></a>01393         <span class="keywordflow">if</span> (old_sec) {
<a name="l01394"></a>01394                 sptlrpc_sec_kill(old_sec);
<a name="l01395"></a>01395 
<a name="l01396"></a>01396                 <span class="comment">/* balance the ref taken by this import */</span>
<a name="l01397"></a>01397                 sptlrpc_sec_put(old_sec);
<a name="l01398"></a>01398         }
<a name="l01399"></a>01399 }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01402"></a>01402 <span class="keywordtype">int</span> flavor_equal(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf1, <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf2)
<a name="l01403"></a>01403 {
<a name="l01404"></a>01404         <span class="keywordflow">return</span> (memcmp(sf1, sf2, <span class="keyword">sizeof</span>(*sf1)) == 0);
<a name="l01405"></a>01405 }
<a name="l01406"></a>01406 
<a name="l01407"></a>01407 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l01408"></a>01408 <span class="keywordtype">void</span> flavor_copy(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *dst, <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *src)
<a name="l01409"></a>01409 {
<a name="l01410"></a>01410         *dst = *src;
<a name="l01411"></a>01411 }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413 <span class="keyword">static</span> <span class="keywordtype">void</span> sptlrpc_import_sec_adapt_inplace(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01414"></a>01414                                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l01415"></a>01415                                              <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf)
<a name="l01416"></a>01416 {
<a name="l01417"></a>01417         <span class="keywordtype">char</span>    str1[32], str2[32];
<a name="l01418"></a>01418 
<a name="l01419"></a>01419         <span class="keywordflow">if</span> (sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> != sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a>)
<a name="l01420"></a>01420                 CDEBUG(D_SEC, <span class="stringliteral">&quot;changing sec flags: %s -&gt; %s\n&quot;</span>,
<a name="l01421"></a>01421                        sptlrpc_secflags2str(sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a>,
<a name="l01422"></a>01422                                             str1, <span class="keyword">sizeof</span>(str1)),
<a name="l01423"></a>01423                        sptlrpc_secflags2str(sf-&gt;<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a>,
<a name="l01424"></a>01424                                             str2, <span class="keyword">sizeof</span>(str2)));
<a name="l01425"></a>01425 
<a name="l01426"></a>01426         spin_lock(&amp;sec-&gt;ps_lock);
<a name="l01427"></a>01427         flavor_copy(&amp;sec-&gt;ps_flvr, sf);
<a name="l01428"></a>01428         spin_unlock(&amp;sec-&gt;ps_lock);
<a name="l01429"></a>01429 }
<a name="l01430"></a>01430 
<a name="l01438"></a><a class="code" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b">01438</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration...">sptlrpc_import_sec_adapt</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01439"></a>01439                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *svc_ctx,
<a name="l01440"></a>01440                              <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *flvr)
<a name="l01441"></a>01441 {
<a name="l01442"></a>01442         <span class="keyword">struct </span><a class="code" href="structptlrpc__connection.html" title="Structure to single define portal connection.">ptlrpc_connection</a>   *conn;
<a name="l01443"></a>01443         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a>       sf;
<a name="l01444"></a>01444         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>          *sec, *newsec;
<a name="l01445"></a>01445         <span class="keyword">enum</span> <a class="code" href="group__sptlrpc.html#gaceeb8c40afd0179b5b42fc19aa58d177" title="identify the RPC is generated from what part of Lustre.">lustre_sec_part</a>        sp;
<a name="l01446"></a>01446         <span class="keywordtype">char</span>                        str[24];
<a name="l01447"></a>01447         <span class="keywordtype">int</span>                         rc = 0;
<a name="l01448"></a>01448         ENTRY;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450         might_sleep();
<a name="l01451"></a>01451 
<a name="l01452"></a>01452         <span class="keywordflow">if</span> (imp == NULL)
<a name="l01453"></a>01453                 RETURN(0);
<a name="l01454"></a>01454 
<a name="l01455"></a>01455         conn = imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>;
<a name="l01456"></a>01456 
<a name="l01457"></a>01457         <span class="keywordflow">if</span> (svc_ctx == NULL) {
<a name="l01458"></a>01458                 <span class="keyword">struct </span><a class="code" href="structclient__obd.html">client_obd</a> *cliobd = &amp;imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;u.cli;
<a name="l01459"></a>01459                 <span class="comment">/*</span>
<a name="l01460"></a>01460 <span class="comment">                 * normal import, determine flavor from rule set, except</span>
<a name="l01461"></a>01461 <span class="comment">                 * for mgc the flavor is predetermined.</span>
<a name="l01462"></a>01462 <span class="comment">                 */</span>
<a name="l01463"></a>01463                 <span class="keywordflow">if</span> (cliobd-&gt;cl_sp_me == LUSTRE_SP_MGC)
<a name="l01464"></a>01464                         sf = cliobd-&gt;cl_flvr_mgc;
<a name="l01465"></a>01465                 <span class="keywordflow">else</span> 
<a name="l01466"></a>01466                         sptlrpc_conf_choose_flavor(cliobd-&gt;cl_sp_me,
<a name="l01467"></a>01467                                                    cliobd-&gt;cl_sp_to,
<a name="l01468"></a>01468                                                    &amp;cliobd-&gt;cl_target_uuid,
<a name="l01469"></a>01469                                                    conn-&gt;<a class="code" href="structptlrpc__connection.html#a002bdb401d67315c931ff672970178b8" title="Our own lnet nid for this connection.">c_self</a>, &amp;sf);
<a name="l01470"></a>01470 
<a name="l01471"></a>01471                 sp = imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;u.cli.cl_sp_me;
<a name="l01472"></a>01472         } <span class="keywordflow">else</span> {
<a name="l01473"></a>01473                 <span class="comment">/* reverse import, determine flavor from incoming reqeust */</span>
<a name="l01474"></a>01474                 sf = *flvr;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476                 <span class="keywordflow">if</span> (sf.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a> != SPTLRPC_FLVR_NULL)
<a name="l01477"></a>01477                         sf.<a class="code" href="structsptlrpc__flavor.html#a36814d7ed6c692c6b796580b06291626" title="general flags of PTLRPC_SEC_FL_*">sf_flags</a> = PTLRPC_SEC_FL_REVERSE |
<a name="l01478"></a>01478                                       PTLRPC_SEC_FL_ROOTONLY;
<a name="l01479"></a>01479 
<a name="l01480"></a>01480                 sp = sptlrpc_target_sec_part(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>);
<a name="l01481"></a>01481         }
<a name="l01482"></a>01482 
<a name="l01483"></a>01483         sec = sptlrpc_import_sec_ref(imp);
<a name="l01484"></a>01484         <span class="keywordflow">if</span> (sec) {
<a name="l01485"></a>01485                 <span class="keywordtype">char</span>    str2[24];
<a name="l01486"></a>01486 
<a name="l01487"></a>01487                 <span class="keywordflow">if</span> (flavor_equal(&amp;sf, &amp;sec-&gt;ps_flvr))
<a name="l01488"></a>01488                         GOTO(out, rc);
<a name="l01489"></a>01489 
<a name="l01490"></a>01490                 CDEBUG(D_SEC, <span class="stringliteral">&quot;import %s-&gt;%s: changing flavor %s -&gt; %s\n&quot;</span>,
<a name="l01491"></a>01491                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01492"></a>01492                        obd_uuid2str(&amp;conn-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>),
<a name="l01493"></a>01493                        sptlrpc_flavor2name(&amp;sec-&gt;ps_flvr, str, <span class="keyword">sizeof</span>(str)),
<a name="l01494"></a>01494                        sptlrpc_flavor2name(&amp;sf, str2, <span class="keyword">sizeof</span>(str2)));
<a name="l01495"></a>01495 
<a name="l01496"></a>01496                 <span class="keywordflow">if</span> (SPTLRPC_FLVR_POLICY(sf.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) ==
<a name="l01497"></a>01497                     SPTLRPC_FLVR_POLICY(sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) &amp;&amp;
<a name="l01498"></a>01498                     SPTLRPC_FLVR_MECH(sf.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) ==
<a name="l01499"></a>01499                     SPTLRPC_FLVR_MECH(sec-&gt;ps_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>)) {
<a name="l01500"></a>01500                         sptlrpc_import_sec_adapt_inplace(imp, sec, &amp;sf);
<a name="l01501"></a>01501                         GOTO(out, rc);
<a name="l01502"></a>01502                 }
<a name="l01503"></a>01503         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SPTLRPC_FLVR_BASE(sf.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) !=
<a name="l01504"></a>01504                    SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_NULL)) {
<a name="l01505"></a>01505                 CDEBUG(D_SEC, <span class="stringliteral">&quot;import %s-&gt;%s netid %x: select flavor %s\n&quot;</span>,
<a name="l01506"></a>01506                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01507"></a>01507                        obd_uuid2str(&amp;conn-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>),
<a name="l01508"></a>01508                        LNET_NIDNET(conn-&gt;<a class="code" href="structptlrpc__connection.html#a002bdb401d67315c931ff672970178b8" title="Our own lnet nid for this connection.">c_self</a>),
<a name="l01509"></a>01509                        sptlrpc_flavor2name(&amp;sf, str, <span class="keyword">sizeof</span>(str)));
<a name="l01510"></a>01510         }
<a name="l01511"></a>01511 
<a name="l01512"></a>01512         mutex_lock(&amp;imp-&gt;imp_sec_mutex);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514         newsec = sptlrpc_sec_create(imp, svc_ctx, &amp;sf, sp);
<a name="l01515"></a>01515         <span class="keywordflow">if</span> (newsec) {
<a name="l01516"></a>01516                 sptlrpc_import_sec_install(imp, newsec);
<a name="l01517"></a>01517         } <span class="keywordflow">else</span> {
<a name="l01518"></a>01518                 CERROR(<span class="stringliteral">&quot;import %s-&gt;%s: failed to create new sec\n&quot;</span>,
<a name="l01519"></a>01519                        imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;obd_name,
<a name="l01520"></a>01520                        obd_uuid2str(&amp;conn-&gt;<a class="code" href="structptlrpc__connection.html#a9060439f5616b4cde3257b28f6f27b30" title="UUID of the other side.">c_remote_uuid</a>));
<a name="l01521"></a>01521                 rc = -EPERM;
<a name="l01522"></a>01522         }
<a name="l01523"></a>01523 
<a name="l01524"></a>01524         mutex_unlock(&amp;imp-&gt;imp_sec_mutex);
<a name="l01525"></a>01525 out:
<a name="l01526"></a>01526         sptlrpc_sec_put(sec);
<a name="l01527"></a>01527         RETURN(rc);
<a name="l01528"></a>01528 }
<a name="l01529"></a>01529 
<a name="l01530"></a>01530 <span class="keywordtype">void</span> sptlrpc_import_sec_put(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l01531"></a>01531 {
<a name="l01532"></a>01532         <span class="keywordflow">if</span> (imp-&gt;<a class="code" href="structobd__import.html#aafb0b9080ca250979c2f31495eaf40be" title="some seciruty-related fields">imp_sec</a>) {
<a name="l01533"></a>01533                 sptlrpc_sec_kill(imp-&gt;<a class="code" href="structobd__import.html#aafb0b9080ca250979c2f31495eaf40be" title="some seciruty-related fields">imp_sec</a>);
<a name="l01534"></a>01534 
<a name="l01535"></a>01535                 sptlrpc_sec_put(imp-&gt;<a class="code" href="structobd__import.html#aafb0b9080ca250979c2f31495eaf40be" title="some seciruty-related fields">imp_sec</a>);
<a name="l01536"></a>01536                 imp-&gt;<a class="code" href="structobd__import.html#aafb0b9080ca250979c2f31495eaf40be" title="some seciruty-related fields">imp_sec</a> = NULL;
<a name="l01537"></a>01537         }
<a name="l01538"></a>01538 }
<a name="l01539"></a>01539 
<a name="l01540"></a>01540 <span class="keyword">static</span> <span class="keywordtype">void</span> import_flush_ctx_common(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01541"></a>01541                                     uid_t uid, <span class="keywordtype">int</span> grace, <span class="keywordtype">int</span> force)
<a name="l01542"></a>01542 {
<a name="l01543"></a>01543         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec;
<a name="l01544"></a>01544 
<a name="l01545"></a>01545         <span class="keywordflow">if</span> (imp == NULL)
<a name="l01546"></a>01546                 <span class="keywordflow">return</span>;
<a name="l01547"></a>01547 
<a name="l01548"></a>01548         sec = sptlrpc_import_sec_ref(imp);
<a name="l01549"></a>01549         <span class="keywordflow">if</span> (sec == NULL)
<a name="l01550"></a>01550                 <span class="keywordflow">return</span>;
<a name="l01551"></a>01551 
<a name="l01552"></a>01552         sec_cop_flush_ctx_cache(sec, uid, grace, force);
<a name="l01553"></a>01553         sptlrpc_sec_put(sec);
<a name="l01554"></a>01554 }
<a name="l01555"></a>01555 
<a name="l01556"></a>01556 <span class="keywordtype">void</span> sptlrpc_import_flush_root_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l01557"></a>01557 {
<a name="l01558"></a>01558         <span class="comment">/* it&apos;s important to use grace mode, see explain in</span>
<a name="l01559"></a>01559 <span class="comment">         * sptlrpc_req_refresh_ctx() */</span>
<a name="l01560"></a>01560         import_flush_ctx_common(imp, 0, 1, 1);
<a name="l01561"></a>01561 }
<a name="l01562"></a>01562 
<a name="l01563"></a>01563 <span class="keywordtype">void</span> sptlrpc_import_flush_my_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l01564"></a>01564 {
<a name="l01565"></a>01565         import_flush_ctx_common(imp, from_kuid(&amp;init_user_ns, current_uid()),
<a name="l01566"></a>01566                                 1, 1);
<a name="l01567"></a>01567 }
<a name="l01568"></a>01568 EXPORT_SYMBOL(sptlrpc_import_flush_my_ctx);
<a name="l01569"></a>01569 
<a name="l01570"></a>01570 <span class="keywordtype">void</span> sptlrpc_import_flush_all_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp)
<a name="l01571"></a>01571 {
<a name="l01572"></a>01572         import_flush_ctx_common(imp, -1, 1, 1);
<a name="l01573"></a>01573 }
<a name="l01574"></a>01574 EXPORT_SYMBOL(sptlrpc_import_flush_all_ctx);
<a name="l01575"></a>01575 
<a name="l01580"></a><a class="code" href="group__sptlrpc.html#gaafb426af1f450b0f25952ba1b38f640d">01580</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gaafb426af1f450b0f25952ba1b38f640d" title="Used by ptlrpc client to allocate request buffer of req.">sptlrpc_cli_alloc_reqbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> msgsize)
<a name="l01581"></a>01581 {
<a name="l01582"></a>01582         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l01583"></a>01583         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l01584"></a>01584         <span class="keywordtype">int</span> rc;
<a name="l01585"></a>01585 
<a name="l01586"></a>01586         LASSERT(ctx);
<a name="l01587"></a>01587         LASSERT(ctx-&gt;cc_sec);
<a name="l01588"></a>01588         LASSERT(ctx-&gt;cc_sec-&gt;ps_policy);
<a name="l01589"></a>01589         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> == NULL);
<a name="l01590"></a>01590         LASSERT_ATOMIC_POS(&amp;ctx-&gt;cc_refcount);
<a name="l01591"></a>01591 
<a name="l01592"></a>01592         policy = ctx-&gt;cc_sec-&gt;ps_policy;
<a name="l01593"></a>01593         rc = policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#aa41ab203ee2687014b25d0876b7427e5" title="To allocate request buffer for req.">alloc_reqbuf</a>(ctx-&gt;cc_sec, req, msgsize);
<a name="l01594"></a>01594         <span class="keywordflow">if</span> (!rc) {
<a name="l01595"></a>01595                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l01596"></a>01596                 LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> || req-&gt;<a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d" title="only in priv mode">rq_clrbuf</a>);
<a name="l01597"></a>01597 
<a name="l01598"></a>01598                 <span class="comment">/* zeroing preallocated buffer */</span>
<a name="l01599"></a>01599                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a2dae5e2bcda80ae75f830e71029f44c4" title="Pool if request is from preallocated list.">rq_pool</a>)
<a name="l01600"></a>01600                         memset(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, 0, msgsize);
<a name="l01601"></a>01601         }
<a name="l01602"></a>01602 
<a name="l01603"></a>01603         <span class="keywordflow">return</span> rc;
<a name="l01604"></a>01604 }
<a name="l01605"></a>01605 
<a name="l01610"></a><a class="code" href="group__sptlrpc.html#ga2f36863ed408b2fc13f7a04eb6280dd4">01610</a> <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga2f36863ed408b2fc13f7a04eb6280dd4" title="Used by ptlrpc client to free request buffer of req.">sptlrpc_cli_free_reqbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01611"></a>01611 {
<a name="l01612"></a>01612         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l01613"></a>01613         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l01614"></a>01614 
<a name="l01615"></a>01615         LASSERT(ctx);
<a name="l01616"></a>01616         LASSERT(ctx-&gt;cc_sec);
<a name="l01617"></a>01617         LASSERT(ctx-&gt;cc_sec-&gt;ps_policy);
<a name="l01618"></a>01618         LASSERT_ATOMIC_POS(&amp;ctx-&gt;cc_refcount);
<a name="l01619"></a>01619 
<a name="l01620"></a>01620         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a> == NULL &amp;&amp; req-&gt;<a class="code" href="structptlrpc__request.html#add50843f7f0c214eefe5d15dd1344d4d" title="only in priv mode">rq_clrbuf</a> == NULL)
<a name="l01621"></a>01621                 <span class="keywordflow">return</span>;
<a name="l01622"></a>01622 
<a name="l01623"></a>01623         policy = ctx-&gt;cc_sec-&gt;ps_policy;
<a name="l01624"></a>01624         policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a1ccde999a88cf1028d6e9f7106c3fdf3" title="To free request buffer for req.">free_reqbuf</a>(ctx-&gt;cc_sec, req);
<a name="l01625"></a>01625         req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> = NULL;
<a name="l01626"></a>01626 }
<a name="l01627"></a>01627 
<a name="l01628"></a>01628 <span class="comment">/*</span>
<a name="l01629"></a>01629 <span class="comment"> * NOTE caller must guarantee the buffer size is enough for the enlargement</span>
<a name="l01630"></a>01630 <span class="comment"> */</span>
<a name="l01631"></a>01631 <span class="keywordtype">void</span> _sptlrpc_enlarge_msg_inplace(<span class="keyword">struct</span> lustre_msg *msg,
<a name="l01632"></a>01632                                   <span class="keywordtype">int</span> segment, <span class="keywordtype">int</span> newsize)
<a name="l01633"></a>01633 {
<a name="l01634"></a>01634         <span class="keywordtype">void</span>   *src, *dst;
<a name="l01635"></a>01635         <span class="keywordtype">int</span>     oldsize, oldmsg_size, movesize;
<a name="l01636"></a>01636 
<a name="l01637"></a>01637         LASSERT(segment &lt; msg-&gt;lm_bufcount);
<a name="l01638"></a>01638         LASSERT(msg-&gt;lm_buflens[segment] &lt;= newsize);
<a name="l01639"></a>01639 
<a name="l01640"></a>01640         <span class="keywordflow">if</span> (msg-&gt;lm_buflens[segment] == newsize)
<a name="l01641"></a>01641                 <span class="keywordflow">return</span>;
<a name="l01642"></a>01642 
<a name="l01643"></a>01643         <span class="comment">/* nothing to do if we are enlarging the last segment */</span>
<a name="l01644"></a>01644         <span class="keywordflow">if</span> (segment == msg-&gt;lm_bufcount - 1) {
<a name="l01645"></a>01645                 msg-&gt;lm_buflens[segment] = newsize;
<a name="l01646"></a>01646                 <span class="keywordflow">return</span>;
<a name="l01647"></a>01647         }
<a name="l01648"></a>01648 
<a name="l01649"></a>01649         oldsize = msg-&gt;lm_buflens[segment];
<a name="l01650"></a>01650 
<a name="l01651"></a>01651         src = lustre_msg_buf(msg, segment + 1, 0);
<a name="l01652"></a>01652         msg-&gt;lm_buflens[segment] = newsize;
<a name="l01653"></a>01653         dst = lustre_msg_buf(msg, segment + 1, 0);
<a name="l01654"></a>01654         msg-&gt;lm_buflens[segment] = oldsize;
<a name="l01655"></a>01655 
<a name="l01656"></a>01656         <span class="comment">/* move from segment + 1 to end segment */</span>
<a name="l01657"></a>01657         LASSERT(msg-&gt;lm_magic == LUSTRE_MSG_MAGIC_V2);
<a name="l01658"></a>01658         oldmsg_size = lustre_msg_size_v2(msg-&gt;lm_bufcount, msg-&gt;lm_buflens);
<a name="l01659"></a>01659         movesize = oldmsg_size - ((<span class="keywordtype">unsigned</span> long) src - (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) msg);
<a name="l01660"></a>01660         LASSERT(movesize &gt;= 0);
<a name="l01661"></a>01661 
<a name="l01662"></a>01662         <span class="keywordflow">if</span> (movesize)
<a name="l01663"></a>01663                 memmove(dst, src, movesize);
<a name="l01664"></a>01664 
<a name="l01665"></a>01665         <span class="comment">/* note we don&apos;t clear the ares where old data live, not secret */</span>
<a name="l01666"></a>01666 
<a name="l01667"></a>01667         <span class="comment">/* finally set new segment size */</span>
<a name="l01668"></a>01668         msg-&gt;lm_buflens[segment] = newsize;
<a name="l01669"></a>01669 }
<a name="l01670"></a>01670 EXPORT_SYMBOL(_sptlrpc_enlarge_msg_inplace);
<a name="l01671"></a>01671 
<a name="l01681"></a><a class="code" href="group__sptlrpc.html#gae060941c4c97b1cb7ba03904a24b53c3">01681</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gae060941c4c97b1cb7ba03904a24b53c3" title="Used by ptlrpc client to enlarge the segment of request message pointed by req-&amp;gt;rq_reqmsg...">sptlrpc_cli_enlarge_reqbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l01682"></a>01682                                <span class="keywordtype">int</span> segment, <span class="keywordtype">int</span> newsize)
<a name="l01683"></a>01683 {
<a name="l01684"></a>01684         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>    *ctx = req-&gt;rq_cli_ctx;
<a name="l01685"></a>01685         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__cops.html" title="client side policy operation vector.">ptlrpc_sec_cops</a>   *cops;
<a name="l01686"></a>01686         <span class="keyword">struct </span>lustre_msg        *msg = req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>;
<a name="l01687"></a>01687 
<a name="l01688"></a>01688         LASSERT(ctx);
<a name="l01689"></a>01689         LASSERT(msg);
<a name="l01690"></a>01690         LASSERT(msg-&gt;lm_bufcount &gt; segment);
<a name="l01691"></a>01691         LASSERT(msg-&gt;lm_buflens[segment] &lt;= newsize);
<a name="l01692"></a>01692 
<a name="l01693"></a>01693         <span class="keywordflow">if</span> (msg-&gt;lm_buflens[segment] == newsize)
<a name="l01694"></a>01694                 <span class="keywordflow">return</span> 0;
<a name="l01695"></a>01695 
<a name="l01696"></a>01696         cops = ctx-&gt;cc_sec-&gt;ps_policy-&gt;sp_cops;
<a name="l01697"></a>01697         LASSERT(cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a67af7eed6f87fb433e01dc500814723f" title="To expand the request buffer of req, thus the segment in the request message pointed...">enlarge_reqbuf</a>);
<a name="l01698"></a>01698         <span class="keywordflow">return</span> cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a67af7eed6f87fb433e01dc500814723f" title="To expand the request buffer of req, thus the segment in the request message pointed...">enlarge_reqbuf</a>(ctx-&gt;cc_sec, req, segment, newsize);
<a name="l01699"></a>01699 }
<a name="l01700"></a>01700 EXPORT_SYMBOL(<a class="code" href="group__sptlrpc.html#gae060941c4c97b1cb7ba03904a24b53c3" title="Used by ptlrpc client to enlarge the segment of request message pointed by req-&amp;gt;rq_reqmsg...">sptlrpc_cli_enlarge_reqbuf</a>);
<a name="l01701"></a>01701 
<a name="l01707"></a><a class="code" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f">01707</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req.">sptlrpc_cli_alloc_repbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> msgsize)
<a name="l01708"></a>01708 {
<a name="l01709"></a>01709         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l01710"></a>01710         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l01711"></a>01711         ENTRY;
<a name="l01712"></a>01712 
<a name="l01713"></a>01713         LASSERT(ctx);
<a name="l01714"></a>01714         LASSERT(ctx-&gt;cc_sec);
<a name="l01715"></a>01715         LASSERT(ctx-&gt;cc_sec-&gt;ps_policy);
<a name="l01716"></a>01716 
<a name="l01717"></a>01717         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a>)
<a name="l01718"></a>01718                 RETURN(0);
<a name="l01719"></a>01719 
<a name="l01720"></a>01720         policy = ctx-&gt;cc_sec-&gt;ps_policy;
<a name="l01721"></a>01721         RETURN(policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#a6b48ac1eaef3ac1159a8d8cac74d5eef" title="To allocate reply buffer for req.">alloc_repbuf</a>(ctx-&gt;cc_sec, req, msgsize));
<a name="l01722"></a>01722 }
<a name="l01723"></a>01723 
<a name="l01728"></a><a class="code" href="group__sptlrpc.html#ga6cd89bd371e4a81930e260bb1b8c79f8">01728</a> <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga6cd89bd371e4a81930e260bb1b8c79f8" title="Used by ptlrpc client to free reply buffer of req.">sptlrpc_cli_free_repbuf</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01729"></a>01729 {
<a name="l01730"></a>01730         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = req-&gt;rq_cli_ctx;
<a name="l01731"></a>01731         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l01732"></a>01732         ENTRY;
<a name="l01733"></a>01733 
<a name="l01734"></a>01734         LASSERT(ctx);
<a name="l01735"></a>01735         LASSERT(ctx-&gt;cc_sec);
<a name="l01736"></a>01736         LASSERT(ctx-&gt;cc_sec-&gt;ps_policy);
<a name="l01737"></a>01737         LASSERT_ATOMIC_POS(&amp;ctx-&gt;cc_refcount);
<a name="l01738"></a>01738 
<a name="l01739"></a>01739         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a2db3b96c4e6b13e1598f4e76276e43c0" title="rep buffer, vmalloc">rq_repbuf</a> == NULL)
<a name="l01740"></a>01740                 <span class="keywordflow">return</span>;
<a name="l01741"></a>01741         LASSERT(req-&gt;rq_repbuf_len);
<a name="l01742"></a>01742 
<a name="l01743"></a>01743         policy = ctx-&gt;cc_sec-&gt;ps_policy;
<a name="l01744"></a>01744         policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#ae72ed3fbdbb93a9fb7d08931fd536082" title="To free reply buffer for req.">free_repbuf</a>(ctx-&gt;cc_sec, req);
<a name="l01745"></a>01745         req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> = NULL;
<a name="l01746"></a>01746         EXIT;
<a name="l01747"></a>01747 }
<a name="l01748"></a>01748 
<a name="l01749"></a>01749 <span class="keywordtype">int</span> sptlrpc_cli_install_rvs_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01750"></a>01750                                 <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l01751"></a>01751 {
<a name="l01752"></a>01752         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy = ctx-&gt;cc_sec-&gt;ps_policy;
<a name="l01753"></a>01753 
<a name="l01754"></a>01754         <span class="keywordflow">if</span> (!policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#af147272a7b7761512f4e964a6b72d14d" title="Given an context ctx, install a corresponding reverse service context on client side...">install_rctx</a>)
<a name="l01755"></a>01755                 <span class="keywordflow">return</span> 0;
<a name="l01756"></a>01756         <span class="keywordflow">return</span> policy-&gt;sp_cops-&gt;<a class="code" href="structptlrpc__sec__cops.html#af147272a7b7761512f4e964a6b72d14d" title="Given an context ctx, install a corresponding reverse service context on client side...">install_rctx</a>(imp, ctx-&gt;cc_sec, ctx);
<a name="l01757"></a>01757 }
<a name="l01758"></a>01758 
<a name="l01759"></a>01759 <span class="keywordtype">int</span> sptlrpc_svc_install_rvs_ctx(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01760"></a>01760                                 <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx)
<a name="l01761"></a>01761 {
<a name="l01762"></a>01762         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy = ctx-&gt;sc_policy;
<a name="l01763"></a>01763 
<a name="l01764"></a>01764         <span class="keywordflow">if</span> (!policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a54b152657628c74074ae4ea4989846a3" title="Install a reverse context based on the server context ctx.">install_rctx</a>)
<a name="l01765"></a>01765                 <span class="keywordflow">return</span> 0;
<a name="l01766"></a>01766         <span class="keywordflow">return</span> policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a54b152657628c74074ae4ea4989846a3" title="Install a reverse context based on the server context ctx.">install_rctx</a>(imp, ctx);
<a name="l01767"></a>01767 }
<a name="l01768"></a>01768 
<a name="l01769"></a>01769 <span class="comment">/****************************************</span>
<a name="l01770"></a>01770 <span class="comment"> * server side security                 *</span>
<a name="l01771"></a>01771 <span class="comment"> ****************************************/</span>
<a name="l01772"></a>01772 
<a name="l01773"></a>01773 <span class="keyword">static</span> <span class="keywordtype">int</span> flavor_allowed(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *exp,
<a name="l01774"></a>01774                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01775"></a>01775 {
<a name="l01776"></a>01776         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *flvr = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>;
<a name="l01777"></a>01777 
<a name="l01778"></a>01778         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a> == SPTLRPC_FLVR_ANY || exp-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a> == flvr-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>)
<a name="l01779"></a>01779                 <span class="keywordflow">return</span> 1;
<a name="l01780"></a>01780 
<a name="l01781"></a>01781         <span class="keywordflow">if</span> ((req-&gt;rq_ctx_init || req-&gt;rq_ctx_fini) &amp;&amp;
<a name="l01782"></a>01782             SPTLRPC_FLVR_POLICY(exp-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) ==
<a name="l01783"></a>01783             SPTLRPC_FLVR_POLICY(flvr-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) &amp;&amp;
<a name="l01784"></a>01784             SPTLRPC_FLVR_MECH(exp-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) == SPTLRPC_FLVR_MECH(flvr-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>))
<a name="l01785"></a>01785                 <span class="keywordflow">return</span> 1;
<a name="l01786"></a>01786 
<a name="l01787"></a>01787         <span class="keywordflow">return</span> 0;
<a name="l01788"></a>01788 }
<a name="l01789"></a>01789 
<a name="l01790"></a>01790 <span class="preprocessor">#define EXP_FLVR_UPDATE_EXPIRE      (OBD_TIMEOUT_DEFAULT + 10)</span>
<a name="l01791"></a>01791 <span class="preprocessor"></span>
<a name="l01797"></a><a class="code" href="group__sptlrpc.html#gaf12efdd6553013c0e886d356541dd86b">01797</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gaf12efdd6553013c0e886d356541dd86b" title="Given an export exp, check whether the flavor of incoming req is allowed by the export...">sptlrpc_target_export_check</a>(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp,
<a name="l01798"></a>01798                                 <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01799"></a>01799 {
<a name="l01800"></a>01800         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a>   flavor;
<a name="l01801"></a>01801 
<a name="l01802"></a>01802         <span class="keywordflow">if</span> (exp == NULL)
<a name="l01803"></a>01803                 <span class="keywordflow">return</span> 0;
<a name="l01804"></a>01804 
<a name="l01805"></a>01805         <span class="comment">/* client side export has no imp_reverse, skip</span>
<a name="l01806"></a>01806 <span class="comment">         * FIXME maybe we should check flavor this as well??? */</span>
<a name="l01807"></a>01807         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structobd__export.html#a2dce74f596d31fe639a35fae13a75214" title="&amp;quot;reverse&amp;quot; import to send requests (e.g.">exp_imp_reverse</a> == NULL)
<a name="l01808"></a>01808                 <span class="keywordflow">return</span> 0;
<a name="l01809"></a>01809 
<a name="l01810"></a>01810         <span class="comment">/* don&apos;t care about ctx fini rpc */</span>
<a name="l01811"></a>01811         <span class="keywordflow">if</span> (req-&gt;rq_ctx_fini)
<a name="l01812"></a>01812                 <span class="keywordflow">return</span> 0;
<a name="l01813"></a>01813 
<a name="l01814"></a>01814         spin_lock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01815"></a>01815 
<a name="l01816"></a>01816         <span class="comment">/* if flavor just changed (exp-&gt;exp_flvr_changed != 0), we wait for</span>
<a name="l01817"></a>01817 <span class="comment">         * the first req with the new flavor, then treat it as current flavor,</span>
<a name="l01818"></a>01818 <span class="comment">         * adapt reverse sec according to it.</span>
<a name="l01819"></a>01819 <span class="comment">         * note the first rpc with new flavor might not be with root ctx, in</span>
<a name="l01820"></a>01820 <span class="comment">         * which case delay the sec_adapt by leaving exp_flvr_adapt == 1. */</span>
<a name="l01821"></a>01821         <span class="keywordflow">if</span> (unlikely(exp-&gt;exp_flvr_changed) &amp;&amp;
<a name="l01822"></a>01822             flavor_allowed(&amp;exp-&gt;exp_flvr_old[1], req)) {
<a name="l01823"></a>01823                 <span class="comment">/* make the new flavor as &quot;current&quot;, and old ones as</span>
<a name="l01824"></a>01824 <span class="comment">                 * about-to-expire */</span>
<a name="l01825"></a>01825                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p: just changed: %x-&gt;%x\n&quot;</span>, exp,
<a name="l01826"></a>01826                        exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01827"></a>01827                 flavor = exp-&gt;exp_flvr_old[1];
<a name="l01828"></a>01828                 exp-&gt;exp_flvr_old[1] = exp-&gt;exp_flvr_old[0];
<a name="l01829"></a>01829                 exp-&gt;exp_flvr_expire[1] = exp-&gt;exp_flvr_expire[0];
<a name="l01830"></a>01830                 exp-&gt;exp_flvr_old[0] = exp-&gt;exp_flvr;
<a name="l01831"></a>01831                 exp-&gt;exp_flvr_expire[0] = cfs_time_current_sec() +
<a name="l01832"></a>01832                                           EXP_FLVR_UPDATE_EXPIRE;
<a name="l01833"></a>01833                 exp-&gt;exp_flvr = flavor;
<a name="l01834"></a>01834 
<a name="l01835"></a>01835                 <span class="comment">/* flavor change finished */</span>
<a name="l01836"></a>01836                 exp-&gt;exp_flvr_changed = 0;
<a name="l01837"></a>01837                 LASSERT(exp-&gt;exp_flvr_adapt == 1);
<a name="l01838"></a>01838 
<a name="l01839"></a>01839                 <span class="comment">/* if it&apos;s gss, we only interested in root ctx init */</span>
<a name="l01840"></a>01840                 <span class="keywordflow">if</span> (req-&gt;rq_auth_gss &amp;&amp;
<a name="l01841"></a>01841                     !(req-&gt;rq_ctx_init &amp;&amp;
<a name="l01842"></a>01842                       (req-&gt;rq_auth_usr_root || req-&gt;rq_auth_usr_mdt ||
<a name="l01843"></a>01843                        req-&gt;rq_auth_usr_ost))) {
<a name="l01844"></a>01844                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01845"></a>01845                         CDEBUG(D_SEC, <span class="stringliteral">&quot;is good but not root(%d:%d:%d:%d:%d)\n&quot;</span>,
<a name="l01846"></a>01846                                req-&gt;rq_auth_gss, req-&gt;rq_ctx_init,
<a name="l01847"></a>01847                                req-&gt;rq_auth_usr_root, req-&gt;rq_auth_usr_mdt,
<a name="l01848"></a>01848                                req-&gt;rq_auth_usr_ost);
<a name="l01849"></a>01849                         <span class="keywordflow">return</span> 0;
<a name="l01850"></a>01850                 }
<a name="l01851"></a>01851 
<a name="l01852"></a>01852                 exp-&gt;exp_flvr_adapt = 0;
<a name="l01853"></a>01853                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01854"></a>01854 
<a name="l01855"></a>01855                 <span class="keywordflow">return</span> <a class="code" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration...">sptlrpc_import_sec_adapt</a>(exp-&gt;<a class="code" href="structobd__export.html#a2dce74f596d31fe639a35fae13a75214" title="&amp;quot;reverse&amp;quot; import to send requests (e.g.">exp_imp_reverse</a>,
<a name="l01856"></a>01856                                                 req-&gt;rq_svc_ctx, &amp;flavor);
<a name="l01857"></a>01857         }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859         <span class="comment">/* if it equals to the current flavor, we accept it, but need to</span>
<a name="l01860"></a>01860 <span class="comment">         * dealing with reverse sec/ctx */</span>
<a name="l01861"></a>01861         <span class="keywordflow">if</span> (likely(flavor_allowed(&amp;exp-&gt;exp_flvr, req))) {
<a name="l01862"></a>01862                 <span class="comment">/* most cases should return here, we only interested in</span>
<a name="l01863"></a>01863 <span class="comment">                 * gss root ctx init */</span>
<a name="l01864"></a>01864                 <span class="keywordflow">if</span> (!req-&gt;rq_auth_gss || !req-&gt;rq_ctx_init ||
<a name="l01865"></a>01865                     (!req-&gt;rq_auth_usr_root &amp;&amp; !req-&gt;rq_auth_usr_mdt &amp;&amp;
<a name="l01866"></a>01866                      !req-&gt;rq_auth_usr_ost)) {
<a name="l01867"></a>01867                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01868"></a>01868                         <span class="keywordflow">return</span> 0;
<a name="l01869"></a>01869                 }
<a name="l01870"></a>01870 
<a name="l01871"></a>01871                 <span class="comment">/* if flavor just changed, we should not proceed, just leave</span>
<a name="l01872"></a>01872 <span class="comment">                 * it and current flavor will be discovered and replaced</span>
<a name="l01873"></a>01873 <span class="comment">                 * shortly, and let _this_ rpc pass through */</span>
<a name="l01874"></a>01874                 <span class="keywordflow">if</span> (exp-&gt;exp_flvr_changed) {
<a name="l01875"></a>01875                         LASSERT(exp-&gt;exp_flvr_adapt);
<a name="l01876"></a>01876                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01877"></a>01877                         <span class="keywordflow">return</span> 0;
<a name="l01878"></a>01878                 }
<a name="l01879"></a>01879 
<a name="l01880"></a>01880                 <span class="keywordflow">if</span> (exp-&gt;exp_flvr_adapt) {
<a name="l01881"></a>01881                         exp-&gt;exp_flvr_adapt = 0;
<a name="l01882"></a>01882                         CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): do delayed adapt\n&quot;</span>,
<a name="l01883"></a>01883                                exp, exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01884"></a>01884                                exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01885"></a>01885                                exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01886"></a>01886                         flavor = exp-&gt;exp_flvr;
<a name="l01887"></a>01887                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01888"></a>01888 
<a name="l01889"></a>01889                         <span class="keywordflow">return</span> <a class="code" href="group__sptlrpc.html#ga01235b3d6bd59ff6adee314742be930b" title="To get an appropriate ptlrpc_sec for the imp, according to the current configuration...">sptlrpc_import_sec_adapt</a>(exp-&gt;<a class="code" href="structobd__export.html#a2dce74f596d31fe639a35fae13a75214" title="&amp;quot;reverse&amp;quot; import to send requests (e.g.">exp_imp_reverse</a>,
<a name="l01890"></a>01890                                                         req-&gt;rq_svc_ctx,
<a name="l01891"></a>01891                                                         &amp;flavor);
<a name="l01892"></a>01892                 } <span class="keywordflow">else</span> {
<a name="l01893"></a>01893                         CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): is current flavor, &quot;</span>
<a name="l01894"></a>01894                                <span class="stringliteral">&quot;install rvs ctx\n&quot;</span>, exp, exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01895"></a>01895                                exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01896"></a>01896                                exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01897"></a>01897                         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01898"></a>01898 
<a name="l01899"></a>01899                         <span class="keywordflow">return</span> sptlrpc_svc_install_rvs_ctx(exp-&gt;<a class="code" href="structobd__export.html#a2dce74f596d31fe639a35fae13a75214" title="&amp;quot;reverse&amp;quot; import to send requests (e.g.">exp_imp_reverse</a>,
<a name="l01900"></a>01900                                                            req-&gt;rq_svc_ctx);
<a name="l01901"></a>01901                 }
<a name="l01902"></a>01902         }
<a name="l01903"></a>01903 
<a name="l01904"></a>01904         <span class="keywordflow">if</span> (exp-&gt;exp_flvr_expire[0]) {
<a name="l01905"></a>01905                 <span class="keywordflow">if</span> (exp-&gt;exp_flvr_expire[0] &gt;= cfs_time_current_sec()) {
<a name="l01906"></a>01906                         <span class="keywordflow">if</span> (flavor_allowed(&amp;exp-&gt;exp_flvr_old[0], req)) {
<a name="l01907"></a>01907                                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): match the &quot;</span>
<a name="l01908"></a>01908                                        <span class="stringliteral">&quot;middle one (&quot;</span>CFS_DURATION_T<span class="stringliteral">&quot;)\n&quot;</span>, exp,
<a name="l01909"></a>01909                                        exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01910"></a>01910                                        exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01911"></a>01911                                        exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01912"></a>01912                                        exp-&gt;exp_flvr_expire[0] -
<a name="l01913"></a>01913                                                 cfs_time_current_sec());
<a name="l01914"></a>01914                                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01915"></a>01915                                 <span class="keywordflow">return</span> 0;
<a name="l01916"></a>01916                         }
<a name="l01917"></a>01917                 } <span class="keywordflow">else</span> {
<a name="l01918"></a>01918                         CDEBUG(D_SEC, <span class="stringliteral">&quot;mark middle expired\n&quot;</span>);
<a name="l01919"></a>01919                         exp-&gt;exp_flvr_expire[0] = 0;
<a name="l01920"></a>01920                 }
<a name="l01921"></a>01921                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): %x not match middle\n&quot;</span>, exp,
<a name="l01922"></a>01922                        exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01923"></a>01923                        exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01924"></a>01924                        req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01925"></a>01925         }
<a name="l01926"></a>01926 
<a name="l01927"></a>01927         <span class="comment">/* now it doesn&apos;t match the current flavor, the only chance we can</span>
<a name="l01928"></a>01928 <span class="comment">         * accept it is match the old flavors which is not expired. */</span>
<a name="l01929"></a>01929         <span class="keywordflow">if</span> (exp-&gt;exp_flvr_changed == 0 &amp;&amp; exp-&gt;exp_flvr_expire[1]) {
<a name="l01930"></a>01930                 <span class="keywordflow">if</span> (exp-&gt;exp_flvr_expire[1] &gt;= cfs_time_current_sec()) {
<a name="l01931"></a>01931                         <span class="keywordflow">if</span> (flavor_allowed(&amp;exp-&gt;exp_flvr_old[1], req)) {
<a name="l01932"></a>01932                                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): match the &quot;</span>
<a name="l01933"></a>01933                                        <span class="stringliteral">&quot;oldest one (&quot;</span>CFS_DURATION_T<span class="stringliteral">&quot;)\n&quot;</span>, exp,
<a name="l01934"></a>01934                                        exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01935"></a>01935                                        exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01936"></a>01936                                        exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01937"></a>01937                                        exp-&gt;exp_flvr_expire[1] -
<a name="l01938"></a>01938                                                 cfs_time_current_sec());
<a name="l01939"></a>01939                                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01940"></a>01940                                 <span class="keywordflow">return</span> 0;
<a name="l01941"></a>01941                         }
<a name="l01942"></a>01942                 } <span class="keywordflow">else</span> {
<a name="l01943"></a>01943                         CDEBUG(D_SEC, <span class="stringliteral">&quot;mark oldest expired\n&quot;</span>);
<a name="l01944"></a>01944                         exp-&gt;exp_flvr_expire[1] = 0;
<a name="l01945"></a>01945                 }
<a name="l01946"></a>01946                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): %x not match found\n&quot;</span>,
<a name="l01947"></a>01947                        exp, exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01948"></a>01948                        exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01949"></a>01949                        req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01950"></a>01950         } <span class="keywordflow">else</span> {
<a name="l01951"></a>01951                 CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%x|%x|%x): skip the last one\n&quot;</span>,
<a name="l01952"></a>01952                        exp, exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>, exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01953"></a>01953                        exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l01954"></a>01954         }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01957"></a>01957 
<a name="l01958"></a>01958         CWARN(<span class="stringliteral">&quot;exp %p(%s): req %p (%u|%u|%u|%u|%u|%u) with &quot;</span>
<a name="l01959"></a>01959               <span class="stringliteral">&quot;unauthorized flavor %x, expect %x|%x(%+ld)|%x(%+ld)\n&quot;</span>,
<a name="l01960"></a>01960               exp, exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_name,
<a name="l01961"></a>01961               req, req-&gt;rq_auth_gss, req-&gt;rq_ctx_init, req-&gt;rq_ctx_fini,
<a name="l01962"></a>01962               req-&gt;rq_auth_usr_root, req-&gt;rq_auth_usr_mdt, req-&gt;rq_auth_usr_ost,
<a name="l01963"></a>01963               req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01964"></a>01964               exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01965"></a>01965               exp-&gt;exp_flvr_old[0].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01966"></a>01966               exp-&gt;exp_flvr_expire[0] ?
<a name="l01967"></a>01967               (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (exp-&gt;exp_flvr_expire[0] -
<a name="l01968"></a>01968                                cfs_time_current_sec()) : 0,
<a name="l01969"></a>01969               exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l01970"></a>01970               exp-&gt;exp_flvr_expire[1] ?
<a name="l01971"></a>01971               (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (exp-&gt;exp_flvr_expire[1] -
<a name="l01972"></a>01972                                cfs_time_current_sec()) : 0);
<a name="l01973"></a>01973         <span class="keywordflow">return</span> -EACCES;
<a name="l01974"></a>01974 }
<a name="l01975"></a>01975 EXPORT_SYMBOL(<a class="code" href="group__sptlrpc.html#gaf12efdd6553013c0e886d356541dd86b" title="Given an export exp, check whether the flavor of incoming req is allowed by the export...">sptlrpc_target_export_check</a>);
<a name="l01976"></a>01976 
<a name="l01977"></a>01977 <span class="keywordtype">void</span> sptlrpc_target_update_exp_flavor(<span class="keyword">struct</span> <a class="code" href="structobd__device.html">obd_device</a> *obd,
<a name="l01978"></a>01978                                       <span class="keyword">struct</span> <a class="code" href="structsptlrpc__rule__set.html" title="A set of rules in memory.">sptlrpc_rule_set</a> *rset)
<a name="l01979"></a>01979 {
<a name="l01980"></a>01980         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>       *exp;
<a name="l01981"></a>01981         <span class="keyword">struct </span><a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a>    new_flvr;
<a name="l01982"></a>01982 
<a name="l01983"></a>01983         LASSERT(obd);
<a name="l01984"></a>01984 
<a name="l01985"></a>01985         spin_lock(&amp;obd-&gt;obd_dev_lock);
<a name="l01986"></a>01986 
<a name="l01987"></a>01987         list_for_each_entry(exp, &amp;obd-&gt;obd_exports, exp_obd_chain) {
<a name="l01988"></a>01988                 <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structobd__export.html#ae0ed47ab09f5904f1b740d33bd2f27ef" title="Active connetion.">exp_connection</a> == NULL)
<a name="l01989"></a>01989                         <span class="keywordflow">continue</span>;
<a name="l01990"></a>01990 
<a name="l01991"></a>01991                 <span class="comment">/* note if this export had just been updated flavor</span>
<a name="l01992"></a>01992 <span class="comment">                 * (exp_flvr_changed == 1), this will override the</span>
<a name="l01993"></a>01993 <span class="comment">                 * previous one. */</span>
<a name="l01994"></a>01994                 spin_lock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l01995"></a>01995                 <a class="code" href="group__sptlrpc.html#gac2dcbcaee70d89f9e5f250d5e095ab4e" title="called by target devices, determine the expected flavor from certain peer (from,...">sptlrpc_target_choose_flavor</a>(rset, exp-&gt;exp_sp_peer,
<a name="l01996"></a>01996                                              exp-&gt;<a class="code" href="structobd__export.html#ae0ed47ab09f5904f1b740d33bd2f27ef" title="Active connetion.">exp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>,
<a name="l01997"></a>01997                                              &amp;new_flvr);
<a name="l01998"></a>01998                 <span class="keywordflow">if</span> (exp-&gt;exp_flvr_changed ||
<a name="l01999"></a>01999                     !flavor_equal(&amp;new_flvr, &amp;exp-&gt;exp_flvr)) {
<a name="l02000"></a>02000                         exp-&gt;exp_flvr_old[1] = new_flvr;
<a name="l02001"></a>02001                         exp-&gt;exp_flvr_expire[1] = 0;
<a name="l02002"></a>02002                         exp-&gt;exp_flvr_changed = 1;
<a name="l02003"></a>02003                         exp-&gt;exp_flvr_adapt = 1;
<a name="l02004"></a>02004 
<a name="l02005"></a>02005                         CDEBUG(D_SEC, <span class="stringliteral">&quot;exp %p (%s): updated flavor %x-&gt;%x\n&quot;</span>,
<a name="l02006"></a>02006                                exp, sptlrpc_part2name(exp-&gt;exp_sp_peer),
<a name="l02007"></a>02007                                exp-&gt;exp_flvr.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>,
<a name="l02008"></a>02008                                exp-&gt;exp_flvr_old[1].<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l02009"></a>02009                 }
<a name="l02010"></a>02010                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l02011"></a>02011         }
<a name="l02012"></a>02012 
<a name="l02013"></a>02013         spin_unlock(&amp;obd-&gt;obd_dev_lock);
<a name="l02014"></a>02014 }
<a name="l02015"></a>02015 EXPORT_SYMBOL(sptlrpc_target_update_exp_flavor);
<a name="l02016"></a>02016 
<a name="l02017"></a>02017 <span class="keyword">static</span> <span class="keywordtype">int</span> sptlrpc_svc_check_from(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> svc_rc)
<a name="l02018"></a>02018 {
<a name="l02019"></a>02019         <span class="comment">/* peer&apos;s claim is unreliable unless gss is being used */</span>
<a name="l02020"></a>02020         <span class="keywordflow">if</span> (!req-&gt;rq_auth_gss || svc_rc == SECSVC_DROP)
<a name="l02021"></a>02021                 <span class="keywordflow">return</span> svc_rc;
<a name="l02022"></a>02022 
<a name="l02023"></a>02023         <span class="keywordflow">switch</span> (req-&gt;rq_sp_from) {
<a name="l02024"></a>02024         <span class="keywordflow">case</span> LUSTRE_SP_CLI:
<a name="l02025"></a>02025                 <span class="keywordflow">if</span> (req-&gt;rq_auth_usr_mdt || req-&gt;rq_auth_usr_ost) {
<a name="l02026"></a>02026                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;faked source CLI&quot;</span>);
<a name="l02027"></a>02027                         svc_rc = SECSVC_DROP;
<a name="l02028"></a>02028                 }
<a name="l02029"></a>02029                 <span class="keywordflow">break</span>;
<a name="l02030"></a>02030         <span class="keywordflow">case</span> LUSTRE_SP_MDT:
<a name="l02031"></a>02031                 <span class="keywordflow">if</span> (!req-&gt;rq_auth_usr_mdt) {
<a name="l02032"></a>02032                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;faked source MDT&quot;</span>);
<a name="l02033"></a>02033                         svc_rc = SECSVC_DROP;
<a name="l02034"></a>02034                 }
<a name="l02035"></a>02035                 <span class="keywordflow">break</span>;
<a name="l02036"></a>02036         <span class="keywordflow">case</span> LUSTRE_SP_OST:
<a name="l02037"></a>02037                 <span class="keywordflow">if</span> (!req-&gt;rq_auth_usr_ost) {
<a name="l02038"></a>02038                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;faked source OST&quot;</span>);
<a name="l02039"></a>02039                         svc_rc = SECSVC_DROP;
<a name="l02040"></a>02040                 }
<a name="l02041"></a>02041                 <span class="keywordflow">break</span>;
<a name="l02042"></a>02042         <span class="keywordflow">case</span> LUSTRE_SP_MGS:
<a name="l02043"></a>02043         <span class="keywordflow">case</span> LUSTRE_SP_MGC:
<a name="l02044"></a>02044                 <span class="keywordflow">if</span> (!req-&gt;rq_auth_usr_root &amp;&amp; !req-&gt;rq_auth_usr_mdt &amp;&amp;
<a name="l02045"></a>02045                     !req-&gt;rq_auth_usr_ost) {
<a name="l02046"></a>02046                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;faked source MGC/MGS&quot;</span>);
<a name="l02047"></a>02047                         svc_rc = SECSVC_DROP;
<a name="l02048"></a>02048                 }
<a name="l02049"></a>02049                 <span class="keywordflow">break</span>;
<a name="l02050"></a>02050         <span class="keywordflow">case</span> LUSTRE_SP_ANY:
<a name="l02051"></a>02051         <span class="keywordflow">default</span>:
<a name="l02052"></a>02052                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;invalid source %u&quot;</span>, req-&gt;rq_sp_from);
<a name="l02053"></a>02053                 svc_rc = SECSVC_DROP;
<a name="l02054"></a>02054         }
<a name="l02055"></a>02055 
<a name="l02056"></a>02056         <span class="keywordflow">return</span> svc_rc;
<a name="l02057"></a>02057 }
<a name="l02058"></a>02058 
<a name="l02070"></a><a class="code" href="group__sptlrpc.html#ga6fdd12db4bcfd925fed91da8a4ecf857">02070</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga6fdd12db4bcfd925fed91da8a4ecf857" title="Used by ptlrpc server, to perform transformation upon request message of incoming...">sptlrpc_svc_unwrap_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02071"></a>02071 {
<a name="l02072"></a>02072         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l02073"></a>02073         <span class="keyword">struct </span>lustre_msg        *msg = req-&gt;<a class="code" href="structptlrpc__request.html#a5b924c6ef6abad807db7d8e4bd53ed1e" title="various buffer pointers">rq_reqbuf</a>;
<a name="l02074"></a>02074         <span class="keywordtype">int</span>                       rc;
<a name="l02075"></a>02075         ENTRY;
<a name="l02076"></a>02076 
<a name="l02077"></a>02077         LASSERT(msg);
<a name="l02078"></a>02078         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> == NULL);
<a name="l02079"></a>02079         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> == NULL);
<a name="l02080"></a>02080         LASSERT(req-&gt;rq_svc_ctx == NULL);
<a name="l02081"></a>02081 
<a name="l02082"></a>02082         req-&gt;<a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a> = 0;
<a name="l02083"></a>02083 
<a name="l02084"></a>02084         rc = __lustre_unpack_msg(msg, req-&gt;rq_reqdata_len);
<a name="l02085"></a>02085         <span class="keywordflow">switch</span> (rc) {
<a name="l02086"></a>02086         <span class="keywordflow">case</span> 1:
<a name="l02087"></a>02087                 lustre_set_req_swabbed(req, <a class="code" href="group__lustreidl.html#gafa5c71e7497acfe5dea4f5efd14ef8ec" title="only use in req-&amp;gt;rq_{req,rep}_swab_mask">MSG_PTLRPC_HEADER_OFF</a>);
<a name="l02088"></a>02088         <span class="keywordflow">case</span> 0:
<a name="l02089"></a>02089                 <span class="keywordflow">break</span>;
<a name="l02090"></a>02090         <span class="keywordflow">default</span>:
<a name="l02091"></a>02091                 CERROR(<span class="stringliteral">&quot;error unpacking request from %s x&quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l02092"></a>02092                        libcfs_id2str(req-&gt;<a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>), req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l02093"></a>02093                 RETURN(SECSVC_DROP);
<a name="l02094"></a>02094         }
<a name="l02095"></a>02095 
<a name="l02096"></a>02096         req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a> = <a class="code" href="group__flavor.html#ga7746f840ac0ba4799482883ea5719881" title="extract the useful part from wire flavor">WIRE_FLVR</a>(msg-&gt;lm_secflvr);
<a name="l02097"></a>02097         req-&gt;rq_sp_from = LUSTRE_SP_ANY;
<a name="l02098"></a>02098         req-&gt;rq_auth_uid = -1;          <span class="comment">/* set to INVALID_UID */</span>
<a name="l02099"></a>02099         req-&gt;rq_auth_mapped_uid = -1;
<a name="l02100"></a>02100 
<a name="l02101"></a>02101         policy = sptlrpc_wireflavor2policy(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l02102"></a>02102         <span class="keywordflow">if</span> (!policy) {
<a name="l02103"></a>02103                 CERROR(<span class="stringliteral">&quot;unsupported rpc flavor %x\n&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>);
<a name="l02104"></a>02104                 RETURN(SECSVC_DROP);
<a name="l02105"></a>02105         }
<a name="l02106"></a>02106 
<a name="l02107"></a>02107         LASSERT(policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a2a593984c53aea5425bc29f6ede99144" title="verify an incoming request.">accept</a>);
<a name="l02108"></a>02108         rc = policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a2a593984c53aea5425bc29f6ede99144" title="verify an incoming request.">accept</a>(req);
<a name="l02109"></a>02109         sptlrpc_policy_put(policy);
<a name="l02110"></a>02110         LASSERT(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> || rc != SECSVC_OK);
<a name="l02111"></a>02111         LASSERT(req-&gt;rq_svc_ctx || rc == SECSVC_DROP);
<a name="l02112"></a>02112 
<a name="l02113"></a>02113         <span class="comment">/*</span>
<a name="l02114"></a>02114 <span class="comment">         * if it&apos;s not null flavor (which means embedded packing msg),</span>
<a name="l02115"></a>02115 <span class="comment">         * reset the swab mask for the comming inner msg unpacking.</span>
<a name="l02116"></a>02116 <span class="comment">         */</span>
<a name="l02117"></a>02117         <span class="keywordflow">if</span> (SPTLRPC_FLVR_POLICY(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) != SPTLRPC_POLICY_NULL)
<a name="l02118"></a>02118                 req-&gt;<a class="code" href="structptlrpc__request.html#a6c627388e734c103dcb1873c66aa814a" title="Fields that help to see if request and reply were swabbed or not.">rq_req_swab_mask</a> = 0;
<a name="l02119"></a>02119 
<a name="l02120"></a>02120         <span class="comment">/* sanity check for the request source */</span>
<a name="l02121"></a>02121         rc = sptlrpc_svc_check_from(req, rc);
<a name="l02122"></a>02122         RETURN(rc);
<a name="l02123"></a>02123 }
<a name="l02124"></a>02124 
<a name="l02130"></a><a class="code" href="group__sptlrpc.html#ga1bcf6cf901c5c461f6f273a9b764430a">02130</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga1bcf6cf901c5c461f6f273a9b764430a" title="Used by ptlrpc server, to allocate reply buffer for req.">sptlrpc_svc_alloc_rs</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req, <span class="keywordtype">int</span> msglen)
<a name="l02131"></a>02131 {
<a name="l02132"></a>02132         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l02133"></a>02133         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs;
<a name="l02134"></a>02134         <span class="keywordtype">int</span> rc;
<a name="l02135"></a>02135         ENTRY;
<a name="l02136"></a>02136 
<a name="l02137"></a>02137         LASSERT(req-&gt;rq_svc_ctx);
<a name="l02138"></a>02138         LASSERT(req-&gt;rq_svc_ctx-&gt;sc_policy);
<a name="l02139"></a>02139 
<a name="l02140"></a>02140         policy = req-&gt;rq_svc_ctx-&gt;sc_policy;
<a name="l02141"></a>02141         LASSERT(policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412" title="Allocate a ptlrpc_reply_state.">alloc_rs</a>);
<a name="l02142"></a>02142 
<a name="l02143"></a>02143         rc = policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412" title="Allocate a ptlrpc_reply_state.">alloc_rs</a>(req, msglen);
<a name="l02144"></a>02144         <span class="keywordflow">if</span> (unlikely(rc == -ENOMEM)) {
<a name="l02145"></a>02145                 <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt = req-&gt;rq_rqbd-&gt;rqbd_svcpt;
<a name="l02146"></a>02146                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service-&gt;srv_max_reply_size &lt;
<a name="l02147"></a>02147                    msglen + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>)) {
<a name="l02148"></a>02148                         <span class="comment">/* Just return failure if the size is too big */</span>
<a name="l02149"></a>02149                         CERROR(<span class="stringliteral">&quot;size of message is too big (%zd), %d allowed\n&quot;</span>,
<a name="l02150"></a>02150                                 msglen + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>),
<a name="l02151"></a>02151                                 svcpt-&gt;scp_service-&gt;srv_max_reply_size);
<a name="l02152"></a>02152                         RETURN(-ENOMEM);
<a name="l02153"></a>02153                 }
<a name="l02154"></a>02154 
<a name="l02155"></a>02155                 <span class="comment">/* failed alloc, try emergency pool */</span>
<a name="l02156"></a>02156                 rs = lustre_get_emerg_rs(svcpt);
<a name="l02157"></a>02157                 <span class="keywordflow">if</span> (rs == NULL)
<a name="l02158"></a>02158                         RETURN(-ENOMEM);
<a name="l02159"></a>02159 
<a name="l02160"></a>02160                 req-&gt;rq_reply_state = rs;
<a name="l02161"></a>02161                 rc = policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412" title="Allocate a ptlrpc_reply_state.">alloc_rs</a>(req, msglen);
<a name="l02162"></a>02162                 <span class="keywordflow">if</span> (rc) {
<a name="l02163"></a>02163                         lustre_put_emerg_rs(rs);
<a name="l02164"></a>02164                         req-&gt;rq_reply_state = NULL;
<a name="l02165"></a>02165                 }
<a name="l02166"></a>02166         }
<a name="l02167"></a>02167 
<a name="l02168"></a>02168         LASSERT(rc != 0 ||
<a name="l02169"></a>02169                 (req-&gt;rq_reply_state &amp;&amp; req-&gt;rq_reply_state-&gt;rs_msg));
<a name="l02170"></a>02170 
<a name="l02171"></a>02171         RETURN(rc);
<a name="l02172"></a>02172 }
<a name="l02173"></a>02173 
<a name="l02180"></a><a class="code" href="group__sptlrpc.html#gaa36445bb3135100651ecb584e151f3cb">02180</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gaa36445bb3135100651ecb584e151f3cb" title="Used by ptlrpc server, to perform transformation upon reply message.">sptlrpc_svc_wrap_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02181"></a>02181 {
<a name="l02182"></a>02182         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l02183"></a>02183         <span class="keywordtype">int</span> rc;
<a name="l02184"></a>02184         ENTRY;
<a name="l02185"></a>02185 
<a name="l02186"></a>02186         LASSERT(req-&gt;rq_svc_ctx);
<a name="l02187"></a>02187         LASSERT(req-&gt;rq_svc_ctx-&gt;sc_policy);
<a name="l02188"></a>02188 
<a name="l02189"></a>02189         policy = req-&gt;rq_svc_ctx-&gt;sc_policy;
<a name="l02190"></a>02190         LASSERT(policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a876a2e82cdca22048ce6521778690e83" title="Perform security transformation upon reply message.">authorize</a>);
<a name="l02191"></a>02191 
<a name="l02192"></a>02192         rc = policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a876a2e82cdca22048ce6521778690e83" title="Perform security transformation upon reply message.">authorize</a>(req);
<a name="l02193"></a>02193         LASSERT(rc || req-&gt;rq_reply_state-&gt;rs_repdata_len);
<a name="l02194"></a>02194 
<a name="l02195"></a>02195         RETURN(rc);
<a name="l02196"></a>02196 }
<a name="l02197"></a>02197 
<a name="l02201"></a><a class="code" href="group__sptlrpc.html#ga993608bc2cfa31615e26f5f368801d30">02201</a> <span class="keywordtype">void</span> <a class="code" href="group__sptlrpc.html#ga993608bc2cfa31615e26f5f368801d30" title="Used by ptlrpc server, to free reply_state.">sptlrpc_svc_free_rs</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs)
<a name="l02202"></a>02202 {
<a name="l02203"></a>02203         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> *policy;
<a name="l02204"></a>02204         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> prealloc;
<a name="l02205"></a>02205         ENTRY;
<a name="l02206"></a>02206 
<a name="l02207"></a>02207         LASSERT(rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ac2a1d9268241bed06a7375d7e6978a1a" title="Context for the sevice thread.">rs_svc_ctx</a>);
<a name="l02208"></a>02208         LASSERT(rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ac2a1d9268241bed06a7375d7e6978a1a" title="Context for the sevice thread.">rs_svc_ctx</a>-&gt;sc_policy);
<a name="l02209"></a>02209 
<a name="l02210"></a>02210         policy = rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ac2a1d9268241bed06a7375d7e6978a1a" title="Context for the sevice thread.">rs_svc_ctx</a>-&gt;sc_policy;
<a name="l02211"></a>02211         LASSERT(policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a9efbc6c11a531f258abfbb66ec8d3c83" title="Free a ptlrpc_reply_state.">free_rs</a>);
<a name="l02212"></a>02212 
<a name="l02213"></a>02213         prealloc = rs-&gt;rs_prealloc;
<a name="l02214"></a>02214         policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a9efbc6c11a531f258abfbb66ec8d3c83" title="Free a ptlrpc_reply_state.">free_rs</a>(rs);
<a name="l02215"></a>02215 
<a name="l02216"></a>02216         <span class="keywordflow">if</span> (prealloc)
<a name="l02217"></a>02217                 lustre_put_emerg_rs(rs);
<a name="l02218"></a>02218         EXIT;
<a name="l02219"></a>02219 }
<a name="l02220"></a>02220 
<a name="l02221"></a>02221 <span class="keywordtype">void</span> sptlrpc_svc_ctx_addref(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02222"></a>02222 {
<a name="l02223"></a>02223         <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx = req-&gt;rq_svc_ctx;
<a name="l02224"></a>02224 
<a name="l02225"></a>02225         <span class="keywordflow">if</span> (ctx != NULL)
<a name="l02226"></a>02226                 atomic_inc(&amp;ctx-&gt;sc_refcount);
<a name="l02227"></a>02227 }
<a name="l02228"></a>02228 
<a name="l02229"></a>02229 <span class="keywordtype">void</span> sptlrpc_svc_ctx_decref(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02230"></a>02230 {
<a name="l02231"></a>02231         <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx = req-&gt;rq_svc_ctx;
<a name="l02232"></a>02232 
<a name="l02233"></a>02233         <span class="keywordflow">if</span> (ctx == NULL)
<a name="l02234"></a>02234                 <span class="keywordflow">return</span>;
<a name="l02235"></a>02235 
<a name="l02236"></a>02236         LASSERT_ATOMIC_POS(&amp;ctx-&gt;sc_refcount);
<a name="l02237"></a>02237         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;ctx-&gt;sc_refcount)) {
<a name="l02238"></a>02238                 <span class="keywordflow">if</span> (ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#af0088688e5488aa185de82f8c48be04c" title="Release the server context ctx.">free_ctx</a>)
<a name="l02239"></a>02239                         ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#af0088688e5488aa185de82f8c48be04c" title="Release the server context ctx.">free_ctx</a>(ctx);
<a name="l02240"></a>02240         }
<a name="l02241"></a>02241         req-&gt;rq_svc_ctx = NULL;
<a name="l02242"></a>02242 }
<a name="l02243"></a>02243 
<a name="l02244"></a>02244 <span class="keywordtype">void</span> sptlrpc_svc_ctx_invalidate(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l02245"></a>02245 {
<a name="l02246"></a>02246         <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx = req-&gt;rq_svc_ctx;
<a name="l02247"></a>02247 
<a name="l02248"></a>02248         <span class="keywordflow">if</span> (ctx == NULL)
<a name="l02249"></a>02249                 <span class="keywordflow">return</span>;
<a name="l02250"></a>02250 
<a name="l02251"></a>02251         LASSERT_ATOMIC_POS(&amp;ctx-&gt;sc_refcount);
<a name="l02252"></a>02252         <span class="keywordflow">if</span> (ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a26a206ee7e1e7782f6ebd2994ecab72b" title="Invalidate server context ctx.">invalidate_ctx</a>)
<a name="l02253"></a>02253                 ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a26a206ee7e1e7782f6ebd2994ecab72b" title="Invalidate server context ctx.">invalidate_ctx</a>(ctx);
<a name="l02254"></a>02254 }
<a name="l02255"></a>02255 EXPORT_SYMBOL(sptlrpc_svc_ctx_invalidate);
<a name="l02256"></a>02256 
<a name="l02257"></a>02257 <span class="comment">/****************************************</span>
<a name="l02258"></a>02258 <span class="comment"> * bulk security                        *</span>
<a name="l02259"></a>02259 <span class="comment"> ****************************************/</span>
<a name="l02260"></a>02260 
<a name="l02265"></a><a class="code" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512">02265</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc.">sptlrpc_cli_wrap_bulk</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02266"></a>02266                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l02267"></a>02267 {
<a name="l02268"></a>02268         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx;
<a name="l02269"></a>02269 
<a name="l02270"></a>02270         LASSERT(req-&gt;rq_bulk_read || req-&gt;rq_bulk_write);
<a name="l02271"></a>02271 
<a name="l02272"></a>02272         <span class="keywordflow">if</span> (!req-&gt;rq_pack_bulk)
<a name="l02273"></a>02273                 <span class="keywordflow">return</span> 0;
<a name="l02274"></a>02274 
<a name="l02275"></a>02275         ctx = req-&gt;rq_cli_ctx;
<a name="l02276"></a>02276         <span class="keywordflow">if</span> (ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a1440abe65b4eac150d2f52c160582631" title="Wrap bulk request data.">wrap_bulk</a>)
<a name="l02277"></a>02277                 <span class="keywordflow">return</span> ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a1440abe65b4eac150d2f52c160582631" title="Wrap bulk request data.">wrap_bulk</a>(ctx, req, desc);
<a name="l02278"></a>02278         <span class="keywordflow">return</span> 0;
<a name="l02279"></a>02279 }
<a name="l02280"></a>02280 EXPORT_SYMBOL(<a class="code" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc.">sptlrpc_cli_wrap_bulk</a>);
<a name="l02281"></a>02281 
<a name="l02286"></a><a class="code" href="group__sptlrpc.html#ga40f686bb862f149e189cf81f3a51a7c3">02286</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga40f686bb862f149e189cf81f3a51a7c3" title="This is called after unwrap the reply message.">sptlrpc_cli_unwrap_bulk_read</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02287"></a>02287                                  <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc,
<a name="l02288"></a>02288                                  <span class="keywordtype">int</span> nob)
<a name="l02289"></a>02289 {
<a name="l02290"></a>02290         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>  *ctx;
<a name="l02291"></a>02291         <span class="keywordtype">int</span>                     rc;
<a name="l02292"></a>02292 
<a name="l02293"></a>02293         LASSERT(req-&gt;rq_bulk_read &amp;&amp; !req-&gt;rq_bulk_write);
<a name="l02294"></a>02294 
<a name="l02295"></a>02295         <span class="keywordflow">if</span> (!req-&gt;rq_pack_bulk)
<a name="l02296"></a>02296                 <span class="keywordflow">return</span> desc-&gt;bd_nob_transferred;
<a name="l02297"></a>02297 
<a name="l02298"></a>02298         ctx = req-&gt;rq_cli_ctx;
<a name="l02299"></a>02299         <span class="keywordflow">if</span> (ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e" title="Unwrap bulk reply data.">unwrap_bulk</a>) {
<a name="l02300"></a>02300                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e" title="Unwrap bulk reply data.">unwrap_bulk</a>(ctx, req, desc);
<a name="l02301"></a>02301                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02302"></a>02302                         <span class="keywordflow">return</span> rc;
<a name="l02303"></a>02303         }
<a name="l02304"></a>02304         <span class="keywordflow">return</span> desc-&gt;bd_nob_transferred;
<a name="l02305"></a>02305 }
<a name="l02306"></a>02306 EXPORT_SYMBOL(<a class="code" href="group__sptlrpc.html#ga40f686bb862f149e189cf81f3a51a7c3" title="This is called after unwrap the reply message.">sptlrpc_cli_unwrap_bulk_read</a>);
<a name="l02307"></a>02307 
<a name="l02312"></a><a class="code" href="group__sptlrpc.html#ga4a0448bc155a2dd383e108188f99beec">02312</a> <span class="keywordtype">int</span> <a class="code" href="group__sptlrpc.html#ga4a0448bc155a2dd383e108188f99beec" title="This is called after unwrap the reply message.">sptlrpc_cli_unwrap_bulk_write</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02313"></a>02313                                   <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l02314"></a>02314 {
<a name="l02315"></a>02315         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>  *ctx;
<a name="l02316"></a>02316         <span class="keywordtype">int</span>                     rc;
<a name="l02317"></a>02317 
<a name="l02318"></a>02318         LASSERT(!req-&gt;rq_bulk_read &amp;&amp; req-&gt;rq_bulk_write);
<a name="l02319"></a>02319 
<a name="l02320"></a>02320         <span class="keywordflow">if</span> (!req-&gt;rq_pack_bulk)
<a name="l02321"></a>02321                 <span class="keywordflow">return</span> 0;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323         ctx = req-&gt;rq_cli_ctx;
<a name="l02324"></a>02324         <span class="keywordflow">if</span> (ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e" title="Unwrap bulk reply data.">unwrap_bulk</a>) {
<a name="l02325"></a>02325                 rc = ctx-&gt;cc_ops-&gt;<a class="code" href="structptlrpc__ctx__ops.html#a3e676304ef422332412950003073eb4e" title="Unwrap bulk reply data.">unwrap_bulk</a>(ctx, req, desc);
<a name="l02326"></a>02326                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02327"></a>02327                         <span class="keywordflow">return</span> rc;
<a name="l02328"></a>02328         }
<a name="l02329"></a>02329 
<a name="l02330"></a>02330         <span class="comment">/*</span>
<a name="l02331"></a>02331 <span class="comment">         * if everything is going right, nob should equals to nob_transferred.</span>
<a name="l02332"></a>02332 <span class="comment">         * in case of privacy mode, nob_transferred needs to be adjusted.</span>
<a name="l02333"></a>02333 <span class="comment">         */</span>
<a name="l02334"></a>02334         <span class="keywordflow">if</span> (desc-&gt;bd_nob != desc-&gt;bd_nob_transferred) {
<a name="l02335"></a>02335                 CERROR(<span class="stringliteral">&quot;nob %d doesn&apos;t match transferred nob %d\n&quot;</span>,
<a name="l02336"></a>02336                        desc-&gt;bd_nob, desc-&gt;bd_nob_transferred);
<a name="l02337"></a>02337                 <span class="keywordflow">return</span> -EPROTO;
<a name="l02338"></a>02338         }
<a name="l02339"></a>02339 
<a name="l02340"></a>02340         <span class="keywordflow">return</span> 0;
<a name="l02341"></a>02341 }
<a name="l02342"></a>02342 EXPORT_SYMBOL(<a class="code" href="group__sptlrpc.html#ga4a0448bc155a2dd383e108188f99beec" title="This is called after unwrap the reply message.">sptlrpc_cli_unwrap_bulk_write</a>);
<a name="l02343"></a>02343 
<a name="l02344"></a>02344 <span class="preprocessor">#ifdef HAVE_SERVER_SUPPORT</span>
<a name="l02345"></a>02345 <span class="preprocessor"></span>
<a name="l02348"></a>02348 <span class="keywordtype">int</span> sptlrpc_svc_wrap_bulk(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02349"></a>02349                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l02350"></a>02350 {
<a name="l02351"></a>02351         <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx;
<a name="l02352"></a>02352 
<a name="l02353"></a>02353         LASSERT(req-&gt;rq_bulk_read);
<a name="l02354"></a>02354 
<a name="l02355"></a>02355         <span class="keywordflow">if</span> (!req-&gt;rq_pack_bulk)
<a name="l02356"></a>02356                 <span class="keywordflow">return</span> 0;
<a name="l02357"></a>02357 
<a name="l02358"></a>02358         ctx = req-&gt;rq_svc_ctx;
<a name="l02359"></a>02359         <span class="keywordflow">if</span> (ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#abbee33a52946011b640ea70e9ad75252" title="Wrap the bulk read data.">wrap_bulk</a>)
<a name="l02360"></a>02360                 <span class="keywordflow">return</span> ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#abbee33a52946011b640ea70e9ad75252" title="Wrap the bulk read data.">wrap_bulk</a>(req, desc);
<a name="l02361"></a>02361 
<a name="l02362"></a>02362         <span class="keywordflow">return</span> 0;
<a name="l02363"></a>02363 }
<a name="l02364"></a>02364 EXPORT_SYMBOL(sptlrpc_svc_wrap_bulk);
<a name="l02365"></a>02365 
<a name="l02369"></a>02369 <span class="keywordtype">int</span> sptlrpc_svc_unwrap_bulk(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02370"></a>02370                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l02371"></a>02371 {
<a name="l02372"></a>02372         <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx;
<a name="l02373"></a>02373         <span class="keywordtype">int</span>                    rc;
<a name="l02374"></a>02374 
<a name="l02375"></a>02375         LASSERT(req-&gt;rq_bulk_write);
<a name="l02376"></a>02376 
<a name="l02377"></a>02377         <span class="comment">/*</span>
<a name="l02378"></a>02378 <span class="comment">         * if it&apos;s in privacy mode, transferred should &gt;= expected; otherwise</span>
<a name="l02379"></a>02379 <span class="comment">         * transferred should == expected.</span>
<a name="l02380"></a>02380 <span class="comment">         */</span>
<a name="l02381"></a>02381         <span class="keywordflow">if</span> (desc-&gt;bd_nob_transferred &lt; desc-&gt;bd_nob ||
<a name="l02382"></a>02382             (desc-&gt;bd_nob_transferred &gt; desc-&gt;bd_nob &amp;&amp;
<a name="l02383"></a>02383              SPTLRPC_FLVR_BULK_SVC(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) !=
<a name="l02384"></a>02384              <a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4fae3bae4ed551d3148b1742dcd88cfc7f8" title="privacy">SPTLRPC_BULK_SVC_PRIV</a>)) {
<a name="l02385"></a>02385                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(D_ERROR, req, <span class="stringliteral">&quot;truncated bulk GET %d(%d)&quot;</span>,
<a name="l02386"></a>02386                           desc-&gt;bd_nob_transferred, desc-&gt;bd_nob);
<a name="l02387"></a>02387                 <span class="keywordflow">return</span> -ETIMEDOUT;
<a name="l02388"></a>02388         }
<a name="l02389"></a>02389 
<a name="l02390"></a>02390         <span class="keywordflow">if</span> (!req-&gt;rq_pack_bulk)
<a name="l02391"></a>02391                 <span class="keywordflow">return</span> 0;
<a name="l02392"></a>02392 
<a name="l02393"></a>02393         ctx = req-&gt;rq_svc_ctx;
<a name="l02394"></a>02394         <span class="keywordflow">if</span> (ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a56c58f3ce724e969057039fb1a0360b3" title="Unwrap the bulk write data.">unwrap_bulk</a>) {
<a name="l02395"></a>02395                 rc = ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a56c58f3ce724e969057039fb1a0360b3" title="Unwrap the bulk write data.">unwrap_bulk</a>(req, desc);
<a name="l02396"></a>02396                 <span class="keywordflow">if</span> (rc)
<a name="l02397"></a>02397                         CERROR(<span class="stringliteral">&quot;error unwrap bulk: %d\n&quot;</span>, rc);
<a name="l02398"></a>02398         }
<a name="l02399"></a>02399 
<a name="l02400"></a>02400         <span class="comment">/* return 0 to allow reply be sent */</span>
<a name="l02401"></a>02401         <span class="keywordflow">return</span> 0;
<a name="l02402"></a>02402 }
<a name="l02403"></a>02403 EXPORT_SYMBOL(sptlrpc_svc_unwrap_bulk);
<a name="l02404"></a>02404 
<a name="l02408"></a>02408 <span class="keywordtype">int</span> sptlrpc_svc_prep_bulk(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l02409"></a>02409                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)
<a name="l02410"></a>02410 {
<a name="l02411"></a>02411         <span class="keyword">struct </span><a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx;
<a name="l02412"></a>02412 
<a name="l02413"></a>02413         LASSERT(req-&gt;rq_bulk_write);
<a name="l02414"></a>02414 
<a name="l02415"></a>02415         <span class="keywordflow">if</span> (!req-&gt;rq_pack_bulk)
<a name="l02416"></a>02416                 <span class="keywordflow">return</span> 0;
<a name="l02417"></a>02417 
<a name="l02418"></a>02418         ctx = req-&gt;rq_svc_ctx;
<a name="l02419"></a>02419         <span class="keywordflow">if</span> (ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a5f77240383f3487906dfdaae468168b8" title="Prepare buffer for incoming bulk write.">prep_bulk</a>)
<a name="l02420"></a>02420                 <span class="keywordflow">return</span> ctx-&gt;sc_policy-&gt;sp_sops-&gt;<a class="code" href="structptlrpc__sec__sops.html#a5f77240383f3487906dfdaae468168b8" title="Prepare buffer for incoming bulk write.">prep_bulk</a>(req, desc);
<a name="l02421"></a>02421 
<a name="l02422"></a>02422         <span class="keywordflow">return</span> 0;
<a name="l02423"></a>02423 }
<a name="l02424"></a>02424 EXPORT_SYMBOL(sptlrpc_svc_prep_bulk);
<a name="l02425"></a>02425 
<a name="l02426"></a>02426 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SERVER_SUPPORT */</span>
<a name="l02427"></a>02427 
<a name="l02428"></a>02428 <span class="comment">/****************************************</span>
<a name="l02429"></a>02429 <span class="comment"> * user descriptor helpers              *</span>
<a name="l02430"></a>02430 <span class="comment"> ****************************************/</span>
<a name="l02431"></a>02431 
<a name="l02432"></a>02432 <span class="keywordtype">int</span> sptlrpc_current_user_desc_size(<span class="keywordtype">void</span>)
<a name="l02433"></a>02433 {
<a name="l02434"></a>02434         <span class="keywordtype">int</span> ngroups;
<a name="l02435"></a>02435 
<a name="l02436"></a>02436         ngroups = current_ngroups;
<a name="l02437"></a>02437 
<a name="l02438"></a>02438         <span class="keywordflow">if</span> (ngroups &gt; LUSTRE_MAX_GROUPS)
<a name="l02439"></a>02439                 ngroups = LUSTRE_MAX_GROUPS;
<a name="l02440"></a>02440         <span class="keywordflow">return</span> sptlrpc_user_desc_size(ngroups);
<a name="l02441"></a>02441 }
<a name="l02442"></a>02442 EXPORT_SYMBOL(sptlrpc_current_user_desc_size);
<a name="l02443"></a>02443 
<a name="l02444"></a>02444 <span class="keywordtype">int</span> sptlrpc_pack_user_desc(<span class="keyword">struct</span> lustre_msg *msg, <span class="keywordtype">int</span> offset)
<a name="l02445"></a>02445 {
<a name="l02446"></a>02446         <span class="keyword">struct </span><a class="code" href="structptlrpc__user__desc.html">ptlrpc_user_desc</a> *pud;
<a name="l02447"></a>02447 
<a name="l02448"></a>02448         pud = lustre_msg_buf(msg, offset, 0);
<a name="l02449"></a>02449 
<a name="l02450"></a>02450         pud-&gt;pud_uid = from_kuid(&amp;init_user_ns, current_uid());
<a name="l02451"></a>02451         pud-&gt;pud_gid = from_kgid(&amp;init_user_ns, current_gid());
<a name="l02452"></a>02452         pud-&gt;pud_fsuid = from_kuid(&amp;init_user_ns, current_fsuid());
<a name="l02453"></a>02453         pud-&gt;pud_fsgid = from_kgid(&amp;init_user_ns, current_fsgid());
<a name="l02454"></a>02454         pud-&gt;pud_cap = cfs_curproc_cap_pack();
<a name="l02455"></a>02455         pud-&gt;pud_ngroups = (msg-&gt;lm_buflens[offset] - <span class="keyword">sizeof</span>(*pud)) / 4;
<a name="l02456"></a>02456 
<a name="l02457"></a>02457         task_lock(current);
<a name="l02458"></a>02458         <span class="keywordflow">if</span> (pud-&gt;pud_ngroups &gt; current_ngroups)
<a name="l02459"></a>02459                 pud-&gt;pud_ngroups = current_ngroups;
<a name="l02460"></a>02460         memcpy(pud-&gt;pud_groups, current_cred()-&gt;group_info-&gt;blocks[0],
<a name="l02461"></a>02461                pud-&gt;pud_ngroups * <span class="keyword">sizeof</span>(__u32));
<a name="l02462"></a>02462         task_unlock(current);
<a name="l02463"></a>02463 
<a name="l02464"></a>02464         <span class="keywordflow">return</span> 0;
<a name="l02465"></a>02465 }
<a name="l02466"></a>02466 EXPORT_SYMBOL(sptlrpc_pack_user_desc);
<a name="l02467"></a>02467 
<a name="l02468"></a>02468 <span class="keywordtype">int</span> sptlrpc_unpack_user_desc(<span class="keyword">struct</span> lustre_msg *msg, <span class="keywordtype">int</span> offset, <span class="keywordtype">int</span> swabbed)
<a name="l02469"></a>02469 {
<a name="l02470"></a>02470         <span class="keyword">struct </span><a class="code" href="structptlrpc__user__desc.html">ptlrpc_user_desc</a> *pud;
<a name="l02471"></a>02471         <span class="keywordtype">int</span>                      i;
<a name="l02472"></a>02472 
<a name="l02473"></a>02473         pud = lustre_msg_buf(msg, offset, <span class="keyword">sizeof</span>(*pud));
<a name="l02474"></a>02474         <span class="keywordflow">if</span> (!pud)
<a name="l02475"></a>02475                 <span class="keywordflow">return</span> -EINVAL;
<a name="l02476"></a>02476 
<a name="l02477"></a>02477         <span class="keywordflow">if</span> (swabbed) {
<a name="l02478"></a>02478                 __swab32s(&amp;pud-&gt;pud_uid);
<a name="l02479"></a>02479                 __swab32s(&amp;pud-&gt;pud_gid);
<a name="l02480"></a>02480                 __swab32s(&amp;pud-&gt;pud_fsuid);
<a name="l02481"></a>02481                 __swab32s(&amp;pud-&gt;pud_fsgid);
<a name="l02482"></a>02482                 __swab32s(&amp;pud-&gt;pud_cap);
<a name="l02483"></a>02483                 __swab32s(&amp;pud-&gt;pud_ngroups);
<a name="l02484"></a>02484         }
<a name="l02485"></a>02485 
<a name="l02486"></a>02486         <span class="keywordflow">if</span> (pud-&gt;pud_ngroups &gt; LUSTRE_MAX_GROUPS) {
<a name="l02487"></a>02487                 CERROR(<span class="stringliteral">&quot;%u groups is too large\n&quot;</span>, pud-&gt;pud_ngroups);
<a name="l02488"></a>02488                 <span class="keywordflow">return</span> -EINVAL;
<a name="l02489"></a>02489         }
<a name="l02490"></a>02490 
<a name="l02491"></a>02491         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(*pud) + pud-&gt;pud_ngroups * <span class="keyword">sizeof</span>(__u32) &gt;
<a name="l02492"></a>02492             msg-&gt;lm_buflens[offset]) {
<a name="l02493"></a>02493                 CERROR(<span class="stringliteral">&quot;%u groups are claimed but bufsize only %u\n&quot;</span>,
<a name="l02494"></a>02494                        pud-&gt;pud_ngroups, msg-&gt;lm_buflens[offset]);
<a name="l02495"></a>02495                 <span class="keywordflow">return</span> -EINVAL;
<a name="l02496"></a>02496         }
<a name="l02497"></a>02497 
<a name="l02498"></a>02498         <span class="keywordflow">if</span> (swabbed) {
<a name="l02499"></a>02499                 <span class="keywordflow">for</span> (i = 0; i &lt; pud-&gt;pud_ngroups; i++)
<a name="l02500"></a>02500                         __swab32s(&amp;pud-&gt;pud_groups[i]);
<a name="l02501"></a>02501         }
<a name="l02502"></a>02502 
<a name="l02503"></a>02503         <span class="keywordflow">return</span> 0;
<a name="l02504"></a>02504 }
<a name="l02505"></a>02505 EXPORT_SYMBOL(sptlrpc_unpack_user_desc);
<a name="l02506"></a>02506 
<a name="l02507"></a>02507 <span class="comment">/****************************************</span>
<a name="l02508"></a>02508 <span class="comment"> * misc helpers                         *</span>
<a name="l02509"></a>02509 <span class="comment"> ****************************************/</span>
<a name="l02510"></a>02510 
<a name="l02511"></a>02511 <span class="keyword">const</span> <span class="keywordtype">char</span> * sec2target_str(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l02512"></a>02512 {
<a name="l02513"></a>02513         <span class="keywordflow">if</span> (!sec || !sec-&gt;<a class="code" href="structptlrpc__sec.html#a52e343bfafb7fde35949b51da5125458" title="owning import">ps_import</a> || !sec-&gt;<a class="code" href="structptlrpc__sec.html#a52e343bfafb7fde35949b51da5125458" title="owning import">ps_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>)
<a name="l02514"></a>02514                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;*&quot;</span>;
<a name="l02515"></a>02515         <span class="keywordflow">if</span> (sec_is_reverse(sec))
<a name="l02516"></a>02516                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;c&quot;</span>;
<a name="l02517"></a>02517         <span class="keywordflow">return</span> obd_uuid2str(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a52e343bfafb7fde35949b51da5125458" title="owning import">ps_import</a>-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;u.cli.cl_target_uuid);
<a name="l02518"></a>02518 }
<a name="l02519"></a>02519 EXPORT_SYMBOL(sec2target_str);
<a name="l02520"></a>02520 
<a name="l02521"></a>02521 <span class="comment">/*</span>
<a name="l02522"></a>02522 <span class="comment"> * return true if the bulk data is protected</span>
<a name="l02523"></a>02523 <span class="comment"> */</span>
<a name="l02524"></a>02524 <span class="keywordtype">int</span> sptlrpc_flavor_has_bulk(<span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *flvr)
<a name="l02525"></a>02525 {
<a name="l02526"></a>02526         <span class="keywordflow">switch</span> (SPTLRPC_FLVR_BULK_SVC(flvr-&gt;<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>)) {
<a name="l02527"></a>02527         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4faec306d681efa1995b008526cfa7500a4" title="integrity">SPTLRPC_BULK_SVC_INTG</a>:
<a name="l02528"></a>02528         <span class="keywordflow">case</span> <a class="code" href="group__flavor.html#gga475c572a7bfc33daec9df01be01b3d4fae3bae4ed551d3148b1742dcd88cfc7f8" title="privacy">SPTLRPC_BULK_SVC_PRIV</a>:
<a name="l02529"></a>02529                 <span class="keywordflow">return</span> 1;
<a name="l02530"></a>02530         <span class="keywordflow">default</span>:
<a name="l02531"></a>02531                 <span class="keywordflow">return</span> 0;
<a name="l02532"></a>02532         }
<a name="l02533"></a>02533 }
<a name="l02534"></a>02534 EXPORT_SYMBOL(sptlrpc_flavor_has_bulk);
<a name="l02535"></a>02535 
<a name="l02536"></a>02536 <span class="comment">/****************************************</span>
<a name="l02537"></a>02537 <span class="comment"> * crypto API helper/alloc blkciper     *</span>
<a name="l02538"></a>02538 <span class="comment"> ****************************************/</span>
<a name="l02539"></a>02539 
<a name="l02540"></a>02540 <span class="comment">/****************************************</span>
<a name="l02541"></a>02541 <span class="comment"> * initialize/finalize                  *</span>
<a name="l02542"></a>02542 <span class="comment"> ****************************************/</span>
<a name="l02543"></a>02543 
<a name="l02544"></a>02544 <span class="keywordtype">int</span> sptlrpc_init(<span class="keywordtype">void</span>)
<a name="l02545"></a>02545 {
<a name="l02546"></a>02546         <span class="keywordtype">int</span> rc;
<a name="l02547"></a>02547 
<a name="l02548"></a>02548         rwlock_init(&amp;policy_lock);
<a name="l02549"></a>02549 
<a name="l02550"></a>02550         rc = sptlrpc_gc_init();
<a name="l02551"></a>02551         <span class="keywordflow">if</span> (rc)
<a name="l02552"></a>02552                 <span class="keywordflow">goto</span> out;
<a name="l02553"></a>02553 
<a name="l02554"></a>02554         rc = sptlrpc_conf_init();
<a name="l02555"></a>02555         <span class="keywordflow">if</span> (rc)
<a name="l02556"></a>02556                 <span class="keywordflow">goto</span> out_gc;
<a name="l02557"></a>02557 
<a name="l02558"></a>02558         rc = sptlrpc_enc_pool_init();
<a name="l02559"></a>02559         <span class="keywordflow">if</span> (rc)
<a name="l02560"></a>02560                 <span class="keywordflow">goto</span> out_conf;
<a name="l02561"></a>02561 
<a name="l02562"></a>02562         rc = sptlrpc_null_init();
<a name="l02563"></a>02563         <span class="keywordflow">if</span> (rc)
<a name="l02564"></a>02564                 <span class="keywordflow">goto</span> out_pool;
<a name="l02565"></a>02565 
<a name="l02566"></a>02566         rc = sptlrpc_plain_init();
<a name="l02567"></a>02567         <span class="keywordflow">if</span> (rc)
<a name="l02568"></a>02568                 <span class="keywordflow">goto</span> out_null;
<a name="l02569"></a>02569 
<a name="l02570"></a>02570         rc = sptlrpc_lproc_init();
<a name="l02571"></a>02571         <span class="keywordflow">if</span> (rc)
<a name="l02572"></a>02572                 <span class="keywordflow">goto</span> out_plain;
<a name="l02573"></a>02573 
<a name="l02574"></a>02574         <span class="keywordflow">return</span> 0;
<a name="l02575"></a>02575 
<a name="l02576"></a>02576 out_plain:
<a name="l02577"></a>02577         sptlrpc_plain_fini();
<a name="l02578"></a>02578 out_null:
<a name="l02579"></a>02579         sptlrpc_null_fini();
<a name="l02580"></a>02580 out_pool:
<a name="l02581"></a>02581         sptlrpc_enc_pool_fini();
<a name="l02582"></a>02582 out_conf:
<a name="l02583"></a>02583         sptlrpc_conf_fini();
<a name="l02584"></a>02584 out_gc:
<a name="l02585"></a>02585         sptlrpc_gc_fini();
<a name="l02586"></a>02586 out:
<a name="l02587"></a>02587         <span class="keywordflow">return</span> rc;
<a name="l02588"></a>02588 }
<a name="l02589"></a>02589 
<a name="l02590"></a>02590 <span class="keywordtype">void</span> sptlrpc_fini(<span class="keywordtype">void</span>)
<a name="l02591"></a>02591 {
<a name="l02592"></a>02592         sptlrpc_lproc_fini();
<a name="l02593"></a>02593         sptlrpc_plain_fini();
<a name="l02594"></a>02594         sptlrpc_null_fini();
<a name="l02595"></a>02595         sptlrpc_enc_pool_fini();
<a name="l02596"></a>02596         sptlrpc_conf_fini();
<a name="l02597"></a>02597         sptlrpc_gc_fini();
<a name="l02598"></a>02598 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:22 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
