<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lib</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structl__wait__info.html">l_wait_info</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69a4bdb69d1ddb62665b4b936e4b37ea"></a><!-- doxytag: member="lib::LWI_ON_SIGNAL_NOOP" ref="ga69a4bdb69d1ddb62665b4b936e4b37ea" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LWI_ON_SIGNAL_NOOP</b>&nbsp;&nbsp;&nbsp;((void (*)(void *))(-1))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LWI_TIMEOUT</b>(time, cb, data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LWI_TIMEOUT_INTERVAL</b>(time, interval, cb, data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LWI_TIMEOUT_INTR</b>(time, time_cb, sig_cb, data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LWI_TIMEOUT_INTR_ALL</b>(time, time_cb, sig_cb, data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab125226712d6a6cb7eaf8833b5c8565e"></a><!-- doxytag: member="lib::LWI_INTR" ref="gab125226712d6a6cb7eaf8833b5c8565e" args="(cb, data)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LWI_INTR</b>(cb, data)&nbsp;&nbsp;&nbsp;LWI_TIMEOUT_INTR(0, NULL, cb, data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LUSTRE_FATAL_SIGS</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib.html#gafa8e2750e27464c8a43db62e9ff969e6">add_wait_queue_exclusive_head</a>(waitq, link)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">wait_queue_t of Linux (version &lt; 2.6.34) is a FIFO list for exclusively waiting threads, which is not always desirable because all threads will be waken up again and again, even user only needs a few of them to be active most time.  <a href="#gafa8e2750e27464c8a43db62e9ff969e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ceb1ccb9463c4f21b22382207cc4c7d"></a><!-- doxytag: member="lib::__l_wait_event" ref="ga6ceb1ccb9463c4f21b22382207cc4c7d" args="(wq, condition, info, ret, l_add_wait)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>__l_wait_event</b>(wq, condition, info, ret, l_add_wait)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>l_wait_event</b>(wq, condition, info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>l_wait_event_exclusive</b>(wq, condition, info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>l_wait_event_exclusive_head</b>(wq, condition, info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>l_wait_condition</b>(wq, condition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>l_wait_condition_exclusive</b>(wq, condition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>l_wait_condition_exclusive_head</b>(wq, condition)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafdb6e70a2f301ef0c9e594f8871d9b40"></a><!-- doxytag: member="lib::target_pack_pool_reply" ref="gafdb6e70a2f301ef0c9e594f8871d9b40" args="(struct ptlrpc_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib.html#gafdb6e70a2f301ef0c9e594f8871d9b40">target_pack_pool_reply</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packs current SLV and Limit into <em>req</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315">do_set_info_async</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, int opcode, int version, size_t keylen, void *key, size_t vallen, void *val, struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a remote set_info_async.  <a href="#gafc5cf9a5b2924b90734e720301742315"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85f5aad1f6441ed3a0d44b17c6b99c7b"></a><!-- doxytag: member="lib::target_send_reply" ref="ga85f5aad1f6441ed3a0d44b17c6b99c7b" args="(struct ptlrpc_request *req, int rc, int fail_id)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>target_send_reply</b> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int rc, int fail_id)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gafa8e2750e27464c8a43db62e9ff969e6"></a><!-- doxytag: member="lustre_lib.h::add_wait_queue_exclusive_head" ref="gafa8e2750e27464c8a43db62e9ff969e6" args="(waitq, link)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define add_wait_queue_exclusive_head</td>
          <td>(</td>
          <td class="paramtype">waitq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">link&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                               \
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;                                    \
                                                                \
        spin_lock_irqsave(&amp;((waitq)-&gt;lock), flags);             \
        __add_wait_queue_exclusive(waitq, link);                \
        spin_unlock_irqrestore(&amp;((waitq)-&gt;lock), flags);        \
}
</pre></div>
<p>wait_queue_t of Linux (version &lt; 2.6.34) is a FIFO list for exclusively waiting threads, which is not always desirable because all threads will be waken up again and again, even user only needs a few of them to be active most time. </p>
<p>This is not good for performance because cache can be polluted by different threads.</p>
<p>LIFO list can resolve this problem because we always wakeup the most recent active thread by default.</p>
<p>NB: please don't call non-exclusive &amp; exclusive wait on the same waitq if add_wait_queue_exclusive_head is used. </p>

<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00240">240</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6070101353394203e1505e9bb2e32413"></a><!-- doxytag: member="lustre_lib.h::l_wait_condition" ref="ga6070101353394203e1505e9bb2e32413" args="(wq, condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define l_wait_condition</td>
          <td>(</td>
          <td class="paramtype">wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">condition&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                                              \
        <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi = { 0 };                         \
        l_wait_event(wq, condition, &amp;lwi);                      \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00359">359</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e071607217fbdc689a9c6c84e529df1"></a><!-- doxytag: member="lustre_lib.h::l_wait_condition_exclusive" ref="ga5e071607217fbdc689a9c6c84e529df1" args="(wq, condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define l_wait_condition_exclusive</td>
          <td>(</td>
          <td class="paramtype">wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">condition&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                                              \
        <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi = { 0 };                         \
        l_wait_event_exclusive(wq, condition, &amp;lwi);            \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00365">365</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaca146888178fcc6e639dd359eede62de"></a><!-- doxytag: member="lustre_lib.h::l_wait_condition_exclusive_head" ref="gaca146888178fcc6e639dd359eede62de" args="(wq, condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define l_wait_condition_exclusive_head</td>
          <td>(</td>
          <td class="paramtype">wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">condition&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                                              \
        <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi = { 0 };                         \
        l_wait_event_exclusive_head(wq, condition, &amp;lwi);       \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00371">371</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga277da3a4d12da2eb0be28a20ba56d900"></a><!-- doxytag: member="lustre_lib.h::l_wait_event" ref="ga277da3a4d12da2eb0be28a20ba56d900" args="(wq, condition, info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define l_wait_event</td>
          <td>(</td>
          <td class="paramtype">wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">condition, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">info&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                                              \
        <span class="keywordtype">int</span>                 __ret;                              \
        <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> *__info = (info);                    \
                                                                \
        __l_wait_event(wq, condition, __info,                   \
                       __ret, add_wait_queue);                  \
        __ret;                                                  \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00329">329</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf2dfb2fca671ff2c1156e18582d2bd03"></a><!-- doxytag: member="lustre_lib.h::l_wait_event_exclusive" ref="gaf2dfb2fca671ff2c1156e18582d2bd03" args="(wq, condition, info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define l_wait_event_exclusive</td>
          <td>(</td>
          <td class="paramtype">wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">condition, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">info&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                                              \
        <span class="keywordtype">int</span>                 __ret;                              \
        <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> *__info = (info);                    \
                                                                \
        __l_wait_event(wq, condition, __info,                   \
                       __ret, add_wait_queue_exclusive);        \
        __ret;                                                  \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00339">339</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga44238bd6042bb29adc0735ba6efc808f"></a><!-- doxytag: member="lustre_lib.h::l_wait_event_exclusive_head" ref="ga44238bd6042bb29adc0735ba6efc808f" args="(wq, condition, info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define l_wait_event_exclusive_head</td>
          <td>(</td>
          <td class="paramtype">wq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">condition, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">info&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">({                                                              \
        <span class="keywordtype">int</span>                 __ret;                              \
        <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> *__info = (info);                    \
                                                                \
        __l_wait_event(wq, condition, __info,                   \
                       __ret, <a class="code" href="group__lib.html#gafa8e2750e27464c8a43db62e9ff969e6" title="wait_queue_t of Linux (version &amp;lt; 2.6.34) is a FIFO list for exclusively waiting...">add_wait_queue_exclusive_head</a>);   \
        __ret;                                                  \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00349">349</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d2f4808ef9f41663e1e40bf527c4509"></a><!-- doxytag: member="lustre_lib.h::LUSTRE_FATAL_SIGS" ref="ga7d2f4808ef9f41663e1e40bf527c4509" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LUSTRE_FATAL_SIGS</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(sigmask(SIGKILL) | sigmask(SIGINT) | sigmask(SIGTERM) | \
         sigmask(SIGQUIT) | sigmask(SIGALRM))
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00211">211</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c8a9c91f1f21e7ff21abedc365140f9"></a><!-- doxytag: member="lustre_lib.h::LWI_TIMEOUT" ref="ga2c8a9c91f1f21e7ff21abedc365140f9" args="(time, cb, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWI_TIMEOUT</td>
          <td>(</td>
          <td class="paramtype">time, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>) {                         \
        .lwi_timeout    = time,                 \
        .lwi_on_timeout = cb,                   \
        .lwi_cb_data    = data,                 \
        .lwi_interval   = 0,                    \
        .lwi_allow_intr = 0                     \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00171">171</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga551c4c576557c71d5d420704bc9206b0"></a><!-- doxytag: member="lustre_lib.h::LWI_TIMEOUT_INTERVAL" ref="ga551c4c576557c71d5d420704bc9206b0" args="(time, interval, cb, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWI_TIMEOUT_INTERVAL</td>
          <td>(</td>
          <td class="paramtype">time, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>) {                                 \
        .lwi_timeout    = time,                         \
        .lwi_on_timeout = cb,                           \
        .lwi_cb_data    = data,                         \
        .lwi_interval   = interval,                     \
        .lwi_allow_intr = 0                             \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00180">180</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga62c286be2c5fae04dc329e2d67ece19b"></a><!-- doxytag: member="lustre_lib.h::LWI_TIMEOUT_INTR" ref="ga62c286be2c5fae04dc329e2d67ece19b" args="(time, time_cb, sig_cb, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWI_TIMEOUT_INTR</td>
          <td>(</td>
          <td class="paramtype">time, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sig_cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>) {                                 \
        .lwi_timeout    = time,                         \
        .lwi_on_timeout = time_cb,                      \
        .lwi_on_signal  = sig_cb,                       \
        .lwi_cb_data    = data,                         \
        .lwi_interval   = 0,                            \
        .lwi_allow_intr = 0                             \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00189">189</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab5290ac11914c764f80117e25f3926ce"></a><!-- doxytag: member="lustre_lib.h::LWI_TIMEOUT_INTR_ALL" ref="gab5290ac11914c764f80117e25f3926ce" args="(time, time_cb, sig_cb, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWI_TIMEOUT_INTR_ALL</td>
          <td>(</td>
          <td class="paramtype">time, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sig_cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>) {                                         \
        .lwi_timeout    = time,                                 \
        .lwi_on_timeout = time_cb,                              \
        .lwi_on_signal  = sig_cb,                               \
        .lwi_cb_data    = data,                                 \
        .lwi_interval   = 0,                                    \
        .lwi_allow_intr = 1                                     \
})
</pre></div>
<p>Definition at line <a class="el" href="lustre__lib_8h_source.html#l00199">199</a> of file <a class="el" href="lustre__lib_8h_source.html">lustre_lib.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gafc5cf9a5b2924b90734e720301742315"></a><!-- doxytag: member="lustre_lib.h::do_set_info_async" ref="gafc5cf9a5b2924b90734e720301742315" args="(struct obd_import *imp, int opcode, int version, size_t keylen, void *key, size_t vallen, void *val, struct ptlrpc_request_set *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int do_set_info_async </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>vallen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request__set.html">ptlrpc_request_set</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a remote set_info_async. </p>
<p>This may go from client to server or server to client. </p>

<p>Definition at line <a class="el" href="pack__generic_8c_source.html#l01574">1574</a> of file <a class="el" href="pack__generic_8c_source.html">pack_generic.c</a>.</p>

<p>References <a class="el" href="client_8c_source.html#l01644">ptlrpc_check_set()</a>, <a class="el" href="client_8c_source.html#l02829">ptlrpc_queue_wait()</a>, <a class="el" href="client_8c_source.html#l02490">ptlrpc_req_finished()</a>, <a class="el" href="client_8c_source.html#l00852">ptlrpc_request_alloc()</a>, <a class="el" href="client_8c_source.html#l00875">ptlrpc_request_free()</a>, <a class="el" href="client_8c_source.html#l00762">ptlrpc_request_pack()</a>, <a class="el" href="client_8c_source.html#l01050">ptlrpc_set_add_req()</a>, <a class="el" href="layout_8c_source.html#l02117">req_capsule_client_get()</a>, <a class="el" href="layout_8c_source.html#l02226">req_capsule_set_size()</a>, and <a class="el" href="lustre__net_8h_source.html#l01121">ptlrpc_request::rq_pill</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01579"></a>01579 {
<a name="l01580"></a>01580         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l01581"></a>01581         <span class="keywordtype">char</span>                  *tmp;
<a name="l01582"></a>01582         <span class="keywordtype">int</span>                    rc;
<a name="l01583"></a>01583         ENTRY;
<a name="l01584"></a>01584 
<a name="l01585"></a>01585         req = <a class="code" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure...">ptlrpc_request_alloc</a>(imp, &amp;RQF_OBD_SET_INFO);
<a name="l01586"></a>01586         <span class="keywordflow">if</span> (req == NULL)
<a name="l01587"></a>01587                 RETURN(-ENOMEM);
<a name="l01588"></a>01588 
<a name="l01589"></a>01589         <a class="code" href="group__req__layout.html#ga6d0a3a11367bcd9fe40dc723243e7b0d" title="Set the size of the PTLRPC request/reply (loc) buffer for the given field of the...">req_capsule_set_size</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_SETINFO_KEY,
<a name="l01590"></a>01590                              RCL_CLIENT, keylen);
<a name="l01591"></a>01591         <a class="code" href="group__req__layout.html#ga6d0a3a11367bcd9fe40dc723243e7b0d" title="Set the size of the PTLRPC request/reply (loc) buffer for the given field of the...">req_capsule_set_size</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_SETINFO_VAL,
<a name="l01592"></a>01592                              RCL_CLIENT, vallen);
<a name="l01593"></a>01593         rc = <a class="code" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps...">ptlrpc_request_pack</a>(req, version, opcode);
<a name="l01594"></a>01594         <span class="keywordflow">if</span> (rc) {
<a name="l01595"></a>01595                 <a class="code" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure.">ptlrpc_request_free</a>(req);
<a name="l01596"></a>01596                 RETURN(rc);
<a name="l01597"></a>01597         }
<a name="l01598"></a>01598 
<a name="l01599"></a>01599         tmp = <a class="code" href="group__req__layout.html#ga0ecb097da2dfa5ac12ec0ef1f33d3e88" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC request buffer...">req_capsule_client_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_SETINFO_KEY);
<a name="l01600"></a>01600         memcpy(tmp, key, keylen);
<a name="l01601"></a>01601         tmp = <a class="code" href="group__req__layout.html#ga0ecb097da2dfa5ac12ec0ef1f33d3e88" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC request buffer...">req_capsule_client_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_SETINFO_VAL);
<a name="l01602"></a>01602         memcpy(tmp, val, vallen);
<a name="l01603"></a>01603 
<a name="l01604"></a>01604         ptlrpc_request_set_replen(req);
<a name="l01605"></a>01605 
<a name="l01606"></a>01606         <span class="keywordflow">if</span> (<span class="keyword">set</span>) {
<a name="l01607"></a>01607                 <a class="code" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set.">ptlrpc_set_add_req</a>(<span class="keyword">set</span>, req);
<a name="l01608"></a>01608                 <a class="code" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies...">ptlrpc_check_set</a>(NULL, <span class="keyword">set</span>);
<a name="l01609"></a>01609         } <span class="keywordflow">else</span> {
<a name="l01610"></a>01610                 rc = <a class="code" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes.">ptlrpc_queue_wait</a>(req);
<a name="l01611"></a>01611                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l01612"></a>01612         }
<a name="l01613"></a>01613 
<a name="l01614"></a>01614         RETURN(rc);
<a name="l01615"></a>01615 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lib_gafc5cf9a5b2924b90734e720301742315_cgraph.png" border="0" usemap="#group__lib_gafc5cf9a5b2924b90734e720301742315_cgraph_map" alt=""></div>
<map name="group__lib_gafc5cf9a5b2924b90734e720301742315_cgraph_map" id="group__lib_gafc5cf9a5b2924b90734e720301742315_cgraph">
<area shape="rect" id="node3" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="656,209,795,239"/><area shape="rect" id="node18" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request." alt="" coords="1143,5,1289,35"/><area shape="rect" id="node40" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="216,288,363,317"/><area shape="rect" id="node45" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set." alt="" coords="428,367,577,396"/><area shape="rect" id="node54" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure..." alt="" coords="211,471,368,500"/><area shape="rect" id="node56" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure." alt="" coords="212,524,367,553"/><area shape="rect" id="node58" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps..." alt="" coords="211,577,368,607"/><area shape="rect" id="node70" href="group__req__layout.html#ga0ecb097da2dfa5ac12ec0ef1f33d3e88" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC request buffer..." alt="" coords="200,631,379,660"/><area shape="rect" id="node72" href="group__req__layout.html#ga6d0a3a11367bcd9fe40dc723243e7b0d" title="Set the size of the PTLRPC request/reply (loc) buffer for the given field of the..." alt="" coords="207,684,372,713"/><area shape="rect" id="node5" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="911,209,1017,239"/><area shape="rect" id="node22" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network." alt="" coords="1131,59,1301,88"/><area shape="rect" id="node32" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="873,263,1055,292"/><area shape="rect" id="node7" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME." alt="" coords="1395,143,1520,172"/><area shape="rect" id="node9" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal." alt="" coords="1396,228,1519,257"/><area shape="rect" id="node11" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list." alt="" coords="1400,293,1515,323"/><area shape="rect" id="node13" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Actual interfacing with LNet to put/get/register/unregister stuff." alt="" coords="1139,216,1293,245"/><area shape="rect" id="node20" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req." alt="" coords="1131,424,1301,453"/><area shape="rect" id="node24" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req." alt="" coords="1128,163,1304,192"/><area shape="rect" id="node26" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre&#45;defined security transformation upon the..." alt="" coords="1123,371,1309,400"/><area shape="rect" id="node28" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc." alt="" coords="1377,371,1537,400"/><area shape="rect" id="node34" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="1104,477,1328,507"/><area shape="rect" id="node36" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="1379,451,1536,480"/><area shape="rect" id="node38" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="1379,504,1536,533"/><area shape="rect" id="node42" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT." alt="" coords="439,263,567,292"/><area shape="rect" id="node47" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set..." alt="" coords="651,107,800,136"/><area shape="rect" id="node50" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="440,209,565,239"/><area shape="rect" id="node60" href="group__req__layout.html#gaf42efe506903884592711902e9276e99" title="This function shrinks the size of the _buffer_ of the pill&#39;s PTLRPC request or..." alt="" coords="429,577,576,607"/><area shape="rect" id="node62" href="group__net.html#ga8ddfe4bfdb34b2159b8281fb3c6e09a4" title="lustre_msg_buflen &#45; return the length of buffer n in message m " alt="" coords="653,524,797,553"/><area shape="rect" id="node64" href="group__req__layout.html#gad281812fde0bdb0aaaed8a022e0008f2" title="Returns a non&#45;zero value if the given field is present in the given pill&#39;s PTLRPC..." alt="" coords="627,577,824,607"/><area shape="rect" id="node66" href="group__req__layout.html#ga35302dbfc2517d692579948a9742d3ba" title="This function returns a non&#45;zero value if the given field is present in the format..." alt="" coords="881,603,1047,632"/></map>
</div>
</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:43 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
