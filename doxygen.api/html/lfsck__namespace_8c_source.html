<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/lfsck/lfsck_namespace.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/lfsck/lfsck_namespace.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment"> * GNU General Public License version 2 for more details.  A copy is</span>
<a name="l00014"></a>00014 <span class="comment"> * included in the COPYING file that accompanied this code.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * along with this program; if not, write to the Free Software</span>
<a name="l00018"></a>00018 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * GPL HEADER END</span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 <span class="comment">/*</span>
<a name="l00023"></a>00023 <span class="comment"> * Copyright (c) 2013, 2015, Intel Corporation.</span>
<a name="l00024"></a>00024 <span class="comment"> */</span>
<a name="l00025"></a>00025 <span class="comment">/*</span>
<a name="l00026"></a>00026 <span class="comment"> * lustre/lfsck/lfsck_namespace.c</span>
<a name="l00027"></a>00027 <span class="comment"> *</span>
<a name="l00028"></a>00028 <span class="comment"> * Author: Fan, Yong &lt;fan.yong@intel.com&gt;</span>
<a name="l00029"></a>00029 <span class="comment"> */</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_LFSCK</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;lustre/lustre_idl.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;lu_object.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;dt_object.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;md_object.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;lustre_fid.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;lustre_lib.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;lustre_net.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;lustre/lustre_user.h&gt;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;lfsck_internal.h&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#define LFSCK_NAMESPACE_MAGIC_V1        0xA0629D03</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#define LFSCK_NAMESPACE_MAGIC_V2        0xA0621A0B</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>
<a name="l00047"></a>00047 <span class="comment">/* For Lustre-2.x (x &lt;= 6), the namespace LFSCK used LFSCK_NAMESPACE_MAGIC_V1</span>
<a name="l00048"></a>00048 <span class="comment"> * as the trace file magic. When downgrade to such old release, the old LFSCK</span>
<a name="l00049"></a>00049 <span class="comment"> * will not recognize the new LFSCK_NAMESPACE_MAGIC_V2 in the new trace file,</span>
<a name="l00050"></a>00050 <span class="comment"> * then it will reset the whole LFSCK, and will not cause start failure. The</span>
<a name="l00051"></a>00051 <span class="comment"> * similar case will happen when upgrade from such old release. */</span>
<a name="l00052"></a>00052 <span class="preprocessor">#define LFSCK_NAMESPACE_MAGIC           LFSCK_NAMESPACE_MAGIC_V2</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="keyword">enum</span> lfsck_nameentry_check {
<a name="l00055"></a>00055         LFSCK_NAMEENTRY_DEAD            = 1, <span class="comment">/* The object has been unlinked. */</span>
<a name="l00056"></a>00056         LFSCK_NAMEENTRY_REMOVED         = 2, <span class="comment">/* The entry has been removed. */</span>
<a name="l00057"></a>00057         LFSCK_NAMEENTRY_RECREATED       = 3, <span class="comment">/* The entry has been recreated. */</span>
<a name="l00058"></a>00058 };
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a> *
<a name="l00061"></a>00061 lfsck_namespace_assistant_req_init(<span class="keyword">struct</span> <a class="code" href="structlfsck__instance.html">lfsck_instance</a> *lfsck,
<a name="l00062"></a>00062                                    <span class="keyword">struct</span> <a class="code" href="structlfsck__assistant__object.html">lfsck_assistant_object</a> *lso,
<a name="l00063"></a>00063                                    <span class="keyword">struct</span> <a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *ent, __u16 type)
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a> *lnr;
<a name="l00066"></a>00066         <span class="keywordtype">int</span>                         size;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068         size = <span class="keyword">sizeof</span>(*lnr) + (ent-&gt;<a class="code" href="structlu__dirent.html#a6cf011f9cdc36e619bad6e893a537c02" title="name length">lde_namelen</a> &amp; ~3) + 4;
<a name="l00069"></a>00069         OBD_ALLOC(lnr, size);
<a name="l00070"></a>00070         <span class="keywordflow">if</span> (lnr == NULL)
<a name="l00071"></a>00071                 <span class="keywordflow">return</span> ERR_PTR(-ENOMEM);
<a name="l00072"></a>00072 
<a name="l00073"></a>00073         INIT_LIST_HEAD(&amp;lnr-&gt;lnr_lar.lar_list);
<a name="l00074"></a>00074         lnr-&gt;lnr_lar.lar_parent = lfsck_assistant_object_get(lso);
<a name="l00075"></a>00075         lnr-&gt;lnr_lmv = lfsck_lmv_get(lfsck-&gt;li_lmv);
<a name="l00076"></a>00076         lnr-&gt;lnr_fid = ent-&gt;<a class="code" href="structlu__dirent.html#a58764bd31894298ed7ab119d7a245308" title="valid if LUDA_FID is set.">lde_fid</a>;
<a name="l00077"></a>00077         lnr-&gt;lnr_dir_cookie = ent-&gt;<a class="code" href="structlu__dirent.html#a93db8cf242015f8192bd7263f8a50e2e" title="a unique entry identifier: a hash or an offset.">lde_hash</a>;
<a name="l00078"></a>00078         lnr-&gt;lnr_attr = ent-&gt;<a class="code" href="structlu__dirent.html#af1fe2598c44bab695e849de0a2ca80dc" title="optional variable size attributes following this entry.">lde_attrs</a>;
<a name="l00079"></a>00079         lnr-&gt;lnr_size = size;
<a name="l00080"></a>00080         lnr-&gt;lnr_type = type;
<a name="l00081"></a>00081         lnr-&gt;lnr_namelen = ent-&gt;<a class="code" href="structlu__dirent.html#a6cf011f9cdc36e619bad6e893a537c02" title="name length">lde_namelen</a>;
<a name="l00082"></a>00082         memcpy(lnr-&gt;lnr_name, ent-&gt;<a class="code" href="structlu__dirent.html#a3e3b5a552269757293891e23de373a3f" title="name is followed by the attributes indicated in -&amp;gt;ldp_attrs, in their natural...">lde_name</a>, ent-&gt;<a class="code" href="structlu__dirent.html#a6cf011f9cdc36e619bad6e893a537c02" title="name length">lde_namelen</a>);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084         <span class="keywordflow">return</span> lnr;
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_assistant_req_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00088"></a>00088                                                <span class="keyword">struct</span> <a class="code" href="structlfsck__assistant__req.html">lfsck_assistant_req</a> *lar)
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a> *lnr =
<a name="l00091"></a>00091                         container_of0(lar, <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a>, lnr_lar);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093         <span class="keywordflow">if</span> (lnr-&gt;lnr_lmv != NULL)
<a name="l00094"></a>00094                 lfsck_lmv_put(env, lnr-&gt;lnr_lmv);
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         lfsck_assistant_object_put(env, lar-&gt;lar_parent);
<a name="l00097"></a>00097         OBD_FREE(lnr, lnr-&gt;lnr_size);
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_le_to_cpu(<span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *dst,
<a name="l00101"></a>00101                                       <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *src)
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103         dst-&gt;ln_magic = le32_to_cpu(src-&gt;ln_magic);
<a name="l00104"></a>00104         dst-&gt;ln_status = le32_to_cpu(src-&gt;ln_status);
<a name="l00105"></a>00105         dst-&gt;ln_flags = le32_to_cpu(src-&gt;ln_flags);
<a name="l00106"></a>00106         dst-&gt;ln_success_count = le32_to_cpu(src-&gt;ln_success_count);
<a name="l00107"></a>00107         dst-&gt;ln_run_time_phase1 = le32_to_cpu(src-&gt;ln_run_time_phase1);
<a name="l00108"></a>00108         dst-&gt;ln_run_time_phase2 = le32_to_cpu(src-&gt;ln_run_time_phase2);
<a name="l00109"></a>00109         dst-&gt;ln_time_last_complete = le64_to_cpu(src-&gt;ln_time_last_complete);
<a name="l00110"></a>00110         dst-&gt;ln_time_latest_start = le64_to_cpu(src-&gt;ln_time_latest_start);
<a name="l00111"></a>00111         dst-&gt;ln_time_last_checkpoint =
<a name="l00112"></a>00112                                 le64_to_cpu(src-&gt;ln_time_last_checkpoint);
<a name="l00113"></a>00113         lfsck_position_le_to_cpu(&amp;dst-&gt;ln_pos_latest_start,
<a name="l00114"></a>00114                                  &amp;src-&gt;ln_pos_latest_start);
<a name="l00115"></a>00115         lfsck_position_le_to_cpu(&amp;dst-&gt;ln_pos_last_checkpoint,
<a name="l00116"></a>00116                                  &amp;src-&gt;ln_pos_last_checkpoint);
<a name="l00117"></a>00117         lfsck_position_le_to_cpu(&amp;dst-&gt;ln_pos_first_inconsistent,
<a name="l00118"></a>00118                                  &amp;src-&gt;ln_pos_first_inconsistent);
<a name="l00119"></a>00119         dst-&gt;ln_items_checked = le64_to_cpu(src-&gt;ln_items_checked);
<a name="l00120"></a>00120         dst-&gt;ln_items_repaired = le64_to_cpu(src-&gt;ln_items_repaired);
<a name="l00121"></a>00121         dst-&gt;ln_items_failed = le64_to_cpu(src-&gt;ln_items_failed);
<a name="l00122"></a>00122         dst-&gt;ln_dirs_checked = le64_to_cpu(src-&gt;ln_dirs_checked);
<a name="l00123"></a>00123         dst-&gt;ln_objs_checked_phase2 = le64_to_cpu(src-&gt;ln_objs_checked_phase2);
<a name="l00124"></a>00124         dst-&gt;ln_objs_repaired_phase2 =
<a name="l00125"></a>00125                                 le64_to_cpu(src-&gt;ln_objs_repaired_phase2);
<a name="l00126"></a>00126         dst-&gt;ln_objs_failed_phase2 = le64_to_cpu(src-&gt;ln_objs_failed_phase2);
<a name="l00127"></a>00127         dst-&gt;ln_objs_nlink_repaired = le64_to_cpu(src-&gt;ln_objs_nlink_repaired);
<a name="l00128"></a>00128         fid_le_to_cpu(&amp;dst-&gt;ln_fid_latest_scanned_phase2,
<a name="l00129"></a>00129                       &amp;src-&gt;ln_fid_latest_scanned_phase2);
<a name="l00130"></a>00130         dst-&gt;ln_dirent_repaired = le64_to_cpu(src-&gt;ln_dirent_repaired);
<a name="l00131"></a>00131         dst-&gt;ln_linkea_repaired = le64_to_cpu(src-&gt;ln_linkea_repaired);
<a name="l00132"></a>00132         dst-&gt;ln_mul_linked_checked = le64_to_cpu(src-&gt;ln_mul_linked_checked);
<a name="l00133"></a>00133         dst-&gt;ln_mul_linked_repaired = le64_to_cpu(src-&gt;ln_mul_linked_repaired);
<a name="l00134"></a>00134         dst-&gt;ln_unknown_inconsistency =
<a name="l00135"></a>00135                                 le64_to_cpu(src-&gt;ln_unknown_inconsistency);
<a name="l00136"></a>00136         dst-&gt;ln_unmatched_pairs_repaired =
<a name="l00137"></a>00137                                 le64_to_cpu(src-&gt;ln_unmatched_pairs_repaired);
<a name="l00138"></a>00138         dst-&gt;ln_dangling_repaired = le64_to_cpu(src-&gt;ln_dangling_repaired);
<a name="l00139"></a>00139         dst-&gt;ln_mul_ref_repaired = le64_to_cpu(src-&gt;ln_mul_ref_repaired);
<a name="l00140"></a>00140         dst-&gt;ln_bad_type_repaired = le64_to_cpu(src-&gt;ln_bad_type_repaired);
<a name="l00141"></a>00141         dst-&gt;ln_lost_dirent_repaired =
<a name="l00142"></a>00142                                 le64_to_cpu(src-&gt;ln_lost_dirent_repaired);
<a name="l00143"></a>00143         dst-&gt;ln_striped_dirs_scanned =
<a name="l00144"></a>00144                                 le64_to_cpu(src-&gt;ln_striped_dirs_scanned);
<a name="l00145"></a>00145         dst-&gt;ln_striped_dirs_repaired =
<a name="l00146"></a>00146                                 le64_to_cpu(src-&gt;ln_striped_dirs_repaired);
<a name="l00147"></a>00147         dst-&gt;ln_striped_dirs_failed =
<a name="l00148"></a>00148                                 le64_to_cpu(src-&gt;ln_striped_dirs_failed);
<a name="l00149"></a>00149         dst-&gt;ln_striped_dirs_disabled =
<a name="l00150"></a>00150                                 le64_to_cpu(src-&gt;ln_striped_dirs_disabled);
<a name="l00151"></a>00151         dst-&gt;ln_striped_dirs_skipped =
<a name="l00152"></a>00152                                 le64_to_cpu(src-&gt;ln_striped_dirs_skipped);
<a name="l00153"></a>00153         dst-&gt;ln_striped_shards_scanned =
<a name="l00154"></a>00154                                 le64_to_cpu(src-&gt;ln_striped_shards_scanned);
<a name="l00155"></a>00155         dst-&gt;ln_striped_shards_repaired =
<a name="l00156"></a>00156                                 le64_to_cpu(src-&gt;ln_striped_shards_repaired);
<a name="l00157"></a>00157         dst-&gt;ln_striped_shards_failed =
<a name="l00158"></a>00158                                 le64_to_cpu(src-&gt;ln_striped_shards_failed);
<a name="l00159"></a>00159         dst-&gt;ln_striped_shards_skipped =
<a name="l00160"></a>00160                                 le64_to_cpu(src-&gt;ln_striped_shards_skipped);
<a name="l00161"></a>00161         dst-&gt;ln_name_hash_repaired = le64_to_cpu(src-&gt;ln_name_hash_repaired);
<a name="l00162"></a>00162         dst-&gt;ln_local_lpf_scanned = le64_to_cpu(src-&gt;ln_local_lpf_scanned);
<a name="l00163"></a>00163         dst-&gt;ln_local_lpf_moved = le64_to_cpu(src-&gt;ln_local_lpf_moved);
<a name="l00164"></a>00164         dst-&gt;ln_local_lpf_skipped = le64_to_cpu(src-&gt;ln_local_lpf_skipped);
<a name="l00165"></a>00165         dst-&gt;ln_local_lpf_failed = le64_to_cpu(src-&gt;ln_local_lpf_failed);
<a name="l00166"></a>00166         dst-&gt;ln_bitmap_size = le32_to_cpu(src-&gt;ln_bitmap_size);
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_cpu_to_le(<span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *dst,
<a name="l00170"></a>00170                                       <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *src)
<a name="l00171"></a>00171 {
<a name="l00172"></a>00172         dst-&gt;ln_magic = cpu_to_le32(src-&gt;ln_magic);
<a name="l00173"></a>00173         dst-&gt;ln_status = cpu_to_le32(src-&gt;ln_status);
<a name="l00174"></a>00174         dst-&gt;ln_flags = cpu_to_le32(src-&gt;ln_flags);
<a name="l00175"></a>00175         dst-&gt;ln_success_count = cpu_to_le32(src-&gt;ln_success_count);
<a name="l00176"></a>00176         dst-&gt;ln_run_time_phase1 = cpu_to_le32(src-&gt;ln_run_time_phase1);
<a name="l00177"></a>00177         dst-&gt;ln_run_time_phase2 = cpu_to_le32(src-&gt;ln_run_time_phase2);
<a name="l00178"></a>00178         dst-&gt;ln_time_last_complete = cpu_to_le64(src-&gt;ln_time_last_complete);
<a name="l00179"></a>00179         dst-&gt;ln_time_latest_start = cpu_to_le64(src-&gt;ln_time_latest_start);
<a name="l00180"></a>00180         dst-&gt;ln_time_last_checkpoint =
<a name="l00181"></a>00181                                 cpu_to_le64(src-&gt;ln_time_last_checkpoint);
<a name="l00182"></a>00182         lfsck_position_cpu_to_le(&amp;dst-&gt;ln_pos_latest_start,
<a name="l00183"></a>00183                                  &amp;src-&gt;ln_pos_latest_start);
<a name="l00184"></a>00184         lfsck_position_cpu_to_le(&amp;dst-&gt;ln_pos_last_checkpoint,
<a name="l00185"></a>00185                                  &amp;src-&gt;ln_pos_last_checkpoint);
<a name="l00186"></a>00186         lfsck_position_cpu_to_le(&amp;dst-&gt;ln_pos_first_inconsistent,
<a name="l00187"></a>00187                                  &amp;src-&gt;ln_pos_first_inconsistent);
<a name="l00188"></a>00188         dst-&gt;ln_items_checked = cpu_to_le64(src-&gt;ln_items_checked);
<a name="l00189"></a>00189         dst-&gt;ln_items_repaired = cpu_to_le64(src-&gt;ln_items_repaired);
<a name="l00190"></a>00190         dst-&gt;ln_items_failed = cpu_to_le64(src-&gt;ln_items_failed);
<a name="l00191"></a>00191         dst-&gt;ln_dirs_checked = cpu_to_le64(src-&gt;ln_dirs_checked);
<a name="l00192"></a>00192         dst-&gt;ln_objs_checked_phase2 = cpu_to_le64(src-&gt;ln_objs_checked_phase2);
<a name="l00193"></a>00193         dst-&gt;ln_objs_repaired_phase2 =
<a name="l00194"></a>00194                                 cpu_to_le64(src-&gt;ln_objs_repaired_phase2);
<a name="l00195"></a>00195         dst-&gt;ln_objs_failed_phase2 = cpu_to_le64(src-&gt;ln_objs_failed_phase2);
<a name="l00196"></a>00196         dst-&gt;ln_objs_nlink_repaired = cpu_to_le64(src-&gt;ln_objs_nlink_repaired);
<a name="l00197"></a>00197         fid_cpu_to_le(&amp;dst-&gt;ln_fid_latest_scanned_phase2,
<a name="l00198"></a>00198                       &amp;src-&gt;ln_fid_latest_scanned_phase2);
<a name="l00199"></a>00199         dst-&gt;ln_dirent_repaired = cpu_to_le64(src-&gt;ln_dirent_repaired);
<a name="l00200"></a>00200         dst-&gt;ln_linkea_repaired = cpu_to_le64(src-&gt;ln_linkea_repaired);
<a name="l00201"></a>00201         dst-&gt;ln_mul_linked_checked = cpu_to_le64(src-&gt;ln_mul_linked_checked);
<a name="l00202"></a>00202         dst-&gt;ln_mul_linked_repaired = cpu_to_le64(src-&gt;ln_mul_linked_repaired);
<a name="l00203"></a>00203         dst-&gt;ln_unknown_inconsistency =
<a name="l00204"></a>00204                                 cpu_to_le64(src-&gt;ln_unknown_inconsistency);
<a name="l00205"></a>00205         dst-&gt;ln_unmatched_pairs_repaired =
<a name="l00206"></a>00206                                 cpu_to_le64(src-&gt;ln_unmatched_pairs_repaired);
<a name="l00207"></a>00207         dst-&gt;ln_dangling_repaired = cpu_to_le64(src-&gt;ln_dangling_repaired);
<a name="l00208"></a>00208         dst-&gt;ln_mul_ref_repaired = cpu_to_le64(src-&gt;ln_mul_ref_repaired);
<a name="l00209"></a>00209         dst-&gt;ln_bad_type_repaired = cpu_to_le64(src-&gt;ln_bad_type_repaired);
<a name="l00210"></a>00210         dst-&gt;ln_lost_dirent_repaired =
<a name="l00211"></a>00211                                 cpu_to_le64(src-&gt;ln_lost_dirent_repaired);
<a name="l00212"></a>00212         dst-&gt;ln_striped_dirs_scanned =
<a name="l00213"></a>00213                                 cpu_to_le64(src-&gt;ln_striped_dirs_scanned);
<a name="l00214"></a>00214         dst-&gt;ln_striped_dirs_repaired =
<a name="l00215"></a>00215                                 cpu_to_le64(src-&gt;ln_striped_dirs_repaired);
<a name="l00216"></a>00216         dst-&gt;ln_striped_dirs_failed =
<a name="l00217"></a>00217                                 cpu_to_le64(src-&gt;ln_striped_dirs_failed);
<a name="l00218"></a>00218         dst-&gt;ln_striped_dirs_disabled =
<a name="l00219"></a>00219                                 cpu_to_le64(src-&gt;ln_striped_dirs_disabled);
<a name="l00220"></a>00220         dst-&gt;ln_striped_dirs_skipped =
<a name="l00221"></a>00221                                 cpu_to_le64(src-&gt;ln_striped_dirs_skipped);
<a name="l00222"></a>00222         dst-&gt;ln_striped_shards_scanned =
<a name="l00223"></a>00223                                 cpu_to_le64(src-&gt;ln_striped_shards_scanned);
<a name="l00224"></a>00224         dst-&gt;ln_striped_shards_repaired =
<a name="l00225"></a>00225                                 cpu_to_le64(src-&gt;ln_striped_shards_repaired);
<a name="l00226"></a>00226         dst-&gt;ln_striped_shards_failed =
<a name="l00227"></a>00227                                 cpu_to_le64(src-&gt;ln_striped_shards_failed);
<a name="l00228"></a>00228         dst-&gt;ln_striped_shards_skipped =
<a name="l00229"></a>00229                                 cpu_to_le64(src-&gt;ln_striped_shards_skipped);
<a name="l00230"></a>00230         dst-&gt;ln_name_hash_repaired = cpu_to_le64(src-&gt;ln_name_hash_repaired);
<a name="l00231"></a>00231         dst-&gt;ln_local_lpf_scanned = cpu_to_le64(src-&gt;ln_local_lpf_scanned);
<a name="l00232"></a>00232         dst-&gt;ln_local_lpf_moved = cpu_to_le64(src-&gt;ln_local_lpf_moved);
<a name="l00233"></a>00233         dst-&gt;ln_local_lpf_skipped = cpu_to_le64(src-&gt;ln_local_lpf_skipped);
<a name="l00234"></a>00234         dst-&gt;ln_local_lpf_failed = cpu_to_le64(src-&gt;ln_local_lpf_failed);
<a name="l00235"></a>00235         dst-&gt;ln_bitmap_size = cpu_to_le32(src-&gt;ln_bitmap_size);
<a name="l00236"></a>00236 }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_record_failure(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00239"></a>00239                                            <span class="keyword">struct</span> <a class="code" href="structlfsck__instance.html">lfsck_instance</a> *lfsck,
<a name="l00240"></a>00240                                            <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns)
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242         <span class="keyword">struct </span><a class="code" href="structlfsck__position.html">lfsck_position</a> pos;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244         ns-&gt;ln_items_failed++;
<a name="l00245"></a>00245         lfsck_pos_fill(env, lfsck, &amp;pos, <span class="keyword">false</span>);
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (lfsck_pos_is_zero(&amp;ns-&gt;ln_pos_first_inconsistent) ||
<a name="l00247"></a>00247             lfsck_pos_is_eq(&amp;pos, &amp;ns-&gt;ln_pos_first_inconsistent) &lt; 0) {
<a name="l00248"></a>00248                 ns-&gt;ln_pos_first_inconsistent = pos;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250                 CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK hit first non-repaired &quot;</span>
<a name="l00251"></a>00251                        <span class="stringliteral">&quot;inconsistency at the pos [&quot;</span>LPU64<span class="stringliteral">&quot;, &quot;</span>DFID<span class="stringliteral">&quot;, &quot;</span>LPX64<span class="stringliteral">&quot;]\n&quot;</span>,
<a name="l00252"></a>00252                        lfsck_lfsck2name(lfsck),
<a name="l00253"></a>00253                        ns-&gt;ln_pos_first_inconsistent.lp_oit_cookie,
<a name="l00254"></a>00254                        PFID(&amp;ns-&gt;ln_pos_first_inconsistent.lp_dir_parent),
<a name="l00255"></a>00255                        ns-&gt;ln_pos_first_inconsistent.lp_dir_cookie);
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257 }
<a name="l00258"></a>00258 
<a name="l00268"></a>00268 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_load_bitmap(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00269"></a>00269                                        <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l00270"></a>00270 {
<a name="l00271"></a>00271         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *obj    = com-&gt;lc_obj;
<a name="l00272"></a>00272         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad    = com-&gt;lc_data;
<a name="l00273"></a>00273         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns     = com-&gt;lc_file_ram;
<a name="l00274"></a>00274         <span class="keyword">struct </span><a class="code" href="structcfs__bitmap.html">cfs_bitmap</a>                       *bitmap = lad-&gt;lad_bitmap;
<a name="l00275"></a>00275         ssize_t                          size;
<a name="l00276"></a>00276         __u32                            nbits;
<a name="l00277"></a>00277         <span class="keywordtype">int</span>                              rc;
<a name="l00278"></a>00278         ENTRY;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280         <span class="keywordflow">if</span> (com-&gt;lc_lfsck-&gt;li_mdt_descs.ltd_tgts_bitmap-&gt;size &gt;
<a name="l00281"></a>00281             ns-&gt;ln_bitmap_size)
<a name="l00282"></a>00282                 nbits = com-&gt;lc_lfsck-&gt;li_mdt_descs.ltd_tgts_bitmap-&gt;size;
<a name="l00283"></a>00283         <span class="keywordflow">else</span>
<a name="l00284"></a>00284                 nbits = ns-&gt;ln_bitmap_size;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286         <span class="keywordflow">if</span> (unlikely(nbits &lt; BITS_PER_LONG))
<a name="l00287"></a>00287                 nbits = BITS_PER_LONG;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         <span class="keywordflow">if</span> (nbits &gt; bitmap-&gt;size) {
<a name="l00290"></a>00290                 __u32 new_bits = bitmap-&gt;size;
<a name="l00291"></a>00291                 <span class="keyword">struct </span><a class="code" href="structcfs__bitmap.html">cfs_bitmap</a> *new_bitmap;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293                 <span class="keywordflow">while</span> (new_bits &lt; nbits)
<a name="l00294"></a>00294                         new_bits &lt;&lt;= 1;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296                 new_bitmap = CFS_ALLOCATE_BITMAP(new_bits);
<a name="l00297"></a>00297                 <span class="keywordflow">if</span> (new_bitmap == NULL)
<a name="l00298"></a>00298                         RETURN(-ENOMEM);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300                 lad-&gt;lad_bitmap = new_bitmap;
<a name="l00301"></a>00301                 CFS_FREE_BITMAP(bitmap);
<a name="l00302"></a>00302                 bitmap = new_bitmap;
<a name="l00303"></a>00303         }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305         <span class="keywordflow">if</span> (ns-&gt;ln_bitmap_size == 0) {
<a name="l00306"></a>00306                 lad-&gt;lad_incomplete = 0;
<a name="l00307"></a>00307                 CFS_RESET_BITMAP(bitmap);
<a name="l00308"></a>00308 
<a name="l00309"></a>00309                 RETURN(0);
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312         size = (ns-&gt;ln_bitmap_size + 7) &gt;&gt; 3;
<a name="l00313"></a>00313         rc = dt_xattr_get(env, obj,
<a name="l00314"></a>00314                           lfsck_buf_get(env, bitmap-&gt;data, size),
<a name="l00315"></a>00315                           XATTR_NAME_LFSCK_BITMAP);
<a name="l00316"></a>00316         <span class="keywordflow">if</span> (rc != size)
<a name="l00317"></a>00317                 RETURN(rc &gt;= 0 ? -EINVAL : rc);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319         <span class="keywordflow">if</span> (cfs_bitmap_check_empty(bitmap))
<a name="l00320"></a>00320                 lad-&gt;lad_incomplete = 0;
<a name="l00321"></a>00321         <span class="keywordflow">else</span>
<a name="l00322"></a>00322                 lad-&gt;lad_incomplete = 1;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324         RETURN(0);
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 
<a name="l00336"></a>00336 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_load(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00337"></a>00337                                 <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l00338"></a>00338 {
<a name="l00339"></a>00339         <span class="keywordtype">int</span> len = com-&gt;lc_file_size;
<a name="l00340"></a>00340         <span class="keywordtype">int</span> rc;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342         rc = dt_xattr_get(env, com-&gt;lc_obj,
<a name="l00343"></a>00343                           lfsck_buf_get(env, com-&gt;lc_file_disk, len),
<a name="l00344"></a>00344                           XATTR_NAME_LFSCK_NAMESPACE);
<a name="l00345"></a>00345         <span class="keywordflow">if</span> (rc == len) {
<a name="l00346"></a>00346                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l00347"></a>00347 
<a name="l00348"></a>00348                 lfsck_namespace_le_to_cpu(ns,
<a name="l00349"></a>00349                                 (<span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *)com-&gt;lc_file_disk);
<a name="l00350"></a>00350                 <span class="keywordflow">if</span> (ns-&gt;ln_magic != LFSCK_NAMESPACE_MAGIC) {
<a name="l00351"></a>00351                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: invalid lfsck_namespace magic &quot;</span>
<a name="l00352"></a>00352                                <span class="stringliteral">&quot;%#x != %#x\n&quot;</span>, lfsck_lfsck2name(com-&gt;lc_lfsck),
<a name="l00353"></a>00353                                ns-&gt;ln_magic, LFSCK_NAMESPACE_MAGIC);
<a name="l00354"></a>00354                         rc = -ESTALE;
<a name="l00355"></a>00355                 } <span class="keywordflow">else</span> {
<a name="l00356"></a>00356                         rc = 0;
<a name="l00357"></a>00357                 }
<a name="l00358"></a>00358         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENODATA) {
<a name="l00359"></a>00359                 CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: fail to load lfsck_namespace, &quot;</span>
<a name="l00360"></a>00360                        <span class="stringliteral">&quot;expected = %d: rc = %d\n&quot;</span>,
<a name="l00361"></a>00361                        lfsck_lfsck2name(com-&gt;lc_lfsck), len, rc);
<a name="l00362"></a>00362                 <span class="keywordflow">if</span> (rc &gt;= 0)
<a name="l00363"></a>00363                         rc = -ESTALE;
<a name="l00364"></a>00364         }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         <span class="keywordflow">return</span> rc;
<a name="l00367"></a>00367 }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_store(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00370"></a>00370                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *obj    = com-&gt;lc_obj;
<a name="l00373"></a>00373         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l00374"></a>00374         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns     = com-&gt;lc_file_ram;
<a name="l00375"></a>00375         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad    = com-&gt;lc_data;
<a name="l00376"></a>00376         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck_obj2dev(obj);
<a name="l00377"></a>00377         <span class="keyword">struct </span><a class="code" href="structcfs__bitmap.html">cfs_bitmap</a>               *bitmap = NULL;
<a name="l00378"></a>00378         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *handle;
<a name="l00379"></a>00379         __u32                            nbits  = 0;
<a name="l00380"></a>00380         <span class="keywordtype">int</span>                              len    = com-&gt;lc_file_size;
<a name="l00381"></a>00381         <span class="keywordtype">int</span>                              rc;
<a name="l00382"></a>00382         ENTRY;
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         <span class="keywordflow">if</span> (lad != NULL) {
<a name="l00385"></a>00385                 bitmap = lad-&gt;lad_bitmap;
<a name="l00386"></a>00386                 nbits = bitmap-&gt;size;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388                 LASSERT(nbits &gt; 0);
<a name="l00389"></a>00389                 LASSERTF((nbits &amp; 7) == 0, <span class="stringliteral">&quot;Invalid nbits %u\n&quot;</span>, nbits);
<a name="l00390"></a>00390         }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392         ns-&gt;ln_bitmap_size = nbits;
<a name="l00393"></a>00393         lfsck_namespace_cpu_to_le((<span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *)com-&gt;lc_file_disk,
<a name="l00394"></a>00394                                   ns);
<a name="l00395"></a>00395         handle = dt_trans_create(env, dev);
<a name="l00396"></a>00396         <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l00397"></a>00397                 GOTO(log, rc = PTR_ERR(handle));
<a name="l00398"></a>00398 
<a name="l00399"></a>00399         rc = dt_declare_xattr_set(env, obj,
<a name="l00400"></a>00400                                   lfsck_buf_get(env, com-&gt;lc_file_disk, len),
<a name="l00401"></a>00401                                   XATTR_NAME_LFSCK_NAMESPACE, 0, handle);
<a name="l00402"></a>00402         <span class="keywordflow">if</span> (rc != 0)
<a name="l00403"></a>00403                 GOTO(out, rc);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         <span class="keywordflow">if</span> (bitmap != NULL) {
<a name="l00406"></a>00406                 rc = dt_declare_xattr_set(env, obj,
<a name="l00407"></a>00407                                 lfsck_buf_get(env, bitmap-&gt;data, nbits &gt;&gt; 3),
<a name="l00408"></a>00408                                 XATTR_NAME_LFSCK_BITMAP, 0, handle);
<a name="l00409"></a>00409                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00410"></a>00410                         GOTO(out, rc);
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413         rc = dt_trans_start_local(env, dev, handle);
<a name="l00414"></a>00414         <span class="keywordflow">if</span> (rc != 0)
<a name="l00415"></a>00415                 GOTO(out, rc);
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         rc = dt_xattr_set(env, obj,
<a name="l00418"></a>00418                           lfsck_buf_get(env, com-&gt;lc_file_disk, len),
<a name="l00419"></a>00419                           XATTR_NAME_LFSCK_NAMESPACE, 0, handle);
<a name="l00420"></a>00420         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; bitmap != NULL)
<a name="l00421"></a>00421                 rc = dt_xattr_set(env, obj,
<a name="l00422"></a>00422                                   lfsck_buf_get(env, bitmap-&gt;data, nbits &gt;&gt; 3),
<a name="l00423"></a>00423                                   XATTR_NAME_LFSCK_BITMAP, 0, handle);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425         GOTO(out, rc);
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 out:
<a name="l00428"></a>00428         dt_trans_stop(env, dev, handle);
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 log:
<a name="l00431"></a>00431         <span class="keywordflow">if</span> (rc != 0)
<a name="l00432"></a>00432                 CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: fail to store lfsck_namespace: rc = %d\n&quot;</span>,
<a name="l00433"></a>00433                        lfsck_lfsck2name(lfsck), rc);
<a name="l00434"></a>00434         <span class="keywordflow">return</span> rc;
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *
<a name="l00438"></a>00438 lfsck_namespace_load_one_trace_file(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00439"></a>00439                                     <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l00440"></a>00440                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *parent,
<a name="l00441"></a>00441                                     <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">bool</span> reset)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck = com-&gt;lc_lfsck;
<a name="l00444"></a>00444         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *obj;
<a name="l00445"></a>00445         <span class="keywordtype">int</span>                      rc;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447         <span class="keywordflow">if</span> (reset) {
<a name="l00448"></a>00448                 rc = local_object_unlink(env, lfsck-&gt;li_bottom, parent, name);
<a name="l00449"></a>00449                 <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -ENOENT)
<a name="l00450"></a>00450                         <span class="keywordflow">return</span> ERR_PTR(rc);
<a name="l00451"></a>00451         }
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         obj = local_index_find_or_create(env, lfsck-&gt;li_los, parent, name,
<a name="l00454"></a>00454                                          S_IFREG | S_IRUGO | S_IWUSR,
<a name="l00455"></a>00455                                          &amp;dt_lfsck_features);
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         <span class="keywordflow">return</span> obj;
<a name="l00458"></a>00458 }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_load_sub_trace_files(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00461"></a>00461                                                 <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l00462"></a>00462                                                 <span class="keywordtype">bool</span> reset)
<a name="l00463"></a>00463 {
<a name="l00464"></a>00464         <span class="keywordtype">char</span>                            *name = lfsck_env_info(env)-&gt;lti_key;
<a name="l00465"></a>00465         <span class="keyword">struct </span><a class="code" href="structlfsck__sub__trace__obj.html">lfsck_sub_trace_obj</a>      *lsto;
<a name="l00466"></a>00466         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *obj;
<a name="l00467"></a>00467         <span class="keywordtype">int</span>                              rc;
<a name="l00468"></a>00468         <span class="keywordtype">int</span>                              i;
<a name="l00469"></a>00469 
<a name="l00470"></a>00470         <span class="keywordflow">for</span> (i = 0, lsto = &amp;com-&gt;lc_sub_trace_objs[0];
<a name="l00471"></a>00471              i &lt; LFSCK_STF_COUNT; i++, lsto++) {
<a name="l00472"></a>00472                 snprintf(name, NAME_MAX, <span class="stringliteral">&quot;%s_%02d&quot;</span>, LFSCK_NAMESPACE, i);
<a name="l00473"></a>00473                 <span class="keywordflow">if</span> (lsto-&gt;lsto_obj != NULL) {
<a name="l00474"></a>00474                         <span class="keywordflow">if</span> (!reset)
<a name="l00475"></a>00475                                 <span class="keywordflow">continue</span>;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477                         lfsck_object_put(env, lsto-&gt;lsto_obj);
<a name="l00478"></a>00478                         lsto-&gt;lsto_obj = NULL;
<a name="l00479"></a>00479                 }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481                 obj = lfsck_namespace_load_one_trace_file(env, com,
<a name="l00482"></a>00482                                 com-&gt;lc_lfsck-&gt;li_lfsck_dir, name, reset);
<a name="l00483"></a>00483                 <span class="keywordflow">if</span> (IS_ERR(obj))
<a name="l00484"></a>00484                         <span class="keywordflow">return</span> PTR_ERR(obj);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486                 lsto-&gt;lsto_obj = obj;
<a name="l00487"></a>00487                 rc = obj-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2" title="Try object as an index.">do_index_try</a>(env, obj, &amp;dt_lfsck_features);
<a name="l00488"></a>00488                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00489"></a>00489                         <span class="keywordflow">return</span> rc;
<a name="l00490"></a>00490         }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         <span class="keywordflow">return</span> 0;
<a name="l00493"></a>00493 }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00496"></a>00496                                 <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l00497"></a>00497 {
<a name="l00498"></a>00498         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l00499"></a>00499         <span class="keywordtype">int</span> rc;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501         memset(ns, 0, <span class="keyword">sizeof</span>(*ns));
<a name="l00502"></a>00502         ns-&gt;ln_magic = LFSCK_NAMESPACE_MAGIC;
<a name="l00503"></a>00503         ns-&gt;ln_status = LS_INIT;
<a name="l00504"></a>00504         down_write(&amp;com-&gt;lc_sem);
<a name="l00505"></a>00505         rc = lfsck_namespace_store(env, com);
<a name="l00506"></a>00506         up_write(&amp;com-&gt;lc_sem);
<a name="l00507"></a>00507         <span class="keywordflow">if</span> (rc == 0)
<a name="l00508"></a>00508                 rc = lfsck_namespace_load_sub_trace_files(env, com, <span class="keyword">true</span>);
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         <span class="keywordflow">return</span> rc;
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00525"></a>00525 <span class="keywordtype">int</span> lfsck_namespace_trace_update(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00526"></a>00526                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l00527"></a>00527                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l00528"></a>00528                                  <span class="keyword">const</span> __u8 flags, <span class="keywordtype">bool</span> add)
<a name="l00529"></a>00529 {
<a name="l00530"></a>00530         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck  = com-&gt;lc_lfsck;
<a name="l00531"></a>00531         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *obj;
<a name="l00532"></a>00532         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           *key    = &amp;lfsck_env_info(env)-&gt;lti_fid3;
<a name="l00533"></a>00533         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>        *dev;
<a name="l00534"></a>00534         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *th     = NULL;
<a name="l00535"></a>00535         <span class="keywordtype">int</span>                      idx;
<a name="l00536"></a>00536         <span class="keywordtype">int</span>                      rc     = 0;
<a name="l00537"></a>00537         __u8                     old    = 0;
<a name="l00538"></a>00538         __u8                     <span class="keyword">new</span>    = 0;
<a name="l00539"></a>00539         ENTRY;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         LASSERT(flags != 0);
<a name="l00542"></a>00542 
<a name="l00543"></a>00543         <span class="keywordflow">if</span> (unlikely(!fid_is_sane(fid)))
<a name="l00544"></a>00544                 RETURN(0);
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         idx = lfsck_sub_trace_file_fid2idx(fid);
<a name="l00547"></a>00547         obj = com-&gt;lc_sub_trace_objs[idx].lsto_obj;
<a name="l00548"></a>00548         dev = lfsck_obj2dev(obj);
<a name="l00549"></a>00549         mutex_lock(&amp;com-&gt;lc_sub_trace_objs[idx].lsto_mutex);
<a name="l00550"></a>00550         fid_cpu_to_be(key, fid);
<a name="l00551"></a>00551         rc = dt_lookup(env, obj, (<span class="keyword">struct</span> dt_rec *)&amp;old,
<a name="l00552"></a>00552                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key);
<a name="l00553"></a>00553         <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l00554"></a>00554                 <span class="keywordflow">if</span> (!add)
<a name="l00555"></a>00555                         GOTO(unlock, rc = 0);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557                 old = 0;
<a name="l00558"></a>00558                 <span class="keyword">new</span> = flags;
<a name="l00559"></a>00559         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 0) {
<a name="l00560"></a>00560                 <span class="keywordflow">if</span> (add) {
<a name="l00561"></a>00561                         <span class="keywordflow">if</span> ((old &amp; flags) == flags)
<a name="l00562"></a>00562                                 GOTO(unlock, rc = 0);
<a name="l00563"></a>00563 
<a name="l00564"></a>00564                         <span class="keyword">new</span> = old | flags;
<a name="l00565"></a>00565                 } <span class="keywordflow">else</span> {
<a name="l00566"></a>00566                         <span class="keywordflow">if</span> ((old &amp; flags) == 0)
<a name="l00567"></a>00567                                 GOTO(unlock, rc = 0);
<a name="l00568"></a>00568 
<a name="l00569"></a>00569                         <span class="keyword">new</span> = old &amp; ~flags;
<a name="l00570"></a>00570                 }
<a name="l00571"></a>00571         } <span class="keywordflow">else</span> {
<a name="l00572"></a>00572                 GOTO(log, rc);
<a name="l00573"></a>00573         }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         th = dt_trans_create(env, dev);
<a name="l00576"></a>00576         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l00577"></a>00577                 GOTO(log, rc = PTR_ERR(th));
<a name="l00578"></a>00578 
<a name="l00579"></a>00579         <span class="keywordflow">if</span> (old != 0) {
<a name="l00580"></a>00580                 rc = dt_declare_delete(env, obj,
<a name="l00581"></a>00581                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th);
<a name="l00582"></a>00582                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00583"></a>00583                         GOTO(log, rc);
<a name="l00584"></a>00584         }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586         <span class="keywordflow">if</span> (<span class="keyword">new</span> != 0) {
<a name="l00587"></a>00587                 rc = dt_declare_insert(env, obj,
<a name="l00588"></a>00588                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)&amp;<span class="keyword">new</span>,
<a name="l00589"></a>00589                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th);
<a name="l00590"></a>00590                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00591"></a>00591                         GOTO(log, rc);
<a name="l00592"></a>00592         }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594         rc = dt_trans_start_local(env, dev, th);
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (rc != 0)
<a name="l00596"></a>00596                 GOTO(log, rc);
<a name="l00597"></a>00597 
<a name="l00598"></a>00598         <span class="keywordflow">if</span> (old != 0) {
<a name="l00599"></a>00599                 rc = dt_delete(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th);
<a name="l00600"></a>00600                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00601"></a>00601                         GOTO(log, rc);
<a name="l00602"></a>00602         }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604         <span class="keywordflow">if</span> (<span class="keyword">new</span> != 0) {
<a name="l00605"></a>00605                 rc = dt_insert(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)&amp;<span class="keyword">new</span>,
<a name="l00606"></a>00606                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th, 1);
<a name="l00607"></a>00607                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00608"></a>00608                         GOTO(log, rc);
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         GOTO(log, rc);
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 log:
<a name="l00614"></a>00614         <span class="keywordflow">if</span> (th != NULL &amp;&amp; !IS_ERR(th))
<a name="l00615"></a>00615                 dt_trans_stop(env, dev, th);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK %s flags for &quot;</span>DFID<span class="stringliteral">&quot; in the &quot;</span>
<a name="l00618"></a>00618                <span class="stringliteral">&quot;trace file, flags %x, old %x, new %x: rc = %d\n&quot;</span>,
<a name="l00619"></a>00619                lfsck_lfsck2name(lfsck), add ? <span class="stringliteral">&quot;add&quot;</span> : <span class="stringliteral">&quot;del&quot;</span>, PFID(fid),
<a name="l00620"></a>00620                (__u32)flags, (__u32)old, (__u32)<span class="keyword">new</span>, rc);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 unlock:
<a name="l00623"></a>00623         mutex_unlock(&amp;com-&gt;lc_sub_trace_objs[idx].lsto_mutex);
<a name="l00624"></a>00624 
<a name="l00625"></a>00625         <span class="keywordflow">return</span> rc;
<a name="l00626"></a>00626 }
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 <span class="keywordtype">int</span> lfsck_namespace_check_exist(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00629"></a>00629                                 <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dir,
<a name="l00630"></a>00630                                 <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l00631"></a>00631 {
<a name="l00632"></a>00632         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>    *fid = &amp;lfsck_env_info(env)-&gt;lti_fid;
<a name="l00633"></a>00633         <span class="keywordtype">int</span>               rc;
<a name="l00634"></a>00634         ENTRY;
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(obj)))
<a name="l00637"></a>00637                 RETURN(LFSCK_NAMEENTRY_DEAD);
<a name="l00638"></a>00638 
<a name="l00639"></a>00639         rc = dt_lookup(env, dir, (<span class="keyword">struct</span> dt_rec *)fid,
<a name="l00640"></a>00640                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name);
<a name="l00641"></a>00641         <span class="keywordflow">if</span> (rc == -ENOENT)
<a name="l00642"></a>00642                 RETURN(LFSCK_NAMEENTRY_REMOVED);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00645"></a>00645                 RETURN(rc);
<a name="l00646"></a>00646 
<a name="l00647"></a>00647         <span class="keywordflow">if</span> (!lu_fid_eq(fid, lfsck_dto2fid(obj)))
<a name="l00648"></a>00648                 RETURN(LFSCK_NAMEENTRY_RECREATED);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         RETURN(0);
<a name="l00651"></a>00651 }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_declare_namespace_exec_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00654"></a>00654                                             <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l00655"></a>00655                                             <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l00656"></a>00656 {
<a name="l00657"></a>00657         <span class="keywordtype">int</span> rc;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         <span class="comment">/* For destroying all invalid linkEA entries. */</span>
<a name="l00660"></a>00660         rc = dt_declare_xattr_del(env, obj, XATTR_NAME_LINK, handle);
<a name="l00661"></a>00661         <span class="keywordflow">if</span> (rc != 0)
<a name="l00662"></a>00662                 <span class="keywordflow">return</span> rc;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         <span class="comment">/* For insert new linkEA entry. */</span>
<a name="l00665"></a>00665         rc = dt_declare_xattr_set(env, obj,
<a name="l00666"></a>00666                         lfsck_buf_get_const(env, NULL, DEFAULT_LINKEA_SIZE),
<a name="l00667"></a>00667                         XATTR_NAME_LINK, 0, handle);
<a name="l00668"></a>00668         <span class="keywordflow">return</span> rc;
<a name="l00669"></a>00669 }
<a name="l00670"></a>00670 
<a name="l00671"></a>00671 <span class="keywordtype">int</span> __lfsck_links_read(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l00672"></a>00672                        <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata)
<a name="l00673"></a>00673 {
<a name="l00674"></a>00674         <span class="keywordtype">int</span> rc;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676         <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf == NULL)
<a name="l00677"></a>00677                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00678"></a>00678 
<a name="l00679"></a>00679         <span class="keywordflow">if</span> (!dt_object_exists(obj))
<a name="l00680"></a>00680                 <span class="keywordflow">return</span> -ENOENT;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682         rc = dt_xattr_get(env, obj, ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>, XATTR_NAME_LINK);
<a name="l00683"></a>00683         <span class="keywordflow">if</span> (rc == -ERANGE) {
<a name="l00684"></a>00684                 <span class="comment">/* Buf was too small, figure out what we need. */</span>
<a name="l00685"></a>00685                 rc = dt_xattr_get(env, obj, &amp;<a class="code" href="group__lu.html#ga3daaf59b14be927dc4227c6fc6635c6d" title="null buffer">LU_BUF_NULL</a>, XATTR_NAME_LINK);
<a name="l00686"></a>00686                 <span class="keywordflow">if</span> (rc &lt;= 0)
<a name="l00687"></a>00687                         <span class="keywordflow">return</span> rc;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689                 lu_buf_realloc(ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>, rc);
<a name="l00690"></a>00690                 <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf == NULL)
<a name="l00691"></a>00691                         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00692"></a>00692 
<a name="l00693"></a>00693                 rc = dt_xattr_get(env, obj, ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>, XATTR_NAME_LINK);
<a name="l00694"></a>00694         }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l00697"></a>00697                 rc = linkea_init(ldata);
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         <span class="keywordflow">return</span> rc;
<a name="l00700"></a>00700 }
<a name="l00701"></a>00701 
<a name="l00714"></a>00714 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_links_remove(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00715"></a>00715                                         <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l00716"></a>00716                                         <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj)
<a name="l00717"></a>00717 {
<a name="l00718"></a>00718         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l00719"></a>00719         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck_obj2dev(obj);
<a name="l00720"></a>00720         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l00721"></a>00721         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l00722"></a>00722         ENTRY;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         LASSERT(dt_object_remote(obj) == 0);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         th = dt_trans_create(env, dev);
<a name="l00727"></a>00727         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l00728"></a>00728                 GOTO(log, rc = PTR_ERR(th));
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         rc = dt_declare_xattr_del(env, obj, XATTR_NAME_LINK, th);
<a name="l00731"></a>00731         <span class="keywordflow">if</span> (rc != 0)
<a name="l00732"></a>00732                 GOTO(stop, rc);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734         rc = dt_trans_start_local(env, dev, th);
<a name="l00735"></a>00735         <span class="keywordflow">if</span> (rc != 0)
<a name="l00736"></a>00736                 GOTO(stop, rc);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         dt_write_lock(env, obj, 0);
<a name="l00739"></a>00739         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(obj)))
<a name="l00740"></a>00740                 GOTO(unlock, rc = -ENOENT);
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         <span class="keywordflow">if</span> (lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN)
<a name="l00743"></a>00743                 GOTO(unlock, rc = 0);
<a name="l00744"></a>00744 
<a name="l00745"></a>00745         rc = dt_xattr_del(env, obj, XATTR_NAME_LINK, th);
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         GOTO(unlock, rc);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 unlock:
<a name="l00750"></a>00750         dt_write_unlock(env, obj);
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 stop:
<a name="l00753"></a>00753         dt_trans_stop(env, dev, th);
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 log:
<a name="l00756"></a>00756         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK remove invalid linkEA &quot;</span>
<a name="l00757"></a>00757                <span class="stringliteral">&quot;for the object &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l00758"></a>00758                lfsck_lfsck2name(lfsck), PFID(lfsck_dto2fid(obj)), rc);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00761"></a>00761                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l00762"></a>00762 
<a name="l00763"></a>00763                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l00764"></a>00764         }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="keywordflow">return</span> rc;
<a name="l00767"></a>00767 }
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_links_write(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l00770"></a>00770                              <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *handle)
<a name="l00771"></a>00771 {
<a name="l00772"></a>00772         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf = lfsck_buf_get_const(env,
<a name="l00773"></a>00773                                                        ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l00774"></a>00774                                                        ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         <span class="keywordflow">return</span> dt_xattr_set(env, obj, buf, XATTR_NAME_LINK, 0, handle);
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_unpack_linkea_entry(<span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l00780"></a>00780                                                 <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *cname,
<a name="l00781"></a>00781                                                 <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l00782"></a>00782                                                 <span class="keywordtype">char</span> *buf)
<a name="l00783"></a>00783 {
<a name="l00784"></a>00784         linkea_entry_unpack(ldata-&gt;ld_lee, &amp;ldata-&gt;ld_reclen, cname, pfid);
<a name="l00785"></a>00785         <span class="comment">/* To guarantee the &apos;name&apos; is terminated with &apos;0&apos;. */</span>
<a name="l00786"></a>00786         memcpy(buf, cname-&gt;ln_name, cname-&gt;ln_namelen);
<a name="l00787"></a>00787         buf[cname-&gt;ln_namelen] = 0;
<a name="l00788"></a>00788         cname-&gt;ln_name = buf;
<a name="l00789"></a>00789 }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_filter_linkea_entry(<span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l00792"></a>00792                                                <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *cname,
<a name="l00793"></a>00793                                                <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l00794"></a>00794                                                <span class="keywordtype">bool</span> <span class="keyword">remove</span>)
<a name="l00795"></a>00795 {
<a name="l00796"></a>00796         <span class="keyword">struct </span><a class="code" href="structlink__ea__entry.html" title="Hardlink data is name and parent fid.">link_ea_entry</a>    *oldlee;
<a name="l00797"></a>00797         <span class="keywordtype">int</span>                      oldlen;
<a name="l00798"></a>00798         <span class="keywordtype">int</span>                      repeated = 0;
<a name="l00799"></a>00799 
<a name="l00800"></a>00800         oldlee = ldata-&gt;ld_lee;
<a name="l00801"></a>00801         oldlen = ldata-&gt;ld_reclen;
<a name="l00802"></a>00802         linkea_next_entry(ldata);
<a name="l00803"></a>00803         <span class="keywordflow">while</span> (ldata-&gt;ld_lee != NULL) {
<a name="l00804"></a>00804                 ldata-&gt;ld_reclen = (ldata-&gt;ld_lee-&gt;<a class="code" href="structlink__ea__entry.html#ac329c586a9a51a478d70ac9d3694bf2a" title="__u16 stored big-endian, unaligned">lee_reclen</a>[0] &lt;&lt; 8) |
<a name="l00805"></a>00805                                    ldata-&gt;ld_lee-&gt;<a class="code" href="structlink__ea__entry.html#ac329c586a9a51a478d70ac9d3694bf2a" title="__u16 stored big-endian, unaligned">lee_reclen</a>[1];
<a name="l00806"></a>00806                 if (unlikely(ldata-&gt;ld_reclen == oldlen &amp;&amp;
<a name="l00807"></a>00807                              memcmp(ldata-&gt;ld_lee, oldlee, oldlen) == 0)) {
<a name="l00808"></a>00808                         repeated++;
<a name="l00809"></a>00809                         <span class="keywordflow">if</span> (!<span class="keyword">remove</span>)
<a name="l00810"></a>00810                                 <span class="keywordflow">break</span>;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812                         linkea_del_buf(ldata, cname);
<a name="l00813"></a>00813                 } <span class="keywordflow">else</span> {
<a name="l00814"></a>00814                         linkea_next_entry(ldata);
<a name="l00815"></a>00815                 }
<a name="l00816"></a>00816         }
<a name="l00817"></a>00817         ldata-&gt;ld_lee = oldlee;
<a name="l00818"></a>00818         ldata-&gt;ld_reclen = oldlen;
<a name="l00819"></a>00819 
<a name="l00820"></a>00820         <span class="keywordflow">return</span> repeated;
<a name="l00821"></a>00821 }
<a name="l00822"></a>00822 
<a name="l00861"></a>00861 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_insert_orphan(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00862"></a>00862                                          <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l00863"></a>00863                                          <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *orphan,
<a name="l00864"></a>00864                                          <span class="keyword">const</span> <span class="keywordtype">char</span> *infix, <span class="keyword">const</span> <span class="keywordtype">char</span> *type,
<a name="l00865"></a>00865                                          <span class="keywordtype">int</span> *count)
<a name="l00866"></a>00866 {
<a name="l00867"></a>00867         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l00868"></a>00868         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>                  *cname  = &amp;info-&gt;lti_name;
<a name="l00869"></a>00869         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>            *rec    = &amp;info-&gt;lti_dt_rec;
<a name="l00870"></a>00870         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>                  *la     = &amp;info-&gt;lti_la2;
<a name="l00871"></a>00871         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *cfid   = lfsck_dto2fid(orphan);
<a name="l00872"></a>00872         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *pfid;
<a name="l00873"></a>00873         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>                    tfid;
<a name="l00874"></a>00874         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l00875"></a>00875         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck_obj2dev(orphan);
<a name="l00876"></a>00876         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *parent;
<a name="l00877"></a>00877         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l00878"></a>00878         <span class="keyword">struct </span><a class="code" href="structlfsck__lock__handle.html">lfsck_lock_handle</a>        *pllh   = &amp;info-&gt;lti_llh;
<a name="l00879"></a>00879         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>             clh    = { 0 };
<a name="l00880"></a>00880         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>               ldata  = { NULL };
<a name="l00881"></a>00881         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                    linkea_buf;
<a name="l00882"></a>00882         <span class="keywordtype">int</span>                              namelen;
<a name="l00883"></a>00883         <span class="keywordtype">int</span>                              idx    = 0;
<a name="l00884"></a>00884         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l00885"></a>00885         <span class="keywordtype">bool</span>                             exist  = <span class="keyword">false</span>;
<a name="l00886"></a>00886         ENTRY;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         cname-&gt;ln_name = NULL;
<a name="l00889"></a>00889         <span class="keywordflow">if</span> (unlikely(lfsck-&gt;li_lpf_obj == NULL))
<a name="l00890"></a>00890                 GOTO(log, rc = -ENXIO);
<a name="l00891"></a>00891 
<a name="l00892"></a>00892         parent = lfsck-&gt;li_lpf_obj;
<a name="l00893"></a>00893         pfid = lfsck_dto2fid(parent);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 again:
<a name="l00896"></a>00896         <span class="keywordflow">do</span> {
<a name="l00897"></a>00897                 namelen = snprintf(info-&gt;lti_key, NAME_MAX, DFID<span class="stringliteral">&quot;%s-%s-%d&quot;</span>,
<a name="l00898"></a>00898                                    PFID(cfid), infix, type, idx++);
<a name="l00899"></a>00899                 rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)&amp;tfid,
<a name="l00900"></a>00900                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)info-&gt;lti_key);
<a name="l00901"></a>00901                 <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -ENOENT)
<a name="l00902"></a>00902                         GOTO(log, rc);
<a name="l00903"></a>00903 
<a name="l00904"></a>00904                 <span class="keywordflow">if</span> (unlikely(rc == 0 &amp;&amp; lu_fid_eq(cfid, &amp;tfid)))
<a name="l00905"></a>00905                         exist = <span class="keyword">true</span>;
<a name="l00906"></a>00906         } <span class="keywordflow">while</span> (rc == 0 &amp;&amp; !exist);
<a name="l00907"></a>00907 
<a name="l00908"></a>00908         rc = lfsck_lock(env, lfsck, parent, info-&gt;lti_key, pllh,
<a name="l00909"></a>00909                         MDS_INODELOCK_UPDATE, LCK_PW);
<a name="l00910"></a>00910         <span class="keywordflow">if</span> (rc != 0)
<a name="l00911"></a>00911                 GOTO(log, rc);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913         <span class="comment">/* Re-check whether the name conflict with othrs after taken</span>
<a name="l00914"></a>00914 <span class="comment">         * the ldlm lock. */</span>
<a name="l00915"></a>00915         rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)&amp;tfid,
<a name="l00916"></a>00916                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)info-&gt;lti_key);
<a name="l00917"></a>00917         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00918"></a>00918                 <span class="keywordflow">if</span> (!lu_fid_eq(cfid, &amp;tfid)) {
<a name="l00919"></a>00919                         exist = <span class="keyword">false</span>;
<a name="l00920"></a>00920                         lfsck_unlock(pllh);
<a name="l00921"></a>00921                         <span class="keywordflow">goto</span> again;
<a name="l00922"></a>00922                 }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924                 exist = <span class="keyword">true</span>;
<a name="l00925"></a>00925         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENOENT) {
<a name="l00926"></a>00926                 GOTO(log, rc);
<a name="l00927"></a>00927         } <span class="keywordflow">else</span> {
<a name="l00928"></a>00928                 exist = <span class="keyword">false</span>;
<a name="l00929"></a>00929         }
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         cname-&gt;ln_name = info-&gt;lti_key;
<a name="l00932"></a>00932         cname-&gt;ln_namelen = namelen;
<a name="l00933"></a>00933         rc = linkea_data_new(&amp;ldata, &amp;info-&gt;lti_linkea_buf2);
<a name="l00934"></a>00934         <span class="keywordflow">if</span> (rc != 0)
<a name="l00935"></a>00935                 GOTO(log, rc);
<a name="l00936"></a>00936 
<a name="l00937"></a>00937         rc = linkea_add_buf(&amp;ldata, cname, pfid);
<a name="l00938"></a>00938         <span class="keywordflow">if</span> (rc != 0)
<a name="l00939"></a>00939                 GOTO(log, rc);
<a name="l00940"></a>00940 
<a name="l00941"></a>00941         rc = lfsck_ibits_lock(env, lfsck, orphan, &amp;clh,
<a name="l00942"></a>00942                               MDS_INODELOCK_UPDATE | MDS_INODELOCK_LOOKUP |
<a name="l00943"></a>00943                               MDS_INODELOCK_XATTR, LCK_EX);
<a name="l00944"></a>00944         <span class="keywordflow">if</span> (rc != 0)
<a name="l00945"></a>00945                 GOTO(log, rc);
<a name="l00946"></a>00946 
<a name="l00947"></a>00947         lfsck_buf_init(&amp;linkea_buf, ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l00948"></a>00948                        ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l00949"></a>00949         th = dt_trans_create(env, dev);
<a name="l00950"></a>00950         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l00951"></a>00951                 GOTO(log, rc = PTR_ERR(th));
<a name="l00952"></a>00952 
<a name="l00953"></a>00953         <span class="keywordflow">if</span> (S_ISDIR(lfsck_object_type(orphan))) {
<a name="l00954"></a>00954                 rc = dt_declare_delete(env, orphan,
<a name="l00955"></a>00955                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th);
<a name="l00956"></a>00956                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00957"></a>00957                         GOTO(stop, rc);
<a name="l00958"></a>00958 
<a name="l00959"></a>00959                 rec-&gt;rec_type = S_IFDIR;
<a name="l00960"></a>00960                 rec-&gt;rec_fid = pfid;
<a name="l00961"></a>00961                 rc = dt_declare_insert(env, orphan, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l00962"></a>00962                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th);
<a name="l00963"></a>00963                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00964"></a>00964                         GOTO(stop, rc);
<a name="l00965"></a>00965         }
<a name="l00966"></a>00966 
<a name="l00967"></a>00967         rc = dt_declare_xattr_set(env, orphan, &amp;linkea_buf,
<a name="l00968"></a>00968                                   XATTR_NAME_LINK, 0, th);
<a name="l00969"></a>00969         <span class="keywordflow">if</span> (rc != 0)
<a name="l00970"></a>00970                 GOTO(stop, rc);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972         <span class="keywordflow">if</span> (!exist) {
<a name="l00973"></a>00973                 rec-&gt;rec_type = lfsck_object_type(orphan) &amp; S_IFMT;
<a name="l00974"></a>00974                 rec-&gt;rec_fid = cfid;
<a name="l00975"></a>00975                 rc = dt_declare_insert(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l00976"></a>00976                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)cname-&gt;ln_name,
<a name="l00977"></a>00977                                        th);
<a name="l00978"></a>00978                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00979"></a>00979                         GOTO(stop, rc);
<a name="l00980"></a>00980 
<a name="l00981"></a>00981                 <span class="keywordflow">if</span> (S_ISDIR(rec-&gt;rec_type)) {
<a name="l00982"></a>00982                         rc = dt_declare_ref_add(env, parent, th);
<a name="l00983"></a>00983                         <span class="keywordflow">if</span> (rc != 0)
<a name="l00984"></a>00984                                 GOTO(stop, rc);
<a name="l00985"></a>00985                 }
<a name="l00986"></a>00986         }
<a name="l00987"></a>00987 
<a name="l00988"></a>00988         memset(la, 0, <span class="keyword">sizeof</span>(*la));
<a name="l00989"></a>00989         la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = cfs_time_current_sec();
<a name="l00990"></a>00990         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l00991"></a>00991         rc = dt_declare_attr_set(env, orphan, la, th);
<a name="l00992"></a>00992         <span class="keywordflow">if</span> (rc != 0)
<a name="l00993"></a>00993                 GOTO(stop, rc);
<a name="l00994"></a>00994 
<a name="l00995"></a>00995         rc = dt_trans_start_local(env, dev, th);
<a name="l00996"></a>00996         <span class="keywordflow">if</span> (rc != 0)
<a name="l00997"></a>00997                 GOTO(stop, rc);
<a name="l00998"></a>00998 
<a name="l00999"></a>00999         dt_write_lock(env, orphan, 0);
<a name="l01000"></a>01000         rc = lfsck_links_read(env, orphan, &amp;ldata);
<a name="l01001"></a>01001         <span class="keywordflow">if</span> (likely((rc == -ENODATA) || (rc == -EINVAL) ||
<a name="l01002"></a>01002                    (rc == 0 &amp;&amp; ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount == 0))) {
<a name="l01003"></a>01003                 <span class="keywordflow">if</span> (lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN)
<a name="l01004"></a>01004                         GOTO(unlock, rc = 1);
<a name="l01005"></a>01005 
<a name="l01006"></a>01006                 <span class="keywordflow">if</span> (S_ISDIR(lfsck_object_type(orphan))) {
<a name="l01007"></a>01007                         rc = dt_delete(env, orphan,
<a name="l01008"></a>01008                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th);
<a name="l01009"></a>01009                         <span class="keywordflow">if</span> (rc != 0)
<a name="l01010"></a>01010                                 GOTO(unlock, rc);
<a name="l01011"></a>01011 
<a name="l01012"></a>01012                         rec-&gt;rec_type = S_IFDIR;
<a name="l01013"></a>01013                         rec-&gt;rec_fid = pfid;
<a name="l01014"></a>01014                         rc = dt_insert(env, orphan, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01015"></a>01015                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th, 1);
<a name="l01016"></a>01016                         <span class="keywordflow">if</span> (rc != 0)
<a name="l01017"></a>01017                                 GOTO(unlock, rc);
<a name="l01018"></a>01018                 }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020                 rc = dt_xattr_set(env, orphan, &amp;linkea_buf, XATTR_NAME_LINK, 0,
<a name="l01021"></a>01021                                   th);
<a name="l01022"></a>01022         } <span class="keywordflow">else</span> {
<a name="l01023"></a>01023                 <span class="keywordflow">if</span> (rc == 0 &amp;&amp; count != NULL)
<a name="l01024"></a>01024                         *count = ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount;
<a name="l01025"></a>01025 
<a name="l01026"></a>01026                 GOTO(unlock, rc);
<a name="l01027"></a>01027         }
<a name="l01028"></a>01028         dt_write_unlock(env, orphan);
<a name="l01029"></a>01029 
<a name="l01030"></a>01030         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; !exist) {
<a name="l01031"></a>01031                 rec-&gt;rec_type = lfsck_object_type(orphan) &amp; S_IFMT;
<a name="l01032"></a>01032                 rec-&gt;rec_fid = cfid;
<a name="l01033"></a>01033                 rc = dt_insert(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01034"></a>01034                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)cname-&gt;ln_name, th, 1);
<a name="l01035"></a>01035                 <span class="keywordflow">if</span> (rc == 0 &amp;&amp; S_ISDIR(rec-&gt;rec_type)) {
<a name="l01036"></a>01036                         dt_write_lock(env, parent, 0);
<a name="l01037"></a>01037                         rc = dt_ref_add(env, parent, th);
<a name="l01038"></a>01038                         dt_write_unlock(env, parent);
<a name="l01039"></a>01039                 }
<a name="l01040"></a>01040         }
<a name="l01041"></a>01041 
<a name="l01042"></a>01042         <span class="keywordflow">if</span> (rc == 0)
<a name="l01043"></a>01043                 rc = dt_attr_set(env, orphan, la, th);
<a name="l01044"></a>01044 
<a name="l01045"></a>01045         GOTO(stop, rc = (rc == 0 ? 1 : rc));
<a name="l01046"></a>01046 
<a name="l01047"></a>01047 unlock:
<a name="l01048"></a>01048         dt_write_unlock(env, orphan);
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 stop:
<a name="l01051"></a>01051         dt_trans_stop(env, dev, th);
<a name="l01052"></a>01052 
<a name="l01053"></a>01053 log:
<a name="l01054"></a>01054         lfsck_ibits_unlock(&amp;clh, LCK_EX);
<a name="l01055"></a>01055         lfsck_unlock(pllh);
<a name="l01056"></a>01056         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK insert orphan for the &quot;</span>
<a name="l01057"></a>01057                <span class="stringliteral">&quot;object &quot;</span>DFID<span class="stringliteral">&quot;, name = %s: rc = %d\n&quot;</span>,
<a name="l01058"></a>01058                lfsck_lfsck2name(lfsck), PFID(cfid),
<a name="l01059"></a>01059                cname-&gt;ln_name != NULL ? cname-&gt;ln_name : <span class="stringliteral">&quot;&lt;NULL&gt;&quot;</span>, rc);
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01062"></a>01062                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l01063"></a>01063 
<a name="l01064"></a>01064                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l01065"></a>01065         }
<a name="l01066"></a>01066 
<a name="l01067"></a>01067         <span class="keywordflow">return</span> rc;
<a name="l01068"></a>01068 }
<a name="l01069"></a>01069 
<a name="l01092"></a>01092 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_insert_normal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01093"></a>01093                                          <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l01094"></a>01094                                          <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *parent,
<a name="l01095"></a>01095                                          <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child,
<a name="l01096"></a>01096                                          <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l01097"></a>01097 {
<a name="l01098"></a>01098         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l01099"></a>01099         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>                  *la     = &amp;info-&gt;lti_la;
<a name="l01100"></a>01100         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>            *rec    = &amp;info-&gt;lti_dt_rec;
<a name="l01101"></a>01101         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l01102"></a>01102         <span class="comment">/* The child and its name may be on different MDTs. */</span>
<a name="l01103"></a>01103         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *pfid   = lfsck_dto2fid(parent);
<a name="l01104"></a>01104         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *cfid   = lfsck_dto2fid(child);
<a name="l01105"></a>01105         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck-&gt;li_next;
<a name="l01106"></a>01106         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l01107"></a>01107         <span class="keyword">struct </span><a class="code" href="structlfsck__lock__handle.html">lfsck_lock_handle</a>        *llh    = &amp;info-&gt;lti_llh;
<a name="l01108"></a>01108         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l01109"></a>01109         ENTRY;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="comment">/* @parent/@child may be based on lfsck-&gt;li_bottom,</span>
<a name="l01112"></a>01112 <span class="comment">         * but here we need the object based on the lfsck-&gt;li_next. */</span>
<a name="l01113"></a>01113 
<a name="l01114"></a>01114         parent = lfsck_object_locate(dev, parent);
<a name="l01115"></a>01115         <span class="keywordflow">if</span> (IS_ERR(parent))
<a name="l01116"></a>01116                 GOTO(log, rc = PTR_ERR(parent));
<a name="l01117"></a>01117 
<a name="l01118"></a>01118         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, parent)))
<a name="l01119"></a>01119                 GOTO(log, rc = -ENOTDIR);
<a name="l01120"></a>01120 
<a name="l01121"></a>01121         child = lfsck_object_locate(dev, child);
<a name="l01122"></a>01122         <span class="keywordflow">if</span> (IS_ERR(child))
<a name="l01123"></a>01123                 GOTO(log, rc = PTR_ERR(child));
<a name="l01124"></a>01124 
<a name="l01125"></a>01125         <span class="keywordflow">if</span> (lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN)
<a name="l01126"></a>01126                 GOTO(log, rc = 1);
<a name="l01127"></a>01127 
<a name="l01128"></a>01128         rc = lfsck_lock(env, lfsck, parent, name, llh,
<a name="l01129"></a>01129                         MDS_INODELOCK_UPDATE, LCK_PW);
<a name="l01130"></a>01130         <span class="keywordflow">if</span> (rc != 0)
<a name="l01131"></a>01131                 GOTO(log, rc);
<a name="l01132"></a>01132 
<a name="l01133"></a>01133         th = dt_trans_create(env, dev);
<a name="l01134"></a>01134         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l01135"></a>01135                 GOTO(unlock, rc = PTR_ERR(th));
<a name="l01136"></a>01136 
<a name="l01137"></a>01137         rec-&gt;rec_type = lfsck_object_type(child) &amp; S_IFMT;
<a name="l01138"></a>01138         rec-&gt;rec_fid = cfid;
<a name="l01139"></a>01139         rc = dt_declare_insert(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01140"></a>01140                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l01141"></a>01141         <span class="keywordflow">if</span> (rc != 0)
<a name="l01142"></a>01142                 GOTO(stop, rc);
<a name="l01143"></a>01143 
<a name="l01144"></a>01144         <span class="keywordflow">if</span> (S_ISDIR(rec-&gt;rec_type)) {
<a name="l01145"></a>01145                 rc = dt_declare_ref_add(env, parent, th);
<a name="l01146"></a>01146                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01147"></a>01147                         GOTO(stop, rc);
<a name="l01148"></a>01148         }
<a name="l01149"></a>01149 
<a name="l01150"></a>01150         memset(la, 0, <span class="keyword">sizeof</span>(*la));
<a name="l01151"></a>01151         la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = cfs_time_current_sec();
<a name="l01152"></a>01152         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l01153"></a>01153         rc = dt_declare_attr_set(env, parent, la, th);
<a name="l01154"></a>01154         <span class="keywordflow">if</span> (rc != 0)
<a name="l01155"></a>01155                 GOTO(stop, rc);
<a name="l01156"></a>01156 
<a name="l01157"></a>01157         rc = dt_declare_attr_set(env, child, la, th);
<a name="l01158"></a>01158         <span class="keywordflow">if</span> (rc != 0)
<a name="l01159"></a>01159                 GOTO(stop, rc);
<a name="l01160"></a>01160 
<a name="l01161"></a>01161         rc = dt_trans_start_local(env, dev, th);
<a name="l01162"></a>01162         <span class="keywordflow">if</span> (rc != 0)
<a name="l01163"></a>01163                 GOTO(stop, rc);
<a name="l01164"></a>01164 
<a name="l01165"></a>01165         rc = dt_insert(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01166"></a>01166                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th, 1);
<a name="l01167"></a>01167         <span class="keywordflow">if</span> (rc != 0)
<a name="l01168"></a>01168                 GOTO(stop, rc);
<a name="l01169"></a>01169 
<a name="l01170"></a>01170         <span class="keywordflow">if</span> (S_ISDIR(rec-&gt;rec_type)) {
<a name="l01171"></a>01171                 dt_write_lock(env, parent, 0);
<a name="l01172"></a>01172                 rc = dt_ref_add(env, parent, th);
<a name="l01173"></a>01173                 dt_write_unlock(env, parent);
<a name="l01174"></a>01174                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01175"></a>01175                         GOTO(stop, rc);
<a name="l01176"></a>01176         }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178         la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = cfs_time_current_sec();
<a name="l01179"></a>01179         rc = dt_attr_set(env, parent, la, th);
<a name="l01180"></a>01180         <span class="keywordflow">if</span> (rc != 0)
<a name="l01181"></a>01181                 GOTO(stop, rc);
<a name="l01182"></a>01182 
<a name="l01183"></a>01183         rc = dt_attr_set(env, child, la, th);
<a name="l01184"></a>01184 
<a name="l01185"></a>01185         GOTO(stop, rc = (rc == 0 ? 1 : rc));
<a name="l01186"></a>01186 
<a name="l01187"></a>01187 stop:
<a name="l01188"></a>01188         dt_trans_stop(env, dev, th);
<a name="l01189"></a>01189 
<a name="l01190"></a>01190 unlock:
<a name="l01191"></a>01191         lfsck_unlock(llh);
<a name="l01192"></a>01192 
<a name="l01193"></a>01193 log:
<a name="l01194"></a>01194         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK insert object &quot;</span>DFID<span class="stringliteral">&quot; with &quot;</span>
<a name="l01195"></a>01195                <span class="stringliteral">&quot;the name %s and type %o to the parent &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l01196"></a>01196                lfsck_lfsck2name(lfsck), PFID(cfid), name,
<a name="l01197"></a>01197                lfsck_object_type(child) &amp; S_IFMT, PFID(pfid), rc);
<a name="l01198"></a>01198 
<a name="l01199"></a>01199         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01200"></a>01200                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l01203"></a>01203                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l01204"></a>01204                         ns-&gt;ln_lost_dirent_repaired++;
<a name="l01205"></a>01205         }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207         <span class="keywordflow">return</span> rc;
<a name="l01208"></a>01208 }
<a name="l01209"></a>01209 
<a name="l01226"></a>01226 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_create_orphan_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01227"></a>01227                                              <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l01228"></a>01228                                              <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *orphan,
<a name="l01229"></a>01229                                              <span class="keyword">struct</span> <a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a> *lmv)
<a name="l01230"></a>01230 {
<a name="l01231"></a>01231         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l01232"></a>01232         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>                  *la     = &amp;info-&gt;lti_la;
<a name="l01233"></a>01233         <span class="keyword">struct </span><a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a>       *hint   = &amp;info-&gt;lti_hint;
<a name="l01234"></a>01234         <span class="keyword">struct </span><a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a>         *dof    = &amp;info-&gt;lti_dof;
<a name="l01235"></a>01235         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>                  *cname  = &amp;info-&gt;lti_name2;
<a name="l01236"></a>01236         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>            *rec    = &amp;info-&gt;lti_dt_rec;
<a name="l01237"></a>01237         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>            *lmv2   = &amp;info-&gt;lti_lmv2;
<a name="l01238"></a>01238         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *cfid   = lfsck_dto2fid(orphan);
<a name="l01239"></a>01239         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>                    tfid;
<a name="l01240"></a>01240         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l01241"></a>01241         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns     = com-&gt;lc_file_ram;
<a name="l01242"></a>01242         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck_obj2dev(orphan);
<a name="l01243"></a>01243         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *parent = NULL;
<a name="l01244"></a>01244         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l01245"></a>01245         <span class="keyword">struct </span><a class="code" href="structlfsck__lock__handle.html">lfsck_lock_handle</a>        *llh    = &amp;info-&gt;lti_llh;
<a name="l01246"></a>01246         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>               ldata  = { NULL };
<a name="l01247"></a>01247         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                    linkea_buf;
<a name="l01248"></a>01248         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                    lmv_buf;
<a name="l01249"></a>01249         <span class="keywordtype">char</span>                             name[32];
<a name="l01250"></a>01250         <span class="keywordtype">int</span>                              namelen;
<a name="l01251"></a>01251         <span class="keywordtype">int</span>                              idx    = 0;
<a name="l01252"></a>01252         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l01253"></a>01253         <span class="keywordtype">int</span>                              rc1    = 0;
<a name="l01254"></a>01254         ENTRY;
<a name="l01255"></a>01255 
<a name="l01256"></a>01256         LASSERT(!dt_object_exists(orphan));
<a name="l01257"></a>01257 
<a name="l01258"></a>01258         cname-&gt;ln_name = NULL;
<a name="l01259"></a>01259         <span class="keywordflow">if</span> (lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN)
<a name="l01260"></a>01260                 GOTO(log, rc = 1);
<a name="l01261"></a>01261 
<a name="l01262"></a>01262         <span class="keywordflow">if</span> (dt_object_remote(orphan)) {
<a name="l01263"></a>01263                 LASSERT(lfsck-&gt;li_lpf_root_obj != NULL);
<a name="l01264"></a>01264 
<a name="l01265"></a>01265                 idx = lfsck_find_mdt_idx_by_fid(env, lfsck, cfid);
<a name="l01266"></a>01266                 <span class="keywordflow">if</span> (idx &lt; 0)
<a name="l01267"></a>01267                         GOTO(log, rc = idx);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269                 snprintf(name, 8, <span class="stringliteral">&quot;MDT%04x&quot;</span>, idx);
<a name="l01270"></a>01270                 rc = dt_lookup(env, lfsck-&gt;li_lpf_root_obj,
<a name="l01271"></a>01271                                (<span class="keyword">struct</span> dt_rec *)&amp;tfid,
<a name="l01272"></a>01272                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name);
<a name="l01273"></a>01273                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01274"></a>01274                         GOTO(log, rc = (rc == -ENOENT ? -ENXIO : rc));
<a name="l01275"></a>01275 
<a name="l01276"></a>01276                 parent = lfsck_object_find_bottom(env, lfsck, &amp;tfid);
<a name="l01277"></a>01277                 <span class="keywordflow">if</span> (IS_ERR(parent))
<a name="l01278"></a>01278                         GOTO(log, rc = PTR_ERR(parent));
<a name="l01279"></a>01279 
<a name="l01280"></a>01280                 <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, parent)))
<a name="l01281"></a>01281                         GOTO(log, rc = -ENOTDIR);
<a name="l01282"></a>01282         } <span class="keywordflow">else</span> {
<a name="l01283"></a>01283                 <span class="keywordflow">if</span> (unlikely(lfsck-&gt;li_lpf_obj == NULL))
<a name="l01284"></a>01284                         GOTO(log, rc = -ENXIO);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286                 parent = lfsck-&gt;li_lpf_obj;
<a name="l01287"></a>01287         }
<a name="l01288"></a>01288 
<a name="l01289"></a>01289         dev = lfsck_find_dev_by_fid(env, lfsck, cfid);
<a name="l01290"></a>01290         <span class="keywordflow">if</span> (IS_ERR(dev))
<a name="l01291"></a>01291                 GOTO(log, rc = PTR_ERR(dev));
<a name="l01292"></a>01292 
<a name="l01293"></a>01293         idx = 0;
<a name="l01294"></a>01294 
<a name="l01295"></a>01295 again:
<a name="l01296"></a>01296         <span class="keywordflow">do</span> {
<a name="l01297"></a>01297                 namelen = snprintf(name, 31, DFID<span class="stringliteral">&quot;-P-%d&quot;</span>,
<a name="l01298"></a>01298                                    PFID(cfid), idx++);
<a name="l01299"></a>01299                 rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)&amp;tfid,
<a name="l01300"></a>01300                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name);
<a name="l01301"></a>01301                 <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -ENOENT)
<a name="l01302"></a>01302                         GOTO(log, rc);
<a name="l01303"></a>01303         } <span class="keywordflow">while</span> (rc == 0);
<a name="l01304"></a>01304 
<a name="l01305"></a>01305         rc = lfsck_lock(env, lfsck, parent, name, llh,
<a name="l01306"></a>01306                         MDS_INODELOCK_UPDATE, LCK_PW);
<a name="l01307"></a>01307         <span class="keywordflow">if</span> (rc != 0)
<a name="l01308"></a>01308                 GOTO(log, rc);
<a name="l01309"></a>01309 
<a name="l01310"></a>01310         <span class="comment">/* Re-check whether the name conflict with othrs after taken</span>
<a name="l01311"></a>01311 <span class="comment">         * the ldlm lock. */</span>
<a name="l01312"></a>01312         rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)&amp;tfid,
<a name="l01313"></a>01313                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name);
<a name="l01314"></a>01314         <span class="keywordflow">if</span> (unlikely(rc == 0)) {
<a name="l01315"></a>01315                 lfsck_unlock(llh);
<a name="l01316"></a>01316                 <span class="keywordflow">goto</span> again;
<a name="l01317"></a>01317         }
<a name="l01318"></a>01318 
<a name="l01319"></a>01319         <span class="keywordflow">if</span> (rc != -ENOENT)
<a name="l01320"></a>01320                 GOTO(unlock1, rc);
<a name="l01321"></a>01321 
<a name="l01322"></a>01322         cname-&gt;ln_name = name;
<a name="l01323"></a>01323         cname-&gt;ln_namelen = namelen;
<a name="l01324"></a>01324 
<a name="l01325"></a>01325         memset(la, 0, <span class="keyword">sizeof</span>(*la));
<a name="l01326"></a>01326         la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> = S_IFDIR | 0700;
<a name="l01327"></a>01327         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_TYPE | LA_MODE | LA_UID | LA_GID |
<a name="l01328"></a>01328                        LA_ATIME | LA_MTIME | LA_CTIME;
<a name="l01329"></a>01329 
<a name="l01330"></a>01330         orphan-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#a00fed99bee94890d3e36719af00d5595" title="Prepare allocation hint for a new object.">do_ah_init</a>(env, hint, parent, orphan,
<a name="l01331"></a>01331                                    la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> &amp; S_IFMT);
<a name="l01332"></a>01332 
<a name="l01333"></a>01333         memset(dof, 0, <span class="keyword">sizeof</span>(*dof));
<a name="l01334"></a>01334         dof-&gt;<a class="code" href="structdt__object__format.html#a7522bce1087145d78c749b182e10357c" title="type for dt object">dof_type</a> = dt_mode_to_dft(S_IFDIR);
<a name="l01335"></a>01335 
<a name="l01336"></a>01336         rc = linkea_data_new(&amp;ldata, &amp;info-&gt;lti_linkea_buf2);
<a name="l01337"></a>01337         <span class="keywordflow">if</span> (rc != 0)
<a name="l01338"></a>01338                 GOTO(unlock1, rc);
<a name="l01339"></a>01339 
<a name="l01340"></a>01340         rc = linkea_add_buf(&amp;ldata, cname, lfsck_dto2fid(parent));
<a name="l01341"></a>01341         <span class="keywordflow">if</span> (rc != 0)
<a name="l01342"></a>01342                 GOTO(unlock1, rc);
<a name="l01343"></a>01343 
<a name="l01344"></a>01344         th = dt_trans_create(env, dev);
<a name="l01345"></a>01345         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l01346"></a>01346                 GOTO(unlock1, rc = PTR_ERR(th));
<a name="l01347"></a>01347 
<a name="l01348"></a>01348         <span class="comment">/* Sync the remote transaction to guarantee that the subsequent</span>
<a name="l01349"></a>01349 <span class="comment">         * lock against the @orphan can find the @orphan in time. */</span>
<a name="l01350"></a>01350         <span class="keywordflow">if</span> (dt_object_remote(orphan))
<a name="l01351"></a>01351                 th-&gt;<a class="code" href="structthandle.html#a4ebd1192a1e6fd4868826aee3ad1ec05" title="whether we need sync commit">th_sync</a> = 1;
<a name="l01352"></a>01352 
<a name="l01353"></a>01353         rc = dt_declare_create(env, orphan, la, hint, dof, th);
<a name="l01354"></a>01354         <span class="keywordflow">if</span> (rc != 0)
<a name="l01355"></a>01355                 GOTO(stop, rc);
<a name="l01356"></a>01356 
<a name="l01357"></a>01357         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, orphan)))
<a name="l01358"></a>01358                 GOTO(stop, rc = -ENOTDIR);
<a name="l01359"></a>01359 
<a name="l01360"></a>01360         rc = dt_declare_ref_add(env, orphan, th);
<a name="l01361"></a>01361         <span class="keywordflow">if</span> (rc != 0)
<a name="l01362"></a>01362                 GOTO(stop, rc);
<a name="l01363"></a>01363 
<a name="l01364"></a>01364         rec-&gt;rec_type = S_IFDIR;
<a name="l01365"></a>01365         rec-&gt;rec_fid = cfid;
<a name="l01366"></a>01366         rc = dt_declare_insert(env, orphan, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01367"></a>01367                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dot, th);
<a name="l01368"></a>01368         <span class="keywordflow">if</span> (rc != 0)
<a name="l01369"></a>01369                 GOTO(stop, rc);
<a name="l01370"></a>01370 
<a name="l01371"></a>01371         rec-&gt;rec_fid = lfsck_dto2fid(parent);
<a name="l01372"></a>01372         rc = dt_declare_insert(env, orphan, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01373"></a>01373                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th);
<a name="l01374"></a>01374         <span class="keywordflow">if</span> (rc != 0)
<a name="l01375"></a>01375                 GOTO(stop, rc);
<a name="l01376"></a>01376 
<a name="l01377"></a>01377         <span class="keywordflow">if</span> (lmv != NULL) {
<a name="l01378"></a>01378                 lmv-&gt;lmv_magic = LMV_MAGIC;
<a name="l01379"></a>01379                 lmv-&gt;lmv_master_mdt_index = lfsck_dev_idx(lfsck);
<a name="l01380"></a>01380                 lfsck_lmv_header_cpu_to_le(lmv2, lmv);
<a name="l01381"></a>01381                 lfsck_buf_init(&amp;lmv_buf, lmv2, <span class="keyword">sizeof</span>(*lmv2));
<a name="l01382"></a>01382                 rc = dt_declare_xattr_set(env, orphan, &amp;lmv_buf,
<a name="l01383"></a>01383                                           XATTR_NAME_LMV, 0, th);
<a name="l01384"></a>01384                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01385"></a>01385                         GOTO(stop, rc);
<a name="l01386"></a>01386         }
<a name="l01387"></a>01387 
<a name="l01388"></a>01388         lfsck_buf_init(&amp;linkea_buf, ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l01389"></a>01389                        ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l01390"></a>01390         rc = dt_declare_xattr_set(env, orphan, &amp;linkea_buf,
<a name="l01391"></a>01391                                   XATTR_NAME_LINK, 0, th);
<a name="l01392"></a>01392         <span class="keywordflow">if</span> (rc != 0)
<a name="l01393"></a>01393                 GOTO(stop, rc);
<a name="l01394"></a>01394 
<a name="l01395"></a>01395         rec-&gt;rec_fid = cfid;
<a name="l01396"></a>01396         rc = dt_declare_insert(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01397"></a>01397                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l01398"></a>01398         <span class="keywordflow">if</span> (rc == 0)
<a name="l01399"></a>01399                 rc = dt_declare_ref_add(env, parent, th);
<a name="l01400"></a>01400 
<a name="l01401"></a>01401         <span class="keywordflow">if</span> (rc != 0)
<a name="l01402"></a>01402                 GOTO(stop, rc);
<a name="l01403"></a>01403 
<a name="l01404"></a>01404         rc = dt_trans_start_local(env, dev, th);
<a name="l01405"></a>01405         <span class="keywordflow">if</span> (rc != 0)
<a name="l01406"></a>01406                 GOTO(stop, rc);
<a name="l01407"></a>01407 
<a name="l01408"></a>01408         dt_write_lock(env, orphan, 0);
<a name="l01409"></a>01409         rc = dt_create(env, orphan, la, hint, dof, th);
<a name="l01410"></a>01410         <span class="keywordflow">if</span> (rc != 0)
<a name="l01411"></a>01411                 GOTO(unlock2, rc);
<a name="l01412"></a>01412 
<a name="l01413"></a>01413         rc = dt_ref_add(env, orphan, th);
<a name="l01414"></a>01414         <span class="keywordflow">if</span> (rc != 0)
<a name="l01415"></a>01415                 GOTO(unlock2, rc);
<a name="l01416"></a>01416 
<a name="l01417"></a>01417         rec-&gt;rec_fid = cfid;
<a name="l01418"></a>01418         rc = dt_insert(env, orphan, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01419"></a>01419                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dot, th, 1);
<a name="l01420"></a>01420         <span class="keywordflow">if</span> (rc != 0)
<a name="l01421"></a>01421                 GOTO(unlock2, rc);
<a name="l01422"></a>01422 
<a name="l01423"></a>01423         rec-&gt;rec_fid = lfsck_dto2fid(parent);
<a name="l01424"></a>01424         rc = dt_insert(env, orphan, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01425"></a>01425                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th, 1);
<a name="l01426"></a>01426         <span class="keywordflow">if</span> (rc != 0)
<a name="l01427"></a>01427                 GOTO(unlock2, rc);
<a name="l01428"></a>01428 
<a name="l01429"></a>01429         <span class="keywordflow">if</span> (lmv != NULL) {
<a name="l01430"></a>01430                 rc = dt_xattr_set(env, orphan, &amp;lmv_buf, XATTR_NAME_LMV, 0, th);
<a name="l01431"></a>01431                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01432"></a>01432                         GOTO(unlock2, rc);
<a name="l01433"></a>01433         }
<a name="l01434"></a>01434 
<a name="l01435"></a>01435         rc = dt_xattr_set(env, orphan, &amp;linkea_buf,
<a name="l01436"></a>01436                           XATTR_NAME_LINK, 0, th);
<a name="l01437"></a>01437         dt_write_unlock(env, orphan);
<a name="l01438"></a>01438         <span class="keywordflow">if</span> (rc != 0)
<a name="l01439"></a>01439                 GOTO(stop, rc);
<a name="l01440"></a>01440 
<a name="l01441"></a>01441         rec-&gt;rec_fid = cfid;
<a name="l01442"></a>01442         rc = dt_insert(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01443"></a>01443                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th, 1);
<a name="l01444"></a>01444         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01445"></a>01445                 dt_write_lock(env, parent, 0);
<a name="l01446"></a>01446                 rc = dt_ref_add(env, parent, th);
<a name="l01447"></a>01447                 dt_write_unlock(env, parent);
<a name="l01448"></a>01448         }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450         GOTO(stop, rc = (rc == 0 ? 1 : rc));
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 unlock2:
<a name="l01453"></a>01453         dt_write_unlock(env, orphan);
<a name="l01454"></a>01454 
<a name="l01455"></a>01455 stop:
<a name="l01456"></a>01456         rc1 = dt_trans_stop(env, dev, th);
<a name="l01457"></a>01457         <span class="keywordflow">if</span> (rc1 != 0 &amp;&amp; rc &gt; 0)
<a name="l01458"></a>01458                 rc = rc1;
<a name="l01459"></a>01459 
<a name="l01460"></a>01460 unlock1:
<a name="l01461"></a>01461         lfsck_unlock(llh);
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 log:
<a name="l01464"></a>01464         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK create orphan dir for &quot;</span>
<a name="l01465"></a>01465                <span class="stringliteral">&quot;the object &quot;</span>DFID<span class="stringliteral">&quot;, name = %s: rc = %d\n&quot;</span>,
<a name="l01466"></a>01466                lfsck_lfsck2name(lfsck), PFID(cfid),
<a name="l01467"></a>01467                cname-&gt;ln_name != NULL ? cname-&gt;ln_name : <span class="stringliteral">&quot;&lt;NULL&gt;&quot;</span>, rc);
<a name="l01468"></a>01468 
<a name="l01469"></a>01469         <span class="keywordflow">if</span> (parent != NULL &amp;&amp; !IS_ERR(parent) &amp;&amp; parent != lfsck-&gt;li_lpf_obj)
<a name="l01470"></a>01470                 lfsck_object_put(env, parent);
<a name="l01471"></a>01471 
<a name="l01472"></a>01472         <span class="keywordflow">if</span> (rc != 0)
<a name="l01473"></a>01473                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l01474"></a>01474 
<a name="l01475"></a>01475         <span class="keywordflow">return</span> rc;
<a name="l01476"></a>01476 }
<a name="l01477"></a>01477 
<a name="l01498"></a>01498 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_shrink_linkea(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01499"></a>01499                                          <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l01500"></a>01500                                          <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l01501"></a>01501                                          <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l01502"></a>01502                                          <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *cname,
<a name="l01503"></a>01503                                          <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l01504"></a>01504                                          <span class="keywordtype">bool</span> next)
<a name="l01505"></a>01505 {
<a name="l01506"></a>01506         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck     = com-&gt;lc_lfsck;
<a name="l01507"></a>01507         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev       = lfsck_obj2dev(obj);
<a name="l01508"></a>01508         <span class="keyword">struct </span><a class="code" href="structlfsck__bookmark.html">lfsck_bookmark</a>           *bk        = &amp;lfsck-&gt;li_bookmark_ram;
<a name="l01509"></a>01509         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th        = NULL;
<a name="l01510"></a>01510         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>             lh        = { 0 };
<a name="l01511"></a>01511         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>               ldata_new = { NULL };
<a name="l01512"></a>01512         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                    linkea_buf;
<a name="l01513"></a>01513         <span class="keywordtype">int</span>                              rc        = 0;
<a name="l01514"></a>01514         ENTRY;
<a name="l01515"></a>01515 
<a name="l01516"></a>01516         rc = lfsck_ibits_lock(env, lfsck, obj, &amp;lh,
<a name="l01517"></a>01517                               MDS_INODELOCK_UPDATE | MDS_INODELOCK_XATTR,
<a name="l01518"></a>01518                               LCK_EX);
<a name="l01519"></a>01519         <span class="keywordflow">if</span> (rc != 0)
<a name="l01520"></a>01520                 GOTO(log, rc);
<a name="l01521"></a>01521 
<a name="l01522"></a>01522         <span class="keywordflow">if</span> (next)
<a name="l01523"></a>01523                 linkea_del_buf(ldata, cname);
<a name="l01524"></a>01524         <span class="keywordflow">else</span>
<a name="l01525"></a>01525                 lfsck_namespace_filter_linkea_entry(ldata, cname, pfid,
<a name="l01526"></a>01526                                                     <span class="keyword">true</span>);
<a name="l01527"></a>01527         lfsck_buf_init(&amp;linkea_buf, ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l01528"></a>01528                        ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530 again:
<a name="l01531"></a>01531         th = dt_trans_create(env, dev);
<a name="l01532"></a>01532         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l01533"></a>01533                 GOTO(unlock1, rc = PTR_ERR(th));
<a name="l01534"></a>01534 
<a name="l01535"></a>01535         rc = dt_declare_xattr_set(env, obj, &amp;linkea_buf,
<a name="l01536"></a>01536                                   XATTR_NAME_LINK, 0, th);
<a name="l01537"></a>01537         <span class="keywordflow">if</span> (rc != 0)
<a name="l01538"></a>01538                 GOTO(stop, rc);
<a name="l01539"></a>01539 
<a name="l01540"></a>01540         rc = dt_trans_start_local(env, dev, th);
<a name="l01541"></a>01541         <span class="keywordflow">if</span> (rc != 0)
<a name="l01542"></a>01542                 GOTO(stop, rc);
<a name="l01543"></a>01543 
<a name="l01544"></a>01544         dt_write_lock(env, obj, 0);
<a name="l01545"></a>01545         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(obj)))
<a name="l01546"></a>01546                 GOTO(unlock2, rc = -ENOENT);
<a name="l01547"></a>01547 
<a name="l01548"></a>01548         rc = lfsck_links_read2(env, obj, &amp;ldata_new);
<a name="l01549"></a>01549         <span class="keywordflow">if</span> (rc != 0)
<a name="l01550"></a>01550                 GOTO(unlock2, rc);
<a name="l01551"></a>01551 
<a name="l01552"></a>01552         <span class="comment">/* The specified linkEA entry has been removed by race. */</span>
<a name="l01553"></a>01553         rc = linkea_links_find(&amp;ldata_new, cname, pfid);
<a name="l01554"></a>01554         <span class="keywordflow">if</span> (rc != 0)
<a name="l01555"></a>01555                 GOTO(unlock2, rc = 0);
<a name="l01556"></a>01556 
<a name="l01557"></a>01557         <span class="keywordflow">if</span> (bk-&gt;lb_param &amp; LPF_DRYRUN)
<a name="l01558"></a>01558                 GOTO(unlock2, rc = 1);
<a name="l01559"></a>01559 
<a name="l01560"></a>01560         <span class="keywordflow">if</span> (next)
<a name="l01561"></a>01561                 linkea_del_buf(&amp;ldata_new, cname);
<a name="l01562"></a>01562         <span class="keywordflow">else</span>
<a name="l01563"></a>01563                 lfsck_namespace_filter_linkea_entry(&amp;ldata_new, cname, pfid,
<a name="l01564"></a>01564                                                     <span class="keyword">true</span>);
<a name="l01565"></a>01565 
<a name="l01566"></a>01566         <span class="keywordflow">if</span> (linkea_buf.lb_len &lt; ldata_new.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len) {
<a name="l01567"></a>01567                 dt_write_unlock(env, obj);
<a name="l01568"></a>01568                 dt_trans_stop(env, dev, th);
<a name="l01569"></a>01569                 lfsck_buf_init(&amp;linkea_buf, ldata_new.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l01570"></a>01570                                ldata_new.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l01571"></a>01571                 <span class="keywordflow">goto</span> again;
<a name="l01572"></a>01572         }
<a name="l01573"></a>01573 
<a name="l01574"></a>01574         lfsck_buf_init(&amp;linkea_buf, ldata_new.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l01575"></a>01575                        ldata_new.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l01576"></a>01576         rc = dt_xattr_set(env, obj, &amp;linkea_buf, XATTR_NAME_LINK, 0, th);
<a name="l01577"></a>01577 
<a name="l01578"></a>01578         GOTO(unlock2, rc = (rc == 0 ? 1 : rc));
<a name="l01579"></a>01579 
<a name="l01580"></a>01580 unlock2:
<a name="l01581"></a>01581         dt_write_unlock(env, obj);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583 stop:
<a name="l01584"></a>01584         dt_trans_stop(env, dev, th);
<a name="l01585"></a>01585 
<a name="l01586"></a>01586 unlock1:
<a name="l01587"></a>01587         lfsck_ibits_unlock(&amp;lh, LCK_EX);
<a name="l01588"></a>01588 
<a name="l01589"></a>01589 log:
<a name="l01590"></a>01590         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK remove %s linkEA entry &quot;</span>
<a name="l01591"></a>01591                <span class="stringliteral">&quot;for the object: &quot;</span>DFID<span class="stringliteral">&quot;, parent &quot;</span>DFID<span class="stringliteral">&quot;, name %.*s\n&quot;</span>,
<a name="l01592"></a>01592                lfsck_lfsck2name(lfsck), next ? <span class="stringliteral">&quot;invalid&quot;</span> : <span class="stringliteral">&quot;redundant&quot;</span>,
<a name="l01593"></a>01593                PFID(lfsck_dto2fid(obj)), PFID(pfid), cname-&gt;ln_namelen,
<a name="l01594"></a>01594                cname-&gt;ln_name);
<a name="l01595"></a>01595 
<a name="l01596"></a>01596         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01597"></a>01597                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l01598"></a>01598 
<a name="l01599"></a>01599                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l01600"></a>01600         }
<a name="l01601"></a>01601 
<a name="l01602"></a>01602         <span class="keywordflow">return</span> rc;
<a name="l01603"></a>01603 }
<a name="l01604"></a>01604 
<a name="l01624"></a>01624 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_shrink_linkea_cond(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01625"></a>01625                                               <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l01626"></a>01626                                               <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *parent,
<a name="l01627"></a>01627                                               <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child,
<a name="l01628"></a>01628                                               <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l01629"></a>01629                                               <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *cname,
<a name="l01630"></a>01630                                               <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid)
<a name="l01631"></a>01631 {
<a name="l01632"></a>01632         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a> *info  = lfsck_env_info(env);
<a name="l01633"></a>01633         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>            *cfid  = &amp;info-&gt;lti_fid3;
<a name="l01634"></a>01634         <span class="keyword">struct </span><a class="code" href="structlfsck__lock__handle.html">lfsck_lock_handle</a> *llh   = &amp;info-&gt;lti_llh;
<a name="l01635"></a>01635         <span class="keywordtype">int</span>                       rc;
<a name="l01636"></a>01636         ENTRY;
<a name="l01637"></a>01637 
<a name="l01638"></a>01638         rc = lfsck_lock(env, com-&gt;lc_lfsck, parent, cname-&gt;ln_name, llh,
<a name="l01639"></a>01639                         MDS_INODELOCK_UPDATE, LCK_PR);
<a name="l01640"></a>01640         <span class="keywordflow">if</span> (rc != 0)
<a name="l01641"></a>01641                 RETURN(rc);
<a name="l01642"></a>01642 
<a name="l01643"></a>01643         dt_read_lock(env, parent, 0);
<a name="l01644"></a>01644         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(parent))) {
<a name="l01645"></a>01645                 dt_read_unlock(env, parent);
<a name="l01646"></a>01646                 lfsck_unlock(llh);
<a name="l01647"></a>01647                 rc = lfsck_namespace_shrink_linkea(env, com, child, ldata,
<a name="l01648"></a>01648                                                    cname, pfid, <span class="keyword">true</span>);
<a name="l01649"></a>01649 
<a name="l01650"></a>01650                 RETURN(rc);
<a name="l01651"></a>01651         }
<a name="l01652"></a>01652 
<a name="l01653"></a>01653         rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)cfid,
<a name="l01654"></a>01654                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)cname-&gt;ln_name);
<a name="l01655"></a>01655         dt_read_unlock(env, parent);
<a name="l01656"></a>01656 
<a name="l01657"></a>01657         <span class="comment">/* It is safe to release the ldlm lock, because when the logic come</span>
<a name="l01658"></a>01658 <span class="comment">         * here, we have got all the needed information above whether the</span>
<a name="l01659"></a>01659 <span class="comment">         * linkEA entry is valid or not. It is not important that others</span>
<a name="l01660"></a>01660 <span class="comment">         * may add new linkEA entry after the ldlm lock released. If other</span>
<a name="l01661"></a>01661 <span class="comment">         * has removed the specified linkEA entry by race, then it is OK,</span>
<a name="l01662"></a>01662 <span class="comment">         * because the subsequent lfsck_namespace_shrink_linkea() can handle</span>
<a name="l01663"></a>01663 <span class="comment">         * such case. */</span>
<a name="l01664"></a>01664         lfsck_unlock(llh);
<a name="l01665"></a>01665         <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l01666"></a>01666                 rc = lfsck_namespace_shrink_linkea(env, com, child, ldata,
<a name="l01667"></a>01667                                                    cname, pfid, <span class="keyword">true</span>);
<a name="l01668"></a>01668 
<a name="l01669"></a>01669                 RETURN(rc);
<a name="l01670"></a>01670         }
<a name="l01671"></a>01671 
<a name="l01672"></a>01672         <span class="keywordflow">if</span> (rc != 0)
<a name="l01673"></a>01673                 RETURN(rc);
<a name="l01674"></a>01674 
<a name="l01675"></a>01675         <span class="comment">/* The LFSCK just found some internal status of cross-MDTs</span>
<a name="l01676"></a>01676 <span class="comment">         * create operation. That is normal. */</span>
<a name="l01677"></a>01677         <span class="keywordflow">if</span> (lu_fid_eq(cfid, lfsck_dto2fid(child))) {
<a name="l01678"></a>01678                 linkea_next_entry(ldata);
<a name="l01679"></a>01679 
<a name="l01680"></a>01680                 RETURN(0);
<a name="l01681"></a>01681         }
<a name="l01682"></a>01682 
<a name="l01683"></a>01683         rc = lfsck_namespace_shrink_linkea(env, com, child, ldata, cname,
<a name="l01684"></a>01684                                            pfid, <span class="keyword">true</span>);
<a name="l01685"></a>01685 
<a name="l01686"></a>01686         RETURN(rc);
<a name="l01687"></a>01687 }
<a name="l01688"></a>01688 
<a name="l01711"></a>01711 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_replace_cond(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01712"></a>01712                                         <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l01713"></a>01713                                         <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *parent,
<a name="l01714"></a>01714                                         <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child,
<a name="l01715"></a>01715                                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *cfid,
<a name="l01716"></a>01716                                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *cname)
<a name="l01717"></a>01717 {
<a name="l01718"></a>01718         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l01719"></a>01719         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>                  *la     = &amp;info-&gt;lti_la;
<a name="l01720"></a>01720         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>            *rec    = &amp;info-&gt;lti_dt_rec;
<a name="l01721"></a>01721         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>                    tfid;
<a name="l01722"></a>01722         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l01723"></a>01723         <span class="comment">/* The child and its name may be on different MDTs. */</span>
<a name="l01724"></a>01724         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck-&gt;li_next;
<a name="l01725"></a>01725         <span class="keyword">const</span> <span class="keywordtype">char</span>                      *name   = cname-&gt;ln_name;
<a name="l01726"></a>01726         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *pfid   = lfsck_dto2fid(parent);
<a name="l01727"></a>01727         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *cobj   = NULL;
<a name="l01728"></a>01728         <span class="keyword">struct </span><a class="code" href="structlfsck__lock__handle.html">lfsck_lock_handle</a>        *pllh   = &amp;info-&gt;lti_llh;
<a name="l01729"></a>01729         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>             clh    = { 0 };
<a name="l01730"></a>01730         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>               ldata  = { NULL };
<a name="l01731"></a>01731         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l01732"></a>01732         <span class="keywordtype">bool</span>                             exist  = <span class="keyword">true</span>;
<a name="l01733"></a>01733         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l01734"></a>01734         ENTRY;
<a name="l01735"></a>01735 
<a name="l01736"></a>01736         <span class="comment">/* @parent/@child may be based on lfsck-&gt;li_bottom,</span>
<a name="l01737"></a>01737 <span class="comment">         * but here we need the object based on the lfsck-&gt;li_next. */</span>
<a name="l01738"></a>01738 
<a name="l01739"></a>01739         parent = lfsck_object_locate(dev, parent);
<a name="l01740"></a>01740         <span class="keywordflow">if</span> (IS_ERR(parent))
<a name="l01741"></a>01741                 GOTO(log, rc = PTR_ERR(parent));
<a name="l01742"></a>01742 
<a name="l01743"></a>01743         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, parent)))
<a name="l01744"></a>01744                 GOTO(log, rc = -ENOTDIR);
<a name="l01745"></a>01745 
<a name="l01746"></a>01746         rc = lfsck_lock(env, lfsck, parent, name, pllh,
<a name="l01747"></a>01747                         MDS_INODELOCK_UPDATE, LCK_PW);
<a name="l01748"></a>01748         <span class="keywordflow">if</span> (rc != 0)
<a name="l01749"></a>01749                 GOTO(log, rc);
<a name="l01750"></a>01750 
<a name="l01751"></a>01751         <span class="keywordflow">if</span> (!fid_is_sane(cfid)) {
<a name="l01752"></a>01752                 exist = <span class="keyword">false</span>;
<a name="l01753"></a>01753                 <span class="keywordflow">goto</span> replace;
<a name="l01754"></a>01754         }
<a name="l01755"></a>01755 
<a name="l01756"></a>01756         cobj = lfsck_object_find_by_dev(env, dev, cfid);
<a name="l01757"></a>01757         <span class="keywordflow">if</span> (IS_ERR(cobj)) {
<a name="l01758"></a>01758                 rc = PTR_ERR(cobj);
<a name="l01759"></a>01759                 <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l01760"></a>01760                         exist = <span class="keyword">false</span>;
<a name="l01761"></a>01761                         <span class="keywordflow">goto</span> replace;
<a name="l01762"></a>01762                 }
<a name="l01763"></a>01763 
<a name="l01764"></a>01764                 GOTO(log, rc);
<a name="l01765"></a>01765         }
<a name="l01766"></a>01766 
<a name="l01767"></a>01767         <span class="keywordflow">if</span> (!dt_object_exists(cobj)) {
<a name="l01768"></a>01768                 exist = <span class="keyword">false</span>;
<a name="l01769"></a>01769                 <span class="keywordflow">goto</span> replace;
<a name="l01770"></a>01770         }
<a name="l01771"></a>01771 
<a name="l01772"></a>01772         rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)&amp;tfid,
<a name="l01773"></a>01773                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name);
<a name="l01774"></a>01774         <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l01775"></a>01775                 exist = <span class="keyword">false</span>;
<a name="l01776"></a>01776                 <span class="keywordflow">goto</span> replace;
<a name="l01777"></a>01777         }
<a name="l01778"></a>01778 
<a name="l01779"></a>01779         <span class="keywordflow">if</span> (rc != 0)
<a name="l01780"></a>01780                 GOTO(log, rc);
<a name="l01781"></a>01781 
<a name="l01782"></a>01782         <span class="comment">/* Someone changed the name entry, cannot replace it. */</span>
<a name="l01783"></a>01783         <span class="keywordflow">if</span> (!lu_fid_eq(cfid, &amp;tfid))
<a name="l01784"></a>01784                 GOTO(log, rc = 0);
<a name="l01785"></a>01785 
<a name="l01786"></a>01786         <span class="comment">/* lock the object to be destroyed. */</span>
<a name="l01787"></a>01787         rc = lfsck_ibits_lock(env, lfsck, cobj, &amp;clh,
<a name="l01788"></a>01788                               MDS_INODELOCK_UPDATE |
<a name="l01789"></a>01789                               MDS_INODELOCK_UPDATE | MDS_INODELOCK_XATTR,
<a name="l01790"></a>01790                               LCK_EX);
<a name="l01791"></a>01791         <span class="keywordflow">if</span> (rc != 0)
<a name="l01792"></a>01792                 GOTO(log, rc);
<a name="l01793"></a>01793 
<a name="l01794"></a>01794         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(cobj))) {
<a name="l01795"></a>01795                 exist = <span class="keyword">false</span>;
<a name="l01796"></a>01796                 <span class="keywordflow">goto</span> replace;
<a name="l01797"></a>01797         }
<a name="l01798"></a>01798 
<a name="l01799"></a>01799         rc = dt_attr_get(env, cobj, la);
<a name="l01800"></a>01800         <span class="keywordflow">if</span> (rc != 0)
<a name="l01801"></a>01801                 GOTO(log, rc);
<a name="l01802"></a>01802 
<a name="l01803"></a>01803         <span class="comment">/* The object has been modified by other(s), or it is not created by</span>
<a name="l01804"></a>01804 <span class="comment">         * LFSCK, the two cases are indistinguishable. So cannot replace it. */</span>
<a name="l01805"></a>01805         <span class="keywordflow">if</span> (la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> != 0)
<a name="l01806"></a>01806                 GOTO(log, rc);
<a name="l01807"></a>01807 
<a name="l01808"></a>01808         <span class="keywordflow">if</span> (S_ISREG(la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l01809"></a>01809                 rc = dt_xattr_get(env, cobj, &amp;<a class="code" href="group__lu.html#ga3daaf59b14be927dc4227c6fc6635c6d" title="null buffer">LU_BUF_NULL</a>, XATTR_NAME_LOV);
<a name="l01810"></a>01810                 <span class="comment">/* If someone has created related OST-object(s),</span>
<a name="l01811"></a>01811 <span class="comment">                 * then keep it. */</span>
<a name="l01812"></a>01812                 <span class="keywordflow">if</span> ((rc &gt; 0) || (rc &lt; 0 &amp;&amp; rc != -ENODATA))
<a name="l01813"></a>01813                         GOTO(log, rc = (rc &gt; 0 ? 0 : rc));
<a name="l01814"></a>01814         }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 replace:
<a name="l01817"></a>01817         dt_read_lock(env, child, 0);
<a name="l01818"></a>01818         rc = lfsck_links_read2(env, child, &amp;ldata);
<a name="l01819"></a>01819         dt_read_unlock(env, child);
<a name="l01820"></a>01820 
<a name="l01821"></a>01821         <span class="comment">/* Someone changed the child, no need to replace. */</span>
<a name="l01822"></a>01822         <span class="keywordflow">if</span> (rc == -ENODATA)
<a name="l01823"></a>01823                 GOTO(log, rc = 0);
<a name="l01824"></a>01824 
<a name="l01825"></a>01825         <span class="keywordflow">if</span> (rc != 0)
<a name="l01826"></a>01826                 GOTO(log, rc);
<a name="l01827"></a>01827 
<a name="l01828"></a>01828         rc = linkea_links_find(&amp;ldata, cname, pfid);
<a name="l01829"></a>01829         <span class="comment">/* Someone moved the child, no need to replace. */</span>
<a name="l01830"></a>01830         <span class="keywordflow">if</span> (rc != 0)
<a name="l01831"></a>01831                 GOTO(log, rc = 0);
<a name="l01832"></a>01832 
<a name="l01833"></a>01833         <span class="keywordflow">if</span> (lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN)
<a name="l01834"></a>01834                 GOTO(log, rc = 1);
<a name="l01835"></a>01835 
<a name="l01836"></a>01836         th = dt_trans_create(env, dev);
<a name="l01837"></a>01837         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l01838"></a>01838                 GOTO(log, rc = PTR_ERR(th));
<a name="l01839"></a>01839 
<a name="l01840"></a>01840         <span class="keywordflow">if</span> (exist) {
<a name="l01841"></a>01841                 rc = dt_declare_destroy(env, cobj, th);
<a name="l01842"></a>01842                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01843"></a>01843                         GOTO(stop, rc);
<a name="l01844"></a>01844         }
<a name="l01845"></a>01845 
<a name="l01846"></a>01846         rc = dt_declare_delete(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l01847"></a>01847         <span class="keywordflow">if</span> (rc != 0)
<a name="l01848"></a>01848                 GOTO(stop, rc);
<a name="l01849"></a>01849 
<a name="l01850"></a>01850         rec-&gt;rec_type = S_IFDIR;
<a name="l01851"></a>01851         rec-&gt;rec_fid = lfsck_dto2fid(child);
<a name="l01852"></a>01852         rc = dt_declare_insert(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01853"></a>01853                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l01854"></a>01854         <span class="keywordflow">if</span> (rc != 0)
<a name="l01855"></a>01855                 GOTO(stop, rc);
<a name="l01856"></a>01856 
<a name="l01857"></a>01857         rc = dt_trans_start_local(env, dev, th);
<a name="l01858"></a>01858         <span class="keywordflow">if</span> (rc != 0)
<a name="l01859"></a>01859                 GOTO(stop, rc);
<a name="l01860"></a>01860 
<a name="l01861"></a>01861         <span class="keywordflow">if</span> (exist) {
<a name="l01862"></a>01862                 rc = dt_destroy(env, cobj, th);
<a name="l01863"></a>01863                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01864"></a>01864                         GOTO(stop, rc);
<a name="l01865"></a>01865         }
<a name="l01866"></a>01866 
<a name="l01867"></a>01867         <span class="comment">/* The old name entry maybe not exist. */</span>
<a name="l01868"></a>01868         rc = dt_delete(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l01869"></a>01869         <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -ENOENT)
<a name="l01870"></a>01870                 GOTO(stop, rc);
<a name="l01871"></a>01871 
<a name="l01872"></a>01872         rc = dt_insert(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01873"></a>01873                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th, 1);
<a name="l01874"></a>01874 
<a name="l01875"></a>01875         GOTO(stop, rc = (rc == 0 ? 1 : rc));
<a name="l01876"></a>01876 
<a name="l01877"></a>01877 stop:
<a name="l01878"></a>01878         dt_trans_stop(env, dev, th);
<a name="l01879"></a>01879 
<a name="l01880"></a>01880 log:
<a name="l01881"></a>01881         lfsck_ibits_unlock(&amp;clh, LCK_EX);
<a name="l01882"></a>01882         lfsck_unlock(pllh);
<a name="l01883"></a>01883 
<a name="l01884"></a>01884         <span class="keywordflow">if</span> (cobj != NULL &amp;&amp; !IS_ERR(cobj))
<a name="l01885"></a>01885                 lfsck_object_put(env, cobj);
<a name="l01886"></a>01886 
<a name="l01887"></a>01887         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK conditionally destroy the &quot;</span>
<a name="l01888"></a>01888                <span class="stringliteral">&quot;object &quot;</span>DFID<span class="stringliteral">&quot; because of conflict with the object &quot;</span>DFID
<a name="l01889"></a>01889                <span class="stringliteral">&quot; under the parent &quot;</span>DFID<span class="stringliteral">&quot; with name %s: rc = %d\n&quot;</span>,
<a name="l01890"></a>01890                lfsck_lfsck2name(lfsck), PFID(cfid),
<a name="l01891"></a>01891                PFID(lfsck_dto2fid(child)), PFID(pfid), name, rc);
<a name="l01892"></a>01892 
<a name="l01893"></a>01893         <span class="keywordflow">return</span> rc;
<a name="l01894"></a>01894 }
<a name="l01895"></a>01895 
<a name="l01910"></a>01910 <span class="keywordtype">int</span> lfsck_namespace_rebuild_linkea(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01911"></a>01911                                    <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l01912"></a>01912                                    <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l01913"></a>01913                                    <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata)
<a name="l01914"></a>01914 {
<a name="l01915"></a>01915         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l01916"></a>01916         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck_obj2dev(obj);
<a name="l01917"></a>01917         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l01918"></a>01918         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                    linkea_buf;
<a name="l01919"></a>01919         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l01920"></a>01920         ENTRY;
<a name="l01921"></a>01921 
<a name="l01922"></a>01922         th = dt_trans_create(env, dev);
<a name="l01923"></a>01923         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l01924"></a>01924                 GOTO(log, rc = PTR_ERR(th));
<a name="l01925"></a>01925 
<a name="l01926"></a>01926         lfsck_buf_init(&amp;linkea_buf, ldata-&gt;<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l01927"></a>01927                        ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l01928"></a>01928         rc = dt_declare_xattr_set(env, obj, &amp;linkea_buf,
<a name="l01929"></a>01929                                   XATTR_NAME_LINK, 0, th);
<a name="l01930"></a>01930         <span class="keywordflow">if</span> (rc != 0)
<a name="l01931"></a>01931                 GOTO(stop, rc);
<a name="l01932"></a>01932 
<a name="l01933"></a>01933         rc = dt_trans_start_local(env, dev, th);
<a name="l01934"></a>01934         <span class="keywordflow">if</span> (rc != 0)
<a name="l01935"></a>01935                 GOTO(stop, rc);
<a name="l01936"></a>01936 
<a name="l01937"></a>01937         dt_write_lock(env, obj, 0);
<a name="l01938"></a>01938         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(obj)))
<a name="l01939"></a>01939                 GOTO(unlock, rc = 0);
<a name="l01940"></a>01940 
<a name="l01941"></a>01941         <span class="keywordflow">if</span> (lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN)
<a name="l01942"></a>01942                 GOTO(unlock, rc = 1);
<a name="l01943"></a>01943 
<a name="l01944"></a>01944         rc = dt_xattr_set(env, obj, &amp;linkea_buf,
<a name="l01945"></a>01945                           XATTR_NAME_LINK, 0, th);
<a name="l01946"></a>01946 
<a name="l01947"></a>01947         GOTO(unlock, rc = (rc == 0 ? 1 : rc));
<a name="l01948"></a>01948 
<a name="l01949"></a>01949 unlock:
<a name="l01950"></a>01950         dt_write_unlock(env, obj);
<a name="l01951"></a>01951 
<a name="l01952"></a>01952 stop:
<a name="l01953"></a>01953         dt_trans_stop(env, dev, th);
<a name="l01954"></a>01954 
<a name="l01955"></a>01955 log:
<a name="l01956"></a>01956         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK rebuild linkEA for the &quot;</span>
<a name="l01957"></a>01957                <span class="stringliteral">&quot;object &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l01958"></a>01958                lfsck_lfsck2name(lfsck), PFID(lfsck_dto2fid(obj)), rc);
<a name="l01959"></a>01959 
<a name="l01960"></a>01960         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01961"></a>01961                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l01962"></a>01962 
<a name="l01963"></a>01963                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l01964"></a>01964         }
<a name="l01965"></a>01965 
<a name="l01966"></a>01966         <span class="keywordflow">return</span> rc;
<a name="l01967"></a>01967 }
<a name="l01968"></a>01968 
<a name="l01990"></a>01990 <span class="keywordtype">int</span> lfsck_namespace_repair_dirent(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01991"></a>01991                                   <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l01992"></a>01992                                   <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *parent,
<a name="l01993"></a>01993                                   <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child,
<a name="l01994"></a>01994                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *name2,
<a name="l01995"></a>01995                                   __u16 type, <span class="keywordtype">bool</span> update, <span class="keywordtype">bool</span> dec)
<a name="l01996"></a>01996 {
<a name="l01997"></a>01997         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l01998"></a>01998         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>            *rec    = &amp;info-&gt;lti_dt_rec;
<a name="l01999"></a>01999         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *pfid   = lfsck_dto2fid(parent);
<a name="l02000"></a>02000         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *cfid   = lfsck_dto2fid(child);
<a name="l02001"></a>02001         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>                    tfid;
<a name="l02002"></a>02002         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l02003"></a>02003         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck-&gt;li_next;
<a name="l02004"></a>02004         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l02005"></a>02005         <span class="keyword">struct </span><a class="code" href="structlfsck__lock__handle.html">lfsck_lock_handle</a>        *llh    = &amp;info-&gt;lti_llh;
<a name="l02006"></a>02006         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>             lh     = { 0 };
<a name="l02007"></a>02007         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l02008"></a>02008         ENTRY;
<a name="l02009"></a>02009 
<a name="l02010"></a>02010         parent = lfsck_object_locate(dev, parent);
<a name="l02011"></a>02011         <span class="keywordflow">if</span> (IS_ERR(parent))
<a name="l02012"></a>02012                 GOTO(log, rc = PTR_ERR(parent));
<a name="l02013"></a>02013 
<a name="l02014"></a>02014         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, parent)))
<a name="l02015"></a>02015                 GOTO(log, rc = -ENOTDIR);
<a name="l02016"></a>02016 
<a name="l02017"></a>02017         <span class="keywordflow">if</span> (!update || strcmp(name, name2) == 0)
<a name="l02018"></a>02018                 rc = lfsck_lock(env, lfsck, parent, name, llh,
<a name="l02019"></a>02019                                 MDS_INODELOCK_UPDATE, LCK_PW);
<a name="l02020"></a>02020         <span class="keywordflow">else</span>
<a name="l02021"></a>02021                 rc = lfsck_ibits_lock(env, lfsck, parent, &amp;lh,
<a name="l02022"></a>02022                                       MDS_INODELOCK_UPDATE, LCK_PW);
<a name="l02023"></a>02023         <span class="keywordflow">if</span> (rc != 0)
<a name="l02024"></a>02024                 GOTO(log, rc);
<a name="l02025"></a>02025 
<a name="l02026"></a>02026         th = dt_trans_create(env, dev);
<a name="l02027"></a>02027         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l02028"></a>02028                 GOTO(unlock1, rc = PTR_ERR(th));
<a name="l02029"></a>02029 
<a name="l02030"></a>02030         rc = dt_declare_delete(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l02031"></a>02031         <span class="keywordflow">if</span> (rc != 0)
<a name="l02032"></a>02032                 GOTO(stop, rc);
<a name="l02033"></a>02033 
<a name="l02034"></a>02034         <span class="keywordflow">if</span> (update) {
<a name="l02035"></a>02035                 rec-&gt;rec_type = lfsck_object_type(child) &amp; S_IFMT;
<a name="l02036"></a>02036                 rec-&gt;rec_fid = cfid;
<a name="l02037"></a>02037                 rc = dt_declare_insert(env, parent,
<a name="l02038"></a>02038                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l02039"></a>02039                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name2, th);
<a name="l02040"></a>02040                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02041"></a>02041                         GOTO(stop, rc);
<a name="l02042"></a>02042         }
<a name="l02043"></a>02043 
<a name="l02044"></a>02044         <span class="keywordflow">if</span> (dec) {
<a name="l02045"></a>02045                 rc = dt_declare_ref_del(env, parent, th);
<a name="l02046"></a>02046                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02047"></a>02047                         GOTO(stop, rc);
<a name="l02048"></a>02048         }
<a name="l02049"></a>02049 
<a name="l02050"></a>02050         rc = dt_trans_start_local(env, dev, th);
<a name="l02051"></a>02051         <span class="keywordflow">if</span> (rc != 0)
<a name="l02052"></a>02052                 GOTO(stop, rc);
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 
<a name="l02055"></a>02055         dt_write_lock(env, parent, 0);
<a name="l02056"></a>02056         rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)&amp;tfid,
<a name="l02057"></a>02057                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name);
<a name="l02058"></a>02058         <span class="comment">/* Someone has removed the bad name entry by race. */</span>
<a name="l02059"></a>02059         <span class="keywordflow">if</span> (rc == -ENOENT)
<a name="l02060"></a>02060                 GOTO(unlock2, rc = 0);
<a name="l02061"></a>02061 
<a name="l02062"></a>02062         <span class="keywordflow">if</span> (rc != 0)
<a name="l02063"></a>02063                 GOTO(unlock2, rc);
<a name="l02064"></a>02064 
<a name="l02065"></a>02065         <span class="comment">/* Someone has removed the bad name entry and reused it for other</span>
<a name="l02066"></a>02066 <span class="comment">         * object by race. */</span>
<a name="l02067"></a>02067         <span class="keywordflow">if</span> (!lu_fid_eq(&amp;tfid, cfid))
<a name="l02068"></a>02068                 GOTO(unlock2, rc = 0);
<a name="l02069"></a>02069 
<a name="l02070"></a>02070         <span class="keywordflow">if</span> (lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN)
<a name="l02071"></a>02071                 GOTO(unlock2, rc = 1);
<a name="l02072"></a>02072 
<a name="l02073"></a>02073         rc = dt_delete(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l02074"></a>02074         <span class="keywordflow">if</span> (rc != 0)
<a name="l02075"></a>02075                 GOTO(unlock2, rc);
<a name="l02076"></a>02076 
<a name="l02077"></a>02077         <span class="keywordflow">if</span> (update) {
<a name="l02078"></a>02078                 rc = dt_insert(env, parent,
<a name="l02079"></a>02079                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l02080"></a>02080                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name2, th, 1);
<a name="l02081"></a>02081                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02082"></a>02082                         GOTO(unlock2, rc);
<a name="l02083"></a>02083         }
<a name="l02084"></a>02084 
<a name="l02085"></a>02085         <span class="keywordflow">if</span> (dec) {
<a name="l02086"></a>02086                 rc = dt_ref_del(env, parent, th);
<a name="l02087"></a>02087                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02088"></a>02088                         GOTO(unlock2, rc);
<a name="l02089"></a>02089         }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091         GOTO(unlock2, rc = (rc == 0 ? 1 : rc));
<a name="l02092"></a>02092 
<a name="l02093"></a>02093 unlock2:
<a name="l02094"></a>02094         dt_write_unlock(env, parent);
<a name="l02095"></a>02095 
<a name="l02096"></a>02096 stop:
<a name="l02097"></a>02097         dt_trans_stop(env, dev, th);
<a name="l02098"></a>02098 
<a name="l02099"></a>02099         <span class="comment">/* We are not sure whether the child will become orphan or not.</span>
<a name="l02100"></a>02100 <span class="comment">         * Record it in the LFSCK trace file for further checking in</span>
<a name="l02101"></a>02101 <span class="comment">         * the second-stage scanning. */</span>
<a name="l02102"></a>02102         <span class="keywordflow">if</span> (!update &amp;&amp; !dec &amp;&amp; rc == 0)
<a name="l02103"></a>02103                 lfsck_namespace_trace_update(env, com, cfid,
<a name="l02104"></a>02104                                              LNTF_CHECK_LINKEA, <span class="keyword">true</span>);
<a name="l02105"></a>02105 
<a name="l02106"></a>02106 unlock1:
<a name="l02107"></a>02107         <span class="comment">/* It is harmless even if unlock the unused lock_handle */</span>
<a name="l02108"></a>02108         lfsck_ibits_unlock(&amp;lh, LCK_PW);
<a name="l02109"></a>02109         lfsck_unlock(llh);
<a name="l02110"></a>02110 
<a name="l02111"></a>02111 log:
<a name="l02112"></a>02112         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK assistant found bad name &quot;</span>
<a name="l02113"></a>02113                <span class="stringliteral">&quot;entry for: parent &quot;</span>DFID<span class="stringliteral">&quot;, child &quot;</span>DFID<span class="stringliteral">&quot;, name %s, type &quot;</span>
<a name="l02114"></a>02114                <span class="stringliteral">&quot;in name entry %o, type claimed by child %o. repair it &quot;</span>
<a name="l02115"></a>02115                <span class="stringliteral">&quot;by %s with new name2 %s: rc = %d\n&quot;</span>,
<a name="l02116"></a>02116                lfsck_lfsck2name(lfsck), PFID(pfid), PFID(cfid),
<a name="l02117"></a>02117                name, type, update ? lfsck_object_type(child) : 0,
<a name="l02118"></a>02118                update ? <span class="stringliteral">&quot;updating&quot;</span> : <span class="stringliteral">&quot;removing&quot;</span>, name2, rc);
<a name="l02119"></a>02119 
<a name="l02120"></a>02120         <span class="keywordflow">if</span> (rc != 0) {
<a name="l02121"></a>02121                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l02122"></a>02122 
<a name="l02123"></a>02123                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l02124"></a>02124         }
<a name="l02125"></a>02125 
<a name="l02126"></a>02126         <span class="keywordflow">return</span> rc;
<a name="l02127"></a>02127 }
<a name="l02128"></a>02128 
<a name="l02147"></a>02147 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_repair_unmatched_pairs(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02148"></a>02148                                                   <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l02149"></a>02149                                                   <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l02150"></a>02150                                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l02151"></a>02151                                                   <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *cname)
<a name="l02152"></a>02152 {
<a name="l02153"></a>02153         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l02154"></a>02154         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>            *rec    = &amp;info-&gt;lti_dt_rec;
<a name="l02155"></a>02155         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l02156"></a>02156         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck_obj2dev(obj);
<a name="l02157"></a>02157         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l02158"></a>02158         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>               ldata  = { NULL };
<a name="l02159"></a>02159         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                    linkea_buf;
<a name="l02160"></a>02160         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l02161"></a>02161         ENTRY;
<a name="l02162"></a>02162 
<a name="l02163"></a>02163         LASSERT(!dt_object_remote(obj));
<a name="l02164"></a>02164         LASSERT(S_ISDIR(lfsck_object_type(obj)));
<a name="l02165"></a>02165 
<a name="l02166"></a>02166         rc = linkea_data_new(&amp;ldata, &amp;info-&gt;lti_big_buf);
<a name="l02167"></a>02167         <span class="keywordflow">if</span> (rc != 0)
<a name="l02168"></a>02168                 GOTO(log, rc);
<a name="l02169"></a>02169 
<a name="l02170"></a>02170         rc = linkea_add_buf(&amp;ldata, cname, pfid);
<a name="l02171"></a>02171         <span class="keywordflow">if</span> (rc != 0)
<a name="l02172"></a>02172                 GOTO(log, rc);
<a name="l02173"></a>02173 
<a name="l02174"></a>02174         lfsck_buf_init(&amp;linkea_buf, ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l02175"></a>02175                        ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l02176"></a>02176 
<a name="l02177"></a>02177         th = dt_trans_create(env, dev);
<a name="l02178"></a>02178         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l02179"></a>02179                 GOTO(log, rc = PTR_ERR(th));
<a name="l02180"></a>02180 
<a name="l02181"></a>02181         rc = dt_declare_delete(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th);
<a name="l02182"></a>02182         <span class="keywordflow">if</span> (rc != 0)
<a name="l02183"></a>02183                 GOTO(stop, rc);
<a name="l02184"></a>02184 
<a name="l02185"></a>02185         rec-&gt;rec_type = S_IFDIR;
<a name="l02186"></a>02186         rec-&gt;rec_fid = pfid;
<a name="l02187"></a>02187         rc = dt_declare_insert(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l02188"></a>02188                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th);
<a name="l02189"></a>02189         <span class="keywordflow">if</span> (rc != 0)
<a name="l02190"></a>02190                 GOTO(stop, rc);
<a name="l02191"></a>02191 
<a name="l02192"></a>02192         rc = dt_declare_xattr_set(env, obj, &amp;linkea_buf,
<a name="l02193"></a>02193                                   XATTR_NAME_LINK, 0, th);
<a name="l02194"></a>02194         <span class="keywordflow">if</span> (rc != 0)
<a name="l02195"></a>02195                 GOTO(stop, rc);
<a name="l02196"></a>02196 
<a name="l02197"></a>02197         rc = dt_trans_start_local(env, dev, th);
<a name="l02198"></a>02198         <span class="keywordflow">if</span> (rc != 0)
<a name="l02199"></a>02199                 GOTO(stop, rc);
<a name="l02200"></a>02200 
<a name="l02201"></a>02201         dt_write_lock(env, obj, 0);
<a name="l02202"></a>02202         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(obj)))
<a name="l02203"></a>02203                 GOTO(unlock, rc = 0);
<a name="l02204"></a>02204 
<a name="l02205"></a>02205         <span class="keywordflow">if</span> (lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN)
<a name="l02206"></a>02206                 GOTO(unlock, rc = 1);
<a name="l02207"></a>02207 
<a name="l02208"></a>02208         <span class="comment">/* The old &quot;..&quot; name entry maybe not exist. */</span>
<a name="l02209"></a>02209         dt_delete(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th);
<a name="l02210"></a>02210 
<a name="l02211"></a>02211         rc = dt_insert(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l02212"></a>02212                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th, 1);
<a name="l02213"></a>02213         <span class="keywordflow">if</span> (rc != 0)
<a name="l02214"></a>02214                 GOTO(unlock, rc);
<a name="l02215"></a>02215 
<a name="l02216"></a>02216         rc = dt_xattr_set(env, obj, &amp;linkea_buf,
<a name="l02217"></a>02217                           XATTR_NAME_LINK, 0, th);
<a name="l02218"></a>02218 
<a name="l02219"></a>02219         GOTO(unlock, rc = (rc == 0 ? 1 : rc));
<a name="l02220"></a>02220 
<a name="l02221"></a>02221 unlock:
<a name="l02222"></a>02222         dt_write_unlock(env, obj);
<a name="l02223"></a>02223 
<a name="l02224"></a>02224 stop:
<a name="l02225"></a>02225         dt_trans_stop(env, dev, th);
<a name="l02226"></a>02226 
<a name="l02227"></a>02227 log:
<a name="l02228"></a>02228         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK rebuild dotdot name entry for &quot;</span>
<a name="l02229"></a>02229                <span class="stringliteral">&quot;the object &quot;</span>DFID<span class="stringliteral">&quot;, new parent &quot;</span>DFID<span class="stringliteral">&quot;: rc = %d\n&quot;</span>,
<a name="l02230"></a>02230                lfsck_lfsck2name(lfsck), PFID(lfsck_dto2fid(obj)),
<a name="l02231"></a>02231                PFID(pfid), rc);
<a name="l02232"></a>02232 
<a name="l02233"></a>02233         <span class="keywordflow">if</span> (rc != 0) {
<a name="l02234"></a>02234                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l02235"></a>02235 
<a name="l02236"></a>02236                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l02237"></a>02237         }
<a name="l02238"></a>02238 
<a name="l02239"></a>02239         <span class="keywordflow">return</span> rc;
<a name="l02240"></a>02240 }
<a name="l02241"></a>02241 
<a name="l02262"></a>02262 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02263"></a>02263 lfsck_namespace_dsd_orphan(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02264"></a>02264                            <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l02265"></a>02265                            <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l02266"></a>02266                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l02267"></a>02267                            <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lh,
<a name="l02268"></a>02268                            <span class="keyword">enum</span> lfsck_namespace_inconsistency_type *type)
<a name="l02269"></a>02269 {
<a name="l02270"></a>02270         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a> *info = lfsck_env_info(env);
<a name="l02271"></a>02271         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>   *ns   = com-&gt;lc_file_ram;
<a name="l02272"></a>02272         <span class="keywordtype">int</span>                       rc;
<a name="l02273"></a>02273         ENTRY;
<a name="l02274"></a>02274 
<a name="l02275"></a>02275         <span class="comment">/* Remove the unrecognized linkEA. */</span>
<a name="l02276"></a>02276         rc = lfsck_namespace_links_remove(env, com, obj);
<a name="l02277"></a>02277         lfsck_ibits_unlock(lh, LCK_EX);
<a name="l02278"></a>02278         <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; rc != -ENODATA)
<a name="l02279"></a>02279                 RETURN(rc);
<a name="l02280"></a>02280 
<a name="l02281"></a>02281         *type = LNIT_MUL_REF;
<a name="l02282"></a>02282 
<a name="l02283"></a>02283         <span class="comment">/* If the LFSCK is marked as LF_INCOMPLETE, then means some MDT has</span>
<a name="l02284"></a>02284 <span class="comment">         * ever tried to verify some remote MDT-object that resides on this</span>
<a name="l02285"></a>02285 <span class="comment">         * MDT, but this MDT failed to respond such request. So means there</span>
<a name="l02286"></a>02286 <span class="comment">         * may be some remote name entry on other MDT that references this</span>
<a name="l02287"></a>02287 <span class="comment">         * object with another name, so we cannot know whether this linkEA</span>
<a name="l02288"></a>02288 <span class="comment">         * is valid or not. So keep it there and maybe resolved when next</span>
<a name="l02289"></a>02289 <span class="comment">         * LFSCK run. */</span>
<a name="l02290"></a>02290         <span class="keywordflow">if</span> (ns-&gt;ln_flags &amp; LF_INCOMPLETE)
<a name="l02291"></a>02291                 RETURN(0);
<a name="l02292"></a>02292 
<a name="l02293"></a>02293         <span class="comment">/* The unique linkEA is invalid, even if the &quot;..&quot; name entry may be</span>
<a name="l02294"></a>02294 <span class="comment">         * valid, we still cannot know via which name entry this directory</span>
<a name="l02295"></a>02295 <span class="comment">         * will be referenced. Then handle it as pure orphan. */</span>
<a name="l02296"></a>02296         snprintf(info-&gt;lti_tmpbuf, <span class="keyword">sizeof</span>(info-&gt;lti_tmpbuf),
<a name="l02297"></a>02297                  <span class="stringliteral">&quot;-&quot;</span>DFID, PFID(pfid));
<a name="l02298"></a>02298         rc = lfsck_namespace_insert_orphan(env, com, obj,
<a name="l02299"></a>02299                                            info-&gt;lti_tmpbuf, <span class="stringliteral">&quot;D&quot;</span>, NULL);
<a name="l02300"></a>02300 
<a name="l02301"></a>02301         RETURN(rc);
<a name="l02302"></a>02302 }
<a name="l02303"></a>02303 
<a name="l02327"></a>02327 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02328"></a>02328 lfsck_namespace_dsd_single(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02329"></a>02329                            <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l02330"></a>02330                            <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child,
<a name="l02331"></a>02331                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l02332"></a>02332                            <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l02333"></a>02333                            <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lh,
<a name="l02334"></a>02334                            <span class="keyword">enum</span> lfsck_namespace_inconsistency_type *type,
<a name="l02335"></a>02335                            <span class="keywordtype">bool</span> *retry)
<a name="l02336"></a>02336 {
<a name="l02337"></a>02337         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a> *info          = lfsck_env_info(env);
<a name="l02338"></a>02338         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>           *cname         = &amp;info-&gt;lti_name;
<a name="l02339"></a>02339         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>      *cfid          = lfsck_dto2fid(child);
<a name="l02340"></a>02340         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             tfid;
<a name="l02341"></a>02341         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>   *ns            = com-&gt;lc_file_ram;
<a name="l02342"></a>02342         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>    *lfsck         = com-&gt;lc_lfsck;
<a name="l02343"></a>02343         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>         *parent        = NULL;
<a name="l02344"></a>02344         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>     *lmv;
<a name="l02345"></a>02345         <span class="keywordtype">int</span>                       rc            = 0;
<a name="l02346"></a>02346         ENTRY;
<a name="l02347"></a>02347 
<a name="l02348"></a>02348         lfsck_namespace_unpack_linkea_entry(ldata, cname, &amp;tfid, info-&gt;lti_key);
<a name="l02349"></a>02349         <span class="comment">/* The unique linkEA entry with bad parent will be handled as orphan. */</span>
<a name="l02350"></a>02350         <span class="keywordflow">if</span> (!fid_is_sane(&amp;tfid)) {
<a name="l02351"></a>02351                 <span class="keywordflow">if</span> (!lustre_handle_is_used(lh) &amp;&amp; retry != NULL)
<a name="l02352"></a>02352                         *retry = <span class="keyword">true</span>;
<a name="l02353"></a>02353                 <span class="keywordflow">else</span>
<a name="l02354"></a>02354                         rc = lfsck_namespace_dsd_orphan(env, com, child,
<a name="l02355"></a>02355                                                         pfid, lh, type);
<a name="l02356"></a>02356 
<a name="l02357"></a>02357                 GOTO(out, rc);
<a name="l02358"></a>02358         }
<a name="l02359"></a>02359 
<a name="l02360"></a>02360         parent = lfsck_object_find_bottom(env, lfsck, &amp;tfid);
<a name="l02361"></a>02361         <span class="keywordflow">if</span> (IS_ERR(parent))
<a name="l02362"></a>02362                 GOTO(out, rc = PTR_ERR(parent));
<a name="l02363"></a>02363 
<a name="l02364"></a>02364         <span class="comment">/* We trust the unique linkEA entry in spite of whether it matches the</span>
<a name="l02365"></a>02365 <span class="comment">         * &quot;..&quot; name entry or not. Because even if the linkEA entry is wrong</span>
<a name="l02366"></a>02366 <span class="comment">         * and the &quot;..&quot; name entry is right, we still cannot know via which</span>
<a name="l02367"></a>02367 <span class="comment">         * name entry the child will be referenced, since all known entries</span>
<a name="l02368"></a>02368 <span class="comment">         * have been verified during the first-stage scanning. */</span>
<a name="l02369"></a>02369         <span class="keywordflow">if</span> (!dt_object_exists(parent)) {
<a name="l02370"></a>02370                 <span class="comment">/* If the LFSCK is marked as LF_INCOMPLETE, then means some MDT</span>
<a name="l02371"></a>02371 <span class="comment">                 * has ever tried to verify some remote MDT-object that resides</span>
<a name="l02372"></a>02372 <span class="comment">                 * on this MDT, but this MDT failed to respond such request. So</span>
<a name="l02373"></a>02373 <span class="comment">                 * means there may be some remote name entry on other MDT that</span>
<a name="l02374"></a>02374 <span class="comment">                 * references this object with another name, so we cannot know</span>
<a name="l02375"></a>02375 <span class="comment">                 * whether this linkEA is valid or not. So keep it there and</span>
<a name="l02376"></a>02376 <span class="comment">                 * maybe resolved when next LFSCK run. */</span>
<a name="l02377"></a>02377                 <span class="keywordflow">if</span> (ns-&gt;ln_flags &amp; LF_INCOMPLETE)
<a name="l02378"></a>02378                         GOTO(out, rc = 0);
<a name="l02379"></a>02379 
<a name="l02380"></a>02380                 <span class="keywordflow">if</span> (!lustre_handle_is_used(lh) &amp;&amp; retry != NULL) {
<a name="l02381"></a>02381                         *retry = <span class="keyword">true</span>;
<a name="l02382"></a>02382 
<a name="l02383"></a>02383                         GOTO(out, rc = 0);
<a name="l02384"></a>02384                 }
<a name="l02385"></a>02385 
<a name="l02386"></a>02386                 lfsck_ibits_unlock(lh, LCK_EX);
<a name="l02387"></a>02387 
<a name="l02388"></a>02388 lost_parent:
<a name="l02389"></a>02389                 lmv = &amp;info-&gt;lti_lmv;
<a name="l02390"></a>02390                 rc = lfsck_read_stripe_lmv(env, child, lmv);
<a name="l02391"></a>02391                 <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -ENODATA)
<a name="l02392"></a>02392                         GOTO(out, rc);
<a name="l02393"></a>02393 
<a name="l02394"></a>02394                 <span class="keywordflow">if</span> (rc == -ENODATA || lmv-&gt;lmv_magic != LMV_MAGIC_STRIPE) {
<a name="l02395"></a>02395                         lmv = NULL;
<a name="l02396"></a>02396                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lfsck_shard_name_to_index(env,
<a name="l02397"></a>02397                                         cname-&gt;ln_name, cname-&gt;ln_namelen,
<a name="l02398"></a>02398                                         S_IFDIR, cfid) &lt; 0) {
<a name="l02399"></a>02399                         <span class="comment">/* It is an invalid name entry, we</span>
<a name="l02400"></a>02400 <span class="comment">                         * cannot trust the parent also. */</span>
<a name="l02401"></a>02401                         rc = lfsck_namespace_shrink_linkea(env, com, child,
<a name="l02402"></a>02402                                                 ldata, cname, &amp;tfid, <span class="keyword">true</span>);
<a name="l02403"></a>02403                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02404"></a>02404                                 GOTO(out, rc);
<a name="l02405"></a>02405 
<a name="l02406"></a>02406                         snprintf(info-&gt;lti_tmpbuf, <span class="keyword">sizeof</span>(info-&gt;lti_tmpbuf),
<a name="l02407"></a>02407                                  <span class="stringliteral">&quot;-&quot;</span>DFID, PFID(pfid));
<a name="l02408"></a>02408                         rc = lfsck_namespace_insert_orphan(env, com, child,
<a name="l02409"></a>02409                                                 info-&gt;lti_tmpbuf, <span class="stringliteral">&quot;S&quot;</span>, NULL);
<a name="l02410"></a>02410 
<a name="l02411"></a>02411                         GOTO(out, rc);
<a name="l02412"></a>02412                 }
<a name="l02413"></a>02413 
<a name="l02414"></a>02414                 <span class="comment">/* Create the lost parent as an orphan. */</span>
<a name="l02415"></a>02415                 rc = lfsck_namespace_create_orphan_dir(env, com, parent, lmv);
<a name="l02416"></a>02416                 <span class="keywordflow">if</span> (rc &gt;= 0) {
<a name="l02417"></a>02417                         <span class="comment">/* Add the missing name entry to the parent. */</span>
<a name="l02418"></a>02418                         rc = lfsck_namespace_insert_normal(env, com, parent,
<a name="l02419"></a>02419                                                         child, cname-&gt;ln_name);
<a name="l02420"></a>02420                         <span class="keywordflow">if</span> (unlikely(rc == -EEXIST)) {
<a name="l02421"></a>02421                                 <span class="comment">/* Unfortunately, someone reused the name</span>
<a name="l02422"></a>02422 <span class="comment">                                 * under the parent by race. So we have</span>
<a name="l02423"></a>02423 <span class="comment">                                 * to remove the linkEA entry from</span>
<a name="l02424"></a>02424 <span class="comment">                                 * current child object. It means that the</span>
<a name="l02425"></a>02425 <span class="comment">                                 * LFSCK cannot recover the system</span>
<a name="l02426"></a>02426 <span class="comment">                                 * totally back to its original status,</span>
<a name="l02427"></a>02427 <span class="comment">                                 * but it is necessary to make the</span>
<a name="l02428"></a>02428 <span class="comment">                                 * current system to be consistent. */</span>
<a name="l02429"></a>02429                                 rc = lfsck_namespace_shrink_linkea(env,
<a name="l02430"></a>02430                                                 com, child, ldata,
<a name="l02431"></a>02431                                                 cname, &amp;tfid, <span class="keyword">true</span>);
<a name="l02432"></a>02432                                 <span class="keywordflow">if</span> (rc &gt;= 0) {
<a name="l02433"></a>02433                                         snprintf(info-&gt;lti_tmpbuf,
<a name="l02434"></a>02434                                                  <span class="keyword">sizeof</span>(info-&gt;lti_tmpbuf),
<a name="l02435"></a>02435                                                  <span class="stringliteral">&quot;-&quot;</span>DFID, PFID(pfid));
<a name="l02436"></a>02436                                         rc = lfsck_namespace_insert_orphan(env,
<a name="l02437"></a>02437                                                 com, child, info-&gt;lti_tmpbuf,
<a name="l02438"></a>02438                                                 <span class="stringliteral">&quot;D&quot;</span>, NULL);
<a name="l02439"></a>02439                                 }
<a name="l02440"></a>02440                         }
<a name="l02441"></a>02441                 }
<a name="l02442"></a>02442 
<a name="l02443"></a>02443                 GOTO(out, rc);
<a name="l02444"></a>02444         }
<a name="l02445"></a>02445 
<a name="l02446"></a>02446         <span class="comment">/* The unique linkEA entry with bad parent will be handled as orphan. */</span>
<a name="l02447"></a>02447         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, parent))) {
<a name="l02448"></a>02448                 <span class="keywordflow">if</span> (!lustre_handle_is_used(lh) &amp;&amp; retry != NULL)
<a name="l02449"></a>02449                         *retry = <span class="keyword">true</span>;
<a name="l02450"></a>02450                 <span class="keywordflow">else</span>
<a name="l02451"></a>02451                         rc = lfsck_namespace_dsd_orphan(env, com, child,
<a name="l02452"></a>02452                                                         pfid, lh, type);
<a name="l02453"></a>02453 
<a name="l02454"></a>02454                 GOTO(out, rc);
<a name="l02455"></a>02455         }
<a name="l02456"></a>02456 
<a name="l02457"></a>02457         rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)&amp;tfid,
<a name="l02458"></a>02458                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)cname-&gt;ln_name);
<a name="l02459"></a>02459         <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l02460"></a>02460                 <span class="comment">/* If the LFSCK is marked as LF_INCOMPLETE, then means some MDT</span>
<a name="l02461"></a>02461 <span class="comment">                 * has ever tried to verify some remote MDT-object that resides</span>
<a name="l02462"></a>02462 <span class="comment">                 * on this MDT, but this MDT failed to respond such request. So</span>
<a name="l02463"></a>02463 <span class="comment">                 * means there may be some remote name entry on other MDT that</span>
<a name="l02464"></a>02464 <span class="comment">                 * references this object with another name, so we cannot know</span>
<a name="l02465"></a>02465 <span class="comment">                 * whether this linkEA is valid or not. So keep it there and</span>
<a name="l02466"></a>02466 <span class="comment">                 * maybe resolved when next LFSCK run. */</span>
<a name="l02467"></a>02467                 <span class="keywordflow">if</span> (ns-&gt;ln_flags &amp; LF_INCOMPLETE)
<a name="l02468"></a>02468                         GOTO(out, rc = 0);
<a name="l02469"></a>02469 
<a name="l02470"></a>02470                 <span class="keywordflow">if</span> (!lustre_handle_is_used(lh) &amp;&amp; retry != NULL) {
<a name="l02471"></a>02471                         *retry = <span class="keyword">true</span>;
<a name="l02472"></a>02472 
<a name="l02473"></a>02473                         GOTO(out, rc = 0);
<a name="l02474"></a>02474                 }
<a name="l02475"></a>02475 
<a name="l02476"></a>02476                 lfsck_ibits_unlock(lh, LCK_EX);
<a name="l02477"></a>02477                 rc = lfsck_namespace_check_name(env, parent, child, cname);
<a name="l02478"></a>02478                 <span class="keywordflow">if</span> (rc == -ENOENT)
<a name="l02479"></a>02479                         <span class="keywordflow">goto</span> lost_parent;
<a name="l02480"></a>02480 
<a name="l02481"></a>02481                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02482"></a>02482                         GOTO(out, rc);
<a name="l02483"></a>02483 
<a name="l02484"></a>02484                 <span class="comment">/* It is an invalid name entry, drop it. */</span>
<a name="l02485"></a>02485                 <span class="keywordflow">if</span> (unlikely(rc &gt; 0)) {
<a name="l02486"></a>02486                         rc = lfsck_namespace_shrink_linkea(env, com, child,
<a name="l02487"></a>02487                                                 ldata, cname, &amp;tfid, <span class="keyword">true</span>);
<a name="l02488"></a>02488                         <span class="keywordflow">if</span> (rc &gt;= 0) {
<a name="l02489"></a>02489                                 snprintf(info-&gt;lti_tmpbuf,
<a name="l02490"></a>02490                                          <span class="keyword">sizeof</span>(info-&gt;lti_tmpbuf),
<a name="l02491"></a>02491                                          <span class="stringliteral">&quot;-&quot;</span>DFID, PFID(pfid));
<a name="l02492"></a>02492                                 rc = lfsck_namespace_insert_orphan(env, com,
<a name="l02493"></a>02493                                         child, info-&gt;lti_tmpbuf, <span class="stringliteral">&quot;D&quot;</span>, NULL);
<a name="l02494"></a>02494                         }
<a name="l02495"></a>02495 
<a name="l02496"></a>02496                         GOTO(out, rc);
<a name="l02497"></a>02497                 }
<a name="l02498"></a>02498 
<a name="l02499"></a>02499                 <span class="comment">/* Add the missing name entry back to the namespace. */</span>
<a name="l02500"></a>02500                 rc = lfsck_namespace_insert_normal(env, com, parent, child,
<a name="l02501"></a>02501                                                    cname-&gt;ln_name);
<a name="l02502"></a>02502                 <span class="keywordflow">if</span> (unlikely(rc == -ESTALE))
<a name="l02503"></a>02503                         <span class="comment">/* It may happen when the remote object has been</span>
<a name="l02504"></a>02504 <span class="comment">                         * removed, but the local MDT is not aware of that. */</span>
<a name="l02505"></a>02505                         <span class="keywordflow">goto</span> lost_parent;
<a name="l02506"></a>02506 
<a name="l02507"></a>02507                 <span class="keywordflow">if</span> (unlikely(rc == -EEXIST)) {
<a name="l02508"></a>02508                         <span class="comment">/* Unfortunately, someone reused the name under the</span>
<a name="l02509"></a>02509 <span class="comment">                         * parent by race. So we have to remove the linkEA</span>
<a name="l02510"></a>02510 <span class="comment">                         * entry from current child object. It means that the</span>
<a name="l02511"></a>02511 <span class="comment">                         * LFSCK cannot recover the system totally back to</span>
<a name="l02512"></a>02512 <span class="comment">                         * its original status, but it is necessary to make</span>
<a name="l02513"></a>02513 <span class="comment">                         * the current system to be consistent.</span>
<a name="l02514"></a>02514 <span class="comment">                         *</span>
<a name="l02515"></a>02515 <span class="comment">                         * It also may be because of the LFSCK found some</span>
<a name="l02516"></a>02516 <span class="comment">                         * internal status of create operation. Under such</span>
<a name="l02517"></a>02517 <span class="comment">                         * case, nothing to be done. */</span>
<a name="l02518"></a>02518                         rc = lfsck_namespace_shrink_linkea_cond(env, com,
<a name="l02519"></a>02519                                         parent, child, ldata, cname, &amp;tfid);
<a name="l02520"></a>02520                         <span class="keywordflow">if</span> (rc &gt;= 0) {
<a name="l02521"></a>02521                                 snprintf(info-&gt;lti_tmpbuf,
<a name="l02522"></a>02522                                          <span class="keyword">sizeof</span>(info-&gt;lti_tmpbuf),
<a name="l02523"></a>02523                                          <span class="stringliteral">&quot;-&quot;</span>DFID, PFID(pfid));
<a name="l02524"></a>02524                                 rc = lfsck_namespace_insert_orphan(env, com,
<a name="l02525"></a>02525                                         child, info-&gt;lti_tmpbuf, <span class="stringliteral">&quot;D&quot;</span>, NULL);
<a name="l02526"></a>02526                         }
<a name="l02527"></a>02527                 }
<a name="l02528"></a>02528 
<a name="l02529"></a>02529                 GOTO(out, rc);
<a name="l02530"></a>02530         }
<a name="l02531"></a>02531 
<a name="l02532"></a>02532         <span class="keywordflow">if</span> (rc != 0)
<a name="l02533"></a>02533                 GOTO(out, rc);
<a name="l02534"></a>02534 
<a name="l02535"></a>02535         <span class="keywordflow">if</span> (!lu_fid_eq(&amp;tfid, cfid)) {
<a name="l02536"></a>02536                 <span class="keywordflow">if</span> (!lustre_handle_is_used(lh) &amp;&amp; retry != NULL) {
<a name="l02537"></a>02537                         *retry = <span class="keyword">true</span>;
<a name="l02538"></a>02538 
<a name="l02539"></a>02539                         GOTO(out, rc = 0);
<a name="l02540"></a>02540                 }
<a name="l02541"></a>02541 
<a name="l02542"></a>02542                 lfsck_ibits_unlock(lh, LCK_EX);
<a name="l02543"></a>02543                 <span class="comment">/* The name entry references another MDT-object that</span>
<a name="l02544"></a>02544 <span class="comment">                 * may be created by the LFSCK for repairing dangling</span>
<a name="l02545"></a>02545 <span class="comment">                 * name entry. Try to replace it. */</span>
<a name="l02546"></a>02546                 rc = lfsck_namespace_replace_cond(env, com, parent, child,
<a name="l02547"></a>02547                                                   &amp;tfid, cname);
<a name="l02548"></a>02548                 <span class="keywordflow">if</span> (rc == 0)
<a name="l02549"></a>02549                         rc = lfsck_namespace_dsd_orphan(env, com, child,
<a name="l02550"></a>02550                                                         pfid, lh, type);
<a name="l02551"></a>02551 
<a name="l02552"></a>02552                 GOTO(out, rc);
<a name="l02553"></a>02553         }
<a name="l02554"></a>02554 
<a name="l02555"></a>02555         <span class="keywordflow">if</span> (fid_is_zero(pfid))
<a name="l02556"></a>02556                 GOTO(out, rc = 0);
<a name="l02557"></a>02557 
<a name="l02558"></a>02558         <span class="comment">/* The &quot;..&quot; name entry is wrong, update it. */</span>
<a name="l02559"></a>02559         <span class="keywordflow">if</span> (!lu_fid_eq(pfid, lfsck_dto2fid(parent))) {
<a name="l02560"></a>02560                 <span class="keywordflow">if</span> (!lustre_handle_is_used(lh) &amp;&amp; retry != NULL) {
<a name="l02561"></a>02561                         *retry = <span class="keyword">true</span>;
<a name="l02562"></a>02562 
<a name="l02563"></a>02563                         GOTO(out, rc = 0);
<a name="l02564"></a>02564                 }
<a name="l02565"></a>02565 
<a name="l02566"></a>02566                 *type = LNIT_UNMATCHED_PAIRS;
<a name="l02567"></a>02567                 rc = lfsck_namespace_repair_unmatched_pairs(env, com, child,
<a name="l02568"></a>02568                                                 lfsck_dto2fid(parent), cname);
<a name="l02569"></a>02569         }
<a name="l02570"></a>02570 
<a name="l02571"></a>02571         GOTO(out, rc);
<a name="l02572"></a>02572 
<a name="l02573"></a>02573 out:
<a name="l02574"></a>02574         <span class="keywordflow">if</span> (parent != NULL &amp;&amp; !IS_ERR(parent))
<a name="l02575"></a>02575                 lfsck_object_put(env, parent);
<a name="l02576"></a>02576 
<a name="l02577"></a>02577         <span class="keywordflow">return</span> rc;
<a name="l02578"></a>02578 }
<a name="l02579"></a>02579 
<a name="l02603"></a>02603 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02604"></a>02604 lfsck_namespace_dsd_multiple(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02605"></a>02605                              <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l02606"></a>02606                              <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child,
<a name="l02607"></a>02607                              <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid,
<a name="l02608"></a>02608                              <span class="keyword">struct</span> <a class="code" href="structlinkea__data.html">linkea_data</a> *ldata,
<a name="l02609"></a>02609                              <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lh,
<a name="l02610"></a>02610                              <span class="keyword">enum</span> lfsck_namespace_inconsistency_type *type,
<a name="l02611"></a>02611                              <span class="keywordtype">bool</span> lpf)
<a name="l02612"></a>02612 {
<a name="l02613"></a>02613         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a> *info          = lfsck_env_info(env);
<a name="l02614"></a>02614         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>           *cname         = &amp;info-&gt;lti_name;
<a name="l02615"></a>02615         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>      *cfid          = lfsck_dto2fid(child);
<a name="l02616"></a>02616         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>            *pfid2         = &amp;info-&gt;lti_fid3;
<a name="l02617"></a>02617         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             tfid;
<a name="l02618"></a>02618         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>   *ns            = com-&gt;lc_file_ram;
<a name="l02619"></a>02619         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>    *lfsck         = com-&gt;lc_lfsck;
<a name="l02620"></a>02620         <span class="keyword">struct </span><a class="code" href="structlfsck__bookmark.html">lfsck_bookmark</a>    *bk            = &amp;lfsck-&gt;li_bookmark_ram;
<a name="l02621"></a>02621         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>         *parent        = NULL;
<a name="l02622"></a>02622         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>        ldata_new     = { NULL };
<a name="l02623"></a>02623         <span class="keywordtype">int</span>                       dirent_count  = 0;
<a name="l02624"></a>02624         <span class="keywordtype">int</span>                       linkea_count  = 0;
<a name="l02625"></a>02625         <span class="keywordtype">int</span>                       rc            = 0;
<a name="l02626"></a>02626         <span class="keywordtype">bool</span>                      once          = <span class="keyword">true</span>;
<a name="l02627"></a>02627         ENTRY;
<a name="l02628"></a>02628 
<a name="l02629"></a>02629 again:
<a name="l02630"></a>02630         <span class="keywordflow">while</span> (ldata-&gt;ld_lee != NULL) {
<a name="l02631"></a>02631                 lfsck_namespace_unpack_linkea_entry(ldata, cname, &amp;tfid,
<a name="l02632"></a>02632                                                     info-&gt;lti_key);
<a name="l02633"></a>02633                 <span class="comment">/* Drop repeated linkEA entries. */</span>
<a name="l02634"></a>02634                 lfsck_namespace_filter_linkea_entry(ldata, cname, &amp;tfid, <span class="keyword">true</span>);
<a name="l02635"></a>02635                 <span class="comment">/* Drop invalid linkEA entry. */</span>
<a name="l02636"></a>02636                 <span class="keywordflow">if</span> (!fid_is_sane(&amp;tfid)) {
<a name="l02637"></a>02637                         linkea_del_buf(ldata, cname);
<a name="l02638"></a>02638                         linkea_count++;
<a name="l02639"></a>02639                         <span class="keywordflow">continue</span>;
<a name="l02640"></a>02640                 }
<a name="l02641"></a>02641 
<a name="l02642"></a>02642                 <span class="comment">/* If current dotdot is the .lustre/lost+found/MDTxxxx/,</span>
<a name="l02643"></a>02643 <span class="comment">                 * then it is possible that: the directry object has ever</span>
<a name="l02644"></a>02644 <span class="comment">                 * been lost, but its name entry was there. In the former</span>
<a name="l02645"></a>02645 <span class="comment">                 * LFSCK run, during the first-stage scanning, the LFSCK</span>
<a name="l02646"></a>02646 <span class="comment">                 * found the dangling name entry, but it did not recreate</span>
<a name="l02647"></a>02647 <span class="comment">                 * the lost object, and when moved to the second-stage</span>
<a name="l02648"></a>02648 <span class="comment">                 * scanning, some children objects of the lost directory</span>
<a name="l02649"></a>02649 <span class="comment">                 * object were found, then the LFSCK recreated such lost</span>
<a name="l02650"></a>02650 <span class="comment">                 * directory object as an orphan.</span>
<a name="l02651"></a>02651 <span class="comment">                 *</span>
<a name="l02652"></a>02652 <span class="comment">                 * When the LFSCK runs again, if the dangling name is still</span>
<a name="l02653"></a>02653 <span class="comment">                 * there, the LFSCK should move the orphan directory object</span>
<a name="l02654"></a>02654 <span class="comment">                 * back to the normal namespace. */</span>
<a name="l02655"></a>02655                 <span class="keywordflow">if</span> (!lpf &amp;&amp; !lu_fid_eq(pfid, &amp;tfid) &amp;&amp; once) {
<a name="l02656"></a>02656                         linkea_next_entry(ldata);
<a name="l02657"></a>02657                         <span class="keywordflow">continue</span>;
<a name="l02658"></a>02658                 }
<a name="l02659"></a>02659 
<a name="l02660"></a>02660                 parent = lfsck_object_find_bottom(env, lfsck, &amp;tfid);
<a name="l02661"></a>02661                 <span class="keywordflow">if</span> (IS_ERR(parent))
<a name="l02662"></a>02662                         RETURN(PTR_ERR(parent));
<a name="l02663"></a>02663 
<a name="l02664"></a>02664                 <span class="keywordflow">if</span> (!dt_object_exists(parent)) {
<a name="l02665"></a>02665                         lfsck_object_put(env, parent);
<a name="l02666"></a>02666                         <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount &gt; 1) {
<a name="l02667"></a>02667                                 <span class="comment">/* If it is NOT the last linkEA entry, then</span>
<a name="l02668"></a>02668 <span class="comment">                                 * there is still other chance to make the</span>
<a name="l02669"></a>02669 <span class="comment">                                 * child to be visible via other parent, then</span>
<a name="l02670"></a>02670 <span class="comment">                                 * remove this linkEA entry. */</span>
<a name="l02671"></a>02671                                 linkea_del_buf(ldata, cname);
<a name="l02672"></a>02672                                 linkea_count++;
<a name="l02673"></a>02673                                 <span class="keywordflow">continue</span>;
<a name="l02674"></a>02674                         }
<a name="l02675"></a>02675 
<a name="l02676"></a>02676                         <span class="keywordflow">break</span>;
<a name="l02677"></a>02677                 }
<a name="l02678"></a>02678 
<a name="l02679"></a>02679                 <span class="comment">/* The linkEA entry with bad parent will be removed. */</span>
<a name="l02680"></a>02680                 <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, parent))) {
<a name="l02681"></a>02681                         lfsck_object_put(env, parent);
<a name="l02682"></a>02682                         linkea_del_buf(ldata, cname);
<a name="l02683"></a>02683                         linkea_count++;
<a name="l02684"></a>02684                         <span class="keywordflow">continue</span>;
<a name="l02685"></a>02685                 }
<a name="l02686"></a>02686 
<a name="l02687"></a>02687                 rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)&amp;tfid,
<a name="l02688"></a>02688                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)cname-&gt;ln_name);
<a name="l02689"></a>02689                 *pfid2 = *lfsck_dto2fid(parent);
<a name="l02690"></a>02690                 <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l02691"></a>02691                         lfsck_object_put(env, parent);
<a name="l02692"></a>02692                         linkea_next_entry(ldata);
<a name="l02693"></a>02693                         <span class="keywordflow">continue</span>;
<a name="l02694"></a>02694                 }
<a name="l02695"></a>02695 
<a name="l02696"></a>02696                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l02697"></a>02697                         lfsck_object_put(env, parent);
<a name="l02698"></a>02698 
<a name="l02699"></a>02699                         RETURN(rc);
<a name="l02700"></a>02700                 }
<a name="l02701"></a>02701 
<a name="l02702"></a>02702                 <span class="keywordflow">if</span> (lu_fid_eq(&amp;tfid, cfid)) {
<a name="l02703"></a>02703                         lfsck_object_put(env, parent);
<a name="l02704"></a>02704                         <span class="keywordflow">if</span> (!lu_fid_eq(pfid, pfid2)) {
<a name="l02705"></a>02705                                 *type = LNIT_UNMATCHED_PAIRS;
<a name="l02706"></a>02706                                 rc = lfsck_namespace_repair_unmatched_pairs(env,
<a name="l02707"></a>02707                                                 com, child, pfid2, cname);
<a name="l02708"></a>02708 
<a name="l02709"></a>02709                                 RETURN(rc);
<a name="l02710"></a>02710                         }
<a name="l02711"></a>02711 
<a name="l02712"></a>02712 rebuild:
<a name="l02713"></a>02713                         <span class="comment">/* It is the most common case that we find the</span>
<a name="l02714"></a>02714 <span class="comment">                         * name entry corresponding to the linkEA entry</span>
<a name="l02715"></a>02715 <span class="comment">                         * that matches the &quot;..&quot; name entry. */</span>
<a name="l02716"></a>02716                         rc = linkea_data_new(&amp;ldata_new, &amp;info-&gt;lti_big_buf);
<a name="l02717"></a>02717                         <span class="keywordflow">if</span> (rc != 0)
<a name="l02718"></a>02718                                 RETURN(rc);
<a name="l02719"></a>02719 
<a name="l02720"></a>02720                         rc = linkea_add_buf(&amp;ldata_new, cname, pfid2);
<a name="l02721"></a>02721                         <span class="keywordflow">if</span> (rc != 0)
<a name="l02722"></a>02722                                 RETURN(rc);
<a name="l02723"></a>02723 
<a name="l02724"></a>02724                         rc = lfsck_namespace_rebuild_linkea(env, com, child,
<a name="l02725"></a>02725                                                             &amp;ldata_new);
<a name="l02726"></a>02726                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02727"></a>02727                                 RETURN(rc);
<a name="l02728"></a>02728 
<a name="l02729"></a>02729                         linkea_del_buf(ldata, cname);
<a name="l02730"></a>02730                         linkea_count++;
<a name="l02731"></a>02731                         linkea_first_entry(ldata);
<a name="l02732"></a>02732                         <span class="comment">/* There may be some invalid dangling name entries under</span>
<a name="l02733"></a>02733 <span class="comment">                         * other parent directories, remove all of them. */</span>
<a name="l02734"></a>02734                         <span class="keywordflow">while</span> (ldata-&gt;ld_lee != NULL) {
<a name="l02735"></a>02735                                 lfsck_namespace_unpack_linkea_entry(ldata,
<a name="l02736"></a>02736                                                 cname, &amp;tfid, info-&gt;lti_key);
<a name="l02737"></a>02737                                 <span class="keywordflow">if</span> (!fid_is_sane(&amp;tfid))
<a name="l02738"></a>02738                                         <span class="keywordflow">goto</span> next;
<a name="l02739"></a>02739 
<a name="l02740"></a>02740                                 parent = lfsck_object_find_bottom(env, lfsck,
<a name="l02741"></a>02741                                                                   &amp;tfid);
<a name="l02742"></a>02742                                 <span class="keywordflow">if</span> (IS_ERR(parent)) {
<a name="l02743"></a>02743                                         rc = PTR_ERR(parent);
<a name="l02744"></a>02744                                         <span class="keywordflow">if</span> (rc != -ENOENT &amp;&amp;
<a name="l02745"></a>02745                                             bk-&gt;lb_param &amp; LPF_FAILOUT)
<a name="l02746"></a>02746                                                 RETURN(rc);
<a name="l02747"></a>02747 
<a name="l02748"></a>02748                                         <span class="keywordflow">goto</span> next;
<a name="l02749"></a>02749                                 }
<a name="l02750"></a>02750 
<a name="l02751"></a>02751                                 <span class="keywordflow">if</span> (!dt_object_exists(parent)) {
<a name="l02752"></a>02752                                         lfsck_object_put(env, parent);
<a name="l02753"></a>02753                                         <span class="keywordflow">goto</span> next;
<a name="l02754"></a>02754                                 }
<a name="l02755"></a>02755 
<a name="l02756"></a>02756                                 rc = lfsck_namespace_repair_dirent(env, com,
<a name="l02757"></a>02757                                         parent, child, cname-&gt;ln_name,
<a name="l02758"></a>02758                                         cname-&gt;ln_name, S_IFDIR, <span class="keyword">false</span>, <span class="keyword">true</span>);
<a name="l02759"></a>02759                                 lfsck_object_put(env, parent);
<a name="l02760"></a>02760                                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02761"></a>02761                                         <span class="keywordflow">if</span> (bk-&gt;lb_param &amp; LPF_FAILOUT)
<a name="l02762"></a>02762                                                 RETURN(rc);
<a name="l02763"></a>02763 
<a name="l02764"></a>02764                                         <span class="keywordflow">goto</span> next;
<a name="l02765"></a>02765                                 }
<a name="l02766"></a>02766 
<a name="l02767"></a>02767                                 dirent_count += rc;
<a name="l02768"></a>02768 
<a name="l02769"></a>02769 next:
<a name="l02770"></a>02770                                 linkea_del_buf(ldata, cname);
<a name="l02771"></a>02771                         }
<a name="l02772"></a>02772 
<a name="l02773"></a>02773                         ns-&gt;ln_dirent_repaired += dirent_count;
<a name="l02774"></a>02774 
<a name="l02775"></a>02775                         RETURN(rc);
<a name="l02776"></a>02776                 }
<a name="l02777"></a>02777 
<a name="l02778"></a>02778                 lfsck_ibits_unlock(lh, LCK_EX);
<a name="l02779"></a>02779                 <span class="comment">/* The name entry references another MDT-object that may be</span>
<a name="l02780"></a>02780 <span class="comment">                 * created by the LFSCK for repairing dangling name entry.</span>
<a name="l02781"></a>02781 <span class="comment">                 * Try to replace it. */</span>
<a name="l02782"></a>02782                 rc = lfsck_namespace_replace_cond(env, com, parent, child,
<a name="l02783"></a>02783                                                   &amp;tfid, cname);
<a name="l02784"></a>02784                 lfsck_object_put(env, parent);
<a name="l02785"></a>02785                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02786"></a>02786                         RETURN(rc);
<a name="l02787"></a>02787 
<a name="l02788"></a>02788                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l02789"></a>02789                         <span class="keywordflow">goto</span> rebuild;
<a name="l02790"></a>02790 
<a name="l02791"></a>02791                 linkea_del_buf(ldata, cname);
<a name="l02792"></a>02792         }
<a name="l02793"></a>02793 
<a name="l02794"></a>02794         linkea_first_entry(ldata);
<a name="l02795"></a>02795         <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount == 1) {
<a name="l02796"></a>02796                 rc = lfsck_namespace_dsd_single(env, com, child, pfid, ldata,
<a name="l02797"></a>02797                                                 lh, type, NULL);
<a name="l02798"></a>02798 
<a name="l02799"></a>02799                 <span class="keywordflow">if</span> (rc == 0 &amp;&amp; fid_is_zero(pfid) &amp;&amp; linkea_count &gt; 0)
<a name="l02800"></a>02800                         rc = lfsck_namespace_rebuild_linkea(env, com, child,
<a name="l02801"></a>02801                                                             ldata);
<a name="l02802"></a>02802 
<a name="l02803"></a>02803                 RETURN(rc);
<a name="l02804"></a>02804         }
<a name="l02805"></a>02805 
<a name="l02806"></a>02806         <span class="comment">/* All linkEA entries are invalid and removed, then handle the @child</span>
<a name="l02807"></a>02807 <span class="comment">         * as an orphan.*/</span>
<a name="l02808"></a>02808         <span class="keywordflow">if</span> (ldata-&gt;<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount == 0) {
<a name="l02809"></a>02809                 rc = lfsck_namespace_dsd_orphan(env, com, child, pfid, lh,
<a name="l02810"></a>02810                                                 type);
<a name="l02811"></a>02811 
<a name="l02812"></a>02812                 RETURN(rc);
<a name="l02813"></a>02813         }
<a name="l02814"></a>02814 
<a name="l02815"></a>02815         <span class="comment">/* If the dangling name entry for the orphan directory object has</span>
<a name="l02816"></a>02816 <span class="comment">         * been remvoed, then just check whether the directory object is</span>
<a name="l02817"></a>02817 <span class="comment">         * still under the .lustre/lost+found/MDTxxxx/ or not. */</span>
<a name="l02818"></a>02818         <span class="keywordflow">if</span> (lpf) {
<a name="l02819"></a>02819                 lpf = <span class="keyword">false</span>;
<a name="l02820"></a>02820                 <span class="keywordflow">goto</span> again;
<a name="l02821"></a>02821         }
<a name="l02822"></a>02822 
<a name="l02823"></a>02823         <span class="comment">/* There is no linkEA entry that matches the &quot;..&quot; name entry. Find</span>
<a name="l02824"></a>02824 <span class="comment">         * the first linkEA entry that both parent and name entry exist to</span>
<a name="l02825"></a>02825 <span class="comment">         * rebuild a new &quot;..&quot; name entry. */</span>
<a name="l02826"></a>02826         <span class="keywordflow">if</span> (once) {
<a name="l02827"></a>02827                 once = <span class="keyword">false</span>;
<a name="l02828"></a>02828                 <span class="keywordflow">goto</span> again;
<a name="l02829"></a>02829         }
<a name="l02830"></a>02830 
<a name="l02831"></a>02831         RETURN(rc);
<a name="l02832"></a>02832 }
<a name="l02833"></a>02833 
<a name="l02853"></a>02853 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_repair_nlink(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02854"></a>02854                                         <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l02855"></a>02855                                         <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l02856"></a>02856                                         <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la)
<a name="l02857"></a>02857 {
<a name="l02858"></a>02858         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l02859"></a>02859         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>                   *tfid   = &amp;info-&gt;lti_fid3;
<a name="l02860"></a>02860         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns     = com-&gt;lc_file_ram;
<a name="l02861"></a>02861         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l02862"></a>02862         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck_obj2dev(obj);
<a name="l02863"></a>02863         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *cfid   = lfsck_dto2fid(obj);
<a name="l02864"></a>02864         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l02865"></a>02865         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>               ldata  = { NULL };
<a name="l02866"></a>02866         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>             lh     = { 0 };
<a name="l02867"></a>02867         __u32                            old    = la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a>;
<a name="l02868"></a>02868         <span class="keywordtype">int</span>                              idx;
<a name="l02869"></a>02869         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l02870"></a>02870         __u8                             flags;
<a name="l02871"></a>02871         ENTRY;
<a name="l02872"></a>02872 
<a name="l02873"></a>02873         LASSERT(!dt_object_remote(obj));
<a name="l02874"></a>02874         LASSERT(S_ISREG(lfsck_object_type(obj)));
<a name="l02875"></a>02875 
<a name="l02876"></a>02876         rc = lfsck_ibits_lock(env, lfsck, obj, &amp;lh,
<a name="l02877"></a>02877                               MDS_INODELOCK_UPDATE, LCK_PW);
<a name="l02878"></a>02878         <span class="keywordflow">if</span> (rc != 0)
<a name="l02879"></a>02879                 GOTO(log, rc);
<a name="l02880"></a>02880 
<a name="l02881"></a>02881         th = dt_trans_create(env, dev);
<a name="l02882"></a>02882         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l02883"></a>02883                 GOTO(log, rc = PTR_ERR(th));
<a name="l02884"></a>02884 
<a name="l02885"></a>02885         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_NLINK;
<a name="l02886"></a>02886         rc = dt_declare_attr_set(env, obj, la, th);
<a name="l02887"></a>02887         <span class="keywordflow">if</span> (rc != 0)
<a name="l02888"></a>02888                 GOTO(stop, rc);
<a name="l02889"></a>02889 
<a name="l02890"></a>02890         rc = dt_trans_start_local(env, dev, th);
<a name="l02891"></a>02891         <span class="keywordflow">if</span> (rc != 0)
<a name="l02892"></a>02892                 GOTO(stop, rc);
<a name="l02893"></a>02893 
<a name="l02894"></a>02894         dt_write_lock(env, obj, 0);
<a name="l02895"></a>02895         <span class="comment">/* If the LFSCK is marked as LF_INCOMPLETE, then means some MDT has</span>
<a name="l02896"></a>02896 <span class="comment">         * ever tried to verify some remote MDT-object that resides on this</span>
<a name="l02897"></a>02897 <span class="comment">         * MDT, but this MDT failed to respond such request. So means there</span>
<a name="l02898"></a>02898 <span class="comment">         * may be some remote name entry on other MDT that references this</span>
<a name="l02899"></a>02899 <span class="comment">         * object with another name, so we cannot know whether this linkEA</span>
<a name="l02900"></a>02900 <span class="comment">         * is valid or not. So keep it there and maybe resolved when next</span>
<a name="l02901"></a>02901 <span class="comment">         * LFSCK run. */</span>
<a name="l02902"></a>02902         <span class="keywordflow">if</span> (ns-&gt;ln_flags &amp; LF_INCOMPLETE)
<a name="l02903"></a>02903                 GOTO(unlock, rc = 0);
<a name="l02904"></a>02904 
<a name="l02905"></a>02905         fid_cpu_to_be(tfid, cfid);
<a name="l02906"></a>02906         idx = lfsck_sub_trace_file_fid2idx(cfid);
<a name="l02907"></a>02907         rc = dt_lookup(env, com-&gt;lc_sub_trace_objs[idx].lsto_obj,
<a name="l02908"></a>02908                        (<span class="keyword">struct</span> dt_rec *)&amp;flags, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)tfid);
<a name="l02909"></a>02909         <span class="keywordflow">if</span> (rc != 0)
<a name="l02910"></a>02910                 GOTO(unlock, rc);
<a name="l02911"></a>02911 
<a name="l02912"></a>02912         <span class="keywordflow">if</span> (flags &amp; LNTF_SKIP_NLINK)
<a name="l02913"></a>02913                 GOTO(unlock, rc = 0);
<a name="l02914"></a>02914 
<a name="l02915"></a>02915         rc = dt_attr_get(env, obj, la);
<a name="l02916"></a>02916         <span class="keywordflow">if</span> (rc != 0)
<a name="l02917"></a>02917                 GOTO(unlock, rc = (rc == -ENOENT ? 0 : rc));
<a name="l02918"></a>02918 
<a name="l02919"></a>02919         rc = lfsck_links_read2(env, obj, &amp;ldata);
<a name="l02920"></a>02920         <span class="keywordflow">if</span> (rc != 0)
<a name="l02921"></a>02921                 GOTO(unlock, rc = (rc == -ENODATA ? 0 : rc));
<a name="l02922"></a>02922 
<a name="l02923"></a>02923         <span class="keywordflow">if</span> (la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> == ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount ||
<a name="l02924"></a>02924             unlikely(la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> == 0))
<a name="l02925"></a>02925                 GOTO(unlock, rc = 0);
<a name="l02926"></a>02926 
<a name="l02927"></a>02927         la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> = ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount;
<a name="l02928"></a>02928         <span class="keywordflow">if</span> (lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN)
<a name="l02929"></a>02929                 GOTO(unlock, rc = 1);
<a name="l02930"></a>02930 
<a name="l02931"></a>02931         rc = dt_attr_set(env, obj, la, th);
<a name="l02932"></a>02932 
<a name="l02933"></a>02933         GOTO(unlock, rc = (rc == 0 ? 1 : rc));
<a name="l02934"></a>02934 
<a name="l02935"></a>02935 unlock:
<a name="l02936"></a>02936         dt_write_unlock(env, obj);
<a name="l02937"></a>02937 
<a name="l02938"></a>02938 stop:
<a name="l02939"></a>02939         dt_trans_stop(env, dev, th);
<a name="l02940"></a>02940 
<a name="l02941"></a>02941 log:
<a name="l02942"></a>02942         lfsck_ibits_unlock(&amp;lh, LCK_PW);
<a name="l02943"></a>02943         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK repaired the object &quot;</span>DFID<span class="stringliteral">&quot;&apos;s &quot;</span>
<a name="l02944"></a>02944                <span class="stringliteral">&quot;nlink count from %u to %u: rc = %d\n&quot;</span>,
<a name="l02945"></a>02945                lfsck_lfsck2name(lfsck), PFID(cfid), old, la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a>, rc);
<a name="l02946"></a>02946 
<a name="l02947"></a>02947         <span class="keywordflow">if</span> (rc != 0)
<a name="l02948"></a>02948                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l02949"></a>02949 
<a name="l02950"></a>02950         <span class="keywordflow">return</span> rc;
<a name="l02951"></a>02951 }
<a name="l02952"></a>02952 
<a name="l02990"></a>02990 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_double_scan_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02991"></a>02991                                            <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l02992"></a>02992                                            <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child, __u8 flags)
<a name="l02993"></a>02993 {
<a name="l02994"></a>02994         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a> *info          = lfsck_env_info(env);
<a name="l02995"></a>02995         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>      *cfid          = lfsck_dto2fid(child);
<a name="l02996"></a>02996         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>            *pfid          = &amp;info-&gt;lti_fid2;
<a name="l02997"></a>02997         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>   *ns            = com-&gt;lc_file_ram;
<a name="l02998"></a>02998         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>    *lfsck         = com-&gt;lc_lfsck;
<a name="l02999"></a>02999         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>      lh            = { 0 };
<a name="l03000"></a>03000         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>        ldata         = { NULL };
<a name="l03001"></a>03001         <span class="keywordtype">bool</span>                      unknown       = <span class="keyword">false</span>;
<a name="l03002"></a>03002         <span class="keywordtype">bool</span>                      lpf           = <span class="keyword">false</span>;
<a name="l03003"></a>03003         <span class="keywordtype">bool</span>                      retry         = <span class="keyword">false</span>;
<a name="l03004"></a>03004         <span class="keyword">enum</span> lfsck_namespace_inconsistency_type type = LNIT_BAD_LINKEA;
<a name="l03005"></a>03005         <span class="keywordtype">int</span>                       rc            = 0;
<a name="l03006"></a>03006         ENTRY;
<a name="l03007"></a>03007 
<a name="l03008"></a>03008         LASSERT(!dt_object_remote(child));
<a name="l03009"></a>03009 
<a name="l03010"></a>03010         <span class="keywordflow">if</span> (flags &amp; LNTF_UNCERTAIN_LMV) {
<a name="l03011"></a>03011                 <span class="keywordflow">if</span> (flags &amp; LNTF_RECHECK_NAME_HASH) {
<a name="l03012"></a>03012                         rc = lfsck_namespace_scan_shard(env, com, child);
<a name="l03013"></a>03013                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03014"></a>03014                                 RETURN(rc);
<a name="l03015"></a>03015 
<a name="l03016"></a>03016                         ns-&gt;ln_striped_shards_scanned++;
<a name="l03017"></a>03017                 } <span class="keywordflow">else</span> {
<a name="l03018"></a>03018                         ns-&gt;ln_striped_shards_skipped++;
<a name="l03019"></a>03019                 }
<a name="l03020"></a>03020         }
<a name="l03021"></a>03021 
<a name="l03022"></a>03022         flags &amp;= ~(LNTF_RECHECK_NAME_HASH | LNTF_UNCERTAIN_LMV);
<a name="l03023"></a>03023         <span class="keywordflow">if</span> (flags == 0)
<a name="l03024"></a>03024                 RETURN(0);
<a name="l03025"></a>03025 
<a name="l03026"></a>03026         <span class="keywordflow">if</span> (flags &amp; (LNTF_CHECK_LINKEA | LNTF_CHECK_PARENT) &amp;&amp;
<a name="l03027"></a>03027             !(lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_ALL_TGT)) {
<a name="l03028"></a>03028                 CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: some MDT(s) maybe NOT take part in the&quot;</span>
<a name="l03029"></a>03029                        <span class="stringliteral">&quot;the namespace LFSCK, then the LFSCK cannot guarantee&quot;</span>
<a name="l03030"></a>03030                        <span class="stringliteral">&quot;all the name entries have been verified in first-stage&quot;</span>
<a name="l03031"></a>03031                        <span class="stringliteral">&quot;scanning. So have to skip orphan related handling for&quot;</span>
<a name="l03032"></a>03032                        <span class="stringliteral">&quot;the directory object &quot;</span>DFID<span class="stringliteral">&quot; with remote name entry\n&quot;</span>,
<a name="l03033"></a>03033                        lfsck_lfsck2name(lfsck), PFID(cfid));
<a name="l03034"></a>03034 
<a name="l03035"></a>03035                 RETURN(0);
<a name="l03036"></a>03036         }
<a name="l03037"></a>03037 
<a name="l03038"></a>03038         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, child)))
<a name="l03039"></a>03039                 GOTO(out, rc = -ENOTDIR);
<a name="l03040"></a>03040 
<a name="l03041"></a>03041         <span class="comment">/* We only take ldlm lock on the @child when required. When the</span>
<a name="l03042"></a>03042 <span class="comment">         * logic comes here for the first time, it is always false. */</span>
<a name="l03043"></a>03043         <span class="keywordflow">if</span> (0) {
<a name="l03044"></a>03044 
<a name="l03045"></a>03045 lock:
<a name="l03046"></a>03046                 rc = lfsck_ibits_lock(env, lfsck, child, &amp;lh,
<a name="l03047"></a>03047                                       MDS_INODELOCK_UPDATE |
<a name="l03048"></a>03048                                       MDS_INODELOCK_XATTR, LCK_EX);
<a name="l03049"></a>03049                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03050"></a>03050                         GOTO(out, rc);
<a name="l03051"></a>03051         }
<a name="l03052"></a>03052 
<a name="l03053"></a>03053         dt_read_lock(env, child, 0);
<a name="l03054"></a>03054         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(child))) {
<a name="l03055"></a>03055                 dt_read_unlock(env, child);
<a name="l03056"></a>03056 
<a name="l03057"></a>03057                 GOTO(out, rc = 0);
<a name="l03058"></a>03058         }
<a name="l03059"></a>03059 
<a name="l03060"></a>03060         rc = dt_lookup(env, child, (<span class="keyword">struct</span> dt_rec *)pfid,
<a name="l03061"></a>03061                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot);
<a name="l03062"></a>03062         <span class="keywordflow">if</span> (rc != 0) {
<a name="l03063"></a>03063                 <span class="keywordflow">if</span> (rc != -ENOENT &amp;&amp; rc != -ENODATA &amp;&amp; rc != -EINVAL) {
<a name="l03064"></a>03064                         dt_read_unlock(env, child);
<a name="l03065"></a>03065 
<a name="l03066"></a>03066                         GOTO(out, rc);
<a name="l03067"></a>03067                 }
<a name="l03068"></a>03068 
<a name="l03069"></a>03069                 <span class="keywordflow">if</span> (!lustre_handle_is_used(&amp;lh)) {
<a name="l03070"></a>03070                         dt_read_unlock(env, child);
<a name="l03071"></a>03071                         <span class="keywordflow">goto</span> lock;
<a name="l03072"></a>03072                 }
<a name="l03073"></a>03073 
<a name="l03074"></a>03074                 fid_zero(pfid);
<a name="l03075"></a>03075         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lfsck-&gt;li_lpf_obj != NULL &amp;&amp;
<a name="l03076"></a>03076                    lu_fid_eq(pfid, lfsck_dto2fid(lfsck-&gt;li_lpf_obj))) {
<a name="l03077"></a>03077                 lpf = <span class="keyword">true</span>;
<a name="l03078"></a>03078         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (unlikely(!fid_is_sane(pfid))) {
<a name="l03079"></a>03079                 fid_zero(pfid);
<a name="l03080"></a>03080         }
<a name="l03081"></a>03081 
<a name="l03082"></a>03082         rc = lfsck_links_read(env, child, &amp;ldata);
<a name="l03083"></a>03083         dt_read_unlock(env, child);
<a name="l03084"></a>03084         <span class="keywordflow">if</span> (rc != 0) {
<a name="l03085"></a>03085                 <span class="keywordflow">if</span> (rc != -ENODATA &amp;&amp; rc != -EINVAL)
<a name="l03086"></a>03086                         GOTO(out, rc);
<a name="l03087"></a>03087 
<a name="l03088"></a>03088                 <span class="keywordflow">if</span> (!lustre_handle_is_used(&amp;lh))
<a name="l03089"></a>03089                         <span class="keywordflow">goto</span> lock;
<a name="l03090"></a>03090 
<a name="l03091"></a>03091                 <span class="keywordflow">if</span> (rc == -EINVAL &amp;&amp; !fid_is_zero(pfid)) {
<a name="l03092"></a>03092                         <span class="comment">/* Remove the corrupted linkEA. */</span>
<a name="l03093"></a>03093                         rc = lfsck_namespace_links_remove(env, com, child);
<a name="l03094"></a>03094                         <span class="keywordflow">if</span> (rc == 0)
<a name="l03095"></a>03095                                 <span class="comment">/* Here, because of the crashed linkEA, we</span>
<a name="l03096"></a>03096 <span class="comment">                                 * cannot know whether there is some parent</span>
<a name="l03097"></a>03097 <span class="comment">                                 * that references the child directory via</span>
<a name="l03098"></a>03098 <span class="comment">                                 * some name entry or not. So keep it there,</span>
<a name="l03099"></a>03099 <span class="comment">                                 * when the LFSCK run next time, if there is</span>
<a name="l03100"></a>03100 <span class="comment">                                 * some parent that references this object,</span>
<a name="l03101"></a>03101 <span class="comment">                                 * then the LFSCK can rebuild the linkEA;</span>
<a name="l03102"></a>03102 <span class="comment">                                 * otherwise, this object will be handled</span>
<a name="l03103"></a>03103 <span class="comment">                                 * as orphan as above. */</span>
<a name="l03104"></a>03104                                 unknown = <span class="keyword">true</span>;
<a name="l03105"></a>03105                 } <span class="keywordflow">else</span> {
<a name="l03106"></a>03106                         <span class="comment">/* 1. If we have neither &quot;..&quot; nor linkEA,</span>
<a name="l03107"></a>03107 <span class="comment">                         *    then it is an orphan.</span>
<a name="l03108"></a>03108 <span class="comment">                         *</span>
<a name="l03109"></a>03109 <span class="comment">                         * 2. If we only have the &quot;..&quot; name entry,</span>
<a name="l03110"></a>03110 <span class="comment">                         *    but no parent references this child</span>
<a name="l03111"></a>03111 <span class="comment">                         *    directory, then handle it as orphan. */</span>
<a name="l03112"></a>03112                         lfsck_ibits_unlock(&amp;lh, LCK_EX);
<a name="l03113"></a>03113                         type = LNIT_MUL_REF;
<a name="l03114"></a>03114 
<a name="l03115"></a>03115                         <span class="comment">/* If the LFSCK is marked as LF_INCOMPLETE,</span>
<a name="l03116"></a>03116 <span class="comment">                         * then means some MDT has ever tried to</span>
<a name="l03117"></a>03117 <span class="comment">                         * verify some remote MDT-object that resides</span>
<a name="l03118"></a>03118 <span class="comment">                         * on this MDT, but this MDT failed to respond</span>
<a name="l03119"></a>03119 <span class="comment">                         * such request. So means there may be some</span>
<a name="l03120"></a>03120 <span class="comment">                         * remote name entry on other MDT that</span>
<a name="l03121"></a>03121 <span class="comment">                         * references this object with another name,</span>
<a name="l03122"></a>03122 <span class="comment">                         * so we cannot know whether this linkEA is</span>
<a name="l03123"></a>03123 <span class="comment">                         * valid or not. So keep it there and maybe</span>
<a name="l03124"></a>03124 <span class="comment">                         * resolved when next LFSCK run. */</span>
<a name="l03125"></a>03125                         <span class="keywordflow">if</span> (ns-&gt;ln_flags &amp; LF_INCOMPLETE)
<a name="l03126"></a>03126                                 GOTO(out, rc = 0);
<a name="l03127"></a>03127 
<a name="l03128"></a>03128                         snprintf(info-&gt;lti_tmpbuf, <span class="keyword">sizeof</span>(info-&gt;lti_tmpbuf),
<a name="l03129"></a>03129                                  <span class="stringliteral">&quot;-&quot;</span>DFID, PFID(pfid));
<a name="l03130"></a>03130                         rc = lfsck_namespace_insert_orphan(env, com, child,
<a name="l03131"></a>03131                                                 info-&gt;lti_tmpbuf, <span class="stringliteral">&quot;D&quot;</span>, NULL);
<a name="l03132"></a>03132                 }
<a name="l03133"></a>03133 
<a name="l03134"></a>03134                 GOTO(out, rc);
<a name="l03135"></a>03135         }
<a name="l03136"></a>03136 
<a name="l03137"></a>03137         linkea_first_entry(&amp;ldata);
<a name="l03138"></a>03138         <span class="comment">/* This is the most common case: the object has unique linkEA entry. */</span>
<a name="l03139"></a>03139         <span class="keywordflow">if</span> (ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount == 1) {
<a name="l03140"></a>03140                 rc = lfsck_namespace_dsd_single(env, com, child, pfid, &amp;ldata,
<a name="l03141"></a>03141                                                 &amp;lh, &amp;type, &amp;retry);
<a name="l03142"></a>03142                 <span class="keywordflow">if</span> (retry) {
<a name="l03143"></a>03143                         LASSERT(!lustre_handle_is_used(&amp;lh));
<a name="l03144"></a>03144 
<a name="l03145"></a>03145                         retry = <span class="keyword">false</span>;
<a name="l03146"></a>03146                         <span class="keywordflow">goto</span> lock;
<a name="l03147"></a>03147                 }
<a name="l03148"></a>03148 
<a name="l03149"></a>03149                 GOTO(out, rc);
<a name="l03150"></a>03150         }
<a name="l03151"></a>03151 
<a name="l03152"></a>03152         <span class="keywordflow">if</span> (!lustre_handle_is_used(&amp;lh))
<a name="l03153"></a>03153                 <span class="keywordflow">goto</span> lock;
<a name="l03154"></a>03154 
<a name="l03155"></a>03155         <span class="keywordflow">if</span> (unlikely(ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount == 0)) {
<a name="l03156"></a>03156                 rc = lfsck_namespace_dsd_orphan(env, com, child, pfid, &amp;lh,
<a name="l03157"></a>03157                                                 &amp;type);
<a name="l03158"></a>03158 
<a name="l03159"></a>03159                 GOTO(out, rc);
<a name="l03160"></a>03160         }
<a name="l03161"></a>03161 
<a name="l03162"></a>03162         <span class="comment">/* When we come here, the cases usually like that:</span>
<a name="l03163"></a>03163 <span class="comment">         * 1) The directory object has a corrupted linkEA entry. During the</span>
<a name="l03164"></a>03164 <span class="comment">         *    first-stage scanning, the LFSCK cannot know such corruption,</span>
<a name="l03165"></a>03165 <span class="comment">         *    then it appends the right linkEA entry according to the found</span>
<a name="l03166"></a>03166 <span class="comment">         *    name entry after the bad one.</span>
<a name="l03167"></a>03167 <span class="comment">         *</span>
<a name="l03168"></a>03168 <span class="comment">         * 2) The directory object has a right linkEA entry. During the</span>
<a name="l03169"></a>03169 <span class="comment">         *    first-stage scanning, the LFSCK finds some bad name entry,</span>
<a name="l03170"></a>03170 <span class="comment">         *    but the LFSCK cannot aware that at that time, then it adds</span>
<a name="l03171"></a>03171 <span class="comment">         *    the bad linkEA entry for further processing. */</span>
<a name="l03172"></a>03172         rc = lfsck_namespace_dsd_multiple(env, com, child, pfid, &amp;ldata,
<a name="l03173"></a>03173                                           &amp;lh, &amp;type, lpf);
<a name="l03174"></a>03174 
<a name="l03175"></a>03175         GOTO(out, rc);
<a name="l03176"></a>03176 
<a name="l03177"></a>03177 out:
<a name="l03178"></a>03178         lfsck_ibits_unlock(&amp;lh, LCK_EX);
<a name="l03179"></a>03179         <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l03180"></a>03180                 <span class="keywordflow">switch</span> (type) {
<a name="l03181"></a>03181                 <span class="keywordflow">case</span> LNIT_BAD_LINKEA:
<a name="l03182"></a>03182                         ns-&gt;ln_linkea_repaired++;
<a name="l03183"></a>03183                         <span class="keywordflow">break</span>;
<a name="l03184"></a>03184                 <span class="keywordflow">case</span> LNIT_UNMATCHED_PAIRS:
<a name="l03185"></a>03185                         ns-&gt;ln_unmatched_pairs_repaired++;
<a name="l03186"></a>03186                         <span class="keywordflow">break</span>;
<a name="l03187"></a>03187                 <span class="keywordflow">case</span> LNIT_MUL_REF:
<a name="l03188"></a>03188                         ns-&gt;ln_mul_ref_repaired++;
<a name="l03189"></a>03189                         <span class="keywordflow">break</span>;
<a name="l03190"></a>03190                 <span class="keywordflow">default</span>:
<a name="l03191"></a>03191                         <span class="keywordflow">break</span>;
<a name="l03192"></a>03192                 }
<a name="l03193"></a>03193         }
<a name="l03194"></a>03194 
<a name="l03195"></a>03195         <span class="keywordflow">if</span> (unknown)
<a name="l03196"></a>03196                 ns-&gt;ln_unknown_inconsistency++;
<a name="l03197"></a>03197 
<a name="l03198"></a>03198         <span class="keywordflow">return</span> rc;
<a name="l03199"></a>03199 }
<a name="l03200"></a>03200 
<a name="l03220"></a>03220 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_double_scan_one(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03221"></a>03221                                            <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l03222"></a>03222                                            <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child, __u8 flags)
<a name="l03223"></a>03223 {
<a name="l03224"></a>03224         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a> *info     = lfsck_env_info(env);
<a name="l03225"></a>03225         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>           *la       = &amp;info-&gt;lti_la;
<a name="l03226"></a>03226         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>           *cname    = &amp;info-&gt;lti_name;
<a name="l03227"></a>03227         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>            *pfid     = &amp;info-&gt;lti_fid;
<a name="l03228"></a>03228         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>            *cfid     = &amp;info-&gt;lti_fid2;
<a name="l03229"></a>03229         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>    *lfsck    = com-&gt;lc_lfsck;
<a name="l03230"></a>03230         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>   *ns       = com-&gt;lc_file_ram;
<a name="l03231"></a>03231         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>         *parent   = NULL;
<a name="l03232"></a>03232         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>        ldata    = { NULL };
<a name="l03233"></a>03233         <span class="keywordtype">bool</span>                      repaired = <span class="keyword">false</span>;
<a name="l03234"></a>03234         <span class="keywordtype">int</span>                       count    = 0;
<a name="l03235"></a>03235         <span class="keywordtype">int</span>                       rc;
<a name="l03236"></a>03236         ENTRY;
<a name="l03237"></a>03237 
<a name="l03238"></a>03238         dt_read_lock(env, child, 0);
<a name="l03239"></a>03239         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(child))) {
<a name="l03240"></a>03240                 dt_read_unlock(env, child);
<a name="l03241"></a>03241 
<a name="l03242"></a>03242                 RETURN(0);
<a name="l03243"></a>03243         }
<a name="l03244"></a>03244 
<a name="l03245"></a>03245         <span class="keywordflow">if</span> (S_ISDIR(lfsck_object_type(child))) {
<a name="l03246"></a>03246                 dt_read_unlock(env, child);
<a name="l03247"></a>03247                 rc = lfsck_namespace_double_scan_dir(env, com, child, flags);
<a name="l03248"></a>03248 
<a name="l03249"></a>03249                 RETURN(rc);
<a name="l03250"></a>03250         }
<a name="l03251"></a>03251 
<a name="l03252"></a>03252         rc = lfsck_links_read(env, child, &amp;ldata);
<a name="l03253"></a>03253         dt_read_unlock(env, child);
<a name="l03254"></a>03254         <span class="keywordflow">if</span> (rc != 0)
<a name="l03255"></a>03255                 GOTO(out, rc);
<a name="l03256"></a>03256 
<a name="l03257"></a>03257         linkea_first_entry(&amp;ldata);
<a name="l03258"></a>03258         <span class="keywordflow">while</span> (ldata.ld_lee != NULL) {
<a name="l03259"></a>03259                 lfsck_namespace_unpack_linkea_entry(&amp;ldata, cname, pfid,
<a name="l03260"></a>03260                                                     info-&gt;lti_key);
<a name="l03261"></a>03261                 rc = lfsck_namespace_filter_linkea_entry(&amp;ldata, cname, pfid,
<a name="l03262"></a>03262                                                          <span class="keyword">false</span>);
<a name="l03263"></a>03263                 <span class="comment">/* Found repeated linkEA entries */</span>
<a name="l03264"></a>03264                 <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l03265"></a>03265                         rc = lfsck_namespace_shrink_linkea(env, com, child,
<a name="l03266"></a>03266                                                 &amp;ldata, cname, pfid, <span class="keyword">false</span>);
<a name="l03267"></a>03267                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03268"></a>03268                                 GOTO(out, rc);
<a name="l03269"></a>03269 
<a name="l03270"></a>03270                         <span class="keywordflow">if</span> (rc == 0)
<a name="l03271"></a>03271                                 <span class="keywordflow">continue</span>;
<a name="l03272"></a>03272 
<a name="l03273"></a>03273                         repaired = <span class="keyword">true</span>;
<a name="l03274"></a>03274 
<a name="l03275"></a>03275                         <span class="comment">/* fall through */</span>
<a name="l03276"></a>03276                 }
<a name="l03277"></a>03277 
<a name="l03278"></a>03278                 <span class="comment">/* Invalid PFID in the linkEA entry. */</span>
<a name="l03279"></a>03279                 <span class="keywordflow">if</span> (!fid_is_sane(pfid)) {
<a name="l03280"></a>03280                         rc = lfsck_namespace_shrink_linkea(env, com, child,
<a name="l03281"></a>03281                                                 &amp;ldata, cname, pfid, <span class="keyword">true</span>);
<a name="l03282"></a>03282                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03283"></a>03283                                 GOTO(out, rc);
<a name="l03284"></a>03284 
<a name="l03285"></a>03285                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l03286"></a>03286                                 repaired = <span class="keyword">true</span>;
<a name="l03287"></a>03287 
<a name="l03288"></a>03288                         <span class="keywordflow">continue</span>;
<a name="l03289"></a>03289                 }
<a name="l03290"></a>03290 
<a name="l03291"></a>03291                 parent = lfsck_object_find_bottom(env, lfsck, pfid);
<a name="l03292"></a>03292                 <span class="keywordflow">if</span> (IS_ERR(parent))
<a name="l03293"></a>03293                         GOTO(out, rc = PTR_ERR(parent));
<a name="l03294"></a>03294 
<a name="l03295"></a>03295                 <span class="keywordflow">if</span> (!dt_object_exists(parent)) {
<a name="l03296"></a>03296 
<a name="l03297"></a>03297 lost_parent:
<a name="l03298"></a>03298                         <span class="keywordflow">if</span> (ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount &gt; 1) {
<a name="l03299"></a>03299                                 <span class="comment">/* If it is NOT the last linkEA entry, then</span>
<a name="l03300"></a>03300 <span class="comment">                                 * there is still other chance to make the</span>
<a name="l03301"></a>03301 <span class="comment">                                 * child to be visible via other parent, then</span>
<a name="l03302"></a>03302 <span class="comment">                                 * remove this linkEA entry. */</span>
<a name="l03303"></a>03303                                 rc = lfsck_namespace_shrink_linkea(env, com,
<a name="l03304"></a>03304                                         child, &amp;ldata, cname, pfid, <span class="keyword">true</span>);
<a name="l03305"></a>03305                         } <span class="keywordflow">else</span> {
<a name="l03306"></a>03306                                 <span class="comment">/* If the LFSCK is marked as LF_INCOMPLETE,</span>
<a name="l03307"></a>03307 <span class="comment">                                 * then means some MDT has ever tried to</span>
<a name="l03308"></a>03308 <span class="comment">                                 * verify some remote MDT-object that resides</span>
<a name="l03309"></a>03309 <span class="comment">                                 * on this MDT, but this MDT failed to respond</span>
<a name="l03310"></a>03310 <span class="comment">                                 * such request. So means there may be some</span>
<a name="l03311"></a>03311 <span class="comment">                                 * remote name entry on other MDT that</span>
<a name="l03312"></a>03312 <span class="comment">                                 * references this object with another name,</span>
<a name="l03313"></a>03313 <span class="comment">                                 * so we cannot know whether this linkEA is</span>
<a name="l03314"></a>03314 <span class="comment">                                 * valid or not. So keep it there and maybe</span>
<a name="l03315"></a>03315 <span class="comment">                                 * resolved when next LFSCK run. */</span>
<a name="l03316"></a>03316                                 <span class="keywordflow">if</span> (ns-&gt;ln_flags &amp; LF_INCOMPLETE) {
<a name="l03317"></a>03317                                         lfsck_object_put(env, parent);
<a name="l03318"></a>03318 
<a name="l03319"></a>03319                                         GOTO(out, rc = 0);
<a name="l03320"></a>03320                                 }
<a name="l03321"></a>03321 
<a name="l03322"></a>03322                                 <span class="comment">/* Create the lost parent as an orphan. */</span>
<a name="l03323"></a>03323                                 rc = lfsck_namespace_create_orphan_dir(env, com,
<a name="l03324"></a>03324                                                                 parent, NULL);
<a name="l03325"></a>03325                                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l03326"></a>03326                                         lfsck_object_put(env, parent);
<a name="l03327"></a>03327 
<a name="l03328"></a>03328                                         GOTO(out, rc);
<a name="l03329"></a>03329                                 }
<a name="l03330"></a>03330 
<a name="l03331"></a>03331                                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l03332"></a>03332                                         repaired = <span class="keyword">true</span>;
<a name="l03333"></a>03333 
<a name="l03334"></a>03334                                 <span class="comment">/* Add the missing name entry to the parent. */</span>
<a name="l03335"></a>03335                                 rc = lfsck_namespace_insert_normal(env, com,
<a name="l03336"></a>03336                                                 parent, child, cname-&gt;ln_name);
<a name="l03337"></a>03337                                 <span class="keywordflow">if</span> (unlikely(rc == -EEXIST))
<a name="l03338"></a>03338                                         <span class="comment">/* Unfortunately, someone reused the</span>
<a name="l03339"></a>03339 <span class="comment">                                         * name under the parent by race. So we</span>
<a name="l03340"></a>03340 <span class="comment">                                         * have to remove the linkEA entry from</span>
<a name="l03341"></a>03341 <span class="comment">                                         * current child object. It means that</span>
<a name="l03342"></a>03342 <span class="comment">                                         * the LFSCK cannot recover the system</span>
<a name="l03343"></a>03343 <span class="comment">                                         * totally back to its original status,</span>
<a name="l03344"></a>03344 <span class="comment">                                         * but it is necessary to make the</span>
<a name="l03345"></a>03345 <span class="comment">                                         * current system to be consistent. */</span>
<a name="l03346"></a>03346                                         rc = lfsck_namespace_shrink_linkea(env,
<a name="l03347"></a>03347                                                         com, child, &amp;ldata,
<a name="l03348"></a>03348                                                         cname, pfid, <span class="keyword">true</span>);
<a name="l03349"></a>03349                                 <span class="keywordflow">else</span>
<a name="l03350"></a>03350                                         linkea_next_entry(&amp;ldata);
<a name="l03351"></a>03351                         }
<a name="l03352"></a>03352 
<a name="l03353"></a>03353                         lfsck_object_put(env, parent);
<a name="l03354"></a>03354                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03355"></a>03355                                 GOTO(out, rc);
<a name="l03356"></a>03356 
<a name="l03357"></a>03357                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l03358"></a>03358                                 repaired = <span class="keyword">true</span>;
<a name="l03359"></a>03359 
<a name="l03360"></a>03360                         <span class="keywordflow">continue</span>;
<a name="l03361"></a>03361                 }
<a name="l03362"></a>03362 
<a name="l03363"></a>03363                 <span class="comment">/* The linkEA entry with bad parent will be removed. */</span>
<a name="l03364"></a>03364                 <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, parent))) {
<a name="l03365"></a>03365                         lfsck_object_put(env, parent);
<a name="l03366"></a>03366                         rc = lfsck_namespace_shrink_linkea(env, com, child,
<a name="l03367"></a>03367                                                 &amp;ldata, cname, pfid, <span class="keyword">true</span>);
<a name="l03368"></a>03368                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03369"></a>03369                                 GOTO(out, rc);
<a name="l03370"></a>03370 
<a name="l03371"></a>03371                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l03372"></a>03372                                 repaired = <span class="keyword">true</span>;
<a name="l03373"></a>03373 
<a name="l03374"></a>03374                         <span class="keywordflow">continue</span>;
<a name="l03375"></a>03375                 }
<a name="l03376"></a>03376 
<a name="l03377"></a>03377                 rc = dt_lookup(env, parent, (<span class="keyword">struct</span> dt_rec *)cfid,
<a name="l03378"></a>03378                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)cname-&gt;ln_name);
<a name="l03379"></a>03379                 <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -ENOENT) {
<a name="l03380"></a>03380                         lfsck_object_put(env, parent);
<a name="l03381"></a>03381 
<a name="l03382"></a>03382                         GOTO(out, rc);
<a name="l03383"></a>03383                 }
<a name="l03384"></a>03384 
<a name="l03385"></a>03385                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l03386"></a>03386                         <span class="keywordflow">if</span> (lu_fid_eq(cfid, lfsck_dto2fid(child))) {
<a name="l03387"></a>03387                                 <span class="comment">/* It is the most common case that we</span>
<a name="l03388"></a>03388 <span class="comment">                                 * find the name entry corresponding</span>
<a name="l03389"></a>03389 <span class="comment">                                 * to the linkEA entry. */</span>
<a name="l03390"></a>03390                                 lfsck_object_put(env, parent);
<a name="l03391"></a>03391                                 linkea_next_entry(&amp;ldata);
<a name="l03392"></a>03392                         } <span class="keywordflow">else</span> {
<a name="l03393"></a>03393                                 <span class="comment">/* The name entry references another</span>
<a name="l03394"></a>03394 <span class="comment">                                 * MDT-object that may be created by</span>
<a name="l03395"></a>03395 <span class="comment">                                 * the LFSCK for repairing dangling</span>
<a name="l03396"></a>03396 <span class="comment">                                 * name entry. Try to replace it. */</span>
<a name="l03397"></a>03397                                 rc = lfsck_namespace_replace_cond(env, com,
<a name="l03398"></a>03398                                                 parent, child, cfid, cname);
<a name="l03399"></a>03399                                 lfsck_object_put(env, parent);
<a name="l03400"></a>03400                                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03401"></a>03401                                         GOTO(out, rc);
<a name="l03402"></a>03402 
<a name="l03403"></a>03403                                 <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l03404"></a>03404                                         repaired = <span class="keyword">true</span>;
<a name="l03405"></a>03405                                         linkea_next_entry(&amp;ldata);
<a name="l03406"></a>03406                                 } <span class="keywordflow">else</span> {
<a name="l03407"></a>03407                                         rc = lfsck_namespace_shrink_linkea(env,
<a name="l03408"></a>03408                                                         com, child, &amp;ldata,
<a name="l03409"></a>03409                                                         cname, pfid, <span class="keyword">true</span>);
<a name="l03410"></a>03410                                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03411"></a>03411                                                 GOTO(out, rc);
<a name="l03412"></a>03412 
<a name="l03413"></a>03413                                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l03414"></a>03414                                                 repaired = <span class="keyword">true</span>;
<a name="l03415"></a>03415                                 }
<a name="l03416"></a>03416                         }
<a name="l03417"></a>03417 
<a name="l03418"></a>03418                         <span class="keywordflow">continue</span>;
<a name="l03419"></a>03419                 }
<a name="l03420"></a>03420 
<a name="l03421"></a>03421                 rc = dt_attr_get(env, child, la);
<a name="l03422"></a>03422                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03423"></a>03423                         GOTO(out, rc);
<a name="l03424"></a>03424 
<a name="l03425"></a>03425                 <span class="comment">/* If there is no name entry in the parent dir and the object</span>
<a name="l03426"></a>03426 <span class="comment">                 * link count is less than the linkea entries count, then the</span>
<a name="l03427"></a>03427 <span class="comment">                 * linkea entry should be removed. */</span>
<a name="l03428"></a>03428                 <span class="keywordflow">if</span> (ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount &gt; la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a>) {
<a name="l03429"></a>03429                         rc = lfsck_namespace_shrink_linkea_cond(env, com,
<a name="l03430"></a>03430                                         parent, child, &amp;ldata, cname, pfid);
<a name="l03431"></a>03431                         lfsck_object_put(env, parent);
<a name="l03432"></a>03432                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03433"></a>03433                                 GOTO(out, rc);
<a name="l03434"></a>03434 
<a name="l03435"></a>03435                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l03436"></a>03436                                 repaired = <span class="keyword">true</span>;
<a name="l03437"></a>03437 
<a name="l03438"></a>03438                         <span class="keywordflow">continue</span>;
<a name="l03439"></a>03439                 }
<a name="l03440"></a>03440 
<a name="l03441"></a>03441                 <span class="comment">/* If the LFSCK is marked as LF_INCOMPLETE, then means some</span>
<a name="l03442"></a>03442 <span class="comment">                 * MDT has ever tried to verify some remote MDT-object that</span>
<a name="l03443"></a>03443 <span class="comment">                 * resides on this MDT, but this MDT failed to respond such</span>
<a name="l03444"></a>03444 <span class="comment">                 * request. So means there may be some remote name entry on</span>
<a name="l03445"></a>03445 <span class="comment">                 * other MDT that references this object with another name,</span>
<a name="l03446"></a>03446 <span class="comment">                 * so we cannot know whether this linkEA is valid or not.</span>
<a name="l03447"></a>03447 <span class="comment">                 * So keep it there and maybe resolved when next LFSCK run. */</span>
<a name="l03448"></a>03448                 <span class="keywordflow">if</span> (ns-&gt;ln_flags &amp; LF_INCOMPLETE) {
<a name="l03449"></a>03449                         lfsck_object_put(env, parent);
<a name="l03450"></a>03450 
<a name="l03451"></a>03451                         GOTO(out, rc = 0);
<a name="l03452"></a>03452                 }
<a name="l03453"></a>03453 
<a name="l03454"></a>03454                 rc = lfsck_namespace_check_name(env, parent, child, cname);
<a name="l03455"></a>03455                 <span class="keywordflow">if</span> (rc == -ENOENT)
<a name="l03456"></a>03456                         <span class="keywordflow">goto</span> lost_parent;
<a name="l03457"></a>03457 
<a name="l03458"></a>03458                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l03459"></a>03459                         lfsck_object_put(env, parent);
<a name="l03460"></a>03460 
<a name="l03461"></a>03461                         GOTO(out, rc);
<a name="l03462"></a>03462                 }
<a name="l03463"></a>03463 
<a name="l03464"></a>03464                 <span class="comment">/* It is an invalid name entry, drop it. */</span>
<a name="l03465"></a>03465                 <span class="keywordflow">if</span> (unlikely(rc &gt; 0)) {
<a name="l03466"></a>03466                         lfsck_object_put(env, parent);
<a name="l03467"></a>03467                         rc = lfsck_namespace_shrink_linkea(env, com, child,
<a name="l03468"></a>03468                                                 &amp;ldata, cname, pfid, <span class="keyword">true</span>);
<a name="l03469"></a>03469                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03470"></a>03470                                 GOTO(out, rc);
<a name="l03471"></a>03471 
<a name="l03472"></a>03472                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l03473"></a>03473                                 repaired = <span class="keyword">true</span>;
<a name="l03474"></a>03474 
<a name="l03475"></a>03475                         <span class="keywordflow">continue</span>;
<a name="l03476"></a>03476                 }
<a name="l03477"></a>03477 
<a name="l03478"></a>03478                 <span class="comment">/* Add the missing name entry back to the namespace. */</span>
<a name="l03479"></a>03479                 rc = lfsck_namespace_insert_normal(env, com, parent, child,
<a name="l03480"></a>03480                                                    cname-&gt;ln_name);
<a name="l03481"></a>03481                 <span class="keywordflow">if</span> (unlikely(rc == -ESTALE))
<a name="l03482"></a>03482                         <span class="comment">/* It may happen when the remote object has been</span>
<a name="l03483"></a>03483 <span class="comment">                         * removed, but the local MDT is not aware of that. */</span>
<a name="l03484"></a>03484                         <span class="keywordflow">goto</span> lost_parent;
<a name="l03485"></a>03485 
<a name="l03486"></a>03486                 <span class="keywordflow">if</span> (unlikely(rc == -EEXIST))
<a name="l03487"></a>03487                         <span class="comment">/* Unfortunately, someone reused the name under the</span>
<a name="l03488"></a>03488 <span class="comment">                         * parent by race. So we have to remove the linkEA</span>
<a name="l03489"></a>03489 <span class="comment">                         * entry from current child object. It means that the</span>
<a name="l03490"></a>03490 <span class="comment">                         * LFSCK cannot recover the system totally back to</span>
<a name="l03491"></a>03491 <span class="comment">                         * its original status, but it is necessary to make</span>
<a name="l03492"></a>03492 <span class="comment">                         * the current system to be consistent.</span>
<a name="l03493"></a>03493 <span class="comment">                         *</span>
<a name="l03494"></a>03494 <span class="comment">                         * It also may be because of the LFSCK found some</span>
<a name="l03495"></a>03495 <span class="comment">                         * internal status of create operation. Under such</span>
<a name="l03496"></a>03496 <span class="comment">                         * case, nothing to be done. */</span>
<a name="l03497"></a>03497                         rc = lfsck_namespace_shrink_linkea_cond(env, com,
<a name="l03498"></a>03498                                         parent, child, &amp;ldata, cname, pfid);
<a name="l03499"></a>03499                 <span class="keywordflow">else</span>
<a name="l03500"></a>03500                         linkea_next_entry(&amp;ldata);
<a name="l03501"></a>03501 
<a name="l03502"></a>03502                 lfsck_object_put(env, parent);
<a name="l03503"></a>03503                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03504"></a>03504                         GOTO(out, rc);
<a name="l03505"></a>03505 
<a name="l03506"></a>03506                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l03507"></a>03507                         repaired = <span class="keyword">true</span>;
<a name="l03508"></a>03508         }
<a name="l03509"></a>03509 
<a name="l03510"></a>03510         GOTO(out, rc = 0);
<a name="l03511"></a>03511 
<a name="l03512"></a>03512 out:
<a name="l03513"></a>03513         <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; rc != -ENODATA)
<a name="l03514"></a>03514                 <span class="keywordflow">return</span> rc;
<a name="l03515"></a>03515 
<a name="l03516"></a>03516         <span class="keywordflow">if</span> (rc == 0) {
<a name="l03517"></a>03517                 LASSERT(ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a> != NULL);
<a name="l03518"></a>03518 
<a name="l03519"></a>03519                 count = ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount;
<a name="l03520"></a>03520         }
<a name="l03521"></a>03521 
<a name="l03522"></a>03522         <span class="keywordflow">if</span> (count == 0) {
<a name="l03523"></a>03523                 <span class="comment">/* If the LFSCK is marked as LF_INCOMPLETE, then means some</span>
<a name="l03524"></a>03524 <span class="comment">                 * MDT has ever tried to verify some remote MDT-object that</span>
<a name="l03525"></a>03525 <span class="comment">                 * resides on this MDT, but this MDT failed to respond such</span>
<a name="l03526"></a>03526 <span class="comment">                 * request. So means there may be some remote name entry on</span>
<a name="l03527"></a>03527 <span class="comment">                 * other MDT that references this object with another name,</span>
<a name="l03528"></a>03528 <span class="comment">                 * so we cannot know whether this linkEA is valid or not.</span>
<a name="l03529"></a>03529 <span class="comment">                 * So keep it there and maybe resolved when next LFSCK run. */</span>
<a name="l03530"></a>03530                 <span class="keywordflow">if</span> (!(ns-&gt;ln_flags &amp; LF_INCOMPLETE)) {
<a name="l03531"></a>03531                         <span class="comment">/* If the child becomes orphan, then insert it into</span>
<a name="l03532"></a>03532 <span class="comment">                         * the global .lustre/lost+found/MDTxxxx directory. */</span>
<a name="l03533"></a>03533                         rc = lfsck_namespace_insert_orphan(env, com, child,
<a name="l03534"></a>03534                                                            <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;O&quot;</span>, &amp;count);
<a name="l03535"></a>03535                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03536"></a>03536                                 <span class="keywordflow">return</span> rc;
<a name="l03537"></a>03537 
<a name="l03538"></a>03538                         <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l03539"></a>03539                                 ns-&gt;ln_mul_ref_repaired++;
<a name="l03540"></a>03540                                 repaired = <span class="keyword">true</span>;
<a name="l03541"></a>03541                         }
<a name="l03542"></a>03542                 }
<a name="l03543"></a>03543         } <span class="keywordflow">else</span> {
<a name="l03544"></a>03544                 rc = dt_attr_get(env, child, la);
<a name="l03545"></a>03545                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03546"></a>03546                         <span class="keywordflow">return</span> rc;
<a name="l03547"></a>03547 
<a name="l03548"></a>03548                 <span class="keywordflow">if</span> (la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> != 0 &amp;&amp; la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> != count) {
<a name="l03549"></a>03549                         rc = lfsck_namespace_repair_nlink(env, com, child, la);
<a name="l03550"></a>03550                         <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l03551"></a>03551                                 ns-&gt;ln_objs_nlink_repaired++;
<a name="l03552"></a>03552                                 rc = 0;
<a name="l03553"></a>03553                         }
<a name="l03554"></a>03554                 }
<a name="l03555"></a>03555         }
<a name="l03556"></a>03556 
<a name="l03557"></a>03557         <span class="keywordflow">if</span> (repaired) {
<a name="l03558"></a>03558                 <span class="keywordflow">if</span> (la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> &gt; 1)
<a name="l03559"></a>03559                         ns-&gt;ln_mul_linked_repaired++;
<a name="l03560"></a>03560 
<a name="l03561"></a>03561                 <span class="keywordflow">if</span> (rc == 0)
<a name="l03562"></a>03562                         rc = 1;
<a name="l03563"></a>03563         }
<a name="l03564"></a>03564 
<a name="l03565"></a>03565         <span class="keywordflow">return</span> rc;
<a name="l03566"></a>03566 }
<a name="l03567"></a>03567 
<a name="l03568"></a>03568 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_dump_statistics(<span class="keyword">struct</span> seq_file *m,
<a name="l03569"></a>03569                                             <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns,
<a name="l03570"></a>03570                                             __u64 checked_phase1,
<a name="l03571"></a>03571                                             __u64 checked_phase2,
<a name="l03572"></a>03572                                             __u32 time_phase1,
<a name="l03573"></a>03573                                             __u32 time_phase2)
<a name="l03574"></a>03574 {
<a name="l03575"></a>03575         seq_printf(m, <span class="stringliteral">&quot;checked_phase1: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03576"></a>03576                    <span class="stringliteral">&quot;checked_phase2: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03577"></a>03577                    <span class="stringliteral">&quot;updated_phase1: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03578"></a>03578                    <span class="stringliteral">&quot;updated_phase2: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03579"></a>03579                    <span class="stringliteral">&quot;failed_phase1: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03580"></a>03580                    <span class="stringliteral">&quot;failed_phase2: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03581"></a>03581                    <span class="stringliteral">&quot;directories: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03582"></a>03582                    <span class="stringliteral">&quot;dirent_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03583"></a>03583                    <span class="stringliteral">&quot;linkea_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03584"></a>03584                    <span class="stringliteral">&quot;nlinks_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03585"></a>03585                    <span class="stringliteral">&quot;multiple_linked_checked: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03586"></a>03586                    <span class="stringliteral">&quot;multiple_linked_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03587"></a>03587                    <span class="stringliteral">&quot;unknown_inconsistency: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03588"></a>03588                    <span class="stringliteral">&quot;unmatched_pairs_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03589"></a>03589                    <span class="stringliteral">&quot;dangling_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03590"></a>03590                    <span class="stringliteral">&quot;multiple_referenced_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03591"></a>03591                    <span class="stringliteral">&quot;bad_file_type_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03592"></a>03592                    <span class="stringliteral">&quot;lost_dirent_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03593"></a>03593                    <span class="stringliteral">&quot;local_lost_found_scanned: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03594"></a>03594                    <span class="stringliteral">&quot;local_lost_found_moved: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03595"></a>03595                    <span class="stringliteral">&quot;local_lost_found_skipped: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03596"></a>03596                    <span class="stringliteral">&quot;local_lost_found_failed: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03597"></a>03597                    <span class="stringliteral">&quot;striped_dirs_scanned: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03598"></a>03598                    <span class="stringliteral">&quot;striped_dirs_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03599"></a>03599                    <span class="stringliteral">&quot;striped_dirs_failed: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03600"></a>03600                    <span class="stringliteral">&quot;striped_dirs_disabled: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03601"></a>03601                    <span class="stringliteral">&quot;striped_dirs_skipped: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03602"></a>03602                    <span class="stringliteral">&quot;striped_shards_scanned: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03603"></a>03603                    <span class="stringliteral">&quot;striped_shards_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03604"></a>03604                    <span class="stringliteral">&quot;striped_shards_failed: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03605"></a>03605                    <span class="stringliteral">&quot;striped_shards_skipped: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03606"></a>03606                    <span class="stringliteral">&quot;name_hash_repaired: &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l03607"></a>03607                    <span class="stringliteral">&quot;success_count: %u\n&quot;</span>
<a name="l03608"></a>03608                    <span class="stringliteral">&quot;run_time_phase1: %u seconds\n&quot;</span>
<a name="l03609"></a>03609                    <span class="stringliteral">&quot;run_time_phase2: %u seconds\n&quot;</span>,
<a name="l03610"></a>03610                    checked_phase1,
<a name="l03611"></a>03611                    checked_phase2,
<a name="l03612"></a>03612                    ns-&gt;ln_items_repaired,
<a name="l03613"></a>03613                    ns-&gt;ln_objs_repaired_phase2,
<a name="l03614"></a>03614                    ns-&gt;ln_items_failed,
<a name="l03615"></a>03615                    ns-&gt;ln_objs_failed_phase2,
<a name="l03616"></a>03616                    ns-&gt;ln_dirs_checked,
<a name="l03617"></a>03617                    ns-&gt;ln_dirent_repaired,
<a name="l03618"></a>03618                    ns-&gt;ln_linkea_repaired,
<a name="l03619"></a>03619                    ns-&gt;ln_objs_nlink_repaired,
<a name="l03620"></a>03620                    ns-&gt;ln_mul_linked_checked,
<a name="l03621"></a>03621                    ns-&gt;ln_mul_linked_repaired,
<a name="l03622"></a>03622                    ns-&gt;ln_unknown_inconsistency,
<a name="l03623"></a>03623                    ns-&gt;ln_unmatched_pairs_repaired,
<a name="l03624"></a>03624                    ns-&gt;ln_dangling_repaired,
<a name="l03625"></a>03625                    ns-&gt;ln_mul_ref_repaired,
<a name="l03626"></a>03626                    ns-&gt;ln_bad_type_repaired,
<a name="l03627"></a>03627                    ns-&gt;ln_lost_dirent_repaired,
<a name="l03628"></a>03628                    ns-&gt;ln_local_lpf_scanned,
<a name="l03629"></a>03629                    ns-&gt;ln_local_lpf_moved,
<a name="l03630"></a>03630                    ns-&gt;ln_local_lpf_skipped,
<a name="l03631"></a>03631                    ns-&gt;ln_local_lpf_failed,
<a name="l03632"></a>03632                    ns-&gt;ln_striped_dirs_scanned,
<a name="l03633"></a>03633                    ns-&gt;ln_striped_dirs_repaired,
<a name="l03634"></a>03634                    ns-&gt;ln_striped_dirs_failed,
<a name="l03635"></a>03635                    ns-&gt;ln_striped_dirs_disabled,
<a name="l03636"></a>03636                    ns-&gt;ln_striped_dirs_skipped,
<a name="l03637"></a>03637                    ns-&gt;ln_striped_shards_scanned,
<a name="l03638"></a>03638                    ns-&gt;ln_striped_shards_repaired,
<a name="l03639"></a>03639                    ns-&gt;ln_striped_shards_failed,
<a name="l03640"></a>03640                    ns-&gt;ln_striped_shards_skipped,
<a name="l03641"></a>03641                    ns-&gt;ln_name_hash_repaired,
<a name="l03642"></a>03642                    ns-&gt;ln_success_count,
<a name="l03643"></a>03643                    time_phase1,
<a name="l03644"></a>03644                    time_phase2);
<a name="l03645"></a>03645 }
<a name="l03646"></a>03646 
<a name="l03647"></a>03647 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_release_lmv(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03648"></a>03648                                         <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l03649"></a>03649 {
<a name="l03650"></a>03650         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l03651"></a>03651         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns     = com-&gt;lc_file_ram;
<a name="l03652"></a>03652 
<a name="l03653"></a>03653         <span class="keywordflow">while</span> (!list_empty(&amp;lfsck-&gt;li_list_lmv)) {
<a name="l03654"></a>03654                 <span class="keyword">struct </span><a class="code" href="structlfsck__lmv__unit.html">lfsck_lmv_unit</a>   *llu;
<a name="l03655"></a>03655                 <span class="keyword">struct </span><a class="code" href="structlfsck__lmv.html">lfsck_lmv</a>        *llmv;
<a name="l03656"></a>03656 
<a name="l03657"></a>03657                 llu = list_entry(lfsck-&gt;li_list_lmv.next,
<a name="l03658"></a>03658                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__lmv__unit.html">lfsck_lmv_unit</a>, llu_link);
<a name="l03659"></a>03659                 llmv = &amp;llu-&gt;llu_lmv;
<a name="l03660"></a>03660 
<a name="l03661"></a>03661                 LASSERTF(atomic_read(&amp;llmv-&gt;ll_ref) == 1,
<a name="l03662"></a>03662                          <span class="stringliteral">&quot;still in using: %u\n&quot;</span>,
<a name="l03663"></a>03663                          atomic_read(&amp;llmv-&gt;ll_ref));
<a name="l03664"></a>03664 
<a name="l03665"></a>03665                 ns-&gt;ln_striped_dirs_skipped++;
<a name="l03666"></a>03666                 lfsck_lmv_put(env, llmv);
<a name="l03667"></a>03667         }
<a name="l03668"></a>03668 }
<a name="l03669"></a>03669 
<a name="l03670"></a>03670 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_check_for_double_scan(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03671"></a>03671                                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l03672"></a>03672                                                  <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj)
<a name="l03673"></a>03673 {
<a name="l03674"></a>03674         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *la = &amp;lfsck_env_info(env)-&gt;lti_la;
<a name="l03675"></a>03675         <span class="keywordtype">int</span>             rc;
<a name="l03676"></a>03676 
<a name="l03677"></a>03677         rc = dt_attr_get(env, obj, la);
<a name="l03678"></a>03678         <span class="keywordflow">if</span> (rc != 0)
<a name="l03679"></a>03679                 <span class="keywordflow">return</span> rc;
<a name="l03680"></a>03680 
<a name="l03681"></a>03681         <span class="comment">/* zero-linkEA object may be orphan, but it also maybe because</span>
<a name="l03682"></a>03682 <span class="comment">         * of upgrading. Currently, we cannot record it for double scan.</span>
<a name="l03683"></a>03683 <span class="comment">         * Because it may cause the LFSCK trace file to be too large. */</span>
<a name="l03684"></a>03684 
<a name="l03685"></a>03685         <span class="comment">/* &quot;la_ctime&quot; == 1 means that it has ever been removed from</span>
<a name="l03686"></a>03686 <span class="comment">         * backend /lost+found directory but not been added back to</span>
<a name="l03687"></a>03687 <span class="comment">         * the normal namespace yet. */</span>
<a name="l03688"></a>03688 
<a name="l03689"></a>03689         <span class="keywordflow">if</span> ((S_ISREG(lfsck_object_type(obj)) &amp;&amp; la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> &gt; 1) ||
<a name="l03690"></a>03690             unlikely(la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> == 1))
<a name="l03691"></a>03691                 rc = lfsck_namespace_trace_update(env, com, lfsck_dto2fid(obj),
<a name="l03692"></a>03692                                                   LNTF_CHECK_LINKEA, <span class="keyword">true</span>);
<a name="l03693"></a>03693 
<a name="l03694"></a>03694         <span class="keywordflow">return</span> rc;
<a name="l03695"></a>03695 }
<a name="l03696"></a>03696 
<a name="l03697"></a>03697 <span class="comment">/* namespace APIs */</span>
<a name="l03698"></a>03698 
<a name="l03699"></a>03699 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_reset(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03700"></a>03700                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com, <span class="keywordtype">bool</span> init)
<a name="l03701"></a>03701 {
<a name="l03702"></a>03702         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l03703"></a>03703         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns     = com-&gt;lc_file_ram;
<a name="l03704"></a>03704         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad    = com-&gt;lc_data;
<a name="l03705"></a>03705         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *root;
<a name="l03706"></a>03706         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *dto;
<a name="l03707"></a>03707         <span class="keywordtype">int</span>                              rc;
<a name="l03708"></a>03708         ENTRY;
<a name="l03709"></a>03709 
<a name="l03710"></a>03710         root = dt_locate(env, lfsck-&gt;li_bottom, &amp;lfsck-&gt;li_local_root_fid);
<a name="l03711"></a>03711         <span class="keywordflow">if</span> (IS_ERR(root))
<a name="l03712"></a>03712                 GOTO(log, rc = PTR_ERR(root));
<a name="l03713"></a>03713 
<a name="l03714"></a>03714         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, root)))
<a name="l03715"></a>03715                 GOTO(put, rc = -ENOTDIR);
<a name="l03716"></a>03716 
<a name="l03717"></a>03717         down_write(&amp;com-&gt;lc_sem);
<a name="l03718"></a>03718         <span class="keywordflow">if</span> (init) {
<a name="l03719"></a>03719                 memset(ns, 0, <span class="keyword">sizeof</span>(*ns));
<a name="l03720"></a>03720         } <span class="keywordflow">else</span> {
<a name="l03721"></a>03721                 __u32 count = ns-&gt;ln_success_count;
<a name="l03722"></a>03722                 __u64 last_time = ns-&gt;ln_time_last_complete;
<a name="l03723"></a>03723 
<a name="l03724"></a>03724                 memset(ns, 0, <span class="keyword">sizeof</span>(*ns));
<a name="l03725"></a>03725                 ns-&gt;ln_success_count = count;
<a name="l03726"></a>03726                 ns-&gt;ln_time_last_complete = last_time;
<a name="l03727"></a>03727         }
<a name="l03728"></a>03728         ns-&gt;ln_magic = LFSCK_NAMESPACE_MAGIC;
<a name="l03729"></a>03729         ns-&gt;ln_status = LS_INIT;
<a name="l03730"></a>03730 
<a name="l03731"></a>03731         lfsck_object_put(env, com-&gt;lc_obj);
<a name="l03732"></a>03732         com-&gt;lc_obj = NULL;
<a name="l03733"></a>03733         dto = lfsck_namespace_load_one_trace_file(env, com, root,
<a name="l03734"></a>03734                                                   LFSCK_NAMESPACE, <span class="keyword">true</span>);
<a name="l03735"></a>03735         <span class="keywordflow">if</span> (IS_ERR(dto))
<a name="l03736"></a>03736                 GOTO(out, rc = PTR_ERR(dto));
<a name="l03737"></a>03737 
<a name="l03738"></a>03738         com-&gt;lc_obj = dto;
<a name="l03739"></a>03739         rc = lfsck_namespace_load_sub_trace_files(env, com, <span class="keyword">true</span>);
<a name="l03740"></a>03740         <span class="keywordflow">if</span> (rc != 0)
<a name="l03741"></a>03741                 GOTO(out, rc);
<a name="l03742"></a>03742 
<a name="l03743"></a>03743         lad-&gt;lad_incomplete = 0;
<a name="l03744"></a>03744         CFS_RESET_BITMAP(lad-&gt;lad_bitmap);
<a name="l03745"></a>03745 
<a name="l03746"></a>03746         rc = lfsck_namespace_store(env, com);
<a name="l03747"></a>03747 
<a name="l03748"></a>03748         GOTO(out, rc);
<a name="l03749"></a>03749 
<a name="l03750"></a>03750 out:
<a name="l03751"></a>03751         up_write(&amp;com-&gt;lc_sem);
<a name="l03752"></a>03752 
<a name="l03753"></a>03753 put:
<a name="l03754"></a>03754         lfsck_object_put(env, root);
<a name="l03755"></a>03755 log:
<a name="l03756"></a>03756         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK reset: rc = %d\n&quot;</span>,
<a name="l03757"></a>03757                lfsck_lfsck2name(lfsck), rc);
<a name="l03758"></a>03758         <span class="keywordflow">return</span> rc;
<a name="l03759"></a>03759 }
<a name="l03760"></a>03760 
<a name="l03761"></a>03761 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03762"></a>03762 lfsck_namespace_fail(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l03763"></a>03763                      <span class="keywordtype">bool</span> new_checked)
<a name="l03764"></a>03764 {
<a name="l03765"></a>03765         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l03766"></a>03766 
<a name="l03767"></a>03767         down_write(&amp;com-&gt;lc_sem);
<a name="l03768"></a>03768         <span class="keywordflow">if</span> (new_checked)
<a name="l03769"></a>03769                 com-&gt;lc_new_checked++;
<a name="l03770"></a>03770         lfsck_namespace_record_failure(env, com-&gt;lc_lfsck, ns);
<a name="l03771"></a>03771         up_write(&amp;com-&gt;lc_sem);
<a name="l03772"></a>03772 }
<a name="l03773"></a>03773 
<a name="l03774"></a>03774 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_close_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03775"></a>03775                                       <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l03776"></a>03776 {
<a name="l03777"></a>03777         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns     = com-&gt;lc_file_ram;
<a name="l03778"></a>03778         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad    = com-&gt;lc_data;
<a name="l03779"></a>03779         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__object.html">lfsck_assistant_object</a>   *lso    = NULL;
<a name="l03780"></a>03780         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l03781"></a>03781         <span class="keyword">struct </span><a class="code" href="structlfsck__lmv.html">lfsck_lmv</a>                *llmv   = lfsck-&gt;li_lmv;
<a name="l03782"></a>03782         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a>      *lnr;
<a name="l03783"></a>03783         __u32                            size   =
<a name="l03784"></a>03784                                 <span class="keyword">sizeof</span>(*lnr) + LFSCK_TMPBUF_LEN;
<a name="l03785"></a>03785         <span class="keywordtype">bool</span>                             wakeup = <span class="keyword">false</span>;
<a name="l03786"></a>03786         ENTRY;
<a name="l03787"></a>03787 
<a name="l03788"></a>03788         <span class="keywordflow">if</span> (llmv == NULL)
<a name="l03789"></a>03789                 RETURN_EXIT;
<a name="l03790"></a>03790 
<a name="l03791"></a>03791         OBD_ALLOC(lnr, size);
<a name="l03792"></a>03792         <span class="keywordflow">if</span> (lnr == NULL) {
<a name="l03793"></a>03793                 ns-&gt;ln_striped_dirs_skipped++;
<a name="l03794"></a>03794 
<a name="l03795"></a>03795                 RETURN_EXIT;
<a name="l03796"></a>03796         }
<a name="l03797"></a>03797 
<a name="l03798"></a>03798         lso = lfsck_assistant_object_init(env, lfsck_dto2fid(lfsck-&gt;li_obj_dir),
<a name="l03799"></a>03799                         NULL, lfsck-&gt;li_pos_current.lp_oit_cookie, <span class="keyword">true</span>);
<a name="l03800"></a>03800         <span class="keywordflow">if</span> (IS_ERR(lso)) {
<a name="l03801"></a>03801                 OBD_FREE(lnr, size);
<a name="l03802"></a>03802                 ns-&gt;ln_striped_dirs_skipped++;
<a name="l03803"></a>03803 
<a name="l03804"></a>03804                 RETURN_EXIT;
<a name="l03805"></a>03805         }
<a name="l03806"></a>03806 
<a name="l03807"></a>03807         <span class="comment">/* Generate a dummy request to indicate that all shards&apos; name entry</span>
<a name="l03808"></a>03808 <span class="comment">         * in this striped directory has been scanned for the first time. */</span>
<a name="l03809"></a>03809         INIT_LIST_HEAD(&amp;lnr-&gt;lnr_lar.lar_list);
<a name="l03810"></a>03810         lnr-&gt;lnr_lar.lar_parent = lso;
<a name="l03811"></a>03811         lnr-&gt;lnr_lmv = lfsck_lmv_get(llmv);
<a name="l03812"></a>03812         lnr-&gt;lnr_fid = *lfsck_dto2fid(lfsck-&gt;li_obj_dir);
<a name="l03813"></a>03813         lnr-&gt;lnr_dir_cookie = MDS_DIR_END_OFF;
<a name="l03814"></a>03814         lnr-&gt;lnr_size = size;
<a name="l03815"></a>03815 
<a name="l03816"></a>03816         spin_lock(&amp;lad-&gt;lad_lock);
<a name="l03817"></a>03817         <span class="keywordflow">if</span> (lad-&gt;lad_assistant_status &lt; 0) {
<a name="l03818"></a>03818                 spin_unlock(&amp;lad-&gt;lad_lock);
<a name="l03819"></a>03819                 lfsck_namespace_assistant_req_fini(env, &amp;lnr-&gt;lnr_lar);
<a name="l03820"></a>03820                 ns-&gt;ln_striped_dirs_skipped++;
<a name="l03821"></a>03821 
<a name="l03822"></a>03822                 RETURN_EXIT;
<a name="l03823"></a>03823         }
<a name="l03824"></a>03824 
<a name="l03825"></a>03825         list_add_tail(&amp;lnr-&gt;lnr_lar.lar_list, &amp;lad-&gt;lad_req_list);
<a name="l03826"></a>03826         <span class="keywordflow">if</span> (lad-&gt;lad_prefetched == 0)
<a name="l03827"></a>03827                 wakeup = <span class="keyword">true</span>;
<a name="l03828"></a>03828 
<a name="l03829"></a>03829         lad-&gt;lad_prefetched++;
<a name="l03830"></a>03830         spin_unlock(&amp;lad-&gt;lad_lock);
<a name="l03831"></a>03831         <span class="keywordflow">if</span> (wakeup)
<a name="l03832"></a>03832                 wake_up_all(&amp;lad-&gt;lad_thread.t_ctl_waitq);
<a name="l03833"></a>03833 
<a name="l03834"></a>03834         EXIT;
<a name="l03835"></a>03835 }
<a name="l03836"></a>03836 
<a name="l03837"></a>03837 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_open_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03838"></a>03838                                     <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l03839"></a>03839 {
<a name="l03840"></a>03840         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck  = com-&gt;lc_lfsck;
<a name="l03841"></a>03841         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>  *ns     = com-&gt;lc_file_ram;
<a name="l03842"></a>03842         <span class="keyword">struct </span><a class="code" href="structlfsck__lmv.html">lfsck_lmv</a>        *llmv   = lfsck-&gt;li_lmv;
<a name="l03843"></a>03843         <span class="keywordtype">int</span>                      rc     = 0;
<a name="l03844"></a>03844         ENTRY;
<a name="l03845"></a>03845 
<a name="l03846"></a>03846         <span class="keywordflow">if</span> (llmv == NULL)
<a name="l03847"></a>03847                 RETURN(0);
<a name="l03848"></a>03848 
<a name="l03849"></a>03849         <span class="keywordflow">if</span> (llmv-&gt;ll_lmv_master) {
<a name="l03850"></a>03850                 <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a> *lmv = &amp;llmv-&gt;ll_lmv;
<a name="l03851"></a>03851 
<a name="l03852"></a>03852                 <span class="keywordflow">if</span> (lmv-&gt;lmv_master_mdt_index != lfsck_dev_idx(lfsck)) {
<a name="l03853"></a>03853                         lmv-&gt;lmv_master_mdt_index =
<a name="l03854"></a>03854                                 lfsck_dev_idx(lfsck);
<a name="l03855"></a>03855                         ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l03856"></a>03856                         llmv-&gt;ll_lmv_updated = 1;
<a name="l03857"></a>03857                 }
<a name="l03858"></a>03858         } <span class="keywordflow">else</span> {
<a name="l03859"></a>03859                 rc = lfsck_namespace_verify_stripe_slave(env, com,
<a name="l03860"></a>03860                                         lfsck-&gt;li_obj_dir, llmv);
<a name="l03861"></a>03861         }
<a name="l03862"></a>03862 
<a name="l03863"></a>03863         RETURN(rc &gt; 0 ? 0 : rc);
<a name="l03864"></a>03864 }
<a name="l03865"></a>03865 
<a name="l03866"></a>03866 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_checkpoint(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03867"></a>03867                                       <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com, <span class="keywordtype">bool</span> init)
<a name="l03868"></a>03868 {
<a name="l03869"></a>03869         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck = com-&gt;lc_lfsck;
<a name="l03870"></a>03870         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>  *ns    = com-&gt;lc_file_ram;
<a name="l03871"></a>03871         <span class="keywordtype">int</span>                      rc;
<a name="l03872"></a>03872 
<a name="l03873"></a>03873         <span class="keywordflow">if</span> (!init) {
<a name="l03874"></a>03874                 rc = lfsck_checkpoint_generic(env, com);
<a name="l03875"></a>03875                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03876"></a>03876                         <span class="keywordflow">goto</span> log;
<a name="l03877"></a>03877         }
<a name="l03878"></a>03878 
<a name="l03879"></a>03879         down_write(&amp;com-&gt;lc_sem);
<a name="l03880"></a>03880         <span class="keywordflow">if</span> (init) {
<a name="l03881"></a>03881                 ns-&gt;ln_pos_latest_start = lfsck-&gt;li_pos_checkpoint;
<a name="l03882"></a>03882         } <span class="keywordflow">else</span> {
<a name="l03883"></a>03883                 ns-&gt;ln_pos_last_checkpoint = lfsck-&gt;li_pos_checkpoint;
<a name="l03884"></a>03884                 ns-&gt;ln_run_time_phase1 += cfs_duration_sec(cfs_time_current() +
<a name="l03885"></a>03885                                 HALF_SEC - lfsck-&gt;li_time_last_checkpoint);
<a name="l03886"></a>03886                 ns-&gt;ln_time_last_checkpoint = cfs_time_current_sec();
<a name="l03887"></a>03887                 ns-&gt;ln_items_checked += com-&gt;lc_new_checked;
<a name="l03888"></a>03888                 com-&gt;lc_new_checked = 0;
<a name="l03889"></a>03889         }
<a name="l03890"></a>03890 
<a name="l03891"></a>03891         rc = lfsck_namespace_store(env, com);
<a name="l03892"></a>03892         up_write(&amp;com-&gt;lc_sem);
<a name="l03893"></a>03893 
<a name="l03894"></a>03894 log:
<a name="l03895"></a>03895         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK checkpoint at the pos [&quot;</span>LPU64
<a name="l03896"></a>03896                <span class="stringliteral">&quot;, &quot;</span>DFID<span class="stringliteral">&quot;, &quot;</span>LPX64<span class="stringliteral">&quot;], status = %d: rc = %d\n&quot;</span>,
<a name="l03897"></a>03897                lfsck_lfsck2name(lfsck), lfsck-&gt;li_pos_current.lp_oit_cookie,
<a name="l03898"></a>03898                PFID(&amp;lfsck-&gt;li_pos_current.lp_dir_parent),
<a name="l03899"></a>03899                lfsck-&gt;li_pos_current.lp_dir_cookie, ns-&gt;ln_status, rc);
<a name="l03900"></a>03900 
<a name="l03901"></a>03901         <span class="keywordflow">return</span> rc &gt; 0 ? 0 : rc;
<a name="l03902"></a>03902 }
<a name="l03903"></a>03903 
<a name="l03904"></a>03904 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_prep(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03905"></a>03905                                 <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l03906"></a>03906                                 <span class="keyword">struct</span> <a class="code" href="structlfsck__start__param.html">lfsck_start_param</a> *lsp)
<a name="l03907"></a>03907 {
<a name="l03908"></a>03908         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck  = com-&gt;lc_lfsck;
<a name="l03909"></a>03909         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>  *ns     = com-&gt;lc_file_ram;
<a name="l03910"></a>03910         <span class="keyword">struct </span><a class="code" href="structlfsck__position.html">lfsck_position</a>   *pos    = &amp;com-&gt;lc_pos_start;
<a name="l03911"></a>03911         <span class="keywordtype">int</span>                      rc;
<a name="l03912"></a>03912 
<a name="l03913"></a>03913         rc = lfsck_namespace_load_bitmap(env, com);
<a name="l03914"></a>03914         <span class="keywordflow">if</span> (rc != 0 || ns-&gt;ln_status == LS_COMPLETED) {
<a name="l03915"></a>03915                 rc = lfsck_namespace_reset(env, com, <span class="keyword">false</span>);
<a name="l03916"></a>03916                 <span class="keywordflow">if</span> (rc == 0)
<a name="l03917"></a>03917                         rc = lfsck_set_param(env, lfsck, lsp-&gt;lsp_start, <span class="keyword">true</span>);
<a name="l03918"></a>03918 
<a name="l03919"></a>03919                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l03920"></a>03920                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK prep failed: &quot;</span>
<a name="l03921"></a>03921                                <span class="stringliteral">&quot;rc = %d\n&quot;</span>, lfsck_lfsck2name(lfsck), rc);
<a name="l03922"></a>03922 
<a name="l03923"></a>03923                         <span class="keywordflow">return</span> rc;
<a name="l03924"></a>03924                 }
<a name="l03925"></a>03925         }
<a name="l03926"></a>03926 
<a name="l03927"></a>03927         down_write(&amp;com-&gt;lc_sem);
<a name="l03928"></a>03928         ns-&gt;ln_time_latest_start = cfs_time_current_sec();
<a name="l03929"></a>03929         spin_lock(&amp;lfsck-&gt;li_lock);
<a name="l03930"></a>03930 
<a name="l03931"></a>03931         <span class="keywordflow">if</span> (ns-&gt;ln_flags &amp; LF_SCANNED_ONCE) {
<a name="l03932"></a>03932                 <span class="keywordflow">if</span> (!lfsck-&gt;li_drop_dryrun ||
<a name="l03933"></a>03933                     lfsck_pos_is_zero(&amp;ns-&gt;ln_pos_first_inconsistent)) {
<a name="l03934"></a>03934                         ns-&gt;ln_status = LS_SCANNING_PHASE2;
<a name="l03935"></a>03935                         list_move_tail(&amp;com-&gt;lc_link,
<a name="l03936"></a>03936                                        &amp;lfsck-&gt;li_list_double_scan);
<a name="l03937"></a>03937                         <span class="keywordflow">if</span> (!list_empty(&amp;com-&gt;lc_link_dir))
<a name="l03938"></a>03938                                 list_del_init(&amp;com-&gt;lc_link_dir);
<a name="l03939"></a>03939                         lfsck_pos_set_zero(pos);
<a name="l03940"></a>03940                 } <span class="keywordflow">else</span> {
<a name="l03941"></a>03941                         ns-&gt;ln_status = LS_SCANNING_PHASE1;
<a name="l03942"></a>03942                         ns-&gt;ln_run_time_phase1 = 0;
<a name="l03943"></a>03943                         ns-&gt;ln_run_time_phase2 = 0;
<a name="l03944"></a>03944                         ns-&gt;ln_items_checked = 0;
<a name="l03945"></a>03945                         ns-&gt;ln_items_repaired = 0;
<a name="l03946"></a>03946                         ns-&gt;ln_items_failed = 0;
<a name="l03947"></a>03947                         ns-&gt;ln_dirs_checked = 0;
<a name="l03948"></a>03948                         ns-&gt;ln_objs_checked_phase2 = 0;
<a name="l03949"></a>03949                         ns-&gt;ln_objs_repaired_phase2 = 0;
<a name="l03950"></a>03950                         ns-&gt;ln_objs_failed_phase2 = 0;
<a name="l03951"></a>03951                         ns-&gt;ln_objs_nlink_repaired = 0;
<a name="l03952"></a>03952                         ns-&gt;ln_dirent_repaired = 0;
<a name="l03953"></a>03953                         ns-&gt;ln_linkea_repaired = 0;
<a name="l03954"></a>03954                         ns-&gt;ln_mul_linked_checked = 0;
<a name="l03955"></a>03955                         ns-&gt;ln_mul_linked_repaired = 0;
<a name="l03956"></a>03956                         ns-&gt;ln_unknown_inconsistency = 0;
<a name="l03957"></a>03957                         ns-&gt;ln_unmatched_pairs_repaired = 0;
<a name="l03958"></a>03958                         ns-&gt;ln_dangling_repaired = 0;
<a name="l03959"></a>03959                         ns-&gt;ln_mul_ref_repaired = 0;
<a name="l03960"></a>03960                         ns-&gt;ln_bad_type_repaired = 0;
<a name="l03961"></a>03961                         ns-&gt;ln_lost_dirent_repaired = 0;
<a name="l03962"></a>03962                         ns-&gt;ln_striped_dirs_scanned = 0;
<a name="l03963"></a>03963                         ns-&gt;ln_striped_dirs_repaired = 0;
<a name="l03964"></a>03964                         ns-&gt;ln_striped_dirs_failed = 0;
<a name="l03965"></a>03965                         ns-&gt;ln_striped_dirs_disabled = 0;
<a name="l03966"></a>03966                         ns-&gt;ln_striped_dirs_skipped = 0;
<a name="l03967"></a>03967                         ns-&gt;ln_striped_shards_scanned = 0;
<a name="l03968"></a>03968                         ns-&gt;ln_striped_shards_repaired = 0;
<a name="l03969"></a>03969                         ns-&gt;ln_striped_shards_failed = 0;
<a name="l03970"></a>03970                         ns-&gt;ln_striped_shards_skipped = 0;
<a name="l03971"></a>03971                         ns-&gt;ln_name_hash_repaired = 0;
<a name="l03972"></a>03972                         fid_zero(&amp;ns-&gt;ln_fid_latest_scanned_phase2);
<a name="l03973"></a>03973                         <span class="keywordflow">if</span> (list_empty(&amp;com-&gt;lc_link_dir))
<a name="l03974"></a>03974                                 list_add_tail(&amp;com-&gt;lc_link_dir,
<a name="l03975"></a>03975                                               &amp;lfsck-&gt;li_list_dir);
<a name="l03976"></a>03976                         *pos = ns-&gt;ln_pos_first_inconsistent;
<a name="l03977"></a>03977                 }
<a name="l03978"></a>03978         } <span class="keywordflow">else</span> {
<a name="l03979"></a>03979                 ns-&gt;ln_status = LS_SCANNING_PHASE1;
<a name="l03980"></a>03980                 <span class="keywordflow">if</span> (list_empty(&amp;com-&gt;lc_link_dir))
<a name="l03981"></a>03981                         list_add_tail(&amp;com-&gt;lc_link_dir,
<a name="l03982"></a>03982                                       &amp;lfsck-&gt;li_list_dir);
<a name="l03983"></a>03983                 <span class="keywordflow">if</span> (!lfsck-&gt;li_drop_dryrun ||
<a name="l03984"></a>03984                     lfsck_pos_is_zero(&amp;ns-&gt;ln_pos_first_inconsistent)) {
<a name="l03985"></a>03985                         *pos = ns-&gt;ln_pos_last_checkpoint;
<a name="l03986"></a>03986                         pos-&gt;lp_oit_cookie++;
<a name="l03987"></a>03987                 } <span class="keywordflow">else</span> {
<a name="l03988"></a>03988                         *pos = ns-&gt;ln_pos_first_inconsistent;
<a name="l03989"></a>03989                 }
<a name="l03990"></a>03990         }
<a name="l03991"></a>03991 
<a name="l03992"></a>03992         spin_unlock(&amp;lfsck-&gt;li_lock);
<a name="l03993"></a>03993         up_write(&amp;com-&gt;lc_sem);
<a name="l03994"></a>03994 
<a name="l03995"></a>03995         rc = lfsck_start_assistant(env, com, lsp);
<a name="l03996"></a>03996 
<a name="l03997"></a>03997         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK prep done, start pos [&quot;</span>LPU64<span class="stringliteral">&quot;, &quot;</span>
<a name="l03998"></a>03998                DFID<span class="stringliteral">&quot;, &quot;</span>LPX64<span class="stringliteral">&quot;]: rc = %d\n&quot;</span>,
<a name="l03999"></a>03999                lfsck_lfsck2name(lfsck), pos-&gt;lp_oit_cookie,
<a name="l04000"></a>04000                PFID(&amp;pos-&gt;lp_dir_parent), pos-&gt;lp_dir_cookie, rc);
<a name="l04001"></a>04001 
<a name="l04002"></a>04002         <span class="keywordflow">return</span> rc;
<a name="l04003"></a>04003 }
<a name="l04004"></a>04004 
<a name="l04005"></a>04005 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_exec_oit(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04006"></a>04006                                     <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l04007"></a>04007                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj)
<a name="l04008"></a>04008 {
<a name="l04009"></a>04009         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a> *info  = lfsck_env_info(env);
<a name="l04010"></a>04010         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>   *ns    = com-&gt;lc_file_ram;
<a name="l04011"></a>04011         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>    *lfsck = com-&gt;lc_lfsck;
<a name="l04012"></a>04012         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>      *fid   = lfsck_dto2fid(obj);
<a name="l04013"></a>04013         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>            *pfid  = &amp;info-&gt;lti_fid2;
<a name="l04014"></a>04014         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>           *cname = &amp;info-&gt;lti_name;
<a name="l04015"></a>04015         <span class="keyword">struct </span><a class="code" href="structlu__seq__range.html" title="Describes a range of sequence, lsr_start is included but lsr_end is not in the range...">lu_seq_range</a>      *range = &amp;info-&gt;lti_range;
<a name="l04016"></a>04016         <span class="keyword">struct </span><a class="code" href="structseq__server__site.html">seq_server_site</a>   *ss    = lfsck_dev_site(lfsck);
<a name="l04017"></a>04017         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>        ldata = { NULL };
<a name="l04018"></a>04018         __u32                     idx   = lfsck_dev_idx(lfsck);
<a name="l04019"></a>04019         <span class="keywordtype">int</span>                       rc;
<a name="l04020"></a>04020         ENTRY;
<a name="l04021"></a>04021 
<a name="l04022"></a>04022         rc = lfsck_links_read(env, obj, &amp;ldata);
<a name="l04023"></a>04023         <span class="keywordflow">if</span> (rc == -ENOENT)
<a name="l04024"></a>04024                 GOTO(out, rc = 0);
<a name="l04025"></a>04025 
<a name="l04026"></a>04026         <span class="comment">/* -EINVAL means crashed linkEA, should be verified. */</span>
<a name="l04027"></a>04027         <span class="keywordflow">if</span> (rc == -EINVAL) {
<a name="l04028"></a>04028                 rc = lfsck_namespace_trace_update(env, com, fid,
<a name="l04029"></a>04029                                                   LNTF_CHECK_LINKEA, <span class="keyword">true</span>);
<a name="l04030"></a>04030                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l04031"></a>04031                         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lh = { 0 };
<a name="l04032"></a>04032 
<a name="l04033"></a>04033                         rc = lfsck_ibits_lock(env, lfsck, obj, &amp;lh,
<a name="l04034"></a>04034                                               MDS_INODELOCK_UPDATE |
<a name="l04035"></a>04035                                               MDS_INODELOCK_XATTR, LCK_EX);
<a name="l04036"></a>04036                         <span class="keywordflow">if</span> (rc == 0) {
<a name="l04037"></a>04037                                 rc = lfsck_namespace_links_remove(env, com,
<a name="l04038"></a>04038                                                                   obj);
<a name="l04039"></a>04039                                 lfsck_ibits_unlock(&amp;lh, LCK_EX);
<a name="l04040"></a>04040                         }
<a name="l04041"></a>04041                 }
<a name="l04042"></a>04042 
<a name="l04043"></a>04043                 GOTO(out, rc = (rc == -ENOENT ? 0 : rc));
<a name="l04044"></a>04044         }
<a name="l04045"></a>04045 
<a name="l04046"></a>04046         <span class="keywordflow">if</span> (rc == -ENODATA) {
<a name="l04047"></a>04047                 rc = lfsck_namespace_check_for_double_scan(env, com, obj);
<a name="l04048"></a>04048 
<a name="l04049"></a>04049                 GOTO(out, rc);
<a name="l04050"></a>04050         }
<a name="l04051"></a>04051 
<a name="l04052"></a>04052         <span class="keywordflow">if</span> (rc != 0)
<a name="l04053"></a>04053                 GOTO(out, rc);
<a name="l04054"></a>04054 
<a name="l04055"></a>04055         <span class="comment">/* Record multiple-linked object. */</span>
<a name="l04056"></a>04056         <span class="keywordflow">if</span> (ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount &gt; 1) {
<a name="l04057"></a>04057                 rc = lfsck_namespace_trace_update(env, com, fid,
<a name="l04058"></a>04058                                                   LNTF_CHECK_LINKEA, <span class="keyword">true</span>);
<a name="l04059"></a>04059 
<a name="l04060"></a>04060                 GOTO(out, rc);
<a name="l04061"></a>04061         }
<a name="l04062"></a>04062 
<a name="l04063"></a>04063         linkea_first_entry(&amp;ldata);
<a name="l04064"></a>04064         linkea_entry_unpack(ldata.ld_lee, &amp;ldata.ld_reclen, cname, pfid);
<a name="l04065"></a>04065         <span class="keywordflow">if</span> (!fid_is_sane(pfid)) {
<a name="l04066"></a>04066                 rc = lfsck_namespace_trace_update(env, com, fid,
<a name="l04067"></a>04067                                                   LNTF_CHECK_PARENT, <span class="keyword">true</span>);
<a name="l04068"></a>04068         } <span class="keywordflow">else</span> {
<a name="l04069"></a>04069                 fld_range_set_mdt(range);
<a name="l04070"></a>04070                 rc = <a class="code" href="group__fld.html#gaaebfe53fda6d4c3bb7dfc963bdb19509" title="Lookup sequece in local cache/fldb.">fld_local_lookup</a>(env, ss-&gt;<a class="code" href="structseq__server__site.html#a325bd7c1845a266e8f54469450152cb8" title="Fid location database.">ss_server_fld</a>,
<a name="l04071"></a>04071                                       <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(pfid), range);
<a name="l04072"></a>04072                 <span class="keywordflow">if</span> ((rc == -ENOENT) ||
<a name="l04073"></a>04073                     (rc == 0 &amp;&amp; range-&gt;lsr_index != idx))
<a name="l04074"></a>04074                         rc = lfsck_namespace_trace_update(env, com, fid,
<a name="l04075"></a>04075                                                 LNTF_CHECK_LINKEA, <span class="keyword">true</span>);
<a name="l04076"></a>04076                 <span class="keywordflow">else</span>
<a name="l04077"></a>04077                         rc = lfsck_namespace_check_for_double_scan(env, com,
<a name="l04078"></a>04078                                                                    obj);
<a name="l04079"></a>04079         }
<a name="l04080"></a>04080 
<a name="l04081"></a>04081         GOTO(out, rc);
<a name="l04082"></a>04082 
<a name="l04083"></a>04083 out:
<a name="l04084"></a>04084         down_write(&amp;com-&gt;lc_sem);
<a name="l04085"></a>04085         <span class="keywordflow">if</span> (S_ISDIR(lfsck_object_type(obj)))
<a name="l04086"></a>04086                 ns-&gt;ln_dirs_checked++;
<a name="l04087"></a>04087         <span class="keywordflow">if</span> (rc != 0)
<a name="l04088"></a>04088                 lfsck_namespace_record_failure(env, com-&gt;lc_lfsck, ns);
<a name="l04089"></a>04089         up_write(&amp;com-&gt;lc_sem);
<a name="l04090"></a>04090 
<a name="l04091"></a>04091         <span class="keywordflow">return</span> rc;
<a name="l04092"></a>04092 }
<a name="l04093"></a>04093 
<a name="l04094"></a>04094 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_exec_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04095"></a>04095                                     <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l04096"></a>04096                                     <span class="keyword">struct</span> <a class="code" href="structlfsck__assistant__object.html">lfsck_assistant_object</a> *lso,
<a name="l04097"></a>04097                                     <span class="keyword">struct</span> <a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *ent, __u16 type)
<a name="l04098"></a>04098 {
<a name="l04099"></a>04099         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad     = com-&gt;lc_data;
<a name="l04100"></a>04100         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck   = com-&gt;lc_lfsck;
<a name="l04101"></a>04101         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a>      *lnr;
<a name="l04102"></a>04102         <span class="keyword">struct </span><a class="code" href="structlfsck__bookmark.html">lfsck_bookmark</a>           *bk      = &amp;lfsck-&gt;li_bookmark_ram;
<a name="l04103"></a>04103         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>            *mthread = &amp;lfsck-&gt;li_thread;
<a name="l04104"></a>04104         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>            *athread = &amp;lad-&gt;lad_thread;
<a name="l04105"></a>04105         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>               lwi     = { 0 };
<a name="l04106"></a>04106         <span class="keywordtype">bool</span>                             wakeup  = <span class="keyword">false</span>;
<a name="l04107"></a>04107 
<a name="l04108"></a>04108         l_wait_event(mthread-&gt;t_ctl_waitq,
<a name="l04109"></a>04109                      lad-&gt;lad_prefetched &lt; bk-&gt;lb_async_windows ||
<a name="l04110"></a>04110                      !thread_is_running(mthread) ||
<a name="l04111"></a>04111                      thread_is_stopped(athread),
<a name="l04112"></a>04112                      &amp;lwi);
<a name="l04113"></a>04113 
<a name="l04114"></a>04114         <span class="keywordflow">if</span> (unlikely(!thread_is_running(mthread)) ||
<a name="l04115"></a>04115                      thread_is_stopped(athread))
<a name="l04116"></a>04116                 <span class="keywordflow">return</span> 0;
<a name="l04117"></a>04117 
<a name="l04118"></a>04118         <span class="keywordflow">if</span> (unlikely(lfsck_is_dead_obj(lfsck-&gt;li_obj_dir)))
<a name="l04119"></a>04119                 <span class="keywordflow">return</span> 0;
<a name="l04120"></a>04120 
<a name="l04121"></a>04121         lnr = lfsck_namespace_assistant_req_init(com-&gt;lc_lfsck, lso, ent, type);
<a name="l04122"></a>04122         <span class="keywordflow">if</span> (IS_ERR(lnr)) {
<a name="l04123"></a>04123                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l04124"></a>04124 
<a name="l04125"></a>04125                 lfsck_namespace_record_failure(env, com-&gt;lc_lfsck, ns);
<a name="l04126"></a>04126                 <span class="keywordflow">return</span> PTR_ERR(lnr);
<a name="l04127"></a>04127         }
<a name="l04128"></a>04128 
<a name="l04129"></a>04129         spin_lock(&amp;lad-&gt;lad_lock);
<a name="l04130"></a>04130         <span class="keywordflow">if</span> (lad-&gt;lad_assistant_status &lt; 0) {
<a name="l04131"></a>04131                 spin_unlock(&amp;lad-&gt;lad_lock);
<a name="l04132"></a>04132                 lfsck_namespace_assistant_req_fini(env, &amp;lnr-&gt;lnr_lar);
<a name="l04133"></a>04133                 <span class="keywordflow">return</span> lad-&gt;lad_assistant_status;
<a name="l04134"></a>04134         }
<a name="l04135"></a>04135 
<a name="l04136"></a>04136         list_add_tail(&amp;lnr-&gt;lnr_lar.lar_list, &amp;lad-&gt;lad_req_list);
<a name="l04137"></a>04137         <span class="keywordflow">if</span> (lad-&gt;lad_prefetched == 0)
<a name="l04138"></a>04138                 wakeup = <span class="keyword">true</span>;
<a name="l04139"></a>04139 
<a name="l04140"></a>04140         lad-&gt;lad_prefetched++;
<a name="l04141"></a>04141         spin_unlock(&amp;lad-&gt;lad_lock);
<a name="l04142"></a>04142         <span class="keywordflow">if</span> (wakeup)
<a name="l04143"></a>04143                 wake_up_all(&amp;lad-&gt;lad_thread.t_ctl_waitq);
<a name="l04144"></a>04144 
<a name="l04145"></a>04145         down_write(&amp;com-&gt;lc_sem);
<a name="l04146"></a>04146         com-&gt;lc_new_checked++;
<a name="l04147"></a>04147         up_write(&amp;com-&gt;lc_sem);
<a name="l04148"></a>04148 
<a name="l04149"></a>04149         <span class="keywordflow">return</span> 0;
<a name="l04150"></a>04150 }
<a name="l04151"></a>04151 
<a name="l04152"></a>04152 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_post(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04153"></a>04153                                 <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l04154"></a>04154                                 <span class="keywordtype">int</span> result, <span class="keywordtype">bool</span> init)
<a name="l04155"></a>04155 {
<a name="l04156"></a>04156         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck = com-&gt;lc_lfsck;
<a name="l04157"></a>04157         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>  *ns    = com-&gt;lc_file_ram;
<a name="l04158"></a>04158         <span class="keywordtype">int</span>                      rc;
<a name="l04159"></a>04159         ENTRY;
<a name="l04160"></a>04160 
<a name="l04161"></a>04161         lfsck_post_generic(env, com, &amp;result);
<a name="l04162"></a>04162 
<a name="l04163"></a>04163         down_write(&amp;com-&gt;lc_sem);
<a name="l04164"></a>04164         lfsck_namespace_release_lmv(env, com);
<a name="l04165"></a>04165 
<a name="l04166"></a>04166         spin_lock(&amp;lfsck-&gt;li_lock);
<a name="l04167"></a>04167         <span class="keywordflow">if</span> (!init)
<a name="l04168"></a>04168                 ns-&gt;ln_pos_last_checkpoint = lfsck-&gt;li_pos_checkpoint;
<a name="l04169"></a>04169         <span class="keywordflow">if</span> (result &gt; 0) {
<a name="l04170"></a>04170                 ns-&gt;ln_status = LS_SCANNING_PHASE2;
<a name="l04171"></a>04171                 ns-&gt;ln_flags |= LF_SCANNED_ONCE;
<a name="l04172"></a>04172                 ns-&gt;ln_flags &amp;= ~LF_UPGRADE;
<a name="l04173"></a>04173                 list_del_init(&amp;com-&gt;lc_link_dir);
<a name="l04174"></a>04174                 list_move_tail(&amp;com-&gt;lc_link, &amp;lfsck-&gt;li_list_double_scan);
<a name="l04175"></a>04175         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (result == 0) {
<a name="l04176"></a>04176                 <span class="keywordflow">if</span> (lfsck-&gt;li_status != 0)
<a name="l04177"></a>04177                         ns-&gt;ln_status = lfsck-&gt;li_status;
<a name="l04178"></a>04178                 <span class="keywordflow">else</span>
<a name="l04179"></a>04179                         ns-&gt;ln_status = LS_STOPPED;
<a name="l04180"></a>04180                 <span class="keywordflow">if</span> (ns-&gt;ln_status != LS_PAUSED) {
<a name="l04181"></a>04181                         list_del_init(&amp;com-&gt;lc_link_dir);
<a name="l04182"></a>04182                         list_move_tail(&amp;com-&gt;lc_link, &amp;lfsck-&gt;li_list_idle);
<a name="l04183"></a>04183                 }
<a name="l04184"></a>04184         } <span class="keywordflow">else</span> {
<a name="l04185"></a>04185                 ns-&gt;ln_status = LS_FAILED;
<a name="l04186"></a>04186                 list_del_init(&amp;com-&gt;lc_link_dir);
<a name="l04187"></a>04187                 list_move_tail(&amp;com-&gt;lc_link, &amp;lfsck-&gt;li_list_idle);
<a name="l04188"></a>04188         }
<a name="l04189"></a>04189         spin_unlock(&amp;lfsck-&gt;li_lock);
<a name="l04190"></a>04190 
<a name="l04191"></a>04191         <span class="keywordflow">if</span> (!init) {
<a name="l04192"></a>04192                 ns-&gt;ln_run_time_phase1 += cfs_duration_sec(cfs_time_current() +
<a name="l04193"></a>04193                                 HALF_SEC - lfsck-&gt;li_time_last_checkpoint);
<a name="l04194"></a>04194                 ns-&gt;ln_time_last_checkpoint = cfs_time_current_sec();
<a name="l04195"></a>04195                 ns-&gt;ln_items_checked += com-&gt;lc_new_checked;
<a name="l04196"></a>04196                 com-&gt;lc_new_checked = 0;
<a name="l04197"></a>04197         }
<a name="l04198"></a>04198 
<a name="l04199"></a>04199         rc = lfsck_namespace_store(env, com);
<a name="l04200"></a>04200         up_write(&amp;com-&gt;lc_sem);
<a name="l04201"></a>04201 
<a name="l04202"></a>04202         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK post done: rc = %d\n&quot;</span>,
<a name="l04203"></a>04203                lfsck_lfsck2name(lfsck), rc);
<a name="l04204"></a>04204 
<a name="l04205"></a>04205         RETURN(rc);
<a name="l04206"></a>04206 }
<a name="l04207"></a>04207 
<a name="l04208"></a>04208 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04209"></a>04209 lfsck_namespace_dump(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l04210"></a>04210                      <span class="keyword">struct</span> seq_file *m)
<a name="l04211"></a>04211 {
<a name="l04212"></a>04212         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck = com-&gt;lc_lfsck;
<a name="l04213"></a>04213         <span class="keyword">struct </span><a class="code" href="structlfsck__bookmark.html">lfsck_bookmark</a>   *bk    = &amp;lfsck-&gt;li_bookmark_ram;
<a name="l04214"></a>04214         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>  *ns    = com-&gt;lc_file_ram;
<a name="l04215"></a>04215 
<a name="l04216"></a>04216         down_read(&amp;com-&gt;lc_sem);
<a name="l04217"></a>04217         seq_printf(m, <span class="stringliteral">&quot;name: lfsck_namespace\n&quot;</span>
<a name="l04218"></a>04218                    <span class="stringliteral">&quot;magic: %#x\n&quot;</span>
<a name="l04219"></a>04219                    <span class="stringliteral">&quot;version: %d\n&quot;</span>
<a name="l04220"></a>04220                    <span class="stringliteral">&quot;status: %s\n&quot;</span>,
<a name="l04221"></a>04221                    ns-&gt;ln_magic,
<a name="l04222"></a>04222                    bk-&gt;lb_version,
<a name="l04223"></a>04223                    lfsck_status2name(ns-&gt;ln_status));
<a name="l04224"></a>04224 
<a name="l04225"></a>04225         lfsck_bits_dump(m, ns-&gt;ln_flags, lfsck_flags_names, <span class="stringliteral">&quot;flags&quot;</span>);
<a name="l04226"></a>04226 
<a name="l04227"></a>04227         lfsck_bits_dump(m, bk-&gt;lb_param, lfsck_param_names, <span class="stringliteral">&quot;param&quot;</span>);
<a name="l04228"></a>04228 
<a name="l04229"></a>04229         lfsck_time_dump(m, ns-&gt;ln_time_last_complete, <span class="stringliteral">&quot;last_completed&quot;</span>);
<a name="l04230"></a>04230 
<a name="l04231"></a>04231         lfsck_time_dump(m, ns-&gt;ln_time_latest_start, <span class="stringliteral">&quot;latest_start&quot;</span>);
<a name="l04232"></a>04232 
<a name="l04233"></a>04233         lfsck_time_dump(m, ns-&gt;ln_time_last_checkpoint, <span class="stringliteral">&quot;last_checkpoint&quot;</span>);
<a name="l04234"></a>04234 
<a name="l04235"></a>04235         lfsck_pos_dump(m, &amp;ns-&gt;ln_pos_latest_start, <span class="stringliteral">&quot;latest_start_position&quot;</span>);
<a name="l04236"></a>04236 
<a name="l04237"></a>04237         lfsck_pos_dump(m, &amp;ns-&gt;ln_pos_last_checkpoint,
<a name="l04238"></a>04238                        <span class="stringliteral">&quot;last_checkpoint_position&quot;</span>);
<a name="l04239"></a>04239 
<a name="l04240"></a>04240         lfsck_pos_dump(m, &amp;ns-&gt;ln_pos_first_inconsistent,
<a name="l04241"></a>04241                        <span class="stringliteral">&quot;first_failure_position&quot;</span>);
<a name="l04242"></a>04242 
<a name="l04243"></a>04243         <span class="keywordflow">if</span> (ns-&gt;ln_status == LS_SCANNING_PHASE1) {
<a name="l04244"></a>04244                 <span class="keyword">struct </span><a class="code" href="structlfsck__position.html">lfsck_position</a> pos;
<a name="l04245"></a>04245                 <span class="keyword">const</span> <span class="keyword">struct </span>dt_it_ops *iops;
<a name="l04246"></a>04246                 cfs_duration_t duration = cfs_time_current() -
<a name="l04247"></a>04247                                           lfsck-&gt;li_time_last_checkpoint;
<a name="l04248"></a>04248                 __u64 checked = ns-&gt;ln_items_checked + com-&gt;lc_new_checked;
<a name="l04249"></a>04249                 __u64 speed = checked;
<a name="l04250"></a>04250                 __u64 new_checked = com-&gt;lc_new_checked *
<a name="l04251"></a>04251                                     msecs_to_jiffies(MSEC_PER_SEC);
<a name="l04252"></a>04252                 __u32 rtime = ns-&gt;ln_run_time_phase1 +
<a name="l04253"></a>04253                               cfs_duration_sec(duration + HALF_SEC);
<a name="l04254"></a>04254 
<a name="l04255"></a>04255                 <span class="keywordflow">if</span> (duration != 0)
<a name="l04256"></a>04256                         do_div(new_checked, duration);
<a name="l04257"></a>04257 
<a name="l04258"></a>04258                 <span class="keywordflow">if</span> (rtime != 0)
<a name="l04259"></a>04259                         do_div(speed, rtime);
<a name="l04260"></a>04260 
<a name="l04261"></a>04261                 lfsck_namespace_dump_statistics(m, ns, checked, 0, rtime, 0);
<a name="l04262"></a>04262                 seq_printf(m, <span class="stringliteral">&quot;average_speed_phase1: &quot;</span>LPU64<span class="stringliteral">&quot; items/sec\n&quot;</span>
<a name="l04263"></a>04263                            <span class="stringliteral">&quot;average_speed_phase2: N/A\n&quot;</span>
<a name="l04264"></a>04264                            <span class="stringliteral">&quot;average_speed_total: &quot;</span>LPU64<span class="stringliteral">&quot; items/sec\n&quot;</span>
<a name="l04265"></a>04265                            <span class="stringliteral">&quot;real_time_speed_phase1: &quot;</span>LPU64<span class="stringliteral">&quot; items/sec\n&quot;</span>
<a name="l04266"></a>04266                            <span class="stringliteral">&quot;real_time_speed_phase2: N/A\n&quot;</span>,
<a name="l04267"></a>04267                            speed,
<a name="l04268"></a>04268                            speed,
<a name="l04269"></a>04269                            new_checked);
<a name="l04270"></a>04270 
<a name="l04271"></a>04271                 LASSERT(lfsck-&gt;li_di_oit != NULL);
<a name="l04272"></a>04272 
<a name="l04273"></a>04273                 iops = &amp;lfsck-&gt;li_obj_oit-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>;
<a name="l04274"></a>04274 
<a name="l04275"></a>04275                 <span class="comment">/* The low layer otable-based iteration position may NOT</span>
<a name="l04276"></a>04276 <span class="comment">                 * exactly match the namespace-based directory traversal</span>
<a name="l04277"></a>04277 <span class="comment">                 * cookie. Generally, it is not a serious issue. But the</span>
<a name="l04278"></a>04278 <span class="comment">                 * caller should NOT make assumption on that. */</span>
<a name="l04279"></a>04279                 pos.lp_oit_cookie = iops-&gt;store(env, lfsck-&gt;li_di_oit);
<a name="l04280"></a>04280                 <span class="keywordflow">if</span> (!lfsck-&gt;li_current_oit_processed)
<a name="l04281"></a>04281                         pos.lp_oit_cookie--;
<a name="l04282"></a>04282 
<a name="l04283"></a>04283                 spin_lock(&amp;lfsck-&gt;li_lock);
<a name="l04284"></a>04284                 <span class="keywordflow">if</span> (lfsck-&gt;li_di_dir != NULL) {
<a name="l04285"></a>04285                         pos.lp_dir_cookie = lfsck-&gt;li_cookie_dir;
<a name="l04286"></a>04286                         <span class="keywordflow">if</span> (pos.lp_dir_cookie &gt;= MDS_DIR_END_OFF) {
<a name="l04287"></a>04287                                 fid_zero(&amp;pos.lp_dir_parent);
<a name="l04288"></a>04288                                 pos.lp_dir_cookie = 0;
<a name="l04289"></a>04289                         } <span class="keywordflow">else</span> {
<a name="l04290"></a>04290                                 pos.lp_dir_parent =
<a name="l04291"></a>04291                                         *lfsck_dto2fid(lfsck-&gt;li_obj_dir);
<a name="l04292"></a>04292                         }
<a name="l04293"></a>04293                 } <span class="keywordflow">else</span> {
<a name="l04294"></a>04294                         fid_zero(&amp;pos.lp_dir_parent);
<a name="l04295"></a>04295                         pos.lp_dir_cookie = 0;
<a name="l04296"></a>04296                 }
<a name="l04297"></a>04297                 spin_unlock(&amp;lfsck-&gt;li_lock);
<a name="l04298"></a>04298                 lfsck_pos_dump(m, &amp;pos, <span class="stringliteral">&quot;current_position&quot;</span>);
<a name="l04299"></a>04299         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ns-&gt;ln_status == LS_SCANNING_PHASE2) {
<a name="l04300"></a>04300                 cfs_duration_t duration = cfs_time_current() -
<a name="l04301"></a>04301                                           com-&gt;lc_time_last_checkpoint;
<a name="l04302"></a>04302                 __u64 checked = ns-&gt;ln_objs_checked_phase2 +
<a name="l04303"></a>04303                                 com-&gt;lc_new_checked;
<a name="l04304"></a>04304                 __u64 speed1 = ns-&gt;ln_items_checked;
<a name="l04305"></a>04305                 __u64 speed2 = checked;
<a name="l04306"></a>04306                 __u64 speed0 = speed1 + speed2;
<a name="l04307"></a>04307                 __u64 new_checked = com-&gt;lc_new_checked *
<a name="l04308"></a>04308                                     msecs_to_jiffies(MSEC_PER_SEC);
<a name="l04309"></a>04309                 __u32 rtime = ns-&gt;ln_run_time_phase2 +
<a name="l04310"></a>04310                               cfs_duration_sec(duration + HALF_SEC);
<a name="l04311"></a>04311                 __u32 time0 = ns-&gt;ln_run_time_phase1 + rtime;
<a name="l04312"></a>04312 
<a name="l04313"></a>04313                 <span class="keywordflow">if</span> (duration != 0)
<a name="l04314"></a>04314                         do_div(new_checked, duration);
<a name="l04315"></a>04315 
<a name="l04316"></a>04316                 <span class="keywordflow">if</span> (ns-&gt;ln_run_time_phase1 != 0)
<a name="l04317"></a>04317                         do_div(speed1, ns-&gt;ln_run_time_phase1);
<a name="l04318"></a>04318                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ns-&gt;ln_items_checked != 0)
<a name="l04319"></a>04319                         time0++;
<a name="l04320"></a>04320 
<a name="l04321"></a>04321                 <span class="keywordflow">if</span> (rtime != 0)
<a name="l04322"></a>04322                         do_div(speed2, rtime);
<a name="l04323"></a>04323                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checked != 0)
<a name="l04324"></a>04324                         time0++;
<a name="l04325"></a>04325 
<a name="l04326"></a>04326                 <span class="keywordflow">if</span> (time0 != 0)
<a name="l04327"></a>04327                         do_div(speed0, time0);
<a name="l04328"></a>04328 
<a name="l04329"></a>04329                 lfsck_namespace_dump_statistics(m, ns, ns-&gt;ln_items_checked,
<a name="l04330"></a>04330                                                 checked,
<a name="l04331"></a>04331                                                 ns-&gt;ln_run_time_phase1, rtime);
<a name="l04332"></a>04332                 seq_printf(m, <span class="stringliteral">&quot;average_speed_phase1: &quot;</span>LPU64<span class="stringliteral">&quot; items/sec\n&quot;</span>
<a name="l04333"></a>04333                            <span class="stringliteral">&quot;average_speed_phase2: &quot;</span>LPU64<span class="stringliteral">&quot; objs/sec\n&quot;</span>
<a name="l04334"></a>04334                            <span class="stringliteral">&quot;average_speed_total: &quot;</span>LPU64<span class="stringliteral">&quot; items/sec\n&quot;</span>
<a name="l04335"></a>04335                            <span class="stringliteral">&quot;real_time_speed_phase1: N/A\n&quot;</span>
<a name="l04336"></a>04336                            <span class="stringliteral">&quot;real_time_speed_phase2: &quot;</span>LPU64<span class="stringliteral">&quot; objs/sec\n&quot;</span>
<a name="l04337"></a>04337                            <span class="stringliteral">&quot;current_position: &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l04338"></a>04338                            speed1,
<a name="l04339"></a>04339                            speed2,
<a name="l04340"></a>04340                            speed0,
<a name="l04341"></a>04341                            new_checked,
<a name="l04342"></a>04342                            PFID(&amp;ns-&gt;ln_fid_latest_scanned_phase2));
<a name="l04343"></a>04343         } <span class="keywordflow">else</span> {
<a name="l04344"></a>04344                 __u64 speed1 = ns-&gt;ln_items_checked;
<a name="l04345"></a>04345                 __u64 speed2 = ns-&gt;ln_objs_checked_phase2;
<a name="l04346"></a>04346                 __u64 speed0 = speed1 + speed2;
<a name="l04347"></a>04347                 __u32 time0 = ns-&gt;ln_run_time_phase1 + ns-&gt;ln_run_time_phase2;
<a name="l04348"></a>04348 
<a name="l04349"></a>04349                 <span class="keywordflow">if</span> (ns-&gt;ln_run_time_phase1 != 0)
<a name="l04350"></a>04350                         do_div(speed1, ns-&gt;ln_run_time_phase1);
<a name="l04351"></a>04351                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ns-&gt;ln_items_checked != 0)
<a name="l04352"></a>04352                         time0++;
<a name="l04353"></a>04353 
<a name="l04354"></a>04354                 <span class="keywordflow">if</span> (ns-&gt;ln_run_time_phase2 != 0)
<a name="l04355"></a>04355                         do_div(speed2, ns-&gt;ln_run_time_phase2);
<a name="l04356"></a>04356                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ns-&gt;ln_objs_checked_phase2 != 0)
<a name="l04357"></a>04357                         time0++;
<a name="l04358"></a>04358 
<a name="l04359"></a>04359                 <span class="keywordflow">if</span> (time0 != 0)
<a name="l04360"></a>04360                         do_div(speed0, time0);
<a name="l04361"></a>04361 
<a name="l04362"></a>04362                 lfsck_namespace_dump_statistics(m, ns, ns-&gt;ln_items_checked,
<a name="l04363"></a>04363                                                 ns-&gt;ln_objs_checked_phase2,
<a name="l04364"></a>04364                                                 ns-&gt;ln_run_time_phase1,
<a name="l04365"></a>04365                                                 ns-&gt;ln_run_time_phase2);
<a name="l04366"></a>04366                 seq_printf(m, <span class="stringliteral">&quot;average_speed_phase1: &quot;</span>LPU64<span class="stringliteral">&quot; items/sec\n&quot;</span>
<a name="l04367"></a>04367                            <span class="stringliteral">&quot;average_speed_phase2: &quot;</span>LPU64<span class="stringliteral">&quot; objs/sec\n&quot;</span>
<a name="l04368"></a>04368                            <span class="stringliteral">&quot;average_speed_total: &quot;</span>LPU64<span class="stringliteral">&quot; items/sec\n&quot;</span>
<a name="l04369"></a>04369                            <span class="stringliteral">&quot;real_time_speed_phase1: N/A\n&quot;</span>
<a name="l04370"></a>04370                            <span class="stringliteral">&quot;real_time_speed_phase2: N/A\n&quot;</span>
<a name="l04371"></a>04371                            <span class="stringliteral">&quot;current_position: N/A\n&quot;</span>,
<a name="l04372"></a>04372                            speed1,
<a name="l04373"></a>04373                            speed2,
<a name="l04374"></a>04374                            speed0);
<a name="l04375"></a>04375         }
<a name="l04376"></a>04376 
<a name="l04377"></a>04377         up_read(&amp;com-&gt;lc_sem);
<a name="l04378"></a>04378 }
<a name="l04379"></a>04379 
<a name="l04380"></a>04380 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_double_scan(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04381"></a>04381                                        <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l04382"></a>04382 {
<a name="l04383"></a>04383         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns     = com-&gt;lc_file_ram;
<a name="l04384"></a>04384         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad    = com-&gt;lc_data;
<a name="l04385"></a>04385         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__descs.html">lfsck_tgt_descs</a>          *ltds   = &amp;com-&gt;lc_lfsck-&gt;li_mdt_descs;
<a name="l04386"></a>04386         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a>           *ltd;
<a name="l04387"></a>04387         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a>           *next;
<a name="l04388"></a>04388         <span class="keywordtype">int</span>                              rc;
<a name="l04389"></a>04389 
<a name="l04390"></a>04390         rc = lfsck_double_scan_generic(env, com, ns-&gt;ln_status);
<a name="l04391"></a>04391         <span class="keywordflow">if</span> (thread_is_stopped(&amp;lad-&gt;lad_thread)) {
<a name="l04392"></a>04392                 LASSERT(list_empty(&amp;lad-&gt;lad_req_list));
<a name="l04393"></a>04393                 LASSERT(list_empty(&amp;lad-&gt;lad_mdt_phase1_list));
<a name="l04394"></a>04394 
<a name="l04395"></a>04395                 spin_lock(&amp;ltds-&gt;ltd_lock);
<a name="l04396"></a>04396                 list_for_each_entry_safe(ltd, next, &amp;lad-&gt;lad_mdt_phase2_list,
<a name="l04397"></a>04397                                          ltd_namespace_phase_list) {
<a name="l04398"></a>04398                         list_del_init(&amp;ltd-&gt;ltd_namespace_phase_list);
<a name="l04399"></a>04399                 }
<a name="l04400"></a>04400                 spin_unlock(&amp;ltds-&gt;ltd_lock);
<a name="l04401"></a>04401         }
<a name="l04402"></a>04402 
<a name="l04403"></a>04403         <span class="keywordflow">return</span> rc;
<a name="l04404"></a>04404 }
<a name="l04405"></a>04405 
<a name="l04406"></a>04406 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_data_release(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04407"></a>04407                                          <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l04408"></a>04408 {
<a name="l04409"></a>04409         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad    = com-&gt;lc_data;
<a name="l04410"></a>04410         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__descs.html">lfsck_tgt_descs</a>          *ltds   = &amp;com-&gt;lc_lfsck-&gt;li_mdt_descs;
<a name="l04411"></a>04411         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a>           *ltd;
<a name="l04412"></a>04412         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a>           *next;
<a name="l04413"></a>04413 
<a name="l04414"></a>04414         LASSERT(lad != NULL);
<a name="l04415"></a>04415         LASSERT(thread_is_init(&amp;lad-&gt;lad_thread) ||
<a name="l04416"></a>04416                 thread_is_stopped(&amp;lad-&gt;lad_thread));
<a name="l04417"></a>04417         LASSERT(list_empty(&amp;lad-&gt;lad_req_list));
<a name="l04418"></a>04418 
<a name="l04419"></a>04419         com-&gt;lc_data = NULL;
<a name="l04420"></a>04420         lfsck_namespace_release_lmv(env, com);
<a name="l04421"></a>04421 
<a name="l04422"></a>04422         spin_lock(&amp;ltds-&gt;ltd_lock);
<a name="l04423"></a>04423         list_for_each_entry_safe(ltd, next, &amp;lad-&gt;lad_mdt_phase1_list,
<a name="l04424"></a>04424                                  ltd_namespace_phase_list) {
<a name="l04425"></a>04425                 list_del_init(&amp;ltd-&gt;ltd_namespace_phase_list);
<a name="l04426"></a>04426         }
<a name="l04427"></a>04427         list_for_each_entry_safe(ltd, next, &amp;lad-&gt;lad_mdt_phase2_list,
<a name="l04428"></a>04428                                  ltd_namespace_phase_list) {
<a name="l04429"></a>04429                 list_del_init(&amp;ltd-&gt;ltd_namespace_phase_list);
<a name="l04430"></a>04430         }
<a name="l04431"></a>04431         list_for_each_entry_safe(ltd, next, &amp;lad-&gt;lad_mdt_list,
<a name="l04432"></a>04432                                  ltd_namespace_list) {
<a name="l04433"></a>04433                 list_del_init(&amp;ltd-&gt;ltd_namespace_list);
<a name="l04434"></a>04434         }
<a name="l04435"></a>04435         spin_unlock(&amp;ltds-&gt;ltd_lock);
<a name="l04436"></a>04436 
<a name="l04437"></a>04437         <span class="keywordflow">if</span> (likely(lad-&gt;lad_bitmap != NULL))
<a name="l04438"></a>04438                 CFS_FREE_BITMAP(lad-&gt;lad_bitmap);
<a name="l04439"></a>04439 
<a name="l04440"></a>04440         OBD_FREE_PTR(lad);
<a name="l04441"></a>04441 }
<a name="l04442"></a>04442 
<a name="l04443"></a>04443 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_quit(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04444"></a>04444                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l04445"></a>04445 {
<a name="l04446"></a>04446         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad    = com-&gt;lc_data;
<a name="l04447"></a>04447         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__descs.html">lfsck_tgt_descs</a>          *ltds   = &amp;com-&gt;lc_lfsck-&gt;li_mdt_descs;
<a name="l04448"></a>04448         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a>           *ltd;
<a name="l04449"></a>04449         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a>           *next;
<a name="l04450"></a>04450 
<a name="l04451"></a>04451         LASSERT(lad != NULL);
<a name="l04452"></a>04452 
<a name="l04453"></a>04453         lfsck_quit_generic(env, com);
<a name="l04454"></a>04454 
<a name="l04455"></a>04455         LASSERT(thread_is_init(&amp;lad-&gt;lad_thread) ||
<a name="l04456"></a>04456                 thread_is_stopped(&amp;lad-&gt;lad_thread));
<a name="l04457"></a>04457         LASSERT(list_empty(&amp;lad-&gt;lad_req_list));
<a name="l04458"></a>04458 
<a name="l04459"></a>04459         lfsck_namespace_release_lmv(env, com);
<a name="l04460"></a>04460 
<a name="l04461"></a>04461         spin_lock(&amp;ltds-&gt;ltd_lock);
<a name="l04462"></a>04462         list_for_each_entry_safe(ltd, next, &amp;lad-&gt;lad_mdt_phase1_list,
<a name="l04463"></a>04463                                  ltd_namespace_phase_list) {
<a name="l04464"></a>04464                 list_del_init(&amp;ltd-&gt;ltd_namespace_phase_list);
<a name="l04465"></a>04465         }
<a name="l04466"></a>04466         list_for_each_entry_safe(ltd, next, &amp;lad-&gt;lad_mdt_phase2_list,
<a name="l04467"></a>04467                                  ltd_namespace_phase_list) {
<a name="l04468"></a>04468                 list_del_init(&amp;ltd-&gt;ltd_namespace_phase_list);
<a name="l04469"></a>04469         }
<a name="l04470"></a>04470         spin_unlock(&amp;ltds-&gt;ltd_lock);
<a name="l04471"></a>04471 }
<a name="l04472"></a>04472 
<a name="l04473"></a>04473 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_in_notify(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04474"></a>04474                                      <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l04475"></a>04475                                      <span class="keyword">struct</span> <a class="code" href="structlfsck__request.html">lfsck_request</a> *lr,
<a name="l04476"></a>04476                                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l04477"></a>04477 {
<a name="l04478"></a>04478         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck = com-&gt;lc_lfsck;
<a name="l04479"></a>04479         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns    = com-&gt;lc_file_ram;
<a name="l04480"></a>04480         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad   = com-&gt;lc_data;
<a name="l04481"></a>04481         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__descs.html">lfsck_tgt_descs</a>          *ltds  = &amp;lfsck-&gt;li_mdt_descs;
<a name="l04482"></a>04482         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a>           *ltd;
<a name="l04483"></a>04483         <span class="keywordtype">int</span>                              rc    = 0;
<a name="l04484"></a>04484         <span class="keywordtype">bool</span>                             fail  = <span class="keyword">false</span>;
<a name="l04485"></a>04485         ENTRY;
<a name="l04486"></a>04486 
<a name="l04487"></a>04487         <span class="keywordflow">switch</span> (lr-&gt;lr_event) {
<a name="l04488"></a>04488         <span class="keywordflow">case</span> LE_SKIP_NLINK_DECLARE: {
<a name="l04489"></a>04489                 <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *obj;
<a name="l04490"></a>04490                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           *key   = &amp;lfsck_env_info(env)-&gt;lti_fid3;
<a name="l04491"></a>04491                 <span class="keywordtype">int</span>                      idx;
<a name="l04492"></a>04492                 __u8                     flags = 0;
<a name="l04493"></a>04493 
<a name="l04494"></a>04494                 LASSERT(th != NULL);
<a name="l04495"></a>04495 
<a name="l04496"></a>04496                 idx = lfsck_sub_trace_file_fid2idx(&amp;lr-&gt;lr_fid);
<a name="l04497"></a>04497                 obj = com-&gt;lc_sub_trace_objs[idx].lsto_obj;
<a name="l04498"></a>04498                 fid_cpu_to_be(key, &amp;lr-&gt;lr_fid);
<a name="l04499"></a>04499                 mutex_lock(&amp;com-&gt;lc_sub_trace_objs[idx].lsto_mutex);
<a name="l04500"></a>04500                 rc = dt_declare_delete(env, obj,
<a name="l04501"></a>04501                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th);
<a name="l04502"></a>04502                 <span class="keywordflow">if</span> (rc == 0)
<a name="l04503"></a>04503                         rc = dt_declare_insert(env, obj,
<a name="l04504"></a>04504                                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)&amp;flags,
<a name="l04505"></a>04505                                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th);
<a name="l04506"></a>04506                 mutex_unlock(&amp;com-&gt;lc_sub_trace_objs[idx].lsto_mutex);
<a name="l04507"></a>04507 
<a name="l04508"></a>04508                 RETURN(rc);
<a name="l04509"></a>04509         }
<a name="l04510"></a>04510         <span class="keywordflow">case</span> LE_SKIP_NLINK: {
<a name="l04511"></a>04511                 <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *obj;
<a name="l04512"></a>04512                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           *key   = &amp;lfsck_env_info(env)-&gt;lti_fid3;
<a name="l04513"></a>04513                 <span class="keywordtype">int</span>                      idx;
<a name="l04514"></a>04514                 __u8                     flags = 0;
<a name="l04515"></a>04515                 <span class="keywordtype">bool</span>                     exist = <span class="keyword">false</span>;
<a name="l04516"></a>04516                 ENTRY;
<a name="l04517"></a>04517 
<a name="l04518"></a>04518                 LASSERT(th != NULL);
<a name="l04519"></a>04519 
<a name="l04520"></a>04520                 idx = lfsck_sub_trace_file_fid2idx(&amp;lr-&gt;lr_fid);
<a name="l04521"></a>04521                 obj = com-&gt;lc_sub_trace_objs[idx].lsto_obj;
<a name="l04522"></a>04522                 fid_cpu_to_be(key, &amp;lr-&gt;lr_fid);
<a name="l04523"></a>04523                 mutex_lock(&amp;com-&gt;lc_sub_trace_objs[idx].lsto_mutex);
<a name="l04524"></a>04524                 rc = dt_lookup(env, obj, (<span class="keyword">struct</span> dt_rec *)&amp;flags,
<a name="l04525"></a>04525                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key);
<a name="l04526"></a>04526                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l04527"></a>04527                         <span class="keywordflow">if</span> (flags &amp; LNTF_SKIP_NLINK) {
<a name="l04528"></a>04528                                 mutex_unlock(
<a name="l04529"></a>04529                                 &amp;com-&gt;lc_sub_trace_objs[idx].lsto_mutex);
<a name="l04530"></a>04530 
<a name="l04531"></a>04531                                 RETURN(0);
<a name="l04532"></a>04532                         }
<a name="l04533"></a>04533 
<a name="l04534"></a>04534                         exist = <span class="keyword">true</span>;
<a name="l04535"></a>04535                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ENOENT) {
<a name="l04536"></a>04536                         GOTO(log, rc);
<a name="l04537"></a>04537                 }
<a name="l04538"></a>04538 
<a name="l04539"></a>04539                 flags |= LNTF_SKIP_NLINK;
<a name="l04540"></a>04540                 <span class="keywordflow">if</span> (exist) {
<a name="l04541"></a>04541                         rc = dt_delete(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key,
<a name="l04542"></a>04542                                        th);
<a name="l04543"></a>04543                         <span class="keywordflow">if</span> (rc != 0)
<a name="l04544"></a>04544                                 GOTO(log, rc);
<a name="l04545"></a>04545                 }
<a name="l04546"></a>04546 
<a name="l04547"></a>04547                 rc = dt_insert(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)&amp;flags,
<a name="l04548"></a>04548                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th, 1);
<a name="l04549"></a>04549 
<a name="l04550"></a>04550                 GOTO(log, rc);
<a name="l04551"></a>04551 
<a name="l04552"></a>04552 log:
<a name="l04553"></a>04553                 mutex_unlock(&amp;com-&gt;lc_sub_trace_objs[idx].lsto_mutex);
<a name="l04554"></a>04554                 CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: RPC service thread mark the &quot;</span>DFID
<a name="l04555"></a>04555                        <span class="stringliteral">&quot; to be skipped for namespace double scan: rc = %d\n&quot;</span>,
<a name="l04556"></a>04556                        lfsck_lfsck2name(com-&gt;lc_lfsck), PFID(&amp;lr-&gt;lr_fid), rc);
<a name="l04557"></a>04557 
<a name="l04558"></a>04558                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04559"></a>04559                         <span class="comment">/* If we cannot record this object in the LFSCK tracing,</span>
<a name="l04560"></a>04560 <span class="comment">                         * we have to mark the LFSC as LF_INCOMPLETE, then the</span>
<a name="l04561"></a>04561 <span class="comment">                         * LFSCK will skip nlink attribute verification for</span>
<a name="l04562"></a>04562 <span class="comment">                         * all objects. */</span>
<a name="l04563"></a>04563                         ns-&gt;ln_flags |= LF_INCOMPLETE;
<a name="l04564"></a>04564 
<a name="l04565"></a>04565                 <span class="keywordflow">return</span> 0;
<a name="l04566"></a>04566         }
<a name="l04567"></a>04567         <span class="keywordflow">case</span> LE_SET_LMV_MASTER: {
<a name="l04568"></a>04568                 <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *obj;
<a name="l04569"></a>04569 
<a name="l04570"></a>04570                 obj = lfsck_object_find_bottom(env, lfsck, &amp;lr-&gt;lr_fid);
<a name="l04571"></a>04571                 <span class="keywordflow">if</span> (IS_ERR(obj))
<a name="l04572"></a>04572                         RETURN(PTR_ERR(obj));
<a name="l04573"></a>04573 
<a name="l04574"></a>04574                 <span class="keywordflow">if</span> (likely(dt_object_exists(obj)))
<a name="l04575"></a>04575                         rc = lfsck_namespace_notify_lmv_master_local(env, com,
<a name="l04576"></a>04576                                                                      obj);
<a name="l04577"></a>04577 
<a name="l04578"></a>04578                 lfsck_object_put(env, obj);
<a name="l04579"></a>04579 
<a name="l04580"></a>04580                 RETURN(rc &gt; 0 ? 0 : rc);
<a name="l04581"></a>04581         }
<a name="l04582"></a>04582         <span class="keywordflow">case</span> LE_SET_LMV_SLAVE: {
<a name="l04583"></a>04583                 <span class="keywordflow">if</span> (!(lr-&gt;lr_flags &amp; LEF_RECHECK_NAME_HASH))
<a name="l04584"></a>04584                         ns-&gt;ln_striped_shards_repaired++;
<a name="l04585"></a>04585 
<a name="l04586"></a>04586                 rc = lfsck_namespace_trace_update(env, com, &amp;lr-&gt;lr_fid,
<a name="l04587"></a>04587                                                   LNTF_RECHECK_NAME_HASH, <span class="keyword">true</span>);
<a name="l04588"></a>04588 
<a name="l04589"></a>04589                 RETURN(rc &gt; 0 ? 0 : rc);
<a name="l04590"></a>04590         }
<a name="l04591"></a>04591         <span class="keywordflow">case</span> LE_PHASE1_DONE:
<a name="l04592"></a>04592         <span class="keywordflow">case</span> LE_PHASE2_DONE:
<a name="l04593"></a>04593         <span class="keywordflow">case</span> LE_PEER_EXIT:
<a name="l04594"></a>04594                 <span class="keywordflow">break</span>;
<a name="l04595"></a>04595         <span class="keywordflow">default</span>:
<a name="l04596"></a>04596                 RETURN(-EINVAL);
<a name="l04597"></a>04597         }
<a name="l04598"></a>04598 
<a name="l04599"></a>04599         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK handles notify %u from MDT %x, &quot;</span>
<a name="l04600"></a>04600                <span class="stringliteral">&quot;status %d, flags %x\n&quot;</span>, lfsck_lfsck2name(lfsck), lr-&gt;lr_event,
<a name="l04601"></a>04601                lr-&gt;lr_index, lr-&gt;lr_status, lr-&gt;lr_flags2);
<a name="l04602"></a>04602 
<a name="l04603"></a>04603         spin_lock(&amp;ltds-&gt;ltd_lock);
<a name="l04604"></a>04604         ltd = lfsck_ltd2tgt(ltds, lr-&gt;lr_index);
<a name="l04605"></a>04605         <span class="keywordflow">if</span> (ltd == NULL) {
<a name="l04606"></a>04606                 spin_unlock(&amp;ltds-&gt;ltd_lock);
<a name="l04607"></a>04607 
<a name="l04608"></a>04608                 RETURN(-ENXIO);
<a name="l04609"></a>04609         }
<a name="l04610"></a>04610 
<a name="l04611"></a>04611         list_del_init(&amp;ltd-&gt;ltd_namespace_phase_list);
<a name="l04612"></a>04612         <span class="keywordflow">switch</span> (lr-&gt;lr_event) {
<a name="l04613"></a>04613         <span class="keywordflow">case</span> LE_PHASE1_DONE:
<a name="l04614"></a>04614                 <span class="keywordflow">if</span> (lr-&gt;lr_status &lt;= 0) {
<a name="l04615"></a>04615                         ltd-&gt;ltd_namespace_done = 1;
<a name="l04616"></a>04616                         list_del_init(&amp;ltd-&gt;ltd_namespace_list);
<a name="l04617"></a>04617                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: MDT %x failed/stopped at &quot;</span>
<a name="l04618"></a>04618                                <span class="stringliteral">&quot;phase1 for namespace LFSCK: rc = %d.\n&quot;</span>,
<a name="l04619"></a>04619                                lfsck_lfsck2name(lfsck),
<a name="l04620"></a>04620                                ltd-&gt;ltd_index, lr-&gt;lr_status);
<a name="l04621"></a>04621                         ns-&gt;ln_flags |= LF_INCOMPLETE;
<a name="l04622"></a>04622                         fail = <span class="keyword">true</span>;
<a name="l04623"></a>04623                         <span class="keywordflow">break</span>;
<a name="l04624"></a>04624                 }
<a name="l04625"></a>04625 
<a name="l04626"></a>04626                 <span class="keywordflow">if</span> (lr-&gt;lr_flags2 &amp; LF_INCOMPLETE)
<a name="l04627"></a>04627                         ns-&gt;ln_flags |= LF_INCOMPLETE;
<a name="l04628"></a>04628 
<a name="l04629"></a>04629                 <span class="keywordflow">if</span> (list_empty(&amp;ltd-&gt;ltd_namespace_list))
<a name="l04630"></a>04630                         list_add_tail(&amp;ltd-&gt;ltd_namespace_list,
<a name="l04631"></a>04631                                       &amp;lad-&gt;lad_mdt_list);
<a name="l04632"></a>04632                 list_add_tail(&amp;ltd-&gt;ltd_namespace_phase_list,
<a name="l04633"></a>04633                               &amp;lad-&gt;lad_mdt_phase2_list);
<a name="l04634"></a>04634                 <span class="keywordflow">break</span>;
<a name="l04635"></a>04635         <span class="keywordflow">case</span> LE_PHASE2_DONE:
<a name="l04636"></a>04636                 ltd-&gt;ltd_namespace_done = 1;
<a name="l04637"></a>04637                 list_del_init(&amp;ltd-&gt;ltd_namespace_list);
<a name="l04638"></a>04638                 <span class="keywordflow">break</span>;
<a name="l04639"></a>04639         <span class="keywordflow">case</span> LE_PEER_EXIT:
<a name="l04640"></a>04640                 fail = <span class="keyword">true</span>;
<a name="l04641"></a>04641                 ltd-&gt;ltd_namespace_done = 1;
<a name="l04642"></a>04642                 list_del_init(&amp;ltd-&gt;ltd_namespace_list);
<a name="l04643"></a>04643                 <span class="keywordflow">if</span> (!(lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_FAILOUT)) {
<a name="l04644"></a>04644                         CDEBUG(D_LFSCK,
<a name="l04645"></a>04645                                <span class="stringliteral">&quot;%s: the peer MDT %x exit namespace LFSCK\n&quot;</span>,
<a name="l04646"></a>04646                                lfsck_lfsck2name(lfsck), ltd-&gt;ltd_index);
<a name="l04647"></a>04647                         ns-&gt;ln_flags |= LF_INCOMPLETE;
<a name="l04648"></a>04648                 }
<a name="l04649"></a>04649                 <span class="keywordflow">break</span>;
<a name="l04650"></a>04650         <span class="keywordflow">default</span>:
<a name="l04651"></a>04651                 <span class="keywordflow">break</span>;
<a name="l04652"></a>04652         }
<a name="l04653"></a>04653         spin_unlock(&amp;ltds-&gt;ltd_lock);
<a name="l04654"></a>04654 
<a name="l04655"></a>04655         <span class="keywordflow">if</span> (fail &amp;&amp; lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_FAILOUT) {
<a name="l04656"></a>04656                 <span class="keyword">struct </span><a class="code" href="structlfsck__stop.html">lfsck_stop</a> *stop = &amp;lfsck_env_info(env)-&gt;lti_stop;
<a name="l04657"></a>04657 
<a name="l04658"></a>04658                 memset(stop, 0, <span class="keyword">sizeof</span>(*stop));
<a name="l04659"></a>04659                 stop-&gt;ls_status = lr-&gt;lr_status;
<a name="l04660"></a>04660                 stop-&gt;ls_flags = lr-&gt;lr_param &amp; ~LPF_BROADCAST;
<a name="l04661"></a>04661                 <a class="code" href="structlfsck__stop.html">lfsck_stop</a>(env, lfsck-&gt;li_bottom, stop);
<a name="l04662"></a>04662         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lfsck_phase2_next_ready(lad)) {
<a name="l04663"></a>04663                 wake_up_all(&amp;lad-&gt;lad_thread.t_ctl_waitq);
<a name="l04664"></a>04664         }
<a name="l04665"></a>04665 
<a name="l04666"></a>04666         RETURN(0);
<a name="l04667"></a>04667 }
<a name="l04668"></a>04668 
<a name="l04669"></a>04669 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_repaired(<span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns, __u64 *count)
<a name="l04670"></a>04670 {
<a name="l04671"></a>04671         *count += ns-&gt;ln_objs_nlink_repaired;
<a name="l04672"></a>04672         *count += ns-&gt;ln_dirent_repaired;
<a name="l04673"></a>04673         *count += ns-&gt;ln_linkea_repaired;
<a name="l04674"></a>04674         *count += ns-&gt;ln_mul_linked_repaired;
<a name="l04675"></a>04675         *count += ns-&gt;ln_unmatched_pairs_repaired;
<a name="l04676"></a>04676         *count += ns-&gt;ln_dangling_repaired;
<a name="l04677"></a>04677         *count += ns-&gt;ln_mul_ref_repaired;
<a name="l04678"></a>04678         *count += ns-&gt;ln_bad_type_repaired;
<a name="l04679"></a>04679         *count += ns-&gt;ln_lost_dirent_repaired;
<a name="l04680"></a>04680         *count += ns-&gt;ln_striped_dirs_disabled;
<a name="l04681"></a>04681         *count += ns-&gt;ln_striped_dirs_repaired;
<a name="l04682"></a>04682         *count += ns-&gt;ln_striped_shards_repaired;
<a name="l04683"></a>04683         *count += ns-&gt;ln_name_hash_repaired;
<a name="l04684"></a>04684         *count += ns-&gt;ln_local_lpf_moved;
<a name="l04685"></a>04685 }
<a name="l04686"></a>04686 
<a name="l04687"></a>04687 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_query_all(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04688"></a>04688                                      <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l04689"></a>04689                                      __u32 *mdts_count, __u64 *repaired)
<a name="l04690"></a>04690 {
<a name="l04691"></a>04691         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l04692"></a>04692         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__descs.html">lfsck_tgt_descs</a> *ltds = &amp;com-&gt;lc_lfsck-&gt;li_mdt_descs;
<a name="l04693"></a>04693         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a> *ltd;
<a name="l04694"></a>04694         <span class="keywordtype">int</span> idx;
<a name="l04695"></a>04695         <span class="keywordtype">int</span> rc;
<a name="l04696"></a>04696         ENTRY;
<a name="l04697"></a>04697 
<a name="l04698"></a>04698         rc = lfsck_query_all(env, com);
<a name="l04699"></a>04699         <span class="keywordflow">if</span> (rc != 0)
<a name="l04700"></a>04700                 RETURN(rc);
<a name="l04701"></a>04701 
<a name="l04702"></a>04702         down_read(&amp;ltds-&gt;ltd_rw_sem);
<a name="l04703"></a>04703         cfs_foreach_bit(ltds-&gt;ltd_tgts_bitmap, idx) {
<a name="l04704"></a>04704                 ltd = lfsck_ltd2tgt(ltds, idx);
<a name="l04705"></a>04705                 LASSERT(ltd != NULL);
<a name="l04706"></a>04706 
<a name="l04707"></a>04707                 mdts_count[ltd-&gt;ltd_namespace_status]++;
<a name="l04708"></a>04708                 *repaired += ltd-&gt;ltd_namespace_repaired;
<a name="l04709"></a>04709         }
<a name="l04710"></a>04710         up_read(&amp;ltds-&gt;ltd_rw_sem);
<a name="l04711"></a>04711 
<a name="l04712"></a>04712         down_read(&amp;com-&gt;lc_sem);
<a name="l04713"></a>04713         mdts_count[ns-&gt;ln_status]++;
<a name="l04714"></a>04714         lfsck_namespace_repaired(ns, repaired);
<a name="l04715"></a>04715         up_read(&amp;com-&gt;lc_sem);
<a name="l04716"></a>04716 
<a name="l04717"></a>04717         RETURN(0);
<a name="l04718"></a>04718 }
<a name="l04719"></a>04719 
<a name="l04720"></a>04720 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_query(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04721"></a>04721                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l04722"></a>04722                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__request.html">lfsck_request</a> *req,
<a name="l04723"></a>04723                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__reply.html">lfsck_reply</a> *rep,
<a name="l04724"></a>04724                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__query.html">lfsck_query</a> *que, <span class="keywordtype">int</span> idx)
<a name="l04725"></a>04725 {
<a name="l04726"></a>04726         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l04727"></a>04727         <span class="keywordtype">int</span> rc = 0;
<a name="l04728"></a>04728 
<a name="l04729"></a>04729         <span class="keywordflow">if</span> (que != NULL) {
<a name="l04730"></a>04730                 LASSERT(com-&gt;lc_lfsck-&gt;li_master);
<a name="l04731"></a>04731 
<a name="l04732"></a>04732                 rc = lfsck_namespace_query_all(env, com,
<a name="l04733"></a>04733                                                que-&gt;lu_mdts_count[idx],
<a name="l04734"></a>04734                                                &amp;que-&gt;lu_repaired[idx]);
<a name="l04735"></a>04735         } <span class="keywordflow">else</span> {
<a name="l04736"></a>04736                 down_read(&amp;com-&gt;lc_sem);
<a name="l04737"></a>04737                 rep-&gt;lr_status = ns-&gt;ln_status;
<a name="l04738"></a>04738                 <span class="keywordflow">if</span> (req-&gt;lr_flags &amp; LEF_QUERY_ALL)
<a name="l04739"></a>04739                         lfsck_namespace_repaired(ns, &amp;rep-&gt;lr_repaired);
<a name="l04740"></a>04740                 up_read(&amp;com-&gt;lc_sem);
<a name="l04741"></a>04741         }
<a name="l04742"></a>04742 
<a name="l04743"></a>04743         <span class="keywordflow">return</span> rc;
<a name="l04744"></a>04744 }
<a name="l04745"></a>04745 
<a name="l04746"></a>04746 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlfsck__operations.html">lfsck_operations</a> lfsck_namespace_ops = {
<a name="l04747"></a>04747         .lfsck_reset            = lfsck_namespace_reset,
<a name="l04748"></a>04748         .lfsck_fail             = lfsck_namespace_fail,
<a name="l04749"></a>04749         .lfsck_close_dir        = lfsck_namespace_close_dir,
<a name="l04750"></a>04750         .lfsck_open_dir         = lfsck_namespace_open_dir,
<a name="l04751"></a>04751         .lfsck_checkpoint       = lfsck_namespace_checkpoint,
<a name="l04752"></a>04752         .lfsck_prep             = lfsck_namespace_prep,
<a name="l04753"></a>04753         .lfsck_exec_oit         = lfsck_namespace_exec_oit,
<a name="l04754"></a>04754         .lfsck_exec_dir         = lfsck_namespace_exec_dir,
<a name="l04755"></a>04755         .lfsck_post             = lfsck_namespace_post,
<a name="l04756"></a>04756         .lfsck_dump             = lfsck_namespace_dump,
<a name="l04757"></a>04757         .lfsck_double_scan      = lfsck_namespace_double_scan,
<a name="l04758"></a>04758         .lfsck_data_release     = lfsck_namespace_data_release,
<a name="l04759"></a>04759         .lfsck_quit             = lfsck_namespace_quit,
<a name="l04760"></a>04760         .lfsck_in_notify        = lfsck_namespace_in_notify,
<a name="l04761"></a>04761         .lfsck_query            = lfsck_namespace_query,
<a name="l04762"></a>04762 };
<a name="l04763"></a>04763 
<a name="l04790"></a>04790 <span class="keywordtype">int</span> lfsck_namespace_repair_dangling(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04791"></a>04791                                     <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l04792"></a>04792                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *parent,
<a name="l04793"></a>04793                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child,
<a name="l04794"></a>04794                                     <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a> *lnr)
<a name="l04795"></a>04795 {
<a name="l04796"></a>04796         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l04797"></a>04797         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>                  *la     = &amp;info-&gt;lti_la;
<a name="l04798"></a>04798         <span class="keyword">struct </span><a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a>       *hint   = &amp;info-&gt;lti_hint;
<a name="l04799"></a>04799         <span class="keyword">struct </span><a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a>         *dof    = &amp;info-&gt;lti_dof;
<a name="l04800"></a>04800         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>            *rec    = &amp;info-&gt;lti_dt_rec;
<a name="l04801"></a>04801         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>            *lmv2   = &amp;info-&gt;lti_lmv2;
<a name="l04802"></a>04802         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>            *cname;
<a name="l04803"></a>04803         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *pfid   = lfsck_dto2fid(parent);
<a name="l04804"></a>04804         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>             *cfid   = lfsck_dto2fid(child);
<a name="l04805"></a>04805         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>               ldata  = { NULL };
<a name="l04806"></a>04806         <span class="keyword">struct </span><a class="code" href="structlfsck__lock__handle.html">lfsck_lock_handle</a>        *llh    = &amp;info-&gt;lti_llh;
<a name="l04807"></a>04807         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                    linkea_buf;
<a name="l04808"></a>04808         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>                    lmv_buf;
<a name="l04809"></a>04809         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l04810"></a>04810         <span class="keyword">struct </span><a class="code" href="structlfsck__bookmark.html">lfsck_bookmark</a>           *bk     = &amp;lfsck-&gt;li_bookmark_ram;
<a name="l04811"></a>04811         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck-&gt;li_next;
<a name="l04812"></a>04812         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l04813"></a>04813         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l04814"></a>04814         __u16                            type   = lnr-&gt;lnr_type;
<a name="l04815"></a>04815         <span class="keywordtype">bool</span>                             create;
<a name="l04816"></a>04816         ENTRY;
<a name="l04817"></a>04817 
<a name="l04818"></a>04818         cname = lfsck_name_get_const(env, lnr-&gt;lnr_name, lnr-&gt;lnr_namelen);
<a name="l04819"></a>04819         <span class="keywordflow">if</span> (bk-&gt;lb_param &amp; LPF_CREATE_MDTOBJ)
<a name="l04820"></a>04820                 create = <span class="keyword">true</span>;
<a name="l04821"></a>04821         <span class="keywordflow">else</span>
<a name="l04822"></a>04822                 create = <span class="keyword">false</span>;
<a name="l04823"></a>04823 
<a name="l04824"></a>04824         <span class="keywordflow">if</span> (!create || bk-&gt;lb_param &amp; LPF_DRYRUN)
<a name="l04825"></a>04825                 GOTO(log, rc = 0);
<a name="l04826"></a>04826 
<a name="l04827"></a>04827         <span class="comment">/* We may need to create the sub-objects of the @child via LOD,</span>
<a name="l04828"></a>04828 <span class="comment">         * so make the modification based on lfsck-&gt;li_next. */</span>
<a name="l04829"></a>04829 
<a name="l04830"></a>04830         parent = lfsck_object_locate(dev, parent);
<a name="l04831"></a>04831         <span class="keywordflow">if</span> (IS_ERR(parent))
<a name="l04832"></a>04832                 GOTO(log, rc = PTR_ERR(parent));
<a name="l04833"></a>04833 
<a name="l04834"></a>04834         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, parent)))
<a name="l04835"></a>04835                 GOTO(log, rc = -ENOTDIR);
<a name="l04836"></a>04836 
<a name="l04837"></a>04837         child = lfsck_object_locate(dev, child);
<a name="l04838"></a>04838         <span class="keywordflow">if</span> (IS_ERR(child))
<a name="l04839"></a>04839                 GOTO(log, rc = PTR_ERR(child));
<a name="l04840"></a>04840 
<a name="l04841"></a>04841         rc = linkea_data_new(&amp;ldata, &amp;info-&gt;lti_linkea_buf2);
<a name="l04842"></a>04842         <span class="keywordflow">if</span> (rc != 0)
<a name="l04843"></a>04843                 GOTO(log, rc);
<a name="l04844"></a>04844 
<a name="l04845"></a>04845         rc = linkea_add_buf(&amp;ldata, cname, pfid);
<a name="l04846"></a>04846         <span class="keywordflow">if</span> (rc != 0)
<a name="l04847"></a>04847                 GOTO(log, rc);
<a name="l04848"></a>04848 
<a name="l04849"></a>04849         rc = lfsck_lock(env, lfsck, parent, lnr-&gt;lnr_name, llh,
<a name="l04850"></a>04850                         MDS_INODELOCK_UPDATE, LCK_PR);
<a name="l04851"></a>04851         <span class="keywordflow">if</span> (rc != 0)
<a name="l04852"></a>04852                 GOTO(log, rc);
<a name="l04853"></a>04853 
<a name="l04854"></a>04854         rc = lfsck_namespace_check_exist(env, parent, child, lnr-&gt;lnr_name);
<a name="l04855"></a>04855         <span class="keywordflow">if</span> (rc != 0)
<a name="l04856"></a>04856                 GOTO(log, rc);
<a name="l04857"></a>04857 
<a name="l04858"></a>04858         <span class="comment">/* Set the ctime as zero, then others can know it is created for</span>
<a name="l04859"></a>04859 <span class="comment">         * repairing dangling name entry by LFSCK. And if the LFSCK made</span>
<a name="l04860"></a>04860 <span class="comment">         * wrong decision and the real MDT-object has been found later,</span>
<a name="l04861"></a>04861 <span class="comment">         * then the LFSCK has chance to fix the incosistency properly. */</span>
<a name="l04862"></a>04862         memset(la, 0, <span class="keyword">sizeof</span>(*la));
<a name="l04863"></a>04863         la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> = (type &amp; S_IFMT) | 0600;
<a name="l04864"></a>04864         la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_TYPE | LA_MODE | LA_UID | LA_GID |
<a name="l04865"></a>04865                         LA_ATIME | LA_MTIME | LA_CTIME;
<a name="l04866"></a>04866 
<a name="l04867"></a>04867         child-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#a00fed99bee94890d3e36719af00d5595" title="Prepare allocation hint for a new object.">do_ah_init</a>(env, hint, parent, child,
<a name="l04868"></a>04868                                  la-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> &amp; S_IFMT);
<a name="l04869"></a>04869 
<a name="l04870"></a>04870         memset(dof, 0, <span class="keyword">sizeof</span>(*dof));
<a name="l04871"></a>04871         dof-&gt;<a class="code" href="structdt__object__format.html#a7522bce1087145d78c749b182e10357c" title="type for dt object">dof_type</a> = dt_mode_to_dft(type);
<a name="l04872"></a>04872         <span class="comment">/* If the target is a regular file, then the LFSCK will only create</span>
<a name="l04873"></a>04873 <span class="comment">         * the MDT-object without stripes (dof-&gt;dof_reg.striped = 0). related</span>
<a name="l04874"></a>04874 <span class="comment">         * OST-objects will be created when write open. */</span>
<a name="l04875"></a>04875 
<a name="l04876"></a>04876         th = dt_trans_create(env, dev);
<a name="l04877"></a>04877         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l04878"></a>04878                 GOTO(log, rc = PTR_ERR(th));
<a name="l04879"></a>04879 
<a name="l04880"></a>04880         <span class="comment">/* 1a. create child. */</span>
<a name="l04881"></a>04881         rc = dt_declare_create(env, child, la, hint, dof, th);
<a name="l04882"></a>04882         <span class="keywordflow">if</span> (rc != 0)
<a name="l04883"></a>04883                 GOTO(stop, rc);
<a name="l04884"></a>04884 
<a name="l04885"></a>04885         <span class="keywordflow">if</span> (S_ISDIR(type)) {
<a name="l04886"></a>04886                 <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, child)))
<a name="l04887"></a>04887                         GOTO(stop, rc = -ENOTDIR);
<a name="l04888"></a>04888 
<a name="l04889"></a>04889                 <span class="comment">/* 2a. increase child nlink */</span>
<a name="l04890"></a>04890                 rc = dt_declare_ref_add(env, child, th);
<a name="l04891"></a>04891                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04892"></a>04892                         GOTO(stop, rc);
<a name="l04893"></a>04893 
<a name="l04894"></a>04894                 <span class="comment">/* 3a. insert dot into child dir */</span>
<a name="l04895"></a>04895                 rec-&gt;rec_type = S_IFDIR;
<a name="l04896"></a>04896                 rec-&gt;rec_fid = cfid;
<a name="l04897"></a>04897                 rc = dt_declare_insert(env, child,
<a name="l04898"></a>04898                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l04899"></a>04899                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dot, th);
<a name="l04900"></a>04900                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04901"></a>04901                         GOTO(stop, rc);
<a name="l04902"></a>04902 
<a name="l04903"></a>04903                 <span class="comment">/* 4a. insert dotdot into child dir */</span>
<a name="l04904"></a>04904                 rec-&gt;rec_fid = pfid;
<a name="l04905"></a>04905                 rc = dt_declare_insert(env, child,
<a name="l04906"></a>04906                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l04907"></a>04907                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th);
<a name="l04908"></a>04908                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04909"></a>04909                         GOTO(stop, rc);
<a name="l04910"></a>04910 
<a name="l04911"></a>04911                 <span class="comment">/* 5a. generate slave LMV EA. */</span>
<a name="l04912"></a>04912                 <span class="keywordflow">if</span> (lnr-&gt;lnr_lmv != NULL &amp;&amp; lnr-&gt;lnr_lmv-&gt;ll_lmv_master) {
<a name="l04913"></a>04913                         <span class="keywordtype">int</span> idx;
<a name="l04914"></a>04914 
<a name="l04915"></a>04915                         idx = lfsck_shard_name_to_index(env,
<a name="l04916"></a>04916                                         lnr-&gt;lnr_name, lnr-&gt;lnr_namelen,
<a name="l04917"></a>04917                                         type, cfid);
<a name="l04918"></a>04918                         <span class="keywordflow">if</span> (unlikely(idx &lt; 0))
<a name="l04919"></a>04919                                 GOTO(stop, rc = idx);
<a name="l04920"></a>04920 
<a name="l04921"></a>04921                         *lmv2 = lnr-&gt;lnr_lmv-&gt;ll_lmv;
<a name="l04922"></a>04922                         lmv2-&gt;lmv_magic = LMV_MAGIC_STRIPE;
<a name="l04923"></a>04923                         lmv2-&gt;lmv_master_mdt_index = idx;
<a name="l04924"></a>04924 
<a name="l04925"></a>04925                         lfsck_lmv_header_cpu_to_le(lmv2, lmv2);
<a name="l04926"></a>04926                         lfsck_buf_init(&amp;lmv_buf, lmv2, <span class="keyword">sizeof</span>(*lmv2));
<a name="l04927"></a>04927                         rc = dt_declare_xattr_set(env, child, &amp;lmv_buf,
<a name="l04928"></a>04928                                                   XATTR_NAME_LMV, 0, th);
<a name="l04929"></a>04929                         <span class="keywordflow">if</span> (rc != 0)
<a name="l04930"></a>04930                                 GOTO(stop, rc);
<a name="l04931"></a>04931                 }
<a name="l04932"></a>04932         }
<a name="l04933"></a>04933 
<a name="l04934"></a>04934         <span class="comment">/* 6a. insert linkEA for child */</span>
<a name="l04935"></a>04935         lfsck_buf_init(&amp;linkea_buf, ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l04936"></a>04936                        ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l04937"></a>04937         rc = dt_declare_xattr_set(env, child, &amp;linkea_buf,
<a name="l04938"></a>04938                                   XATTR_NAME_LINK, 0, th);
<a name="l04939"></a>04939         <span class="keywordflow">if</span> (rc != 0)
<a name="l04940"></a>04940                 GOTO(stop, rc);
<a name="l04941"></a>04941 
<a name="l04942"></a>04942         rc = dt_trans_start_local(env, dev, th);
<a name="l04943"></a>04943         <span class="keywordflow">if</span> (rc != 0)
<a name="l04944"></a>04944                 GOTO(stop, rc = (rc == -EEXIST ? 1 : rc));
<a name="l04945"></a>04945 
<a name="l04946"></a>04946         dt_write_lock(env, child, 0);
<a name="l04947"></a>04947         <span class="comment">/* 1b. create child */</span>
<a name="l04948"></a>04948         rc = dt_create(env, child, la, hint, dof, th);
<a name="l04949"></a>04949         <span class="keywordflow">if</span> (rc != 0)
<a name="l04950"></a>04950                 GOTO(unlock, rc = (rc == -EEXIST ? 1 : rc));
<a name="l04951"></a>04951 
<a name="l04952"></a>04952         <span class="keywordflow">if</span> (S_ISDIR(type)) {
<a name="l04953"></a>04953                 <span class="comment">/* 2b. increase child nlink */</span>
<a name="l04954"></a>04954                 rc = dt_ref_add(env, child, th);
<a name="l04955"></a>04955                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04956"></a>04956                         GOTO(unlock, rc);
<a name="l04957"></a>04957 
<a name="l04958"></a>04958                 <span class="comment">/* 3b. insert dot into child dir */</span>
<a name="l04959"></a>04959                 rec-&gt;rec_type = S_IFDIR;
<a name="l04960"></a>04960                 rec-&gt;rec_fid = cfid;
<a name="l04961"></a>04961                 rc = dt_insert(env, child, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l04962"></a>04962                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dot, th, 1);
<a name="l04963"></a>04963                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04964"></a>04964                         GOTO(unlock, rc);
<a name="l04965"></a>04965 
<a name="l04966"></a>04966                 <span class="comment">/* 4b. insert dotdot into child dir */</span>
<a name="l04967"></a>04967                 rec-&gt;rec_fid = pfid;
<a name="l04968"></a>04968                 rc = dt_insert(env, child, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l04969"></a>04969                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th, 1);
<a name="l04970"></a>04970                 <span class="keywordflow">if</span> (rc != 0)
<a name="l04971"></a>04971                         GOTO(unlock, rc);
<a name="l04972"></a>04972 
<a name="l04973"></a>04973                 <span class="comment">/* 5b. generate slave LMV EA. */</span>
<a name="l04974"></a>04974                 <span class="keywordflow">if</span> (lnr-&gt;lnr_lmv != NULL &amp;&amp; lnr-&gt;lnr_lmv-&gt;ll_lmv_master) {
<a name="l04975"></a>04975                         rc = dt_xattr_set(env, child, &amp;lmv_buf, XATTR_NAME_LMV,
<a name="l04976"></a>04976                                           0, th);
<a name="l04977"></a>04977                         <span class="keywordflow">if</span> (rc != 0)
<a name="l04978"></a>04978                                 GOTO(unlock, rc);
<a name="l04979"></a>04979                 }
<a name="l04980"></a>04980         }
<a name="l04981"></a>04981 
<a name="l04982"></a>04982         <span class="comment">/* 6b. insert linkEA for child. */</span>
<a name="l04983"></a>04983         rc = dt_xattr_set(env, child, &amp;linkea_buf,
<a name="l04984"></a>04984                           XATTR_NAME_LINK, 0, th);
<a name="l04985"></a>04985 
<a name="l04986"></a>04986         GOTO(unlock, rc);
<a name="l04987"></a>04987 
<a name="l04988"></a>04988 unlock:
<a name="l04989"></a>04989         dt_write_unlock(env, child);
<a name="l04990"></a>04990 
<a name="l04991"></a>04991 stop:
<a name="l04992"></a>04992         dt_trans_stop(env, dev, th);
<a name="l04993"></a>04993 
<a name="l04994"></a>04994 log:
<a name="l04995"></a>04995         lfsck_unlock(llh);
<a name="l04996"></a>04996         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK assistant found dangling &quot;</span>
<a name="l04997"></a>04997                <span class="stringliteral">&quot;reference for: parent &quot;</span>DFID<span class="stringliteral">&quot;, child &quot;</span>DFID<span class="stringliteral">&quot;, type %u, &quot;</span>
<a name="l04998"></a>04998                <span class="stringliteral">&quot;name %s. %s: rc = %d\n&quot;</span>, lfsck_lfsck2name(lfsck),
<a name="l04999"></a>04999                PFID(pfid), PFID(cfid), type, cname-&gt;ln_name,
<a name="l05000"></a>05000                create ? <span class="stringliteral">&quot;Create the lost MDT-object as required&quot;</span> :
<a name="l05001"></a>05001                         <span class="stringliteral">&quot;Keep the MDT-object there by default&quot;</span>, rc);
<a name="l05002"></a>05002 
<a name="l05003"></a>05003         <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l05004"></a>05004                 <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a> *ns = com-&gt;lc_file_ram;
<a name="l05005"></a>05005 
<a name="l05006"></a>05006                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l05007"></a>05007         }
<a name="l05008"></a>05008 
<a name="l05009"></a>05009         <span class="keywordflow">return</span> rc;
<a name="l05010"></a>05010 }
<a name="l05011"></a>05011 
<a name="l05012"></a>05012 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_assistant_handler_p1(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l05013"></a>05013                                                 <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l05014"></a>05014                                                 <span class="keyword">struct</span> <a class="code" href="structlfsck__assistant__req.html">lfsck_assistant_req</a> *lar)
<a name="l05015"></a>05015 {
<a name="l05016"></a>05016         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>   *info     = lfsck_env_info(env);
<a name="l05017"></a>05017         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>             *la       = &amp;info-&gt;lti_la;
<a name="l05018"></a>05018         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>      *lfsck    = com-&gt;lc_lfsck;
<a name="l05019"></a>05019         <span class="keyword">struct </span><a class="code" href="structlfsck__bookmark.html">lfsck_bookmark</a>      *bk       = &amp;lfsck-&gt;li_bookmark_ram;
<a name="l05020"></a>05020         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>     *ns       = com-&gt;lc_file_ram;
<a name="l05021"></a>05021         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a> *lad     = com-&gt;lc_data;
<a name="l05022"></a>05022         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>          ldata    = { NULL };
<a name="l05023"></a>05023         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>       *cname;
<a name="l05024"></a>05024         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>             *handle   = NULL;
<a name="l05025"></a>05025         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a> *lnr      =
<a name="l05026"></a>05026                         container_of0(lar, <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a>, lnr_lar);
<a name="l05027"></a>05027         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>           *dir      = NULL;
<a name="l05028"></a>05028         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>           *obj      = NULL;
<a name="l05029"></a>05029         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__object.html">lfsck_assistant_object</a> *lso   = lar-&gt;lar_parent;
<a name="l05030"></a>05030         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>        *pfid     = &amp;lso-&gt;lso_fid;
<a name="l05031"></a>05031         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>           *dev      = NULL;
<a name="l05032"></a>05032         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>        lh       = { 0 };
<a name="l05033"></a>05033         <span class="keywordtype">bool</span>                        repaired = <span class="keyword">false</span>;
<a name="l05034"></a>05034         <span class="keywordtype">bool</span>                        dtlocked = <span class="keyword">false</span>;
<a name="l05035"></a>05035         <span class="keywordtype">bool</span>                        <span class="keyword">remove</span>;
<a name="l05036"></a>05036         <span class="keywordtype">bool</span>                        newdata;
<a name="l05037"></a>05037         <span class="keywordtype">bool</span>                        log      = <span class="keyword">false</span>;
<a name="l05038"></a>05038         <span class="keywordtype">bool</span>                        bad_hash = <span class="keyword">false</span>;
<a name="l05039"></a>05039         <span class="keywordtype">bool</span>                        bad_linkea = <span class="keyword">false</span>;
<a name="l05040"></a>05040         <span class="keywordtype">int</span>                         idx      = 0;
<a name="l05041"></a>05041         <span class="keywordtype">int</span>                         count    = 0;
<a name="l05042"></a>05042         <span class="keywordtype">int</span>                         rc       = 0;
<a name="l05043"></a>05043         <span class="keyword">enum</span> lfsck_namespace_inconsistency_type type = LNIT_NONE;
<a name="l05044"></a>05044         ENTRY;
<a name="l05045"></a>05045 
<a name="l05046"></a>05046         <span class="keywordflow">if</span> (lso-&gt;lso_dead)
<a name="l05047"></a>05047                 RETURN(0);
<a name="l05048"></a>05048 
<a name="l05049"></a>05049         la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> = 0;
<a name="l05050"></a>05050         <span class="keywordflow">if</span> (lnr-&gt;lnr_attr &amp; LUDA_UPGRADE) {
<a name="l05051"></a>05051                 ns-&gt;ln_flags |= LF_UPGRADE;
<a name="l05052"></a>05052                 ns-&gt;ln_dirent_repaired++;
<a name="l05053"></a>05053                 repaired = <span class="keyword">true</span>;
<a name="l05054"></a>05054         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lnr-&gt;lnr_attr &amp; LUDA_REPAIR) {
<a name="l05055"></a>05055                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l05056"></a>05056                 ns-&gt;ln_dirent_repaired++;
<a name="l05057"></a>05057                 repaired = <span class="keyword">true</span>;
<a name="l05058"></a>05058         }
<a name="l05059"></a>05059 
<a name="l05060"></a>05060         <span class="keywordflow">if</span> (unlikely(fid_is_zero(&amp;lnr-&gt;lnr_fid))) {
<a name="l05061"></a>05061                 <span class="keywordflow">if</span> (strcmp(lnr-&gt;lnr_name, dotdot) != 0)
<a name="l05062"></a>05062                         LBUG();
<a name="l05063"></a>05063                 <span class="keywordflow">else</span>
<a name="l05064"></a>05064                         rc = lfsck_namespace_trace_update(env, com, pfid,
<a name="l05065"></a>05065                                                 LNTF_CHECK_PARENT, <span class="keyword">true</span>);
<a name="l05066"></a>05066 
<a name="l05067"></a>05067                 GOTO(out, rc);
<a name="l05068"></a>05068         }
<a name="l05069"></a>05069 
<a name="l05070"></a>05070         <span class="keywordflow">if</span> (unlikely(!fid_is_sane(&amp;lnr-&gt;lnr_fid))) {
<a name="l05071"></a>05071                 CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: dir scan find invalid FID &quot;</span>DFID
<a name="l05072"></a>05072                        <span class="stringliteral">&quot; for the name entry %.*s under &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l05073"></a>05073                        lfsck_lfsck2name(lfsck), PFID(&amp;lnr-&gt;lnr_fid),
<a name="l05074"></a>05074                        lnr-&gt;lnr_namelen, lnr-&gt;lnr_name, PFID(pfid));
<a name="l05075"></a>05075 
<a name="l05076"></a>05076                 <span class="keywordflow">if</span> (strcmp(lnr-&gt;lnr_name, dotdot) != 0)
<a name="l05077"></a>05077                         <span class="comment">/* invalid FID means bad name entry, remove it. */</span>
<a name="l05078"></a>05078                         type = LNIT_BAD_DIRENT;
<a name="l05079"></a>05079                 <span class="keywordflow">else</span>
<a name="l05080"></a>05080                         <span class="comment">/* If the parent FID is invalid, we cannot remove</span>
<a name="l05081"></a>05081 <span class="comment">                         * the &quot;..&quot; entry directly. */</span>
<a name="l05082"></a>05082                         rc = lfsck_namespace_trace_update(env, com, pfid,
<a name="l05083"></a>05083                                                 LNTF_CHECK_PARENT, <span class="keyword">true</span>);
<a name="l05084"></a>05084 
<a name="l05085"></a>05085                 GOTO(out, rc);
<a name="l05086"></a>05086         }
<a name="l05087"></a>05087 
<a name="l05088"></a>05088         <span class="keywordflow">if</span> (unlikely(lnr-&gt;lnr_dir_cookie == MDS_DIR_END_OFF)) {
<a name="l05089"></a>05089                 rc = lfsck_namespace_striped_dir_rescan(env, com, lnr);
<a name="l05090"></a>05090 
<a name="l05091"></a>05091                 RETURN(rc);
<a name="l05092"></a>05092         }
<a name="l05093"></a>05093 
<a name="l05094"></a>05094         <span class="keywordflow">if</span> (fid_seq_is_dot(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(&amp;lnr-&gt;lnr_fid)))
<a name="l05095"></a>05095                 GOTO(out, rc = 0);
<a name="l05096"></a>05096 
<a name="l05097"></a>05097         <span class="keywordflow">if</span> (lnr-&gt;lnr_lmv != NULL &amp;&amp; lnr-&gt;lnr_lmv-&gt;ll_lmv_master) {
<a name="l05098"></a>05098                 rc = lfsck_namespace_handle_striped_master(env, com, lnr);
<a name="l05099"></a>05099 
<a name="l05100"></a>05100                 RETURN(rc);
<a name="l05101"></a>05101         }
<a name="l05102"></a>05102 
<a name="l05103"></a>05103         idx = lfsck_find_mdt_idx_by_fid(env, lfsck, &amp;lnr-&gt;lnr_fid);
<a name="l05104"></a>05104         <span class="keywordflow">if</span> (idx &lt; 0)
<a name="l05105"></a>05105                 GOTO(out, rc = idx);
<a name="l05106"></a>05106 
<a name="l05107"></a>05107         <span class="keywordflow">if</span> (idx == lfsck_dev_idx(lfsck)) {
<a name="l05108"></a>05108                 <span class="keywordflow">if</span> (unlikely(strcmp(lnr-&gt;lnr_name, dotdot) == 0))
<a name="l05109"></a>05109                         GOTO(out, rc = 0);
<a name="l05110"></a>05110 
<a name="l05111"></a>05111                 dev = lfsck-&gt;li_bottom;
<a name="l05112"></a>05112         } <span class="keywordflow">else</span> {
<a name="l05113"></a>05113                 <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a> *ltd;
<a name="l05114"></a>05114 
<a name="l05115"></a>05115                 <span class="comment">/* Usually, some local filesystem consistency verification</span>
<a name="l05116"></a>05116 <span class="comment">                 * tools can guarantee the local namespace tree consistenct.</span>
<a name="l05117"></a>05117 <span class="comment">                 * So the LFSCK will only verify the remote directory. */</span>
<a name="l05118"></a>05118                 <span class="keywordflow">if</span> (unlikely(strcmp(lnr-&gt;lnr_name, dotdot) == 0)) {
<a name="l05119"></a>05119                         rc = lfsck_namespace_trace_update(env, com, pfid,
<a name="l05120"></a>05120                                                 LNTF_CHECK_PARENT, <span class="keyword">true</span>);
<a name="l05121"></a>05121 
<a name="l05122"></a>05122                         GOTO(out, rc);
<a name="l05123"></a>05123                 }
<a name="l05124"></a>05124 
<a name="l05125"></a>05125                 ltd = lfsck_ltd2tgt(&amp;lfsck-&gt;li_mdt_descs, idx);
<a name="l05126"></a>05126                 <span class="keywordflow">if</span> (unlikely(ltd == NULL)) {
<a name="l05127"></a>05127                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: cannot talk with MDT %x which &quot;</span>
<a name="l05128"></a>05128                                <span class="stringliteral">&quot;did not join the namespace LFSCK\n&quot;</span>,
<a name="l05129"></a>05129                                lfsck_lfsck2name(lfsck), idx);
<a name="l05130"></a>05130                         lfsck_lad_set_bitmap(env, com, idx);
<a name="l05131"></a>05131 
<a name="l05132"></a>05132                         GOTO(out, rc = -ENODEV);
<a name="l05133"></a>05133                 }
<a name="l05134"></a>05134 
<a name="l05135"></a>05135                 dev = ltd-&gt;ltd_tgt;
<a name="l05136"></a>05136         }
<a name="l05137"></a>05137 
<a name="l05138"></a>05138         obj = lfsck_object_find_by_dev(env, dev, &amp;lnr-&gt;lnr_fid);
<a name="l05139"></a>05139         <span class="keywordflow">if</span> (IS_ERR(obj))
<a name="l05140"></a>05140                 GOTO(out, rc = PTR_ERR(obj));
<a name="l05141"></a>05141 
<a name="l05142"></a>05142         cname = lfsck_name_get_const(env, lnr-&gt;lnr_name, lnr-&gt;lnr_namelen);
<a name="l05143"></a>05143         <span class="keywordflow">if</span> (dt_object_exists(obj) == 0) {
<a name="l05144"></a>05144 
<a name="l05145"></a>05145 dangling:
<a name="l05146"></a>05146                 <span class="keywordflow">if</span> (dir == NULL) {
<a name="l05147"></a>05147                         dir = lfsck_assistant_object_load(env, lfsck, lso);
<a name="l05148"></a>05148                         <span class="keywordflow">if</span> (IS_ERR(dir)) {
<a name="l05149"></a>05149                                 rc = PTR_ERR(dir);
<a name="l05150"></a>05150 
<a name="l05151"></a>05151                                 GOTO(trace, rc == -ENOENT ? 0 : rc);
<a name="l05152"></a>05152                         }
<a name="l05153"></a>05153                 }
<a name="l05154"></a>05154 
<a name="l05155"></a>05155                 rc = lfsck_namespace_check_exist(env, dir, obj, lnr-&gt;lnr_name);
<a name="l05156"></a>05156                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l05157"></a>05157                         <span class="keywordflow">if</span> (!lfsck_is_valid_slave_name_entry(env, lnr-&gt;lnr_lmv,
<a name="l05158"></a>05158                                         lnr-&gt;lnr_name, lnr-&gt;lnr_namelen)) {
<a name="l05159"></a>05159                                 type = LNIT_BAD_DIRENT;
<a name="l05160"></a>05160 
<a name="l05161"></a>05161                                 GOTO(out, rc);
<a name="l05162"></a>05162                         }
<a name="l05163"></a>05163 
<a name="l05164"></a>05164                         type = LNIT_DANGLING;
<a name="l05165"></a>05165                         rc = lfsck_namespace_repair_dangling(env, com, dir,
<a name="l05166"></a>05166                                                              obj, lnr);
<a name="l05167"></a>05167                         <span class="keywordflow">if</span> (rc == 0)
<a name="l05168"></a>05168                                 repaired = <span class="keyword">true</span>;
<a name="l05169"></a>05169                 }
<a name="l05170"></a>05170 
<a name="l05171"></a>05171                 GOTO(out, rc);
<a name="l05172"></a>05172         }
<a name="l05173"></a>05173 
<a name="l05174"></a>05174         <span class="keywordflow">if</span> (!(bk-&gt;lb_param &amp; LPF_DRYRUN) &amp;&amp; lad-&gt;lad_advance_lock) {
<a name="l05175"></a>05175 
<a name="l05176"></a>05176 again:
<a name="l05177"></a>05177                 rc = lfsck_ibits_lock(env, lfsck, obj, &amp;lh,
<a name="l05178"></a>05178                                       MDS_INODELOCK_UPDATE |
<a name="l05179"></a>05179                                       MDS_INODELOCK_XATTR, LCK_EX);
<a name="l05180"></a>05180                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05181"></a>05181                         GOTO(out, rc);
<a name="l05182"></a>05182 
<a name="l05183"></a>05183                 handle = dt_trans_create(env, dev);
<a name="l05184"></a>05184                 <span class="keywordflow">if</span> (IS_ERR(handle))
<a name="l05185"></a>05185                         GOTO(out, rc = PTR_ERR(handle));
<a name="l05186"></a>05186 
<a name="l05187"></a>05187                 rc = lfsck_declare_namespace_exec_dir(env, obj, handle);
<a name="l05188"></a>05188                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05189"></a>05189                         GOTO(stop, rc);
<a name="l05190"></a>05190 
<a name="l05191"></a>05191                 rc = dt_trans_start_local(env, dev, handle);
<a name="l05192"></a>05192                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05193"></a>05193                         GOTO(stop, rc);
<a name="l05194"></a>05194 
<a name="l05195"></a>05195                 dt_write_lock(env, obj, 0);
<a name="l05196"></a>05196                 dtlocked = <span class="keyword">true</span>;
<a name="l05197"></a>05197         }
<a name="l05198"></a>05198 
<a name="l05199"></a>05199         rc = lfsck_links_read(env, obj, &amp;ldata);
<a name="l05200"></a>05200         <span class="keywordflow">if</span> (unlikely(rc == -ENOENT)) {
<a name="l05201"></a>05201                 <span class="keywordflow">if</span> (handle != NULL) {
<a name="l05202"></a>05202                         dt_write_unlock(env, obj);
<a name="l05203"></a>05203                         dtlocked = <span class="keyword">false</span>;
<a name="l05204"></a>05204 
<a name="l05205"></a>05205                         dt_trans_stop(env, dev, handle);
<a name="l05206"></a>05206                         handle = NULL;
<a name="l05207"></a>05207 
<a name="l05208"></a>05208                         lfsck_ibits_unlock(&amp;lh, LCK_EX);
<a name="l05209"></a>05209                 }
<a name="l05210"></a>05210 
<a name="l05211"></a>05211                 <span class="comment">/* It may happen when the remote object has been removed,</span>
<a name="l05212"></a>05212 <span class="comment">                 * but the local MDT is not aware of that. */</span>
<a name="l05213"></a>05213                 <span class="keywordflow">goto</span> dangling;
<a name="l05214"></a>05214         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 0) {
<a name="l05215"></a>05215                 count = ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount;
<a name="l05216"></a>05216                 rc = linkea_links_find(&amp;ldata, cname, pfid);
<a name="l05217"></a>05217                 <span class="keywordflow">if</span> ((rc == 0) &amp;&amp;
<a name="l05218"></a>05218                     (count == 1 || !S_ISDIR(lfsck_object_type(obj)))) {
<a name="l05219"></a>05219                         <span class="keywordflow">if</span> ((lfsck_object_type(obj) &amp; S_IFMT) !=
<a name="l05220"></a>05220                             lnr-&gt;lnr_type) {
<a name="l05221"></a>05221                                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l05222"></a>05222                                 type = LNIT_BAD_TYPE;
<a name="l05223"></a>05223                         }
<a name="l05224"></a>05224 
<a name="l05225"></a>05225                         <span class="keywordflow">goto</span> stop;
<a name="l05226"></a>05226                 }
<a name="l05227"></a>05227 
<a name="l05228"></a>05228                 <span class="comment">/* If the name entry hash does not match the slave striped</span>
<a name="l05229"></a>05229 <span class="comment">                 * directory, and the name entry does not match also, then</span>
<a name="l05230"></a>05230 <span class="comment">                 * it is quite possible that name entry is corrupted. */</span>
<a name="l05231"></a>05231                 <span class="keywordflow">if</span> (!lfsck_is_valid_slave_name_entry(env, lnr-&gt;lnr_lmv,
<a name="l05232"></a>05232                                         lnr-&gt;lnr_name, lnr-&gt;lnr_namelen)) {
<a name="l05233"></a>05233                         ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l05234"></a>05234                         type = LNIT_BAD_DIRENT;
<a name="l05235"></a>05235 
<a name="l05236"></a>05236                         GOTO(stop, rc = 0);
<a name="l05237"></a>05237                 }
<a name="l05238"></a>05238 
<a name="l05239"></a>05239                 <span class="comment">/* If the file type stored in the name entry does not match</span>
<a name="l05240"></a>05240 <span class="comment">                 * the file type claimed by the object, and the object does</span>
<a name="l05241"></a>05241 <span class="comment">                 * not recognize the name entry, then it is quite possible</span>
<a name="l05242"></a>05242 <span class="comment">                 * that the name entry is corrupted. */</span>
<a name="l05243"></a>05243                 <span class="keywordflow">if</span> ((lfsck_object_type(obj) &amp; S_IFMT) != lnr-&gt;lnr_type) {
<a name="l05244"></a>05244                         ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l05245"></a>05245                         type = LNIT_BAD_DIRENT;
<a name="l05246"></a>05246 
<a name="l05247"></a>05247                         GOTO(stop, rc = 0);
<a name="l05248"></a>05248                 }
<a name="l05249"></a>05249 
<a name="l05250"></a>05250                 <span class="comment">/* For sub-dir object, we cannot make sure whether the sub-dir</span>
<a name="l05251"></a>05251 <span class="comment">                 * back references the parent via &quot;..&quot; name entry correctly or</span>
<a name="l05252"></a>05252 <span class="comment">                 * not in the LFSCK first-stage scanning. It may be that the</span>
<a name="l05253"></a>05253 <span class="comment">                 * (remote) sub-dir &quot;..&quot; name entry has no parent FID after</span>
<a name="l05254"></a>05254 <span class="comment">                 * file-level backup/restore and its linkEA may be wrong.</span>
<a name="l05255"></a>05255 <span class="comment">                 * So under such case, we should replace the linkEA according</span>
<a name="l05256"></a>05256 <span class="comment">                 * to current name entry. But this needs to be done during the</span>
<a name="l05257"></a>05257 <span class="comment">                 * LFSCK second-stage scanning. The LFSCK will record the name</span>
<a name="l05258"></a>05258 <span class="comment">                 * entry for further possible using. */</span>
<a name="l05259"></a>05259                 <span class="keyword">remove</span> = <span class="keyword">false</span>;
<a name="l05260"></a>05260                 newdata = <span class="keyword">false</span>;
<a name="l05261"></a>05261                 <span class="keywordflow">goto</span> nodata;
<a name="l05262"></a>05262         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (unlikely(rc == -EINVAL)) {
<a name="l05263"></a>05263                 <span class="keywordflow">if</span> ((lfsck_object_type(obj) &amp; S_IFMT) != lnr-&gt;lnr_type)
<a name="l05264"></a>05264                         type = LNIT_BAD_TYPE;
<a name="l05265"></a>05265 
<a name="l05266"></a>05266                 count = 1;
<a name="l05267"></a>05267                 <span class="comment">/* The magic crashed, we are not sure whether there are more</span>
<a name="l05268"></a>05268 <span class="comment">                 * corrupt data in the linkea, so remove all linkea entries. */</span>
<a name="l05269"></a>05269                 <span class="keyword">remove</span> = <span class="keyword">true</span>;
<a name="l05270"></a>05270                 newdata = <span class="keyword">true</span>;
<a name="l05271"></a>05271                 <span class="keywordflow">goto</span> nodata;
<a name="l05272"></a>05272         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == -ENODATA) {
<a name="l05273"></a>05273                 <span class="keywordflow">if</span> ((lfsck_object_type(obj) &amp; S_IFMT) != lnr-&gt;lnr_type)
<a name="l05274"></a>05274                         type = LNIT_BAD_TYPE;
<a name="l05275"></a>05275 
<a name="l05276"></a>05276                 count = 1;
<a name="l05277"></a>05277                 <span class="keyword">remove</span> = <span class="keyword">false</span>;
<a name="l05278"></a>05278                 newdata = <span class="keyword">true</span>;
<a name="l05279"></a>05279 
<a name="l05280"></a>05280 nodata:
<a name="l05281"></a>05281                 <span class="keywordflow">if</span> (bk-&gt;lb_param &amp; LPF_DRYRUN) {
<a name="l05282"></a>05282                         <span class="keywordflow">if</span> (rc == -ENODATA)
<a name="l05283"></a>05283                                 ns-&gt;ln_flags |= LF_UPGRADE;
<a name="l05284"></a>05284                         <span class="keywordflow">else</span>
<a name="l05285"></a>05285                                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l05286"></a>05286                         ns-&gt;ln_linkea_repaired++;
<a name="l05287"></a>05287                         repaired = <span class="keyword">true</span>;
<a name="l05288"></a>05288                         log = <span class="keyword">true</span>;
<a name="l05289"></a>05289                         <span class="keywordflow">goto</span> stop;
<a name="l05290"></a>05290                 }
<a name="l05291"></a>05291 
<a name="l05292"></a>05292                 <span class="keywordflow">if</span> (!lustre_handle_is_used(&amp;lh)) {
<a name="l05293"></a>05293                         <span class="keyword">remove</span> = <span class="keyword">false</span>;
<a name="l05294"></a>05294                         newdata = <span class="keyword">false</span>;
<a name="l05295"></a>05295                         type = LNIT_NONE;
<a name="l05296"></a>05296 
<a name="l05297"></a>05297                         <span class="keywordflow">goto</span> again;
<a name="l05298"></a>05298                 }
<a name="l05299"></a>05299 
<a name="l05300"></a>05300                 <span class="keywordflow">if</span> (dir == NULL) {
<a name="l05301"></a>05301                         dir = lfsck_assistant_object_load(env, lfsck, lso);
<a name="l05302"></a>05302                         <span class="keywordflow">if</span> (IS_ERR(dir)) {
<a name="l05303"></a>05303                                 rc = PTR_ERR(dir);
<a name="l05304"></a>05304 
<a name="l05305"></a>05305                                 GOTO(stop, rc == -ENOENT ? 0 : rc);
<a name="l05306"></a>05306                         }
<a name="l05307"></a>05307                 }
<a name="l05308"></a>05308 
<a name="l05309"></a>05309                 rc = lfsck_namespace_check_exist(env, dir, obj, lnr-&gt;lnr_name);
<a name="l05310"></a>05310                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05311"></a>05311                         GOTO(stop, rc);
<a name="l05312"></a>05312 
<a name="l05313"></a>05313                 bad_linkea = <span class="keyword">true</span>;
<a name="l05314"></a>05314                 <span class="keywordflow">if</span> (!<span class="keyword">remove</span> &amp;&amp; newdata)
<a name="l05315"></a>05315                         ns-&gt;ln_flags |= LF_UPGRADE;
<a name="l05316"></a>05316                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">remove</span> || !(ns-&gt;ln_flags &amp; LF_UPGRADE))
<a name="l05317"></a>05317                         ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l05318"></a>05318 
<a name="l05319"></a>05319                 <span class="keywordflow">if</span> (<span class="keyword">remove</span>) {
<a name="l05320"></a>05320                         LASSERT(newdata);
<a name="l05321"></a>05321 
<a name="l05322"></a>05322                         rc = dt_xattr_del(env, obj, XATTR_NAME_LINK, handle);
<a name="l05323"></a>05323                         <span class="keywordflow">if</span> (rc != 0)
<a name="l05324"></a>05324                                 GOTO(stop, rc);
<a name="l05325"></a>05325                 }
<a name="l05326"></a>05326 
<a name="l05327"></a>05327                 <span class="keywordflow">if</span> (newdata) {
<a name="l05328"></a>05328                         rc = linkea_data_new(&amp;ldata,
<a name="l05329"></a>05329                                         &amp;lfsck_env_info(env)-&gt;lti_linkea_buf);
<a name="l05330"></a>05330                         <span class="keywordflow">if</span> (rc != 0)
<a name="l05331"></a>05331                                 GOTO(stop, rc);
<a name="l05332"></a>05332                 }
<a name="l05333"></a>05333 
<a name="l05334"></a>05334                 rc = linkea_add_buf(&amp;ldata, cname, pfid);
<a name="l05335"></a>05335                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05336"></a>05336                         GOTO(stop, rc);
<a name="l05337"></a>05337 
<a name="l05338"></a>05338                 rc = lfsck_links_write(env, obj, &amp;ldata, handle);
<a name="l05339"></a>05339                 <span class="keywordflow">if</span> (unlikely(rc == -ENOSPC) &amp;&amp;
<a name="l05340"></a>05340                     S_ISREG(lfsck_object_type(obj)) &amp;&amp; !dt_object_remote(obj)) {
<a name="l05341"></a>05341                         <span class="keywordflow">if</span> (handle != NULL) {
<a name="l05342"></a>05342                                 LASSERT(dt_write_locked(env, obj));
<a name="l05343"></a>05343 
<a name="l05344"></a>05344                                 dt_write_unlock(env, obj);
<a name="l05345"></a>05345                                 dtlocked = <span class="keyword">false</span>;
<a name="l05346"></a>05346 
<a name="l05347"></a>05347                                 dt_trans_stop(env, dev, handle);
<a name="l05348"></a>05348                                 handle = NULL;
<a name="l05349"></a>05349 
<a name="l05350"></a>05350                                 lfsck_ibits_unlock(&amp;lh, LCK_EX);
<a name="l05351"></a>05351                         }
<a name="l05352"></a>05352 
<a name="l05353"></a>05353                         rc = lfsck_namespace_trace_update(env, com,
<a name="l05354"></a>05354                                         &amp;lnr-&gt;lnr_fid, LNTF_SKIP_NLINK, <span class="keyword">true</span>);
<a name="l05355"></a>05355                         <span class="keywordflow">if</span> (rc != 0)
<a name="l05356"></a>05356                                 <span class="comment">/* If we cannot record this object in the</span>
<a name="l05357"></a>05357 <span class="comment">                                 * LFSCK tracing, we have to mark the LFSCK</span>
<a name="l05358"></a>05358 <span class="comment">                                 * as LF_INCOMPLETE, then the LFSCK will</span>
<a name="l05359"></a>05359 <span class="comment">                                 * skip nlink attribute verification for</span>
<a name="l05360"></a>05360 <span class="comment">                                 * all objects. */</span>
<a name="l05361"></a>05361                                 ns-&gt;ln_flags |= LF_INCOMPLETE;
<a name="l05362"></a>05362 
<a name="l05363"></a>05363                         GOTO(out, rc = 0);
<a name="l05364"></a>05364                 }
<a name="l05365"></a>05365 
<a name="l05366"></a>05366                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05367"></a>05367                         GOTO(stop, rc);
<a name="l05368"></a>05368 
<a name="l05369"></a>05369                 count = ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount;
<a name="l05370"></a>05370                 <span class="keywordflow">if</span> (!S_ISDIR(lfsck_object_type(obj)) ||
<a name="l05371"></a>05371                     !dt_object_remote(obj)) {
<a name="l05372"></a>05372                         ns-&gt;ln_linkea_repaired++;
<a name="l05373"></a>05373                         repaired = <span class="keyword">true</span>;
<a name="l05374"></a>05374                         log = <span class="keyword">true</span>;
<a name="l05375"></a>05375                 }
<a name="l05376"></a>05376         } <span class="keywordflow">else</span> {
<a name="l05377"></a>05377                 GOTO(stop, rc);
<a name="l05378"></a>05378         }
<a name="l05379"></a>05379 
<a name="l05380"></a>05380 stop:
<a name="l05381"></a>05381         <span class="keywordflow">if</span> (dtlocked)
<a name="l05382"></a>05382                 dt_write_unlock(env, obj);
<a name="l05383"></a>05383 
<a name="l05384"></a>05384         <span class="keywordflow">if</span> (handle != NULL &amp;&amp; !IS_ERR(handle))
<a name="l05385"></a>05385                 dt_trans_stop(env, dev, handle);
<a name="l05386"></a>05386 
<a name="l05387"></a>05387 out:
<a name="l05388"></a>05388         lfsck_ibits_unlock(&amp;lh, LCK_EX);
<a name="l05389"></a>05389 
<a name="l05390"></a>05390         <span class="keywordflow">if</span> (!name_is_dot_or_dotdot(lnr-&gt;lnr_name, lnr-&gt;lnr_namelen) &amp;&amp;
<a name="l05391"></a>05391             !lfsck_is_valid_slave_name_entry(env, lnr-&gt;lnr_lmv,
<a name="l05392"></a>05392                                              lnr-&gt;lnr_name, lnr-&gt;lnr_namelen) &amp;&amp;
<a name="l05393"></a>05393             type != LNIT_BAD_DIRENT) {
<a name="l05394"></a>05394                 ns-&gt;ln_flags |= LF_INCONSISTENT;
<a name="l05395"></a>05395 
<a name="l05396"></a>05396                 log = <span class="keyword">false</span>;
<a name="l05397"></a>05397                 <span class="keywordflow">if</span> (dir == NULL) {
<a name="l05398"></a>05398                         dir = lfsck_assistant_object_load(env, lfsck, lso);
<a name="l05399"></a>05399                         <span class="keywordflow">if</span> (IS_ERR(dir)) {
<a name="l05400"></a>05400                                 rc = PTR_ERR(dir);
<a name="l05401"></a>05401 
<a name="l05402"></a>05402                                 GOTO(trace, rc == -ENOENT ? 0 : rc);
<a name="l05403"></a>05403                         }
<a name="l05404"></a>05404                 }
<a name="l05405"></a>05405 
<a name="l05406"></a>05406                 rc = lfsck_namespace_repair_bad_name_hash(env, com, dir,
<a name="l05407"></a>05407                                                 lnr-&gt;lnr_lmv, lnr-&gt;lnr_name);
<a name="l05408"></a>05408                 <span class="keywordflow">if</span> (rc == 0)
<a name="l05409"></a>05409                         bad_hash = <span class="keyword">true</span>;
<a name="l05410"></a>05410         }
<a name="l05411"></a>05411 
<a name="l05412"></a>05412         <span class="keywordflow">if</span> (rc &gt;= 0) {
<a name="l05413"></a>05413                 <span class="keywordflow">if</span> (type != LNIT_NONE &amp;&amp; dir == NULL) {
<a name="l05414"></a>05414                         dir = lfsck_assistant_object_load(env, lfsck, lso);
<a name="l05415"></a>05415                         <span class="keywordflow">if</span> (IS_ERR(dir)) {
<a name="l05416"></a>05416                                 rc = PTR_ERR(dir);
<a name="l05417"></a>05417 
<a name="l05418"></a>05418                                 GOTO(trace, rc == -ENOENT ? 0 : rc);
<a name="l05419"></a>05419                         }
<a name="l05420"></a>05420                 }
<a name="l05421"></a>05421 
<a name="l05422"></a>05422                 <span class="keywordflow">switch</span> (type) {
<a name="l05423"></a>05423                 <span class="keywordflow">case</span> LNIT_BAD_TYPE:
<a name="l05424"></a>05424                         log = <span class="keyword">false</span>;
<a name="l05425"></a>05425                         rc = lfsck_namespace_repair_dirent(env, com, dir,
<a name="l05426"></a>05426                                         obj, lnr-&gt;lnr_name, lnr-&gt;lnr_name,
<a name="l05427"></a>05427                                         lnr-&gt;lnr_type, <span class="keyword">true</span>, <span class="keyword">false</span>);
<a name="l05428"></a>05428                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l05429"></a>05429                                 repaired = <span class="keyword">true</span>;
<a name="l05430"></a>05430                         <span class="keywordflow">break</span>;
<a name="l05431"></a>05431                 <span class="keywordflow">case</span> LNIT_BAD_DIRENT:
<a name="l05432"></a>05432                         log = <span class="keyword">false</span>;
<a name="l05433"></a>05433                         <span class="comment">/* XXX: This is a bad dirent, we do not know whether</span>
<a name="l05434"></a>05434 <span class="comment">                         *      the original name entry reference a regular</span>
<a name="l05435"></a>05435 <span class="comment">                         *      file or a directory, then keep the parent&apos;s</span>
<a name="l05436"></a>05436 <span class="comment">                         *      nlink count unchanged here. */</span>
<a name="l05437"></a>05437                         rc = lfsck_namespace_repair_dirent(env, com, dir,
<a name="l05438"></a>05438                                         obj, lnr-&gt;lnr_name, lnr-&gt;lnr_name,
<a name="l05439"></a>05439                                         lnr-&gt;lnr_type, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l05440"></a>05440                         <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l05441"></a>05441                                 repaired = <span class="keyword">true</span>;
<a name="l05442"></a>05442                         <span class="keywordflow">break</span>;
<a name="l05443"></a>05443                 <span class="keywordflow">default</span>:
<a name="l05444"></a>05444                         <span class="keywordflow">break</span>;
<a name="l05445"></a>05445                 }
<a name="l05446"></a>05446 
<a name="l05447"></a>05447                 <span class="keywordflow">if</span> (count == 1 &amp;&amp; S_ISREG(lfsck_object_type(obj)))
<a name="l05448"></a>05448                         dt_attr_get(env, obj, la);
<a name="l05449"></a>05449         }
<a name="l05450"></a>05450 
<a name="l05451"></a>05451 trace:
<a name="l05452"></a>05452         down_write(&amp;com-&gt;lc_sem);
<a name="l05453"></a>05453         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l05454"></a>05454                 CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK assistant fail to handle &quot;</span>
<a name="l05455"></a>05455                        <span class="stringliteral">&quot;the entry: &quot;</span>DFID<span class="stringliteral">&quot;, parent &quot;</span>DFID<span class="stringliteral">&quot;, name %.*s: rc = %d\n&quot;</span>,
<a name="l05456"></a>05456                        lfsck_lfsck2name(lfsck), PFID(&amp;lnr-&gt;lnr_fid), PFID(pfid),
<a name="l05457"></a>05457                        lnr-&gt;lnr_namelen, lnr-&gt;lnr_name, rc);
<a name="l05458"></a>05458 
<a name="l05459"></a>05459                 lfsck_namespace_record_failure(env, lfsck, ns);
<a name="l05460"></a>05460                 <span class="keywordflow">if</span> ((rc == -ENOTCONN || rc == -ESHUTDOWN || rc == -EREMCHG ||
<a name="l05461"></a>05461                      rc == -ETIMEDOUT || rc == -EHOSTDOWN ||
<a name="l05462"></a>05462                      rc == -EHOSTUNREACH || rc == -EINPROGRESS) &amp;&amp;
<a name="l05463"></a>05463                     dev != NULL &amp;&amp; dev != lfsck-&gt;li_bottom)
<a name="l05464"></a>05464                         lfsck_lad_set_bitmap(env, com, idx);
<a name="l05465"></a>05465 
<a name="l05466"></a>05466                 <span class="keywordflow">if</span> (!(bk-&gt;lb_param &amp; LPF_FAILOUT))
<a name="l05467"></a>05467                         rc = 0;
<a name="l05468"></a>05468         } <span class="keywordflow">else</span> {
<a name="l05469"></a>05469                 <span class="keywordflow">if</span> (log)
<a name="l05470"></a>05470                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK assistant &quot;</span>
<a name="l05471"></a>05471                                <span class="stringliteral">&quot;repaired the entry: &quot;</span>DFID<span class="stringliteral">&quot;, parent &quot;</span>DFID
<a name="l05472"></a>05472                                <span class="stringliteral">&quot;, name %.*s\n&quot;</span>, lfsck_lfsck2name(lfsck),
<a name="l05473"></a>05473                                PFID(&amp;lnr-&gt;lnr_fid), PFID(pfid),
<a name="l05474"></a>05474                                lnr-&gt;lnr_namelen, lnr-&gt;lnr_name);
<a name="l05475"></a>05475 
<a name="l05476"></a>05476                 <span class="keywordflow">if</span> (repaired) {
<a name="l05477"></a>05477                         ns-&gt;ln_items_repaired++;
<a name="l05478"></a>05478 
<a name="l05479"></a>05479                         <span class="keywordflow">switch</span> (type) {
<a name="l05480"></a>05480                         <span class="keywordflow">case</span> LNIT_DANGLING:
<a name="l05481"></a>05481                                 ns-&gt;ln_dangling_repaired++;
<a name="l05482"></a>05482                                 <span class="keywordflow">break</span>;
<a name="l05483"></a>05483                         <span class="keywordflow">case</span> LNIT_BAD_TYPE:
<a name="l05484"></a>05484                                 ns-&gt;ln_bad_type_repaired++;
<a name="l05485"></a>05485                                 <span class="keywordflow">break</span>;
<a name="l05486"></a>05486                         <span class="keywordflow">case</span> LNIT_BAD_DIRENT:
<a name="l05487"></a>05487                                 ns-&gt;ln_dirent_repaired++;
<a name="l05488"></a>05488                                 <span class="keywordflow">break</span>;
<a name="l05489"></a>05489                         <span class="keywordflow">default</span>:
<a name="l05490"></a>05490                                 <span class="keywordflow">break</span>;
<a name="l05491"></a>05491                         }
<a name="l05492"></a>05492 
<a name="l05493"></a>05493                         <span class="keywordflow">if</span> (bk-&gt;lb_param &amp; LPF_DRYRUN &amp;&amp;
<a name="l05494"></a>05494                             lfsck_pos_is_zero(&amp;ns-&gt;ln_pos_first_inconsistent))
<a name="l05495"></a>05495                                 lfsck_pos_fill(env, lfsck,
<a name="l05496"></a>05496                                                &amp;ns-&gt;ln_pos_first_inconsistent,
<a name="l05497"></a>05497                                                <span class="keyword">false</span>);
<a name="l05498"></a>05498                 }
<a name="l05499"></a>05499 
<a name="l05500"></a>05500                 <span class="keywordflow">if</span> (bad_hash) {
<a name="l05501"></a>05501                         ns-&gt;ln_name_hash_repaired++;
<a name="l05502"></a>05502 
<a name="l05503"></a>05503                         <span class="comment">/* Not count repeatedly. */</span>
<a name="l05504"></a>05504                         <span class="keywordflow">if</span> (!repaired)
<a name="l05505"></a>05505                                 ns-&gt;ln_items_repaired++;
<a name="l05506"></a>05506 
<a name="l05507"></a>05507                         <span class="keywordflow">if</span> (bk-&gt;lb_param &amp; LPF_DRYRUN &amp;&amp;
<a name="l05508"></a>05508                             lfsck_pos_is_zero(&amp;ns-&gt;ln_pos_first_inconsistent))
<a name="l05509"></a>05509                                 lfsck_pos_fill(env, lfsck,
<a name="l05510"></a>05510                                                &amp;ns-&gt;ln_pos_first_inconsistent,
<a name="l05511"></a>05511                                                <span class="keyword">false</span>);
<a name="l05512"></a>05512                 }
<a name="l05513"></a>05513 
<a name="l05514"></a>05514                 rc = 0;
<a name="l05515"></a>05515         }
<a name="l05516"></a>05516 
<a name="l05517"></a>05517         <span class="keywordflow">if</span> (count &gt; 1 || la-&gt;<a class="code" href="structlu__attr.html#a3fd3698668908ad2da2235b210ed2209" title="number of persistent references to this object">la_nlink</a> &gt; 1)
<a name="l05518"></a>05518                 ns-&gt;ln_mul_linked_checked++;
<a name="l05519"></a>05519 
<a name="l05520"></a>05520         up_write(&amp;com-&gt;lc_sem);
<a name="l05521"></a>05521 
<a name="l05522"></a>05522         <span class="keywordflow">if</span> (obj != NULL &amp;&amp; !IS_ERR(obj))
<a name="l05523"></a>05523                 lfsck_object_put(env, obj);
<a name="l05524"></a>05524 
<a name="l05525"></a>05525         <span class="keywordflow">if</span> (dir != NULL &amp;&amp; !IS_ERR(dir))
<a name="l05526"></a>05526                 lfsck_object_put(env, dir);
<a name="l05527"></a>05527 
<a name="l05528"></a>05528         lad-&gt;lad_advance_lock = bad_linkea;
<a name="l05529"></a>05529 
<a name="l05530"></a>05530         <span class="keywordflow">return</span> rc;
<a name="l05531"></a>05531 }
<a name="l05532"></a>05532 
<a name="l05560"></a>05560 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_scan_local_lpf_one(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l05561"></a>05561                                               <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l05562"></a>05562                                               <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *parent,
<a name="l05563"></a>05563                                               <span class="keyword">struct</span> <a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *ent)
<a name="l05564"></a>05564 {
<a name="l05565"></a>05565         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l05566"></a>05566         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>                   *key    = &amp;info-&gt;lti_fid;
<a name="l05567"></a>05567         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>                  *la     = &amp;info-&gt;lti_la;
<a name="l05568"></a>05568         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l05569"></a>05569         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *obj;
<a name="l05570"></a>05570         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>                *dev    = lfsck-&gt;li_bottom;
<a name="l05571"></a>05571         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *child  = NULL;
<a name="l05572"></a>05572         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>                  *th     = NULL;
<a name="l05573"></a>05573         <span class="keywordtype">int</span>                              idx;
<a name="l05574"></a>05574         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l05575"></a>05575         __u8                             flags  = 0;
<a name="l05576"></a>05576         <span class="keywordtype">bool</span>                             exist  = <span class="keyword">false</span>;
<a name="l05577"></a>05577         ENTRY;
<a name="l05578"></a>05578 
<a name="l05579"></a>05579         child = lfsck_object_find_by_dev(env, dev, &amp;ent-&gt;<a class="code" href="structlu__dirent.html#a58764bd31894298ed7ab119d7a245308" title="valid if LUDA_FID is set.">lde_fid</a>);
<a name="l05580"></a>05580         <span class="keywordflow">if</span> (IS_ERR(child))
<a name="l05581"></a>05581                 RETURN(PTR_ERR(child));
<a name="l05582"></a>05582 
<a name="l05583"></a>05583         LASSERT(dt_object_exists(child));
<a name="l05584"></a>05584         LASSERT(!dt_object_remote(child));
<a name="l05585"></a>05585 
<a name="l05586"></a>05586         idx = lfsck_sub_trace_file_fid2idx(&amp;ent-&gt;<a class="code" href="structlu__dirent.html#a58764bd31894298ed7ab119d7a245308" title="valid if LUDA_FID is set.">lde_fid</a>);
<a name="l05587"></a>05587         obj = com-&gt;lc_sub_trace_objs[idx].lsto_obj;
<a name="l05588"></a>05588         fid_cpu_to_be(key, &amp;ent-&gt;<a class="code" href="structlu__dirent.html#a58764bd31894298ed7ab119d7a245308" title="valid if LUDA_FID is set.">lde_fid</a>);
<a name="l05589"></a>05589         rc = dt_lookup(env, obj, (<span class="keyword">struct</span> dt_rec *)&amp;flags,
<a name="l05590"></a>05590                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key);
<a name="l05591"></a>05591         <span class="keywordflow">if</span> (rc == 0) {
<a name="l05592"></a>05592                 exist = <span class="keyword">true</span>;
<a name="l05593"></a>05593                 flags |= LNTF_CHECK_ORPHAN;
<a name="l05594"></a>05594         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l05595"></a>05595                 flags = LNTF_CHECK_ORPHAN;
<a name="l05596"></a>05596         } <span class="keywordflow">else</span> {
<a name="l05597"></a>05597                 GOTO(out, rc);
<a name="l05598"></a>05598         }
<a name="l05599"></a>05599 
<a name="l05600"></a>05600         th = dt_trans_create(env, dev);
<a name="l05601"></a>05601         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l05602"></a>05602                 GOTO(out, rc = PTR_ERR(th));
<a name="l05603"></a>05603 
<a name="l05604"></a>05604         <span class="comment">/* a1. remove name entry from backend /lost+found */</span>
<a name="l05605"></a>05605         rc = dt_declare_delete(env, parent,
<a name="l05606"></a>05606                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)ent-&gt;<a class="code" href="structlu__dirent.html#a3e3b5a552269757293891e23de373a3f" title="name is followed by the attributes indicated in -&amp;gt;ldp_attrs, in their natural...">lde_name</a>, th);
<a name="l05607"></a>05607         <span class="keywordflow">if</span> (rc != 0)
<a name="l05608"></a>05608                 GOTO(stop, rc);
<a name="l05609"></a>05609 
<a name="l05610"></a>05610         <span class="keywordflow">if</span> (S_ISDIR(lfsck_object_type(child))) {
<a name="l05611"></a>05611                 <span class="comment">/* a2. decrease parent&apos;s nlink */</span>
<a name="l05612"></a>05612                 rc = dt_declare_ref_del(env, parent, th);
<a name="l05613"></a>05613                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05614"></a>05614                         GOTO(stop, rc);
<a name="l05615"></a>05615         }
<a name="l05616"></a>05616 
<a name="l05617"></a>05617         <span class="keywordflow">if</span> (exist) {
<a name="l05618"></a>05618                 <span class="comment">/* a3. remove child&apos;s FID from the LFSCK trace file. */</span>
<a name="l05619"></a>05619                 rc = dt_declare_delete(env, obj,
<a name="l05620"></a>05620                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th);
<a name="l05621"></a>05621                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05622"></a>05622                         GOTO(stop, rc);
<a name="l05623"></a>05623         } <span class="keywordflow">else</span> {
<a name="l05624"></a>05624                 <span class="comment">/* a4. set child&apos;s ctime as 1 */</span>
<a name="l05625"></a>05625                 memset(la, 0, <span class="keyword">sizeof</span>(*la));
<a name="l05626"></a>05626                 la-&gt;<a class="code" href="structlu__attr.html#ae05ad3ab91bf7ad9a6ad9844e8d5f8b4" title="change time in seconds since Epoch">la_ctime</a> = 1;
<a name="l05627"></a>05627                 la-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_CTIME;
<a name="l05628"></a>05628                 rc = dt_declare_attr_set(env, child, la, th);
<a name="l05629"></a>05629                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05630"></a>05630                         GOTO(stop, rc);
<a name="l05631"></a>05631         }
<a name="l05632"></a>05632 
<a name="l05633"></a>05633         <span class="comment">/* a5. insert child&apos;s FID into the LFSCK trace file. */</span>
<a name="l05634"></a>05634         rc = dt_declare_insert(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)&amp;flags,
<a name="l05635"></a>05635                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th);
<a name="l05636"></a>05636         <span class="keywordflow">if</span> (rc != 0)
<a name="l05637"></a>05637                 GOTO(stop, rc);
<a name="l05638"></a>05638 
<a name="l05639"></a>05639         rc = dt_trans_start_local(env, dev, th);
<a name="l05640"></a>05640         <span class="keywordflow">if</span> (rc != 0)
<a name="l05641"></a>05641                 GOTO(stop, rc);
<a name="l05642"></a>05642 
<a name="l05643"></a>05643         <span class="comment">/* b1. remove name entry from backend /lost+found */</span>
<a name="l05644"></a>05644         rc = dt_delete(env, parent, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)ent-&gt;<a class="code" href="structlu__dirent.html#a3e3b5a552269757293891e23de373a3f" title="name is followed by the attributes indicated in -&amp;gt;ldp_attrs, in their natural...">lde_name</a>, th);
<a name="l05645"></a>05645         <span class="keywordflow">if</span> (rc != 0)
<a name="l05646"></a>05646                 GOTO(stop, rc);
<a name="l05647"></a>05647 
<a name="l05648"></a>05648         <span class="keywordflow">if</span> (S_ISDIR(lfsck_object_type(child))) {
<a name="l05649"></a>05649                 <span class="comment">/* b2. decrease parent&apos;s nlink */</span>
<a name="l05650"></a>05650                 dt_write_lock(env, parent, 0);
<a name="l05651"></a>05651                 rc = dt_ref_del(env, parent, th);
<a name="l05652"></a>05652                 dt_write_unlock(env, parent);
<a name="l05653"></a>05653                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05654"></a>05654                         GOTO(stop, rc);
<a name="l05655"></a>05655         }
<a name="l05656"></a>05656 
<a name="l05657"></a>05657         <span class="keywordflow">if</span> (exist) {
<a name="l05658"></a>05658                 <span class="comment">/* a3. remove child&apos;s FID from the LFSCK trace file. */</span>
<a name="l05659"></a>05659                 rc = dt_delete(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th);
<a name="l05660"></a>05660                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05661"></a>05661                         GOTO(stop, rc);
<a name="l05662"></a>05662         } <span class="keywordflow">else</span> {
<a name="l05663"></a>05663                 <span class="comment">/* b4. set child&apos;s ctime as 1 */</span>
<a name="l05664"></a>05664                 rc = dt_attr_set(env, child, la, th);
<a name="l05665"></a>05665                 <span class="keywordflow">if</span> (rc != 0)
<a name="l05666"></a>05666                         GOTO(stop, rc);
<a name="l05667"></a>05667         }
<a name="l05668"></a>05668 
<a name="l05669"></a>05669         <span class="comment">/* b5. insert child&apos;s FID into the LFSCK trace file. */</span>
<a name="l05670"></a>05670         rc = dt_insert(env, obj, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)&amp;flags,
<a name="l05671"></a>05671                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)key, th, 1);
<a name="l05672"></a>05672 
<a name="l05673"></a>05673         GOTO(stop, rc = (rc == 0 ? 1 : rc));
<a name="l05674"></a>05674 
<a name="l05675"></a>05675 stop:
<a name="l05676"></a>05676         dt_trans_stop(env, dev, th);
<a name="l05677"></a>05677 
<a name="l05678"></a>05678 out:
<a name="l05679"></a>05679         lfsck_object_put(env, child);
<a name="l05680"></a>05680 
<a name="l05681"></a>05681         <span class="keywordflow">return</span> rc;
<a name="l05682"></a>05682 }
<a name="l05683"></a>05683 
<a name="l05699"></a>05699 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_scan_local_lpf(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l05700"></a>05700                                            <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l05701"></a>05701 {
<a name="l05702"></a>05702         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l05703"></a>05703         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>                *ent    =
<a name="l05704"></a>05704                                         (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)info-&gt;lti_key;
<a name="l05705"></a>05705         <span class="keyword">struct</span> <a class="code" href="structlu__seq__range.html" title="Describes a range of sequence, lsr_start is included but lsr_end is not in the range...">lu_seq_range</a>             *range  = &amp;info-&gt;lti_range;
<a name="l05706"></a>05706         <span class="keyword">struct</span> <a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l05707"></a>05707         <span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>            *thread = &amp;lfsck-&gt;li_thread;
<a name="l05708"></a>05708         <span class="keyword">struct</span> <a class="code" href="structlfsck__bookmark.html">lfsck_bookmark</a>           *bk     = &amp;lfsck-&gt;li_bookmark_ram;
<a name="l05709"></a>05709         <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>          *ns     = com-&gt;lc_file_ram;
<a name="l05710"></a>05710         <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a>                *parent;
<a name="l05711"></a>05711         <span class="keyword">const</span> <span class="keyword">struct</span> dt_it_ops          *iops;
<a name="l05712"></a>05712         <span class="keyword">struct</span> dt_it                    *di;
<a name="l05713"></a>05713         <span class="keyword">struct</span> <a class="code" href="structseq__server__site.html">seq_server_site</a>          *ss     = lfsck_dev_site(lfsck);
<a name="l05714"></a>05714         __u64                            cookie;
<a name="l05715"></a>05715         __u32                            idx    = lfsck_dev_idx(lfsck);
<a name="l05716"></a>05716         <span class="keywordtype">int</span>                              rc     = 0;
<a name="l05717"></a>05717         __u16                            type;
<a name="l05718"></a>05718         ENTRY;
<a name="l05719"></a>05719 
<a name="l05720"></a>05720         parent = lfsck_object_find_by_dev(env, lfsck-&gt;li_bottom,
<a name="l05721"></a>05721                                           &amp;<a class="code" href="group__fid.html#ga512282a77c53f1a51ecaae168f1d4b99" title="&amp;quot;/lost+found&amp;quot; - special FID for ldiskfs backend, invislbe to client.">LU_BACKEND_LPF_FID</a>);
<a name="l05722"></a>05722         <span class="keywordflow">if</span> (IS_ERR(parent)) {
<a name="l05723"></a>05723                 CERROR(<span class="stringliteral">&quot;%s: fail to find backend /lost+found: rc = %ld\n&quot;</span>,
<a name="l05724"></a>05724                        lfsck_lfsck2name(lfsck), PTR_ERR(parent));
<a name="l05725"></a>05725                 RETURN_EXIT;
<a name="l05726"></a>05726         }
<a name="l05727"></a>05727 
<a name="l05728"></a>05728         <span class="comment">/* It is normal that the /lost+found does not exist for ZFS backend. */</span>
<a name="l05729"></a>05729         <span class="keywordflow">if</span> (!dt_object_exists(parent))
<a name="l05730"></a>05730                 GOTO(out, rc = 0);
<a name="l05731"></a>05731 
<a name="l05732"></a>05732         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, parent)))
<a name="l05733"></a>05733                 GOTO(out, rc = -ENOTDIR);
<a name="l05734"></a>05734 
<a name="l05735"></a>05735         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: start to scan backend /lost+found\n&quot;</span>,
<a name="l05736"></a>05736                lfsck_lfsck2name(lfsck));
<a name="l05737"></a>05737 
<a name="l05738"></a>05738         com-&gt;lc_new_scanned = 0;
<a name="l05739"></a>05739         iops = &amp;parent-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>;
<a name="l05740"></a>05740         di = iops-&gt;<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a74b9db7e1791f6accf99c80a3a0c43e2" title="Allocate and initialize new iterator.">init</a>(env, parent, LUDA_64BITHASH | LUDA_TYPE);
<a name="l05741"></a>05741         <span class="keywordflow">if</span> (IS_ERR(di))
<a name="l05742"></a>05742                 GOTO(out, rc = PTR_ERR(di));
<a name="l05743"></a>05743 
<a name="l05744"></a>05744         rc = iops-&gt;load(env, di, 0);
<a name="l05745"></a>05745         <span class="keywordflow">if</span> (rc == 0)
<a name="l05746"></a>05746                 rc = iops-&gt;next(env, di);
<a name="l05747"></a>05747         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l05748"></a>05748                 rc = 0;
<a name="l05749"></a>05749 
<a name="l05750"></a>05750         <span class="keywordflow">while</span> (rc == 0) {
<a name="l05751"></a>05751                 <span class="keywordflow">if</span> (CFS_FAIL_TIMEOUT(OBD_FAIL_LFSCK_DELAY3, cfs_fail_val) &amp;&amp;
<a name="l05752"></a>05752                     unlikely(!thread_is_running(thread)))
<a name="l05753"></a>05753                         <span class="keywordflow">break</span>;
<a name="l05754"></a>05754 
<a name="l05755"></a>05755                 rc = iops-&gt;rec(env, di, (<span class="keyword">struct</span> dt_rec *)ent,
<a name="l05756"></a>05756                                LUDA_64BITHASH | LUDA_TYPE);
<a name="l05757"></a>05757                 <span class="keywordflow">if</span> (rc == 0)
<a name="l05758"></a>05758                         rc = lfsck_unpack_ent(ent, &amp;cookie, &amp;type);
<a name="l05759"></a>05759 
<a name="l05760"></a>05760                 <span class="keywordflow">if</span> (unlikely(rc != 0)) {
<a name="l05761"></a>05761                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: fail to iterate backend &quot;</span>
<a name="l05762"></a>05762                                <span class="stringliteral">&quot;/lost+found: rc = %d\n&quot;</span>,
<a name="l05763"></a>05763                                lfsck_lfsck2name(lfsck), rc);
<a name="l05764"></a>05764 
<a name="l05765"></a>05765                         <span class="keywordflow">goto</span> skip;
<a name="l05766"></a>05766                 }
<a name="l05767"></a>05767 
<a name="l05768"></a>05768                 <span class="comment">/* skip dot and dotdot entries */</span>
<a name="l05769"></a>05769                 <span class="keywordflow">if</span> (name_is_dot_or_dotdot(ent-&gt;lde_name, ent-&gt;lde_namelen))
<a name="l05770"></a>05770                         <span class="keywordflow">goto</span> next;
<a name="l05771"></a>05771 
<a name="l05772"></a>05772                 <span class="keywordflow">if</span> (!fid_seq_in_fldb(<a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(&amp;ent-&gt;lde_fid)))
<a name="l05773"></a>05773                         <span class="keywordflow">goto</span> skip;
<a name="l05774"></a>05774 
<a name="l05775"></a>05775                 <span class="keywordflow">if</span> (fid_is_norm(&amp;ent-&gt;lde_fid)) {
<a name="l05776"></a>05776                         fld_range_set_mdt(range);
<a name="l05777"></a>05777                         rc = <a class="code" href="group__fld.html#gaaebfe53fda6d4c3bb7dfc963bdb19509" title="Lookup sequece in local cache/fldb.">fld_local_lookup</a>(env, ss-&gt;<a class="code" href="structseq__server__site.html#a325bd7c1845a266e8f54469450152cb8" title="Fid location database.">ss_server_fld</a>,
<a name="l05778"></a>05778                                               <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(&amp;ent-&gt;lde_fid), range);
<a name="l05779"></a>05779                         <span class="keywordflow">if</span> (rc != 0)
<a name="l05780"></a>05780                                 <span class="keywordflow">goto</span> skip;
<a name="l05781"></a>05781                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (idx != 0) {
<a name="l05782"></a>05782                         <span class="comment">/* If the returned FID is IGIF, then there are three</span>
<a name="l05783"></a>05783 <span class="comment">                         * possible cases:</span>
<a name="l05784"></a>05784 <span class="comment">                         *</span>
<a name="l05785"></a>05785 <span class="comment">                         * 1) The object is upgraded from old Lustre-1.8 with</span>
<a name="l05786"></a>05786 <span class="comment">                         *    IGIF assigned to such object.</span>
<a name="l05787"></a>05787 <span class="comment">                         * 2) The object is a backend local object and is</span>
<a name="l05788"></a>05788 <span class="comment">                         *    invisible to client.</span>
<a name="l05789"></a>05789 <span class="comment">                         * 3) The object lost its LMV EA, and since there is</span>
<a name="l05790"></a>05790 <span class="comment">                         *    no FID-in-dirent for the orphan in the backend</span>
<a name="l05791"></a>05791 <span class="comment">                         *    /lost+found directory, then the low layer will</span>
<a name="l05792"></a>05792 <span class="comment">                         *    return IGIF for such object.</span>
<a name="l05793"></a>05793 <span class="comment">                         *</span>
<a name="l05794"></a>05794 <span class="comment">                         * For MDTx (x != 0), it is either case 2) or case 3),</span>
<a name="l05795"></a>05795 <span class="comment">                         * but from the LFSCK view, they are indistinguishable.</span>
<a name="l05796"></a>05796 <span class="comment">                         * To be safe, the LFSCK will keep it there and report</span>
<a name="l05797"></a>05797 <span class="comment">                         * some message, then the adminstrator can handle that</span>
<a name="l05798"></a>05798 <span class="comment">                         * furtherly.</span>
<a name="l05799"></a>05799 <span class="comment">                         *</span>
<a name="l05800"></a>05800 <span class="comment">                         * For MDT0, it is more possible the case 1). The LFSCK</span>
<a name="l05801"></a>05801 <span class="comment">                         * will handle the orphan as an upgraded object. */</span>
<a name="l05802"></a>05802                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: the orphan %.*s with IGIF &quot;</span>DFID
<a name="l05803"></a>05803                                <span class="stringliteral">&quot;in the backend /lost+found on the MDT %04x, &quot;</span>
<a name="l05804"></a>05804                                <span class="stringliteral">&quot;to be safe, skip it.\n&quot;</span>,
<a name="l05805"></a>05805                                lfsck_lfsck2name(lfsck), ent-&gt;lde_namelen,
<a name="l05806"></a>05806                                ent-&gt;lde_name, PFID(&amp;ent-&gt;lde_fid), idx);
<a name="l05807"></a>05807                         <span class="keywordflow">goto</span> skip;
<a name="l05808"></a>05808                 }
<a name="l05809"></a>05809 
<a name="l05810"></a>05810                 rc = lfsck_namespace_scan_local_lpf_one(env, com, parent, ent);
<a name="l05811"></a>05811 
<a name="l05812"></a>05812 skip:
<a name="l05813"></a>05813                 down_write(&amp;com-&gt;lc_sem);
<a name="l05814"></a>05814                 com-&gt;lc_new_scanned++;
<a name="l05815"></a>05815                 ns-&gt;ln_local_lpf_scanned++;
<a name="l05816"></a>05816                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l05817"></a>05817                         ns-&gt;ln_local_lpf_moved++;
<a name="l05818"></a>05818                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 0)
<a name="l05819"></a>05819                         ns-&gt;ln_local_lpf_skipped++;
<a name="l05820"></a>05820                 <span class="keywordflow">else</span>
<a name="l05821"></a>05821                         ns-&gt;ln_local_lpf_failed++;
<a name="l05822"></a>05822                 up_write(&amp;com-&gt;lc_sem);
<a name="l05823"></a>05823 
<a name="l05824"></a>05824                 <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; bk-&gt;lb_param &amp; LPF_FAILOUT)
<a name="l05825"></a>05825                         <span class="keywordflow">break</span>;
<a name="l05826"></a>05826 
<a name="l05827"></a>05827 next:
<a name="l05828"></a>05828                 lfsck_control_speed_by_self(com);
<a name="l05829"></a>05829                 <span class="keywordflow">if</span> (unlikely(!thread_is_running(thread))) {
<a name="l05830"></a>05830                         rc = 0;
<a name="l05831"></a>05831                         <span class="keywordflow">break</span>;
<a name="l05832"></a>05832                 }
<a name="l05833"></a>05833 
<a name="l05834"></a>05834                 rc = iops-&gt;next(env, di);
<a name="l05835"></a>05835         }
<a name="l05836"></a>05836 
<a name="l05837"></a>05837         iops-&gt;put(env, di);
<a name="l05838"></a>05838         iops-&gt;fini(env, di);
<a name="l05839"></a>05839 
<a name="l05840"></a>05840         EXIT;
<a name="l05841"></a>05841 
<a name="l05842"></a>05842 out:
<a name="l05843"></a>05843         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: stop to scan backend /lost+found: rc = %d\n&quot;</span>,
<a name="l05844"></a>05844                lfsck_lfsck2name(lfsck), rc);
<a name="l05845"></a>05845 
<a name="l05846"></a>05846         lfsck_object_put(env, parent);
<a name="l05847"></a>05847 }
<a name="l05848"></a>05848 
<a name="l05869"></a>05869 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_rescan_striped_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l05870"></a>05870                                               <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l05871"></a>05871                                               <span class="keyword">struct</span> <a class="code" href="structlfsck__lmv__unit.html">lfsck_lmv_unit</a> *llu)
<a name="l05872"></a>05872 {
<a name="l05873"></a>05873         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a>        *info   = lfsck_env_info(env);
<a name="l05874"></a>05874         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>           *lfsck  = com-&gt;lc_lfsck;
<a name="l05875"></a>05875         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad    = com-&gt;lc_data;
<a name="l05876"></a>05876         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>                *dir;
<a name="l05877"></a>05877         <span class="keyword">const</span> <span class="keyword">struct </span>dt_it_ops          *iops;
<a name="l05878"></a>05878         <span class="keyword">struct </span>dt_it                    *di;
<a name="l05879"></a>05879         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>                *ent    =
<a name="l05880"></a>05880                         (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)info-&gt;lti_key;
<a name="l05881"></a>05881         <span class="keyword">struct</span> <a class="code" href="structlfsck__bookmark.html">lfsck_bookmark</a>           *bk     = &amp;lfsck-&gt;li_bookmark_ram;
<a name="l05882"></a>05882         <span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>            *thread = &amp;lfsck-&gt;li_thread;
<a name="l05883"></a>05883         <span class="keyword">struct</span> <a class="code" href="structlfsck__assistant__object.html">lfsck_assistant_object</a>   *lso    = NULL;
<a name="l05884"></a>05884         <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a>      *lnr;
<a name="l05885"></a>05885         <span class="keyword">struct</span> <a class="code" href="structlfsck__assistant__req.html">lfsck_assistant_req</a>      *lar;
<a name="l05886"></a>05886         <span class="keywordtype">int</span>                              rc;
<a name="l05887"></a>05887         __u16                            type;
<a name="l05888"></a>05888         ENTRY;
<a name="l05889"></a>05889 
<a name="l05890"></a>05890         LASSERT(list_empty(&amp;lad-&gt;lad_req_list));
<a name="l05891"></a>05891 
<a name="l05892"></a>05892         lfsck-&gt;li_lmv = &amp;llu-&gt;llu_lmv;
<a name="l05893"></a>05893         lfsck-&gt;li_obj_dir = lfsck_object_get(llu-&gt;llu_obj);
<a name="l05894"></a>05894         rc = lfsck_open_dir(env, lfsck, 0);
<a name="l05895"></a>05895         <span class="keywordflow">if</span> (rc != 0)
<a name="l05896"></a>05896                 RETURN(rc);
<a name="l05897"></a>05897 
<a name="l05898"></a>05898         dir = lfsck-&gt;li_obj_dir;
<a name="l05899"></a>05899         di = lfsck-&gt;li_di_dir;
<a name="l05900"></a>05900         iops = &amp;dir-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>;
<a name="l05901"></a>05901         <span class="keywordflow">do</span> {
<a name="l05902"></a>05902                 rc = iops-&gt;<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a1b24018fcd837461771bb59a4d0c0d05" title="Return record.">rec</a>(env, di, (<span class="keyword">struct</span> dt_rec *)ent,
<a name="l05903"></a>05903                                lfsck-&gt;li_args_dir);
<a name="l05904"></a>05904                 <span class="keywordflow">if</span> (rc == 0)
<a name="l05905"></a>05905                         rc = lfsck_unpack_ent(ent, &amp;lfsck-&gt;li_cookie_dir,
<a name="l05906"></a>05906                                               &amp;type);
<a name="l05907"></a>05907 
<a name="l05908"></a>05908                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l05909"></a>05909                         <span class="keywordflow">if</span> (bk-&gt;lb_param &amp; LPF_FAILOUT)
<a name="l05910"></a>05910                                 GOTO(out, rc);
<a name="l05911"></a>05911 
<a name="l05912"></a>05912                         <span class="keywordflow">goto</span> next;
<a name="l05913"></a>05913                 }
<a name="l05914"></a>05914 
<a name="l05915"></a>05915                 <span class="keywordflow">if</span> (name_is_dot_or_dotdot(ent-&gt;lde_name, ent-&gt;lde_namelen))
<a name="l05916"></a>05916                         <span class="keywordflow">goto</span> next;
<a name="l05917"></a>05917 
<a name="l05918"></a>05918                 <span class="keywordflow">if</span> (lso == NULL) {
<a name="l05919"></a>05919                         lso = lfsck_assistant_object_init(env,
<a name="l05920"></a>05920                                 lfsck_dto2fid(dir), NULL,
<a name="l05921"></a>05921                                 lfsck-&gt;li_pos_current.lp_oit_cookie, <span class="keyword">true</span>);
<a name="l05922"></a>05922                         <span class="keywordflow">if</span> (IS_ERR(lso)) {
<a name="l05923"></a>05923                                 <span class="keywordflow">if</span> (bk-&gt;lb_param &amp; LPF_FAILOUT)
<a name="l05924"></a>05924                                         GOTO(out, rc = PTR_ERR(lso));
<a name="l05925"></a>05925 
<a name="l05926"></a>05926                                 lso = NULL;
<a name="l05927"></a>05927                                 <span class="keywordflow">goto</span> next;
<a name="l05928"></a>05928                         }
<a name="l05929"></a>05929                 }
<a name="l05930"></a>05930 
<a name="l05931"></a>05931                 lnr = lfsck_namespace_assistant_req_init(lfsck, lso, ent, type);
<a name="l05932"></a>05932                 <span class="keywordflow">if</span> (IS_ERR(lnr)) {
<a name="l05933"></a>05933                         <span class="keywordflow">if</span> (bk-&gt;lb_param &amp; LPF_FAILOUT)
<a name="l05934"></a>05934                                 GOTO(out, rc = PTR_ERR(lnr));
<a name="l05935"></a>05935 
<a name="l05936"></a>05936                         <span class="keywordflow">goto</span> next;
<a name="l05937"></a>05937                 }
<a name="l05938"></a>05938 
<a name="l05939"></a>05939                 lar = &amp;lnr-&gt;lnr_lar;
<a name="l05940"></a>05940                 rc = lfsck_namespace_assistant_handler_p1(env, com, lar);
<a name="l05941"></a>05941                 lfsck_namespace_assistant_req_fini(env, lar);
<a name="l05942"></a>05942                 <span class="keywordflow">if</span> (rc != 0 &amp;&amp; bk-&gt;lb_param &amp; LPF_FAILOUT)
<a name="l05943"></a>05943                         GOTO(out, rc);
<a name="l05944"></a>05944 
<a name="l05945"></a>05945                 <span class="keywordflow">if</span> (unlikely(!thread_is_running(thread)))
<a name="l05946"></a>05946                         GOTO(out, rc = 0);
<a name="l05947"></a>05947 
<a name="l05948"></a>05948 next:
<a name="l05949"></a>05949                 rc = iops-&gt;next(env, di);
<a name="l05950"></a>05950         } <span class="keywordflow">while</span> (rc == 0);
<a name="l05951"></a>05951 
<a name="l05952"></a>05952 out:
<a name="l05953"></a>05953         <span class="keywordflow">if</span> (lso != NULL &amp;&amp; !IS_ERR(lso))
<a name="l05954"></a>05954                 lfsck_assistant_object_put(env, lso);
<a name="l05955"></a>05955 
<a name="l05956"></a>05956         lfsck_close_dir(env, lfsck, rc);
<a name="l05957"></a>05957         <span class="keywordflow">if</span> (rc &lt;= 0)
<a name="l05958"></a>05958                 RETURN(rc);
<a name="l05959"></a>05959 
<a name="l05960"></a>05960         <span class="comment">/* The close_dir() may insert a dummy lnr in the lad-&gt;lad_req_list. */</span>
<a name="l05961"></a>05961         <span class="keywordflow">if</span> (list_empty(&amp;lad-&gt;lad_req_list))
<a name="l05962"></a>05962                 RETURN(1);
<a name="l05963"></a>05963 
<a name="l05964"></a>05964         spin_lock(&amp;lad-&gt;lad_lock);
<a name="l05965"></a>05965         lar = list_entry(lad-&gt;lad_req_list.next, <span class="keyword">struct</span> <a class="code" href="structlfsck__assistant__req.html">lfsck_assistant_req</a>,
<a name="l05966"></a>05966                           lar_list);
<a name="l05967"></a>05967         list_del_init(&amp;lar-&gt;lar_list);
<a name="l05968"></a>05968         spin_unlock(&amp;lad-&gt;lad_lock);
<a name="l05969"></a>05969 
<a name="l05970"></a>05970         rc = lfsck_namespace_assistant_handler_p1(env, com, lar);
<a name="l05971"></a>05971         lfsck_namespace_assistant_req_fini(env, lar);
<a name="l05972"></a>05972 
<a name="l05973"></a>05973         RETURN(rc == 0 ? 1 : rc);
<a name="l05974"></a>05974 }
<a name="l05975"></a>05975 
<a name="l05976"></a>05976 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05977"></a>05977 lfsck_namespace_double_scan_one_trace_file(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l05978"></a>05978                                            <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l05979"></a>05979                                            <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj, <span class="keywordtype">bool</span> first)
<a name="l05980"></a>05980 {
<a name="l05981"></a>05981         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck  = com-&gt;lc_lfsck;
<a name="l05982"></a>05982         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>    *thread = &amp;lfsck-&gt;li_thread;
<a name="l05983"></a>05983         <span class="keyword">struct </span><a class="code" href="structlfsck__bookmark.html">lfsck_bookmark</a>   *bk     = &amp;lfsck-&gt;li_bookmark_ram;
<a name="l05984"></a>05984         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>  *ns     = com-&gt;lc_file_ram;
<a name="l05985"></a>05985         <span class="keyword">const</span> <span class="keyword">struct </span>dt_it_ops  *iops   = &amp;obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>;
<a name="l05986"></a>05986         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *target;
<a name="l05987"></a>05987         <span class="keyword">struct </span>dt_it            *di;
<a name="l05988"></a>05988         <span class="keyword">struct </span>dt_key           *key;
<a name="l05989"></a>05989         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>            fid;
<a name="l05990"></a>05990         <span class="keywordtype">int</span>                      rc;
<a name="l05991"></a>05991         __u8                     flags  = 0;
<a name="l05992"></a>05992         ENTRY;
<a name="l05993"></a>05993 
<a name="l05994"></a>05994         di = iops-&gt;init(env, obj, 0);
<a name="l05995"></a>05995         <span class="keywordflow">if</span> (IS_ERR(di))
<a name="l05996"></a>05996                 RETURN(PTR_ERR(di));
<a name="l05997"></a>05997 
<a name="l05998"></a>05998         <span class="keywordflow">if</span> (first)
<a name="l05999"></a>05999                 fid_cpu_to_be(&amp;fid, &amp;ns-&gt;ln_fid_latest_scanned_phase2);
<a name="l06000"></a>06000         <span class="keywordflow">else</span>
<a name="l06001"></a>06001                 fid_zero(&amp;fid);
<a name="l06002"></a>06002         rc = iops-&gt;get(env, di, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)&amp;fid);
<a name="l06003"></a>06003         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l06004"></a>06004                 GOTO(fini, rc);
<a name="l06005"></a>06005 
<a name="l06006"></a>06006         <span class="keywordflow">if</span> (first) {
<a name="l06007"></a>06007                 <span class="comment">/* The start one either has been processed or does not exist,</span>
<a name="l06008"></a>06008 <span class="comment">                 * skip it. */</span>
<a name="l06009"></a>06009                 rc = iops-&gt;next(env, di);
<a name="l06010"></a>06010                 <span class="keywordflow">if</span> (rc != 0)
<a name="l06011"></a>06011                         GOTO(put, rc);
<a name="l06012"></a>06012         }
<a name="l06013"></a>06013 
<a name="l06014"></a>06014         <span class="keywordflow">do</span> {
<a name="l06015"></a>06015                 <span class="keywordflow">if</span> (CFS_FAIL_TIMEOUT(OBD_FAIL_LFSCK_DELAY3, cfs_fail_val) &amp;&amp;
<a name="l06016"></a>06016                     unlikely(!thread_is_running(thread)))
<a name="l06017"></a>06017                         GOTO(put, rc = 0);
<a name="l06018"></a>06018 
<a name="l06019"></a>06019                 key = iops-&gt;key(env, di);
<a name="l06020"></a>06020                 <span class="keywordflow">if</span> (IS_ERR(key)) {
<a name="l06021"></a>06021                         rc = PTR_ERR(key);
<a name="l06022"></a>06022                         <span class="keywordflow">if</span> (rc == -ENOENT)
<a name="l06023"></a>06023                                 GOTO(put, rc = 1);
<a name="l06024"></a>06024 
<a name="l06025"></a>06025                         <span class="keywordflow">goto</span> checkpoint;
<a name="l06026"></a>06026                 }
<a name="l06027"></a>06027 
<a name="l06028"></a>06028                 fid_be_to_cpu(&amp;fid, (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *)key);
<a name="l06029"></a>06029                 <span class="keywordflow">if</span> (!fid_is_sane(&amp;fid)) {
<a name="l06030"></a>06030                         rc = 0;
<a name="l06031"></a>06031                         <span class="keywordflow">goto</span> checkpoint;
<a name="l06032"></a>06032                 }
<a name="l06033"></a>06033 
<a name="l06034"></a>06034                 target = lfsck_object_find_bottom(env, lfsck, &amp;fid);
<a name="l06035"></a>06035                 <span class="keywordflow">if</span> (IS_ERR(target)) {
<a name="l06036"></a>06036                         rc = PTR_ERR(target);
<a name="l06037"></a>06037                         <span class="keywordflow">goto</span> checkpoint;
<a name="l06038"></a>06038                 }
<a name="l06039"></a>06039 
<a name="l06040"></a>06040                 <span class="keywordflow">if</span> (dt_object_exists(target)) {
<a name="l06041"></a>06041                         rc = iops-&gt;rec(env, di, (<span class="keyword">struct</span> dt_rec *)&amp;flags, 0);
<a name="l06042"></a>06042                         <span class="keywordflow">if</span> (rc == 0) {
<a name="l06043"></a>06043                                 rc = lfsck_namespace_double_scan_one(env, com,
<a name="l06044"></a>06044                                                                 target, flags);
<a name="l06045"></a>06045                                 <span class="keywordflow">if</span> (rc == -ENOENT)
<a name="l06046"></a>06046                                         rc = 0;
<a name="l06047"></a>06047                         }
<a name="l06048"></a>06048                 }
<a name="l06049"></a>06049 
<a name="l06050"></a>06050                 lfsck_object_put(env, target);
<a name="l06051"></a>06051 
<a name="l06052"></a>06052 checkpoint:
<a name="l06053"></a>06053                 down_write(&amp;com-&gt;lc_sem);
<a name="l06054"></a>06054                 com-&gt;lc_new_checked++;
<a name="l06055"></a>06055                 com-&gt;lc_new_scanned++;
<a name="l06056"></a>06056                 <span class="keywordflow">if</span> (rc &gt;= 0 &amp;&amp; fid_is_sane(&amp;fid))
<a name="l06057"></a>06057                         ns-&gt;ln_fid_latest_scanned_phase2 = fid;
<a name="l06058"></a>06058                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l06059"></a>06059                         ns-&gt;ln_objs_repaired_phase2++;
<a name="l06060"></a>06060                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l06061"></a>06061                         ns-&gt;ln_objs_failed_phase2++;
<a name="l06062"></a>06062                 up_write(&amp;com-&gt;lc_sem);
<a name="l06063"></a>06063 
<a name="l06064"></a>06064                 <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; bk-&gt;lb_param &amp; LPF_FAILOUT)
<a name="l06065"></a>06065                         GOTO(put, rc);
<a name="l06066"></a>06066 
<a name="l06067"></a>06067                 <span class="keywordflow">if</span> (unlikely(cfs_time_beforeq(com-&gt;lc_time_next_checkpoint,
<a name="l06068"></a>06068                                               cfs_time_current())) &amp;&amp;
<a name="l06069"></a>06069                     com-&gt;lc_new_checked != 0) {
<a name="l06070"></a>06070                         down_write(&amp;com-&gt;lc_sem);
<a name="l06071"></a>06071                         ns-&gt;ln_run_time_phase2 +=
<a name="l06072"></a>06072                                 cfs_duration_sec(cfs_time_current() +
<a name="l06073"></a>06073                                 HALF_SEC - com-&gt;lc_time_last_checkpoint);
<a name="l06074"></a>06074                         ns-&gt;ln_time_last_checkpoint = cfs_time_current_sec();
<a name="l06075"></a>06075                         ns-&gt;ln_objs_checked_phase2 += com-&gt;lc_new_checked;
<a name="l06076"></a>06076                         com-&gt;lc_new_checked = 0;
<a name="l06077"></a>06077                         rc = lfsck_namespace_store(env, com);
<a name="l06078"></a>06078                         up_write(&amp;com-&gt;lc_sem);
<a name="l06079"></a>06079                         <span class="keywordflow">if</span> (rc != 0)
<a name="l06080"></a>06080                                 GOTO(put, rc);
<a name="l06081"></a>06081 
<a name="l06082"></a>06082                         com-&gt;lc_time_last_checkpoint = cfs_time_current();
<a name="l06083"></a>06083                         com-&gt;lc_time_next_checkpoint =
<a name="l06084"></a>06084                                 com-&gt;lc_time_last_checkpoint +
<a name="l06085"></a>06085                                 cfs_time_seconds(LFSCK_CHECKPOINT_INTERVAL);
<a name="l06086"></a>06086                 }
<a name="l06087"></a>06087 
<a name="l06088"></a>06088                 lfsck_control_speed_by_self(com);
<a name="l06089"></a>06089                 <span class="keywordflow">if</span> (unlikely(!thread_is_running(thread)))
<a name="l06090"></a>06090                         GOTO(put, rc = 0);
<a name="l06091"></a>06091 
<a name="l06092"></a>06092                 rc = iops-&gt;next(env, di);
<a name="l06093"></a>06093         } <span class="keywordflow">while</span> (rc == 0);
<a name="l06094"></a>06094 
<a name="l06095"></a>06095         GOTO(put, rc);
<a name="l06096"></a>06096 
<a name="l06097"></a>06097 put:
<a name="l06098"></a>06098         iops-&gt;put(env, di);
<a name="l06099"></a>06099 
<a name="l06100"></a>06100 fini:
<a name="l06101"></a>06101         iops-&gt;fini(env, di);
<a name="l06102"></a>06102 
<a name="l06103"></a>06103         <span class="keywordflow">return</span> rc;
<a name="l06104"></a>06104 }
<a name="l06105"></a>06105 
<a name="l06106"></a>06106 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_assistant_handler_p2(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l06107"></a>06107                                                 <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com)
<a name="l06108"></a>06108 {
<a name="l06109"></a>06109         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck  = com-&gt;lc_lfsck;
<a name="l06110"></a>06110         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>  *ns     = com-&gt;lc_file_ram;
<a name="l06111"></a>06111         <span class="keywordtype">int</span>                      rc;
<a name="l06112"></a>06112         <span class="keywordtype">int</span>                      i;
<a name="l06113"></a>06113         ENTRY;
<a name="l06114"></a>06114 
<a name="l06115"></a>06115         <span class="keywordflow">while</span> (!list_empty(&amp;lfsck-&gt;li_list_lmv)) {
<a name="l06116"></a>06116                 <span class="keyword">struct </span><a class="code" href="structlfsck__lmv__unit.html">lfsck_lmv_unit</a> *llu;
<a name="l06117"></a>06117 
<a name="l06118"></a>06118                 spin_lock(&amp;lfsck-&gt;li_lock);
<a name="l06119"></a>06119                 llu = list_entry(lfsck-&gt;li_list_lmv.next,
<a name="l06120"></a>06120                                  <span class="keyword">struct</span> <a class="code" href="structlfsck__lmv__unit.html">lfsck_lmv_unit</a>, llu_link);
<a name="l06121"></a>06121                 list_del_init(&amp;llu-&gt;llu_link);
<a name="l06122"></a>06122                 spin_unlock(&amp;lfsck-&gt;li_lock);
<a name="l06123"></a>06123 
<a name="l06124"></a>06124                 rc = lfsck_namespace_rescan_striped_dir(env, com, llu);
<a name="l06125"></a>06125                 <span class="keywordflow">if</span> (rc &lt;= 0)
<a name="l06126"></a>06126                         RETURN(rc);
<a name="l06127"></a>06127         }
<a name="l06128"></a>06128 
<a name="l06129"></a>06129         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK phase2 scan start\n&quot;</span>,
<a name="l06130"></a>06130                lfsck_lfsck2name(lfsck));
<a name="l06131"></a>06131 
<a name="l06132"></a>06132         lfsck_namespace_scan_local_lpf(env, com);
<a name="l06133"></a>06133 
<a name="l06134"></a>06134         com-&gt;lc_new_checked = 0;
<a name="l06135"></a>06135         com-&gt;lc_new_scanned = 0;
<a name="l06136"></a>06136         com-&gt;lc_time_last_checkpoint = cfs_time_current();
<a name="l06137"></a>06137         com-&gt;lc_time_next_checkpoint = com-&gt;lc_time_last_checkpoint +
<a name="l06138"></a>06138                                 cfs_time_seconds(LFSCK_CHECKPOINT_INTERVAL);
<a name="l06139"></a>06139 
<a name="l06140"></a>06140         i = lfsck_sub_trace_file_fid2idx(&amp;ns-&gt;ln_fid_latest_scanned_phase2);
<a name="l06141"></a>06141         rc = lfsck_namespace_double_scan_one_trace_file(env, com,
<a name="l06142"></a>06142                                 com-&gt;lc_sub_trace_objs[i].lsto_obj, <span class="keyword">true</span>);
<a name="l06143"></a>06143         <span class="keywordflow">while</span> (rc &gt; 0 &amp;&amp; ++i &lt; LFSCK_STF_COUNT)
<a name="l06144"></a>06144                 rc = lfsck_namespace_double_scan_one_trace_file(env, com,
<a name="l06145"></a>06145                                 com-&gt;lc_sub_trace_objs[i].lsto_obj, <span class="keyword">false</span>);
<a name="l06146"></a>06146 
<a name="l06147"></a>06147         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK phase2 scan stop at the No. %d &quot;</span>
<a name="l06148"></a>06148                <span class="stringliteral">&quot;trace file: rc = %d\n&quot;</span>, lfsck_lfsck2name(lfsck), i, rc);
<a name="l06149"></a>06149 
<a name="l06150"></a>06150         RETURN(rc);
<a name="l06151"></a>06151 }
<a name="l06152"></a>06152 
<a name="l06153"></a>06153 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_assistant_fill_pos(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l06154"></a>06154                                                <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l06155"></a>06155                                                <span class="keyword">struct</span> <a class="code" href="structlfsck__position.html">lfsck_position</a> *pos)
<a name="l06156"></a>06156 {
<a name="l06157"></a>06157         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>     *lad = com-&gt;lc_data;
<a name="l06158"></a>06158         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a>      *lnr;
<a name="l06159"></a>06159 
<a name="l06160"></a>06160         <span class="keywordflow">if</span> (list_empty(&amp;lad-&gt;lad_req_list))
<a name="l06161"></a>06161                 <span class="keywordflow">return</span>;
<a name="l06162"></a>06162 
<a name="l06163"></a>06163         lnr = list_entry(lad-&gt;lad_req_list.next,
<a name="l06164"></a>06164                          <span class="keyword">struct</span> <a class="code" href="structlfsck__namespace__req.html">lfsck_namespace_req</a>,
<a name="l06165"></a>06165                          lnr_lar.lar_list);
<a name="l06166"></a>06166         pos-&gt;lp_oit_cookie = lnr-&gt;lnr_lar.lar_parent-&gt;lso_oit_cookie;
<a name="l06167"></a>06167         pos-&gt;lp_dir_cookie = lnr-&gt;lnr_dir_cookie - 1;
<a name="l06168"></a>06168         pos-&gt;lp_dir_parent = lnr-&gt;lnr_lar.lar_parent-&gt;lso_fid;
<a name="l06169"></a>06169 }
<a name="l06170"></a>06170 
<a name="l06171"></a>06171 <span class="keyword">static</span> <span class="keywordtype">int</span> lfsck_namespace_double_scan_result(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l06172"></a>06172                                               <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l06173"></a>06173                                               <span class="keywordtype">int</span> rc)
<a name="l06174"></a>06174 {
<a name="l06175"></a>06175         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>   *lfsck  = com-&gt;lc_lfsck;
<a name="l06176"></a>06176         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>  *ns     = com-&gt;lc_file_ram;
<a name="l06177"></a>06177 
<a name="l06178"></a>06178         down_write(&amp;com-&gt;lc_sem);
<a name="l06179"></a>06179         ns-&gt;ln_run_time_phase2 += cfs_duration_sec(cfs_time_current() +
<a name="l06180"></a>06180                                   HALF_SEC - com-&gt;lc_time_last_checkpoint);
<a name="l06181"></a>06181         ns-&gt;ln_time_last_checkpoint = cfs_time_current_sec();
<a name="l06182"></a>06182         ns-&gt;ln_objs_checked_phase2 += com-&gt;lc_new_checked;
<a name="l06183"></a>06183         com-&gt;lc_new_checked = 0;
<a name="l06184"></a>06184 
<a name="l06185"></a>06185         <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l06186"></a>06186                 <span class="keywordflow">if</span> (ns-&gt;ln_flags &amp; LF_INCOMPLETE)
<a name="l06187"></a>06187                         ns-&gt;ln_status = LS_PARTIAL;
<a name="l06188"></a>06188                 <span class="keywordflow">else</span>
<a name="l06189"></a>06189                         ns-&gt;ln_status = LS_COMPLETED;
<a name="l06190"></a>06190                 <span class="keywordflow">if</span> (!(lfsck-&gt;li_bookmark_ram.lb_param &amp; LPF_DRYRUN))
<a name="l06191"></a>06191                         ns-&gt;ln_flags &amp;= ~(LF_SCANNED_ONCE | LF_INCONSISTENT);
<a name="l06192"></a>06192                 ns-&gt;ln_time_last_complete = ns-&gt;ln_time_last_checkpoint;
<a name="l06193"></a>06193                 ns-&gt;ln_success_count++;
<a name="l06194"></a>06194         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 0) {
<a name="l06195"></a>06195                 <span class="keywordflow">if</span> (lfsck-&gt;li_status != 0)
<a name="l06196"></a>06196                         ns-&gt;ln_status = lfsck-&gt;li_status;
<a name="l06197"></a>06197                 <span class="keywordflow">else</span>
<a name="l06198"></a>06198                         ns-&gt;ln_status = LS_STOPPED;
<a name="l06199"></a>06199         } <span class="keywordflow">else</span> {
<a name="l06200"></a>06200                 ns-&gt;ln_status = LS_FAILED;
<a name="l06201"></a>06201         }
<a name="l06202"></a>06202 
<a name="l06203"></a>06203         rc = lfsck_namespace_store(env, com);
<a name="l06204"></a>06204         up_write(&amp;com-&gt;lc_sem);
<a name="l06205"></a>06205 
<a name="l06206"></a>06206         <span class="keywordflow">return</span> rc;
<a name="l06207"></a>06207 }
<a name="l06208"></a>06208 
<a name="l06209"></a>06209 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l06210"></a>06210 lfsck_namespace_assistant_sync_failures_interpret(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l06211"></a>06211                                                   <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l06212"></a>06212                                                   <span class="keywordtype">void</span> *args, <span class="keywordtype">int</span> rc)
<a name="l06213"></a>06213 {
<a name="l06214"></a>06214         <span class="keywordflow">if</span> (rc == 0) {
<a name="l06215"></a>06215                 <span class="keyword">struct </span><a class="code" href="structlfsck__async__interpret__args.html">lfsck_async_interpret_args</a> *laia = args;
<a name="l06216"></a>06216                 <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a>             *ltd  = laia-&gt;laia_ltd;
<a name="l06217"></a>06217 
<a name="l06218"></a>06218                 ltd-&gt;ltd_synced_failures = 1;
<a name="l06219"></a>06219         }
<a name="l06220"></a>06220 
<a name="l06221"></a>06221         <span class="keywordflow">return</span> 0;
<a name="l06222"></a>06222 }
<a name="l06223"></a>06223 
<a name="l06245"></a>06245 <span class="keyword">static</span> <span class="keywordtype">void</span> lfsck_namespace_assistant_sync_failures(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l06246"></a>06246                                                     <span class="keyword">struct</span> <a class="code" href="structlfsck__component.html">lfsck_component</a> *com,
<a name="l06247"></a>06247                                                     <span class="keyword">struct</span> <a class="code" href="structlfsck__request.html">lfsck_request</a> *lr)
<a name="l06248"></a>06248 {
<a name="l06249"></a>06249         <span class="keyword">struct </span><a class="code" href="structlfsck__async__interpret__args.html">lfsck_async_interpret_args</a> *laia  =
<a name="l06250"></a>06250                                 &amp;lfsck_env_info(env)-&gt;lti_laia2;
<a name="l06251"></a>06251         <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__data.html">lfsck_assistant_data</a>       *lad   = com-&gt;lc_data;
<a name="l06252"></a>06252         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>            *ns    = com-&gt;lc_file_ram;
<a name="l06253"></a>06253         <span class="keyword">struct </span><a class="code" href="structlfsck__instance.html">lfsck_instance</a>             *lfsck = com-&gt;lc_lfsck;
<a name="l06254"></a>06254         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__descs.html">lfsck_tgt_descs</a>            *ltds  = &amp;lfsck-&gt;li_mdt_descs;
<a name="l06255"></a>06255         <span class="keyword">struct </span><a class="code" href="structlfsck__tgt__desc.html">lfsck_tgt_desc</a>             *ltd;
<a name="l06256"></a>06256         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__set.html" title="Definition of request set structure.">ptlrpc_request_set</a>         *<span class="keyword">set</span>;
<a name="l06257"></a>06257         __u32                              idx;
<a name="l06258"></a>06258         <span class="keywordtype">int</span>                                rc    = 0;
<a name="l06259"></a>06259         ENTRY;
<a name="l06260"></a>06260 
<a name="l06261"></a>06261         <span class="keywordflow">if</span> (!lad-&gt;lad_incomplete)
<a name="l06262"></a>06262                 RETURN_EXIT;
<a name="l06263"></a>06263 
<a name="l06264"></a>06264         <span class="keyword">set</span> = <a class="code" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT.">ptlrpc_prep_set</a>();
<a name="l06265"></a>06265         <span class="keywordflow">if</span> (<span class="keyword">set</span> == NULL)
<a name="l06266"></a>06266                 GOTO(out, rc = -ENOMEM);
<a name="l06267"></a>06267 
<a name="l06268"></a>06268         lr-&gt;lr_flags2 = ns-&gt;ln_flags | LF_INCOMPLETE;
<a name="l06269"></a>06269         memset(laia, 0, <span class="keyword">sizeof</span>(*laia));
<a name="l06270"></a>06270         lad-&gt;lad_touch_gen++;
<a name="l06271"></a>06271 
<a name="l06272"></a>06272         down_read(&amp;ltds-&gt;ltd_rw_sem);
<a name="l06273"></a>06273         cfs_foreach_bit(lad-&gt;lad_bitmap, idx) {
<a name="l06274"></a>06274                 ltd = lfsck_ltd2tgt(ltds, idx);
<a name="l06275"></a>06275                 LASSERT(ltd != NULL);
<a name="l06276"></a>06276 
<a name="l06277"></a>06277                 laia-&gt;laia_ltd = ltd;
<a name="l06278"></a>06278                 rc = lfsck_async_request(env, ltd-&gt;ltd_exp, lr, <span class="keyword">set</span>,
<a name="l06279"></a>06279                         lfsck_namespace_assistant_sync_failures_interpret,
<a name="l06280"></a>06280                         laia, LFSCK_NOTIFY);
<a name="l06281"></a>06281                 <span class="keywordflow">if</span> (rc != 0)
<a name="l06282"></a>06282                         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK assistant fail &quot;</span>
<a name="l06283"></a>06283                                <span class="stringliteral">&quot;to sync failure with MDT %x: rc = %d\n&quot;</span>,
<a name="l06284"></a>06284                                lfsck_lfsck2name(lfsck), ltd-&gt;ltd_index, rc);
<a name="l06285"></a>06285         }
<a name="l06286"></a>06286         up_read(&amp;ltds-&gt;ltd_rw_sem);
<a name="l06287"></a>06287 
<a name="l06288"></a>06288         rc = <a class="code" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set...">ptlrpc_set_wait</a>(<span class="keyword">set</span>);
<a name="l06289"></a>06289         <a class="code" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set...">ptlrpc_set_destroy</a>(<span class="keyword">set</span>);
<a name="l06290"></a>06290 
<a name="l06291"></a>06291         GOTO(out, rc);
<a name="l06292"></a>06292 
<a name="l06293"></a>06293 out:
<a name="l06294"></a>06294         <span class="keywordflow">if</span> (rc != 0)
<a name="l06295"></a>06295                 CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: namespace LFSCK assistant fail &quot;</span>
<a name="l06296"></a>06296                        <span class="stringliteral">&quot;to sync failure with MDTs, and related MDTs &quot;</span>
<a name="l06297"></a>06297                        <span class="stringliteral">&quot;may handle orphan improperly: rc = %d\n&quot;</span>,
<a name="l06298"></a>06298                        lfsck_lfsck2name(lfsck), rc);
<a name="l06299"></a>06299 
<a name="l06300"></a>06300         EXIT;
<a name="l06301"></a>06301 }
<a name="l06302"></a>06302 
<a name="l06303"></a>06303 <span class="keyword">struct </span><a class="code" href="structlfsck__assistant__operations.html">lfsck_assistant_operations</a> lfsck_namespace_assistant_ops = {
<a name="l06304"></a>06304         .la_handler_p1          = lfsck_namespace_assistant_handler_p1,
<a name="l06305"></a>06305         .la_handler_p2          = lfsck_namespace_assistant_handler_p2,
<a name="l06306"></a>06306         .la_fill_pos            = lfsck_namespace_assistant_fill_pos,
<a name="l06307"></a>06307         .la_double_scan_result  = lfsck_namespace_double_scan_result,
<a name="l06308"></a>06308         .la_req_fini            = lfsck_namespace_assistant_req_fini,
<a name="l06309"></a>06309         .la_sync_failures       = lfsck_namespace_assistant_sync_failures,
<a name="l06310"></a>06310 };
<a name="l06311"></a>06311 
<a name="l06325"></a>06325 <span class="keywordtype">int</span> lfsck_verify_linkea(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l06326"></a>06326                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a> *cname, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid)
<a name="l06327"></a>06327 {
<a name="l06328"></a>06328         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>        *dev    = lfsck_obj2dev(obj);
<a name="l06329"></a>06329         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>       ldata  = { NULL };
<a name="l06330"></a>06330         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>            linkea_buf;
<a name="l06331"></a>06331         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>          *th;
<a name="l06332"></a>06332         <span class="keywordtype">int</span>                      rc;
<a name="l06333"></a>06333         <span class="keywordtype">int</span>                      fl     = LU_XATTR_CREATE;
<a name="l06334"></a>06334         <span class="keywordtype">bool</span>                     dirty  = <span class="keyword">false</span>;
<a name="l06335"></a>06335         ENTRY;
<a name="l06336"></a>06336 
<a name="l06337"></a>06337         LASSERT(S_ISDIR(lfsck_object_type(obj)));
<a name="l06338"></a>06338 
<a name="l06339"></a>06339         rc = lfsck_links_read(env, obj, &amp;ldata);
<a name="l06340"></a>06340         <span class="keywordflow">if</span> (rc == -ENODATA) {
<a name="l06341"></a>06341                 dirty = <span class="keyword">true</span>;
<a name="l06342"></a>06342         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 0) {
<a name="l06343"></a>06343                 fl = LU_XATTR_REPLACE;
<a name="l06344"></a>06344                 <span class="keywordflow">if</span> (ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_reccount != 1) {
<a name="l06345"></a>06345                         dirty = <span class="keyword">true</span>;
<a name="l06346"></a>06346                 } <span class="keywordflow">else</span> {
<a name="l06347"></a>06347                         rc = linkea_links_find(&amp;ldata, cname, pfid);
<a name="l06348"></a>06348                         <span class="keywordflow">if</span> (rc != 0)
<a name="l06349"></a>06349                                 dirty = <span class="keyword">true</span>;
<a name="l06350"></a>06350                 }
<a name="l06351"></a>06351         }
<a name="l06352"></a>06352 
<a name="l06353"></a>06353         <span class="keywordflow">if</span> (!dirty)
<a name="l06354"></a>06354                 RETURN(rc);
<a name="l06355"></a>06355 
<a name="l06356"></a>06356         rc = linkea_data_new(&amp;ldata, &amp;lfsck_env_info(env)-&gt;lti_linkea_buf);
<a name="l06357"></a>06357         <span class="keywordflow">if</span> (rc != 0)
<a name="l06358"></a>06358                 RETURN(rc);
<a name="l06359"></a>06359 
<a name="l06360"></a>06360         rc = linkea_add_buf(&amp;ldata, cname, pfid);
<a name="l06361"></a>06361         <span class="keywordflow">if</span> (rc != 0)
<a name="l06362"></a>06362                 RETURN(rc);
<a name="l06363"></a>06363 
<a name="l06364"></a>06364         lfsck_buf_init(&amp;linkea_buf, ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf,
<a name="l06365"></a>06365                        ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len);
<a name="l06366"></a>06366         th = dt_trans_create(env, dev);
<a name="l06367"></a>06367         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l06368"></a>06368                 RETURN(PTR_ERR(th));
<a name="l06369"></a>06369 
<a name="l06370"></a>06370         rc = dt_declare_xattr_set(env, obj, &amp;linkea_buf,
<a name="l06371"></a>06371                                   XATTR_NAME_LINK, fl, th);
<a name="l06372"></a>06372         <span class="keywordflow">if</span> (rc != 0)
<a name="l06373"></a>06373                 GOTO(stop, rc);
<a name="l06374"></a>06374 
<a name="l06375"></a>06375         rc = dt_trans_start_local(env, dev, th);
<a name="l06376"></a>06376         <span class="keywordflow">if</span> (rc != 0)
<a name="l06377"></a>06377                 GOTO(stop, rc);
<a name="l06378"></a>06378 
<a name="l06379"></a>06379         dt_write_lock(env, obj, 0);
<a name="l06380"></a>06380         rc = dt_xattr_set(env, obj, &amp;linkea_buf,
<a name="l06381"></a>06381                           XATTR_NAME_LINK, fl, th);
<a name="l06382"></a>06382         dt_write_unlock(env, obj);
<a name="l06383"></a>06383 
<a name="l06384"></a>06384         GOTO(stop, rc);
<a name="l06385"></a>06385 
<a name="l06386"></a>06386 stop:
<a name="l06387"></a>06387         dt_trans_stop(env, dev, th);
<a name="l06388"></a>06388         <span class="keywordflow">return</span> rc;
<a name="l06389"></a>06389 }
<a name="l06390"></a>06390 
<a name="l06404"></a>06404 <span class="keywordtype">int</span> lfsck_links_get_first(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *obj,
<a name="l06405"></a>06405                           <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *pfid)
<a name="l06406"></a>06406 {
<a name="l06407"></a>06407         <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>           *cname = &amp;lfsck_env_info(env)-&gt;lti_name;
<a name="l06408"></a>06408         <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>        ldata = { NULL };
<a name="l06409"></a>06409         <span class="keywordtype">int</span>                       rc;
<a name="l06410"></a>06410 
<a name="l06411"></a>06411         rc = lfsck_links_read(env, obj, &amp;ldata);
<a name="l06412"></a>06412         <span class="keywordflow">if</span> (rc != 0)
<a name="l06413"></a>06413                 <span class="keywordflow">return</span> rc;
<a name="l06414"></a>06414 
<a name="l06415"></a>06415         linkea_first_entry(&amp;ldata);
<a name="l06416"></a>06416         <span class="keywordflow">if</span> (ldata.ld_lee == NULL)
<a name="l06417"></a>06417                 <span class="keywordflow">return</span> -ENODATA;
<a name="l06418"></a>06418 
<a name="l06419"></a>06419         linkea_entry_unpack(ldata.ld_lee, &amp;ldata.ld_reclen, cname, pfid);
<a name="l06420"></a>06420         <span class="comment">/* To guarantee the &apos;name&apos; is terminated with &apos;0&apos;. */</span>
<a name="l06421"></a>06421         memcpy(name, cname-&gt;ln_name, cname-&gt;ln_namelen);
<a name="l06422"></a>06422         name[cname-&gt;ln_namelen] = 0;
<a name="l06423"></a>06423 
<a name="l06424"></a>06424         <span class="keywordflow">return</span> 0;
<a name="l06425"></a>06425 }
<a name="l06426"></a>06426 
<a name="l06441"></a>06441 <span class="keywordtype">int</span> lfsck_update_name_entry(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l06442"></a>06442                             <span class="keyword">struct</span> <a class="code" href="structlfsck__instance.html">lfsck_instance</a> *lfsck,
<a name="l06443"></a>06443                             <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dir, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l06444"></a>06444                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid, __u32 type)
<a name="l06445"></a>06445 {
<a name="l06446"></a>06446         <span class="keyword">struct </span><a class="code" href="structlfsck__thread__info.html">lfsck_thread_info</a> *info   = lfsck_env_info(env);
<a name="l06447"></a>06447         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>     *rec    = &amp;info-&gt;lti_dt_rec;
<a name="l06448"></a>06448         <span class="keyword">struct </span><a class="code" href="structlfsck__lock__handle.html">lfsck_lock_handle</a> *llh    = &amp;info-&gt;lti_llh;
<a name="l06449"></a>06449         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>         *dev    = lfsck_obj2dev(dir);
<a name="l06450"></a>06450         <span class="keyword">struct </span><a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a>           *th;
<a name="l06451"></a>06451         <span class="keywordtype">int</span>                       rc;
<a name="l06452"></a>06452         <span class="keywordtype">bool</span>                      exists = <span class="keyword">true</span>;
<a name="l06453"></a>06453         ENTRY;
<a name="l06454"></a>06454 
<a name="l06455"></a>06455         rc = lfsck_lock(env, lfsck, dir, name, llh,
<a name="l06456"></a>06456                         MDS_INODELOCK_UPDATE, LCK_PW);
<a name="l06457"></a>06457         <span class="keywordflow">if</span> (rc != 0)
<a name="l06458"></a>06458                 RETURN(rc);
<a name="l06459"></a>06459 
<a name="l06460"></a>06460         th = dt_trans_create(env, dev);
<a name="l06461"></a>06461         <span class="keywordflow">if</span> (IS_ERR(th))
<a name="l06462"></a>06462                 GOTO(unlock, rc = PTR_ERR(th));
<a name="l06463"></a>06463 
<a name="l06464"></a>06464         rc = dt_declare_delete(env, dir, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l06465"></a>06465         <span class="keywordflow">if</span> (rc != 0)
<a name="l06466"></a>06466                 GOTO(stop, rc);
<a name="l06467"></a>06467 
<a name="l06468"></a>06468         rec-&gt;rec_type = type;
<a name="l06469"></a>06469         rec-&gt;rec_fid = fid;
<a name="l06470"></a>06470         rc = dt_declare_insert(env, dir, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l06471"></a>06471                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l06472"></a>06472         <span class="keywordflow">if</span> (rc != 0)
<a name="l06473"></a>06473                 GOTO(stop, rc);
<a name="l06474"></a>06474 
<a name="l06475"></a>06475         rc = dt_declare_ref_add(env, dir, th);
<a name="l06476"></a>06476         <span class="keywordflow">if</span> (rc != 0)
<a name="l06477"></a>06477                 GOTO(stop, rc);
<a name="l06478"></a>06478 
<a name="l06479"></a>06479         rc = dt_trans_start_local(env, dev, th);
<a name="l06480"></a>06480         <span class="keywordflow">if</span> (rc != 0)
<a name="l06481"></a>06481                 GOTO(stop, rc);
<a name="l06482"></a>06482 
<a name="l06483"></a>06483         rc = dt_delete(env, dir, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th);
<a name="l06484"></a>06484         <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l06485"></a>06485                 exists = <span class="keyword">false</span>;
<a name="l06486"></a>06486                 rc = 0;
<a name="l06487"></a>06487         }
<a name="l06488"></a>06488 
<a name="l06489"></a>06489         <span class="keywordflow">if</span> (rc != 0)
<a name="l06490"></a>06490                 GOTO(stop, rc);
<a name="l06491"></a>06491 
<a name="l06492"></a>06492         rc = dt_insert(env, dir, (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l06493"></a>06493                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)name, th, 1);
<a name="l06494"></a>06494         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; S_ISDIR(type) &amp;&amp; !exists) {
<a name="l06495"></a>06495                 dt_write_lock(env, dir, 0);
<a name="l06496"></a>06496                 rc = dt_ref_add(env, dir, th);
<a name="l06497"></a>06497                 dt_write_unlock(env, dir);
<a name="l06498"></a>06498         }
<a name="l06499"></a>06499 
<a name="l06500"></a>06500         GOTO(stop, rc);
<a name="l06501"></a>06501 
<a name="l06502"></a>06502 stop:
<a name="l06503"></a>06503         dt_trans_stop(env, dev, th);
<a name="l06504"></a>06504 
<a name="l06505"></a>06505 unlock:
<a name="l06506"></a>06506         lfsck_unlock(llh);
<a name="l06507"></a>06507         CDEBUG(D_LFSCK, <span class="stringliteral">&quot;%s: update name entry &quot;</span>DFID<span class="stringliteral">&quot;/%s with the FID &quot;</span>DFID
<a name="l06508"></a>06508                <span class="stringliteral">&quot; and the type %o: rc = %d\n&quot;</span>, lfsck_lfsck2name(lfsck),
<a name="l06509"></a>06509                PFID(lfsck_dto2fid(dir)), name, PFID(fid), type, rc);
<a name="l06510"></a>06510 
<a name="l06511"></a>06511         <span class="keywordflow">return</span> rc;
<a name="l06512"></a>06512 }
<a name="l06513"></a>06513 
<a name="l06514"></a>06514 <span class="keywordtype">int</span> lfsck_namespace_setup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l06515"></a>06515                           <span class="keyword">struct</span> <a class="code" href="structlfsck__instance.html">lfsck_instance</a> *lfsck)
<a name="l06516"></a>06516 {
<a name="l06517"></a>06517         <span class="keyword">struct </span><a class="code" href="structlfsck__component.html">lfsck_component</a>  *com;
<a name="l06518"></a>06518         <span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>  *ns;
<a name="l06519"></a>06519         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *root = NULL;
<a name="l06520"></a>06520         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *obj;
<a name="l06521"></a>06521         <span class="keywordtype">int</span>                      i;
<a name="l06522"></a>06522         <span class="keywordtype">int</span>                      rc;
<a name="l06523"></a>06523         ENTRY;
<a name="l06524"></a>06524 
<a name="l06525"></a>06525         LASSERT(lfsck-&gt;li_master);
<a name="l06526"></a>06526 
<a name="l06527"></a>06527         OBD_ALLOC_PTR(com);
<a name="l06528"></a>06528         <span class="keywordflow">if</span> (com == NULL)
<a name="l06529"></a>06529                 RETURN(-ENOMEM);
<a name="l06530"></a>06530 
<a name="l06531"></a>06531         INIT_LIST_HEAD(&amp;com-&gt;lc_link);
<a name="l06532"></a>06532         INIT_LIST_HEAD(&amp;com-&gt;lc_link_dir);
<a name="l06533"></a>06533         init_rwsem(&amp;com-&gt;lc_sem);
<a name="l06534"></a>06534         atomic_set(&amp;com-&gt;lc_ref, 1);
<a name="l06535"></a>06535         com-&gt;lc_lfsck = lfsck;
<a name="l06536"></a>06536         com-&gt;lc_type = LFSCK_TYPE_NAMESPACE;
<a name="l06537"></a>06537         com-&gt;lc_ops = &amp;lfsck_namespace_ops;
<a name="l06538"></a>06538         com-&gt;lc_data = lfsck_assistant_data_init(
<a name="l06539"></a>06539                         &amp;lfsck_namespace_assistant_ops,
<a name="l06540"></a>06540                         LFSCK_NAMESPACE);
<a name="l06541"></a>06541         <span class="keywordflow">if</span> (com-&gt;lc_data == NULL)
<a name="l06542"></a>06542                 GOTO(out, rc = -ENOMEM);
<a name="l06543"></a>06543 
<a name="l06544"></a>06544         com-&gt;lc_file_size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlfsck__namespace.html">lfsck_namespace</a>);
<a name="l06545"></a>06545         OBD_ALLOC(com-&gt;lc_file_ram, com-&gt;lc_file_size);
<a name="l06546"></a>06546         <span class="keywordflow">if</span> (com-&gt;lc_file_ram == NULL)
<a name="l06547"></a>06547                 GOTO(out, rc = -ENOMEM);
<a name="l06548"></a>06548 
<a name="l06549"></a>06549         OBD_ALLOC(com-&gt;lc_file_disk, com-&gt;lc_file_size);
<a name="l06550"></a>06550         <span class="keywordflow">if</span> (com-&gt;lc_file_disk == NULL)
<a name="l06551"></a>06551                 GOTO(out, rc = -ENOMEM);
<a name="l06552"></a>06552 
<a name="l06553"></a>06553         <span class="keywordflow">for</span> (i = 0; i &lt; LFSCK_STF_COUNT; i++)
<a name="l06554"></a>06554                 mutex_init(&amp;com-&gt;lc_sub_trace_objs[i].lsto_mutex);
<a name="l06555"></a>06555 
<a name="l06556"></a>06556         root = dt_locate(env, lfsck-&gt;li_bottom, &amp;lfsck-&gt;li_local_root_fid);
<a name="l06557"></a>06557         <span class="keywordflow">if</span> (IS_ERR(root))
<a name="l06558"></a>06558                 GOTO(out, rc = PTR_ERR(root));
<a name="l06559"></a>06559 
<a name="l06560"></a>06560         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, root)))
<a name="l06561"></a>06561                 GOTO(out, rc = -ENOTDIR);
<a name="l06562"></a>06562 
<a name="l06563"></a>06563         obj = local_index_find_or_create(env, lfsck-&gt;li_los, root,
<a name="l06564"></a>06564                                          LFSCK_NAMESPACE,
<a name="l06565"></a>06565                                          S_IFREG | S_IRUGO | S_IWUSR,
<a name="l06566"></a>06566                                          &amp;dt_lfsck_features);
<a name="l06567"></a>06567         <span class="keywordflow">if</span> (IS_ERR(obj))
<a name="l06568"></a>06568                 GOTO(out, rc = PTR_ERR(obj));
<a name="l06569"></a>06569 
<a name="l06570"></a>06570         com-&gt;lc_obj = obj;
<a name="l06571"></a>06571         rc = lfsck_namespace_load(env, com);
<a name="l06572"></a>06572         <span class="keywordflow">if</span> (rc == -ENODATA)
<a name="l06573"></a>06573                 rc = lfsck_namespace_init(env, com);
<a name="l06574"></a>06574         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l06575"></a>06575                 rc = lfsck_namespace_reset(env, com, <span class="keyword">true</span>);
<a name="l06576"></a>06576         <span class="keywordflow">else</span>
<a name="l06577"></a>06577                 rc = lfsck_namespace_load_sub_trace_files(env, com, <span class="keyword">false</span>);
<a name="l06578"></a>06578         <span class="keywordflow">if</span> (rc != 0)
<a name="l06579"></a>06579                 GOTO(out, rc);
<a name="l06580"></a>06580 
<a name="l06581"></a>06581         ns = com-&gt;lc_file_ram;
<a name="l06582"></a>06582         <span class="keywordflow">switch</span> (ns-&gt;ln_status) {
<a name="l06583"></a>06583         <span class="keywordflow">case</span> LS_INIT:
<a name="l06584"></a>06584         <span class="keywordflow">case</span> LS_COMPLETED:
<a name="l06585"></a>06585         <span class="keywordflow">case</span> LS_FAILED:
<a name="l06586"></a>06586         <span class="keywordflow">case</span> LS_STOPPED:
<a name="l06587"></a>06587                 spin_lock(&amp;lfsck-&gt;li_lock);
<a name="l06588"></a>06588                 list_add_tail(&amp;com-&gt;lc_link, &amp;lfsck-&gt;li_list_idle);
<a name="l06589"></a>06589                 spin_unlock(&amp;lfsck-&gt;li_lock);
<a name="l06590"></a>06590                 <span class="keywordflow">break</span>;
<a name="l06591"></a>06591         <span class="keywordflow">default</span>:
<a name="l06592"></a>06592                 CERROR(<span class="stringliteral">&quot;%s: unknown lfsck_namespace status %d\n&quot;</span>,
<a name="l06593"></a>06593                        lfsck_lfsck2name(lfsck), ns-&gt;ln_status);
<a name="l06594"></a>06594                 <span class="comment">/* fall through */</span>
<a name="l06595"></a>06595         <span class="keywordflow">case</span> LS_SCANNING_PHASE1:
<a name="l06596"></a>06596         <span class="keywordflow">case</span> LS_SCANNING_PHASE2:
<a name="l06597"></a>06597                 <span class="comment">/* No need to store the status to disk right now.</span>
<a name="l06598"></a>06598 <span class="comment">                 * If the system crashed before the status stored,</span>
<a name="l06599"></a>06599 <span class="comment">                 * it will be loaded back when next time. */</span>
<a name="l06600"></a>06600                 ns-&gt;ln_status = LS_CRASHED;
<a name="l06601"></a>06601                 <span class="comment">/* fall through */</span>
<a name="l06602"></a>06602         <span class="keywordflow">case</span> LS_PAUSED:
<a name="l06603"></a>06603         <span class="keywordflow">case</span> LS_CRASHED:
<a name="l06604"></a>06604                 spin_lock(&amp;lfsck-&gt;li_lock);
<a name="l06605"></a>06605                 list_add_tail(&amp;com-&gt;lc_link, &amp;lfsck-&gt;li_list_scan);
<a name="l06606"></a>06606                 list_add_tail(&amp;com-&gt;lc_link_dir, &amp;lfsck-&gt;li_list_dir);
<a name="l06607"></a>06607                 spin_unlock(&amp;lfsck-&gt;li_lock);
<a name="l06608"></a>06608                 <span class="keywordflow">break</span>;
<a name="l06609"></a>06609         }
<a name="l06610"></a>06610 
<a name="l06611"></a>06611         GOTO(out, rc = 0);
<a name="l06612"></a>06612 
<a name="l06613"></a>06613 out:
<a name="l06614"></a>06614         <span class="keywordflow">if</span> (root != NULL &amp;&amp; !IS_ERR(root))
<a name="l06615"></a>06615                 lfsck_object_put(env, root);
<a name="l06616"></a>06616         <span class="keywordflow">if</span> (rc != 0) {
<a name="l06617"></a>06617                 lfsck_component_cleanup(env, com);
<a name="l06618"></a>06618                 CERROR(<span class="stringliteral">&quot;%s: fail to init namespace LFSCK component: rc = %d\n&quot;</span>,
<a name="l06619"></a>06619                        lfsck_lfsck2name(lfsck), rc);
<a name="l06620"></a>06620         }
<a name="l06621"></a>06621         <span class="keywordflow">return</span> rc;
<a name="l06622"></a>06622 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:15 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
