<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/llite/file.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/llite/file.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lustre/llite/file.c</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Author: Peter Braam &lt;braam@clusterfs.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> * Author: Phil Schwan &lt;phil@clusterfs.com&gt;</span>
<a name="l00040"></a>00040 <span class="comment"> * Author: Andreas Dilger &lt;adilger@clusterfs.com&gt;</span>
<a name="l00041"></a>00041 <span class="comment"> */</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_LLITE</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#include &lt;lustre_dlm.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;linux/pagemap.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;linux/file.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;linux/sched.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;linux/user_namespace.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#ifdef HAVE_UIDGID_HEADER</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor"># include &lt;linux/uidgid.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#endif</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#include &lt;lustre/ll_fiemap.h&gt;</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;lustre_ioctl.h&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;lustre_swab.h&gt;</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;cl_object.h&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;llite_internal.h&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;vvp_internal.h&quot;</span>
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00062"></a>00062 ll_put_grouplock(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg);
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_lease_close(<span class="keyword">struct</span> <a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och, <span class="keyword">struct</span> inode *inode,
<a name="l00065"></a>00065                           <span class="keywordtype">bool</span> *lease_broken);
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="keyword">static</span> <span class="keyword">enum</span> llioc_iter
<a name="l00068"></a>00068 ll_iocontrol_call(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file,
<a name="l00069"></a>00069                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg, <span class="keywordtype">int</span> *rcp);
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a> *ll_file_data_get(<span class="keywordtype">void</span>)
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073         <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a> *fd;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         OBD_SLAB_ALLOC_PTR_GFP(fd, ll_file_data_slab, GFP_NOFS);
<a name="l00076"></a>00076         <span class="keywordflow">if</span> (fd == NULL)
<a name="l00077"></a>00077                 <span class="keywordflow">return</span> NULL;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079         fd-&gt;fd_write_failed = <span class="keyword">false</span>;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081         <span class="keywordflow">return</span> fd;
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="keyword">static</span> <span class="keywordtype">void</span> ll_file_data_put(<span class="keyword">struct</span> <a class="code" href="structll__file__data.html">ll_file_data</a> *fd)
<a name="l00085"></a>00085 {
<a name="l00086"></a>00086         <span class="keywordflow">if</span> (fd != NULL)
<a name="l00087"></a>00087                 OBD_SLAB_FREE_PTR(fd, ll_file_data_slab);
<a name="l00088"></a>00088 }
<a name="l00089"></a>00089 
<a name="l00093"></a>00093 <span class="keyword">static</span> <span class="keywordtype">void</span> ll_prepare_close(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> <a class="code" href="structmd__op__data.html">md_op_data</a> *op_data,
<a name="l00094"></a>00094                              <span class="keyword">struct</span> <a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och)
<a name="l00095"></a>00095 {
<a name="l00096"></a>00096         ENTRY;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098         ll_prep_md_op_data(op_data, inode, NULL, NULL,
<a name="l00099"></a>00099                            0, 0, LUSTRE_OPC_ANY, NULL);
<a name="l00100"></a>00100 
<a name="l00101"></a>00101         op_data-&gt;op_attr.ia_mode = inode-&gt;i_mode;
<a name="l00102"></a>00102         op_data-&gt;op_attr.ia_atime = inode-&gt;i_atime;
<a name="l00103"></a>00103         op_data-&gt;op_attr.ia_mtime = inode-&gt;i_mtime;
<a name="l00104"></a>00104         op_data-&gt;op_attr.ia_ctime = inode-&gt;i_ctime;
<a name="l00105"></a>00105         op_data-&gt;op_attr.ia_size = i_size_read(inode);
<a name="l00106"></a>00106         op_data-&gt;op_attr.ia_valid |= ATTR_MODE | ATTR_ATIME | ATTR_ATIME_SET |
<a name="l00107"></a>00107                                      ATTR_MTIME | ATTR_MTIME_SET |
<a name="l00108"></a>00108                                      ATTR_CTIME | ATTR_CTIME_SET;
<a name="l00109"></a>00109         op_data-&gt;op_attr_blocks = inode-&gt;i_blocks;
<a name="l00110"></a>00110         op_data-&gt;op_attr_flags = ll_inode_to_ext_flags(inode-&gt;i_flags);
<a name="l00111"></a>00111         op_data-&gt;op_handle = och-&gt;och_fh;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         <span class="keywordflow">if</span> (och-&gt;och_flags &amp; FMODE_WRITE &amp;&amp;
<a name="l00114"></a>00114             ll_file_test_and_clear_flag(ll_i2info(inode), LLIF_DATA_MODIFIED))
<a name="l00115"></a>00115                 <span class="comment">/* For HSM: if inode data has been modified, pack it so that</span>
<a name="l00116"></a>00116 <span class="comment">                 * MDT can set data dirty flag in the archive. */</span>
<a name="l00117"></a>00117                 op_data-&gt;op_bias |= MDS_DATA_MODIFIED;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119         EXIT;
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00130"></a>00130 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_close_inode_openhandle(<span class="keyword">struct</span> inode *inode,
<a name="l00131"></a>00131                                      <span class="keyword">struct</span> <a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och,
<a name="l00132"></a>00132                                      <span class="keyword">enum</span> mds_op_bias bias, <span class="keywordtype">void</span> *data)
<a name="l00133"></a>00133 {
<a name="l00134"></a>00134         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *md_exp = ll_i2mdexp(inode);
<a name="l00135"></a>00135         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l00136"></a>00136         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a> *op_data;
<a name="l00137"></a>00137         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = NULL;
<a name="l00138"></a>00138         <span class="keywordtype">int</span> rc;
<a name="l00139"></a>00139         ENTRY;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141         <span class="keywordflow">if</span> (class_exp2obd(md_exp) == NULL) {
<a name="l00142"></a>00142                 CERROR(<span class="stringliteral">&quot;%s: invalid MDC connection handle closing &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00143"></a>00143                        ll_get_fsname(inode-&gt;i_sb, NULL, 0),
<a name="l00144"></a>00144                        PFID(&amp;lli-&gt;lli_fid));
<a name="l00145"></a>00145                 GOTO(out, rc = 0);
<a name="l00146"></a>00146         }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148         OBD_ALLOC_PTR(op_data);
<a name="l00149"></a>00149         <span class="comment">/* We leak openhandle and request here on error, but not much to be</span>
<a name="l00150"></a>00150 <span class="comment">         * done in OOM case since app won&apos;t retry close on error either. */</span>
<a name="l00151"></a>00151         <span class="keywordflow">if</span> (op_data == NULL)
<a name="l00152"></a>00152                 GOTO(out, rc = -ENOMEM);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         ll_prepare_close(inode, op_data, och);
<a name="l00155"></a>00155         <span class="keywordflow">switch</span> (bias) {
<a name="l00156"></a>00156         <span class="keywordflow">case</span> MDS_CLOSE_LAYOUT_SWAP:
<a name="l00157"></a>00157                 LASSERT(data != NULL);
<a name="l00158"></a>00158                 op_data-&gt;op_bias |= MDS_CLOSE_LAYOUT_SWAP;
<a name="l00159"></a>00159                 op_data-&gt;op_data_version = 0;
<a name="l00160"></a>00160                 op_data-&gt;op_lease_handle = och-&gt;och_lease_handle;
<a name="l00161"></a>00161                 op_data-&gt;op_fid2 = *ll_inode2fid(data);
<a name="l00162"></a>00162                 <span class="keywordflow">break</span>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         <span class="keywordflow">case</span> MDS_HSM_RELEASE:
<a name="l00165"></a>00165                 LASSERT(data != NULL);
<a name="l00166"></a>00166                 op_data-&gt;op_bias |= MDS_HSM_RELEASE;
<a name="l00167"></a>00167                 op_data-&gt;op_data_version = *(__u64 *)data;
<a name="l00168"></a>00168                 op_data-&gt;op_lease_handle = och-&gt;och_lease_handle;
<a name="l00169"></a>00169                 op_data-&gt;op_attr.ia_valid |= ATTR_SIZE | ATTR_BLOCKS;
<a name="l00170"></a>00170                 <span class="keywordflow">break</span>;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172         <span class="keywordflow">default</span>:
<a name="l00173"></a>00173                 LASSERT(data == NULL);
<a name="l00174"></a>00174                 <span class="keywordflow">break</span>;
<a name="l00175"></a>00175         }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         rc = md_close(md_exp, op_data, och-&gt;och_mod, &amp;req);
<a name="l00178"></a>00178         <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -EINTR)
<a name="l00179"></a>00179                 CERROR(<span class="stringliteral">&quot;%s: inode &quot;</span>DFID<span class="stringliteral">&quot; mdc close failed: rc = %d\n&quot;</span>,
<a name="l00180"></a>00180                        md_exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;obd_name, PFID(&amp;lli-&gt;lli_fid), rc);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182         <span class="keywordflow">if</span> (rc == 0 &amp;&amp;
<a name="l00183"></a>00183             op_data-&gt;op_bias &amp; (MDS_HSM_RELEASE | MDS_CLOSE_LAYOUT_SWAP)) {
<a name="l00184"></a>00184                 <span class="keyword">struct </span><a class="code" href="structmdt__body.html">mdt_body</a> *body;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186                 body = <a class="code" href="group__req__layout.html#ga0d1ad53a1914c35470f3916e4bb4b8fe" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC reply buffer...">req_capsule_server_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_MDT_BODY);
<a name="l00187"></a>00187                 <span class="keywordflow">if</span> (!(body-&gt;mbo_valid &amp; OBD_MD_CLOSE_INTENT_EXECED))
<a name="l00188"></a>00188                         rc = -EBUSY;
<a name="l00189"></a>00189         }
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         ll_finish_md_op_data(op_data);
<a name="l00192"></a>00192         EXIT;
<a name="l00193"></a>00193 out:
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         md_clear_open_replay_data(md_exp, och);
<a name="l00196"></a>00196         och-&gt;och_fh.cookie = DEAD_HANDLE_MAGIC;
<a name="l00197"></a>00197         OBD_FREE_PTR(och);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);       <span class="comment">/* This is close request */</span>
<a name="l00200"></a>00200         <span class="keywordflow">return</span> rc;
<a name="l00201"></a>00201 }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 <span class="keywordtype">int</span> ll_md_real_close(<span class="keyword">struct</span> inode *inode, fmode_t fmode)
<a name="l00204"></a>00204 {
<a name="l00205"></a>00205         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l00206"></a>00206         <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> **och_p;
<a name="l00207"></a>00207         <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och;
<a name="l00208"></a>00208         __u64 *och_usecount;
<a name="l00209"></a>00209         <span class="keywordtype">int</span> rc = 0;
<a name="l00210"></a>00210         ENTRY;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         <span class="keywordflow">if</span> (fmode &amp; FMODE_WRITE) {
<a name="l00213"></a>00213                 och_p = &amp;lli-&gt;lli_mds_write_och;
<a name="l00214"></a>00214                 och_usecount = &amp;lli-&gt;lli_open_fd_write_count;
<a name="l00215"></a>00215         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fmode &amp; FMODE_EXEC) {
<a name="l00216"></a>00216                 och_p = &amp;lli-&gt;lli_mds_exec_och;
<a name="l00217"></a>00217                 och_usecount = &amp;lli-&gt;lli_open_fd_exec_count;
<a name="l00218"></a>00218         } <span class="keywordflow">else</span> {
<a name="l00219"></a>00219                 LASSERT(fmode &amp; FMODE_READ);
<a name="l00220"></a>00220                 och_p = &amp;lli-&gt;lli_mds_read_och;
<a name="l00221"></a>00221                 och_usecount = &amp;lli-&gt;lli_open_fd_read_count;
<a name="l00222"></a>00222         }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224         mutex_lock(&amp;lli-&gt;lli_och_mutex);
<a name="l00225"></a>00225         <span class="keywordflow">if</span> (*och_usecount &gt; 0) {
<a name="l00226"></a>00226                 <span class="comment">/* There are still users of this handle, so skip</span>
<a name="l00227"></a>00227 <span class="comment">                 * freeing it. */</span>
<a name="l00228"></a>00228                 mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00229"></a>00229                 RETURN(0);
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232         och = *och_p;
<a name="l00233"></a>00233         *och_p = NULL;
<a name="l00234"></a>00234         mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         <span class="keywordflow">if</span> (och != NULL) {
<a name="l00237"></a>00237                 <span class="comment">/* There might be a race and this handle may already</span>
<a name="l00238"></a>00238 <span class="comment">                 * be closed. */</span>
<a name="l00239"></a>00239                 rc = ll_close_inode_openhandle(inode, och, 0, NULL);
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         RETURN(rc);
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_md_close(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247         <span class="keyword">union </span><a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> policy = {
<a name="l00248"></a>00248                 .l_inodebits    = { MDS_INODELOCK_OPEN },
<a name="l00249"></a>00249         };
<a name="l00250"></a>00250         __u64 flags = <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a> | <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>;
<a name="l00251"></a>00251         <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a> *fd = LUSTRE_FPRIVATE(file);
<a name="l00252"></a>00252         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l00253"></a>00253         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lockh;
<a name="l00254"></a>00254         <span class="keyword">enum</span> ldlm_mode lockmode;
<a name="l00255"></a>00255         <span class="keywordtype">int</span> rc = 0;
<a name="l00256"></a>00256         ENTRY;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         <span class="comment">/* clear group lock, if present */</span>
<a name="l00259"></a>00259         <span class="keywordflow">if</span> (unlikely(fd-&gt;fd_flags &amp; LL_FILE_GROUP_LOCKED))
<a name="l00260"></a>00260                 ll_put_grouplock(inode, file, fd-&gt;fd_grouplock.lg_gid);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         <span class="keywordflow">if</span> (fd-&gt;fd_lease_och != NULL) {
<a name="l00263"></a>00263                 <span class="keywordtype">bool</span> lease_broken;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265                 <span class="comment">/* Usually the lease is not released when the</span>
<a name="l00266"></a>00266 <span class="comment">                 * application crashed, we need to release here. */</span>
<a name="l00267"></a>00267                 rc = ll_lease_close(fd-&gt;fd_lease_och, inode, &amp;lease_broken);
<a name="l00268"></a>00268                 CDEBUG(rc ? D_ERROR : D_INODE, <span class="stringliteral">&quot;Clean up lease &quot;</span>DFID<span class="stringliteral">&quot; %d/%d\n&quot;</span>,
<a name="l00269"></a>00269                         PFID(&amp;lli-&gt;lli_fid), rc, lease_broken);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271                 fd-&gt;fd_lease_och = NULL;
<a name="l00272"></a>00272         }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274         <span class="keywordflow">if</span> (fd-&gt;fd_och != NULL) {
<a name="l00275"></a>00275                 rc = ll_close_inode_openhandle(inode, fd-&gt;fd_och, 0, NULL);
<a name="l00276"></a>00276                 fd-&gt;fd_och = NULL;
<a name="l00277"></a>00277                 GOTO(out, rc);
<a name="l00278"></a>00278         }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280         <span class="comment">/* Let&apos;s see if we have good enough OPEN lock on the file and if</span>
<a name="l00281"></a>00281 <span class="comment">           we can skip talking to MDS */</span>
<a name="l00282"></a>00282         mutex_lock(&amp;lli-&gt;lli_och_mutex);
<a name="l00283"></a>00283         <span class="keywordflow">if</span> (fd-&gt;fd_omode &amp; FMODE_WRITE) {
<a name="l00284"></a>00284                 lockmode = LCK_CW;
<a name="l00285"></a>00285                 LASSERT(lli-&gt;lli_open_fd_write_count);
<a name="l00286"></a>00286                 lli-&gt;lli_open_fd_write_count--;
<a name="l00287"></a>00287         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fd-&gt;fd_omode &amp; FMODE_EXEC) {
<a name="l00288"></a>00288                 lockmode = LCK_PR;
<a name="l00289"></a>00289                 LASSERT(lli-&gt;lli_open_fd_exec_count);
<a name="l00290"></a>00290                 lli-&gt;lli_open_fd_exec_count--;
<a name="l00291"></a>00291         } <span class="keywordflow">else</span> {
<a name="l00292"></a>00292                 lockmode = LCK_CR;
<a name="l00293"></a>00293                 LASSERT(lli-&gt;lli_open_fd_read_count);
<a name="l00294"></a>00294                 lli-&gt;lli_open_fd_read_count--;
<a name="l00295"></a>00295         }
<a name="l00296"></a>00296         mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00297"></a>00297 
<a name="l00298"></a>00298         <span class="keywordflow">if</span> (!md_lock_match(ll_i2mdexp(inode), flags, ll_inode2fid(inode),
<a name="l00299"></a>00299                            LDLM_IBITS, &amp;policy, lockmode, &amp;lockh))
<a name="l00300"></a>00300                 rc = ll_md_real_close(inode, fd-&gt;fd_omode);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 out:
<a name="l00303"></a>00303         LUSTRE_FPRIVATE(file) = NULL;
<a name="l00304"></a>00304         ll_file_data_put(fd);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306         RETURN(rc);
<a name="l00307"></a>00307 }
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="comment">/* While this returns an error code, fput() the caller does not, so we need</span>
<a name="l00310"></a>00310 <span class="comment"> * to make every effort to clean up all of our state here.  Also, applications</span>
<a name="l00311"></a>00311 <span class="comment"> * rarely check close errors and even if an error is returned they will not</span>
<a name="l00312"></a>00312 <span class="comment"> * re-try the close call.</span>
<a name="l00313"></a>00313 <span class="comment"> */</span>
<a name="l00314"></a>00314 <span class="keywordtype">int</span> ll_file_release(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316         <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a> *fd;
<a name="l00317"></a>00317         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a> *sbi = ll_i2sbi(inode);
<a name="l00318"></a>00318         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l00319"></a>00319         <span class="keywordtype">int</span> rc;
<a name="l00320"></a>00320         ENTRY;
<a name="l00321"></a>00321 
<a name="l00322"></a>00322         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;VFS Op:inode=&quot;</span>DFID<span class="stringliteral">&quot;(%p)\n&quot;</span>,
<a name="l00323"></a>00323                PFID(ll_inode2fid(inode)), inode);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="preprocessor">#ifdef CONFIG_FS_POSIX_ACL</span>
<a name="l00326"></a>00326 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (sbi-&gt;ll_flags &amp; LL_SBI_RMT_CLIENT &amp;&amp;
<a name="l00327"></a>00327             inode == inode-&gt;i_sb-&gt;s_root-&gt;d_inode) {
<a name="l00328"></a>00328                 <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a> *fd = LUSTRE_FPRIVATE(file);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330                 LASSERT(fd != NULL);
<a name="l00331"></a>00331                 <span class="keywordflow">if</span> (unlikely(fd-&gt;fd_flags &amp; LL_FILE_RMTACL)) {
<a name="l00332"></a>00332                         fd-&gt;fd_flags &amp;= ~LL_FILE_RMTACL;
<a name="l00333"></a>00333                         rct_del(&amp;sbi-&gt;ll_rct, current_pid());
<a name="l00334"></a>00334                         et_search_free(&amp;sbi-&gt;ll_et, current_pid());
<a name="l00335"></a>00335                 }
<a name="l00336"></a>00336         }
<a name="l00337"></a>00337 <span class="preprocessor">#endif</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span>
<a name="l00339"></a>00339         <span class="keywordflow">if</span> (inode-&gt;i_sb-&gt;s_root != file-&gt;f_path.dentry)
<a name="l00340"></a>00340                 ll_stats_ops_tally(sbi, LPROC_LL_RELEASE, 1);
<a name="l00341"></a>00341         fd = LUSTRE_FPRIVATE(file);
<a name="l00342"></a>00342         LASSERT(fd != NULL);
<a name="l00343"></a>00343 
<a name="l00344"></a>00344         <span class="comment">/* The last ref on @file, maybe not the the owner pid of statahead,</span>
<a name="l00345"></a>00345 <span class="comment">         * because parent and child process can share the same file handle. */</span>
<a name="l00346"></a>00346         <span class="keywordflow">if</span> (S_ISDIR(inode-&gt;i_mode) &amp;&amp; lli-&gt;lli_opendir_key == fd)
<a name="l00347"></a>00347                 ll_deauthorize_statahead(inode, fd);
<a name="l00348"></a>00348 
<a name="l00349"></a>00349         <span class="keywordflow">if</span> (inode-&gt;i_sb-&gt;s_root == file-&gt;f_path.dentry) {
<a name="l00350"></a>00350                 LUSTRE_FPRIVATE(file) = NULL;
<a name="l00351"></a>00351                 ll_file_data_put(fd);
<a name="l00352"></a>00352                 RETURN(0);
<a name="l00353"></a>00353         }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         <span class="keywordflow">if</span> (!S_ISDIR(inode-&gt;i_mode)) {
<a name="l00356"></a>00356                 <span class="keywordflow">if</span> (lli-&gt;lli_clob != NULL)
<a name="l00357"></a>00357                         lov_read_and_clear_async_rc(lli-&gt;lli_clob);
<a name="l00358"></a>00358                 lli-&gt;lli_async_rc = 0;
<a name="l00359"></a>00359         }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361         rc = ll_md_close(inode, file);
<a name="l00362"></a>00362 
<a name="l00363"></a>00363         <span class="keywordflow">if</span> (CFS_FAIL_TIMEOUT_MS(OBD_FAIL_PTLRPC_DUMP_LOG, cfs_fail_val))
<a name="l00364"></a>00364                 libcfs_debug_dumplog();
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         RETURN(rc);
<a name="l00367"></a>00367 }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_intent_file_open(<span class="keyword">struct</span> file *file, <span class="keywordtype">void</span> *lmm, <span class="keywordtype">int</span> lmmsize,
<a name="l00370"></a>00370                                 <span class="keyword">struct</span> <a class="code" href="structlookup__intent.html">lookup_intent</a> *itp)
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372         <span class="keyword">struct </span>dentry *de = file-&gt;f_path.dentry;
<a name="l00373"></a>00373         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a> *sbi = ll_i2sbi(de-&gt;d_inode);
<a name="l00374"></a>00374         <span class="keyword">struct </span>dentry *parent = de-&gt;d_parent;
<a name="l00375"></a>00375         <span class="keyword">const</span> <span class="keywordtype">char</span> *name = NULL;
<a name="l00376"></a>00376         <span class="keywordtype">int</span> len = 0;
<a name="l00377"></a>00377         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a> *op_data;
<a name="l00378"></a>00378         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = NULL;
<a name="l00379"></a>00379         <span class="keywordtype">int</span> rc;
<a name="l00380"></a>00380         ENTRY;
<a name="l00381"></a>00381 
<a name="l00382"></a>00382         LASSERT(parent != NULL);
<a name="l00383"></a>00383         LASSERT(itp-&gt;it_flags &amp; MDS_OPEN_BY_FID);
<a name="l00384"></a>00384 
<a name="l00385"></a>00385         <span class="comment">/* if server supports open-by-fid, or file name is invalid, don&apos;t pack</span>
<a name="l00386"></a>00386 <span class="comment">         * name in open request */</span>
<a name="l00387"></a>00387         <span class="keywordflow">if</span> (!(exp_connect_flags(sbi-&gt;ll_md_exp) &amp; OBD_CONNECT_OPEN_BY_FID) &amp;&amp;
<a name="l00388"></a>00388             lu_name_is_valid_2(de-&gt;d_name.name, de-&gt;d_name.len)) {
<a name="l00389"></a>00389                 name = de-&gt;d_name.name;
<a name="l00390"></a>00390                 len = de-&gt;d_name.len;
<a name="l00391"></a>00391         }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393         op_data = ll_prep_md_op_data(NULL, parent-&gt;d_inode, de-&gt;d_inode,
<a name="l00394"></a>00394                                      name, len, 0, LUSTRE_OPC_ANY, NULL);
<a name="l00395"></a>00395         <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l00396"></a>00396                 RETURN(PTR_ERR(op_data));
<a name="l00397"></a>00397         op_data-&gt;op_data = lmm;
<a name="l00398"></a>00398         op_data-&gt;op_data_size = lmmsize;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400         rc = md_intent_lock(sbi-&gt;ll_md_exp, op_data, itp, &amp;req,
<a name="l00401"></a>00401                             &amp;ll_md_blocking_ast, 0);
<a name="l00402"></a>00402         ll_finish_md_op_data(op_data);
<a name="l00403"></a>00403         <span class="keywordflow">if</span> (rc == -ESTALE) {
<a name="l00404"></a>00404                 <span class="comment">/* reason for keep own exit path - don`t flood log</span>
<a name="l00405"></a>00405 <span class="comment">                 * with messages with -ESTALE errors.</span>
<a name="l00406"></a>00406 <span class="comment">                 */</span>
<a name="l00407"></a>00407                 <span class="keywordflow">if</span> (!it_disposition(itp, DISP_OPEN_OPEN) ||
<a name="l00408"></a>00408                      it_open_error(DISP_OPEN_OPEN, itp))
<a name="l00409"></a>00409                         GOTO(out, rc);
<a name="l00410"></a>00410                 ll_release_openhandle(de, itp);
<a name="l00411"></a>00411                 GOTO(out, rc);
<a name="l00412"></a>00412         }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414         <span class="keywordflow">if</span> (it_disposition(itp, DISP_LOOKUP_NEG))
<a name="l00415"></a>00415                 GOTO(out, rc = -ENOENT);
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         <span class="keywordflow">if</span> (rc != 0 || it_open_error(DISP_OPEN_OPEN, itp)) {
<a name="l00418"></a>00418                 rc = rc ? rc : it_open_error(DISP_OPEN_OPEN, itp);
<a name="l00419"></a>00419                 CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;lock enqueue: err: %d\n&quot;</span>, rc);
<a name="l00420"></a>00420                 GOTO(out, rc);
<a name="l00421"></a>00421         }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         rc = ll_prep_inode(&amp;de-&gt;d_inode, req, NULL, itp);
<a name="l00424"></a>00424         <span class="keywordflow">if</span> (!rc &amp;&amp; itp-&gt;it_lock_mode)
<a name="l00425"></a>00425                 ll_set_lock_data(sbi-&gt;ll_md_exp, de-&gt;d_inode, itp, NULL);
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 out:
<a name="l00428"></a>00428         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l00429"></a>00429         ll_intent_drop_lock(itp);
<a name="l00430"></a>00430 
<a name="l00431"></a>00431         RETURN(rc);
<a name="l00432"></a>00432 }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_och_fill(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *md_exp, <span class="keyword">struct</span> <a class="code" href="structlookup__intent.html">lookup_intent</a> *it,
<a name="l00435"></a>00435                        <span class="keyword">struct</span> <a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och)
<a name="l00436"></a>00436 {
<a name="l00437"></a>00437         <span class="keyword">struct </span><a class="code" href="structmdt__body.html">mdt_body</a> *body;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         body = <a class="code" href="group__req__layout.html#ga0d1ad53a1914c35470f3916e4bb4b8fe" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC reply buffer...">req_capsule_server_get</a>(&amp;it-&gt;it_request-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_MDT_BODY);
<a name="l00440"></a>00440         och-&gt;och_fh = body-&gt;mbo_handle;
<a name="l00441"></a>00441         och-&gt;och_fid = body-&gt;mbo_fid1;
<a name="l00442"></a>00442         och-&gt;och_lease_handle.cookie = it-&gt;it_lock_handle;
<a name="l00443"></a>00443         och-&gt;och_magic = OBD_CLIENT_HANDLE_MAGIC;
<a name="l00444"></a>00444         och-&gt;och_flags = it-&gt;it_flags;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446         <span class="keywordflow">return</span> md_set_open_replay_data(md_exp, och, it);
<a name="l00447"></a>00447 }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_local_open(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> <a class="code" href="structlookup__intent.html">lookup_intent</a> *it,
<a name="l00450"></a>00450                          <span class="keyword">struct</span> <a class="code" href="structll__file__data.html">ll_file_data</a> *fd, <span class="keyword">struct</span> <a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och)
<a name="l00451"></a>00451 {
<a name="l00452"></a>00452         <span class="keyword">struct </span>inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l00453"></a>00453         ENTRY;
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         LASSERT(!LUSTRE_FPRIVATE(file));
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         LASSERT(fd != NULL);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         <span class="keywordflow">if</span> (och) {
<a name="l00460"></a>00460                 <span class="keywordtype">int</span> rc;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462                 rc = ll_och_fill(ll_i2sbi(inode)-&gt;ll_md_exp, it, och);
<a name="l00463"></a>00463                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00464"></a>00464                         RETURN(rc);
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         LUSTRE_FPRIVATE(file) = fd;
<a name="l00468"></a>00468         ll_readahead_init(inode, &amp;fd-&gt;fd_ras);
<a name="l00469"></a>00469         fd-&gt;fd_omode = it-&gt;it_flags &amp; (FMODE_READ | FMODE_WRITE | FMODE_EXEC);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         <span class="comment">/* ll_cl_context initialize */</span>
<a name="l00472"></a>00472         rwlock_init(&amp;fd-&gt;fd_lock);
<a name="l00473"></a>00473         INIT_LIST_HEAD(&amp;fd-&gt;fd_lccs);
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         RETURN(0);
<a name="l00476"></a>00476 }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="comment">/* Open a file, and (for the very first open) create objects on the OSTs at</span>
<a name="l00479"></a>00479 <span class="comment"> * this time.  If opened with O_LOV_DELAY_CREATE, then we don&apos;t do the object</span>
<a name="l00480"></a>00480 <span class="comment"> * creation or open until ll_lov_setstripe() ioctl is called.</span>
<a name="l00481"></a>00481 <span class="comment"> *</span>
<a name="l00482"></a>00482 <span class="comment"> * If we already have the stripe MD locally then we don&apos;t request it in</span>
<a name="l00483"></a>00483 <span class="comment"> * md_open(), by passing a lmm_size = 0.</span>
<a name="l00484"></a>00484 <span class="comment"> *</span>
<a name="l00485"></a>00485 <span class="comment"> * It is up to the application to ensure no other processes open this file</span>
<a name="l00486"></a>00486 <span class="comment"> * in the O_LOV_DELAY_CREATE case, or the default striping pattern will be</span>
<a name="l00487"></a>00487 <span class="comment"> * used.  We might be able to avoid races of that sort by getting lli_open_sem</span>
<a name="l00488"></a>00488 <span class="comment"> * before returning in the O_LOV_DELAY_CREATE case and dropping it here</span>
<a name="l00489"></a>00489 <span class="comment"> * or in ll_file_release(), but I&apos;m not sure that is desirable/necessary.</span>
<a name="l00490"></a>00490 <span class="comment"> */</span>
<a name="l00491"></a>00491 <span class="keywordtype">int</span> ll_file_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)
<a name="l00492"></a>00492 {
<a name="l00493"></a>00493         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l00494"></a>00494         <span class="keyword">struct </span><a class="code" href="structlookup__intent.html">lookup_intent</a> *it, oit = { .it_op = IT_OPEN,
<a name="l00495"></a>00495                                           .it_flags = file-&gt;f_flags };
<a name="l00496"></a>00496         <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> **och_p = NULL;
<a name="l00497"></a>00497         __u64 *och_usecount = NULL;
<a name="l00498"></a>00498         <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a> *fd;
<a name="l00499"></a>00499         <span class="keywordtype">int</span> rc = 0;
<a name="l00500"></a>00500         ENTRY;
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;VFS Op:inode=&quot;</span>DFID<span class="stringliteral">&quot;(%p), flags %o\n&quot;</span>,
<a name="l00503"></a>00503                PFID(ll_inode2fid(inode)), inode, file-&gt;f_flags);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         it = file-&gt;private_data; <span class="comment">/* XXX: compat macro */</span>
<a name="l00506"></a>00506         file-&gt;private_data = NULL; <span class="comment">/* prevent ll_local_open assertion */</span>
<a name="l00507"></a>00507 
<a name="l00508"></a>00508         fd = ll_file_data_get();
<a name="l00509"></a>00509         <span class="keywordflow">if</span> (fd == NULL)
<a name="l00510"></a>00510                 GOTO(out_openerr, rc = -ENOMEM);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         fd-&gt;fd_file = file;
<a name="l00513"></a>00513         <span class="keywordflow">if</span> (S_ISDIR(inode-&gt;i_mode))
<a name="l00514"></a>00514                 ll_authorize_statahead(inode, fd);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516         <span class="keywordflow">if</span> (inode-&gt;i_sb-&gt;s_root == file-&gt;f_path.dentry) {
<a name="l00517"></a>00517                 LUSTRE_FPRIVATE(file) = fd;
<a name="l00518"></a>00518                 RETURN(0);
<a name="l00519"></a>00519         }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521         <span class="keywordflow">if</span> (!it || !it-&gt;it_disposition) {
<a name="l00522"></a>00522                 <span class="comment">/* Convert f_flags into access mode. We cannot use file-&gt;f_mode,</span>
<a name="l00523"></a>00523 <span class="comment">                 * because everything but O_ACCMODE mask was stripped from</span>
<a name="l00524"></a>00524 <span class="comment">                 * there */</span>
<a name="l00525"></a>00525                 <span class="keywordflow">if</span> ((oit.it_flags + 1) &amp; O_ACCMODE)
<a name="l00526"></a>00526                         oit.it_flags++;
<a name="l00527"></a>00527                 <span class="keywordflow">if</span> (file-&gt;f_flags &amp; O_TRUNC)
<a name="l00528"></a>00528                         oit.it_flags |= FMODE_WRITE;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530                 <span class="comment">/* kernel only call f_op-&gt;open in dentry_open.  filp_open calls</span>
<a name="l00531"></a>00531 <span class="comment">                 * dentry_open after call to open_namei that checks permissions.</span>
<a name="l00532"></a>00532 <span class="comment">                 * Only nfsd_open call dentry_open directly without checking</span>
<a name="l00533"></a>00533 <span class="comment">                 * permissions and because of that this code below is safe. */</span>
<a name="l00534"></a>00534                 <span class="keywordflow">if</span> (oit.it_flags &amp; (FMODE_WRITE | FMODE_READ))
<a name="l00535"></a>00535                         oit.it_flags |= MDS_OPEN_OWNEROVERRIDE;
<a name="l00536"></a>00536 
<a name="l00537"></a>00537                 <span class="comment">/* We do not want O_EXCL here, presumably we opened the file</span>
<a name="l00538"></a>00538 <span class="comment">                 * already? XXX - NFS implications? */</span>
<a name="l00539"></a>00539                 oit.it_flags &amp;= ~O_EXCL;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541                 <span class="comment">/* bug20584, if &quot;it_flags&quot; contains O_CREAT, the file will be</span>
<a name="l00542"></a>00542 <span class="comment">                 * created if necessary, then &quot;IT_CREAT&quot; should be set to keep</span>
<a name="l00543"></a>00543 <span class="comment">                 * consistent with it */</span>
<a name="l00544"></a>00544                 <span class="keywordflow">if</span> (oit.it_flags &amp; O_CREAT)
<a name="l00545"></a>00545                         oit.it_op |= IT_CREAT;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547                 it = &amp;oit;
<a name="l00548"></a>00548         }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 restart:
<a name="l00551"></a>00551         <span class="comment">/* Let&apos;s see if we have file open on MDS already. */</span>
<a name="l00552"></a>00552         <span class="keywordflow">if</span> (it-&gt;it_flags &amp; FMODE_WRITE) {
<a name="l00553"></a>00553                 och_p = &amp;lli-&gt;lli_mds_write_och;
<a name="l00554"></a>00554                 och_usecount = &amp;lli-&gt;lli_open_fd_write_count;
<a name="l00555"></a>00555         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (it-&gt;it_flags &amp; FMODE_EXEC) {
<a name="l00556"></a>00556                 och_p = &amp;lli-&gt;lli_mds_exec_och;
<a name="l00557"></a>00557                 och_usecount = &amp;lli-&gt;lli_open_fd_exec_count;
<a name="l00558"></a>00558          } <span class="keywordflow">else</span> {
<a name="l00559"></a>00559                 och_p = &amp;lli-&gt;lli_mds_read_och;
<a name="l00560"></a>00560                 och_usecount = &amp;lli-&gt;lli_open_fd_read_count;
<a name="l00561"></a>00561         }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563         mutex_lock(&amp;lli-&gt;lli_och_mutex);
<a name="l00564"></a>00564         <span class="keywordflow">if</span> (*och_p) { <span class="comment">/* Open handle is present */</span>
<a name="l00565"></a>00565                 <span class="keywordflow">if</span> (it_disposition(it, DISP_OPEN_OPEN)) {
<a name="l00566"></a>00566                         <span class="comment">/* Well, there&apos;s extra open request that we do not need,</span>
<a name="l00567"></a>00567 <span class="comment">                           let&apos;s close it somehow. This will decref request. */</span>
<a name="l00568"></a>00568                         rc = it_open_error(DISP_OPEN_OPEN, it);
<a name="l00569"></a>00569                         <span class="keywordflow">if</span> (rc) {
<a name="l00570"></a>00570                                 mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00571"></a>00571                                 GOTO(out_openerr, rc);
<a name="l00572"></a>00572                         }
<a name="l00573"></a>00573 
<a name="l00574"></a>00574                         ll_release_openhandle(file-&gt;f_path.dentry, it);
<a name="l00575"></a>00575                 }
<a name="l00576"></a>00576                 (*och_usecount)++;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578                 rc = ll_local_open(file, it, fd, NULL);
<a name="l00579"></a>00579                 <span class="keywordflow">if</span> (rc) {
<a name="l00580"></a>00580                         (*och_usecount)--;
<a name="l00581"></a>00581                         mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00582"></a>00582                         GOTO(out_openerr, rc);
<a name="l00583"></a>00583                 }
<a name="l00584"></a>00584         } <span class="keywordflow">else</span> {
<a name="l00585"></a>00585                 LASSERT(*och_usecount == 0);
<a name="l00586"></a>00586                 <span class="keywordflow">if</span> (!it-&gt;it_disposition) {
<a name="l00587"></a>00587                         <span class="comment">/* We cannot just request lock handle now, new ELC code</span>
<a name="l00588"></a>00588 <span class="comment">                           means that one of other OPEN locks for this file</span>
<a name="l00589"></a>00589 <span class="comment">                           could be cancelled, and since blocking ast handler</span>
<a name="l00590"></a>00590 <span class="comment">                           would attempt to grab och_mutex as well, that would</span>
<a name="l00591"></a>00591 <span class="comment">                           result in a deadlock */</span>
<a name="l00592"></a>00592                         mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00593"></a>00593                         <span class="comment">/*</span>
<a name="l00594"></a>00594 <span class="comment">                         * Normally called under two situations:</span>
<a name="l00595"></a>00595 <span class="comment">                         * 1. NFS export.</span>
<a name="l00596"></a>00596 <span class="comment">                         * 2. A race/condition on MDS resulting in no open</span>
<a name="l00597"></a>00597 <span class="comment">                         *    handle to be returned from LOOKUP|OPEN request,</span>
<a name="l00598"></a>00598 <span class="comment">                         *    for example if the target entry was a symlink.</span>
<a name="l00599"></a>00599 <span class="comment">                         *</span>
<a name="l00600"></a>00600 <span class="comment">                         * Always fetch MDS_OPEN_LOCK if this is not setstripe.</span>
<a name="l00601"></a>00601 <span class="comment">                         *</span>
<a name="l00602"></a>00602 <span class="comment">                         * Always specify MDS_OPEN_BY_FID because we don&apos;t want</span>
<a name="l00603"></a>00603 <span class="comment">                         * to get file with different fid.</span>
<a name="l00604"></a>00604 <span class="comment">                         */</span>
<a name="l00605"></a>00605                         it-&gt;it_flags |= MDS_OPEN_LOCK | MDS_OPEN_BY_FID;
<a name="l00606"></a>00606                         rc = ll_intent_file_open(file, NULL, 0, it);
<a name="l00607"></a>00607                         <span class="keywordflow">if</span> (rc)
<a name="l00608"></a>00608                                 GOTO(out_openerr, rc);
<a name="l00609"></a>00609 
<a name="l00610"></a>00610                         <span class="keywordflow">goto</span> restart;
<a name="l00611"></a>00611                 }
<a name="l00612"></a>00612                 OBD_ALLOC(*och_p, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structobd__client__handle.html">obd_client_handle</a>));
<a name="l00613"></a>00613                 <span class="keywordflow">if</span> (!*och_p)
<a name="l00614"></a>00614                         GOTO(out_och_free, rc = -ENOMEM);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616                 (*och_usecount)++;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618                 <span class="comment">/* md_intent_lock() didn&apos;t get a request ref if there was an</span>
<a name="l00619"></a>00619 <span class="comment">                 * open error, so don&apos;t do cleanup on the request here</span>
<a name="l00620"></a>00620 <span class="comment">                 * (bug 3430) */</span>
<a name="l00621"></a>00621                 <span class="comment">/* XXX (green): Should not we bail out on any error here, not</span>
<a name="l00622"></a>00622 <span class="comment">                 * just open error? */</span>
<a name="l00623"></a>00623                 rc = it_open_error(DISP_OPEN_OPEN, it);
<a name="l00624"></a>00624                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00625"></a>00625                         GOTO(out_och_free, rc);
<a name="l00626"></a>00626 
<a name="l00627"></a>00627                 LASSERTF(it_disposition(it, DISP_ENQ_OPEN_REF),
<a name="l00628"></a>00628                          <span class="stringliteral">&quot;inode %p: disposition %x, status %d\n&quot;</span>, inode,
<a name="l00629"></a>00629                          it_disposition(it, ~0), it-&gt;it_status);
<a name="l00630"></a>00630 
<a name="l00631"></a>00631                 rc = ll_local_open(file, it, fd, *och_p);
<a name="l00632"></a>00632                 <span class="keywordflow">if</span> (rc)
<a name="l00633"></a>00633                         GOTO(out_och_free, rc);
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635         mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00636"></a>00636         fd = NULL;
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         <span class="comment">/* Must do this outside lli_och_mutex lock to prevent deadlock where</span>
<a name="l00639"></a>00639 <span class="comment">           different kind of OPEN lock for this same inode gets cancelled</span>
<a name="l00640"></a>00640 <span class="comment">           by ldlm_cancel_lru */</span>
<a name="l00641"></a>00641         <span class="keywordflow">if</span> (!S_ISREG(inode-&gt;i_mode))
<a name="l00642"></a>00642                 GOTO(out_och_free, rc);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644         cl_lov_delay_create_clear(&amp;file-&gt;f_flags);
<a name="l00645"></a>00645         GOTO(out_och_free, rc);
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 out_och_free:
<a name="l00648"></a>00648         <span class="keywordflow">if</span> (rc) {
<a name="l00649"></a>00649                 <span class="keywordflow">if</span> (och_p &amp;&amp; *och_p) {
<a name="l00650"></a>00650                         OBD_FREE(*och_p, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structobd__client__handle.html">obd_client_handle</a>));
<a name="l00651"></a>00651                         *och_p = NULL; <span class="comment">/* OBD_FREE writes some magic there */</span>
<a name="l00652"></a>00652                         (*och_usecount)--;
<a name="l00653"></a>00653                 }
<a name="l00654"></a>00654                 mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 out_openerr:
<a name="l00657"></a>00657                 <span class="keywordflow">if</span> (lli-&gt;lli_opendir_key == fd)
<a name="l00658"></a>00658                         ll_deauthorize_statahead(inode, fd);
<a name="l00659"></a>00659                 <span class="keywordflow">if</span> (fd != NULL)
<a name="l00660"></a>00660                         ll_file_data_put(fd);
<a name="l00661"></a>00661         } <span class="keywordflow">else</span> {
<a name="l00662"></a>00662                 ll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_OPEN, 1);
<a name="l00663"></a>00663         }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665         <span class="keywordflow">if</span> (it &amp;&amp; it_disposition(it, DISP_ENQ_OPEN_REF)) {
<a name="l00666"></a>00666                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(it-&gt;it_request);
<a name="l00667"></a>00667                 it_clear_disposition(it, DISP_ENQ_OPEN_REF);
<a name="l00668"></a>00668         }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         <span class="keywordflow">return</span> rc;
<a name="l00671"></a>00671 }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_md_blocking_lease_ast(<span class="keyword">struct</span> <a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock,
<a name="l00674"></a>00674                         <span class="keyword">struct</span> <a class="code" href="structldlm__lock__desc.html">ldlm_lock_desc</a> *desc, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> flag)
<a name="l00675"></a>00675 {
<a name="l00676"></a>00676         <span class="keywordtype">int</span> rc;
<a name="l00677"></a>00677         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lockh;
<a name="l00678"></a>00678         ENTRY;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680         <span class="keywordflow">switch</span> (flag) {
<a name="l00681"></a>00681         <span class="keywordflow">case</span> <a class="code" href="group__LDLM.html#gac91b29eaa6987e07656d85e9e139ca3f" title="The blocking callback is overloaded to perform two functions.">LDLM_CB_BLOCKING</a>:
<a name="l00682"></a>00682                 <a class="code" href="group__LDLM.html#ga35362f3605ec8dec52464f153c932c85" title="Fills in handle for LDLM lock lock into supplied lockh Does not take any references...">ldlm_lock2handle</a>(lock, &amp;lockh);
<a name="l00683"></a>00683                 rc = <a class="code" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel.">ldlm_cli_cancel</a>(&amp;lockh, LCF_ASYNC);
<a name="l00684"></a>00684                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00685"></a>00685                         CDEBUG(D_INODE, <span class="stringliteral">&quot;ldlm_cli_cancel: %d\n&quot;</span>, rc);
<a name="l00686"></a>00686                         RETURN(rc);
<a name="l00687"></a>00687                 }
<a name="l00688"></a>00688                 <span class="keywordflow">break</span>;
<a name="l00689"></a>00689         <span class="keywordflow">case</span> LDLM_CB_CANCELING:
<a name="l00690"></a>00690                 <span class="comment">/* do nothing */</span>
<a name="l00691"></a>00691                 <span class="keywordflow">break</span>;
<a name="l00692"></a>00692         }
<a name="l00693"></a>00693         RETURN(0);
<a name="l00694"></a>00694 }
<a name="l00695"></a>00695 
<a name="l00699"></a>00699 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> *
<a name="l00700"></a>00700 ll_lease_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file, fmode_t fmode,
<a name="l00701"></a>00701               __u64 open_flags)
<a name="l00702"></a>00702 {
<a name="l00703"></a>00703         <span class="keyword">struct </span><a class="code" href="structlookup__intent.html">lookup_intent</a> it = { .it_op = IT_OPEN };
<a name="l00704"></a>00704         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a> *sbi = ll_i2sbi(inode);
<a name="l00705"></a>00705         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a> *op_data;
<a name="l00706"></a>00706         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = NULL;
<a name="l00707"></a>00707         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> old_handle = { 0 };
<a name="l00708"></a>00708         <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och = NULL;
<a name="l00709"></a>00709         <span class="keywordtype">int</span> rc;
<a name="l00710"></a>00710         <span class="keywordtype">int</span> rc2;
<a name="l00711"></a>00711         ENTRY;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713         <span class="keywordflow">if</span> (fmode != FMODE_WRITE &amp;&amp; fmode != FMODE_READ)
<a name="l00714"></a>00714                 RETURN(ERR_PTR(-EINVAL));
<a name="l00715"></a>00715 
<a name="l00716"></a>00716         <span class="keywordflow">if</span> (file != NULL) {
<a name="l00717"></a>00717                 <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l00718"></a>00718                 <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a> *fd = LUSTRE_FPRIVATE(file);
<a name="l00719"></a>00719                 <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> **och_p;
<a name="l00720"></a>00720                 __u64 *och_usecount;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722                 <span class="keywordflow">if</span> (!(fmode &amp; file-&gt;f_mode) || (file-&gt;f_mode &amp; FMODE_EXEC))
<a name="l00723"></a>00723                         RETURN(ERR_PTR(-EPERM));
<a name="l00724"></a>00724 
<a name="l00725"></a>00725                 <span class="comment">/* Get the openhandle of the file */</span>
<a name="l00726"></a>00726                 rc = -EBUSY;
<a name="l00727"></a>00727                 mutex_lock(&amp;lli-&gt;lli_och_mutex);
<a name="l00728"></a>00728                 <span class="keywordflow">if</span> (fd-&gt;fd_lease_och != NULL) {
<a name="l00729"></a>00729                         mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00730"></a>00730                         RETURN(ERR_PTR(rc));
<a name="l00731"></a>00731                 }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733                 <span class="keywordflow">if</span> (fd-&gt;fd_och == NULL) {
<a name="l00734"></a>00734                         <span class="keywordflow">if</span> (file-&gt;f_mode &amp; FMODE_WRITE) {
<a name="l00735"></a>00735                                 LASSERT(lli-&gt;lli_mds_write_och != NULL);
<a name="l00736"></a>00736                                 och_p = &amp;lli-&gt;lli_mds_write_och;
<a name="l00737"></a>00737                                 och_usecount = &amp;lli-&gt;lli_open_fd_write_count;
<a name="l00738"></a>00738                         } <span class="keywordflow">else</span> {
<a name="l00739"></a>00739                                 LASSERT(lli-&gt;lli_mds_read_och != NULL);
<a name="l00740"></a>00740                                 och_p = &amp;lli-&gt;lli_mds_read_och;
<a name="l00741"></a>00741                                 och_usecount = &amp;lli-&gt;lli_open_fd_read_count;
<a name="l00742"></a>00742                         }
<a name="l00743"></a>00743                         <span class="keywordflow">if</span> (*och_usecount == 1) {
<a name="l00744"></a>00744                                 fd-&gt;fd_och = *och_p;
<a name="l00745"></a>00745                                 *och_p = NULL;
<a name="l00746"></a>00746                                 *och_usecount = 0;
<a name="l00747"></a>00747                                 rc = 0;
<a name="l00748"></a>00748                         }
<a name="l00749"></a>00749                 }
<a name="l00750"></a>00750                 mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l00751"></a>00751                 <span class="keywordflow">if</span> (rc &lt; 0) <span class="comment">/* more than 1 opener */</span>
<a name="l00752"></a>00752                         RETURN(ERR_PTR(rc));
<a name="l00753"></a>00753 
<a name="l00754"></a>00754                 LASSERT(fd-&gt;fd_och != NULL);
<a name="l00755"></a>00755                 old_handle = fd-&gt;fd_och-&gt;och_fh;
<a name="l00756"></a>00756         }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758         OBD_ALLOC_PTR(och);
<a name="l00759"></a>00759         <span class="keywordflow">if</span> (och == NULL)
<a name="l00760"></a>00760                 RETURN(ERR_PTR(-ENOMEM));
<a name="l00761"></a>00761 
<a name="l00762"></a>00762         op_data = ll_prep_md_op_data(NULL, inode, inode, NULL, 0, 0,
<a name="l00763"></a>00763                                         LUSTRE_OPC_ANY, NULL);
<a name="l00764"></a>00764         <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l00765"></a>00765                 GOTO(out, rc = PTR_ERR(op_data));
<a name="l00766"></a>00766 
<a name="l00767"></a>00767         <span class="comment">/* To tell the MDT this openhandle is from the same owner */</span>
<a name="l00768"></a>00768         op_data-&gt;op_handle = old_handle;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770         it.it_flags = fmode | open_flags;
<a name="l00771"></a>00771         it.it_flags |= MDS_OPEN_LOCK | MDS_OPEN_BY_FID | MDS_OPEN_LEASE;
<a name="l00772"></a>00772         rc = md_intent_lock(sbi-&gt;ll_md_exp, op_data, &amp;it, &amp;req,
<a name="l00773"></a>00773                             &amp;ll_md_blocking_lease_ast,
<a name="l00774"></a>00774         <span class="comment">/* LDLM_FL_NO_LRU: To not put the lease lock into LRU list, otherwise</span>
<a name="l00775"></a>00775 <span class="comment">         * it can be cancelled which may mislead applications that the lease is</span>
<a name="l00776"></a>00776 <span class="comment">         * broken;</span>
<a name="l00777"></a>00777 <span class="comment">         * LDLM_FL_EXCL: Set this flag so that it won&apos;t be matched by normal</span>
<a name="l00778"></a>00778 <span class="comment">         * open in ll_md_blocking_ast(). Otherwise as ll_md_blocking_lease_ast</span>
<a name="l00779"></a>00779 <span class="comment">         * doesn&apos;t deal with openhandle, so normal openhandle will be leaked. */</span>
<a name="l00780"></a>00780                             <a class="code" href="group__LDLM.html#ga628bde1454443ba6f69043120c61acb9" title="Don&amp;#39;t put lock into the LRU list, so that it is not canceled due to aging.">LDLM_FL_NO_LRU</a> | <a class="code" href="group__LDLM.html#ga353cf18a1a7c41ccaf72d5c8bf71a129" title="Flag whether this lock can be reused.">LDLM_FL_EXCL</a>);
<a name="l00781"></a>00781         ll_finish_md_op_data(op_data);
<a name="l00782"></a>00782         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l00783"></a>00783         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00784"></a>00784                 GOTO(out_release_it, rc);
<a name="l00785"></a>00785 
<a name="l00786"></a>00786         <span class="keywordflow">if</span> (it_disposition(&amp;it, DISP_LOOKUP_NEG))
<a name="l00787"></a>00787                 GOTO(out_release_it, rc = -ENOENT);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789         rc = it_open_error(DISP_OPEN_OPEN, &amp;it);
<a name="l00790"></a>00790         <span class="keywordflow">if</span> (rc)
<a name="l00791"></a>00791                 GOTO(out_release_it, rc);
<a name="l00792"></a>00792 
<a name="l00793"></a>00793         LASSERT(it_disposition(&amp;it, DISP_ENQ_OPEN_REF));
<a name="l00794"></a>00794         ll_och_fill(sbi-&gt;ll_md_exp, &amp;it, och);
<a name="l00795"></a>00795 
<a name="l00796"></a>00796         <span class="keywordflow">if</span> (!it_disposition(&amp;it, DISP_OPEN_LEASE)) <span class="comment">/* old server? */</span>
<a name="l00797"></a>00797                 GOTO(out_close, rc = -EOPNOTSUPP);
<a name="l00798"></a>00798 
<a name="l00799"></a>00799         <span class="comment">/* already get lease, handle lease lock */</span>
<a name="l00800"></a>00800         ll_set_lock_data(sbi-&gt;ll_md_exp, inode, &amp;it, NULL);
<a name="l00801"></a>00801         <span class="keywordflow">if</span> (it.it_lock_mode == 0 ||
<a name="l00802"></a>00802             it.it_lock_bits != MDS_INODELOCK_OPEN) {
<a name="l00803"></a>00803                 <span class="comment">/* open lock must return for lease */</span>
<a name="l00804"></a>00804                 CERROR(DFID <span class="stringliteral">&quot;lease granted but no open lock, %d/&quot;</span>LPU64<span class="stringliteral">&quot;.\n&quot;</span>,
<a name="l00805"></a>00805                         PFID(ll_inode2fid(inode)), it.it_lock_mode,
<a name="l00806"></a>00806                         it.it_lock_bits);
<a name="l00807"></a>00807                 GOTO(out_close, rc = -EPROTO);
<a name="l00808"></a>00808         }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810         ll_intent_release(&amp;it);
<a name="l00811"></a>00811         RETURN(och);
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 out_close:
<a name="l00814"></a>00814         <span class="comment">/* Cancel open lock */</span>
<a name="l00815"></a>00815         <span class="keywordflow">if</span> (it.it_lock_mode != 0) {
<a name="l00816"></a>00816                 <a class="code" href="group__LDLM.html#gad236a9af5f0845e1046060a55419914b" title="Decrease reader/writer refcount for LDLM lock with handle lockh and mark it for subsequent...">ldlm_lock_decref_and_cancel</a>(&amp;och-&gt;och_lease_handle,
<a name="l00817"></a>00817                                             it.it_lock_mode);
<a name="l00818"></a>00818                 it.it_lock_mode = 0;
<a name="l00819"></a>00819                 och-&gt;och_lease_handle.cookie = 0ULL;
<a name="l00820"></a>00820         }
<a name="l00821"></a>00821         rc2 = ll_close_inode_openhandle(inode, och, 0, NULL);
<a name="l00822"></a>00822         <span class="keywordflow">if</span> (rc2 &lt; 0)
<a name="l00823"></a>00823                 CERROR(<span class="stringliteral">&quot;%s: error closing file &quot;</span>DFID<span class="stringliteral">&quot;: %d\n&quot;</span>,
<a name="l00824"></a>00824                        ll_get_fsname(inode-&gt;i_sb, NULL, 0),
<a name="l00825"></a>00825                        PFID(&amp;ll_i2info(inode)-&gt;lli_fid), rc2);
<a name="l00826"></a>00826         och = NULL; <span class="comment">/* och has been freed in ll_close_inode_openhandle() */</span>
<a name="l00827"></a>00827 out_release_it:
<a name="l00828"></a>00828         ll_intent_release(&amp;it);
<a name="l00829"></a>00829 out:
<a name="l00830"></a>00830         <span class="keywordflow">if</span> (och != NULL)
<a name="l00831"></a>00831                 OBD_FREE_PTR(och);
<a name="l00832"></a>00832         RETURN(ERR_PTR(rc));
<a name="l00833"></a>00833 }
<a name="l00834"></a>00834 
<a name="l00844"></a>00844 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_check_swap_layouts_validity(<span class="keyword">struct</span> inode *inode1,
<a name="l00845"></a>00845                                           <span class="keyword">struct</span> inode *inode2)
<a name="l00846"></a>00846 {
<a name="l00847"></a>00847         <span class="keywordflow">if</span> (!S_ISREG(inode1-&gt;i_mode) || !S_ISREG(inode2-&gt;i_mode))
<a name="l00848"></a>00848                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00849"></a>00849 
<a name="l00850"></a>00850         <span class="keywordflow">if</span> (inode_permission(inode1, MAY_WRITE) ||
<a name="l00851"></a>00851             inode_permission(inode2, MAY_WRITE))
<a name="l00852"></a>00852                 <span class="keywordflow">return</span> -EPERM;
<a name="l00853"></a>00853 
<a name="l00854"></a>00854         <span class="keywordflow">if</span> (inode1-&gt;i_sb != inode2-&gt;i_sb)
<a name="l00855"></a>00855                 <span class="keywordflow">return</span> -EXDEV;
<a name="l00856"></a>00856 
<a name="l00857"></a>00857         <span class="keywordflow">return</span> 0;
<a name="l00858"></a>00858 }
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_swap_layouts_close(<span class="keyword">struct</span> <a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och,
<a name="l00861"></a>00861                                  <span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> inode *inode2)
<a name="l00862"></a>00862 {
<a name="l00863"></a>00863         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>     *fid1 = ll_inode2fid(inode);
<a name="l00864"></a>00864         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>     *fid2;
<a name="l00865"></a>00865         <span class="keywordtype">int</span>                      rc;
<a name="l00866"></a>00866         ENTRY;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868         CDEBUG(D_INODE, <span class="stringliteral">&quot;%s: biased close of file &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00869"></a>00869                ll_get_fsname(inode-&gt;i_sb, NULL, 0), PFID(fid1));
<a name="l00870"></a>00870 
<a name="l00871"></a>00871         rc = ll_check_swap_layouts_validity(inode, inode2);
<a name="l00872"></a>00872         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00873"></a>00873                 GOTO(out_free_och, rc);
<a name="l00874"></a>00874 
<a name="l00875"></a>00875         <span class="comment">/* We now know that inode2 is a lustre inode */</span>
<a name="l00876"></a>00876         fid2 = ll_inode2fid(inode2);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878         rc = lu_fid_cmp(fid1, fid2);
<a name="l00879"></a>00879         <span class="keywordflow">if</span> (rc == 0)
<a name="l00880"></a>00880                 GOTO(out_free_och, rc = -EINVAL);
<a name="l00881"></a>00881 
<a name="l00882"></a>00882         <span class="comment">/* Close the file and swap layouts between inode &amp; inode2.</span>
<a name="l00883"></a>00883 <span class="comment">         * NB: lease lock handle is released in mdc_close_layout_swap_pack()</span>
<a name="l00884"></a>00884 <span class="comment">         * because we still need it to pack l_remote_handle to MDT. */</span>
<a name="l00885"></a>00885         rc = ll_close_inode_openhandle(inode, och, MDS_CLOSE_LAYOUT_SWAP,
<a name="l00886"></a>00886                                        inode2);
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         och = NULL; <span class="comment">/* freed in ll_close_inode_openhandle() */</span>
<a name="l00889"></a>00889 
<a name="l00890"></a>00890 out_free_och:
<a name="l00891"></a>00891         <span class="keywordflow">if</span> (och != NULL)
<a name="l00892"></a>00892                 OBD_FREE_PTR(och);
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         RETURN(rc);
<a name="l00895"></a>00895 }
<a name="l00896"></a>00896 
<a name="l00901"></a>00901 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_lease_close(<span class="keyword">struct</span> <a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och, <span class="keyword">struct</span> inode *inode,
<a name="l00902"></a>00902                           <span class="keywordtype">bool</span> *lease_broken)
<a name="l00903"></a>00903 {
<a name="l00904"></a>00904         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock;
<a name="l00905"></a>00905         <span class="keywordtype">bool</span> cancelled = <span class="keyword">true</span>;
<a name="l00906"></a>00906         <span class="keywordtype">int</span> rc;
<a name="l00907"></a>00907         ENTRY;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909         lock = ldlm_handle2lock(&amp;och-&gt;och_lease_handle);
<a name="l00910"></a>00910         <span class="keywordflow">if</span> (lock != NULL) {
<a name="l00911"></a>00911                 <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00912"></a>00912                 cancelled = ldlm_is_cancel(lock);
<a name="l00913"></a>00913                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00914"></a>00914                 <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l00915"></a>00915         }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917         CDEBUG(D_INODE, <span class="stringliteral">&quot;lease for &quot;</span>DFID<span class="stringliteral">&quot; broken? %d\n&quot;</span>,
<a name="l00918"></a>00918                 PFID(&amp;ll_i2info(inode)-&gt;lli_fid), cancelled);
<a name="l00919"></a>00919 
<a name="l00920"></a>00920         <span class="keywordflow">if</span> (!cancelled)
<a name="l00921"></a>00921                 <a class="code" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel.">ldlm_cli_cancel</a>(&amp;och-&gt;och_lease_handle, 0);
<a name="l00922"></a>00922         <span class="keywordflow">if</span> (lease_broken != NULL)
<a name="l00923"></a>00923                 *lease_broken = cancelled;
<a name="l00924"></a>00924 
<a name="l00925"></a>00925         rc = ll_close_inode_openhandle(inode, och, 0, NULL);
<a name="l00926"></a>00926         RETURN(rc);
<a name="l00927"></a>00927 }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929 <span class="keywordtype">int</span> ll_merge_attr(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> inode *inode)
<a name="l00930"></a>00930 {
<a name="l00931"></a>00931         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l00932"></a>00932         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj = lli-&gt;lli_clob;
<a name="l00933"></a>00933         <span class="keyword">struct </span><a class="code" href="structcl__attr.html" title="&amp;quot;Data attributes&amp;quot; of cl_object.">cl_attr</a> *attr = vvp_env_thread_attr(env);
<a name="l00934"></a>00934         s64 atime;
<a name="l00935"></a>00935         s64 mtime;
<a name="l00936"></a>00936         s64 ctime;
<a name="l00937"></a>00937         <span class="keywordtype">int</span> rc = 0;
<a name="l00938"></a>00938 
<a name="l00939"></a>00939         ENTRY;
<a name="l00940"></a>00940 
<a name="l00941"></a>00941         ll_inode_size_lock(inode);
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <span class="comment">/* merge timestamps the most recently obtained from mds with</span>
<a name="l00944"></a>00944 <span class="comment">           timestamps obtained from osts */</span>
<a name="l00945"></a>00945         LTIME_S(inode-&gt;i_atime) = lli-&gt;lli_atime;
<a name="l00946"></a>00946         LTIME_S(inode-&gt;i_mtime) = lli-&gt;lli_mtime;
<a name="l00947"></a>00947         LTIME_S(inode-&gt;i_ctime) = lli-&gt;lli_ctime;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         atime = LTIME_S(inode-&gt;i_atime);
<a name="l00950"></a>00950         mtime = LTIME_S(inode-&gt;i_mtime);
<a name="l00951"></a>00951         ctime = LTIME_S(inode-&gt;i_ctime);
<a name="l00952"></a>00952 
<a name="l00953"></a>00953         <a class="code" href="group__cl__object.html#ga0ab97a8a879d5a81b4b5d60367e0ff0a" title="Locks data-attributes.">cl_object_attr_lock</a>(obj);
<a name="l00954"></a>00954         rc = <a class="code" href="group__cl__object.html#gadfa2c03f781edcc53976843d94c18b48" title="Returns data-attributes of an object obj.">cl_object_attr_get</a>(env, obj, attr);
<a name="l00955"></a>00955         <a class="code" href="group__cl__object.html#ga2fc69699a9214cda8ac2e8264b709dac" title="Releases data-attributes lock, acquired by cl_object_attr_lock().">cl_object_attr_unlock</a>(obj);
<a name="l00956"></a>00956 
<a name="l00957"></a>00957         <span class="keywordflow">if</span> (rc != 0)
<a name="l00958"></a>00958                 GOTO(out_size_unlock, rc);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960         <span class="keywordflow">if</span> (atime &lt; attr-&gt;<a class="code" href="structcl__attr.html#a703fa4a91dbf487ea43a491efbcbb26c" title="Access time.">cat_atime</a>)
<a name="l00961"></a>00961                 atime = attr-&gt;<a class="code" href="structcl__attr.html#a703fa4a91dbf487ea43a491efbcbb26c" title="Access time.">cat_atime</a>;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963         <span class="keywordflow">if</span> (ctime &lt; attr-&gt;<a class="code" href="structcl__attr.html#ad219a939eaf54b1de26b049f26d513e3" title="Change time.">cat_ctime</a>)
<a name="l00964"></a>00964                 ctime = attr-&gt;<a class="code" href="structcl__attr.html#ad219a939eaf54b1de26b049f26d513e3" title="Change time.">cat_ctime</a>;
<a name="l00965"></a>00965 
<a name="l00966"></a>00966         <span class="keywordflow">if</span> (mtime &lt; attr-&gt;<a class="code" href="structcl__attr.html#ac337ab4467993ed3c1ed8a74407e933b" title="Modification time.">cat_mtime</a>)
<a name="l00967"></a>00967                 mtime = attr-&gt;<a class="code" href="structcl__attr.html#ac337ab4467993ed3c1ed8a74407e933b" title="Modification time.">cat_mtime</a>;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         CDEBUG(D_VFSTRACE, DFID<span class="stringliteral">&quot; updating i_size &quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00970"></a>00970                PFID(&amp;lli-&gt;lli_fid), attr-&gt;<a class="code" href="structcl__attr.html#a301cbfa8e597852a6f7cf1b5a22d5269" title="Object size, in bytes.">cat_size</a>);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972         i_size_write(inode, attr-&gt;<a class="code" href="structcl__attr.html#a301cbfa8e597852a6f7cf1b5a22d5269" title="Object size, in bytes.">cat_size</a>);
<a name="l00973"></a>00973         inode-&gt;i_blocks = attr-&gt;<a class="code" href="structcl__attr.html#aa5bce270584ece6d9511008c0d827821" title="Blocks allocated to this cl_object on the server file system.">cat_blocks</a>;
<a name="l00974"></a>00974 
<a name="l00975"></a>00975         LTIME_S(inode-&gt;i_atime) = atime;
<a name="l00976"></a>00976         LTIME_S(inode-&gt;i_mtime) = mtime;
<a name="l00977"></a>00977         LTIME_S(inode-&gt;i_ctime) = ctime;
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 out_size_unlock:
<a name="l00980"></a>00980         ll_inode_size_unlock(inode);
<a name="l00981"></a>00981 
<a name="l00982"></a>00982         RETURN(rc);
<a name="l00983"></a>00983 }
<a name="l00984"></a>00984 
<a name="l00985"></a>00985 <span class="keyword">static</span> <span class="keywordtype">bool</span> file_is_noatime(<span class="keyword">const</span> <span class="keyword">struct</span> file *file)
<a name="l00986"></a>00986 {
<a name="l00987"></a>00987         <span class="keyword">const</span> <span class="keyword">struct </span>vfsmount *mnt = file-&gt;f_path.mnt;
<a name="l00988"></a>00988         <span class="keyword">const</span> <span class="keyword">struct </span>inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l00989"></a>00989 
<a name="l00990"></a>00990         <span class="comment">/* Adapted from file_accessed() and touch_atime().*/</span>
<a name="l00991"></a>00991         <span class="keywordflow">if</span> (file-&gt;f_flags &amp; O_NOATIME)
<a name="l00992"></a>00992                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994         <span class="keywordflow">if</span> (inode-&gt;i_flags &amp; S_NOATIME)
<a name="l00995"></a>00995                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00996"></a>00996 
<a name="l00997"></a>00997         <span class="keywordflow">if</span> (IS_NOATIME(inode))
<a name="l00998"></a>00998                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00999"></a>00999 
<a name="l01000"></a>01000         <span class="keywordflow">if</span> (mnt-&gt;mnt_flags &amp; (MNT_NOATIME | MNT_READONLY))
<a name="l01001"></a>01001                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01002"></a>01002 
<a name="l01003"></a>01003         <span class="keywordflow">if</span> ((mnt-&gt;mnt_flags &amp; MNT_NODIRATIME) &amp;&amp; S_ISDIR(inode-&gt;i_mode))
<a name="l01004"></a>01004                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01005"></a>01005 
<a name="l01006"></a>01006         <span class="keywordflow">if</span> ((inode-&gt;i_sb-&gt;s_flags &amp; MS_NODIRATIME) &amp;&amp; S_ISDIR(inode-&gt;i_mode))
<a name="l01007"></a>01007                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01010"></a>01010 }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 <span class="keyword">static</span> <span class="keywordtype">void</span> ll_io_init(<span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io, <span class="keyword">const</span> <span class="keyword">struct</span> file *file, <span class="keywordtype">int</span> write)
<a name="l01013"></a>01013 {
<a name="l01014"></a>01014         <span class="keyword">struct </span>inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016         io-&gt;u.ci_rw.crw_nonblock = file-&gt;f_flags &amp; O_NONBLOCK;
<a name="l01017"></a>01017         <span class="keywordflow">if</span> (write) {
<a name="l01018"></a>01018                 io-&gt;u.ci_wr.wr_append = !!(file-&gt;f_flags &amp; O_APPEND);
<a name="l01019"></a>01019                 io-&gt;u.ci_wr.wr_sync = file-&gt;f_flags &amp; O_SYNC ||
<a name="l01020"></a>01020                                       file-&gt;f_flags &amp; O_DIRECT ||
<a name="l01021"></a>01021                                       IS_SYNC(inode);
<a name="l01022"></a>01022         }
<a name="l01023"></a>01023         io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a>     = ll_i2info(inode)-&gt;lli_clob;
<a name="l01024"></a>01024         io-&gt;<a class="code" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa" title="lock requirements, this is just a help info for sublayers.">ci_lockreq</a> = <a class="code" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824bafc402749f67a87f7c2508998b1caec47" title="Layers are free to decide between local and global locking.">CILR_MAYBE</a>;
<a name="l01025"></a>01025         <span class="keywordflow">if</span> (ll_file_nolock(file)) {
<a name="l01026"></a>01026                 io-&gt;<a class="code" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa" title="lock requirements, this is just a help info for sublayers.">ci_lockreq</a> = <a class="code" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824bacfd43489ba9d674ad77c4bdd51d3a7bc" title="Never lock: there is no cache (e.g., liblustre).">CILR_NEVER</a>;
<a name="l01027"></a>01027                 io-&gt;<a class="code" href="structcl__io.html#a435468f51ab9aab5145e46b36c669376" title="This io has held grouplock, to inform sublayers that don&amp;#39;t do lockless i/o.">ci_no_srvlock</a> = 1;
<a name="l01028"></a>01028         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (file-&gt;f_flags &amp; O_APPEND) {
<a name="l01029"></a>01029                 io-&gt;<a class="code" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa" title="lock requirements, this is just a help info for sublayers.">ci_lockreq</a> = <a class="code" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824ba4e46f767dce68b1f061c35ec1edc0528" title="Always lock data (e.g., O_APPEND).">CILR_MANDATORY</a>;
<a name="l01030"></a>01030         }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032         io-&gt;<a class="code" href="structcl__io.html#a74a86e6e753e3df915972b23ba399196" title="O_NOATIME.">ci_noatime</a> = file_is_noatime(file);
<a name="l01033"></a>01033 }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035 <span class="keyword">static</span> ssize_t
<a name="l01036"></a>01036 ll_file_io_generic(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structvvp__io__args.html" title="IO arguments for various VFS I/O interfaces.">vvp_io_args</a> *args,
<a name="l01037"></a>01037                    <span class="keyword">struct</span> file *file, <span class="keyword">enum</span> <a class="code" href="group__cl__io.html#ga7ce44ceebcd945560fa661571e3a4378" title="IO types.">cl_io_type</a> iot,
<a name="l01038"></a>01038                    loff_t *ppos, <span class="keywordtype">size_t</span> count)
<a name="l01039"></a>01039 {
<a name="l01040"></a>01040         <span class="keyword">struct </span><a class="code" href="structvvp__io.html" title="IO state private to VVP layer.">vvp_io</a>           *vio = vvp_env_io(env);
<a name="l01041"></a>01041         <span class="keyword">struct </span>inode            *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l01042"></a>01042         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a>    *lli = ll_i2info(inode);
<a name="l01043"></a>01043         <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a>     *fd  = LUSTRE_FPRIVATE(file);
<a name="l01044"></a>01044         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>            *io;
<a name="l01045"></a>01045         ssize_t                 result = 0;
<a name="l01046"></a>01046         <span class="keywordtype">int</span>                     rc = 0;
<a name="l01047"></a>01047         <span class="keyword">struct </span><a class="code" href="structrange__lock.html">range_lock</a>       range;
<a name="l01048"></a>01048 
<a name="l01049"></a>01049         ENTRY;
<a name="l01050"></a>01050 
<a name="l01051"></a>01051         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;file: %s, type: %d ppos: &quot;</span>LPU64<span class="stringliteral">&quot;, count: %zu\n&quot;</span>,
<a name="l01052"></a>01052                 file-&gt;f_path.dentry-&gt;d_name.name, iot, *ppos, count);
<a name="l01053"></a>01053 
<a name="l01054"></a>01054 restart:
<a name="l01055"></a>01055         io = vvp_env_thread_io(env);
<a name="l01056"></a>01056         ll_io_init(io, file, iot == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475" title="write system call">CIT_WRITE</a>);
<a name="l01057"></a>01057 
<a name="l01058"></a>01058         <span class="keywordflow">if</span> (<a class="code" href="group__cl__io.html#gacff72463468f75b6af811bf709aefa9d" title="Initialize read or write io.">cl_io_rw_init</a>(env, io, iot, *ppos, count) == 0) {
<a name="l01059"></a>01059                 <span class="keywordtype">bool</span> range_locked = <span class="keyword">false</span>;
<a name="l01060"></a>01060 
<a name="l01061"></a>01061                 <span class="keywordflow">if</span> (file-&gt;f_flags &amp; O_APPEND)
<a name="l01062"></a>01062                         range_lock_init(&amp;range, 0, LUSTRE_EOF);
<a name="l01063"></a>01063                 <span class="keywordflow">else</span>
<a name="l01064"></a>01064                         range_lock_init(&amp;range, *ppos, *ppos + count - 1);
<a name="l01065"></a>01065 
<a name="l01066"></a>01066                 vio-&gt;<a class="code" href="structvvp__io.html#af572692c69f5bb58a3e2dc4bb3283e81" title="File descriptor against which IO is done.">vui_fd</a>  = LUSTRE_FPRIVATE(file);
<a name="l01067"></a>01067                 vio-&gt;vui_io_subtype = args-&gt;<a class="code" href="structvvp__io__args.html#a4dbdc30e68d1afd9ec36494c96abb7c3" title="normal/sendfile/splice">via_io_subtype</a>;
<a name="l01068"></a>01068 
<a name="l01069"></a>01069                 <span class="keywordflow">switch</span> (vio-&gt;vui_io_subtype) {
<a name="l01070"></a>01070                 <span class="keywordflow">case</span> IO_NORMAL:
<a name="l01071"></a>01071                         vio-&gt;<a class="code" href="structvvp__io.html#a875f8ceaf13277e60b72a3849074c622" title="I/O vector information to or from which read/write is going.">vui_iter</a> = args-&gt;u.normal.via_iter;
<a name="l01072"></a>01072 <span class="preprocessor">#ifndef HAVE_FILE_OPERATIONS_READ_WRITE_ITER</span>
<a name="l01073"></a>01073 <span class="preprocessor"></span>                        vio-&gt;<a class="code" href="structvvp__io.html#a12dc40ddf29836cf81194909da4453ab" title="Total iov count for left IO.">vui_tot_nrsegs</a> = vio-&gt;<a class="code" href="structvvp__io.html#a875f8ceaf13277e60b72a3849074c622" title="I/O vector information to or from which read/write is going.">vui_iter</a>-&gt;nr_segs;
<a name="l01074"></a>01074 <span class="preprocessor">#endif </span><span class="comment">/* !HAVE_FILE_OPERATIONS_READ_WRITE_ITER */</span>
<a name="l01075"></a>01075                         vio-&gt;vui_iocb = args-&gt;u.normal.via_iocb;
<a name="l01076"></a>01076                         <span class="comment">/* Direct IO reads must also take range lock,</span>
<a name="l01077"></a>01077 <span class="comment">                         * or multiple reads will try to work on the same pages</span>
<a name="l01078"></a>01078 <span class="comment">                         * See LU-6227 for details. */</span>
<a name="l01079"></a>01079                         <span class="keywordflow">if</span> (((iot == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475" title="write system call">CIT_WRITE</a>) ||
<a name="l01080"></a>01080                             (iot == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a> &amp;&amp; (file-&gt;f_flags &amp; O_DIRECT))) &amp;&amp;
<a name="l01081"></a>01081                             !(vio-&gt;<a class="code" href="structvvp__io.html#af572692c69f5bb58a3e2dc4bb3283e81" title="File descriptor against which IO is done.">vui_fd</a>-&gt;fd_flags &amp; LL_FILE_GROUP_LOCKED)) {
<a name="l01082"></a>01082                                 CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;Range lock &quot;</span>RL_FMT<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01083"></a>01083                                        RL_PARA(&amp;range));
<a name="l01084"></a>01084                                 rc = <a class="code" href="structrange__lock.html">range_lock</a>(&amp;lli-&gt;lli_write_tree, &amp;range);
<a name="l01085"></a>01085                                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01086"></a>01086                                         GOTO(out, rc);
<a name="l01087"></a>01087 
<a name="l01088"></a>01088                                 range_locked = <span class="keyword">true</span>;
<a name="l01089"></a>01089                         }
<a name="l01090"></a>01090                         <span class="keywordflow">break</span>;
<a name="l01091"></a>01091                 <span class="keywordflow">case</span> IO_SPLICE:
<a name="l01092"></a>01092                         vio-&gt;u.splice.vui_pipe = args-&gt;u.splice.via_pipe;
<a name="l01093"></a>01093                         vio-&gt;u.splice.vui_flags = args-&gt;u.splice.via_flags;
<a name="l01094"></a>01094                         <span class="keywordflow">break</span>;
<a name="l01095"></a>01095                 <span class="keywordflow">default</span>:
<a name="l01096"></a>01096                         CERROR(<span class="stringliteral">&quot;unknown IO subtype %u\n&quot;</span>, vio-&gt;vui_io_subtype);
<a name="l01097"></a>01097                         LBUG();
<a name="l01098"></a>01098                 }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100                 ll_cl_add(file, env, io);
<a name="l01101"></a>01101                 rc = <a class="code" href="group__cl__io.html#ga2b13e91188661c45925b56e88b000c6e" title="Main io loop.">cl_io_loop</a>(env, io);
<a name="l01102"></a>01102                 ll_cl_remove(file, env);
<a name="l01103"></a>01103 
<a name="l01104"></a>01104                 <span class="keywordflow">if</span> (range_locked) {
<a name="l01105"></a>01105                         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;Range unlock &quot;</span>RL_FMT<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01106"></a>01106                                RL_PARA(&amp;range));
<a name="l01107"></a>01107                         range_unlock(&amp;lli-&gt;lli_write_tree, &amp;range);
<a name="l01108"></a>01108                 }
<a name="l01109"></a>01109         } <span class="keywordflow">else</span> {
<a name="l01110"></a>01110                 <span class="comment">/* cl_io_rw_init() handled IO */</span>
<a name="l01111"></a>01111                 rc = io-&gt;ci_result;
<a name="l01112"></a>01112         }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114         <span class="keywordflow">if</span> (io-&gt;ci_nob &gt; 0) {
<a name="l01115"></a>01115                 result += io-&gt;ci_nob;
<a name="l01116"></a>01116                 count -= io-&gt;ci_nob;
<a name="l01117"></a>01117                 *ppos = io-&gt;u.ci_wr.wr.crw_pos; <span class="comment">/* for splice */</span>
<a name="l01118"></a>01118 
<a name="l01119"></a>01119                 <span class="comment">/* prepare IO restart */</span>
<a name="l01120"></a>01120                 <span class="keywordflow">if</span> (count &gt; 0 &amp;&amp; args-&gt;<a class="code" href="structvvp__io__args.html#a4dbdc30e68d1afd9ec36494c96abb7c3" title="normal/sendfile/splice">via_io_subtype</a> == IO_NORMAL) {
<a name="l01121"></a>01121                         args-&gt;u.normal.via_iter = vio-&gt;<a class="code" href="structvvp__io.html#a875f8ceaf13277e60b72a3849074c622" title="I/O vector information to or from which read/write is going.">vui_iter</a>;
<a name="l01122"></a>01122 <span class="preprocessor">#ifndef HAVE_FILE_OPERATIONS_READ_WRITE_ITER</span>
<a name="l01123"></a>01123 <span class="preprocessor"></span>                        args-&gt;u.normal.via_iter-&gt;nr_segs = vio-&gt;<a class="code" href="structvvp__io.html#a12dc40ddf29836cf81194909da4453ab" title="Total iov count for left IO.">vui_tot_nrsegs</a>;
<a name="l01124"></a>01124 <span class="preprocessor">#endif </span><span class="comment">/* !HAVE_FILE_OPERATIONS_READ_WRITE_ITER */</span>
<a name="l01125"></a>01125                 }
<a name="l01126"></a>01126         }
<a name="l01127"></a>01127         GOTO(out, rc);
<a name="l01128"></a>01128 out:
<a name="l01129"></a>01129         <a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>(env, io);
<a name="l01130"></a>01130 
<a name="l01131"></a>01131         <span class="keywordflow">if</span> ((rc == 0 || rc == -ENODATA) &amp;&amp; count &gt; 0 &amp;&amp; io-&gt;<a class="code" href="structcl__io.html#a425b5ecdec17c901b3c8d8e09327d902" title="The whole IO need to be restarted because layout has been changed.">ci_need_restart</a>) {
<a name="l01132"></a>01132                 CDEBUG(D_VFSTRACE,
<a name="l01133"></a>01133                        <span class="stringliteral">&quot;%s: restart %s from %lld, count:%zu, result: %zd\n&quot;</span>,
<a name="l01134"></a>01134                        file-&gt;f_path.dentry-&gt;d_name.name,
<a name="l01135"></a>01135                        iot == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a> ? <span class="stringliteral">&quot;read&quot;</span> : <span class="stringliteral">&quot;write&quot;</span>,
<a name="l01136"></a>01136                        *ppos, count, result);
<a name="l01137"></a>01137                 <span class="keywordflow">goto</span> restart;
<a name="l01138"></a>01138         }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140         <span class="keywordflow">if</span> (iot == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a>) {
<a name="l01141"></a>01141                 <span class="keywordflow">if</span> (result &gt; 0)
<a name="l01142"></a>01142                         ll_stats_ops_tally(ll_i2sbi(inode),
<a name="l01143"></a>01143                                            LPROC_LL_READ_BYTES, result);
<a name="l01144"></a>01144         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iot == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475" title="write system call">CIT_WRITE</a>) {
<a name="l01145"></a>01145                 <span class="keywordflow">if</span> (result &gt; 0) {
<a name="l01146"></a>01146                         ll_stats_ops_tally(ll_i2sbi(inode),
<a name="l01147"></a>01147                                            LPROC_LL_WRITE_BYTES, result);
<a name="l01148"></a>01148                         fd-&gt;fd_write_failed = <span class="keyword">false</span>;
<a name="l01149"></a>01149                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (result == 0 &amp;&amp; rc == 0) {
<a name="l01150"></a>01150                         rc = io-&gt;ci_result;
<a name="l01151"></a>01151                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01152"></a>01152                                 fd-&gt;fd_write_failed = <span class="keyword">true</span>;
<a name="l01153"></a>01153                         <span class="keywordflow">else</span>
<a name="l01154"></a>01154                                 fd-&gt;fd_write_failed = <span class="keyword">false</span>;
<a name="l01155"></a>01155                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != -ERESTARTSYS) {
<a name="l01156"></a>01156                         fd-&gt;fd_write_failed = <span class="keyword">true</span>;
<a name="l01157"></a>01157                 }
<a name="l01158"></a>01158         }
<a name="l01159"></a>01159 
<a name="l01160"></a>01160         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;iot: %d, result: %zd\n&quot;</span>, iot, result);
<a name="l01161"></a>01161 
<a name="l01162"></a>01162         <span class="keywordflow">return</span> result &gt; 0 ? result : rc;
<a name="l01163"></a>01163 }
<a name="l01164"></a>01164 
<a name="l01165"></a>01165 <span class="comment">/*</span>
<a name="l01166"></a>01166 <span class="comment"> * Read from a file (through the page cache).</span>
<a name="l01167"></a>01167 <span class="comment"> */</span>
<a name="l01168"></a>01168 <span class="keyword">static</span> ssize_t ll_file_read_iter(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)
<a name="l01169"></a>01169 {
<a name="l01170"></a>01170         <span class="keyword">struct </span><a class="code" href="structvvp__io__args.html" title="IO arguments for various VFS I/O interfaces.">vvp_io_args</a> *args;
<a name="l01171"></a>01171         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01172"></a>01172         ssize_t result;
<a name="l01173"></a>01173         __u16 refcheck;
<a name="l01174"></a>01174 
<a name="l01175"></a>01175         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01176"></a>01176         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01177"></a>01177                 <span class="keywordflow">return</span> PTR_ERR(env);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179         args = ll_env_args(env, IO_NORMAL);
<a name="l01180"></a>01180         args-&gt;u.normal.via_iter = to;
<a name="l01181"></a>01181         args-&gt;u.normal.via_iocb = iocb;
<a name="l01182"></a>01182 
<a name="l01183"></a>01183         result = ll_file_io_generic(env, args, iocb-&gt;ki_filp, <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a>,
<a name="l01184"></a>01184                                     &amp;iocb-&gt;ki_pos, iov_iter_count(to));
<a name="l01185"></a>01185         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01186"></a>01186         <span class="keywordflow">return</span> result;
<a name="l01187"></a>01187 }
<a name="l01188"></a>01188 
<a name="l01189"></a>01189 <span class="comment">/*</span>
<a name="l01190"></a>01190 <span class="comment"> * Write to a file (through the page cache).</span>
<a name="l01191"></a>01191 <span class="comment"> */</span>
<a name="l01192"></a>01192 <span class="keyword">static</span> ssize_t ll_file_write_iter(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)
<a name="l01193"></a>01193 {
<a name="l01194"></a>01194         <span class="keyword">struct </span><a class="code" href="structvvp__io__args.html" title="IO arguments for various VFS I/O interfaces.">vvp_io_args</a> *args;
<a name="l01195"></a>01195         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01196"></a>01196         ssize_t result;
<a name="l01197"></a>01197         __u16 refcheck;
<a name="l01198"></a>01198 
<a name="l01199"></a>01199         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01200"></a>01200         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01201"></a>01201                 <span class="keywordflow">return</span> PTR_ERR(env);
<a name="l01202"></a>01202 
<a name="l01203"></a>01203         args = ll_env_args(env, IO_NORMAL);
<a name="l01204"></a>01204         args-&gt;u.normal.via_iter = from;
<a name="l01205"></a>01205         args-&gt;u.normal.via_iocb = iocb;
<a name="l01206"></a>01206 
<a name="l01207"></a>01207         result = ll_file_io_generic(env, args, iocb-&gt;ki_filp, <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475" title="write system call">CIT_WRITE</a>,
<a name="l01208"></a>01208                                     &amp;iocb-&gt;ki_pos, iov_iter_count(from));
<a name="l01209"></a>01209         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01210"></a>01210         <span class="keywordflow">return</span> result;
<a name="l01211"></a>01211 }
<a name="l01212"></a>01212 
<a name="l01213"></a>01213 <span class="preprocessor">#ifndef HAVE_FILE_OPERATIONS_READ_WRITE_ITER</span>
<a name="l01214"></a>01214 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01215"></a>01215 <span class="comment"> * XXX: exact copy from kernel code (__generic_file_aio_write_nolock)</span>
<a name="l01216"></a>01216 <span class="comment"> */</span>
<a name="l01217"></a>01217 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_file_get_iov_count(<span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov,
<a name="l01218"></a>01218                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *nr_segs, <span class="keywordtype">size_t</span> *count)
<a name="l01219"></a>01219 {
<a name="l01220"></a>01220         <span class="keywordtype">size_t</span> cnt = 0;
<a name="l01221"></a>01221         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> seg;
<a name="l01222"></a>01222 
<a name="l01223"></a>01223         <span class="keywordflow">for</span> (seg = 0; seg &lt; *nr_segs; seg++) {
<a name="l01224"></a>01224                 <span class="keyword">const</span> <span class="keyword">struct </span>iovec *iv = &amp;iov[seg];
<a name="l01225"></a>01225 
<a name="l01226"></a>01226                 <span class="comment">/*</span>
<a name="l01227"></a>01227 <span class="comment">                 * If any segment has a negative length, or the cumulative</span>
<a name="l01228"></a>01228 <span class="comment">                 * length ever wraps negative then return -EINVAL.</span>
<a name="l01229"></a>01229 <span class="comment">                 */</span>
<a name="l01230"></a>01230                 cnt += iv-&gt;iov_len;
<a name="l01231"></a>01231                 <span class="keywordflow">if</span> (unlikely((ssize_t)(cnt|iv-&gt;iov_len) &lt; 0))
<a name="l01232"></a>01232                         <span class="keywordflow">return</span> -EINVAL;
<a name="l01233"></a>01233                 <span class="keywordflow">if</span> (access_ok(VERIFY_READ, iv-&gt;iov_base, iv-&gt;iov_len))
<a name="l01234"></a>01234                         <span class="keywordflow">continue</span>;
<a name="l01235"></a>01235                 <span class="keywordflow">if</span> (seg == 0)
<a name="l01236"></a>01236                         <span class="keywordflow">return</span> -EFAULT;
<a name="l01237"></a>01237                 *nr_segs = seg;
<a name="l01238"></a>01238                 cnt -= iv-&gt;iov_len;     <span class="comment">/* This segment is no good */</span>
<a name="l01239"></a>01239                 <span class="keywordflow">break</span>;
<a name="l01240"></a>01240         }
<a name="l01241"></a>01241         *count = cnt;
<a name="l01242"></a>01242         <span class="keywordflow">return</span> 0;
<a name="l01243"></a>01243 }
<a name="l01244"></a>01244 
<a name="l01245"></a>01245 <span class="keyword">static</span> ssize_t ll_file_aio_read(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov,
<a name="l01246"></a>01246                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nr_segs, loff_t pos)
<a name="l01247"></a>01247 {
<a name="l01248"></a>01248         <span class="keyword">struct </span>iovec *local_iov;
<a name="l01249"></a>01249         <span class="keyword">struct </span>iov_iter *to;
<a name="l01250"></a>01250         <span class="keywordtype">size_t</span> iov_count;
<a name="l01251"></a>01251         ssize_t result;
<a name="l01252"></a>01252         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env = NULL;
<a name="l01253"></a>01253         __u16 refcheck;
<a name="l01254"></a>01254         ENTRY;
<a name="l01255"></a>01255 
<a name="l01256"></a>01256         result = ll_file_get_iov_count(iov, &amp;nr_segs, &amp;iov_count);
<a name="l01257"></a>01257         <span class="keywordflow">if</span> (result)
<a name="l01258"></a>01258                 RETURN(result);
<a name="l01259"></a>01259 
<a name="l01260"></a>01260         <span class="keywordflow">if</span> (nr_segs == 1) {
<a name="l01261"></a>01261 
<a name="l01262"></a>01262                 env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01263"></a>01263                 <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01264"></a>01264                         RETURN(PTR_ERR(env));
<a name="l01265"></a>01265 
<a name="l01266"></a>01266                 local_iov = &amp;ll_env_info(env)-&gt;lti_local_iov;
<a name="l01267"></a>01267                 *local_iov = *iov;
<a name="l01268"></a>01268 
<a name="l01269"></a>01269         } <span class="keywordflow">else</span> {
<a name="l01270"></a>01270                 OBD_ALLOC(local_iov, <span class="keyword">sizeof</span>(*iov) * nr_segs);
<a name="l01271"></a>01271                 <span class="keywordflow">if</span> (local_iov == NULL)
<a name="l01272"></a>01272                         RETURN(-ENOMEM);
<a name="l01273"></a>01273 
<a name="l01274"></a>01274                 memcpy(local_iov, iov, <span class="keyword">sizeof</span>(*iov) * nr_segs);
<a name="l01275"></a>01275         }
<a name="l01276"></a>01276 
<a name="l01277"></a>01277         OBD_ALLOC_PTR(to);
<a name="l01278"></a>01278         <span class="keywordflow">if</span> (to == NULL) {
<a name="l01279"></a>01279                 result = -ENOMEM;
<a name="l01280"></a>01280                 <span class="keywordflow">goto</span> out;
<a name="l01281"></a>01281         }
<a name="l01282"></a>01282 <span class="preprocessor"># ifdef HAVE_IOV_ITER_INIT_DIRECTION</span>
<a name="l01283"></a>01283 <span class="preprocessor"></span>        iov_iter_init(to, READ, local_iov, nr_segs, iov_count);
<a name="l01284"></a>01284 <span class="preprocessor"># else </span><span class="comment">/* !HAVE_IOV_ITER_INIT_DIRECTION */</span>
<a name="l01285"></a>01285         iov_iter_init(to, local_iov, nr_segs, iov_count, 0);
<a name="l01286"></a>01286 <span class="preprocessor"># endif </span><span class="comment">/* HAVE_IOV_ITER_INIT_DIRECTION */</span>
<a name="l01287"></a>01287 
<a name="l01288"></a>01288         result = ll_file_read_iter(iocb, to);
<a name="l01289"></a>01289 
<a name="l01290"></a>01290         OBD_FREE_PTR(to);
<a name="l01291"></a>01291 out:
<a name="l01292"></a>01292         <span class="keywordflow">if</span> (nr_segs == 1)
<a name="l01293"></a>01293                 <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01294"></a>01294         <span class="keywordflow">else</span>
<a name="l01295"></a>01295                 OBD_FREE(local_iov, <span class="keyword">sizeof</span>(*iov) * nr_segs);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297         RETURN(result);
<a name="l01298"></a>01298 }
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 <span class="keyword">static</span> ssize_t ll_file_read(<span class="keyword">struct</span> file *file, <span class="keywordtype">char</span> __user *buf, <span class="keywordtype">size_t</span> count,
<a name="l01301"></a>01301                             loff_t *ppos)
<a name="l01302"></a>01302 {
<a name="l01303"></a>01303         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01304"></a>01304         <span class="keyword">struct </span>iovec   iov = { .iov_base = buf, .iov_len = count };
<a name="l01305"></a>01305         <span class="keyword">struct </span>kiocb  *kiocb;
<a name="l01306"></a>01306         ssize_t        result;
<a name="l01307"></a>01307         __u16          refcheck;
<a name="l01308"></a>01308         ENTRY;
<a name="l01309"></a>01309 
<a name="l01310"></a>01310         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01311"></a>01311         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01312"></a>01312                 RETURN(PTR_ERR(env));
<a name="l01313"></a>01313 
<a name="l01314"></a>01314         kiocb = &amp;ll_env_info(env)-&gt;lti_kiocb;
<a name="l01315"></a>01315         init_sync_kiocb(kiocb, file);
<a name="l01316"></a>01316         kiocb-&gt;ki_pos = *ppos;
<a name="l01317"></a>01317 <span class="preprocessor">#ifdef HAVE_KIOCB_KI_LEFT</span>
<a name="l01318"></a>01318 <span class="preprocessor"></span>        kiocb-&gt;ki_left = count;
<a name="l01319"></a>01319 <span class="preprocessor">#elif defined(HAVE_KI_NBYTES)</span>
<a name="l01320"></a>01320 <span class="preprocessor"></span>        kiocb-&gt;ki_nbytes = count;
<a name="l01321"></a>01321 <span class="preprocessor">#endif</span>
<a name="l01322"></a>01322 <span class="preprocessor"></span>
<a name="l01323"></a>01323         result = ll_file_aio_read(kiocb, &amp;iov, 1, kiocb-&gt;ki_pos);
<a name="l01324"></a>01324         *ppos = kiocb-&gt;ki_pos;
<a name="l01325"></a>01325 
<a name="l01326"></a>01326         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01327"></a>01327         RETURN(result);
<a name="l01328"></a>01328 }
<a name="l01329"></a>01329 
<a name="l01330"></a>01330 <span class="comment">/*</span>
<a name="l01331"></a>01331 <span class="comment"> * Write to a file (through the page cache).</span>
<a name="l01332"></a>01332 <span class="comment"> * AIO stuff</span>
<a name="l01333"></a>01333 <span class="comment"> */</span>
<a name="l01334"></a>01334 <span class="keyword">static</span> ssize_t ll_file_aio_write(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov,
<a name="l01335"></a>01335                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nr_segs, loff_t pos)
<a name="l01336"></a>01336 {
<a name="l01337"></a>01337         <span class="keyword">struct </span>iovec *local_iov;
<a name="l01338"></a>01338         <span class="keyword">struct </span>iov_iter *from;
<a name="l01339"></a>01339         <span class="keywordtype">size_t</span> iov_count;
<a name="l01340"></a>01340         ssize_t result;
<a name="l01341"></a>01341         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env = NULL;
<a name="l01342"></a>01342         __u16 refcheck;
<a name="l01343"></a>01343         ENTRY;
<a name="l01344"></a>01344 
<a name="l01345"></a>01345         result = ll_file_get_iov_count(iov, &amp;nr_segs, &amp;iov_count);
<a name="l01346"></a>01346         <span class="keywordflow">if</span> (result)
<a name="l01347"></a>01347                 RETURN(result);
<a name="l01348"></a>01348 
<a name="l01349"></a>01349         <span class="keywordflow">if</span> (nr_segs == 1) {
<a name="l01350"></a>01350                 env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01351"></a>01351                 <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01352"></a>01352                         RETURN(PTR_ERR(env));
<a name="l01353"></a>01353 
<a name="l01354"></a>01354                 local_iov = &amp;ll_env_info(env)-&gt;lti_local_iov;
<a name="l01355"></a>01355                 *local_iov = *iov;
<a name="l01356"></a>01356         } <span class="keywordflow">else</span> {
<a name="l01357"></a>01357                 OBD_ALLOC(local_iov, <span class="keyword">sizeof</span>(*iov) * nr_segs);
<a name="l01358"></a>01358                 <span class="keywordflow">if</span> (local_iov == NULL)
<a name="l01359"></a>01359                         RETURN(-ENOMEM);
<a name="l01360"></a>01360 
<a name="l01361"></a>01361                 memcpy(local_iov, iov, <span class="keyword">sizeof</span>(*iov) * nr_segs);
<a name="l01362"></a>01362         }
<a name="l01363"></a>01363 
<a name="l01364"></a>01364         OBD_ALLOC_PTR(from);
<a name="l01365"></a>01365         <span class="keywordflow">if</span> (from == NULL) {
<a name="l01366"></a>01366                 result = -ENOMEM;
<a name="l01367"></a>01367                 <span class="keywordflow">goto</span> out;
<a name="l01368"></a>01368         }
<a name="l01369"></a>01369 <span class="preprocessor"># ifdef HAVE_IOV_ITER_INIT_DIRECTION</span>
<a name="l01370"></a>01370 <span class="preprocessor"></span>        iov_iter_init(from, WRITE, local_iov, nr_segs, iov_count);
<a name="l01371"></a>01371 <span class="preprocessor"># else </span><span class="comment">/* !HAVE_IOV_ITER_INIT_DIRECTION */</span>
<a name="l01372"></a>01372         iov_iter_init(from, local_iov, nr_segs, iov_count, 0);
<a name="l01373"></a>01373 <span class="preprocessor"># endif </span><span class="comment">/* HAVE_IOV_ITER_INIT_DIRECTION */</span>
<a name="l01374"></a>01374 
<a name="l01375"></a>01375         result = ll_file_write_iter(iocb, from);
<a name="l01376"></a>01376 
<a name="l01377"></a>01377         OBD_FREE_PTR(from);
<a name="l01378"></a>01378 out:
<a name="l01379"></a>01379         <span class="keywordflow">if</span> (nr_segs == 1)
<a name="l01380"></a>01380                 <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01381"></a>01381         <span class="keywordflow">else</span>
<a name="l01382"></a>01382                 OBD_FREE(local_iov, <span class="keyword">sizeof</span>(*iov) * nr_segs);
<a name="l01383"></a>01383 
<a name="l01384"></a>01384         RETURN(result);
<a name="l01385"></a>01385 }
<a name="l01386"></a>01386 
<a name="l01387"></a>01387 <span class="keyword">static</span> ssize_t ll_file_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buf,
<a name="l01388"></a>01388                              <span class="keywordtype">size_t</span> count, loff_t *ppos)
<a name="l01389"></a>01389 {
<a name="l01390"></a>01390         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01391"></a>01391         <span class="keyword">struct </span>iovec   iov = { .iov_base = (<span class="keywordtype">void</span> __user *)buf,
<a name="l01392"></a>01392                                .iov_len = count };
<a name="l01393"></a>01393         <span class="keyword">struct </span>kiocb  *kiocb;
<a name="l01394"></a>01394         ssize_t        result;
<a name="l01395"></a>01395         __u16          refcheck;
<a name="l01396"></a>01396         ENTRY;
<a name="l01397"></a>01397 
<a name="l01398"></a>01398         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01399"></a>01399         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01400"></a>01400                 RETURN(PTR_ERR(env));
<a name="l01401"></a>01401 
<a name="l01402"></a>01402         kiocb = &amp;ll_env_info(env)-&gt;lti_kiocb;
<a name="l01403"></a>01403         init_sync_kiocb(kiocb, file);
<a name="l01404"></a>01404         kiocb-&gt;ki_pos = *ppos;
<a name="l01405"></a>01405 <span class="preprocessor">#ifdef HAVE_KIOCB_KI_LEFT</span>
<a name="l01406"></a>01406 <span class="preprocessor"></span>        kiocb-&gt;ki_left = count;
<a name="l01407"></a>01407 <span class="preprocessor">#elif defined(HAVE_KI_NBYTES)</span>
<a name="l01408"></a>01408 <span class="preprocessor"></span>        kiocb-&gt;ki_nbytes = count;
<a name="l01409"></a>01409 <span class="preprocessor">#endif</span>
<a name="l01410"></a>01410 <span class="preprocessor"></span>
<a name="l01411"></a>01411         result = ll_file_aio_write(kiocb, &amp;iov, 1, kiocb-&gt;ki_pos);
<a name="l01412"></a>01412         *ppos = kiocb-&gt;ki_pos;
<a name="l01413"></a>01413 
<a name="l01414"></a>01414         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01415"></a>01415         RETURN(result);
<a name="l01416"></a>01416 }
<a name="l01417"></a>01417 <span class="preprocessor">#endif </span><span class="comment">/* !HAVE_FILE_OPERATIONS_READ_WRITE_ITER */</span>
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 <span class="comment">/*</span>
<a name="l01420"></a>01420 <span class="comment"> * Send file content (through pagecache) somewhere with helper</span>
<a name="l01421"></a>01421 <span class="comment"> */</span>
<a name="l01422"></a>01422 <span class="keyword">static</span> ssize_t ll_file_splice_read(<span class="keyword">struct</span> file *in_file, loff_t *ppos,
<a name="l01423"></a>01423                                    <span class="keyword">struct</span> pipe_inode_info *pipe, <span class="keywordtype">size_t</span> count,
<a name="l01424"></a>01424                                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
<a name="l01425"></a>01425 {
<a name="l01426"></a>01426         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>      *env;
<a name="l01427"></a>01427         <span class="keyword">struct </span><a class="code" href="structvvp__io__args.html" title="IO arguments for various VFS I/O interfaces.">vvp_io_args</a> *args;
<a name="l01428"></a>01428         ssize_t             result;
<a name="l01429"></a>01429         __u16               refcheck;
<a name="l01430"></a>01430         ENTRY;
<a name="l01431"></a>01431 
<a name="l01432"></a>01432         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01433"></a>01433         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01434"></a>01434                 RETURN(PTR_ERR(env));
<a name="l01435"></a>01435 
<a name="l01436"></a>01436         args = ll_env_args(env, IO_SPLICE);
<a name="l01437"></a>01437         args-&gt;u.splice.via_pipe = pipe;
<a name="l01438"></a>01438         args-&gt;u.splice.via_flags = flags;
<a name="l01439"></a>01439 
<a name="l01440"></a>01440         result = ll_file_io_generic(env, args, in_file, <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a30c0e746c178fe52f3c6f3939df1b2cb" title="read system call">CIT_READ</a>, ppos, count);
<a name="l01441"></a>01441         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01442"></a>01442         RETURN(result);
<a name="l01443"></a>01443 }
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 <span class="keywordtype">int</span> ll_lov_setstripe_ea_info(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file,
<a name="l01446"></a>01446                              __u64  flags, <span class="keyword">struct</span> lov_user_md *lum,
<a name="l01447"></a>01447                              <span class="keywordtype">int</span> lum_size)
<a name="l01448"></a>01448 {
<a name="l01449"></a>01449         <span class="keyword">struct </span><a class="code" href="structlookup__intent.html">lookup_intent</a> oit = {
<a name="l01450"></a>01450                 .it_op = IT_OPEN,
<a name="l01451"></a>01451                 .it_flags = flags | MDS_OPEN_BY_FID,
<a name="l01452"></a>01452         };
<a name="l01453"></a>01453         <span class="keywordtype">int</span> rc;
<a name="l01454"></a>01454         ENTRY;
<a name="l01455"></a>01455 
<a name="l01456"></a>01456         ll_inode_size_lock(inode);
<a name="l01457"></a>01457         rc = ll_intent_file_open(file, lum, lum_size, &amp;oit);
<a name="l01458"></a>01458         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01459"></a>01459                 GOTO(out_unlock, rc);
<a name="l01460"></a>01460 
<a name="l01461"></a>01461         ll_release_openhandle(file-&gt;f_path.dentry, &amp;oit);
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 out_unlock:
<a name="l01464"></a>01464         ll_inode_size_unlock(inode);
<a name="l01465"></a>01465         ll_intent_release(&amp;oit);
<a name="l01466"></a>01466         cl_lov_delay_create_clear(&amp;file-&gt;f_flags);
<a name="l01467"></a>01467 
<a name="l01468"></a>01468         RETURN(rc);
<a name="l01469"></a>01469 }
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="keywordtype">int</span> ll_lov_getstripe_ea_info(<span class="keyword">struct</span> inode *inode, <span class="keyword">const</span> <span class="keywordtype">char</span> *filename,
<a name="l01472"></a>01472                              <span class="keyword">struct</span> lov_mds_md **lmmp, <span class="keywordtype">int</span> *lmm_size,
<a name="l01473"></a>01473                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> **request)
<a name="l01474"></a>01474 {
<a name="l01475"></a>01475         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a> *sbi = ll_i2sbi(inode);
<a name="l01476"></a>01476         <span class="keyword">struct </span><a class="code" href="structmdt__body.html">mdt_body</a>  *body;
<a name="l01477"></a>01477         <span class="keyword">struct </span>lov_mds_md *lmm = NULL;
<a name="l01478"></a>01478         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = NULL;
<a name="l01479"></a>01479         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a> *op_data;
<a name="l01480"></a>01480         <span class="keywordtype">int</span> rc, lmmsize;
<a name="l01481"></a>01481 
<a name="l01482"></a>01482         rc = ll_get_default_mdsize(sbi, &amp;lmmsize);
<a name="l01483"></a>01483         <span class="keywordflow">if</span> (rc)
<a name="l01484"></a>01484                 RETURN(rc);
<a name="l01485"></a>01485 
<a name="l01486"></a>01486         op_data = ll_prep_md_op_data(NULL, inode, NULL, filename,
<a name="l01487"></a>01487                                      strlen(filename), lmmsize,
<a name="l01488"></a>01488                                      LUSTRE_OPC_ANY, NULL);
<a name="l01489"></a>01489         <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l01490"></a>01490                 RETURN(PTR_ERR(op_data));
<a name="l01491"></a>01491 
<a name="l01492"></a>01492         op_data-&gt;op_valid = OBD_MD_FLEASIZE | OBD_MD_FLDIREA;
<a name="l01493"></a>01493         rc = md_getattr_name(sbi-&gt;ll_md_exp, op_data, &amp;req);
<a name="l01494"></a>01494         ll_finish_md_op_data(op_data);
<a name="l01495"></a>01495         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01496"></a>01496                 CDEBUG(D_INFO, <span class="stringliteral">&quot;md_getattr_name failed &quot;</span>
<a name="l01497"></a>01497                        <span class="stringliteral">&quot;on %s: rc %d\n&quot;</span>, filename, rc);
<a name="l01498"></a>01498                 GOTO(out, rc);
<a name="l01499"></a>01499         }
<a name="l01500"></a>01500 
<a name="l01501"></a>01501         body = <a class="code" href="group__req__layout.html#ga0d1ad53a1914c35470f3916e4bb4b8fe" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC reply buffer...">req_capsule_server_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_MDT_BODY);
<a name="l01502"></a>01502         LASSERT(body != NULL); <span class="comment">/* checked by mdc_getattr_name */</span>
<a name="l01503"></a>01503 
<a name="l01504"></a>01504         lmmsize = body-&gt;mbo_eadatasize;
<a name="l01505"></a>01505 
<a name="l01506"></a>01506         <span class="keywordflow">if</span> (!(body-&gt;mbo_valid &amp; (OBD_MD_FLEASIZE | OBD_MD_FLDIREA)) ||
<a name="l01507"></a>01507                         lmmsize == 0) {
<a name="l01508"></a>01508                 GOTO(out, rc = -ENODATA);
<a name="l01509"></a>01509         }
<a name="l01510"></a>01510 
<a name="l01511"></a>01511         lmm = <a class="code" href="group__req__layout.html#gaebc460299194b773def6ad6960826860" title="Utility that combines req_capsule_set_size() and req_capsule_server_get().">req_capsule_server_sized_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_MDT_MD, lmmsize);
<a name="l01512"></a>01512         LASSERT(lmm != NULL);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514         <span class="keywordflow">if</span> ((lmm-&gt;lmm_magic != cpu_to_le32(LOV_MAGIC_V1)) &amp;&amp;
<a name="l01515"></a>01515             (lmm-&gt;lmm_magic != cpu_to_le32(LOV_MAGIC_V3))) {
<a name="l01516"></a>01516                 GOTO(out, rc = -EPROTO);
<a name="l01517"></a>01517         }
<a name="l01518"></a>01518 
<a name="l01519"></a>01519         <span class="comment">/*</span>
<a name="l01520"></a>01520 <span class="comment">         * This is coming from the MDS, so is probably in</span>
<a name="l01521"></a>01521 <span class="comment">         * little endian.  We convert it to host endian before</span>
<a name="l01522"></a>01522 <span class="comment">         * passing it to userspace.</span>
<a name="l01523"></a>01523 <span class="comment">         */</span>
<a name="l01524"></a>01524         <span class="keywordflow">if</span> (LOV_MAGIC != cpu_to_le32(LOV_MAGIC)) {
<a name="l01525"></a>01525                 <span class="keywordtype">int</span> stripe_count;
<a name="l01526"></a>01526 
<a name="l01527"></a>01527                 stripe_count = le16_to_cpu(lmm-&gt;lmm_stripe_count);
<a name="l01528"></a>01528                 <span class="keywordflow">if</span> (le32_to_cpu(lmm-&gt;lmm_pattern) &amp; LOV_PATTERN_F_RELEASED)
<a name="l01529"></a>01529                         stripe_count = 0;
<a name="l01530"></a>01530 
<a name="l01531"></a>01531                 <span class="comment">/* if function called for directory - we should</span>
<a name="l01532"></a>01532 <span class="comment">                 * avoid swab not existent lsm objects */</span>
<a name="l01533"></a>01533                 <span class="keywordflow">if</span> (lmm-&gt;lmm_magic == cpu_to_le32(LOV_MAGIC_V1)) {
<a name="l01534"></a>01534                         lustre_swab_lov_user_md_v1((<span class="keyword">struct</span> <a class="code" href="structlov__user__md__v1.html">lov_user_md_v1</a> *)lmm);
<a name="l01535"></a>01535                         <span class="keywordflow">if</span> (S_ISREG(body-&gt;mbo_mode))
<a name="l01536"></a>01536                                 lustre_swab_lov_user_md_objects(
<a name="l01537"></a>01537                                     ((<span class="keyword">struct</span> <a class="code" href="structlov__user__md__v1.html">lov_user_md_v1</a> *)lmm)-&gt;lmm_objects,
<a name="l01538"></a>01538                                     stripe_count);
<a name="l01539"></a>01539                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lmm-&gt;lmm_magic == cpu_to_le32(LOV_MAGIC_V3)) {
<a name="l01540"></a>01540                         lustre_swab_lov_user_md_v3(
<a name="l01541"></a>01541                                 (<span class="keyword">struct</span> <a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a> *)lmm);
<a name="l01542"></a>01542                         <span class="keywordflow">if</span> (S_ISREG(body-&gt;mbo_mode))
<a name="l01543"></a>01543                                 lustre_swab_lov_user_md_objects(
<a name="l01544"></a>01544                                  ((<span class="keyword">struct</span> <a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a> *)lmm)-&gt;lmm_objects,
<a name="l01545"></a>01545                                  stripe_count);
<a name="l01546"></a>01546                 }
<a name="l01547"></a>01547         }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549 out:
<a name="l01550"></a>01550         *lmmp = lmm;
<a name="l01551"></a>01551         *lmm_size = lmmsize;
<a name="l01552"></a>01552         *request = req;
<a name="l01553"></a>01553         <span class="keywordflow">return</span> rc;
<a name="l01554"></a>01554 }
<a name="l01555"></a>01555 
<a name="l01556"></a>01556 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_lov_setea(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file,
<a name="l01557"></a>01557                             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
<a name="l01558"></a>01558 {
<a name="l01559"></a>01559         __u64                    flags = MDS_OPEN_HAS_OBJS | FMODE_WRITE;
<a name="l01560"></a>01560         <span class="keyword">struct </span>lov_user_md      *lump;
<a name="l01561"></a>01561         <span class="keywordtype">int</span>                      lum_size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>lov_user_md) +
<a name="l01562"></a>01562                                             sizeof(struct lov_user_ost_data);
<a name="l01563"></a>01563         <span class="keywordtype">int</span>                      rc;
<a name="l01564"></a>01564         ENTRY;
<a name="l01565"></a>01565 
<a name="l01566"></a>01566         <span class="keywordflow">if</span> (!cfs_capable(CFS_CAP_SYS_ADMIN))
<a name="l01567"></a>01567                 RETURN(-EPERM);
<a name="l01568"></a>01568 
<a name="l01569"></a>01569         OBD_ALLOC_LARGE(lump, lum_size);
<a name="l01570"></a>01570         <span class="keywordflow">if</span> (lump == NULL)
<a name="l01571"></a>01571                 RETURN(-ENOMEM);
<a name="l01572"></a>01572 
<a name="l01573"></a>01573         <span class="keywordflow">if</span> (copy_from_user(lump, (<span class="keyword">struct</span> lov_user_md __user *)arg, lum_size))
<a name="l01574"></a>01574                 GOTO(out_lump, rc = -EFAULT);
<a name="l01575"></a>01575 
<a name="l01576"></a>01576         rc = ll_lov_setstripe_ea_info(inode, file, flags, lump, lum_size);
<a name="l01577"></a>01577 
<a name="l01578"></a>01578 out_lump:
<a name="l01579"></a>01579         OBD_FREE_LARGE(lump, lum_size);
<a name="l01580"></a>01580         RETURN(rc);
<a name="l01581"></a>01581 }
<a name="l01582"></a>01582 
<a name="l01583"></a>01583 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_file_getstripe(<span class="keyword">struct</span> inode *inode,
<a name="l01584"></a>01584                              <span class="keyword">struct</span> lov_user_md __user *lum)
<a name="l01585"></a>01585 {
<a name="l01586"></a>01586         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>   *env;
<a name="l01587"></a>01587         __u16           refcheck;
<a name="l01588"></a>01588         <span class="keywordtype">int</span>             rc;
<a name="l01589"></a>01589         ENTRY;
<a name="l01590"></a>01590 
<a name="l01591"></a>01591         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01592"></a>01592         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01593"></a>01593                 RETURN(PTR_ERR(env));
<a name="l01594"></a>01594 
<a name="l01595"></a>01595         rc = <a class="code" href="group__cl__object.html#ga746cc5d7737450ca64ba6997f3e9afd8" title="Get stripe information of this object.">cl_object_getstripe</a>(env, ll_i2info(inode)-&gt;lli_clob, lum);
<a name="l01596"></a>01596         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01597"></a>01597         RETURN(rc);
<a name="l01598"></a>01598 }
<a name="l01599"></a>01599 
<a name="l01600"></a>01600 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_lov_setstripe(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file,
<a name="l01601"></a>01601                             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
<a name="l01602"></a>01602 {
<a name="l01603"></a>01603         <span class="keyword">struct </span>lov_user_md __user *lum = (<span class="keyword">struct </span>lov_user_md __user *)arg;
<a name="l01604"></a>01604         <span class="keyword">struct </span>lov_user_md        *klum;
<a name="l01605"></a>01605         <span class="keywordtype">int</span>                        lum_size, rc;
<a name="l01606"></a>01606         __u64                      flags = FMODE_WRITE;
<a name="l01607"></a>01607         ENTRY;
<a name="l01608"></a>01608 
<a name="l01609"></a>01609         rc = ll_copy_user_md(lum, &amp;klum);
<a name="l01610"></a>01610         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01611"></a>01611                 RETURN(rc);
<a name="l01612"></a>01612 
<a name="l01613"></a>01613         lum_size = rc;
<a name="l01614"></a>01614         rc = ll_lov_setstripe_ea_info(inode, file, flags, klum, lum_size);
<a name="l01615"></a>01615         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01616"></a>01616                 __u32 gen;
<a name="l01617"></a>01617 
<a name="l01618"></a>01618                 put_user(0, &amp;lum-&gt;lmm_stripe_count);
<a name="l01619"></a>01619 
<a name="l01620"></a>01620                 ll_layout_refresh(inode, &amp;gen);
<a name="l01621"></a>01621                 rc = ll_file_getstripe(inode, (<span class="keyword">struct</span> lov_user_md __user *)arg);
<a name="l01622"></a>01622         }
<a name="l01623"></a>01623 
<a name="l01624"></a>01624         OBD_FREE(klum, lum_size);
<a name="l01625"></a>01625         RETURN(rc);
<a name="l01626"></a>01626 }
<a name="l01627"></a>01627 
<a name="l01628"></a>01628 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01629"></a>01629 ll_get_grouplock(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
<a name="l01630"></a>01630 {
<a name="l01631"></a>01631         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a>   *lli = ll_i2info(inode);
<a name="l01632"></a>01632         <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a>    *fd = LUSTRE_FPRIVATE(file);
<a name="l01633"></a>01633         <span class="keyword">struct </span><a class="code" href="structll__grouplock.html">ll_grouplock</a>     grouplock;
<a name="l01634"></a>01634         <span class="keywordtype">int</span>                     rc;
<a name="l01635"></a>01635         ENTRY;
<a name="l01636"></a>01636 
<a name="l01637"></a>01637         <span class="keywordflow">if</span> (arg == 0) {
<a name="l01638"></a>01638                 CWARN(<span class="stringliteral">&quot;group id for group lock must not be 0\n&quot;</span>);
<a name="l01639"></a>01639                 RETURN(-EINVAL);
<a name="l01640"></a>01640         }
<a name="l01641"></a>01641 
<a name="l01642"></a>01642         <span class="keywordflow">if</span> (ll_file_nolock(file))
<a name="l01643"></a>01643                 RETURN(-EOPNOTSUPP);
<a name="l01644"></a>01644 
<a name="l01645"></a>01645         spin_lock(&amp;lli-&gt;lli_lock);
<a name="l01646"></a>01646         <span class="keywordflow">if</span> (fd-&gt;fd_flags &amp; LL_FILE_GROUP_LOCKED) {
<a name="l01647"></a>01647                 CWARN(<span class="stringliteral">&quot;group lock already existed with gid %lu\n&quot;</span>,
<a name="l01648"></a>01648                       fd-&gt;fd_grouplock.lg_gid);
<a name="l01649"></a>01649                 spin_unlock(&amp;lli-&gt;lli_lock);
<a name="l01650"></a>01650                 RETURN(-EINVAL);
<a name="l01651"></a>01651         }
<a name="l01652"></a>01652         LASSERT(fd-&gt;fd_grouplock.lg_lock == NULL);
<a name="l01653"></a>01653         spin_unlock(&amp;lli-&gt;lli_lock);
<a name="l01654"></a>01654 
<a name="l01655"></a>01655         rc = cl_get_grouplock(ll_i2info(inode)-&gt;lli_clob,
<a name="l01656"></a>01656                               arg, (file-&gt;f_flags &amp; O_NONBLOCK), &amp;grouplock);
<a name="l01657"></a>01657         <span class="keywordflow">if</span> (rc)
<a name="l01658"></a>01658                 RETURN(rc);
<a name="l01659"></a>01659 
<a name="l01660"></a>01660         spin_lock(&amp;lli-&gt;lli_lock);
<a name="l01661"></a>01661         <span class="keywordflow">if</span> (fd-&gt;fd_flags &amp; LL_FILE_GROUP_LOCKED) {
<a name="l01662"></a>01662                 spin_unlock(&amp;lli-&gt;lli_lock);
<a name="l01663"></a>01663                 CERROR(<span class="stringliteral">&quot;another thread just won the race\n&quot;</span>);
<a name="l01664"></a>01664                 cl_put_grouplock(&amp;grouplock);
<a name="l01665"></a>01665                 RETURN(-EINVAL);
<a name="l01666"></a>01666         }
<a name="l01667"></a>01667 
<a name="l01668"></a>01668         fd-&gt;fd_flags |= LL_FILE_GROUP_LOCKED;
<a name="l01669"></a>01669         fd-&gt;fd_grouplock = grouplock;
<a name="l01670"></a>01670         spin_unlock(&amp;lli-&gt;lli_lock);
<a name="l01671"></a>01671 
<a name="l01672"></a>01672         CDEBUG(D_INFO, <span class="stringliteral">&quot;group lock %lu obtained\n&quot;</span>, arg);
<a name="l01673"></a>01673         RETURN(0);
<a name="l01674"></a>01674 }
<a name="l01675"></a>01675 
<a name="l01676"></a>01676 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_put_grouplock(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file,
<a name="l01677"></a>01677                             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
<a name="l01678"></a>01678 {
<a name="l01679"></a>01679         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a>   *lli = ll_i2info(inode);
<a name="l01680"></a>01680         <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a>    *fd = LUSTRE_FPRIVATE(file);
<a name="l01681"></a>01681         <span class="keyword">struct </span><a class="code" href="structll__grouplock.html">ll_grouplock</a>     grouplock;
<a name="l01682"></a>01682         ENTRY;
<a name="l01683"></a>01683 
<a name="l01684"></a>01684         spin_lock(&amp;lli-&gt;lli_lock);
<a name="l01685"></a>01685         <span class="keywordflow">if</span> (!(fd-&gt;fd_flags &amp; LL_FILE_GROUP_LOCKED)) {
<a name="l01686"></a>01686                 spin_unlock(&amp;lli-&gt;lli_lock);
<a name="l01687"></a>01687                 CWARN(<span class="stringliteral">&quot;no group lock held\n&quot;</span>);
<a name="l01688"></a>01688                 RETURN(-EINVAL);
<a name="l01689"></a>01689         }
<a name="l01690"></a>01690 
<a name="l01691"></a>01691         LASSERT(fd-&gt;fd_grouplock.lg_lock != NULL);
<a name="l01692"></a>01692 
<a name="l01693"></a>01693         <span class="keywordflow">if</span> (fd-&gt;fd_grouplock.lg_gid != arg) {
<a name="l01694"></a>01694                 CWARN(<span class="stringliteral">&quot;group lock %lu doesn&apos;t match current id %lu\n&quot;</span>,
<a name="l01695"></a>01695                       arg, fd-&gt;fd_grouplock.lg_gid);
<a name="l01696"></a>01696                 spin_unlock(&amp;lli-&gt;lli_lock);
<a name="l01697"></a>01697                 RETURN(-EINVAL);
<a name="l01698"></a>01698         }
<a name="l01699"></a>01699 
<a name="l01700"></a>01700         grouplock = fd-&gt;fd_grouplock;
<a name="l01701"></a>01701         memset(&amp;fd-&gt;fd_grouplock, 0, <span class="keyword">sizeof</span>(fd-&gt;fd_grouplock));
<a name="l01702"></a>01702         fd-&gt;fd_flags &amp;= ~LL_FILE_GROUP_LOCKED;
<a name="l01703"></a>01703         spin_unlock(&amp;lli-&gt;lli_lock);
<a name="l01704"></a>01704 
<a name="l01705"></a>01705         cl_put_grouplock(&amp;grouplock);
<a name="l01706"></a>01706         CDEBUG(D_INFO, <span class="stringliteral">&quot;group lock %lu released\n&quot;</span>, arg);
<a name="l01707"></a>01707         RETURN(0);
<a name="l01708"></a>01708 }
<a name="l01709"></a>01709 
<a name="l01719"></a>01719 <span class="keywordtype">int</span> ll_release_openhandle(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> <a class="code" href="structlookup__intent.html">lookup_intent</a> *it)
<a name="l01720"></a>01720 {
<a name="l01721"></a>01721         <span class="keyword">struct </span>inode *inode = dentry-&gt;d_inode;
<a name="l01722"></a>01722         <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och;
<a name="l01723"></a>01723         <span class="keywordtype">int</span> rc;
<a name="l01724"></a>01724         ENTRY;
<a name="l01725"></a>01725 
<a name="l01726"></a>01726         LASSERT(inode);
<a name="l01727"></a>01727 
<a name="l01728"></a>01728         <span class="comment">/* Root ? Do nothing. */</span>
<a name="l01729"></a>01729         <span class="keywordflow">if</span> (dentry-&gt;d_inode-&gt;i_sb-&gt;s_root == dentry)
<a name="l01730"></a>01730                 RETURN(0);
<a name="l01731"></a>01731 
<a name="l01732"></a>01732         <span class="comment">/* No open handle to close? Move away */</span>
<a name="l01733"></a>01733         <span class="keywordflow">if</span> (!it_disposition(it, DISP_OPEN_OPEN))
<a name="l01734"></a>01734                 RETURN(0);
<a name="l01735"></a>01735 
<a name="l01736"></a>01736         LASSERT(it_open_error(DISP_OPEN_OPEN, it) == 0);
<a name="l01737"></a>01737 
<a name="l01738"></a>01738         OBD_ALLOC(och, <span class="keyword">sizeof</span>(*och));
<a name="l01739"></a>01739         <span class="keywordflow">if</span> (!och)
<a name="l01740"></a>01740                 GOTO(out, rc = -ENOMEM);
<a name="l01741"></a>01741 
<a name="l01742"></a>01742         ll_och_fill(ll_i2sbi(inode)-&gt;ll_md_exp, it, och);
<a name="l01743"></a>01743 
<a name="l01744"></a>01744         rc = ll_close_inode_openhandle(inode, och, 0, NULL);
<a name="l01745"></a>01745 out:
<a name="l01746"></a>01746         <span class="comment">/* this one is in place of ll_file_open */</span>
<a name="l01747"></a>01747         <span class="keywordflow">if</span> (it_disposition(it, DISP_ENQ_OPEN_REF)) {
<a name="l01748"></a>01748                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(it-&gt;it_request);
<a name="l01749"></a>01749                 it_clear_disposition(it, DISP_ENQ_OPEN_REF);
<a name="l01750"></a>01750         }
<a name="l01751"></a>01751         RETURN(rc);
<a name="l01752"></a>01752 }
<a name="l01753"></a>01753 
<a name="l01760"></a>01760 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_do_fiemap(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> fiemap *fiemap,
<a name="l01761"></a>01761                         <span class="keywordtype">size_t</span> num_bytes)
<a name="l01762"></a>01762 {
<a name="l01763"></a>01763         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>                   *env;
<a name="l01764"></a>01764         __u16                           refcheck;
<a name="l01765"></a>01765         <span class="keywordtype">int</span>                             rc = 0;
<a name="l01766"></a>01766         <span class="keyword">struct </span><a class="code" href="structll__fiemap__info__key.html">ll_fiemap_info_key</a>       fmkey = { .lfik_name = KEY_FIEMAP, };
<a name="l01767"></a>01767         ENTRY;
<a name="l01768"></a>01768 
<a name="l01769"></a>01769         <span class="comment">/* Checks for fiemap flags */</span>
<a name="l01770"></a>01770         <span class="keywordflow">if</span> (fiemap-&gt;fm_flags &amp; ~LUSTRE_FIEMAP_FLAGS_COMPAT) {
<a name="l01771"></a>01771                 fiemap-&gt;fm_flags &amp;= ~LUSTRE_FIEMAP_FLAGS_COMPAT;
<a name="l01772"></a>01772                 <span class="keywordflow">return</span> -EBADR;
<a name="l01773"></a>01773         }
<a name="l01774"></a>01774 
<a name="l01775"></a>01775         <span class="comment">/* Check for FIEMAP_FLAG_SYNC */</span>
<a name="l01776"></a>01776         <span class="keywordflow">if</span> (fiemap-&gt;fm_flags &amp; FIEMAP_FLAG_SYNC) {
<a name="l01777"></a>01777                 rc = filemap_fdatawrite(inode-&gt;i_mapping);
<a name="l01778"></a>01778                 <span class="keywordflow">if</span> (rc)
<a name="l01779"></a>01779                         <span class="keywordflow">return</span> rc;
<a name="l01780"></a>01780         }
<a name="l01781"></a>01781 
<a name="l01782"></a>01782         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01783"></a>01783         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01784"></a>01784                 RETURN(PTR_ERR(env));
<a name="l01785"></a>01785 
<a name="l01786"></a>01786         <span class="keywordflow">if</span> (i_size_read(inode) == 0) {
<a name="l01787"></a>01787                 rc = ll_glimpse_size(inode);
<a name="l01788"></a>01788                 <span class="keywordflow">if</span> (rc)
<a name="l01789"></a>01789                         GOTO(out, rc);
<a name="l01790"></a>01790         }
<a name="l01791"></a>01791 
<a name="l01792"></a>01792         fmkey.lfik_oa.o_valid = OBD_MD_FLID | OBD_MD_FLGROUP;
<a name="l01793"></a>01793         obdo_from_inode(&amp;fmkey.lfik_oa, inode, OBD_MD_FLSIZE);
<a name="l01794"></a>01794         obdo_set_parent_fid(&amp;fmkey.lfik_oa, &amp;ll_i2info(inode)-&gt;lli_fid);
<a name="l01795"></a>01795 
<a name="l01796"></a>01796         <span class="comment">/* If filesize is 0, then there would be no objects for mapping */</span>
<a name="l01797"></a>01797         <span class="keywordflow">if</span> (fmkey.lfik_oa.o_size == 0) {
<a name="l01798"></a>01798                 fiemap-&gt;fm_mapped_extents = 0;
<a name="l01799"></a>01799                 GOTO(out, rc = 0);
<a name="l01800"></a>01800         }
<a name="l01801"></a>01801 
<a name="l01802"></a>01802         fmkey.lfik_fiemap = *fiemap;
<a name="l01803"></a>01803 
<a name="l01804"></a>01804         rc = <a class="code" href="group__cl__object.html#gae661d62a9c4af07425119b1308c3ff61" title="Get fiemap extents from file object.">cl_object_fiemap</a>(env, ll_i2info(inode)-&gt;lli_clob,
<a name="l01805"></a>01805                               &amp;fmkey, fiemap, &amp;num_bytes);
<a name="l01806"></a>01806 out:
<a name="l01807"></a>01807         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01808"></a>01808         RETURN(rc);
<a name="l01809"></a>01809 }
<a name="l01810"></a>01810 
<a name="l01811"></a>01811 <span class="keywordtype">int</span> ll_fid2path(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">void</span> __user *arg)
<a name="l01812"></a>01812 {
<a name="l01813"></a>01813         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>       *exp = ll_i2mdexp(inode);
<a name="l01814"></a>01814         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structgetinfo__fid2path.html" title="fid2path request/reply structure">getinfo_fid2path</a> __user *gfin = arg;
<a name="l01815"></a>01815         __u32                    pathlen;
<a name="l01816"></a>01816         <span class="keyword">struct </span><a class="code" href="structgetinfo__fid2path.html" title="fid2path request/reply structure">getinfo_fid2path</a> *gfout;
<a name="l01817"></a>01817         <span class="keywordtype">size_t</span>                   outsize;
<a name="l01818"></a>01818         <span class="keywordtype">int</span>                      rc;
<a name="l01819"></a>01819 
<a name="l01820"></a>01820         ENTRY;
<a name="l01821"></a>01821 
<a name="l01822"></a>01822         <span class="keywordflow">if</span> (!cfs_capable(CFS_CAP_DAC_READ_SEARCH) &amp;&amp;
<a name="l01823"></a>01823             !(ll_i2sbi(inode)-&gt;ll_flags &amp; LL_SBI_USER_FID2PATH))
<a name="l01824"></a>01824                 RETURN(-EPERM);
<a name="l01825"></a>01825 
<a name="l01826"></a>01826         <span class="comment">/* Only need to get the buflen */</span>
<a name="l01827"></a>01827         <span class="keywordflow">if</span> (get_user(pathlen, &amp;gfin-&gt;gf_pathlen))
<a name="l01828"></a>01828                 RETURN(-EFAULT);
<a name="l01829"></a>01829 
<a name="l01830"></a>01830         <span class="keywordflow">if</span> (pathlen &gt; PATH_MAX)
<a name="l01831"></a>01831                 RETURN(-EINVAL);
<a name="l01832"></a>01832 
<a name="l01833"></a>01833         outsize = <span class="keyword">sizeof</span>(*gfout) + pathlen;
<a name="l01834"></a>01834         OBD_ALLOC(gfout, outsize);
<a name="l01835"></a>01835         <span class="keywordflow">if</span> (gfout == NULL)
<a name="l01836"></a>01836                 RETURN(-ENOMEM);
<a name="l01837"></a>01837 
<a name="l01838"></a>01838         <span class="keywordflow">if</span> (copy_from_user(gfout, arg, <span class="keyword">sizeof</span>(*gfout)))
<a name="l01839"></a>01839                 GOTO(gf_free, rc = -EFAULT);
<a name="l01840"></a>01840         <span class="comment">/* append root FID after gfout to let MDT know the root FID so that it</span>
<a name="l01841"></a>01841 <span class="comment">         * can lookup the correct path, this is mainly for fileset.</span>
<a name="l01842"></a>01842 <span class="comment">         * old server without fileset mount support will ignore this. */</span>
<a name="l01843"></a>01843         *gfout-&gt;gf_u.gf_root_fid = *ll_inode2fid(inode);
<a name="l01844"></a>01844 
<a name="l01845"></a>01845         <span class="comment">/* Call mdc_iocontrol */</span>
<a name="l01846"></a>01846         rc = obd_iocontrol(OBD_IOC_FID2PATH, exp, outsize, gfout, NULL);
<a name="l01847"></a>01847         <span class="keywordflow">if</span> (rc != 0)
<a name="l01848"></a>01848                 GOTO(gf_free, rc);
<a name="l01849"></a>01849 
<a name="l01850"></a>01850         <span class="keywordflow">if</span> (copy_to_user(arg, gfout, outsize))
<a name="l01851"></a>01851                 rc = -EFAULT;
<a name="l01852"></a>01852 
<a name="l01853"></a>01853 gf_free:
<a name="l01854"></a>01854         OBD_FREE(gfout, outsize);
<a name="l01855"></a>01855         RETURN(rc);
<a name="l01856"></a>01856 }
<a name="l01857"></a>01857 
<a name="l01858"></a>01858 <span class="comment">/*</span>
<a name="l01859"></a>01859 <span class="comment"> * Read the data_version for inode.</span>
<a name="l01860"></a>01860 <span class="comment"> *</span>
<a name="l01861"></a>01861 <span class="comment"> * This value is computed using stripe object version on OST.</span>
<a name="l01862"></a>01862 <span class="comment"> * Version is computed using server side locking.</span>
<a name="l01863"></a>01863 <span class="comment"> *</span>
<a name="l01864"></a>01864 <span class="comment"> * @param flags if do sync on the OST side;</span>
<a name="l01865"></a>01865 <span class="comment"> *              0: no sync</span>
<a name="l01866"></a>01866 <span class="comment"> *              LL_DV_RD_FLUSH: flush dirty pages, LCK_PR on OSTs</span>
<a name="l01867"></a>01867 <span class="comment"> *              LL_DV_WR_FLUSH: drop all caching pages, LCK_PW on OSTs</span>
<a name="l01868"></a>01868 <span class="comment"> */</span>
<a name="l01869"></a>01869 <span class="keywordtype">int</span> ll_data_version(<span class="keyword">struct</span> inode *inode, __u64 *data_version, <span class="keywordtype">int</span> flags)
<a name="l01870"></a>01870 {
<a name="l01871"></a>01871         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj = ll_i2info(inode)-&gt;lli_clob;
<a name="l01872"></a>01872         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01873"></a>01873         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io;
<a name="l01874"></a>01874         __u16  refcheck;
<a name="l01875"></a>01875         <span class="keywordtype">int</span> result;
<a name="l01876"></a>01876 
<a name="l01877"></a>01877         ENTRY;
<a name="l01878"></a>01878 
<a name="l01879"></a>01879         <span class="comment">/* If no file object initialized, we consider its version is 0. */</span>
<a name="l01880"></a>01880         <span class="keywordflow">if</span> (obj == NULL) {
<a name="l01881"></a>01881                 *data_version = 0;
<a name="l01882"></a>01882                 RETURN(0);
<a name="l01883"></a>01883         }
<a name="l01884"></a>01884 
<a name="l01885"></a>01885         env = <a class="code" href="group__cl__env.html#ga17240d2c6cef5226d4ec8c0b4046afa1" title="Returns lu_env: if there already is an environment associated with the current thread...">cl_env_get</a>(&amp;refcheck);
<a name="l01886"></a>01886         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01887"></a>01887                 RETURN(PTR_ERR(env));
<a name="l01888"></a>01888 
<a name="l01889"></a>01889         io = vvp_env_thread_io(env);
<a name="l01890"></a>01890         io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a> = obj;
<a name="l01891"></a>01891         io-&gt;u.ci_data_version.dv_data_version = 0;
<a name="l01892"></a>01892         io-&gt;u.ci_data_version.dv_flags = flags;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894 restart:
<a name="l01895"></a>01895         <span class="keywordflow">if</span> (<a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_init</a>(env, io, <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ae0e5d488dc0faa7eca8a7ab4a48cbc25" title="get data version">CIT_DATA_VERSION</a>, io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a>) == 0)
<a name="l01896"></a>01896                 result = <a class="code" href="group__cl__io.html#ga2b13e91188661c45925b56e88b000c6e" title="Main io loop.">cl_io_loop</a>(env, io);
<a name="l01897"></a>01897         <span class="keywordflow">else</span>
<a name="l01898"></a>01898                 result = io-&gt;ci_result;
<a name="l01899"></a>01899 
<a name="l01900"></a>01900         *data_version = io-&gt;u.ci_data_version.dv_data_version;
<a name="l01901"></a>01901 
<a name="l01902"></a>01902         <a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>(env, io);
<a name="l01903"></a>01903 
<a name="l01904"></a>01904         <span class="keywordflow">if</span> (unlikely(io-&gt;<a class="code" href="structcl__io.html#a425b5ecdec17c901b3c8d8e09327d902" title="The whole IO need to be restarted because layout has been changed.">ci_need_restart</a>))
<a name="l01905"></a>01905                 <span class="keywordflow">goto</span> restart;
<a name="l01906"></a>01906 
<a name="l01907"></a>01907         <a class="code" href="group__cl__env.html#ga9cf31d221b7596143ff46bd799f19cf2" title="Release an environment.">cl_env_put</a>(env, &amp;refcheck);
<a name="l01908"></a>01908 
<a name="l01909"></a>01909         RETURN(result);
<a name="l01910"></a>01910 }
<a name="l01911"></a>01911 
<a name="l01912"></a>01912 <span class="comment">/*</span>
<a name="l01913"></a>01913 <span class="comment"> * Trigger a HSM release request for the provided inode.</span>
<a name="l01914"></a>01914 <span class="comment"> */</span>
<a name="l01915"></a>01915 <span class="keywordtype">int</span> ll_hsm_release(<span class="keyword">struct</span> inode *inode)
<a name="l01916"></a>01916 {
<a name="l01917"></a>01917         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a> nest;
<a name="l01918"></a>01918         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l01919"></a>01919         <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och = NULL;
<a name="l01920"></a>01920         __u64 data_version = 0;
<a name="l01921"></a>01921         <span class="keywordtype">int</span> rc;
<a name="l01922"></a>01922         ENTRY;
<a name="l01923"></a>01923 
<a name="l01924"></a>01924         CDEBUG(D_INODE, <span class="stringliteral">&quot;%s: Releasing file &quot;</span>DFID<span class="stringliteral">&quot;.\n&quot;</span>,
<a name="l01925"></a>01925                ll_get_fsname(inode-&gt;i_sb, NULL, 0),
<a name="l01926"></a>01926                PFID(&amp;ll_i2info(inode)-&gt;lli_fid));
<a name="l01927"></a>01927 
<a name="l01928"></a>01928         och = ll_lease_open(inode, NULL, FMODE_WRITE, MDS_OPEN_RELEASE);
<a name="l01929"></a>01929         <span class="keywordflow">if</span> (IS_ERR(och))
<a name="l01930"></a>01930                 GOTO(out, rc = PTR_ERR(och));
<a name="l01931"></a>01931 
<a name="l01932"></a>01932         <span class="comment">/* Grab latest data_version and [am]time values */</span>
<a name="l01933"></a>01933         rc = ll_data_version(inode, &amp;data_version, LL_DV_WR_FLUSH);
<a name="l01934"></a>01934         <span class="keywordflow">if</span> (rc != 0)
<a name="l01935"></a>01935                 GOTO(out, rc);
<a name="l01936"></a>01936 
<a name="l01937"></a>01937         env = cl_env_nested_get(&amp;nest);
<a name="l01938"></a>01938         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l01939"></a>01939                 GOTO(out, rc = PTR_ERR(env));
<a name="l01940"></a>01940 
<a name="l01941"></a>01941         ll_merge_attr(env, inode);
<a name="l01942"></a>01942         cl_env_nested_put(&amp;nest, env);
<a name="l01943"></a>01943 
<a name="l01944"></a>01944         <span class="comment">/* Release the file.</span>
<a name="l01945"></a>01945 <span class="comment">         * NB: lease lock handle is released in mdc_hsm_release_pack() because</span>
<a name="l01946"></a>01946 <span class="comment">         * we still need it to pack l_remote_handle to MDT. */</span>
<a name="l01947"></a>01947         rc = ll_close_inode_openhandle(inode, och, MDS_HSM_RELEASE,
<a name="l01948"></a>01948                                        &amp;data_version);
<a name="l01949"></a>01949         och = NULL;
<a name="l01950"></a>01950 
<a name="l01951"></a>01951         EXIT;
<a name="l01952"></a>01952 out:
<a name="l01953"></a>01953         <span class="keywordflow">if</span> (och != NULL &amp;&amp; !IS_ERR(och)) <span class="comment">/* close the file */</span>
<a name="l01954"></a>01954                 ll_lease_close(och, inode, NULL);
<a name="l01955"></a>01955 
<a name="l01956"></a>01956         <span class="keywordflow">return</span> rc;
<a name="l01957"></a>01957 }
<a name="l01958"></a>01958 
<a name="l01959"></a>01959 <span class="keyword">struct </span>ll_swap_stack {
<a name="l01960"></a>01960         __u64                    dv1;
<a name="l01961"></a>01961         __u64                    dv2;
<a name="l01962"></a>01962         <span class="keyword">struct </span>inode            *inode1;
<a name="l01963"></a>01963         <span class="keyword">struct </span>inode            *inode2;
<a name="l01964"></a>01964         <span class="keywordtype">bool</span>                     check_dv1;
<a name="l01965"></a>01965         <span class="keywordtype">bool</span>                     check_dv2;
<a name="l01966"></a>01966 };
<a name="l01967"></a>01967 
<a name="l01968"></a>01968 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_swap_layouts(<span class="keyword">struct</span> file *file1, <span class="keyword">struct</span> file *file2,
<a name="l01969"></a>01969                            <span class="keyword">struct</span> <a class="code" href="structlustre__swap__layouts.html">lustre_swap_layouts</a> *lsl)
<a name="l01970"></a>01970 {
<a name="l01971"></a>01971         <span class="keyword">struct </span><a class="code" href="structmdc__swap__layouts.html" title="layout swap request structure fid1 and fid2 are in mdt_body">mdc_swap_layouts</a>  msl;
<a name="l01972"></a>01972         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a>       *op_data;
<a name="l01973"></a>01973         __u32                    gid;
<a name="l01974"></a>01974         __u64                    dv;
<a name="l01975"></a>01975         <span class="keyword">struct </span>ll_swap_stack    *llss = NULL;
<a name="l01976"></a>01976         <span class="keywordtype">int</span>                      rc;
<a name="l01977"></a>01977 
<a name="l01978"></a>01978         OBD_ALLOC_PTR(llss);
<a name="l01979"></a>01979         <span class="keywordflow">if</span> (llss == NULL)
<a name="l01980"></a>01980                 RETURN(-ENOMEM);
<a name="l01981"></a>01981 
<a name="l01982"></a>01982         llss-&gt;inode1 = file1-&gt;f_path.dentry-&gt;d_inode;
<a name="l01983"></a>01983         llss-&gt;inode2 = file2-&gt;f_path.dentry-&gt;d_inode;
<a name="l01984"></a>01984 
<a name="l01985"></a>01985         rc = ll_check_swap_layouts_validity(llss-&gt;inode1, llss-&gt;inode2);
<a name="l01986"></a>01986         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01987"></a>01987                 GOTO(free, rc);
<a name="l01988"></a>01988 
<a name="l01989"></a>01989         <span class="comment">/* we use 2 bool because it is easier to swap than 2 bits */</span>
<a name="l01990"></a>01990         <span class="keywordflow">if</span> (lsl-&gt;sl_flags &amp; SWAP_LAYOUTS_CHECK_DV1)
<a name="l01991"></a>01991                 llss-&gt;check_dv1 = <span class="keyword">true</span>;
<a name="l01992"></a>01992 
<a name="l01993"></a>01993         <span class="keywordflow">if</span> (lsl-&gt;sl_flags &amp; SWAP_LAYOUTS_CHECK_DV2)
<a name="l01994"></a>01994                 llss-&gt;check_dv2 = <span class="keyword">true</span>;
<a name="l01995"></a>01995 
<a name="l01996"></a>01996         <span class="comment">/* we cannot use lsl-&gt;sl_dvX directly because we may swap them */</span>
<a name="l01997"></a>01997         llss-&gt;dv1 = lsl-&gt;sl_dv1;
<a name="l01998"></a>01998         llss-&gt;dv2 = lsl-&gt;sl_dv2;
<a name="l01999"></a>01999 
<a name="l02000"></a>02000         rc = lu_fid_cmp(ll_inode2fid(llss-&gt;inode1), ll_inode2fid(llss-&gt;inode2));
<a name="l02001"></a>02001         <span class="keywordflow">if</span> (rc == 0) <span class="comment">/* same file, done! */</span>
<a name="l02002"></a>02002                 GOTO(free, rc);
<a name="l02003"></a>02003 
<a name="l02004"></a>02004         <span class="keywordflow">if</span> (rc &lt; 0) { <span class="comment">/* sequentialize it */</span>
<a name="l02005"></a>02005                 swap(llss-&gt;inode1, llss-&gt;inode2);
<a name="l02006"></a>02006                 swap(file1, file2);
<a name="l02007"></a>02007                 swap(llss-&gt;dv1, llss-&gt;dv2);
<a name="l02008"></a>02008                 swap(llss-&gt;check_dv1, llss-&gt;check_dv2);
<a name="l02009"></a>02009         }
<a name="l02010"></a>02010 
<a name="l02011"></a>02011         gid = lsl-&gt;sl_gid;
<a name="l02012"></a>02012         <span class="keywordflow">if</span> (gid != 0) { <span class="comment">/* application asks to flush dirty cache */</span>
<a name="l02013"></a>02013                 rc = ll_get_grouplock(llss-&gt;inode1, file1, gid);
<a name="l02014"></a>02014                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02015"></a>02015                         GOTO(free, rc);
<a name="l02016"></a>02016 
<a name="l02017"></a>02017                 rc = ll_get_grouplock(llss-&gt;inode2, file2, gid);
<a name="l02018"></a>02018                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02019"></a>02019                         ll_put_grouplock(llss-&gt;inode1, file1, gid);
<a name="l02020"></a>02020                         GOTO(free, rc);
<a name="l02021"></a>02021                 }
<a name="l02022"></a>02022         }
<a name="l02023"></a>02023 
<a name="l02024"></a>02024         <span class="comment">/* ultimate check, before swaping the layouts we check if</span>
<a name="l02025"></a>02025 <span class="comment">         * dataversion has changed (if requested) */</span>
<a name="l02026"></a>02026         <span class="keywordflow">if</span> (llss-&gt;check_dv1) {
<a name="l02027"></a>02027                 rc = ll_data_version(llss-&gt;inode1, &amp;dv, 0);
<a name="l02028"></a>02028                 <span class="keywordflow">if</span> (rc)
<a name="l02029"></a>02029                         GOTO(putgl, rc);
<a name="l02030"></a>02030                 <span class="keywordflow">if</span> (dv != llss-&gt;dv1)
<a name="l02031"></a>02031                         GOTO(putgl, rc = -EAGAIN);
<a name="l02032"></a>02032         }
<a name="l02033"></a>02033 
<a name="l02034"></a>02034         <span class="keywordflow">if</span> (llss-&gt;check_dv2) {
<a name="l02035"></a>02035                 rc = ll_data_version(llss-&gt;inode2, &amp;dv, 0);
<a name="l02036"></a>02036                 <span class="keywordflow">if</span> (rc)
<a name="l02037"></a>02037                         GOTO(putgl, rc);
<a name="l02038"></a>02038                 <span class="keywordflow">if</span> (dv != llss-&gt;dv2)
<a name="l02039"></a>02039                         GOTO(putgl, rc = -EAGAIN);
<a name="l02040"></a>02040         }
<a name="l02041"></a>02041 
<a name="l02042"></a>02042         <span class="comment">/* struct md_op_data is used to send the swap args to the mdt</span>
<a name="l02043"></a>02043 <span class="comment">         * only flags is missing, so we use struct mdc_swap_layouts</span>
<a name="l02044"></a>02044 <span class="comment">         * through the md_op_data-&gt;op_data */</span>
<a name="l02045"></a>02045         <span class="comment">/* flags from user space have to be converted before they are send to</span>
<a name="l02046"></a>02046 <span class="comment">         * server, no flag is sent today, they are only used on the client */</span>
<a name="l02047"></a>02047         msl.msl_flags = 0;
<a name="l02048"></a>02048         rc = -ENOMEM;
<a name="l02049"></a>02049         op_data = ll_prep_md_op_data(NULL, llss-&gt;inode1, llss-&gt;inode2, NULL, 0,
<a name="l02050"></a>02050                                      0, LUSTRE_OPC_ANY, &amp;msl);
<a name="l02051"></a>02051         <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l02052"></a>02052                 GOTO(free, rc = PTR_ERR(op_data));
<a name="l02053"></a>02053 
<a name="l02054"></a>02054         rc = obd_iocontrol(LL_IOC_LOV_SWAP_LAYOUTS, ll_i2mdexp(llss-&gt;inode1),
<a name="l02055"></a>02055                            <span class="keyword">sizeof</span>(*op_data), op_data, NULL);
<a name="l02056"></a>02056         ll_finish_md_op_data(op_data);
<a name="l02057"></a>02057 
<a name="l02058"></a>02058         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02059"></a>02059                 GOTO(putgl, rc);
<a name="l02060"></a>02060 
<a name="l02061"></a>02061 putgl:
<a name="l02062"></a>02062         <span class="keywordflow">if</span> (gid != 0) {
<a name="l02063"></a>02063                 ll_put_grouplock(llss-&gt;inode2, file2, gid);
<a name="l02064"></a>02064                 ll_put_grouplock(llss-&gt;inode1, file1, gid);
<a name="l02065"></a>02065         }
<a name="l02066"></a>02066 
<a name="l02067"></a>02067 free:
<a name="l02068"></a>02068         <span class="keywordflow">if</span> (llss != NULL)
<a name="l02069"></a>02069                 OBD_FREE_PTR(llss);
<a name="l02070"></a>02070 
<a name="l02071"></a>02071         RETURN(rc);
<a name="l02072"></a>02072 }
<a name="l02073"></a>02073 
<a name="l02074"></a>02074 <span class="keywordtype">int</span> ll_hsm_state_set(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> <a class="code" href="structhsm__state__set.html">hsm_state_set</a> *hss)
<a name="l02075"></a>02075 {
<a name="l02076"></a>02076         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a>       *op_data;
<a name="l02077"></a>02077         <span class="keywordtype">int</span>                      rc;
<a name="l02078"></a>02078         ENTRY;
<a name="l02079"></a>02079 
<a name="l02080"></a>02080         <span class="comment">/* Detect out-of range masks */</span>
<a name="l02081"></a>02081         <span class="keywordflow">if</span> ((hss-&gt;hss_setmask | hss-&gt;hss_clearmask) &amp; ~HSM_FLAGS_MASK)
<a name="l02082"></a>02082                 RETURN(-EINVAL);
<a name="l02083"></a>02083 
<a name="l02084"></a>02084         <span class="comment">/* Non-root users are forbidden to set or clear flags which are</span>
<a name="l02085"></a>02085 <span class="comment">         * NOT defined in HSM_USER_MASK. */</span>
<a name="l02086"></a>02086         <span class="keywordflow">if</span> (((hss-&gt;hss_setmask | hss-&gt;hss_clearmask) &amp; ~HSM_USER_MASK) &amp;&amp;
<a name="l02087"></a>02087             !cfs_capable(CFS_CAP_SYS_ADMIN))
<a name="l02088"></a>02088                 RETURN(-EPERM);
<a name="l02089"></a>02089 
<a name="l02090"></a>02090         <span class="comment">/* Detect out-of range archive id */</span>
<a name="l02091"></a>02091         <span class="keywordflow">if</span> ((hss-&gt;hss_valid &amp; HSS_ARCHIVE_ID) &amp;&amp;
<a name="l02092"></a>02092             (hss-&gt;hss_archive_id &gt; LL_HSM_MAX_ARCHIVE))
<a name="l02093"></a>02093                 RETURN(-EINVAL);
<a name="l02094"></a>02094 
<a name="l02095"></a>02095         op_data = ll_prep_md_op_data(NULL, inode, NULL, NULL, 0, 0,
<a name="l02096"></a>02096                                      LUSTRE_OPC_ANY, hss);
<a name="l02097"></a>02097         <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l02098"></a>02098                 RETURN(PTR_ERR(op_data));
<a name="l02099"></a>02099 
<a name="l02100"></a>02100         rc = obd_iocontrol(LL_IOC_HSM_STATE_SET, ll_i2mdexp(inode),
<a name="l02101"></a>02101                            <span class="keyword">sizeof</span>(*op_data), op_data, NULL);
<a name="l02102"></a>02102 
<a name="l02103"></a>02103         ll_finish_md_op_data(op_data);
<a name="l02104"></a>02104 
<a name="l02105"></a>02105         RETURN(rc);
<a name="l02106"></a>02106 }
<a name="l02107"></a>02107 
<a name="l02108"></a>02108 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_hsm_import(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file,
<a name="l02109"></a>02109                          <span class="keyword">struct</span> <a class="code" href="structhsm__user__import.html">hsm_user_import</a> *hui)
<a name="l02110"></a>02110 {
<a name="l02111"></a>02111         <span class="keyword">struct </span><a class="code" href="structhsm__state__set.html">hsm_state_set</a>    *hss = NULL;
<a name="l02112"></a>02112         <span class="keyword">struct </span>iattr            *attr = NULL;
<a name="l02113"></a>02113         <span class="keywordtype">int</span>                      rc;
<a name="l02114"></a>02114         ENTRY;
<a name="l02115"></a>02115 
<a name="l02116"></a>02116         <span class="keywordflow">if</span> (!S_ISREG(inode-&gt;i_mode))
<a name="l02117"></a>02117                 RETURN(-EINVAL);
<a name="l02118"></a>02118 
<a name="l02119"></a>02119         <span class="comment">/* set HSM flags */</span>
<a name="l02120"></a>02120         OBD_ALLOC_PTR(hss);
<a name="l02121"></a>02121         <span class="keywordflow">if</span> (hss == NULL)
<a name="l02122"></a>02122                 GOTO(out, rc = -ENOMEM);
<a name="l02123"></a>02123 
<a name="l02124"></a>02124         hss-&gt;hss_valid = HSS_SETMASK | HSS_ARCHIVE_ID;
<a name="l02125"></a>02125         hss-&gt;hss_archive_id = hui-&gt;hui_archive_id;
<a name="l02126"></a>02126         hss-&gt;hss_setmask = HS_ARCHIVED | HS_EXISTS | HS_RELEASED;
<a name="l02127"></a>02127         rc = ll_hsm_state_set(inode, hss);
<a name="l02128"></a>02128         <span class="keywordflow">if</span> (rc != 0)
<a name="l02129"></a>02129                 GOTO(out, rc);
<a name="l02130"></a>02130 
<a name="l02131"></a>02131         OBD_ALLOC_PTR(attr);
<a name="l02132"></a>02132         <span class="keywordflow">if</span> (attr == NULL)
<a name="l02133"></a>02133                 GOTO(out, rc = -ENOMEM);
<a name="l02134"></a>02134 
<a name="l02135"></a>02135         attr-&gt;ia_mode = hui-&gt;hui_mode &amp; (S_IRWXU | S_IRWXG | S_IRWXO);
<a name="l02136"></a>02136         attr-&gt;ia_mode |= S_IFREG;
<a name="l02137"></a>02137         attr-&gt;ia_uid = make_kuid(&amp;init_user_ns, hui-&gt;hui_uid);
<a name="l02138"></a>02138         attr-&gt;ia_gid = make_kgid(&amp;init_user_ns, hui-&gt;hui_gid);
<a name="l02139"></a>02139         attr-&gt;ia_size = hui-&gt;hui_size;
<a name="l02140"></a>02140         attr-&gt;ia_mtime.tv_sec = hui-&gt;hui_mtime;
<a name="l02141"></a>02141         attr-&gt;ia_mtime.tv_nsec = hui-&gt;hui_mtime_ns;
<a name="l02142"></a>02142         attr-&gt;ia_atime.tv_sec = hui-&gt;hui_atime;
<a name="l02143"></a>02143         attr-&gt;ia_atime.tv_nsec = hui-&gt;hui_atime_ns;
<a name="l02144"></a>02144 
<a name="l02145"></a>02145         attr-&gt;ia_valid = ATTR_SIZE | ATTR_MODE | ATTR_FORCE |
<a name="l02146"></a>02146                          ATTR_UID | ATTR_GID |
<a name="l02147"></a>02147                          ATTR_MTIME | ATTR_MTIME_SET |
<a name="l02148"></a>02148                          ATTR_ATIME | ATTR_ATIME_SET;
<a name="l02149"></a>02149 
<a name="l02150"></a>02150         mutex_lock(&amp;inode-&gt;i_mutex);
<a name="l02151"></a>02151 
<a name="l02152"></a>02152         rc = ll_setattr_raw(file-&gt;f_path.dentry, attr, <span class="keyword">true</span>);
<a name="l02153"></a>02153         <span class="keywordflow">if</span> (rc == -ENODATA)
<a name="l02154"></a>02154                 rc = 0;
<a name="l02155"></a>02155 
<a name="l02156"></a>02156         mutex_unlock(&amp;inode-&gt;i_mutex);
<a name="l02157"></a>02157 
<a name="l02158"></a>02158 out:
<a name="l02159"></a>02159         <span class="keywordflow">if</span> (hss != NULL)
<a name="l02160"></a>02160                 OBD_FREE_PTR(hss);
<a name="l02161"></a>02161 
<a name="l02162"></a>02162         <span class="keywordflow">if</span> (attr != NULL)
<a name="l02163"></a>02163                 OBD_FREE_PTR(attr);
<a name="l02164"></a>02164 
<a name="l02165"></a>02165         RETURN(rc);
<a name="l02166"></a>02166 }
<a name="l02167"></a>02167 
<a name="l02168"></a>02168 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">long</span> ll_lease_type_from_fmode(fmode_t fmode)
<a name="l02169"></a>02169 {
<a name="l02170"></a>02170         <span class="keywordflow">return</span> ((fmode &amp; FMODE_READ) ? LL_LEASE_RDLCK : 0) |
<a name="l02171"></a>02171                ((fmode &amp; FMODE_WRITE) ? LL_LEASE_WRLCK : 0);
<a name="l02172"></a>02172 }
<a name="l02173"></a>02173 
<a name="l02174"></a>02174 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_file_futimes_3(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structll__futimes__3.html">ll_futimes_3</a> *lfu)
<a name="l02175"></a>02175 {
<a name="l02176"></a>02176         <span class="keyword">struct </span>inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l02177"></a>02177         <span class="keyword">struct </span>iattr ia = {
<a name="l02178"></a>02178                 .ia_valid = ATTR_ATIME | ATTR_ATIME_SET |
<a name="l02179"></a>02179                             ATTR_MTIME | ATTR_MTIME_SET |
<a name="l02180"></a>02180                             ATTR_CTIME | ATTR_CTIME_SET,
<a name="l02181"></a>02181                 .ia_atime = {
<a name="l02182"></a>02182                         .tv_sec = lfu-&gt;lfu_atime_sec,
<a name="l02183"></a>02183                         .tv_nsec = lfu-&gt;lfu_atime_nsec,
<a name="l02184"></a>02184                 },
<a name="l02185"></a>02185                 .ia_mtime = {
<a name="l02186"></a>02186                         .tv_sec = lfu-&gt;lfu_mtime_sec,
<a name="l02187"></a>02187                         .tv_nsec = lfu-&gt;lfu_mtime_nsec,
<a name="l02188"></a>02188                 },
<a name="l02189"></a>02189                 .ia_ctime = {
<a name="l02190"></a>02190                         .tv_sec = lfu-&gt;lfu_ctime_sec,
<a name="l02191"></a>02191                         .tv_nsec = lfu-&gt;lfu_ctime_nsec,
<a name="l02192"></a>02192                 },
<a name="l02193"></a>02193         };
<a name="l02194"></a>02194         <span class="keywordtype">int</span> rc;
<a name="l02195"></a>02195         ENTRY;
<a name="l02196"></a>02196 
<a name="l02197"></a>02197         <span class="keywordflow">if</span> (!capable(CAP_SYS_ADMIN))
<a name="l02198"></a>02198                 RETURN(-EPERM);
<a name="l02199"></a>02199 
<a name="l02200"></a>02200         <span class="keywordflow">if</span> (!S_ISREG(inode-&gt;i_mode))
<a name="l02201"></a>02201                 RETURN(-EINVAL);
<a name="l02202"></a>02202 
<a name="l02203"></a>02203         mutex_lock(&amp;inode-&gt;i_mutex);
<a name="l02204"></a>02204         rc = ll_setattr_raw(file-&gt;f_path.dentry, &amp;ia, <span class="keyword">false</span>);
<a name="l02205"></a>02205         mutex_unlock(&amp;inode-&gt;i_mutex);
<a name="l02206"></a>02206 
<a name="l02207"></a>02207         RETURN(rc);
<a name="l02208"></a>02208 }
<a name="l02209"></a>02209 
<a name="l02210"></a>02210 <span class="comment">/*</span>
<a name="l02211"></a>02211 <span class="comment"> * Give file access advices</span>
<a name="l02212"></a>02212 <span class="comment"> *</span>
<a name="l02213"></a>02213 <span class="comment"> * The ladvise interface is similar to Linux fadvise() system call, except it</span>
<a name="l02214"></a>02214 <span class="comment"> * forwards the advices directly from Lustre client to server. The server side</span>
<a name="l02215"></a>02215 <span class="comment"> * codes will apply appropriate read-ahead and caching techniques for the</span>
<a name="l02216"></a>02216 <span class="comment"> * corresponding files.</span>
<a name="l02217"></a>02217 <span class="comment"> *</span>
<a name="l02218"></a>02218 <span class="comment"> * A typical workload for ladvise is e.g. a bunch of different clients are</span>
<a name="l02219"></a>02219 <span class="comment"> * doing small random reads of a file, so prefetching pages into OSS cache</span>
<a name="l02220"></a>02220 <span class="comment"> * with big linear reads before the random IO is a net benefit. Fetching</span>
<a name="l02221"></a>02221 <span class="comment"> * all that data into each client cache with fadvise() may not be, due to</span>
<a name="l02222"></a>02222 <span class="comment"> * much more data being sent to the client.</span>
<a name="l02223"></a>02223 <span class="comment"> */</span>
<a name="l02224"></a>02224 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_ladvise(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file, __u64 flags,
<a name="l02225"></a>02225                       <span class="keyword">struct</span> <a class="code" href="structlu__ladvise.html">lu_ladvise</a> *ladvise)
<a name="l02226"></a>02226 {
<a name="l02227"></a>02227         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a> nest;
<a name="l02228"></a>02228         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l02229"></a>02229         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io;
<a name="l02230"></a>02230         <span class="keyword">struct </span>cl_ladvise_io *lio;
<a name="l02231"></a>02231         <span class="keywordtype">int</span> rc;
<a name="l02232"></a>02232         ENTRY;
<a name="l02233"></a>02233 
<a name="l02234"></a>02234         env = cl_env_nested_get(&amp;nest);
<a name="l02235"></a>02235         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l02236"></a>02236                 RETURN(PTR_ERR(env));
<a name="l02237"></a>02237 
<a name="l02238"></a>02238         io = vvp_env_thread_io(env);
<a name="l02239"></a>02239         io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a> = ll_i2info(inode)-&gt;lli_clob;
<a name="l02240"></a>02240 
<a name="l02241"></a>02241         <span class="comment">/* initialize parameters for ladvise */</span>
<a name="l02242"></a>02242         lio = &amp;io-&gt;u.ci_ladvise;
<a name="l02243"></a>02243         lio-&gt;li_start = ladvise-&gt;lla_start;
<a name="l02244"></a>02244         lio-&gt;li_end = ladvise-&gt;lla_end;
<a name="l02245"></a>02245         lio-&gt;li_fid = ll_inode2fid(inode);
<a name="l02246"></a>02246         lio-&gt;li_advice = ladvise-&gt;lla_advice;
<a name="l02247"></a>02247         lio-&gt;li_flags = flags;
<a name="l02248"></a>02248 
<a name="l02249"></a>02249         <span class="keywordflow">if</span> (<a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_init</a>(env, io, <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ad49f27c1cdc5be6e64ea32bcb4f16e8d" title="ladvise handling To give advice about access of a file">CIT_LADVISE</a>, io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a>) == 0)
<a name="l02250"></a>02250                 rc = <a class="code" href="group__cl__io.html#ga2b13e91188661c45925b56e88b000c6e" title="Main io loop.">cl_io_loop</a>(env, io);
<a name="l02251"></a>02251         <span class="keywordflow">else</span>
<a name="l02252"></a>02252                 rc = io-&gt;ci_result;
<a name="l02253"></a>02253 
<a name="l02254"></a>02254         <a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>(env, io);
<a name="l02255"></a>02255         cl_env_nested_put(&amp;nest, env);
<a name="l02256"></a>02256         RETURN(rc);
<a name="l02257"></a>02257 }
<a name="l02258"></a>02258 
<a name="l02259"></a>02259 <span class="keyword">static</span> <span class="keywordtype">long</span>
<a name="l02260"></a>02260 ll_file_ioctl(<span class="keyword">struct</span> file *file, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
<a name="l02261"></a>02261 {
<a name="l02262"></a>02262         <span class="keyword">struct </span>inode            *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l02263"></a>02263         <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a>     *fd = LUSTRE_FPRIVATE(file);
<a name="l02264"></a>02264         <span class="keywordtype">int</span>                      flags, rc;
<a name="l02265"></a>02265         ENTRY;
<a name="l02266"></a>02266 
<a name="l02267"></a>02267         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;VFS Op:inode=&quot;</span>DFID<span class="stringliteral">&quot;(%p), cmd=%x\n&quot;</span>,
<a name="l02268"></a>02268                PFID(ll_inode2fid(inode)), inode, cmd);
<a name="l02269"></a>02269         ll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_IOCTL, 1);
<a name="l02270"></a>02270 
<a name="l02271"></a>02271         <span class="comment">/* asm-ppc{,64} declares TCGETS, et. al. as type &apos;t&apos; not &apos;T&apos; */</span>
<a name="l02272"></a>02272         <span class="keywordflow">if</span> (_IOC_TYPE(cmd) == <span class="charliteral">&apos;T&apos;</span> || _IOC_TYPE(cmd) == <span class="charliteral">&apos;t&apos;</span>) <span class="comment">/* tty ioctls */</span>
<a name="l02273"></a>02273                 RETURN(-ENOTTY);
<a name="l02274"></a>02274 
<a name="l02275"></a>02275         <span class="keywordflow">switch</span>(cmd) {
<a name="l02276"></a>02276         <span class="keywordflow">case</span> LL_IOC_GETFLAGS:
<a name="l02277"></a>02277                 <span class="comment">/* Get the current value of the file flags */</span>
<a name="l02278"></a>02278                 <span class="keywordflow">return</span> put_user(fd-&gt;fd_flags, (<span class="keywordtype">int</span> __user *)arg);
<a name="l02279"></a>02279         <span class="keywordflow">case</span> LL_IOC_SETFLAGS:
<a name="l02280"></a>02280         <span class="keywordflow">case</span> LL_IOC_CLRFLAGS:
<a name="l02281"></a>02281                 <span class="comment">/* Set or clear specific file flags */</span>
<a name="l02282"></a>02282                 <span class="comment">/* XXX This probably needs checks to ensure the flags are</span>
<a name="l02283"></a>02283 <span class="comment">                 *     not abused, and to handle any flag side effects.</span>
<a name="l02284"></a>02284 <span class="comment">                 */</span>
<a name="l02285"></a>02285                 <span class="keywordflow">if</span> (get_user(flags, (<span class="keywordtype">int</span> __user *) arg))
<a name="l02286"></a>02286                         RETURN(-EFAULT);
<a name="l02287"></a>02287 
<a name="l02288"></a>02288                 <span class="keywordflow">if</span> (cmd == LL_IOC_SETFLAGS) {
<a name="l02289"></a>02289                         <span class="keywordflow">if</span> ((flags &amp; LL_FILE_IGNORE_LOCK) &amp;&amp;
<a name="l02290"></a>02290                             !(file-&gt;f_flags &amp; O_DIRECT)) {
<a name="l02291"></a>02291                                 CERROR(<span class="stringliteral">&quot;%s: unable to disable locking on &quot;</span>
<a name="l02292"></a>02292                                        <span class="stringliteral">&quot;non-O_DIRECT file\n&quot;</span>, current-&gt;comm);
<a name="l02293"></a>02293                                 RETURN(-EINVAL);
<a name="l02294"></a>02294                         }
<a name="l02295"></a>02295 
<a name="l02296"></a>02296                         fd-&gt;fd_flags |= flags;
<a name="l02297"></a>02297                 } <span class="keywordflow">else</span> {
<a name="l02298"></a>02298                         fd-&gt;fd_flags &amp;= ~flags;
<a name="l02299"></a>02299                 }
<a name="l02300"></a>02300                 RETURN(0);
<a name="l02301"></a>02301         <span class="keywordflow">case</span> LL_IOC_LOV_SETSTRIPE:
<a name="l02302"></a>02302                 RETURN(ll_lov_setstripe(inode, file, arg));
<a name="l02303"></a>02303         <span class="keywordflow">case</span> LL_IOC_LOV_SETEA:
<a name="l02304"></a>02304                 RETURN(ll_lov_setea(inode, file, arg));
<a name="l02305"></a>02305         <span class="keywordflow">case</span> LL_IOC_LOV_SWAP_LAYOUTS: {
<a name="l02306"></a>02306                 <span class="keyword">struct </span>file *file2;
<a name="l02307"></a>02307                 <span class="keyword">struct </span><a class="code" href="structlustre__swap__layouts.html">lustre_swap_layouts</a> lsl;
<a name="l02308"></a>02308 
<a name="l02309"></a>02309                 <span class="keywordflow">if</span> (copy_from_user(&amp;lsl, (<span class="keywordtype">char</span> __user *)arg,
<a name="l02310"></a>02310                                        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structlustre__swap__layouts.html">lustre_swap_layouts</a>)))
<a name="l02311"></a>02311                         RETURN(-EFAULT);
<a name="l02312"></a>02312 
<a name="l02313"></a>02313                 <span class="keywordflow">if</span> ((file-&gt;f_flags &amp; O_ACCMODE) == O_RDONLY)
<a name="l02314"></a>02314                         RETURN(-EPERM);
<a name="l02315"></a>02315 
<a name="l02316"></a>02316                 file2 = fget(lsl.sl_fd);
<a name="l02317"></a>02317                 <span class="keywordflow">if</span> (file2 == NULL)
<a name="l02318"></a>02318                         RETURN(-EBADF);
<a name="l02319"></a>02319 
<a name="l02320"></a>02320                 <span class="comment">/* O_WRONLY or O_RDWR */</span>
<a name="l02321"></a>02321                 <span class="keywordflow">if</span> ((file2-&gt;f_flags &amp; O_ACCMODE) == O_RDONLY)
<a name="l02322"></a>02322                         GOTO(out, rc = -EPERM);
<a name="l02323"></a>02323 
<a name="l02324"></a>02324                 <span class="keywordflow">if</span> (lsl.sl_flags &amp; SWAP_LAYOUTS_CLOSE) {
<a name="l02325"></a>02325                         <span class="keyword">struct </span>inode                    *inode2;
<a name="l02326"></a>02326                         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a>            *lli;
<a name="l02327"></a>02327                         <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a>        *och = NULL;
<a name="l02328"></a>02328 
<a name="l02329"></a>02329                         <span class="keywordflow">if</span> (lsl.sl_flags != SWAP_LAYOUTS_CLOSE)
<a name="l02330"></a>02330                                 GOTO(out, rc = -EINVAL);
<a name="l02331"></a>02331 
<a name="l02332"></a>02332                         lli = ll_i2info(inode);
<a name="l02333"></a>02333                         mutex_lock(&amp;lli-&gt;lli_och_mutex);
<a name="l02334"></a>02334                         <span class="keywordflow">if</span> (fd-&gt;fd_lease_och != NULL) {
<a name="l02335"></a>02335                                 och = fd-&gt;fd_lease_och;
<a name="l02336"></a>02336                                 fd-&gt;fd_lease_och = NULL;
<a name="l02337"></a>02337                         }
<a name="l02338"></a>02338                         mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l02339"></a>02339                         <span class="keywordflow">if</span> (och == NULL)
<a name="l02340"></a>02340                                 GOTO(out, rc = -ENOLCK);
<a name="l02341"></a>02341                         inode2 = file2-&gt;f_path.dentry-&gt;d_inode;
<a name="l02342"></a>02342                         rc = ll_swap_layouts_close(och, inode, inode2);
<a name="l02343"></a>02343                 } <span class="keywordflow">else</span> {
<a name="l02344"></a>02344                         rc = ll_swap_layouts(file, file2, &amp;lsl);
<a name="l02345"></a>02345                 }
<a name="l02346"></a>02346 out:
<a name="l02347"></a>02347                 fput(file2);
<a name="l02348"></a>02348                 RETURN(rc);
<a name="l02349"></a>02349         }
<a name="l02350"></a>02350         <span class="keywordflow">case</span> LL_IOC_LOV_GETSTRIPE:
<a name="l02351"></a>02351                 RETURN(ll_file_getstripe(inode,
<a name="l02352"></a>02352                                          (<span class="keyword">struct</span> lov_user_md __user *)arg));
<a name="l02353"></a>02353         <span class="keywordflow">case</span> FSFILT_IOC_GETFLAGS:
<a name="l02354"></a>02354         <span class="keywordflow">case</span> FSFILT_IOC_SETFLAGS:
<a name="l02355"></a>02355                 RETURN(ll_iocontrol(inode, file, cmd, arg));
<a name="l02356"></a>02356         <span class="keywordflow">case</span> FSFILT_IOC_GETVERSION_OLD:
<a name="l02357"></a>02357         <span class="keywordflow">case</span> FSFILT_IOC_GETVERSION:
<a name="l02358"></a>02358                 RETURN(put_user(inode-&gt;i_generation, (<span class="keywordtype">int</span> __user *)arg));
<a name="l02359"></a>02359         <span class="keywordflow">case</span> LL_IOC_GROUP_LOCK:
<a name="l02360"></a>02360                 RETURN(ll_get_grouplock(inode, file, arg));
<a name="l02361"></a>02361         <span class="keywordflow">case</span> LL_IOC_GROUP_UNLOCK:
<a name="l02362"></a>02362                 RETURN(ll_put_grouplock(inode, file, arg));
<a name="l02363"></a>02363         <span class="keywordflow">case</span> IOC_OBD_STATFS:
<a name="l02364"></a>02364                 RETURN(ll_obd_statfs(inode, (<span class="keywordtype">void</span> __user *)arg));
<a name="l02365"></a>02365 
<a name="l02366"></a>02366         <span class="comment">/* We need to special case any other ioctls we want to handle,</span>
<a name="l02367"></a>02367 <span class="comment">         * to send them to the MDS/OST as appropriate and to properly</span>
<a name="l02368"></a>02368 <span class="comment">         * network encode the arg field.</span>
<a name="l02369"></a>02369 <span class="comment">        case FSFILT_IOC_SETVERSION_OLD:</span>
<a name="l02370"></a>02370 <span class="comment">        case FSFILT_IOC_SETVERSION:</span>
<a name="l02371"></a>02371 <span class="comment">        */</span>
<a name="l02372"></a>02372         <span class="keywordflow">case</span> LL_IOC_FLUSHCTX:
<a name="l02373"></a>02373                 RETURN(ll_flush_ctx(inode));
<a name="l02374"></a>02374         <span class="keywordflow">case</span> LL_IOC_PATH2FID: {
<a name="l02375"></a>02375                 <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">void</span> __user *)arg, ll_inode2fid(inode),
<a name="l02376"></a>02376                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>)))
<a name="l02377"></a>02377                         RETURN(-EFAULT);
<a name="l02378"></a>02378 
<a name="l02379"></a>02379                 RETURN(0);
<a name="l02380"></a>02380         }
<a name="l02381"></a>02381         <span class="keywordflow">case</span> LL_IOC_GETPARENT:
<a name="l02382"></a>02382                 RETURN(ll_getparent(file, (<span class="keyword">struct</span> <a class="code" href="structgetparent.html" title="path2parent request/reply structures">getparent</a> __user *)arg));
<a name="l02383"></a>02383 
<a name="l02384"></a>02384         <span class="keywordflow">case</span> OBD_IOC_FID2PATH:
<a name="l02385"></a>02385                 RETURN(ll_fid2path(inode, (<span class="keywordtype">void</span> __user *)arg));
<a name="l02386"></a>02386         <span class="keywordflow">case</span> LL_IOC_DATA_VERSION: {
<a name="l02387"></a>02387                 <span class="keyword">struct </span><a class="code" href="structioc__data__version.html">ioc_data_version</a> idv;
<a name="l02388"></a>02388                 <span class="keywordtype">int</span> rc;
<a name="l02389"></a>02389 
<a name="l02390"></a>02390                 <span class="keywordflow">if</span> (copy_from_user(&amp;idv, (<span class="keywordtype">char</span> __user *)arg, <span class="keyword">sizeof</span>(idv)))
<a name="l02391"></a>02391                         RETURN(-EFAULT);
<a name="l02392"></a>02392 
<a name="l02393"></a>02393                 idv.idv_flags &amp;= LL_DV_RD_FLUSH | LL_DV_WR_FLUSH;
<a name="l02394"></a>02394                 rc = ll_data_version(inode, &amp;idv.idv_version, idv.idv_flags);
<a name="l02395"></a>02395 
<a name="l02396"></a>02396                 <span class="keywordflow">if</span> (rc == 0 &amp;&amp;
<a name="l02397"></a>02397                     copy_to_user((<span class="keywordtype">char</span> __user *)arg, &amp;idv, <span class="keyword">sizeof</span>(idv)))
<a name="l02398"></a>02398                         RETURN(-EFAULT);
<a name="l02399"></a>02399 
<a name="l02400"></a>02400                 RETURN(rc);
<a name="l02401"></a>02401         }
<a name="l02402"></a>02402 
<a name="l02403"></a>02403         <span class="keywordflow">case</span> LL_IOC_GET_MDTIDX: {
<a name="l02404"></a>02404                 <span class="keywordtype">int</span> mdtidx;
<a name="l02405"></a>02405 
<a name="l02406"></a>02406                 mdtidx = ll_get_mdt_idx(inode);
<a name="l02407"></a>02407                 <span class="keywordflow">if</span> (mdtidx &lt; 0)
<a name="l02408"></a>02408                         RETURN(mdtidx);
<a name="l02409"></a>02409 
<a name="l02410"></a>02410                 <span class="keywordflow">if</span> (put_user((<span class="keywordtype">int</span>)mdtidx, (<span class="keywordtype">int</span> __user *)arg))
<a name="l02411"></a>02411                         RETURN(-EFAULT);
<a name="l02412"></a>02412 
<a name="l02413"></a>02413                 RETURN(0);
<a name="l02414"></a>02414         }
<a name="l02415"></a>02415         <span class="keywordflow">case</span> OBD_IOC_GETDTNAME:
<a name="l02416"></a>02416         <span class="keywordflow">case</span> OBD_IOC_GETMDNAME:
<a name="l02417"></a>02417                 RETURN(ll_get_obd_name(inode, cmd, arg));
<a name="l02418"></a>02418         <span class="keywordflow">case</span> LL_IOC_HSM_STATE_GET: {
<a name="l02419"></a>02419                 <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a>       *op_data;
<a name="l02420"></a>02420                 <span class="keyword">struct </span><a class="code" href="structhsm__user__state.html" title="Current HSM states of a Lustre file.">hsm_user_state</a>   *hus;
<a name="l02421"></a>02421                 <span class="keywordtype">int</span>                      rc;
<a name="l02422"></a>02422 
<a name="l02423"></a>02423                 OBD_ALLOC_PTR(hus);
<a name="l02424"></a>02424                 <span class="keywordflow">if</span> (hus == NULL)
<a name="l02425"></a>02425                         RETURN(-ENOMEM);
<a name="l02426"></a>02426 
<a name="l02427"></a>02427                 op_data = ll_prep_md_op_data(NULL, inode, NULL, NULL, 0, 0,
<a name="l02428"></a>02428                                              LUSTRE_OPC_ANY, hus);
<a name="l02429"></a>02429                 <span class="keywordflow">if</span> (IS_ERR(op_data)) {
<a name="l02430"></a>02430                         OBD_FREE_PTR(hus);
<a name="l02431"></a>02431                         RETURN(PTR_ERR(op_data));
<a name="l02432"></a>02432                 }
<a name="l02433"></a>02433 
<a name="l02434"></a>02434                 rc = obd_iocontrol(cmd, ll_i2mdexp(inode), <span class="keyword">sizeof</span>(*op_data),
<a name="l02435"></a>02435                                    op_data, NULL);
<a name="l02436"></a>02436 
<a name="l02437"></a>02437                 <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">void</span> __user *)arg, hus, <span class="keyword">sizeof</span>(*hus)))
<a name="l02438"></a>02438                         rc = -EFAULT;
<a name="l02439"></a>02439 
<a name="l02440"></a>02440                 ll_finish_md_op_data(op_data);
<a name="l02441"></a>02441                 OBD_FREE_PTR(hus);
<a name="l02442"></a>02442                 RETURN(rc);
<a name="l02443"></a>02443         }
<a name="l02444"></a>02444         <span class="keywordflow">case</span> LL_IOC_HSM_STATE_SET: {
<a name="l02445"></a>02445                 <span class="keyword">struct </span><a class="code" href="structhsm__state__set.html">hsm_state_set</a>    *hss;
<a name="l02446"></a>02446                 <span class="keywordtype">int</span>                      rc;
<a name="l02447"></a>02447 
<a name="l02448"></a>02448                 OBD_ALLOC_PTR(hss);
<a name="l02449"></a>02449                 <span class="keywordflow">if</span> (hss == NULL)
<a name="l02450"></a>02450                         RETURN(-ENOMEM);
<a name="l02451"></a>02451 
<a name="l02452"></a>02452                 <span class="keywordflow">if</span> (copy_from_user(hss, (<span class="keywordtype">char</span> __user *)arg, <span class="keyword">sizeof</span>(*hss))) {
<a name="l02453"></a>02453                         OBD_FREE_PTR(hss);
<a name="l02454"></a>02454                         RETURN(-EFAULT);
<a name="l02455"></a>02455                 }
<a name="l02456"></a>02456 
<a name="l02457"></a>02457                 rc = ll_hsm_state_set(inode, hss);
<a name="l02458"></a>02458 
<a name="l02459"></a>02459                 OBD_FREE_PTR(hss);
<a name="l02460"></a>02460                 RETURN(rc);
<a name="l02461"></a>02461         }
<a name="l02462"></a>02462         <span class="keywordflow">case</span> LL_IOC_HSM_ACTION: {
<a name="l02463"></a>02463                 <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a>               *op_data;
<a name="l02464"></a>02464                 <span class="keyword">struct </span><a class="code" href="structhsm__current__action.html">hsm_current_action</a>       *hca;
<a name="l02465"></a>02465                 <span class="keywordtype">int</span>                              rc;
<a name="l02466"></a>02466 
<a name="l02467"></a>02467                 OBD_ALLOC_PTR(hca);
<a name="l02468"></a>02468                 <span class="keywordflow">if</span> (hca == NULL)
<a name="l02469"></a>02469                         RETURN(-ENOMEM);
<a name="l02470"></a>02470 
<a name="l02471"></a>02471                 op_data = ll_prep_md_op_data(NULL, inode, NULL, NULL, 0, 0,
<a name="l02472"></a>02472                                              LUSTRE_OPC_ANY, hca);
<a name="l02473"></a>02473                 <span class="keywordflow">if</span> (IS_ERR(op_data)) {
<a name="l02474"></a>02474                         OBD_FREE_PTR(hca);
<a name="l02475"></a>02475                         RETURN(PTR_ERR(op_data));
<a name="l02476"></a>02476                 }
<a name="l02477"></a>02477 
<a name="l02478"></a>02478                 rc = obd_iocontrol(cmd, ll_i2mdexp(inode), <span class="keyword">sizeof</span>(*op_data),
<a name="l02479"></a>02479                                    op_data, NULL);
<a name="l02480"></a>02480 
<a name="l02481"></a>02481                 <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">char</span> __user *)arg, hca, <span class="keyword">sizeof</span>(*hca)))
<a name="l02482"></a>02482                         rc = -EFAULT;
<a name="l02483"></a>02483 
<a name="l02484"></a>02484                 ll_finish_md_op_data(op_data);
<a name="l02485"></a>02485                 OBD_FREE_PTR(hca);
<a name="l02486"></a>02486                 RETURN(rc);
<a name="l02487"></a>02487         }
<a name="l02488"></a>02488         <span class="keywordflow">case</span> LL_IOC_SET_LEASE: {
<a name="l02489"></a>02489                 <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l02490"></a>02490                 <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och = NULL;
<a name="l02491"></a>02491                 <span class="keywordtype">bool</span> lease_broken;
<a name="l02492"></a>02492                 fmode_t fmode;
<a name="l02493"></a>02493 
<a name="l02494"></a>02494                 <span class="keywordflow">switch</span> (arg) {
<a name="l02495"></a>02495                 <span class="keywordflow">case</span> LL_LEASE_WRLCK:
<a name="l02496"></a>02496                         <span class="keywordflow">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))
<a name="l02497"></a>02497                                 RETURN(-EPERM);
<a name="l02498"></a>02498                         fmode = FMODE_WRITE;
<a name="l02499"></a>02499                         <span class="keywordflow">break</span>;
<a name="l02500"></a>02500                 <span class="keywordflow">case</span> LL_LEASE_RDLCK:
<a name="l02501"></a>02501                         <span class="keywordflow">if</span> (!(file-&gt;f_mode &amp; FMODE_READ))
<a name="l02502"></a>02502                                 RETURN(-EPERM);
<a name="l02503"></a>02503                         fmode = FMODE_READ;
<a name="l02504"></a>02504                         <span class="keywordflow">break</span>;
<a name="l02505"></a>02505                 <span class="keywordflow">case</span> LL_LEASE_UNLCK:
<a name="l02506"></a>02506                         mutex_lock(&amp;lli-&gt;lli_och_mutex);
<a name="l02507"></a>02507                         <span class="keywordflow">if</span> (fd-&gt;fd_lease_och != NULL) {
<a name="l02508"></a>02508                                 och = fd-&gt;fd_lease_och;
<a name="l02509"></a>02509                                 fd-&gt;fd_lease_och = NULL;
<a name="l02510"></a>02510                         }
<a name="l02511"></a>02511                         mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l02512"></a>02512 
<a name="l02513"></a>02513                         <span class="keywordflow">if</span> (och == NULL)
<a name="l02514"></a>02514                                 RETURN(-ENOLCK);
<a name="l02515"></a>02515 
<a name="l02516"></a>02516                         fmode = och-&gt;och_flags;
<a name="l02517"></a>02517                         rc = ll_lease_close(och, inode, &amp;lease_broken);
<a name="l02518"></a>02518                         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02519"></a>02519                                 RETURN(rc);
<a name="l02520"></a>02520 
<a name="l02521"></a>02521                         <span class="keywordflow">if</span> (lease_broken)
<a name="l02522"></a>02522                                 fmode = 0;
<a name="l02523"></a>02523 
<a name="l02524"></a>02524                         RETURN(ll_lease_type_from_fmode(fmode));
<a name="l02525"></a>02525                 <span class="keywordflow">default</span>:
<a name="l02526"></a>02526                         RETURN(-EINVAL);
<a name="l02527"></a>02527                 }
<a name="l02528"></a>02528 
<a name="l02529"></a>02529                 CDEBUG(D_INODE, <span class="stringliteral">&quot;Set lease with mode %u\n&quot;</span>, fmode);
<a name="l02530"></a>02530 
<a name="l02531"></a>02531                 <span class="comment">/* apply for lease */</span>
<a name="l02532"></a>02532                 och = ll_lease_open(inode, file, fmode, 0);
<a name="l02533"></a>02533                 <span class="keywordflow">if</span> (IS_ERR(och))
<a name="l02534"></a>02534                         RETURN(PTR_ERR(och));
<a name="l02535"></a>02535 
<a name="l02536"></a>02536                 rc = 0;
<a name="l02537"></a>02537                 mutex_lock(&amp;lli-&gt;lli_och_mutex);
<a name="l02538"></a>02538                 <span class="keywordflow">if</span> (fd-&gt;fd_lease_och == NULL) {
<a name="l02539"></a>02539                         fd-&gt;fd_lease_och = och;
<a name="l02540"></a>02540                         och = NULL;
<a name="l02541"></a>02541                 }
<a name="l02542"></a>02542                 mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l02543"></a>02543                 <span class="keywordflow">if</span> (och != NULL) {
<a name="l02544"></a>02544                         <span class="comment">/* impossible now that only excl is supported for now */</span>
<a name="l02545"></a>02545                         ll_lease_close(och, inode, &amp;lease_broken);
<a name="l02546"></a>02546                         rc = -EBUSY;
<a name="l02547"></a>02547                 }
<a name="l02548"></a>02548                 RETURN(rc);
<a name="l02549"></a>02549         }
<a name="l02550"></a>02550         <span class="keywordflow">case</span> LL_IOC_GET_LEASE: {
<a name="l02551"></a>02551                 <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l02552"></a>02552                 <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock = NULL;
<a name="l02553"></a>02553                 fmode_t fmode = 0;
<a name="l02554"></a>02554 
<a name="l02555"></a>02555                 mutex_lock(&amp;lli-&gt;lli_och_mutex);
<a name="l02556"></a>02556                 <span class="keywordflow">if</span> (fd-&gt;fd_lease_och != NULL) {
<a name="l02557"></a>02557                         <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och = fd-&gt;fd_lease_och;
<a name="l02558"></a>02558 
<a name="l02559"></a>02559                         lock = ldlm_handle2lock(&amp;och-&gt;och_lease_handle);
<a name="l02560"></a>02560                         <span class="keywordflow">if</span> (lock != NULL) {
<a name="l02561"></a>02561                                 <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l02562"></a>02562                                 <span class="keywordflow">if</span> (!ldlm_is_cancel(lock))
<a name="l02563"></a>02563                                         fmode = och-&gt;och_flags;
<a name="l02564"></a>02564 
<a name="l02565"></a>02565                                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l02566"></a>02566                                 <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l02567"></a>02567                         }
<a name="l02568"></a>02568                 }
<a name="l02569"></a>02569                 mutex_unlock(&amp;lli-&gt;lli_och_mutex);
<a name="l02570"></a>02570 
<a name="l02571"></a>02571                 RETURN(ll_lease_type_from_fmode(fmode));
<a name="l02572"></a>02572         }
<a name="l02573"></a>02573         <span class="keywordflow">case</span> LL_IOC_HSM_IMPORT: {
<a name="l02574"></a>02574                 <span class="keyword">struct </span><a class="code" href="structhsm__user__import.html">hsm_user_import</a> *hui;
<a name="l02575"></a>02575 
<a name="l02576"></a>02576                 OBD_ALLOC_PTR(hui);
<a name="l02577"></a>02577                 <span class="keywordflow">if</span> (hui == NULL)
<a name="l02578"></a>02578                         RETURN(-ENOMEM);
<a name="l02579"></a>02579 
<a name="l02580"></a>02580                 <span class="keywordflow">if</span> (copy_from_user(hui, (<span class="keywordtype">void</span> __user *)arg, <span class="keyword">sizeof</span>(*hui))) {
<a name="l02581"></a>02581                         OBD_FREE_PTR(hui);
<a name="l02582"></a>02582                         RETURN(-EFAULT);
<a name="l02583"></a>02583                 }
<a name="l02584"></a>02584 
<a name="l02585"></a>02585                 rc = ll_hsm_import(inode, file, hui);
<a name="l02586"></a>02586 
<a name="l02587"></a>02587                 OBD_FREE_PTR(hui);
<a name="l02588"></a>02588                 RETURN(rc);
<a name="l02589"></a>02589         }
<a name="l02590"></a>02590         <span class="keywordflow">case</span> LL_IOC_FUTIMES_3: {
<a name="l02591"></a>02591                 <span class="keyword">struct </span><a class="code" href="structll__futimes__3.html">ll_futimes_3</a> lfu;
<a name="l02592"></a>02592 
<a name="l02593"></a>02593                 <span class="keywordflow">if</span> (copy_from_user(&amp;lfu,
<a name="l02594"></a>02594                                    (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structll__futimes__3.html">ll_futimes_3</a> __user *)arg,
<a name="l02595"></a>02595                                    <span class="keyword">sizeof</span>(lfu)))
<a name="l02596"></a>02596                         RETURN(-EFAULT);
<a name="l02597"></a>02597 
<a name="l02598"></a>02598                 RETURN(ll_file_futimes_3(file, &amp;lfu));
<a name="l02599"></a>02599         }
<a name="l02600"></a>02600         <span class="keywordflow">case</span> LL_IOC_LADVISE: {
<a name="l02601"></a>02601                 <span class="keyword">struct </span><a class="code" href="structladvise__hdr.html">ladvise_hdr</a> *<a class="code" href="structladvise__hdr.html">ladvise_hdr</a>;
<a name="l02602"></a>02602                 <span class="keywordtype">int</span> i;
<a name="l02603"></a>02603                 <span class="keywordtype">int</span> num_advise;
<a name="l02604"></a>02604                 <span class="keywordtype">int</span> alloc_size = <span class="keyword">sizeof</span>(*ladvise_hdr);
<a name="l02605"></a>02605 
<a name="l02606"></a>02606                 rc = 0;
<a name="l02607"></a>02607                 OBD_ALLOC_PTR(ladvise_hdr);
<a name="l02608"></a>02608                 <span class="keywordflow">if</span> (ladvise_hdr == NULL)
<a name="l02609"></a>02609                         RETURN(-ENOMEM);
<a name="l02610"></a>02610 
<a name="l02611"></a>02611                 <span class="keywordflow">if</span> (copy_from_user(ladvise_hdr,
<a name="l02612"></a>02612                                    (<span class="keyword">const</span> <span class="keyword">struct</span> ladvise_hdr __user *)arg,
<a name="l02613"></a>02613                                    alloc_size))
<a name="l02614"></a>02614                         GOTO(out_ladvise, rc = -EFAULT);
<a name="l02615"></a>02615 
<a name="l02616"></a>02616                 <span class="keywordflow">if</span> (ladvise_hdr-&gt;lah_magic != LADVISE_MAGIC ||
<a name="l02617"></a>02617                     ladvise_hdr-&gt;lah_count &lt; 1)
<a name="l02618"></a>02618                         GOTO(out_ladvise, rc = -EINVAL);
<a name="l02619"></a>02619 
<a name="l02620"></a>02620                 num_advise = ladvise_hdr-&gt;lah_count;
<a name="l02621"></a>02621                 <span class="keywordflow">if</span> (num_advise &gt;= LAH_COUNT_MAX)
<a name="l02622"></a>02622                         GOTO(out_ladvise, rc = -EFBIG);
<a name="l02623"></a>02623 
<a name="l02624"></a>02624                 OBD_FREE_PTR(ladvise_hdr);
<a name="l02625"></a>02625                 alloc_size = offsetof(typeof(*ladvise_hdr),
<a name="l02626"></a>02626                                       lah_advise[num_advise]);
<a name="l02627"></a>02627                 OBD_ALLOC(ladvise_hdr, alloc_size);
<a name="l02628"></a>02628                 <span class="keywordflow">if</span> (ladvise_hdr == NULL)
<a name="l02629"></a>02629                         RETURN(-ENOMEM);
<a name="l02630"></a>02630 
<a name="l02631"></a>02631                 <span class="comment">/*</span>
<a name="l02632"></a>02632 <span class="comment">                 * TODO: submit multiple advices to one server in a single RPC</span>
<a name="l02633"></a>02633 <span class="comment">                 */</span>
<a name="l02634"></a>02634                 <span class="keywordflow">if</span> (copy_from_user(ladvise_hdr,
<a name="l02635"></a>02635                                    (<span class="keyword">const</span> <span class="keyword">struct</span> ladvise_hdr __user *)arg,
<a name="l02636"></a>02636                                    alloc_size))
<a name="l02637"></a>02637                         GOTO(out_ladvise, rc = -EFAULT);
<a name="l02638"></a>02638 
<a name="l02639"></a>02639                 <span class="keywordflow">for</span> (i = 0; i &lt; num_advise; i++) {
<a name="l02640"></a>02640                         rc = ll_ladvise(inode, file, ladvise_hdr-&gt;lah_flags,
<a name="l02641"></a>02641                                         &amp;ladvise_hdr-&gt;lah_advise[i]);
<a name="l02642"></a>02642                         <span class="keywordflow">if</span> (rc)
<a name="l02643"></a>02643                                 <span class="keywordflow">break</span>;
<a name="l02644"></a>02644                 }
<a name="l02645"></a>02645 
<a name="l02646"></a>02646 out_ladvise:
<a name="l02647"></a>02647                 OBD_FREE(ladvise_hdr, alloc_size);
<a name="l02648"></a>02648                 RETURN(rc);
<a name="l02649"></a>02649         }
<a name="l02650"></a>02650         <span class="keywordflow">default</span>: {
<a name="l02651"></a>02651                 <span class="keywordtype">int</span> err;
<a name="l02652"></a>02652 
<a name="l02653"></a>02653                 <span class="keywordflow">if</span> (LLIOC_STOP ==
<a name="l02654"></a>02654                      ll_iocontrol_call(inode, file, cmd, arg, &amp;err))
<a name="l02655"></a>02655                         RETURN(err);
<a name="l02656"></a>02656 
<a name="l02657"></a>02657                 RETURN(obd_iocontrol(cmd, ll_i2dtexp(inode), 0, NULL,
<a name="l02658"></a>02658                                      (<span class="keywordtype">void</span> __user *)arg));
<a name="l02659"></a>02659         }
<a name="l02660"></a>02660         }
<a name="l02661"></a>02661 }
<a name="l02662"></a>02662 
<a name="l02663"></a>02663 <span class="preprocessor">#ifndef HAVE_FILE_LLSEEK_SIZE</span>
<a name="l02664"></a>02664 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> loff_t
<a name="l02665"></a>02665 llseek_execute(<span class="keyword">struct</span> file *file, loff_t offset, loff_t maxsize)
<a name="l02666"></a>02666 {
<a name="l02667"></a>02667         <span class="keywordflow">if</span> (offset &lt; 0 &amp;&amp; !(file-&gt;f_mode &amp; FMODE_UNSIGNED_OFFSET))
<a name="l02668"></a>02668                 <span class="keywordflow">return</span> -EINVAL;
<a name="l02669"></a>02669         <span class="keywordflow">if</span> (offset &gt; maxsize)
<a name="l02670"></a>02670                 <span class="keywordflow">return</span> -EINVAL;
<a name="l02671"></a>02671 
<a name="l02672"></a>02672         <span class="keywordflow">if</span> (offset != file-&gt;f_pos) {
<a name="l02673"></a>02673                 file-&gt;f_pos = offset;
<a name="l02674"></a>02674                 file-&gt;f_version = 0;
<a name="l02675"></a>02675         }
<a name="l02676"></a>02676         <span class="keywordflow">return</span> offset;
<a name="l02677"></a>02677 }
<a name="l02678"></a>02678 
<a name="l02679"></a>02679 <span class="keyword">static</span> loff_t
<a name="l02680"></a>02680 generic_file_llseek_size(<span class="keyword">struct</span> file *file, loff_t offset, <span class="keywordtype">int</span> origin,
<a name="l02681"></a>02681                 loff_t maxsize, loff_t eof)
<a name="l02682"></a>02682 {
<a name="l02683"></a>02683         <span class="keyword">struct </span>inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l02684"></a>02684 
<a name="l02685"></a>02685         <span class="keywordflow">switch</span> (origin) {
<a name="l02686"></a>02686         <span class="keywordflow">case</span> SEEK_END:
<a name="l02687"></a>02687                 offset += eof;
<a name="l02688"></a>02688                 <span class="keywordflow">break</span>;
<a name="l02689"></a>02689         <span class="keywordflow">case</span> SEEK_CUR:
<a name="l02690"></a>02690                 <span class="comment">/*</span>
<a name="l02691"></a>02691 <span class="comment">                 * Here we special-case the lseek(fd, 0, SEEK_CUR)</span>
<a name="l02692"></a>02692 <span class="comment">                 * position-querying operation.  Avoid rewriting the &quot;same&quot;</span>
<a name="l02693"></a>02693 <span class="comment">                 * f_pos value back to the file because a concurrent read(),</span>
<a name="l02694"></a>02694 <span class="comment">                 * write() or lseek() might have altered it</span>
<a name="l02695"></a>02695 <span class="comment">                 */</span>
<a name="l02696"></a>02696                 <span class="keywordflow">if</span> (offset == 0)
<a name="l02697"></a>02697                         <span class="keywordflow">return</span> file-&gt;f_pos;
<a name="l02698"></a>02698                 <span class="comment">/*</span>
<a name="l02699"></a>02699 <span class="comment">                 * f_lock protects against read/modify/write race with other</span>
<a name="l02700"></a>02700 <span class="comment">                 * SEEK_CURs. Note that parallel writes and reads behave</span>
<a name="l02701"></a>02701 <span class="comment">                 * like SEEK_SET.</span>
<a name="l02702"></a>02702 <span class="comment">                 */</span>
<a name="l02703"></a>02703                 mutex_lock(&amp;inode-&gt;i_mutex);
<a name="l02704"></a>02704                 offset = llseek_execute(file, file-&gt;f_pos + offset, maxsize);
<a name="l02705"></a>02705                 mutex_unlock(&amp;inode-&gt;i_mutex);
<a name="l02706"></a>02706                 <span class="keywordflow">return</span> offset;
<a name="l02707"></a>02707         <span class="keywordflow">case</span> SEEK_DATA:
<a name="l02708"></a>02708                 <span class="comment">/*</span>
<a name="l02709"></a>02709 <span class="comment">                 * In the generic case the entire file is data, so as long as</span>
<a name="l02710"></a>02710 <span class="comment">                 * offset isn&apos;t at the end of the file then the offset is data.</span>
<a name="l02711"></a>02711 <span class="comment">                 */</span>
<a name="l02712"></a>02712                 <span class="keywordflow">if</span> (offset &gt;= eof)
<a name="l02713"></a>02713                         <span class="keywordflow">return</span> -ENXIO;
<a name="l02714"></a>02714                 <span class="keywordflow">break</span>;
<a name="l02715"></a>02715         <span class="keywordflow">case</span> SEEK_HOLE:
<a name="l02716"></a>02716                 <span class="comment">/*</span>
<a name="l02717"></a>02717 <span class="comment">                 * There is a virtual hole at the end of the file, so as long as</span>
<a name="l02718"></a>02718 <span class="comment">                 * offset isn&apos;t i_size or larger, return i_size.</span>
<a name="l02719"></a>02719 <span class="comment">                 */</span>
<a name="l02720"></a>02720                 <span class="keywordflow">if</span> (offset &gt;= eof)
<a name="l02721"></a>02721                         <span class="keywordflow">return</span> -ENXIO;
<a name="l02722"></a>02722                 offset = eof;
<a name="l02723"></a>02723                 <span class="keywordflow">break</span>;
<a name="l02724"></a>02724         }
<a name="l02725"></a>02725 
<a name="l02726"></a>02726         <span class="keywordflow">return</span> llseek_execute(file, offset, maxsize);
<a name="l02727"></a>02727 }
<a name="l02728"></a>02728 <span class="preprocessor">#endif</span>
<a name="l02729"></a>02729 <span class="preprocessor"></span>
<a name="l02730"></a>02730 <span class="keyword">static</span> loff_t ll_file_seek(<span class="keyword">struct</span> file *file, loff_t offset, <span class="keywordtype">int</span> origin)
<a name="l02731"></a>02731 {
<a name="l02732"></a>02732         <span class="keyword">struct </span>inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l02733"></a>02733         loff_t retval, eof = 0;
<a name="l02734"></a>02734 
<a name="l02735"></a>02735         ENTRY;
<a name="l02736"></a>02736         retval = offset + ((origin == SEEK_END) ? i_size_read(inode) :
<a name="l02737"></a>02737                            (origin == SEEK_CUR) ? file-&gt;f_pos : 0);
<a name="l02738"></a>02738         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;VFS Op:inode=&quot;</span>DFID<span class="stringliteral">&quot;(%p), to=%llu=%#llx(%d)\n&quot;</span>,
<a name="l02739"></a>02739                PFID(ll_inode2fid(inode)), inode, retval, retval,
<a name="l02740"></a>02740                origin);
<a name="l02741"></a>02741         ll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_LLSEEK, 1);
<a name="l02742"></a>02742 
<a name="l02743"></a>02743         <span class="keywordflow">if</span> (origin == SEEK_END || origin == SEEK_HOLE || origin == SEEK_DATA) {
<a name="l02744"></a>02744                 retval = ll_glimpse_size(inode);
<a name="l02745"></a>02745                 <span class="keywordflow">if</span> (retval != 0)
<a name="l02746"></a>02746                         RETURN(retval);
<a name="l02747"></a>02747                 eof = i_size_read(inode);
<a name="l02748"></a>02748         }
<a name="l02749"></a>02749 
<a name="l02750"></a>02750         retval = ll_generic_file_llseek_size(file, offset, origin,
<a name="l02751"></a>02751                                           ll_file_maxbytes(inode), eof);
<a name="l02752"></a>02752         RETURN(retval);
<a name="l02753"></a>02753 }
<a name="l02754"></a>02754 
<a name="l02755"></a>02755 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_flush(<span class="keyword">struct</span> file *file, fl_owner_t <span class="keywordtype">id</span>)
<a name="l02756"></a>02756 {
<a name="l02757"></a>02757         <span class="keyword">struct </span>inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l02758"></a>02758         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l02759"></a>02759         <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a> *fd = LUSTRE_FPRIVATE(file);
<a name="l02760"></a>02760         <span class="keywordtype">int</span> rc, err;
<a name="l02761"></a>02761 
<a name="l02762"></a>02762         LASSERT(!S_ISDIR(inode-&gt;i_mode));
<a name="l02763"></a>02763 
<a name="l02764"></a>02764         <span class="comment">/* catch async errors that were recorded back when async writeback</span>
<a name="l02765"></a>02765 <span class="comment">         * failed for pages in this mapping. */</span>
<a name="l02766"></a>02766         rc = lli-&gt;lli_async_rc;
<a name="l02767"></a>02767         lli-&gt;lli_async_rc = 0;
<a name="l02768"></a>02768         <span class="keywordflow">if</span> (lli-&gt;lli_clob != NULL) {
<a name="l02769"></a>02769                 err = lov_read_and_clear_async_rc(lli-&gt;lli_clob);
<a name="l02770"></a>02770                 <span class="keywordflow">if</span> (rc == 0)
<a name="l02771"></a>02771                         rc = err;
<a name="l02772"></a>02772         }
<a name="l02773"></a>02773 
<a name="l02774"></a>02774         <span class="comment">/* The application has been told write failure already.</span>
<a name="l02775"></a>02775 <span class="comment">         * Do not report failure again. */</span>
<a name="l02776"></a>02776         <span class="keywordflow">if</span> (fd-&gt;fd_write_failed)
<a name="l02777"></a>02777                 <span class="keywordflow">return</span> 0;
<a name="l02778"></a>02778         <span class="keywordflow">return</span> rc ? -EIO : 0;
<a name="l02779"></a>02779 }
<a name="l02780"></a>02780 
<a name="l02787"></a>02787 <span class="keywordtype">int</span> cl_sync_file_range(<span class="keyword">struct</span> inode *inode, loff_t start, loff_t end,
<a name="l02788"></a>02788                        <span class="keyword">enum</span> <a class="code" href="group__cl__io.html#gabb7d5d07a2e68b82b9b13cac60256a7d">cl_fsync_mode</a> mode, <span class="keywordtype">int</span> ignore_layout)
<a name="l02789"></a>02789 {
<a name="l02790"></a>02790         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a> nest;
<a name="l02791"></a>02791         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l02792"></a>02792         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io;
<a name="l02793"></a>02793         <span class="keyword">struct </span>cl_fsync_io *fio;
<a name="l02794"></a>02794         <span class="keywordtype">int</span> result;
<a name="l02795"></a>02795         ENTRY;
<a name="l02796"></a>02796 
<a name="l02797"></a>02797         <span class="keywordflow">if</span> (mode != <a class="code" href="group__cl__io.html#ggabb7d5d07a2e68b82b9b13cac60256a7da2efbba1b7d141493ec27186a908dfd02" title="start writeback, do not wait for them to finish">CL_FSYNC_NONE</a> &amp;&amp; mode != <a class="code" href="group__cl__io.html#ggabb7d5d07a2e68b82b9b13cac60256a7da7421020b0252ff0989fd86dc2b3c2620" title="start writeback and wait for them to finish">CL_FSYNC_LOCAL</a> &amp;&amp;
<a name="l02798"></a>02798             mode != <a class="code" href="group__cl__io.html#ggabb7d5d07a2e68b82b9b13cac60256a7da26eec0d9c8b5fb4114c7841d531cd07e" title="discard all of dirty pages in a specific file range">CL_FSYNC_DISCARD</a> &amp;&amp; mode != <a class="code" href="group__cl__io.html#ggabb7d5d07a2e68b82b9b13cac60256a7da1289d6fd8294a72b7d758fd5d5c1aa2e" title="start writeback and make sure they have reached storage before return.">CL_FSYNC_ALL</a>)
<a name="l02799"></a>02799                 RETURN(-EINVAL);
<a name="l02800"></a>02800 
<a name="l02801"></a>02801         env = cl_env_nested_get(&amp;nest);
<a name="l02802"></a>02802         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l02803"></a>02803                 RETURN(PTR_ERR(env));
<a name="l02804"></a>02804 
<a name="l02805"></a>02805         io = vvp_env_thread_io(env);
<a name="l02806"></a>02806         io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a> = ll_i2info(inode)-&gt;lli_clob;
<a name="l02807"></a>02807         io-&gt;<a class="code" href="structcl__io.html#a5d6c1c346a6203b03bf6fb768c6799da" title="to not refresh layout - the IO issuer knows that the layout won&amp;#39;t change(page...">ci_ignore_layout</a> = ignore_layout;
<a name="l02808"></a>02808 
<a name="l02809"></a>02809         <span class="comment">/* initialize parameters for sync */</span>
<a name="l02810"></a>02810         fio = &amp;io-&gt;u.ci_fsync;
<a name="l02811"></a>02811         fio-&gt;fi_start = start;
<a name="l02812"></a>02812         fio-&gt;fi_end = end;
<a name="l02813"></a>02813         fio-&gt;fi_fid = ll_inode2fid(inode);
<a name="l02814"></a>02814         fio-&gt;fi_mode = mode;
<a name="l02815"></a>02815         fio-&gt;fi_nr_written = 0;
<a name="l02816"></a>02816 
<a name="l02817"></a>02817         <span class="keywordflow">if</span> (<a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_init</a>(env, io, <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a5e5f57a7ae1e41cc45aa7ec77eacf4b3" title="fsync system call handling To write out a range of file">CIT_FSYNC</a>, io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a>) == 0)
<a name="l02818"></a>02818                 result = <a class="code" href="group__cl__io.html#ga2b13e91188661c45925b56e88b000c6e" title="Main io loop.">cl_io_loop</a>(env, io);
<a name="l02819"></a>02819         <span class="keywordflow">else</span>
<a name="l02820"></a>02820                 result = io-&gt;ci_result;
<a name="l02821"></a>02821         <span class="keywordflow">if</span> (result == 0)
<a name="l02822"></a>02822                 result = fio-&gt;fi_nr_written;
<a name="l02823"></a>02823         <a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>(env, io);
<a name="l02824"></a>02824         cl_env_nested_put(&amp;nest, env);
<a name="l02825"></a>02825 
<a name="l02826"></a>02826         RETURN(result);
<a name="l02827"></a>02827 }
<a name="l02828"></a>02828 
<a name="l02829"></a>02829 <span class="comment">/*</span>
<a name="l02830"></a>02830 <span class="comment"> * When dentry is provided (the &apos;else&apos; case), *file-&gt;f_path.dentry may be</span>
<a name="l02831"></a>02831 <span class="comment"> * null and dentry must be used directly rather than pulled from</span>
<a name="l02832"></a>02832 <span class="comment"> * *file-&gt;f_path.dentry as is done otherwise.</span>
<a name="l02833"></a>02833 <span class="comment"> */</span>
<a name="l02834"></a>02834 
<a name="l02835"></a>02835 <span class="preprocessor">#ifdef HAVE_FILE_FSYNC_4ARGS</span>
<a name="l02836"></a>02836 <span class="preprocessor"></span><span class="keywordtype">int</span> ll_fsync(<span class="keyword">struct</span> file *file, loff_t start, loff_t end, <span class="keywordtype">int</span> datasync)
<a name="l02837"></a>02837 {
<a name="l02838"></a>02838         <span class="keyword">struct </span>dentry *dentry = file-&gt;f_path.dentry;
<a name="l02839"></a>02839 <span class="preprocessor">#elif defined(HAVE_FILE_FSYNC_2ARGS)</span>
<a name="l02840"></a>02840 <span class="preprocessor"></span><span class="keywordtype">int</span> ll_fsync(<span class="keyword">struct</span> file *file, <span class="keywordtype">int</span> datasync)
<a name="l02841"></a>02841 {
<a name="l02842"></a>02842         <span class="keyword">struct </span>dentry *dentry = file-&gt;f_path.dentry;
<a name="l02843"></a>02843         loff_t start = 0;
<a name="l02844"></a>02844         loff_t end = LLONG_MAX;
<a name="l02845"></a>02845 <span class="preprocessor">#else</span>
<a name="l02846"></a>02846 <span class="preprocessor"></span><span class="keywordtype">int</span> ll_fsync(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> dentry *dentry, <span class="keywordtype">int</span> datasync)
<a name="l02847"></a>02847 {
<a name="l02848"></a>02848         loff_t start = 0;
<a name="l02849"></a>02849         loff_t end = LLONG_MAX;
<a name="l02850"></a>02850 <span class="preprocessor">#endif</span>
<a name="l02851"></a>02851 <span class="preprocessor"></span>        <span class="keyword">struct </span>inode *inode = dentry-&gt;d_inode;
<a name="l02852"></a>02852         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l02853"></a>02853         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l02854"></a>02854         <span class="keywordtype">int</span> rc, err;
<a name="l02855"></a>02855         ENTRY;
<a name="l02856"></a>02856 
<a name="l02857"></a>02857         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;VFS Op:inode=&quot;</span>DFID<span class="stringliteral">&quot;(%p)\n&quot;</span>,
<a name="l02858"></a>02858                PFID(ll_inode2fid(inode)), inode);
<a name="l02859"></a>02859         ll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_FSYNC, 1);
<a name="l02860"></a>02860 
<a name="l02861"></a>02861 <span class="preprocessor">#ifdef HAVE_FILE_FSYNC_4ARGS</span>
<a name="l02862"></a>02862 <span class="preprocessor"></span>        rc = filemap_write_and_wait_range(inode-&gt;i_mapping, start, end);
<a name="l02863"></a>02863         mutex_lock(&amp;inode-&gt;i_mutex);
<a name="l02864"></a>02864 <span class="preprocessor">#else</span>
<a name="l02865"></a>02865 <span class="preprocessor"></span>        <span class="comment">/* fsync&apos;s caller has already called _fdata{sync,write}, we want</span>
<a name="l02866"></a>02866 <span class="comment">         * that IO to finish before calling the osc and mdc sync methods */</span>
<a name="l02867"></a>02867         rc = filemap_fdatawait(inode-&gt;i_mapping);
<a name="l02868"></a>02868 <span class="preprocessor">#endif</span>
<a name="l02869"></a>02869 <span class="preprocessor"></span>
<a name="l02870"></a>02870         <span class="comment">/* catch async errors that were recorded back when async writeback</span>
<a name="l02871"></a>02871 <span class="comment">         * failed for pages in this mapping. */</span>
<a name="l02872"></a>02872         <span class="keywordflow">if</span> (!S_ISDIR(inode-&gt;i_mode)) {
<a name="l02873"></a>02873                 err = lli-&gt;lli_async_rc;
<a name="l02874"></a>02874                 lli-&gt;lli_async_rc = 0;
<a name="l02875"></a>02875                 <span class="keywordflow">if</span> (rc == 0)
<a name="l02876"></a>02876                         rc = err;
<a name="l02877"></a>02877                 err = lov_read_and_clear_async_rc(lli-&gt;lli_clob);
<a name="l02878"></a>02878                 <span class="keywordflow">if</span> (rc == 0)
<a name="l02879"></a>02879                         rc = err;
<a name="l02880"></a>02880         }
<a name="l02881"></a>02881 
<a name="l02882"></a>02882         err = md_fsync(ll_i2sbi(inode)-&gt;ll_md_exp, ll_inode2fid(inode), &amp;req);
<a name="l02883"></a>02883         <span class="keywordflow">if</span> (!rc)
<a name="l02884"></a>02884                 rc = err;
<a name="l02885"></a>02885         <span class="keywordflow">if</span> (!err)
<a name="l02886"></a>02886                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l02887"></a>02887 
<a name="l02888"></a>02888         <span class="keywordflow">if</span> (S_ISREG(inode-&gt;i_mode)) {
<a name="l02889"></a>02889                 <span class="keyword">struct </span><a class="code" href="structll__file__data.html">ll_file_data</a> *fd = LUSTRE_FPRIVATE(file);
<a name="l02890"></a>02890 
<a name="l02891"></a>02891                 err = cl_sync_file_range(inode, start, end, <a class="code" href="group__cl__io.html#ggabb7d5d07a2e68b82b9b13cac60256a7da1289d6fd8294a72b7d758fd5d5c1aa2e" title="start writeback and make sure they have reached storage before return.">CL_FSYNC_ALL</a>, 0);
<a name="l02892"></a>02892                 <span class="keywordflow">if</span> (rc == 0 &amp;&amp; err &lt; 0)
<a name="l02893"></a>02893                         rc = err;
<a name="l02894"></a>02894                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02895"></a>02895                         fd-&gt;fd_write_failed = <span class="keyword">true</span>;
<a name="l02896"></a>02896                 <span class="keywordflow">else</span>
<a name="l02897"></a>02897                         fd-&gt;fd_write_failed = <span class="keyword">false</span>;
<a name="l02898"></a>02898         }
<a name="l02899"></a>02899 
<a name="l02900"></a>02900 <span class="preprocessor">#ifdef HAVE_FILE_FSYNC_4ARGS</span>
<a name="l02901"></a>02901 <span class="preprocessor"></span>        mutex_unlock(&amp;inode-&gt;i_mutex);
<a name="l02902"></a>02902 <span class="preprocessor">#endif</span>
<a name="l02903"></a>02903 <span class="preprocessor"></span>        RETURN(rc);
<a name="l02904"></a>02904 }
<a name="l02905"></a>02905 
<a name="l02906"></a>02906 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02907"></a>02907 ll_file_flock(<span class="keyword">struct</span> file *file, <span class="keywordtype">int</span> cmd, <span class="keyword">struct</span> file_lock *file_lock)
<a name="l02908"></a>02908 {
<a name="l02909"></a>02909         <span class="keyword">struct </span>inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
<a name="l02910"></a>02910         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a> *sbi = ll_i2sbi(inode);
<a name="l02911"></a>02911         <span class="keyword">struct </span><a class="code" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters.">ldlm_enqueue_info</a> einfo = {
<a name="l02912"></a>02912                 .ei_type        = LDLM_FLOCK,
<a name="l02913"></a>02913                 .ei_cb_cp       = <a class="code" href="group__LDLM.html#ga921f8d85541cbe1fa330b9a12080103f" title="Flock completion callback function.">ldlm_flock_completion_ast</a>,
<a name="l02914"></a>02914                 .ei_cbdata      = file_lock,
<a name="l02915"></a>02915         };
<a name="l02916"></a>02916         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a> *op_data;
<a name="l02917"></a>02917         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lockh = { 0 };
<a name="l02918"></a>02918         <span class="keyword">union </span><a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> flock = { { 0 } };
<a name="l02919"></a>02919         <span class="keywordtype">int</span> fl_type = file_lock-&gt;fl_type;
<a name="l02920"></a>02920         __u64 flags = 0;
<a name="l02921"></a>02921         <span class="keywordtype">int</span> rc;
<a name="l02922"></a>02922         <span class="keywordtype">int</span> rc2 = 0;
<a name="l02923"></a>02923         ENTRY;
<a name="l02924"></a>02924 
<a name="l02925"></a>02925         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;VFS Op:inode=&quot;</span>DFID<span class="stringliteral">&quot; file_lock=%p\n&quot;</span>,
<a name="l02926"></a>02926                PFID(ll_inode2fid(inode)), file_lock);
<a name="l02927"></a>02927 
<a name="l02928"></a>02928         ll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_FLOCK, 1);
<a name="l02929"></a>02929 
<a name="l02930"></a>02930         <span class="keywordflow">if</span> (file_lock-&gt;fl_flags &amp; FL_FLOCK) {
<a name="l02931"></a>02931                 LASSERT((cmd == F_SETLKW) || (cmd == F_SETLK));
<a name="l02932"></a>02932                 <span class="comment">/* flocks are whole-file locks */</span>
<a name="l02933"></a>02933                 flock.l_flock.end = OFFSET_MAX;
<a name="l02934"></a>02934                 <span class="comment">/* For flocks owner is determined by the local file desctiptor*/</span>
<a name="l02935"></a>02935                 flock.l_flock.owner = (<span class="keywordtype">unsigned</span> long)file_lock-&gt;fl_file;
<a name="l02936"></a>02936         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (file_lock-&gt;fl_flags &amp; FL_POSIX) {
<a name="l02937"></a>02937                 flock.l_flock.owner = (<span class="keywordtype">unsigned</span> long)file_lock-&gt;fl_owner;
<a name="l02938"></a>02938                 flock.l_flock.start = file_lock-&gt;fl_start;
<a name="l02939"></a>02939                 flock.l_flock.end = file_lock-&gt;fl_end;
<a name="l02940"></a>02940         } <span class="keywordflow">else</span> {
<a name="l02941"></a>02941                 RETURN(-EINVAL);
<a name="l02942"></a>02942         }
<a name="l02943"></a>02943         flock.l_flock.pid = file_lock-&gt;fl_pid;
<a name="l02944"></a>02944 
<a name="l02945"></a>02945         <span class="comment">/* Somewhat ugly workaround for svc lockd.</span>
<a name="l02946"></a>02946 <span class="comment">         * lockd installs custom fl_lmops-&gt;lm_compare_owner that checks</span>
<a name="l02947"></a>02947 <span class="comment">         * for the fl_owner to be the same (which it always is on local node</span>
<a name="l02948"></a>02948 <span class="comment">         * I guess between lockd processes) and then compares pid.</span>
<a name="l02949"></a>02949 <span class="comment">         * As such we assign pid to the owner field to make it all work,</span>
<a name="l02950"></a>02950 <span class="comment">         * conflict with normal locks is unlikely since pid space and</span>
<a name="l02951"></a>02951 <span class="comment">         * pointer space for current-&gt;files are not intersecting */</span>
<a name="l02952"></a>02952         <span class="keywordflow">if</span> (file_lock-&gt;fl_lmops &amp;&amp; file_lock-&gt;fl_lmops-&gt;lm_compare_owner)
<a name="l02953"></a>02953                 flock.l_flock.owner = (<span class="keywordtype">unsigned</span> long)file_lock-&gt;fl_pid;
<a name="l02954"></a>02954 
<a name="l02955"></a>02955         switch (fl_type) {
<a name="l02956"></a>02956         <span class="keywordflow">case</span> F_RDLCK:
<a name="l02957"></a>02957                 einfo.<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a> = LCK_PR;
<a name="l02958"></a>02958                 <span class="keywordflow">break</span>;
<a name="l02959"></a>02959         <span class="keywordflow">case</span> F_UNLCK:
<a name="l02960"></a>02960                 <span class="comment">/* An unlock request may or may not have any relation to</span>
<a name="l02961"></a>02961 <span class="comment">                 * existing locks so we may not be able to pass a lock handle</span>
<a name="l02962"></a>02962 <span class="comment">                 * via a normal ldlm_lock_cancel() request. The request may even</span>
<a name="l02963"></a>02963 <span class="comment">                 * unlock a byte range in the middle of an existing lock. In</span>
<a name="l02964"></a>02964 <span class="comment">                 * order to process an unlock request we need all of the same</span>
<a name="l02965"></a>02965 <span class="comment">                 * information that is given with a normal read or write record</span>
<a name="l02966"></a>02966 <span class="comment">                 * lock request. To avoid creating another ldlm unlock (cancel)</span>
<a name="l02967"></a>02967 <span class="comment">                 * message we&apos;ll treat a LCK_NL flock request as an unlock. */</span>
<a name="l02968"></a>02968                 einfo.<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a> = LCK_NL;
<a name="l02969"></a>02969                 <span class="keywordflow">break</span>;
<a name="l02970"></a>02970         <span class="keywordflow">case</span> F_WRLCK:
<a name="l02971"></a>02971                 einfo.<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a> = LCK_PW;
<a name="l02972"></a>02972                 <span class="keywordflow">break</span>;
<a name="l02973"></a>02973         <span class="keywordflow">default</span>:
<a name="l02974"></a>02974                 CDEBUG(D_INFO, <span class="stringliteral">&quot;Unknown fcntl lock type: %d\n&quot;</span>, fl_type);
<a name="l02975"></a>02975                 RETURN (-ENOTSUPP);
<a name="l02976"></a>02976         }
<a name="l02977"></a>02977 
<a name="l02978"></a>02978         <span class="keywordflow">switch</span> (cmd) {
<a name="l02979"></a>02979         <span class="keywordflow">case</span> F_SETLKW:
<a name="l02980"></a>02980 <span class="preprocessor">#ifdef F_SETLKW64</span>
<a name="l02981"></a>02981 <span class="preprocessor"></span>        <span class="keywordflow">case</span> F_SETLKW64:
<a name="l02982"></a>02982 <span class="preprocessor">#endif</span>
<a name="l02983"></a>02983 <span class="preprocessor"></span>                flags = 0;
<a name="l02984"></a>02984                 <span class="keywordflow">break</span>;
<a name="l02985"></a>02985         <span class="keywordflow">case</span> F_SETLK:
<a name="l02986"></a>02986 <span class="preprocessor">#ifdef F_SETLK64</span>
<a name="l02987"></a>02987 <span class="preprocessor"></span>        <span class="keywordflow">case</span> F_SETLK64:
<a name="l02988"></a>02988 <span class="preprocessor">#endif</span>
<a name="l02989"></a>02989 <span class="preprocessor"></span>                flags = <a class="code" href="group__LDLM.html#ga34a11c94b46a7cd00e464a9063ff3879" title="Server told not to wait if blocked.">LDLM_FL_BLOCK_NOWAIT</a>;
<a name="l02990"></a>02990                 <span class="keywordflow">break</span>;
<a name="l02991"></a>02991         <span class="keywordflow">case</span> F_GETLK:
<a name="l02992"></a>02992 <span class="preprocessor">#ifdef F_GETLK64</span>
<a name="l02993"></a>02993 <span class="preprocessor"></span>        <span class="keywordflow">case</span> F_GETLK64:
<a name="l02994"></a>02994 <span class="preprocessor">#endif</span>
<a name="l02995"></a>02995 <span class="preprocessor"></span>                flags = <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>;
<a name="l02996"></a>02996                 <span class="keywordflow">break</span>;
<a name="l02997"></a>02997         <span class="keywordflow">default</span>:
<a name="l02998"></a>02998                 CERROR(<span class="stringliteral">&quot;unknown fcntl lock command: %d\n&quot;</span>, cmd);
<a name="l02999"></a>02999                 RETURN (-EINVAL);
<a name="l03000"></a>03000         }
<a name="l03001"></a>03001 
<a name="l03002"></a>03002         <span class="comment">/* Save the old mode so that if the mode in the lock changes we</span>
<a name="l03003"></a>03003 <span class="comment">         * can decrement the appropriate reader or writer refcount. */</span>
<a name="l03004"></a>03004         file_lock-&gt;fl_type = einfo.<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a>;
<a name="l03005"></a>03005 
<a name="l03006"></a>03006         op_data = ll_prep_md_op_data(NULL, inode, NULL, NULL, 0, 0,
<a name="l03007"></a>03007                                      LUSTRE_OPC_ANY, NULL);
<a name="l03008"></a>03008         <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l03009"></a>03009                 RETURN(PTR_ERR(op_data));
<a name="l03010"></a>03010 
<a name="l03011"></a>03011         CDEBUG(D_DLMTRACE, <span class="stringliteral">&quot;inode=&quot;</span>DFID<span class="stringliteral">&quot;, pid=%u, flags=&quot;</span>LPX64<span class="stringliteral">&quot;, mode=%u, &quot;</span>
<a name="l03012"></a>03012                <span class="stringliteral">&quot;start=&quot;</span>LPU64<span class="stringliteral">&quot;, end=&quot;</span>LPU64<span class="stringliteral">&quot;\n&quot;</span>, PFID(ll_inode2fid(inode)),
<a name="l03013"></a>03013                flock.l_flock.pid, flags, einfo.<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a>,
<a name="l03014"></a>03014                flock.l_flock.start, flock.l_flock.end);
<a name="l03015"></a>03015 
<a name="l03016"></a>03016         rc = md_enqueue(sbi-&gt;ll_md_exp, &amp;einfo, &amp;flock, NULL, op_data, &amp;lockh,
<a name="l03017"></a>03017                         flags);
<a name="l03018"></a>03018 
<a name="l03019"></a>03019         <span class="comment">/* Restore the file lock type if not TEST lock. */</span>
<a name="l03020"></a>03020         <span class="keywordflow">if</span> (!(flags &amp; <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>))
<a name="l03021"></a>03021                 file_lock-&gt;fl_type = fl_type;
<a name="l03022"></a>03022 
<a name="l03023"></a>03023 <span class="preprocessor">#ifdef HAVE_LOCKS_LOCK_FILE_WAIT</span>
<a name="l03024"></a>03024 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((rc == 0 || file_lock-&gt;fl_type == F_UNLCK) &amp;&amp;
<a name="l03025"></a>03025             !(flags &amp; LDLM_FL_TEST_LOCK))
<a name="l03026"></a>03026                 rc2  = locks_lock_file_wait(file, file_lock);
<a name="l03027"></a>03027 <span class="preprocessor">#else</span>
<a name="l03028"></a>03028 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((file_lock-&gt;fl_flags &amp; FL_FLOCK) &amp;&amp;
<a name="l03029"></a>03029             (rc == 0 || file_lock-&gt;fl_type == F_UNLCK))
<a name="l03030"></a>03030                 rc2  = flock_lock_file_wait(file, file_lock);
<a name="l03031"></a>03031         <span class="keywordflow">if</span> ((file_lock-&gt;fl_flags &amp; FL_POSIX) &amp;&amp;
<a name="l03032"></a>03032             (rc == 0 || file_lock-&gt;fl_type == F_UNLCK) &amp;&amp;
<a name="l03033"></a>03033             !(flags &amp; LDLM_FL_TEST_LOCK))
<a name="l03034"></a>03034                 rc2  = posix_lock_file_wait(file, file_lock);
<a name="l03035"></a>03035 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_LOCKS_LOCK_FILE_WAIT */</span>
<a name="l03036"></a>03036 
<a name="l03037"></a>03037         <span class="keywordflow">if</span> (rc2 &amp;&amp; file_lock-&gt;fl_type != F_UNLCK) {
<a name="l03038"></a>03038                 einfo.<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a> = LCK_NL;
<a name="l03039"></a>03039                 md_enqueue(sbi-&gt;ll_md_exp, &amp;einfo, &amp;flock, NULL, op_data,
<a name="l03040"></a>03040                            &amp;lockh, flags);
<a name="l03041"></a>03041                 rc = rc2;
<a name="l03042"></a>03042         }
<a name="l03043"></a>03043 
<a name="l03044"></a>03044         ll_finish_md_op_data(op_data);
<a name="l03045"></a>03045 
<a name="l03046"></a>03046         RETURN(rc);
<a name="l03047"></a>03047 }
<a name="l03048"></a>03048 
<a name="l03049"></a>03049 <span class="keywordtype">int</span> ll_get_fid_by_name(<span class="keyword">struct</span> inode *parent, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l03050"></a>03050                        <span class="keywordtype">int</span> namelen, <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid,
<a name="l03051"></a>03051                        <span class="keyword">struct</span> inode **inode)
<a name="l03052"></a>03052 {
<a name="l03053"></a>03053         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a>       *op_data = NULL;
<a name="l03054"></a>03054         <span class="keyword">struct </span><a class="code" href="structmdt__body.html">mdt_body</a>         *body;
<a name="l03055"></a>03055         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *req;
<a name="l03056"></a>03056         <span class="keywordtype">int</span>                     rc;
<a name="l03057"></a>03057         ENTRY;
<a name="l03058"></a>03058 
<a name="l03059"></a>03059         op_data = ll_prep_md_op_data(NULL, parent, NULL, name, namelen, 0,
<a name="l03060"></a>03060                                      LUSTRE_OPC_ANY, NULL);
<a name="l03061"></a>03061         <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l03062"></a>03062                 RETURN(PTR_ERR(op_data));
<a name="l03063"></a>03063 
<a name="l03064"></a>03064         op_data-&gt;op_valid = OBD_MD_FLID | OBD_MD_FLTYPE;
<a name="l03065"></a>03065         rc = md_getattr_name(ll_i2sbi(parent)-&gt;ll_md_exp, op_data, &amp;req);
<a name="l03066"></a>03066         ll_finish_md_op_data(op_data);
<a name="l03067"></a>03067         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03068"></a>03068                 RETURN(rc);
<a name="l03069"></a>03069 
<a name="l03070"></a>03070         body = <a class="code" href="group__req__layout.html#ga0d1ad53a1914c35470f3916e4bb4b8fe" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC reply buffer...">req_capsule_server_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_MDT_BODY);
<a name="l03071"></a>03071         <span class="keywordflow">if</span> (body == NULL)
<a name="l03072"></a>03072                 GOTO(out_req, rc = -EFAULT);
<a name="l03073"></a>03073         <span class="keywordflow">if</span> (fid != NULL)
<a name="l03074"></a>03074                 *fid = body-&gt;mbo_fid1;
<a name="l03075"></a>03075 
<a name="l03076"></a>03076         <span class="keywordflow">if</span> (inode != NULL)
<a name="l03077"></a>03077                 rc = ll_prep_inode(inode, req, parent-&gt;i_sb, NULL);
<a name="l03078"></a>03078 out_req:
<a name="l03079"></a>03079         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l03080"></a>03080         RETURN(rc);
<a name="l03081"></a>03081 }
<a name="l03082"></a>03082 
<a name="l03083"></a>03083 <span class="keywordtype">int</span> ll_migrate(<span class="keyword">struct</span> inode *parent, <span class="keyword">struct</span> file *file, <span class="keywordtype">int</span> mdtidx,
<a name="l03084"></a>03084                <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> namelen)
<a name="l03085"></a>03085 {
<a name="l03086"></a>03086         <span class="keyword">struct </span>dentry         *dchild = NULL;
<a name="l03087"></a>03087         <span class="keyword">struct </span>inode          *child_inode = NULL;
<a name="l03088"></a>03088         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a>     *op_data;
<a name="l03089"></a>03089         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *request = NULL;
<a name="l03090"></a>03090         <span class="keyword">struct </span><a class="code" href="structobd__client__handle.html">obd_client_handle</a> *och = NULL;
<a name="l03091"></a>03091         <span class="keyword">struct </span>qstr           qstr;
<a name="l03092"></a>03092         <span class="keyword">struct </span><a class="code" href="structmdt__body.html">mdt_body</a>         *body;
<a name="l03093"></a>03093         <span class="keywordtype">int</span>                    rc;
<a name="l03094"></a>03094         __u64                   data_version = 0;
<a name="l03095"></a>03095         ENTRY;
<a name="l03096"></a>03096 
<a name="l03097"></a>03097         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;migrate %s under &quot;</span>DFID<span class="stringliteral">&quot; to MDT%04x\n&quot;</span>,
<a name="l03098"></a>03098                name, PFID(ll_inode2fid(parent)), mdtidx);
<a name="l03099"></a>03099 
<a name="l03100"></a>03100         op_data = ll_prep_md_op_data(NULL, parent, NULL, name, namelen,
<a name="l03101"></a>03101                                      0, LUSTRE_OPC_ANY, NULL);
<a name="l03102"></a>03102         <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l03103"></a>03103                 RETURN(PTR_ERR(op_data));
<a name="l03104"></a>03104 
<a name="l03105"></a>03105         <span class="comment">/* Get child FID first */</span>
<a name="l03106"></a>03106         qstr.hash = full_name_hash(name, namelen);
<a name="l03107"></a>03107         qstr.name = name;
<a name="l03108"></a>03108         qstr.len = namelen;
<a name="l03109"></a>03109         dchild = d_lookup(file-&gt;f_path.dentry, &amp;qstr);
<a name="l03110"></a>03110         <span class="keywordflow">if</span> (dchild != NULL) {
<a name="l03111"></a>03111                 <span class="keywordflow">if</span> (dchild-&gt;d_inode != NULL)
<a name="l03112"></a>03112                         child_inode = igrab(dchild-&gt;d_inode);
<a name="l03113"></a>03113                 dput(dchild);
<a name="l03114"></a>03114         }
<a name="l03115"></a>03115 
<a name="l03116"></a>03116         <span class="keywordflow">if</span> (child_inode == NULL) {
<a name="l03117"></a>03117                 rc = ll_get_fid_by_name(parent, name, namelen,
<a name="l03118"></a>03118                                         &amp;op_data-&gt;op_fid3, &amp;child_inode);
<a name="l03119"></a>03119                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03120"></a>03120                         GOTO(out_free, rc);
<a name="l03121"></a>03121         }
<a name="l03122"></a>03122 
<a name="l03123"></a>03123         <span class="keywordflow">if</span> (child_inode == NULL)
<a name="l03124"></a>03124                 GOTO(out_free, rc = -EINVAL);
<a name="l03125"></a>03125 
<a name="l03126"></a>03126         <span class="comment">/*</span>
<a name="l03127"></a>03127 <span class="comment">         * lfs migrate command needs to be blocked on the client</span>
<a name="l03128"></a>03128 <span class="comment">         * by checking the migrate FID against the FID of the</span>
<a name="l03129"></a>03129 <span class="comment">         * filesystem root.</span>
<a name="l03130"></a>03130 <span class="comment">         */</span>
<a name="l03131"></a>03131         <span class="keywordflow">if</span> (child_inode == parent-&gt;i_sb-&gt;s_root-&gt;d_inode)
<a name="l03132"></a>03132                 GOTO(out_iput, rc = -EINVAL);
<a name="l03133"></a>03133 
<a name="l03134"></a>03134         mutex_lock(&amp;child_inode-&gt;i_mutex);
<a name="l03135"></a>03135         op_data-&gt;op_fid3 = *ll_inode2fid(child_inode);
<a name="l03136"></a>03136         <span class="keywordflow">if</span> (!fid_is_sane(&amp;op_data-&gt;op_fid3)) {
<a name="l03137"></a>03137                 CERROR(<span class="stringliteral">&quot;%s: migrate %s, but FID &quot;</span>DFID<span class="stringliteral">&quot; is insane\n&quot;</span>,
<a name="l03138"></a>03138                        ll_get_fsname(parent-&gt;i_sb, NULL, 0), name,
<a name="l03139"></a>03139                        PFID(&amp;op_data-&gt;op_fid3));
<a name="l03140"></a>03140                 GOTO(out_unlock, rc = -EINVAL);
<a name="l03141"></a>03141         }
<a name="l03142"></a>03142 
<a name="l03143"></a>03143         rc = ll_get_mdt_idx_by_fid(ll_i2sbi(parent), &amp;op_data-&gt;op_fid3);
<a name="l03144"></a>03144         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03145"></a>03145                 GOTO(out_unlock, rc);
<a name="l03146"></a>03146 
<a name="l03147"></a>03147         <span class="keywordflow">if</span> (rc == mdtidx) {
<a name="l03148"></a>03148                 CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: &quot;</span>DFID<span class="stringliteral">&quot; is already on MDT%04x\n&quot;</span>, name,
<a name="l03149"></a>03149                        PFID(&amp;op_data-&gt;op_fid3), mdtidx);
<a name="l03150"></a>03150                 GOTO(out_unlock, rc = 0);
<a name="l03151"></a>03151         }
<a name="l03152"></a>03152 again:
<a name="l03153"></a>03153         <span class="keywordflow">if</span> (S_ISREG(child_inode-&gt;i_mode)) {
<a name="l03154"></a>03154                 och = ll_lease_open(child_inode, NULL, FMODE_WRITE, 0);
<a name="l03155"></a>03155                 <span class="keywordflow">if</span> (IS_ERR(och)) {
<a name="l03156"></a>03156                         rc = PTR_ERR(och);
<a name="l03157"></a>03157                         och = NULL;
<a name="l03158"></a>03158                         GOTO(out_unlock, rc);
<a name="l03159"></a>03159                 }
<a name="l03160"></a>03160 
<a name="l03161"></a>03161                 rc = ll_data_version(child_inode, &amp;data_version,
<a name="l03162"></a>03162                                      LL_DV_WR_FLUSH);
<a name="l03163"></a>03163                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03164"></a>03164                         GOTO(out_close, rc);
<a name="l03165"></a>03165 
<a name="l03166"></a>03166                 op_data-&gt;op_handle = och-&gt;och_fh;
<a name="l03167"></a>03167                 op_data-&gt;op_data = och-&gt;och_mod;
<a name="l03168"></a>03168                 op_data-&gt;op_data_version = data_version;
<a name="l03169"></a>03169                 op_data-&gt;op_lease_handle = och-&gt;och_lease_handle;
<a name="l03170"></a>03170                 op_data-&gt;op_bias |= MDS_RENAME_MIGRATE;
<a name="l03171"></a>03171         }
<a name="l03172"></a>03172 
<a name="l03173"></a>03173         op_data-&gt;op_mds = mdtidx;
<a name="l03174"></a>03174         op_data-&gt;op_cli_flags = CLI_MIGRATE;
<a name="l03175"></a>03175         rc = md_rename(ll_i2sbi(parent)-&gt;ll_md_exp, op_data, name,
<a name="l03176"></a>03176                        namelen, name, namelen, &amp;request);
<a name="l03177"></a>03177         <span class="keywordflow">if</span> (rc == 0)
<a name="l03178"></a>03178                 ll_update_times(request, parent);
<a name="l03179"></a>03179 
<a name="l03180"></a>03180         <span class="keywordflow">if</span> (request != NULL) {
<a name="l03181"></a>03181                 body = <a class="code" href="group__req__layout.html#ga0d1ad53a1914c35470f3916e4bb4b8fe" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC reply buffer...">req_capsule_server_get</a>(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_MDT_BODY);
<a name="l03182"></a>03182                 <span class="keywordflow">if</span> (body == NULL) {
<a name="l03183"></a>03183                         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(request);
<a name="l03184"></a>03184                         GOTO(out_close, rc = -EPROTO);
<a name="l03185"></a>03185                 }
<a name="l03186"></a>03186 
<a name="l03187"></a>03187                 <span class="comment">/* If the server does release layout lock, then we cleanup</span>
<a name="l03188"></a>03188 <span class="comment">                 * the client och here, otherwise release it in out_close: */</span>
<a name="l03189"></a>03189                 <span class="keywordflow">if</span> (och != NULL &amp;&amp;
<a name="l03190"></a>03190                     body-&gt;mbo_valid &amp; OBD_MD_CLOSE_INTENT_EXECED) {
<a name="l03191"></a>03191                         obd_mod_put(och-&gt;och_mod);
<a name="l03192"></a>03192                         md_clear_open_replay_data(ll_i2sbi(parent)-&gt;ll_md_exp,
<a name="l03193"></a>03193                                                   och);
<a name="l03194"></a>03194                         och-&gt;och_fh.cookie = DEAD_HANDLE_MAGIC;
<a name="l03195"></a>03195                         OBD_FREE_PTR(och);
<a name="l03196"></a>03196                         och = NULL;
<a name="l03197"></a>03197                 }
<a name="l03198"></a>03198                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(request);
<a name="l03199"></a>03199         }
<a name="l03200"></a>03200 
<a name="l03201"></a>03201         <span class="comment">/* Try again if the file layout has changed. */</span>
<a name="l03202"></a>03202         <span class="keywordflow">if</span> (rc == -EAGAIN &amp;&amp; S_ISREG(child_inode-&gt;i_mode)) {
<a name="l03203"></a>03203                 request = NULL;
<a name="l03204"></a>03204                 <span class="keywordflow">goto</span> again;
<a name="l03205"></a>03205         }
<a name="l03206"></a>03206 out_close:
<a name="l03207"></a>03207         <span class="keywordflow">if</span> (och != NULL) <span class="comment">/* close the file */</span>
<a name="l03208"></a>03208                 ll_lease_close(och, child_inode, NULL);
<a name="l03209"></a>03209         <span class="keywordflow">if</span> (rc == 0)
<a name="l03210"></a>03210                 clear_nlink(child_inode);
<a name="l03211"></a>03211 out_unlock:
<a name="l03212"></a>03212         mutex_unlock(&amp;child_inode-&gt;i_mutex);
<a name="l03213"></a>03213 out_iput:
<a name="l03214"></a>03214         iput(child_inode);
<a name="l03215"></a>03215 out_free:
<a name="l03216"></a>03216         ll_finish_md_op_data(op_data);
<a name="l03217"></a>03217         RETURN(rc);
<a name="l03218"></a>03218 }
<a name="l03219"></a>03219 
<a name="l03220"></a>03220 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03221"></a>03221 ll_file_noflock(<span class="keyword">struct</span> file *file, <span class="keywordtype">int</span> cmd, <span class="keyword">struct</span> file_lock *file_lock)
<a name="l03222"></a>03222 {
<a name="l03223"></a>03223         ENTRY;
<a name="l03224"></a>03224 
<a name="l03225"></a>03225         RETURN(-ENOSYS);
<a name="l03226"></a>03226 }
<a name="l03227"></a>03227 
<a name="l03238"></a>03238 <span class="keywordtype">int</span> ll_have_md_lock(<span class="keyword">struct</span> inode *inode, __u64 *bits, <span class="keyword">enum</span> ldlm_mode l_req_mode)
<a name="l03239"></a>03239 {
<a name="l03240"></a>03240         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lockh;
<a name="l03241"></a>03241         <span class="keyword">union </span><a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> policy;
<a name="l03242"></a>03242         <span class="keyword">enum</span> ldlm_mode mode = (l_req_mode == LCK_MINMODE) ?
<a name="l03243"></a>03243                               (LCK_CR | LCK_CW | LCK_PR | LCK_PW) : l_req_mode;
<a name="l03244"></a>03244         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid;
<a name="l03245"></a>03245         __u64 flags;
<a name="l03246"></a>03246         <span class="keywordtype">int</span> i;
<a name="l03247"></a>03247         ENTRY;
<a name="l03248"></a>03248 
<a name="l03249"></a>03249         <span class="keywordflow">if</span> (!inode)
<a name="l03250"></a>03250                RETURN(0);
<a name="l03251"></a>03251 
<a name="l03252"></a>03252         fid = &amp;ll_i2info(inode)-&gt;lli_fid;
<a name="l03253"></a>03253         CDEBUG(D_INFO, <span class="stringliteral">&quot;trying to match res &quot;</span>DFID<span class="stringliteral">&quot; mode %s\n&quot;</span>, PFID(fid),
<a name="l03254"></a>03254                ldlm_lockname[mode]);
<a name="l03255"></a>03255 
<a name="l03256"></a>03256         flags = <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a> | <a class="code" href="group__LDLM.html#ga3845b64e7040a6d03323e5289bd71adc" title="this lock is being destroyed">LDLM_FL_CBPENDING</a> | LDLM_FL_TEST_LOCK;
<a name="l03257"></a>03257         <span class="keywordflow">for</span> (i = 0; i &lt;= MDS_INODELOCK_MAXSHIFT &amp;&amp; *bits != 0; i++) {
<a name="l03258"></a>03258                 policy.l_inodebits.bits = *bits &amp; (1 &lt;&lt; i);
<a name="l03259"></a>03259                 <span class="keywordflow">if</span> (policy.l_inodebits.bits == 0)
<a name="l03260"></a>03260                         <span class="keywordflow">continue</span>;
<a name="l03261"></a>03261 
<a name="l03262"></a>03262                 <span class="keywordflow">if</span> (md_lock_match(ll_i2mdexp(inode), flags, fid, LDLM_IBITS,
<a name="l03263"></a>03263                                   &amp;policy, mode, &amp;lockh)) {
<a name="l03264"></a>03264                         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock;
<a name="l03265"></a>03265 
<a name="l03266"></a>03266                         lock = ldlm_handle2lock(&amp;lockh);
<a name="l03267"></a>03267                         <span class="keywordflow">if</span> (lock) {
<a name="l03268"></a>03268                                 *bits &amp;=
<a name="l03269"></a>03269                                       ~(lock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.l_inodebits.bits);
<a name="l03270"></a>03270                                 <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l03271"></a>03271                         } <span class="keywordflow">else</span> {
<a name="l03272"></a>03272                                 *bits &amp;= ~policy.l_inodebits.bits;
<a name="l03273"></a>03273                         }
<a name="l03274"></a>03274                 }
<a name="l03275"></a>03275         }
<a name="l03276"></a>03276         RETURN(*bits == 0);
<a name="l03277"></a>03277 }
<a name="l03278"></a>03278 
<a name="l03279"></a>03279 <span class="keyword">enum</span> ldlm_mode ll_take_md_lock(<span class="keyword">struct</span> inode *inode, __u64 bits,
<a name="l03280"></a>03280                                <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lockh, __u64 flags,
<a name="l03281"></a>03281                                <span class="keyword">enum</span> ldlm_mode mode)
<a name="l03282"></a>03282 {
<a name="l03283"></a>03283         <span class="keyword">union </span><a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> policy = { .l_inodebits = { bits } };
<a name="l03284"></a>03284         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid;
<a name="l03285"></a>03285         <span class="keyword">enum</span> ldlm_mode rc;
<a name="l03286"></a>03286         ENTRY;
<a name="l03287"></a>03287 
<a name="l03288"></a>03288         fid = &amp;ll_i2info(inode)-&gt;lli_fid;
<a name="l03289"></a>03289         CDEBUG(D_INFO, <span class="stringliteral">&quot;trying to match res &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>, PFID(fid));
<a name="l03290"></a>03290 
<a name="l03291"></a>03291         rc = md_lock_match(ll_i2mdexp(inode), <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a>|flags,
<a name="l03292"></a>03292                            fid, LDLM_IBITS, &amp;policy, mode, lockh);
<a name="l03293"></a>03293 
<a name="l03294"></a>03294         RETURN(rc);
<a name="l03295"></a>03295 }
<a name="l03296"></a>03296 
<a name="l03297"></a>03297 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_inode_revalidate_fini(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">int</span> rc)
<a name="l03298"></a>03298 {
<a name="l03299"></a>03299         <span class="comment">/* Already unlinked. Just update nlink and return success */</span>
<a name="l03300"></a>03300         <span class="keywordflow">if</span> (rc == -ENOENT) {
<a name="l03301"></a>03301                 clear_nlink(inode);
<a name="l03302"></a>03302                 <span class="comment">/* If it is striped directory, and there is bad stripe</span>
<a name="l03303"></a>03303 <span class="comment">                 * Let&apos;s revalidate the dentry again, instead of returning</span>
<a name="l03304"></a>03304 <span class="comment">                 * error */</span>
<a name="l03305"></a>03305                 <span class="keywordflow">if</span> (S_ISDIR(inode-&gt;i_mode) &amp;&amp;
<a name="l03306"></a>03306                     ll_i2info(inode)-&gt;lli_lsm_md != NULL)
<a name="l03307"></a>03307                         <span class="keywordflow">return</span> 0;
<a name="l03308"></a>03308 
<a name="l03309"></a>03309                 <span class="comment">/* This path cannot be hit for regular files unless in</span>
<a name="l03310"></a>03310 <span class="comment">                 * case of obscure races, so no need to to validate</span>
<a name="l03311"></a>03311 <span class="comment">                 * size. */</span>
<a name="l03312"></a>03312                 <span class="keywordflow">if</span> (!S_ISREG(inode-&gt;i_mode) &amp;&amp; !S_ISDIR(inode-&gt;i_mode))
<a name="l03313"></a>03313                         <span class="keywordflow">return</span> 0;
<a name="l03314"></a>03314         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != 0) {
<a name="l03315"></a>03315                 CDEBUG_LIMIT((rc == -EACCES || rc == -EIDRM) ? D_INFO : D_ERROR,
<a name="l03316"></a>03316                              <span class="stringliteral">&quot;%s: revalidate FID &quot;</span>DFID<span class="stringliteral">&quot; error: rc = %d\n&quot;</span>,
<a name="l03317"></a>03317                              ll_get_fsname(inode-&gt;i_sb, NULL, 0),
<a name="l03318"></a>03318                              PFID(ll_inode2fid(inode)), rc);
<a name="l03319"></a>03319         }
<a name="l03320"></a>03320 
<a name="l03321"></a>03321         <span class="keywordflow">return</span> rc;
<a name="l03322"></a>03322 }
<a name="l03323"></a>03323 
<a name="l03324"></a>03324 <span class="keyword">static</span> <span class="keywordtype">int</span> __ll_inode_revalidate(<span class="keyword">struct</span> dentry *dentry, __u64 ibits)
<a name="l03325"></a>03325 {
<a name="l03326"></a>03326         <span class="keyword">struct </span>inode *inode = dentry-&gt;d_inode;
<a name="l03327"></a>03327         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = NULL;
<a name="l03328"></a>03328         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp;
<a name="l03329"></a>03329         <span class="keywordtype">int</span> rc = 0;
<a name="l03330"></a>03330         ENTRY;
<a name="l03331"></a>03331 
<a name="l03332"></a>03332         LASSERT(inode != NULL);
<a name="l03333"></a>03333 
<a name="l03334"></a>03334         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;VFS Op:inode=&quot;</span>DFID<span class="stringliteral">&quot;(%p),name=%s\n&quot;</span>,
<a name="l03335"></a>03335                PFID(ll_inode2fid(inode)), inode, dentry-&gt;d_name.name);
<a name="l03336"></a>03336 
<a name="l03337"></a>03337         exp = ll_i2mdexp(inode);
<a name="l03338"></a>03338 
<a name="l03339"></a>03339         <span class="comment">/* XXX: Enable OBD_CONNECT_ATTRFID to reduce unnecessary getattr RPC.</span>
<a name="l03340"></a>03340 <span class="comment">         *      But under CMD case, it caused some lock issues, should be fixed</span>
<a name="l03341"></a>03341 <span class="comment">         *      with new CMD ibits lock. See bug 12718 */</span>
<a name="l03342"></a>03342         <span class="keywordflow">if</span> (exp_connect_flags(exp) &amp; OBD_CONNECT_ATTRFID) {
<a name="l03343"></a>03343                 <span class="keyword">struct </span><a class="code" href="structlookup__intent.html">lookup_intent</a> oit = { .it_op = IT_GETATTR };
<a name="l03344"></a>03344                 <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a> *op_data;
<a name="l03345"></a>03345 
<a name="l03346"></a>03346                 <span class="keywordflow">if</span> (ibits == MDS_INODELOCK_LOOKUP)
<a name="l03347"></a>03347                         oit.it_op = IT_LOOKUP;
<a name="l03348"></a>03348 
<a name="l03349"></a>03349                 <span class="comment">/* Call getattr by fid, so do not provide name at all. */</span>
<a name="l03350"></a>03350                 op_data = ll_prep_md_op_data(NULL, dentry-&gt;d_inode,
<a name="l03351"></a>03351                                              dentry-&gt;d_inode, NULL, 0, 0,
<a name="l03352"></a>03352                                              LUSTRE_OPC_ANY, NULL);
<a name="l03353"></a>03353                 <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l03354"></a>03354                         RETURN(PTR_ERR(op_data));
<a name="l03355"></a>03355 
<a name="l03356"></a>03356                 rc = md_intent_lock(exp, op_data, &amp;oit, &amp;req,
<a name="l03357"></a>03357                                     &amp;ll_md_blocking_ast, 0);
<a name="l03358"></a>03358                 ll_finish_md_op_data(op_data);
<a name="l03359"></a>03359                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l03360"></a>03360                         rc = ll_inode_revalidate_fini(inode, rc);
<a name="l03361"></a>03361                         GOTO (out, rc);
<a name="l03362"></a>03362                 }
<a name="l03363"></a>03363 
<a name="l03364"></a>03364                 rc = ll_revalidate_it_finish(req, &amp;oit, dentry);
<a name="l03365"></a>03365                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l03366"></a>03366                         ll_intent_release(&amp;oit);
<a name="l03367"></a>03367                         GOTO(out, rc);
<a name="l03368"></a>03368                 }
<a name="l03369"></a>03369 
<a name="l03370"></a>03370                 <span class="comment">/* Unlinked? Unhash dentry, so it is not picked up later by</span>
<a name="l03371"></a>03371 <span class="comment">                   do_lookup() -&gt; ll_revalidate_it(). We cannot use d_drop</span>
<a name="l03372"></a>03372 <span class="comment">                   here to preserve get_cwd functionality on 2.6.</span>
<a name="l03373"></a>03373 <span class="comment">                   Bug 10503 */</span>
<a name="l03374"></a>03374                 <span class="keywordflow">if</span> (!dentry-&gt;d_inode-&gt;i_nlink) {
<a name="l03375"></a>03375                         ll_lock_dcache(inode);
<a name="l03376"></a>03376                         d_lustre_invalidate(dentry, 0);
<a name="l03377"></a>03377                         ll_unlock_dcache(inode);
<a name="l03378"></a>03378                 }
<a name="l03379"></a>03379 
<a name="l03380"></a>03380                 ll_lookup_finish_locks(&amp;oit, dentry);
<a name="l03381"></a>03381         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!ll_have_md_lock(dentry-&gt;d_inode, &amp;ibits, LCK_MINMODE)) {
<a name="l03382"></a>03382                 <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a> *sbi = ll_i2sbi(dentry-&gt;d_inode);
<a name="l03383"></a>03383                 u64 valid = OBD_MD_FLGETATTR;
<a name="l03384"></a>03384                 <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a> *op_data;
<a name="l03385"></a>03385                 <span class="keywordtype">int</span> ealen = 0;
<a name="l03386"></a>03386 
<a name="l03387"></a>03387                 <span class="keywordflow">if</span> (S_ISREG(inode-&gt;i_mode)) {
<a name="l03388"></a>03388                         rc = ll_get_default_mdsize(sbi, &amp;ealen);
<a name="l03389"></a>03389                         <span class="keywordflow">if</span> (rc)
<a name="l03390"></a>03390                                 RETURN(rc);
<a name="l03391"></a>03391                         valid |= OBD_MD_FLEASIZE | OBD_MD_FLMODEASIZE;
<a name="l03392"></a>03392                 }
<a name="l03393"></a>03393 
<a name="l03394"></a>03394                 op_data = ll_prep_md_op_data(NULL, inode, NULL, NULL,
<a name="l03395"></a>03395                                              0, ealen, LUSTRE_OPC_ANY,
<a name="l03396"></a>03396                                              NULL);
<a name="l03397"></a>03397                 <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l03398"></a>03398                         RETURN(PTR_ERR(op_data));
<a name="l03399"></a>03399 
<a name="l03400"></a>03400                 op_data-&gt;op_valid = valid;
<a name="l03401"></a>03401                 rc = md_getattr(sbi-&gt;ll_md_exp, op_data, &amp;req);
<a name="l03402"></a>03402                 ll_finish_md_op_data(op_data);
<a name="l03403"></a>03403                 <span class="keywordflow">if</span> (rc) {
<a name="l03404"></a>03404                         rc = ll_inode_revalidate_fini(inode, rc);
<a name="l03405"></a>03405                         RETURN(rc);
<a name="l03406"></a>03406                 }
<a name="l03407"></a>03407 
<a name="l03408"></a>03408                 rc = ll_prep_inode(&amp;inode, req, NULL, NULL);
<a name="l03409"></a>03409         }
<a name="l03410"></a>03410 out:
<a name="l03411"></a>03411         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l03412"></a>03412         <span class="keywordflow">return</span> rc;
<a name="l03413"></a>03413 }
<a name="l03414"></a>03414 
<a name="l03415"></a>03415 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_merge_md_attr(<span class="keyword">struct</span> inode *inode)
<a name="l03416"></a>03416 {
<a name="l03417"></a>03417         <span class="keyword">struct </span><a class="code" href="structcl__attr.html" title="&amp;quot;Data attributes&amp;quot; of cl_object.">cl_attr</a> attr = { 0 };
<a name="l03418"></a>03418         <span class="keywordtype">int</span> rc;
<a name="l03419"></a>03419 
<a name="l03420"></a>03420         LASSERT(ll_i2info(inode)-&gt;lli_lsm_md != NULL);
<a name="l03421"></a>03421         rc = md_merge_attr(ll_i2mdexp(inode), ll_i2info(inode)-&gt;lli_lsm_md,
<a name="l03422"></a>03422                            &amp;attr, ll_md_blocking_ast);
<a name="l03423"></a>03423         <span class="keywordflow">if</span> (rc != 0)
<a name="l03424"></a>03424                 RETURN(rc);
<a name="l03425"></a>03425 
<a name="l03426"></a>03426         set_nlink(inode, attr.cat_nlink);
<a name="l03427"></a>03427         inode-&gt;i_blocks = attr.<a class="code" href="structcl__attr.html#aa5bce270584ece6d9511008c0d827821" title="Blocks allocated to this cl_object on the server file system.">cat_blocks</a>;
<a name="l03428"></a>03428         i_size_write(inode, attr.<a class="code" href="structcl__attr.html#a301cbfa8e597852a6f7cf1b5a22d5269" title="Object size, in bytes.">cat_size</a>);
<a name="l03429"></a>03429 
<a name="l03430"></a>03430         ll_i2info(inode)-&gt;lli_atime = attr.<a class="code" href="structcl__attr.html#a703fa4a91dbf487ea43a491efbcbb26c" title="Access time.">cat_atime</a>;
<a name="l03431"></a>03431         ll_i2info(inode)-&gt;lli_mtime = attr.<a class="code" href="structcl__attr.html#ac337ab4467993ed3c1ed8a74407e933b" title="Modification time.">cat_mtime</a>;
<a name="l03432"></a>03432         ll_i2info(inode)-&gt;lli_ctime = attr.<a class="code" href="structcl__attr.html#ad219a939eaf54b1de26b049f26d513e3" title="Change time.">cat_ctime</a>;
<a name="l03433"></a>03433 
<a name="l03434"></a>03434         RETURN(0);
<a name="l03435"></a>03435 }
<a name="l03436"></a>03436 
<a name="l03437"></a>03437 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03438"></a>03438 ll_inode_revalidate(<span class="keyword">struct</span> dentry *dentry, __u64 ibits)
<a name="l03439"></a>03439 {
<a name="l03440"></a>03440         <span class="keyword">struct </span>inode    *inode = dentry-&gt;d_inode;
<a name="l03441"></a>03441         <span class="keywordtype">int</span>              rc;
<a name="l03442"></a>03442         ENTRY;
<a name="l03443"></a>03443 
<a name="l03444"></a>03444         rc = __ll_inode_revalidate(dentry, ibits);
<a name="l03445"></a>03445         <span class="keywordflow">if</span> (rc != 0)
<a name="l03446"></a>03446                 RETURN(rc);
<a name="l03447"></a>03447 
<a name="l03448"></a>03448         <span class="comment">/* if object isn&apos;t regular file, don&apos;t validate size */</span>
<a name="l03449"></a>03449         <span class="keywordflow">if</span> (!S_ISREG(inode-&gt;i_mode)) {
<a name="l03450"></a>03450                 <span class="keywordflow">if</span> (S_ISDIR(inode-&gt;i_mode) &amp;&amp;
<a name="l03451"></a>03451                     ll_i2info(inode)-&gt;lli_lsm_md != NULL) {
<a name="l03452"></a>03452                         rc = ll_merge_md_attr(inode);
<a name="l03453"></a>03453                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03454"></a>03454                                 RETURN(rc);
<a name="l03455"></a>03455                 }
<a name="l03456"></a>03456 
<a name="l03457"></a>03457                 LTIME_S(inode-&gt;i_atime) = ll_i2info(inode)-&gt;lli_atime;
<a name="l03458"></a>03458                 LTIME_S(inode-&gt;i_mtime) = ll_i2info(inode)-&gt;lli_mtime;
<a name="l03459"></a>03459                 LTIME_S(inode-&gt;i_ctime) = ll_i2info(inode)-&gt;lli_ctime;
<a name="l03460"></a>03460         } <span class="keywordflow">else</span> {
<a name="l03461"></a>03461                 <span class="comment">/* In case of restore, the MDT has the right size and has</span>
<a name="l03462"></a>03462 <span class="comment">                 * already send it back without granting the layout lock,</span>
<a name="l03463"></a>03463 <span class="comment">                 * inode is up-to-date so glimpse is useless.</span>
<a name="l03464"></a>03464 <span class="comment">                 * Also to glimpse we need the layout, in case of a running</span>
<a name="l03465"></a>03465 <span class="comment">                 * restore the MDT holds the layout lock so the glimpse will</span>
<a name="l03466"></a>03466 <span class="comment">                 * block up to the end of restore (getattr will block)</span>
<a name="l03467"></a>03467 <span class="comment">                 */</span>
<a name="l03468"></a>03468                 <span class="keywordflow">if</span> (!ll_file_test_flag(ll_i2info(inode), LLIF_FILE_RESTORING))
<a name="l03469"></a>03469                         rc = ll_glimpse_size(inode);
<a name="l03470"></a>03470         }
<a name="l03471"></a>03471         RETURN(rc);
<a name="l03472"></a>03472 }
<a name="l03473"></a>03473 
<a name="l03474"></a>03474 <span class="keywordtype">int</span> ll_getattr(<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> dentry *de, <span class="keyword">struct</span> kstat *stat)
<a name="l03475"></a>03475 {
<a name="l03476"></a>03476         <span class="keyword">struct </span>inode *inode = de-&gt;d_inode;
<a name="l03477"></a>03477         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a> *sbi = ll_i2sbi(inode);
<a name="l03478"></a>03478         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l03479"></a>03479         <span class="keywordtype">int</span> res = 0;
<a name="l03480"></a>03480 
<a name="l03481"></a>03481         res = ll_inode_revalidate(de, MDS_INODELOCK_UPDATE |
<a name="l03482"></a>03482                                       MDS_INODELOCK_LOOKUP);
<a name="l03483"></a>03483         ll_stats_ops_tally(sbi, LPROC_LL_GETATTR, 1);
<a name="l03484"></a>03484 
<a name="l03485"></a>03485         <span class="keywordflow">if</span> (res)
<a name="l03486"></a>03486                 <span class="keywordflow">return</span> res;
<a name="l03487"></a>03487 
<a name="l03488"></a>03488         OBD_FAIL_TIMEOUT(OBD_FAIL_GETATTR_DELAY, 30);
<a name="l03489"></a>03489 
<a name="l03490"></a>03490         stat-&gt;dev = inode-&gt;i_sb-&gt;s_dev;
<a name="l03491"></a>03491         <span class="keywordflow">if</span> (ll_need_32bit_api(sbi))
<a name="l03492"></a>03492                 stat-&gt;ino = cl_fid_build_ino(&amp;lli-&gt;lli_fid, 1);
<a name="l03493"></a>03493         <span class="keywordflow">else</span>
<a name="l03494"></a>03494                 stat-&gt;ino = inode-&gt;i_ino;
<a name="l03495"></a>03495         stat-&gt;mode = inode-&gt;i_mode;
<a name="l03496"></a>03496         stat-&gt;uid = inode-&gt;i_uid;
<a name="l03497"></a>03497         stat-&gt;gid = inode-&gt;i_gid;
<a name="l03498"></a>03498         stat-&gt;rdev = inode-&gt;i_rdev;
<a name="l03499"></a>03499         stat-&gt;atime = inode-&gt;i_atime;
<a name="l03500"></a>03500         stat-&gt;mtime = inode-&gt;i_mtime;
<a name="l03501"></a>03501         stat-&gt;ctime = inode-&gt;i_ctime;
<a name="l03502"></a>03502         stat-&gt;blksize = 1 &lt;&lt; inode-&gt;i_blkbits;
<a name="l03503"></a>03503 
<a name="l03504"></a>03504         stat-&gt;nlink = inode-&gt;i_nlink;
<a name="l03505"></a>03505         stat-&gt;size = i_size_read(inode);
<a name="l03506"></a>03506         stat-&gt;blocks = inode-&gt;i_blocks;
<a name="l03507"></a>03507 
<a name="l03508"></a>03508         <span class="keywordflow">return</span> 0;
<a name="l03509"></a>03509 }
<a name="l03510"></a>03510 
<a name="l03511"></a>03511 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_fiemap(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> fiemap_extent_info *fieinfo,
<a name="l03512"></a>03512                      __u64 start, __u64 len)
<a name="l03513"></a>03513 {
<a name="l03514"></a>03514         <span class="keywordtype">int</span>             rc;
<a name="l03515"></a>03515         <span class="keywordtype">size_t</span>          num_bytes;
<a name="l03516"></a>03516         <span class="keyword">struct </span>fiemap   *fiemap;
<a name="l03517"></a>03517         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    extent_count = fieinfo-&gt;fi_extents_max;
<a name="l03518"></a>03518 
<a name="l03519"></a>03519         num_bytes = <span class="keyword">sizeof</span>(*fiemap) + (extent_count *
<a name="l03520"></a>03520                                        <span class="keyword">sizeof</span>(<span class="keyword">struct </span>fiemap_extent));
<a name="l03521"></a>03521         OBD_ALLOC_LARGE(fiemap, num_bytes);
<a name="l03522"></a>03522 
<a name="l03523"></a>03523         <span class="keywordflow">if</span> (fiemap == NULL)
<a name="l03524"></a>03524                 RETURN(-ENOMEM);
<a name="l03525"></a>03525 
<a name="l03526"></a>03526         fiemap-&gt;fm_flags = fieinfo-&gt;fi_flags;
<a name="l03527"></a>03527         fiemap-&gt;fm_extent_count = fieinfo-&gt;fi_extents_max;
<a name="l03528"></a>03528         fiemap-&gt;fm_start = start;
<a name="l03529"></a>03529         fiemap-&gt;fm_length = len;
<a name="l03530"></a>03530         <span class="keywordflow">if</span> (extent_count &gt; 0 &amp;&amp;
<a name="l03531"></a>03531             copy_from_user(&amp;fiemap-&gt;fm_extents[0], fieinfo-&gt;fi_extents_start,
<a name="l03532"></a>03532                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fiemap_extent)) != 0)
<a name="l03533"></a>03533                 GOTO(out, rc = -EFAULT);
<a name="l03534"></a>03534 
<a name="l03535"></a>03535         rc = ll_do_fiemap(inode, fiemap, num_bytes);
<a name="l03536"></a>03536 
<a name="l03537"></a>03537         fieinfo-&gt;fi_flags = fiemap-&gt;fm_flags;
<a name="l03538"></a>03538         fieinfo-&gt;fi_extents_mapped = fiemap-&gt;fm_mapped_extents;
<a name="l03539"></a>03539         <span class="keywordflow">if</span> (extent_count &gt; 0 &amp;&amp;
<a name="l03540"></a>03540             copy_to_user(fieinfo-&gt;fi_extents_start, &amp;fiemap-&gt;fm_extents[0],
<a name="l03541"></a>03541                          fiemap-&gt;fm_mapped_extents *
<a name="l03542"></a>03542                          <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fiemap_extent)) != 0)
<a name="l03543"></a>03543                 GOTO(out, rc = -EFAULT);
<a name="l03544"></a>03544 out:
<a name="l03545"></a>03545         OBD_FREE_LARGE(fiemap, num_bytes);
<a name="l03546"></a>03546         <span class="keywordflow">return</span> rc;
<a name="l03547"></a>03547 }
<a name="l03548"></a>03548 
<a name="l03549"></a>03549 <span class="keyword">struct </span>posix_acl *ll_get_acl(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">int</span> type)
<a name="l03550"></a>03550 {
<a name="l03551"></a>03551         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l03552"></a>03552         <span class="keyword">struct </span>posix_acl *acl = NULL;
<a name="l03553"></a>03553         ENTRY;
<a name="l03554"></a>03554 
<a name="l03555"></a>03555         spin_lock(&amp;lli-&gt;lli_lock);
<a name="l03556"></a>03556         <span class="comment">/* VFS&apos; acl_permission_check-&gt;check_acl will release the refcount */</span>
<a name="l03557"></a>03557         acl = posix_acl_dup(lli-&gt;lli_posix_acl);
<a name="l03558"></a>03558         spin_unlock(&amp;lli-&gt;lli_lock);
<a name="l03559"></a>03559 
<a name="l03560"></a>03560         RETURN(acl);
<a name="l03561"></a>03561 }
<a name="l03562"></a>03562 
<a name="l03563"></a>03563 <span class="preprocessor">#ifndef HAVE_GENERIC_PERMISSION_2ARGS</span>
<a name="l03564"></a>03564 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03565"></a>03565 <span class="preprocessor"># ifdef HAVE_GENERIC_PERMISSION_4ARGS</span>
<a name="l03566"></a>03566 <span class="preprocessor"></span>ll_check_acl(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">int</span> mask, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
<a name="l03567"></a>03567 <span class="preprocessor"># else</span>
<a name="l03568"></a>03568 <span class="preprocessor"></span>ll_check_acl(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">int</span> mask)
<a name="l03569"></a>03569 <span class="preprocessor"># endif</span>
<a name="l03570"></a>03570 <span class="preprocessor"></span>{
<a name="l03571"></a>03571 <span class="preprocessor"># ifdef CONFIG_FS_POSIX_ACL</span>
<a name="l03572"></a>03572 <span class="preprocessor"></span>        <span class="keyword">struct </span>posix_acl *acl;
<a name="l03573"></a>03573         <span class="keywordtype">int</span> rc;
<a name="l03574"></a>03574         ENTRY;
<a name="l03575"></a>03575 
<a name="l03576"></a>03576 <span class="preprocessor">#  ifdef HAVE_GENERIC_PERMISSION_4ARGS</span>
<a name="l03577"></a>03577 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (flags &amp; IPERM_FLAG_RCU)
<a name="l03578"></a>03578                 <span class="keywordflow">return</span> -ECHILD;
<a name="l03579"></a>03579 <span class="preprocessor">#  endif</span>
<a name="l03580"></a>03580 <span class="preprocessor"></span>        acl = ll_get_acl(inode, ACL_TYPE_ACCESS);
<a name="l03581"></a>03581 
<a name="l03582"></a>03582         <span class="keywordflow">if</span> (!acl)
<a name="l03583"></a>03583                 RETURN(-EAGAIN);
<a name="l03584"></a>03584 
<a name="l03585"></a>03585         rc = posix_acl_permission(inode, acl, mask);
<a name="l03586"></a>03586         posix_acl_release(acl);
<a name="l03587"></a>03587 
<a name="l03588"></a>03588         RETURN(rc);
<a name="l03589"></a>03589 <span class="preprocessor"># else </span><span class="comment">/* !CONFIG_FS_POSIX_ACL */</span>
<a name="l03590"></a>03590         <span class="keywordflow">return</span> -EAGAIN;
<a name="l03591"></a>03591 <span class="preprocessor"># endif </span><span class="comment">/* CONFIG_FS_POSIX_ACL */</span>
<a name="l03592"></a>03592 }
<a name="l03593"></a>03593 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_GENERIC_PERMISSION_2ARGS */</span>
<a name="l03594"></a>03594 
<a name="l03595"></a>03595 <span class="preprocessor">#ifdef HAVE_GENERIC_PERMISSION_4ARGS</span>
<a name="l03596"></a>03596 <span class="preprocessor"></span><span class="keywordtype">int</span> ll_inode_permission(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">int</span> mask, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
<a name="l03597"></a>03597 <span class="preprocessor">#else</span>
<a name="l03598"></a>03598 <span class="preprocessor"></span><span class="preprocessor"># ifdef HAVE_INODE_PERMISION_2ARGS</span>
<a name="l03599"></a>03599 <span class="preprocessor"></span><span class="keywordtype">int</span> ll_inode_permission(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">int</span> mask)
<a name="l03600"></a>03600 <span class="preprocessor"># else</span>
<a name="l03601"></a>03601 <span class="preprocessor"></span><span class="keywordtype">int</span> ll_inode_permission(<span class="keyword">struct</span> inode *inode, <span class="keywordtype">int</span> mask, <span class="keyword">struct</span> nameidata *nd)
<a name="l03602"></a>03602 <span class="preprocessor"># endif</span>
<a name="l03603"></a>03603 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03604"></a>03604 <span class="preprocessor"></span>{
<a name="l03605"></a>03605         <span class="keywordtype">int</span> rc = 0;
<a name="l03606"></a>03606         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a> *sbi;
<a name="l03607"></a>03607         <span class="keyword">struct </span><a class="code" href="structroot__squash__info.html">root_squash_info</a> *squash;
<a name="l03608"></a>03608         <span class="keyword">struct </span>cred *cred = NULL;
<a name="l03609"></a>03609         <span class="keyword">const</span> <span class="keyword">struct </span>cred *old_cred = NULL;
<a name="l03610"></a>03610         cfs_cap_t cap;
<a name="l03611"></a>03611         <span class="keywordtype">bool</span> squash_id = <span class="keyword">false</span>;
<a name="l03612"></a>03612         ENTRY;
<a name="l03613"></a>03613 
<a name="l03614"></a>03614 <span class="preprocessor">#ifdef MAY_NOT_BLOCK</span>
<a name="l03615"></a>03615 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (mask &amp; MAY_NOT_BLOCK)
<a name="l03616"></a>03616                 <span class="keywordflow">return</span> -ECHILD;
<a name="l03617"></a>03617 <span class="preprocessor">#elif defined(HAVE_GENERIC_PERMISSION_4ARGS)</span>
<a name="l03618"></a>03618 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (flags &amp; IPERM_FLAG_RCU)
<a name="l03619"></a>03619                 <span class="keywordflow">return</span> -ECHILD;
<a name="l03620"></a>03620 <span class="preprocessor">#endif</span>
<a name="l03621"></a>03621 <span class="preprocessor"></span>
<a name="l03622"></a>03622        <span class="comment">/* as root inode are NOT getting validated in lookup operation,</span>
<a name="l03623"></a>03623 <span class="comment">        * need to do it before permission check. */</span>
<a name="l03624"></a>03624 
<a name="l03625"></a>03625         <span class="keywordflow">if</span> (inode == inode-&gt;i_sb-&gt;s_root-&gt;d_inode) {
<a name="l03626"></a>03626                 rc = __ll_inode_revalidate(inode-&gt;i_sb-&gt;s_root,
<a name="l03627"></a>03627                                            MDS_INODELOCK_LOOKUP);
<a name="l03628"></a>03628                 <span class="keywordflow">if</span> (rc)
<a name="l03629"></a>03629                         RETURN(rc);
<a name="l03630"></a>03630         }
<a name="l03631"></a>03631 
<a name="l03632"></a>03632         CDEBUG(D_VFSTRACE, <span class="stringliteral">&quot;VFS Op:inode=&quot;</span>DFID<span class="stringliteral">&quot;(%p), inode mode %x mask %o\n&quot;</span>,
<a name="l03633"></a>03633                PFID(ll_inode2fid(inode)), inode, inode-&gt;i_mode, mask);
<a name="l03634"></a>03634 
<a name="l03635"></a>03635         <span class="comment">/* squash fsuid/fsgid if needed */</span>
<a name="l03636"></a>03636         sbi = ll_i2sbi(inode);
<a name="l03637"></a>03637         squash = &amp;sbi-&gt;ll_squash;
<a name="l03638"></a>03638         <span class="keywordflow">if</span> (unlikely(squash-&gt;rsi_uid != 0 &amp;&amp;
<a name="l03639"></a>03639                      uid_eq(current_fsuid(), GLOBAL_ROOT_UID) &amp;&amp;
<a name="l03640"></a>03640                      !(sbi-&gt;ll_flags &amp; LL_SBI_NOROOTSQUASH))) {
<a name="l03641"></a>03641                         squash_id = <span class="keyword">true</span>;
<a name="l03642"></a>03642         }
<a name="l03643"></a>03643         <span class="keywordflow">if</span> (squash_id) {
<a name="l03644"></a>03644                 CDEBUG(D_OTHER, <span class="stringliteral">&quot;squash creds (%d:%d)=&gt;(%d:%d)\n&quot;</span>,
<a name="l03645"></a>03645                        __kuid_val(current_fsuid()), __kgid_val(current_fsgid()),
<a name="l03646"></a>03646                        squash-&gt;rsi_uid, squash-&gt;rsi_gid);
<a name="l03647"></a>03647 
<a name="l03648"></a>03648                 <span class="comment">/* update current process&apos;s credentials</span>
<a name="l03649"></a>03649 <span class="comment">                 * and FS capability */</span>
<a name="l03650"></a>03650                 cred = prepare_creds();
<a name="l03651"></a>03651                 <span class="keywordflow">if</span> (cred == NULL)
<a name="l03652"></a>03652                         RETURN(-ENOMEM);
<a name="l03653"></a>03653 
<a name="l03654"></a>03654                 cred-&gt;fsuid = make_kuid(&amp;init_user_ns, squash-&gt;rsi_uid);
<a name="l03655"></a>03655                 cred-&gt;fsgid = make_kgid(&amp;init_user_ns, squash-&gt;rsi_gid);
<a name="l03656"></a>03656                 <span class="keywordflow">for</span> (cap = 0; cap &lt; <span class="keyword">sizeof</span>(cfs_cap_t) * 8; cap++) {
<a name="l03657"></a>03657                         <span class="keywordflow">if</span> ((1 &lt;&lt; cap) &amp; CFS_CAP_FS_MASK)
<a name="l03658"></a>03658                                 cap_lower(cred-&gt;cap_effective, cap);
<a name="l03659"></a>03659                 }
<a name="l03660"></a>03660                 old_cred = override_creds(cred);
<a name="l03661"></a>03661         }
<a name="l03662"></a>03662 
<a name="l03663"></a>03663         ll_stats_ops_tally(sbi, LPROC_LL_INODE_PERM, 1);
<a name="l03664"></a>03664 
<a name="l03665"></a>03665         <span class="keywordflow">if</span> (sbi-&gt;ll_flags &amp; LL_SBI_RMT_CLIENT)
<a name="l03666"></a>03666                 rc = lustre_check_remote_perm(inode, mask);
<a name="l03667"></a>03667         <span class="keywordflow">else</span>
<a name="l03668"></a>03668                 rc = ll_generic_permission(inode, mask, flags, ll_check_acl);
<a name="l03669"></a>03669 
<a name="l03670"></a>03670         <span class="comment">/* restore current process&apos;s credentials and FS capability */</span>
<a name="l03671"></a>03671         <span class="keywordflow">if</span> (squash_id) {
<a name="l03672"></a>03672                 revert_creds(old_cred);
<a name="l03673"></a>03673                 put_cred(cred);
<a name="l03674"></a>03674         }
<a name="l03675"></a>03675 
<a name="l03676"></a>03676         RETURN(rc);
<a name="l03677"></a>03677 }
<a name="l03678"></a>03678 
<a name="l03679"></a>03679 <span class="comment">/* -o localflock - only provides locally consistent flock locks */</span>
<a name="l03680"></a>03680 <span class="keyword">struct </span>file_operations ll_file_operations = {
<a name="l03681"></a>03681 <span class="preprocessor">#ifdef HAVE_FILE_OPERATIONS_READ_WRITE_ITER</span>
<a name="l03682"></a>03682 <span class="preprocessor"></span><span class="preprocessor"># ifdef HAVE_SYNC_READ_WRITE</span>
<a name="l03683"></a>03683 <span class="preprocessor"></span>        .read           = new_sync_read,
<a name="l03684"></a>03684         .write          = new_sync_write,
<a name="l03685"></a>03685 <span class="preprocessor"># endif</span>
<a name="l03686"></a>03686 <span class="preprocessor"></span>        .read_iter      = ll_file_read_iter,
<a name="l03687"></a>03687         .write_iter     = ll_file_write_iter,
<a name="l03688"></a>03688 <span class="preprocessor">#else </span><span class="comment">/* !HAVE_FILE_OPERATIONS_READ_WRITE_ITER */</span>
<a name="l03689"></a>03689         .read           = ll_file_read,
<a name="l03690"></a>03690         .aio_read       = ll_file_aio_read,
<a name="l03691"></a>03691         .write          = ll_file_write,
<a name="l03692"></a>03692         .aio_write      = ll_file_aio_write,
<a name="l03693"></a>03693 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_FILE_OPERATIONS_READ_WRITE_ITER */</span>
<a name="l03694"></a>03694         .unlocked_ioctl = ll_file_ioctl,
<a name="l03695"></a>03695         .open           = ll_file_open,
<a name="l03696"></a>03696         .release        = ll_file_release,
<a name="l03697"></a>03697         .mmap           = ll_file_mmap,
<a name="l03698"></a>03698         .llseek         = ll_file_seek,
<a name="l03699"></a>03699         .splice_read    = ll_file_splice_read,
<a name="l03700"></a>03700         .fsync          = ll_fsync,
<a name="l03701"></a>03701         .flush          = ll_flush
<a name="l03702"></a>03702 };
<a name="l03703"></a>03703 
<a name="l03704"></a>03704 <span class="keyword">struct </span>file_operations ll_file_operations_flock = {
<a name="l03705"></a>03705 <span class="preprocessor">#ifdef HAVE_FILE_OPERATIONS_READ_WRITE_ITER</span>
<a name="l03706"></a>03706 <span class="preprocessor"></span><span class="preprocessor"># ifdef HAVE_SYNC_READ_WRITE</span>
<a name="l03707"></a>03707 <span class="preprocessor"></span>        .read           = new_sync_read,
<a name="l03708"></a>03708         .write          = new_sync_write,
<a name="l03709"></a>03709 <span class="preprocessor"># endif </span><span class="comment">/* HAVE_SYNC_READ_WRITE */</span>
<a name="l03710"></a>03710         .read_iter      = ll_file_read_iter,
<a name="l03711"></a>03711         .write_iter     = ll_file_write_iter,
<a name="l03712"></a>03712 <span class="preprocessor">#else </span><span class="comment">/* !HAVE_FILE_OPERATIONS_READ_WRITE_ITER */</span>
<a name="l03713"></a>03713         .read           = ll_file_read,
<a name="l03714"></a>03714         .aio_read       = ll_file_aio_read,
<a name="l03715"></a>03715         .write          = ll_file_write,
<a name="l03716"></a>03716         .aio_write      = ll_file_aio_write,
<a name="l03717"></a>03717 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_FILE_OPERATIONS_READ_WRITE_ITER */</span>
<a name="l03718"></a>03718         .unlocked_ioctl = ll_file_ioctl,
<a name="l03719"></a>03719         .open           = ll_file_open,
<a name="l03720"></a>03720         .release        = ll_file_release,
<a name="l03721"></a>03721         .mmap           = ll_file_mmap,
<a name="l03722"></a>03722         .llseek         = ll_file_seek,
<a name="l03723"></a>03723         .splice_read    = ll_file_splice_read,
<a name="l03724"></a>03724         .fsync          = ll_fsync,
<a name="l03725"></a>03725         .flush          = ll_flush,
<a name="l03726"></a>03726         .flock          = ll_file_flock,
<a name="l03727"></a>03727         .lock           = ll_file_flock
<a name="l03728"></a>03728 };
<a name="l03729"></a>03729 
<a name="l03730"></a>03730 <span class="comment">/* These are for -o noflock - to return ENOSYS on flock calls */</span>
<a name="l03731"></a>03731 <span class="keyword">struct </span>file_operations ll_file_operations_noflock = {
<a name="l03732"></a>03732 <span class="preprocessor">#ifdef HAVE_FILE_OPERATIONS_READ_WRITE_ITER</span>
<a name="l03733"></a>03733 <span class="preprocessor"></span><span class="preprocessor"># ifdef HAVE_SYNC_READ_WRITE</span>
<a name="l03734"></a>03734 <span class="preprocessor"></span>        .read           = new_sync_read,
<a name="l03735"></a>03735         .write          = new_sync_write,
<a name="l03736"></a>03736 <span class="preprocessor"># endif </span><span class="comment">/* HAVE_SYNC_READ_WRITE */</span>
<a name="l03737"></a>03737         .read_iter      = ll_file_read_iter,
<a name="l03738"></a>03738         .write_iter     = ll_file_write_iter,
<a name="l03739"></a>03739 <span class="preprocessor">#else </span><span class="comment">/* !HAVE_FILE_OPERATIONS_READ_WRITE_ITER */</span>
<a name="l03740"></a>03740         .read           = ll_file_read,
<a name="l03741"></a>03741         .aio_read       = ll_file_aio_read,
<a name="l03742"></a>03742         .write          = ll_file_write,
<a name="l03743"></a>03743         .aio_write      = ll_file_aio_write,
<a name="l03744"></a>03744 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_FILE_OPERATIONS_READ_WRITE_ITER */</span>
<a name="l03745"></a>03745         .unlocked_ioctl = ll_file_ioctl,
<a name="l03746"></a>03746         .open           = ll_file_open,
<a name="l03747"></a>03747         .release        = ll_file_release,
<a name="l03748"></a>03748         .mmap           = ll_file_mmap,
<a name="l03749"></a>03749         .llseek         = ll_file_seek,
<a name="l03750"></a>03750         .splice_read    = ll_file_splice_read,
<a name="l03751"></a>03751         .fsync          = ll_fsync,
<a name="l03752"></a>03752         .flush          = ll_flush,
<a name="l03753"></a>03753         .flock          = ll_file_noflock,
<a name="l03754"></a>03754         .lock           = ll_file_noflock
<a name="l03755"></a>03755 };
<a name="l03756"></a>03756 
<a name="l03757"></a>03757 <span class="keyword">struct </span>inode_operations ll_file_inode_operations = {
<a name="l03758"></a>03758         .setattr        = ll_setattr,
<a name="l03759"></a>03759         .getattr        = ll_getattr,
<a name="l03760"></a>03760         .permission     = ll_inode_permission,
<a name="l03761"></a>03761         .setxattr       = ll_setxattr,
<a name="l03762"></a>03762         .getxattr       = ll_getxattr,
<a name="l03763"></a>03763         .listxattr      = ll_listxattr,
<a name="l03764"></a>03764         .removexattr    = ll_removexattr,
<a name="l03765"></a>03765         .fiemap         = ll_fiemap,
<a name="l03766"></a>03766 <span class="preprocessor">#ifdef HAVE_IOP_GET_ACL</span>
<a name="l03767"></a>03767 <span class="preprocessor"></span>        .get_acl        = ll_get_acl,
<a name="l03768"></a>03768 <span class="preprocessor">#endif</span>
<a name="l03769"></a>03769 <span class="preprocessor"></span>};
<a name="l03770"></a>03770 
<a name="l03771"></a>03771 <span class="comment">/* dynamic ioctl number support routins */</span>
<a name="l03772"></a>03772 <span class="keyword">static</span> <span class="keyword">struct </span>llioc_ctl_data {
<a name="l03773"></a>03773         <span class="keyword">struct </span>rw_semaphore     ioc_sem;
<a name="l03774"></a>03774         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        ioc_head;
<a name="l03775"></a>03775 } llioc = {
<a name="l03776"></a>03776         __RWSEM_INITIALIZER(llioc.ioc_sem),
<a name="l03777"></a>03777         LIST_HEAD_INIT(llioc.ioc_head)
<a name="l03778"></a>03778 };
<a name="l03779"></a>03779 
<a name="l03780"></a>03780 
<a name="l03781"></a>03781 <span class="keyword">struct </span>llioc_data {
<a name="l03782"></a>03782         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        iocd_list;
<a name="l03783"></a>03783         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            iocd_size;
<a name="l03784"></a>03784         llioc_callback_t        iocd_cb;
<a name="l03785"></a>03785         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            iocd_count;
<a name="l03786"></a>03786         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            iocd_cmd[0];
<a name="l03787"></a>03787 };
<a name="l03788"></a>03788 
<a name="l03789"></a>03789 <span class="keywordtype">void</span> *ll_iocontrol_register(llioc_callback_t cb, <span class="keywordtype">int</span> count, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *cmd)
<a name="l03790"></a>03790 {
<a name="l03791"></a>03791         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size;
<a name="l03792"></a>03792         <span class="keyword">struct </span>llioc_data *in_data = NULL;
<a name="l03793"></a>03793         ENTRY;
<a name="l03794"></a>03794 
<a name="l03795"></a>03795         <span class="keywordflow">if</span> (cb == NULL || cmd == NULL ||
<a name="l03796"></a>03796             count &gt; LLIOC_MAX_CMD || count &lt; 0)
<a name="l03797"></a>03797                 RETURN(NULL);
<a name="l03798"></a>03798 
<a name="l03799"></a>03799         size = <span class="keyword">sizeof</span>(*in_data) + count * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int);
<a name="l03800"></a>03800         OBD_ALLOC(in_data, size);
<a name="l03801"></a>03801         <span class="keywordflow">if</span> (in_data == NULL)
<a name="l03802"></a>03802                 RETURN(NULL);
<a name="l03803"></a>03803 
<a name="l03804"></a>03804         memset(in_data, 0, <span class="keyword">sizeof</span>(*in_data));
<a name="l03805"></a>03805         in_data-&gt;iocd_size = size;
<a name="l03806"></a>03806         in_data-&gt;iocd_cb = cb;
<a name="l03807"></a>03807         in_data-&gt;iocd_count = count;
<a name="l03808"></a>03808         memcpy(in_data-&gt;iocd_cmd, cmd, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) * count);
<a name="l03809"></a>03809 
<a name="l03810"></a>03810         down_write(&amp;llioc.ioc_sem);
<a name="l03811"></a>03811         list_add_tail(&amp;in_data-&gt;iocd_list, &amp;llioc.ioc_head);
<a name="l03812"></a>03812         up_write(&amp;llioc.ioc_sem);
<a name="l03813"></a>03813 
<a name="l03814"></a>03814         RETURN(in_data);
<a name="l03815"></a>03815 }
<a name="l03816"></a>03816 
<a name="l03817"></a>03817 <span class="keywordtype">void</span> ll_iocontrol_unregister(<span class="keywordtype">void</span> *magic)
<a name="l03818"></a>03818 {
<a name="l03819"></a>03819         <span class="keyword">struct </span>llioc_data *tmp;
<a name="l03820"></a>03820 
<a name="l03821"></a>03821         <span class="keywordflow">if</span> (magic == NULL)
<a name="l03822"></a>03822                 <span class="keywordflow">return</span>;
<a name="l03823"></a>03823 
<a name="l03824"></a>03824         down_write(&amp;llioc.ioc_sem);
<a name="l03825"></a>03825         list_for_each_entry(tmp, &amp;llioc.ioc_head, iocd_list) {
<a name="l03826"></a>03826                 <span class="keywordflow">if</span> (tmp == magic) {
<a name="l03827"></a>03827                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = tmp-&gt;iocd_size;
<a name="l03828"></a>03828 
<a name="l03829"></a>03829                         list_del(&amp;tmp-&gt;iocd_list);
<a name="l03830"></a>03830                         up_write(&amp;llioc.ioc_sem);
<a name="l03831"></a>03831 
<a name="l03832"></a>03832                         OBD_FREE(tmp, size);
<a name="l03833"></a>03833                         <span class="keywordflow">return</span>;
<a name="l03834"></a>03834                 }
<a name="l03835"></a>03835         }
<a name="l03836"></a>03836         up_write(&amp;llioc.ioc_sem);
<a name="l03837"></a>03837 
<a name="l03838"></a>03838         CWARN(<span class="stringliteral">&quot;didn&apos;t find iocontrol register block with magic: %p\n&quot;</span>, magic);
<a name="l03839"></a>03839 }
<a name="l03840"></a>03840 
<a name="l03841"></a>03841 EXPORT_SYMBOL(ll_iocontrol_register);
<a name="l03842"></a>03842 EXPORT_SYMBOL(ll_iocontrol_unregister);
<a name="l03843"></a>03843 
<a name="l03844"></a>03844 <span class="keyword">static</span> <span class="keyword">enum</span> llioc_iter
<a name="l03845"></a>03845 ll_iocontrol_call(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file,
<a name="l03846"></a>03846                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg, <span class="keywordtype">int</span> *rcp)
<a name="l03847"></a>03847 {
<a name="l03848"></a>03848         <span class="keyword">enum</span> llioc_iter ret = LLIOC_CONT;
<a name="l03849"></a>03849         <span class="keyword">struct </span>llioc_data *data;
<a name="l03850"></a>03850         <span class="keywordtype">int</span> rc = -EINVAL, i;
<a name="l03851"></a>03851 
<a name="l03852"></a>03852         down_read(&amp;llioc.ioc_sem);
<a name="l03853"></a>03853         list_for_each_entry(data, &amp;llioc.ioc_head, iocd_list) {
<a name="l03854"></a>03854                 <span class="keywordflow">for</span> (i = 0; i &lt; data-&gt;iocd_count; i++) {
<a name="l03855"></a>03855                         <span class="keywordflow">if</span> (cmd != data-&gt;iocd_cmd[i])
<a name="l03856"></a>03856                                 <span class="keywordflow">continue</span>;
<a name="l03857"></a>03857 
<a name="l03858"></a>03858                         ret = data-&gt;iocd_cb(inode, file, cmd, arg, data, &amp;rc);
<a name="l03859"></a>03859                         <span class="keywordflow">break</span>;
<a name="l03860"></a>03860                 }
<a name="l03861"></a>03861 
<a name="l03862"></a>03862                 <span class="keywordflow">if</span> (ret == LLIOC_STOP)
<a name="l03863"></a>03863                         <span class="keywordflow">break</span>;
<a name="l03864"></a>03864         }
<a name="l03865"></a>03865         up_read(&amp;llioc.ioc_sem);
<a name="l03866"></a>03866 
<a name="l03867"></a>03867         <span class="keywordflow">if</span> (rcp)
<a name="l03868"></a>03868                 *rcp = rc;
<a name="l03869"></a>03869         <span class="keywordflow">return</span> ret;
<a name="l03870"></a>03870 }
<a name="l03871"></a>03871 
<a name="l03872"></a>03872 <span class="keywordtype">int</span> ll_layout_conf(<span class="keyword">struct</span> inode *inode, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__object__conf.html" title="Description of the client object configuration.">cl_object_conf</a> *conf)
<a name="l03873"></a>03873 {
<a name="l03874"></a>03874         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l03875"></a>03875         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj = lli-&gt;lli_clob;
<a name="l03876"></a>03876         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a> nest;
<a name="l03877"></a>03877         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l03878"></a>03878         <span class="keywordtype">int</span> rc;
<a name="l03879"></a>03879         ENTRY;
<a name="l03880"></a>03880 
<a name="l03881"></a>03881         <span class="keywordflow">if</span> (obj == NULL)
<a name="l03882"></a>03882                 RETURN(0);
<a name="l03883"></a>03883 
<a name="l03884"></a>03884         env = cl_env_nested_get(&amp;nest);
<a name="l03885"></a>03885         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l03886"></a>03886                 RETURN(PTR_ERR(env));
<a name="l03887"></a>03887 
<a name="l03888"></a>03888         rc = <a class="code" href="group__cl__object.html#ga2e572a2e5a92e017e5d45187657e3f94" title="Updates a configuration of an object obj.">cl_conf_set</a>(env, lli-&gt;lli_clob, conf);
<a name="l03889"></a>03889         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03890"></a>03890                 GOTO(out, rc);
<a name="l03891"></a>03891 
<a name="l03892"></a>03892         <span class="keywordflow">if</span> (conf-&gt;<a class="code" href="structcl__object__conf.html#a2a446f25ea361181f94766c0db1031b7" title="Operation to handle layout, OBJECT_CONF_XYZ.">coc_opc</a> == <a class="code" href="group__cl__object.html#gga99fb83031ce9923c84392b4e92f956b5afbab2abc5d277403ef84e9bcd75ee7e5" title="configure layout, set up a new stripe, must be called while holding layout lock.">OBJECT_CONF_SET</a>) {
<a name="l03893"></a>03893                 <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock = conf-&gt;<a class="code" href="structcl__object__conf.html#a69b3a255df05a23ba42c9fe5623349f2" title="Layout lock handle.">coc_lock</a>;
<a name="l03894"></a>03894                 <span class="keyword">struct </span><a class="code" href="structcl__layout.html">cl_layout</a> cl = {
<a name="l03895"></a>03895                         .cl_layout_gen = 0,
<a name="l03896"></a>03896                 };
<a name="l03897"></a>03897 
<a name="l03898"></a>03898                 LASSERT(lock != NULL);
<a name="l03899"></a>03899                 LASSERT(ldlm_has_layout(lock));
<a name="l03900"></a>03900 
<a name="l03901"></a>03901                 <span class="comment">/* it can only be allowed to match after layout is</span>
<a name="l03902"></a>03902 <span class="comment">                 * applied to inode otherwise false layout would be</span>
<a name="l03903"></a>03903 <span class="comment">                 * seen. Applying layout shoud happen before dropping</span>
<a name="l03904"></a>03904 <span class="comment">                 * the intent lock. */</span>
<a name="l03905"></a>03905                 <a class="code" href="group__LDLM.html#ga9e8b401ed51dda94f553670e73872135" title="Mark lock as &amp;quot;matchable&amp;quot; by OST.">ldlm_lock_allow_match</a>(lock);
<a name="l03906"></a>03906 
<a name="l03907"></a>03907                 rc = cl_object_layout_get(env, obj, &amp;cl);
<a name="l03908"></a>03908                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03909"></a>03909                         GOTO(out, rc);
<a name="l03910"></a>03910 
<a name="l03911"></a>03911                 CDEBUG(D_VFSTRACE,
<a name="l03912"></a>03912                        DFID<span class="stringliteral">&quot;: layout version change: %u -&gt; %u\n&quot;</span>,
<a name="l03913"></a>03913                        PFID(&amp;lli-&gt;lli_fid), ll_layout_version_get(lli),
<a name="l03914"></a>03914                        cl.<a class="code" href="structcl__layout.html#ab0968d21c86a319b62cb40bdb9a60518" title="Layout generation.">cl_layout_gen</a>);
<a name="l03915"></a>03915                 ll_layout_version_set(lli, cl.<a class="code" href="structcl__layout.html#ab0968d21c86a319b62cb40bdb9a60518" title="Layout generation.">cl_layout_gen</a>);
<a name="l03916"></a>03916         }
<a name="l03917"></a>03917 
<a name="l03918"></a>03918 out:
<a name="l03919"></a>03919         cl_env_nested_put(&amp;nest, env);
<a name="l03920"></a>03920 
<a name="l03921"></a>03921         RETURN(rc);
<a name="l03922"></a>03922 }
<a name="l03923"></a>03923 
<a name="l03924"></a>03924 <span class="comment">/* Fetch layout from MDT with getxattr request, if it&apos;s not ready yet */</span>
<a name="l03925"></a>03925 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_layout_fetch(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> <a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock)
<a name="l03926"></a>03926 
<a name="l03927"></a>03927 {
<a name="l03928"></a>03928         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a> *sbi = ll_i2sbi(inode);
<a name="l03929"></a>03929         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req;
<a name="l03930"></a>03930         <span class="keyword">struct </span><a class="code" href="structmdt__body.html">mdt_body</a> *body;
<a name="l03931"></a>03931         <span class="keywordtype">void</span> *lvbdata;
<a name="l03932"></a>03932         <span class="keywordtype">void</span> *lmm;
<a name="l03933"></a>03933         <span class="keywordtype">int</span> lmmsize;
<a name="l03934"></a>03934         <span class="keywordtype">int</span> rc;
<a name="l03935"></a>03935         ENTRY;
<a name="l03936"></a>03936 
<a name="l03937"></a>03937         CDEBUG(D_INODE, DFID<span class="stringliteral">&quot; LVB_READY=%d l_lvb_data=%p l_lvb_len=%d\n&quot;</span>,
<a name="l03938"></a>03938                PFID(ll_inode2fid(inode)), ldlm_is_lvb_ready(lock),
<a name="l03939"></a>03939                lock-&gt;l_lvb_data, lock-&gt;<a class="code" href="structldlm__lock.html#af9af59e08968100a683ab5f5d595a495" title="Temporary storage for a LVB received during an enqueue operation.">l_lvb_len</a>);
<a name="l03940"></a>03940 
<a name="l03941"></a>03941         <span class="keywordflow">if</span> (lock-&gt;l_lvb_data != NULL)
<a name="l03942"></a>03942                 RETURN(0);
<a name="l03943"></a>03943 
<a name="l03944"></a>03944         <span class="comment">/* if layout lock was granted right away, the layout is returned</span>
<a name="l03945"></a>03945 <span class="comment">         * within DLM_LVB of dlm reply; otherwise if the lock was ever</span>
<a name="l03946"></a>03946 <span class="comment">         * blocked and then granted via completion ast, we have to fetch</span>
<a name="l03947"></a>03947 <span class="comment">         * layout here. Please note that we can&apos;t use the LVB buffer in</span>
<a name="l03948"></a>03948 <span class="comment">         * completion AST because it doesn&apos;t have a large enough buffer */</span>
<a name="l03949"></a>03949         rc = ll_get_default_mdsize(sbi, &amp;lmmsize);
<a name="l03950"></a>03950         <span class="keywordflow">if</span> (rc == 0)
<a name="l03951"></a>03951                 rc = md_getxattr(sbi-&gt;ll_md_exp, ll_inode2fid(inode),
<a name="l03952"></a>03952                                 OBD_MD_FLXATTR, XATTR_NAME_LOV, NULL, 0,
<a name="l03953"></a>03953                                 lmmsize, 0, &amp;req);
<a name="l03954"></a>03954         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03955"></a>03955                 RETURN(rc);
<a name="l03956"></a>03956 
<a name="l03957"></a>03957         body = <a class="code" href="group__req__layout.html#ga0d1ad53a1914c35470f3916e4bb4b8fe" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC reply buffer...">req_capsule_server_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_MDT_BODY);
<a name="l03958"></a>03958         <span class="keywordflow">if</span> (body == NULL)
<a name="l03959"></a>03959                 GOTO(out, rc = -EPROTO);
<a name="l03960"></a>03960 
<a name="l03961"></a>03961         lmmsize = body-&gt;mbo_eadatasize;
<a name="l03962"></a>03962         <span class="keywordflow">if</span> (lmmsize == 0) <span class="comment">/* empty layout */</span>
<a name="l03963"></a>03963                 GOTO(out, rc = 0);
<a name="l03964"></a>03964 
<a name="l03965"></a>03965         lmm = <a class="code" href="group__req__layout.html#gaebc460299194b773def6ad6960826860" title="Utility that combines req_capsule_set_size() and req_capsule_server_get().">req_capsule_server_sized_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>, &amp;RMF_EADATA, lmmsize);
<a name="l03966"></a>03966         <span class="keywordflow">if</span> (lmm == NULL)
<a name="l03967"></a>03967                 GOTO(out, rc = -EFAULT);
<a name="l03968"></a>03968 
<a name="l03969"></a>03969         OBD_ALLOC_LARGE(lvbdata, lmmsize);
<a name="l03970"></a>03970         <span class="keywordflow">if</span> (lvbdata == NULL)
<a name="l03971"></a>03971                 GOTO(out, rc = -ENOMEM);
<a name="l03972"></a>03972 
<a name="l03973"></a>03973         memcpy(lvbdata, lmm, lmmsize);
<a name="l03974"></a>03974         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l03975"></a>03975         <span class="keywordflow">if</span> (unlikely(lock-&gt;l_lvb_data == NULL)) {
<a name="l03976"></a>03976                 lock-&gt;l_lvb_type = LVB_T_LAYOUT;
<a name="l03977"></a>03977                 lock-&gt;l_lvb_data = lvbdata;
<a name="l03978"></a>03978                 lock-&gt;<a class="code" href="structldlm__lock.html#af9af59e08968100a683ab5f5d595a495" title="Temporary storage for a LVB received during an enqueue operation.">l_lvb_len</a> = lmmsize;
<a name="l03979"></a>03979                 lvbdata = NULL;
<a name="l03980"></a>03980         }
<a name="l03981"></a>03981         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l03982"></a>03982 
<a name="l03983"></a>03983         <span class="keywordflow">if</span> (lvbdata)
<a name="l03984"></a>03984                 OBD_FREE_LARGE(lvbdata, lmmsize);
<a name="l03985"></a>03985 
<a name="l03986"></a>03986         EXIT;
<a name="l03987"></a>03987 
<a name="l03988"></a>03988 out:
<a name="l03989"></a>03989         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l03990"></a>03990         <span class="keywordflow">return</span> rc;
<a name="l03991"></a>03991 }
<a name="l03992"></a>03992 
<a name="l03997"></a>03997 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_layout_lock_set(<span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lockh, <span class="keyword">enum</span> ldlm_mode mode,
<a name="l03998"></a>03998                               <span class="keyword">struct</span> inode *inode)
<a name="l03999"></a>03999 {
<a name="l04000"></a>04000         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a> *lli = ll_i2info(inode);
<a name="l04001"></a>04001         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a>    *sbi = ll_i2sbi(inode);
<a name="l04002"></a>04002         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock;
<a name="l04003"></a>04003         <span class="keyword">struct </span><a class="code" href="structcl__object__conf.html" title="Description of the client object configuration.">cl_object_conf</a> conf;
<a name="l04004"></a>04004         <span class="keywordtype">int</span> rc = 0;
<a name="l04005"></a>04005         <span class="keywordtype">bool</span> lvb_ready;
<a name="l04006"></a>04006         <span class="keywordtype">bool</span> wait_layout = <span class="keyword">false</span>;
<a name="l04007"></a>04007         ENTRY;
<a name="l04008"></a>04008 
<a name="l04009"></a>04009         LASSERT(lustre_handle_is_used(lockh));
<a name="l04010"></a>04010 
<a name="l04011"></a>04011         lock = ldlm_handle2lock(lockh);
<a name="l04012"></a>04012         LASSERT(lock != NULL);
<a name="l04013"></a>04013         LASSERT(ldlm_has_layout(lock));
<a name="l04014"></a>04014 
<a name="l04015"></a>04015         LDLM_DEBUG(lock, <span class="stringliteral">&quot;file &quot;</span>DFID<span class="stringliteral">&quot;(%p) being reconfigured&quot;</span>,
<a name="l04016"></a>04016                    PFID(&amp;lli-&gt;lli_fid), inode);
<a name="l04017"></a>04017 
<a name="l04018"></a>04018         <span class="comment">/* in case this is a caching lock and reinstate with new inode */</span>
<a name="l04019"></a>04019         md_set_lock_data(sbi-&gt;ll_md_exp, &amp;lockh-&gt;cookie, inode, NULL);
<a name="l04020"></a>04020 
<a name="l04021"></a>04021         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l04022"></a>04022         lvb_ready = ldlm_is_lvb_ready(lock);
<a name="l04023"></a>04023         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l04024"></a>04024         <span class="comment">/* checking lvb_ready is racy but this is okay. The worst case is</span>
<a name="l04025"></a>04025 <span class="comment">         * that multi processes may configure the file on the same time. */</span>
<a name="l04026"></a>04026 
<a name="l04027"></a>04027         <span class="keywordflow">if</span> (lvb_ready)
<a name="l04028"></a>04028                 GOTO(out, rc = 0);
<a name="l04029"></a>04029 
<a name="l04030"></a>04030         rc = ll_layout_fetch(inode, lock);
<a name="l04031"></a>04031         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l04032"></a>04032                 GOTO(out, rc);
<a name="l04033"></a>04033 
<a name="l04034"></a>04034         <span class="comment">/* for layout lock, lmm is stored in lock&apos;s lvb.</span>
<a name="l04035"></a>04035 <span class="comment">         * lvb_data is immutable if the lock is held so it&apos;s safe to access it</span>
<a name="l04036"></a>04036 <span class="comment">         * without res lock.</span>
<a name="l04037"></a>04037 <span class="comment">         *</span>
<a name="l04038"></a>04038 <span class="comment">         * set layout to file. Unlikely this will fail as old layout was</span>
<a name="l04039"></a>04039 <span class="comment">         * surely eliminated */</span>
<a name="l04040"></a>04040         memset(&amp;conf, 0, <span class="keyword">sizeof</span> conf);
<a name="l04041"></a>04041         conf.<a class="code" href="structcl__object__conf.html#a2a446f25ea361181f94766c0db1031b7" title="Operation to handle layout, OBJECT_CONF_XYZ.">coc_opc</a> = <a class="code" href="group__cl__object.html#gga99fb83031ce9923c84392b4e92f956b5afbab2abc5d277403ef84e9bcd75ee7e5" title="configure layout, set up a new stripe, must be called while holding layout lock.">OBJECT_CONF_SET</a>;
<a name="l04042"></a>04042         conf.<a class="code" href="structcl__object__conf.html#a4b4c17da427838b3643cec7876583c66" title="VFS inode.">coc_inode</a> = inode;
<a name="l04043"></a>04043         conf.<a class="code" href="structcl__object__conf.html#a69b3a255df05a23ba42c9fe5623349f2" title="Layout lock handle.">coc_lock</a> = lock;
<a name="l04044"></a>04044         conf.u.<a class="code" href="structcl__object__conf.html#a3ec339f59ef4d1a259a02c80d760a814" title="Object layout.">coc_layout</a>.lb_buf = lock-&gt;l_lvb_data;
<a name="l04045"></a>04045         conf.u.<a class="code" href="structcl__object__conf.html#a3ec339f59ef4d1a259a02c80d760a814" title="Object layout.">coc_layout</a>.lb_len = lock-&gt;<a class="code" href="structldlm__lock.html#af9af59e08968100a683ab5f5d595a495" title="Temporary storage for a LVB received during an enqueue operation.">l_lvb_len</a>;
<a name="l04046"></a>04046         rc = ll_layout_conf(inode, &amp;conf);
<a name="l04047"></a>04047 
<a name="l04048"></a>04048         <span class="comment">/* refresh layout failed, need to wait */</span>
<a name="l04049"></a>04049         wait_layout = rc == -EBUSY;
<a name="l04050"></a>04050         EXIT;
<a name="l04051"></a>04051 
<a name="l04052"></a>04052 out:
<a name="l04053"></a>04053         <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l04054"></a>04054         <a class="code" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref</a>(lockh, mode);
<a name="l04055"></a>04055 
<a name="l04056"></a>04056         <span class="comment">/* wait for IO to complete if it&apos;s still being used. */</span>
<a name="l04057"></a>04057         <span class="keywordflow">if</span> (wait_layout) {
<a name="l04058"></a>04058                 CDEBUG(D_INODE, <span class="stringliteral">&quot;%s: &quot;</span>DFID<span class="stringliteral">&quot;(%p) wait for layout reconf\n&quot;</span>,
<a name="l04059"></a>04059                        ll_get_fsname(inode-&gt;i_sb, NULL, 0),
<a name="l04060"></a>04060                        PFID(&amp;lli-&gt;lli_fid), inode);
<a name="l04061"></a>04061 
<a name="l04062"></a>04062                 memset(&amp;conf, 0, <span class="keyword">sizeof</span> conf);
<a name="l04063"></a>04063                 conf.<a class="code" href="structcl__object__conf.html#a2a446f25ea361181f94766c0db1031b7" title="Operation to handle layout, OBJECT_CONF_XYZ.">coc_opc</a> = <a class="code" href="group__cl__object.html#gga99fb83031ce9923c84392b4e92f956b5a916b610eabe05c138a1717820f9a0696" title="wait for old layout to go away so that new layout can be set up.">OBJECT_CONF_WAIT</a>;
<a name="l04064"></a>04064                 conf.<a class="code" href="structcl__object__conf.html#a4b4c17da427838b3643cec7876583c66" title="VFS inode.">coc_inode</a> = inode;
<a name="l04065"></a>04065                 rc = ll_layout_conf(inode, &amp;conf);
<a name="l04066"></a>04066                 <span class="keywordflow">if</span> (rc == 0)
<a name="l04067"></a>04067                         rc = -EAGAIN;
<a name="l04068"></a>04068 
<a name="l04069"></a>04069                 CDEBUG(D_INODE, <span class="stringliteral">&quot;%s file=&quot;</span>DFID<span class="stringliteral">&quot; waiting layout return: %d\n&quot;</span>,
<a name="l04070"></a>04070                        ll_get_fsname(inode-&gt;i_sb, NULL, 0),
<a name="l04071"></a>04071                        PFID(&amp;lli-&gt;lli_fid), rc);
<a name="l04072"></a>04072         }
<a name="l04073"></a>04073         RETURN(rc);
<a name="l04074"></a>04074 }
<a name="l04075"></a>04075 
<a name="l04076"></a>04076 <span class="keyword">static</span> <span class="keywordtype">int</span> ll_layout_refresh_locked(<span class="keyword">struct</span> inode *inode)
<a name="l04077"></a>04077 {
<a name="l04078"></a>04078         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a>  *lli = ll_i2info(inode);
<a name="l04079"></a>04079         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a>     *sbi = ll_i2sbi(inode);
<a name="l04080"></a>04080         <span class="keyword">struct </span><a class="code" href="structmd__op__data.html">md_op_data</a>     *op_data;
<a name="l04081"></a>04081         <span class="keyword">struct </span><a class="code" href="structlookup__intent.html">lookup_intent</a>    it;
<a name="l04082"></a>04082         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    lockh;
<a name="l04083"></a>04083         <span class="keyword">enum</span> ldlm_mode          mode;
<a name="l04084"></a>04084         <span class="keyword">struct </span><a class="code" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters.">ldlm_enqueue_info</a> einfo = {
<a name="l04085"></a>04085                 .ei_type = LDLM_IBITS,
<a name="l04086"></a>04086                 .ei_mode = LCK_CR,
<a name="l04087"></a>04087                 .ei_cb_bl = &amp;ll_md_blocking_ast,
<a name="l04088"></a>04088                 .ei_cb_cp = &amp;<a class="code" href="group__ldlm__local__ast.html#gaae5738d417a8624f65b5418d57fef359" title="Generic LDLM &amp;quot;completion&amp;quot; AST.">ldlm_completion_ast</a>,
<a name="l04089"></a>04089         };
<a name="l04090"></a>04090         <span class="keywordtype">int</span> rc;
<a name="l04091"></a>04091         ENTRY;
<a name="l04092"></a>04092 
<a name="l04093"></a>04093 again:
<a name="l04094"></a>04094         <span class="comment">/* mostly layout lock is caching on the local side, so try to match</span>
<a name="l04095"></a>04095 <span class="comment">         * it before grabbing layout lock mutex. */</span>
<a name="l04096"></a>04096         mode = ll_take_md_lock(inode, MDS_INODELOCK_LAYOUT, &amp;lockh, 0,
<a name="l04097"></a>04097                                LCK_CR | LCK_CW | LCK_PR | LCK_PW);
<a name="l04098"></a>04098         <span class="keywordflow">if</span> (mode != 0) { <span class="comment">/* hit cached lock */</span>
<a name="l04099"></a>04099                 rc = ll_layout_lock_set(&amp;lockh, mode, inode);
<a name="l04100"></a>04100                 <span class="keywordflow">if</span> (rc == -EAGAIN)
<a name="l04101"></a>04101                         <span class="keywordflow">goto</span> again;
<a name="l04102"></a>04102 
<a name="l04103"></a>04103                 RETURN(rc);
<a name="l04104"></a>04104         }
<a name="l04105"></a>04105 
<a name="l04106"></a>04106         op_data = ll_prep_md_op_data(NULL, inode, inode, NULL,
<a name="l04107"></a>04107                                      0, 0, LUSTRE_OPC_ANY, NULL);
<a name="l04108"></a>04108         <span class="keywordflow">if</span> (IS_ERR(op_data))
<a name="l04109"></a>04109                 RETURN(PTR_ERR(op_data));
<a name="l04110"></a>04110 
<a name="l04111"></a>04111         <span class="comment">/* have to enqueue one */</span>
<a name="l04112"></a>04112         memset(&amp;it, 0, <span class="keyword">sizeof</span>(it));
<a name="l04113"></a>04113         it.it_op = IT_LAYOUT;
<a name="l04114"></a>04114         lockh.cookie = 0ULL;
<a name="l04115"></a>04115 
<a name="l04116"></a>04116         <a class="code" href="group__LDLM.html#gae27210c0d51e6f38e3b5f2ff08793f97" title="Just a fancy CDEBUG call with log level preset to LDLM_DEBUG.">LDLM_DEBUG_NOLOCK</a>(<span class="stringliteral">&quot;%s: requeue layout lock for file &quot;</span>DFID<span class="stringliteral">&quot;(%p)&quot;</span>,
<a name="l04117"></a>04117                           ll_get_fsname(inode-&gt;i_sb, NULL, 0),
<a name="l04118"></a>04118                           PFID(&amp;lli-&gt;lli_fid), inode);
<a name="l04119"></a>04119 
<a name="l04120"></a>04120         rc = md_enqueue(sbi-&gt;ll_md_exp, &amp;einfo, NULL, &amp;it, op_data, &amp;lockh, 0);
<a name="l04121"></a>04121         <span class="keywordflow">if</span> (it.it_request != NULL)
<a name="l04122"></a>04122                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(it.it_request);
<a name="l04123"></a>04123         it.it_request = NULL;
<a name="l04124"></a>04124 
<a name="l04125"></a>04125         ll_finish_md_op_data(op_data);
<a name="l04126"></a>04126 
<a name="l04127"></a>04127         mode = it.it_lock_mode;
<a name="l04128"></a>04128         it.it_lock_mode = 0;
<a name="l04129"></a>04129         ll_intent_drop_lock(&amp;it);
<a name="l04130"></a>04130 
<a name="l04131"></a>04131         <span class="keywordflow">if</span> (rc == 0) {
<a name="l04132"></a>04132                 <span class="comment">/* set lock data in case this is a new lock */</span>
<a name="l04133"></a>04133                 ll_set_lock_data(sbi-&gt;ll_md_exp, inode, &amp;it, NULL);
<a name="l04134"></a>04134                 rc = ll_layout_lock_set(&amp;lockh, mode, inode);
<a name="l04135"></a>04135                 <span class="keywordflow">if</span> (rc == -EAGAIN)
<a name="l04136"></a>04136                         <span class="keywordflow">goto</span> again;
<a name="l04137"></a>04137         }
<a name="l04138"></a>04138 
<a name="l04139"></a>04139         RETURN(rc);
<a name="l04140"></a>04140 }
<a name="l04141"></a>04141 
<a name="l04155"></a>04155 <span class="keywordtype">int</span> ll_layout_refresh(<span class="keyword">struct</span> inode *inode, __u32 *gen)
<a name="l04156"></a>04156 {
<a name="l04157"></a>04157         <span class="keyword">struct </span><a class="code" href="structll__inode__info.html">ll_inode_info</a>    *lli = ll_i2info(inode);
<a name="l04158"></a>04158         <span class="keyword">struct </span><a class="code" href="structll__sb__info.html">ll_sb_info</a>       *sbi = ll_i2sbi(inode);
<a name="l04159"></a>04159         <span class="keywordtype">int</span> rc;
<a name="l04160"></a>04160         ENTRY;
<a name="l04161"></a>04161 
<a name="l04162"></a>04162         *gen = ll_layout_version_get(lli);
<a name="l04163"></a>04163         <span class="keywordflow">if</span> (!(sbi-&gt;ll_flags &amp; LL_SBI_LAYOUT_LOCK) || *gen != CL_LAYOUT_GEN_NONE)
<a name="l04164"></a>04164                 RETURN(0);
<a name="l04165"></a>04165 
<a name="l04166"></a>04166         <span class="comment">/* sanity checks */</span>
<a name="l04167"></a>04167         LASSERT(fid_is_sane(ll_inode2fid(inode)));
<a name="l04168"></a>04168         LASSERT(S_ISREG(inode-&gt;i_mode));
<a name="l04169"></a>04169 
<a name="l04170"></a>04170         <span class="comment">/* take layout lock mutex to enqueue layout lock exclusively. */</span>
<a name="l04171"></a>04171         mutex_lock(&amp;lli-&gt;lli_layout_mutex);
<a name="l04172"></a>04172 
<a name="l04173"></a>04173         rc = ll_layout_refresh_locked(inode);
<a name="l04174"></a>04174         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l04175"></a>04175                 GOTO(out, rc);
<a name="l04176"></a>04176 
<a name="l04177"></a>04177         *gen = ll_layout_version_get(lli);
<a name="l04178"></a>04178 out:
<a name="l04179"></a>04179         mutex_unlock(&amp;lli-&gt;lli_layout_mutex);
<a name="l04180"></a>04180 
<a name="l04181"></a>04181         RETURN(rc);
<a name="l04182"></a>04182 }
<a name="l04183"></a>04183 
<a name="l04187"></a>04187 <span class="keywordtype">int</span> ll_layout_restore(<span class="keyword">struct</span> inode *inode, loff_t offset, __u64 length)
<a name="l04188"></a>04188 {
<a name="l04189"></a>04189         <span class="keyword">struct </span><a class="code" href="structhsm__user__request.html">hsm_user_request</a> *hur;
<a name="l04190"></a>04190         <span class="keywordtype">int</span>                      len, rc;
<a name="l04191"></a>04191         ENTRY;
<a name="l04192"></a>04192 
<a name="l04193"></a>04193         len = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structhsm__user__request.html">hsm_user_request</a>) +
<a name="l04194"></a>04194               sizeof(struct <a class="code" href="structhsm__user__item.html">hsm_user_item</a>);
<a name="l04195"></a>04195         OBD_ALLOC(hur, len);
<a name="l04196"></a>04196         <span class="keywordflow">if</span> (hur == NULL)
<a name="l04197"></a>04197                 RETURN(-ENOMEM);
<a name="l04198"></a>04198 
<a name="l04199"></a>04199         hur-&gt;hur_request.hr_action = HUA_RESTORE;
<a name="l04200"></a>04200         hur-&gt;hur_request.hr_archive_id = 0;
<a name="l04201"></a>04201         hur-&gt;hur_request.hr_flags = 0;
<a name="l04202"></a>04202         memcpy(&amp;hur-&gt;hur_user_item[0].hui_fid, &amp;ll_i2info(inode)-&gt;lli_fid,
<a name="l04203"></a>04203                <span class="keyword">sizeof</span>(hur-&gt;hur_user_item[0].hui_fid));
<a name="l04204"></a>04204         hur-&gt;hur_user_item[0].hui_extent.offset = offset;
<a name="l04205"></a>04205         hur-&gt;hur_user_item[0].hui_extent.length = length;
<a name="l04206"></a>04206         hur-&gt;hur_request.hr_itemcount = 1;
<a name="l04207"></a>04207         rc = obd_iocontrol(LL_IOC_HSM_REQUEST, ll_i2sbi(inode)-&gt;ll_md_exp,
<a name="l04208"></a>04208                            len, hur, NULL);
<a name="l04209"></a>04209         OBD_FREE(hur, len);
<a name="l04210"></a>04210         RETURN(rc);
<a name="l04211"></a>04211 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:15 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
