<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: llapi</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>llapi</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllapi__stripe__param.html">llapi_stripe_param</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfind__param.html">find_param</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga25f003de16c08a4888b69f619d70f427"></a><!-- doxytag: member="llapi::ARRAY_SIZE" ref="ga25f003de16c08a4888b69f619d70f427" args="(a)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ARRAY_SIZE</b>(a)&nbsp;&nbsp;&nbsp;((sizeof(a)) / (sizeof((a)[0])))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga98869aa04b7409448e1c5cb3e0ed8b35"></a><!-- doxytag: member="llapi::LLAPI_MSG_MASK" ref="ga98869aa04b7409448e1c5cb3e0ed8b35" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLAPI_MSG_MASK</b>&nbsp;&nbsp;&nbsp;0x00000007</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc58f91da8053599135f6ce840be86cf"></a><!-- doxytag: member="llapi::LLAPI_MSG_NO_ERRNO" ref="gafc58f91da8053599135f6ce840be86cf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LLAPI_MSG_NO_ERRNO</b>&nbsp;&nbsp;&nbsp;0x00000010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadca2260b21d63cb102a3abd921edc5d5"></a><!-- doxytag: member="llapi::llapi_err_noerrno" ref="gadca2260b21d63cb102a3abd921edc5d5" args="(level, fmt, a...)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_err_noerrno</b>(level, fmt, a...)&nbsp;&nbsp;&nbsp;llapi_error((level) | LLAPI_MSG_NO_ERRNO, 0, fmt, ## a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d7cdb94baf8e15f59fe658b7f67ce0a"></a><!-- doxytag: member="llapi::HAVE_LLAPI_FILE_LOOKUP" ref="ga0d7cdb94baf8e15f59fe658b7f67ce0a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>HAVE_LLAPI_FILE_LOOKUP</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85ddb21f601e117c5b2241f8d60dd4ed"></a><!-- doxytag: member="llapi::VERBOSE_COUNT" ref="ga85ddb21f601e117c5b2241f8d60dd4ed" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_COUNT</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6123dd8de16c49e41fd3e844b4d81f60"></a><!-- doxytag: member="llapi::VERBOSE_SIZE" ref="ga6123dd8de16c49e41fd3e844b4d81f60" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_SIZE</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5bc80d7f40d343ff01cd97c73a21ed0d"></a><!-- doxytag: member="llapi::VERBOSE_OFFSET" ref="ga5bc80d7f40d343ff01cd97c73a21ed0d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_OFFSET</b>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4cf7fd49e9f6d4ae0380018df9016127"></a><!-- doxytag: member="llapi::VERBOSE_POOL" ref="ga4cf7fd49e9f6d4ae0380018df9016127" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_POOL</b>&nbsp;&nbsp;&nbsp;0x8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4735fcda00d9a9e0a38d3c39e28f9378"></a><!-- doxytag: member="llapi::VERBOSE_DETAIL" ref="ga4735fcda00d9a9e0a38d3c39e28f9378" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_DETAIL</b>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9e06734ee293cae820211083d5262e98"></a><!-- doxytag: member="llapi::VERBOSE_OBJID" ref="ga9e06734ee293cae820211083d5262e98" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_OBJID</b>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga637750f5cd8ff16bdc2b9191ae562b73"></a><!-- doxytag: member="llapi::VERBOSE_GENERATION" ref="ga637750f5cd8ff16bdc2b9191ae562b73" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_GENERATION</b>&nbsp;&nbsp;&nbsp;0x40</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2cfc368ed6b0ac8764ed7aeed89df2ad"></a><!-- doxytag: member="llapi::VERBOSE_MDTINDEX" ref="ga2cfc368ed6b0ac8764ed7aeed89df2ad" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_MDTINDEX</b>&nbsp;&nbsp;&nbsp;0x80</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69c59929cfba3d9179f094ec08c32934"></a><!-- doxytag: member="llapi::VERBOSE_LAYOUT" ref="ga69c59929cfba3d9179f094ec08c32934" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_LAYOUT</b>&nbsp;&nbsp;&nbsp;0x100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERBOSE_ALL</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7858313d505ffbe0e22d7323c2e28286"></a><!-- doxytag: member="llapi::HAVE_LLAPI_IS_LUSTRE_MNT" ref="ga7858313d505ffbe0e22d7323c2e28286" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>HAVE_LLAPI_IS_LUSTRE_MNT</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae6c86b6a39bbe606e12689554d00c18"></a><!-- doxytag: member="llapi::HAVE_CHANGELOG_EXTEND_REC" ref="gaae6c86b6a39bbe606e12689554d00c18" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>HAVE_CHANGELOG_EXTEND_REC</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad263ffb1750f15fd2f683c3066825522"></a><!-- doxytag: member="llapi::llapi_cb_t" ref="gad263ffb1750f15fd2f683c3066825522" args=")(char *obd_type_name, char *obd_name, char *obd_uuid, void *args)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_cb_t</b> )(char *obd_type_name, char *obd_name, char *<a class="el" href="structobd__uuid.html">obd_uuid</a>, void *args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac0308ef91064adec82c1085bfc404158"></a><!-- doxytag: member="llapi::llapi_log_callback_t" ref="gac0308ef91064adec82c1085bfc404158" args=")(enum llapi_message_level level, int err, const char *fmt, va_list ap)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_log_callback_t</b> )(enum llapi_message_level level, int err, const char *fmt, va_list ap)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_message_level</b> { <br/>
&nbsp;&nbsp;<b>LLAPI_MSG_OFF</b> =  0, 
<b>LLAPI_MSG_FATAL</b> =  1, 
<b>LLAPI_MSG_ERROR</b> =  2, 
<b>LLAPI_MSG_WARN</b> =  3, 
<br/>
&nbsp;&nbsp;<b>LLAPI_MSG_NORMAL</b> =  4, 
<b>LLAPI_MSG_INFO</b> =  5, 
<b>LLAPI_MSG_DEBUG</b> =  6, 
<b>LLAPI_MSG_MAX</b>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga855b585cacedf642b76b5506d4d067b3"></a><!-- doxytag: member="llapi::llapi_msg_set_level" ref="ga855b585cacedf642b76b5506d4d067b3" args="(int level)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_msg_set_level</b> (int level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05a9b288d8fd4bd49eac3fbcf33f5e82"></a><!-- doxytag: member="llapi::llapi_msg_get_level" ref="ga05a9b288d8fd4bd49eac3fbcf33f5e82" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_msg_get_level</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llapi_log_callback_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga8db697eb702075e7bd1b7a3eee23dae8">llapi_error_callback_set</a> (llapi_log_callback_t cb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a custom error logging function.  <a href="#ga8db697eb702075e7bd1b7a3eee23dae8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llapi_log_callback_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gaa794f0f94fc56b7d5ded3b97ad8f966c">llapi_info_callback_set</a> (llapi_log_callback_t cb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a custom info logging function.  <a href="#gaa794f0f94fc56b7d5ded3b97ad8f966c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga315938c57a626bde7a668f860d211ea0"></a><!-- doxytag: member="llapi::llapi_error" ref="ga315938c57a626bde7a668f860d211ea0" args="(enum llapi_message_level level, int err, const char *fmt,...) __attribute__((__format__(__printf__" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_error</b> (enum llapi_message_level level, int err, const char *fmt,...) __attribute__((__format__(__printf__</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga004859c04c7a3ee35ffd90ef227c2db4"></a><!-- doxytag: member="llapi::llapi_printf" ref="ga004859c04c7a3ee35ffd90ef227c2db4" args="(enum llapi_message_level level, const char *fmt,...) __attribute__((__format__(__printf__" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_printf</b> (enum llapi_message_level level, const char *fmt,...) __attribute__((__format__(__printf__</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gac3a99b881313d663dbf6babea2b8202c">llapi_file_open_param</a> (const char *name, int flags, mode_t mode, const struct <a class="el" href="structllapi__stripe__param.html">llapi_stripe_param</a> *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a Lustre file.  <a href="#gac3a99b881313d663dbf6babea2b8202c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga42d548524b99dad00a7c254655c10aea"></a><!-- doxytag: member="llapi::llapi_file_create" ref="ga42d548524b99dad00a7c254655c10aea" args="(const char *name, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_create</b> (const char *name, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ab2dca0e709fbbdff900f0abbd5baf9"></a><!-- doxytag: member="llapi::llapi_file_open" ref="ga4ab2dca0e709fbbdff900f0abbd5baf9" args="(const char *name, int flags, int mode, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_open</b> (const char *name, int flags, int mode, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaafec67dde5ee10e6994c71a4b8ee0689"></a><!-- doxytag: member="llapi::llapi_file_create_pool" ref="gaafec67dde5ee10e6994c71a4b8ee0689" args="(const char *name, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern, char *pool_name)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_create_pool</b> (const char *name, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern, char *pool_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f844f3e56759b6e2b626ce40979bf97"></a><!-- doxytag: member="llapi::llapi_file_open_pool" ref="ga9f844f3e56759b6e2b626ce40979bf97" args="(const char *name, int flags, int mode, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern, char *pool_name)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_open_pool</b> (const char *name, int flags, int mode, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern, char *pool_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d336359b969db810c58915215ef4ed4"></a><!-- doxytag: member="llapi::llapi_poollist" ref="ga0d336359b969db810c58915215ef4ed4" args="(const char *name)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_poollist</b> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga65ff2acbd45636796734faad3f8afc81">llapi_get_poollist</a> (const char *name, char **poollist, int list_size, char *buffer, int buffer_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of pools in a filesystem.  <a href="#ga65ff2acbd45636796734faad3f8afc81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gaa3e9bdb0dfe48d7ed11d10630b34f3fe">llapi_get_poolmembers</a> (const char *poolname, char **members, int list_size, char *buffer, int buffer_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of pool members.  <a href="#gaa3e9bdb0dfe48d7ed11d10630b34f3fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga87ce9ea36dfde2cd79c301ba00060bf8"></a><!-- doxytag: member="llapi::llapi_file_get_stripe" ref="ga87ce9ea36dfde2cd79c301ba00060bf8" args="(const char *path, struct lov_user_md *lum)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_get_stripe</b> (const char *path, struct lov_user_md *lum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae4ad6feea87f82f02700db53577fb168"></a><!-- doxytag: member="llapi::llapi_file_lookup" ref="gae4ad6feea87f82f02700db53577fb168" args="(int dirfd, const char *name)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_lookup</b> (int dirfd, const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabdfc54de2e3950921e487cfe56649926"></a><!-- doxytag: member="llapi::llapi_ostlist" ref="gabdfc54de2e3950921e487cfe56649926" args="(char *path, struct find_param *param)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_ostlist</b> (char *path, struct <a class="el" href="structfind__param.html">find_param</a> *param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae37b5f3934f11d4c267b4594bc5096e2"></a><!-- doxytag: member="llapi::llapi_uuid_match" ref="gae37b5f3934f11d4c267b4594bc5096e2" args="(char *real_uuid, char *search_uuid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_uuid_match</b> (char *real_uuid, char *search_uuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga62bd783920582bf19cbef1f6057482a1"></a><!-- doxytag: member="llapi::llapi_getstripe" ref="ga62bd783920582bf19cbef1f6057482a1" args="(char *path, struct find_param *param)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_getstripe</b> (char *path, struct <a class="el" href="structfind__param.html">find_param</a> *param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf27c1220f2f93f05fdde74531a7e473a"></a><!-- doxytag: member="llapi::llapi_find" ref="gaf27c1220f2f93f05fdde74531a7e473a" args="(char *path, struct find_param *param)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_find</b> (char *path, struct <a class="el" href="structfind__param.html">find_param</a> *param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1de394c7bd29ac5fbcaf8f9d7316848d"></a><!-- doxytag: member="llapi::llapi_file_fget_mdtidx" ref="ga1de394c7bd29ac5fbcaf8f9d7316848d" args="(int fd, int *mdtidx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_fget_mdtidx</b> (int fd, int *mdtidx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga123be2d7352befd56cb48dd96024a88f"></a><!-- doxytag: member="llapi::llapi_dir_set_default_lmv_stripe" ref="ga123be2d7352befd56cb48dd96024a88f" args="(const char *name, int stripe_offset, int stripe_count, int stripe_pattern, const char *pool_name)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_dir_set_default_lmv_stripe</b> (const char *name, int stripe_offset, int stripe_count, int stripe_pattern, const char *pool_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaab31d5486f7cc0806555873750ce37c3"></a><!-- doxytag: member="llapi::llapi_dir_create_pool" ref="gaab31d5486f7cc0806555873750ce37c3" args="(const char *name, int flags, int stripe_offset, int stripe_count, int stripe_pattern, const char *poolname)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_dir_create_pool</b> (const char *name, int flags, int stripe_offset, int stripe_count, int stripe_pattern, const char *poolname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee88e211d19a83239500890dc2566160"></a><!-- doxytag: member="llapi::llapi_direntry_remove" ref="gaee88e211d19a83239500890dc2566160" args="(char *dname)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_direntry_remove</b> (char *dname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafbedc10fd7f98509049df62b9ce42802"></a><!-- doxytag: member="llapi::llapi_obd_statfs" ref="gafbedc10fd7f98509049df62b9ce42802" args="(char *path, __u32 type, __u32 index, struct obd_statfs *stat_buf, struct obd_uuid *uuid_buf)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_obd_statfs</b> (char *path, __u32 type, __u32 index, struct <a class="el" href="structobd__statfs.html">obd_statfs</a> *stat_buf, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuid_buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66a04fbf7157e1b6a049c040101176b5"></a><!-- doxytag: member="llapi::llapi_ping" ref="ga66a04fbf7157e1b6a049c040101176b5" args="(char *obd_type, char *obd_name)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_ping</b> (char *<a class="el" href="structobd__type.html">obd_type</a>, char *obd_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f838de5f04d010bd34ec4e1f262767a"></a><!-- doxytag: member="llapi::llapi_target_check" ref="ga8f838de5f04d010bd34ec4e1f262767a" args="(int num_types, char **obd_types, char *dir)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_target_check</b> (int num_types, char **obd_types, char *dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad06a5f4c8be1f3d08252b5494accbfdb"></a><!-- doxytag: member="llapi::llapi_file_get_lov_uuid" ref="gad06a5f4c8be1f3d08252b5494accbfdb" args="(const char *path, struct obd_uuid *lov_uuid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_get_lov_uuid</b> (const char *path, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *lov_uuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5317c62998e8f6909c3e8adac1bbe696"></a><!-- doxytag: member="llapi::llapi_file_get_lmv_uuid" ref="ga5317c62998e8f6909c3e8adac1bbe696" args="(const char *path, struct obd_uuid *lmv_uuid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_get_lmv_uuid</b> (const char *path, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *lmv_uuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf08b86b2792afa9ba93b678ed1e53ae"></a><!-- doxytag: member="llapi::llapi_file_fget_lov_uuid" ref="gadf08b86b2792afa9ba93b678ed1e53ae" args="(int fd, struct obd_uuid *lov_uuid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_file_fget_lov_uuid</b> (int fd, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *lov_uuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a23f9ab3ab755b0a8004c74b607519c"></a><!-- doxytag: member="llapi::llapi_lov_get_uuids" ref="ga4a23f9ab3ab755b0a8004c74b607519c" args="(int fd, struct obd_uuid *uuidp, int *ost_count)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_lov_get_uuids</b> (int fd, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuidp, int *ost_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5adb0dd829f136997de97d0db8a7db4"></a><!-- doxytag: member="llapi::llapi_lmv_get_uuids" ref="gad5adb0dd829f136997de97d0db8a7db4" args="(int fd, struct obd_uuid *uuidp, int *mdt_count)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_lmv_get_uuids</b> (int fd, struct <a class="el" href="structobd__uuid.html">obd_uuid</a> *uuidp, int *mdt_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9a566e1bd6bfe4b7281f629813ed706"></a><!-- doxytag: member="llapi::llapi_is_lustre_mnttype" ref="gad9a566e1bd6bfe4b7281f629813ed706" args="(const char *type)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_is_lustre_mnttype</b> (const char *type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga17ffa4b669a8b368f002d28fda4b16d3"></a><!-- doxytag: member="llapi::llapi_search_ost" ref="ga17ffa4b669a8b368f002d28fda4b16d3" args="(char *fsname, char *poolname, char *ostname)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_search_ost</b> (char *fsname, char *poolname, char *ostname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd3005be8753655ceb746328b620b716"></a><!-- doxytag: member="llapi::llapi_get_obd_count" ref="gadd3005be8753655ceb746328b620b716" args="(char *mnt, int *count, int is_mdt)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_get_obd_count</b> (char *mnt, int *count, int is_mdt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga94c34eb3d77f1512eada7264bc8ee659"></a><!-- doxytag: member="llapi::llapi_parse_size" ref="ga94c34eb3d77f1512eada7264bc8ee659" args="(const char *optarg, unsigned long long *size, unsigned long long *size_units, int bytes_spec)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga94c34eb3d77f1512eada7264bc8ee659">llapi_parse_size</a> (const char *optarg, unsigned long long *size, unsigned long long *size_units, int bytes_spec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">size_units is to be initialized (or zeroed) by caller. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38febe08e228a854926ed95068b9d629"></a><!-- doxytag: member="llapi::llapi_search_mounts" ref="ga38febe08e228a854926ed95068b9d629" args="(const char *pathname, int index, char *mntdir, char *fsname)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_search_mounts</b> (const char *pathname, int index, char *mntdir, char *fsname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae92b583ed1e09e4afcb845fa4997add7"></a><!-- doxytag: member="llapi::llapi_search_fsname" ref="gae92b583ed1e09e4afcb845fa4997add7" args="(const char *pathname, char *fsname)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_search_fsname</b> (const char *pathname, char *fsname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga53161182aeef981851b8990c73be2ae2"></a><!-- doxytag: member="llapi::llapi_getname" ref="ga53161182aeef981851b8990c73be2ae2" args="(const char *path, char *buf, size_t size)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_getname</b> (const char *path, char *buf, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad38166c43d4bc530bfdd80e5115660ae"></a><!-- doxytag: member="llapi::llapi_search_fileset" ref="gad38166c43d4bc530bfdd80e5115660ae" args="(const char *pathname, char *fileset)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_search_fileset</b> (const char *pathname, char *fileset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27cde37fa53d0cf1fb9589509330fb2c"></a><!-- doxytag: member="llapi::llapi_search_rootpath" ref="ga27cde37fa53d0cf1fb9589509330fb2c" args="(char *pathname, const char *fsname)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_search_rootpath</b> (char *pathname, const char *fsname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c523ab63e009cc65fcf973d7a1c7149"></a><!-- doxytag: member="llapi::llapi_nodemap_exists" ref="ga4c523ab63e009cc65fcf973d7a1c7149" args="(const char *name)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_nodemap_exists</b> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gade985f0cd753f1460c929dbe41e47728"></a><!-- doxytag: member="llapi::llapi_migrate_mdt" ref="gade985f0cd753f1460c929dbe41e47728" args="(char *path, struct find_param *param)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_migrate_mdt</b> (char *path, struct <a class="el" href="structfind__param.html">find_param</a> *param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f6eb116de57b4cf9c4130dee95c9025"></a><!-- doxytag: member="llapi::llapi_mv" ref="ga8f6eb116de57b4cf9c4130dee95c9025" args="(char *path, struct find_param *param)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_mv</b> (char *path, struct <a class="el" href="structfind__param.html">find_param</a> *param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2979b78b928692e5fe7f926a8f40da2"></a><!-- doxytag: member="llapi::llapi_is_lustre_mnt" ref="gaa2979b78b928692e5fe7f926a8f40da2" args="(struct mntent *mnt)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_is_lustre_mnt</b> (struct mntent *mnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae20aedb4e8d8076b29aa459f3bf55fc2"></a><!-- doxytag: member="llapi::llapi_quotactl" ref="gae20aedb4e8d8076b29aa459f3bf55fc2" args="(char *mnt, struct if_quotactl *qctl)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_quotactl</b> (char *mnt, struct <a class="el" href="structif__quotactl.html">if_quotactl</a> *qctl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga99e60f4daf6b482c97a4aca29e723826"></a><!-- doxytag: member="llapi::llapi_target_iterate" ref="ga99e60f4daf6b482c97a4aca29e723826" args="(int type_num, char **obd_type, void *args, llapi_cb_t cb)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_target_iterate</b> (int type_num, char **<a class="el" href="structobd__type.html">obd_type</a>, void *args, llapi_cb_t cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a2413516b119ad449c18e5c7f26692e"></a><!-- doxytag: member="llapi::llapi_get_connect_flags" ref="ga6a2413516b119ad449c18e5c7f26692e" args="(const char *mnt, __u64 *flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_get_connect_flags</b> (const char *mnt, __u64 *flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga964474284fdaa73f643cc200c90cfe39"></a><!-- doxytag: member="llapi::llapi_lsetfacl" ref="ga964474284fdaa73f643cc200c90cfe39" args="(int argc, char *argv[])" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_lsetfacl</b> (int argc, char *argv[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga408268dc213693f1495ca66f5555b520"></a><!-- doxytag: member="llapi::llapi_lgetfacl" ref="ga408268dc213693f1495ca66f5555b520" args="(int argc, char *argv[])" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_lgetfacl</b> (int argc, char *argv[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9543334db265f2df4e8cabbd11241749"></a><!-- doxytag: member="llapi::llapi_rsetfacl" ref="ga9543334db265f2df4e8cabbd11241749" args="(int argc, char *argv[])" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_rsetfacl</b> (int argc, char *argv[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c75172424e7eb978a7759eaf9922ecd"></a><!-- doxytag: member="llapi::llapi_rgetfacl" ref="ga0c75172424e7eb978a7759eaf9922ecd" args="(int argc, char *argv[])" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_rgetfacl</b> (int argc, char *argv[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5811f65be12ab456f75c0cb895c433b"></a><!-- doxytag: member="llapi::llapi_cp" ref="gac5811f65be12ab456f75c0cb895c433b" args="(int argc, char *argv[])" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_cp</b> (int argc, char *argv[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad0931e23f305efcfd66a7f3a158922b2"></a><!-- doxytag: member="llapi::llapi_ls" ref="gad0931e23f305efcfd66a7f3a158922b2" args="(int argc, char *argv[])" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_ls</b> (int argc, char *argv[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa4aed3d5f28ecdf2f9249590c10d6831"></a><!-- doxytag: member="llapi::llapi_fid2path" ref="gaa4aed3d5f28ecdf2f9249590c10d6831" args="(const char *device, const char *fidstr, char *path, int pathlen, long long *recno, int *linkno)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_fid2path</b> (const char *device, const char *fidstr, char *path, int pathlen, long long *recno, int *linkno)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf01f7e0bb55475960f42e34de20cbbee"></a><!-- doxytag: member="llapi::llapi_path2fid" ref="gaf01f7e0bb55475960f42e34de20cbbee" args="(const char *path, lustre_fid *fid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_path2fid</b> (const char *path, <a class="el" href="structlu__fid.html">lustre_fid</a> *fid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc35a9d35e0f9cc1d204454129eae5df"></a><!-- doxytag: member="llapi::llapi_get_mdt_index_by_fid" ref="gafc35a9d35e0f9cc1d204454129eae5df" args="(int fd, const lustre_fid *fid, int *mdt_index)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_get_mdt_index_by_fid</b> (int fd, const <a class="el" href="structlu__fid.html">lustre_fid</a> *fid, int *mdt_index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaef932c01e7dd7d0c159a8fa69bd9931a"></a><!-- doxytag: member="llapi::llapi_fd2fid" ref="gaef932c01e7dd7d0c159a8fa69bd9931a" args="(const int fd, lustre_fid *fid)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_fd2fid</b> (const int fd, <a class="el" href="structlu__fid.html">lustre_fid</a> *fid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae56156ca5bc6543ed15c87ccbd3ba985"></a><!-- doxytag: member="llapi::llapi_path2parent" ref="gae56156ca5bc6543ed15c87ccbd3ba985" args="(const char *path, unsigned int linkno, lustre_fid *parent_fid, char *name, size_t name_size)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_path2parent</b> (const char *path, unsigned int linkno, <a class="el" href="structlu__fid.html">lustre_fid</a> *parent_fid, char *name, size_t name_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8ac07693bb06a6c5cde60be90ad999b5"></a><!-- doxytag: member="llapi::llapi_fd2parent" ref="ga8ac07693bb06a6c5cde60be90ad999b5" args="(int fd, unsigned int linkno, lustre_fid *parent_fid, char *name, size_t name_size)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_fd2parent</b> (int fd, unsigned int linkno, <a class="el" href="structlu__fid.html">lustre_fid</a> *parent_fid, char *name, size_t name_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc10619c76e4c99aaabb01d1f762acee"></a><!-- doxytag: member="llapi::llapi_chomp_string" ref="gafc10619c76e4c99aaabb01d1f762acee" args="(char *buf)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_chomp_string</b> (char *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga3ff3a2f29406fd45315a6ef7fc084bf0">llapi_open_by_fid</a> (const char *dir, const <a class="el" href="structlu__fid.html">lustre_fid</a> *fid, int open_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to open a file with Lustre file identifier <em>fid</em> and return an open file descriptor.  <a href="#ga3ff3a2f29406fd45315a6ef7fc084bf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92c323d16597dd7ee4bd14070468021c"></a><!-- doxytag: member="llapi::llapi_get_version" ref="ga92c323d16597dd7ee4bd14070468021c" args="(char *buffer, int buffer_size, char **version)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_get_version</b> (char *buffer, int buffer_size, char **version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga9e9e67e755fe3a7d4db8f3fe2ceb89d0">llapi_get_data_version</a> (int fd, __u64 *data_version, __u64 flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a 64-bit value representing the version of file data pointed by fd.  <a href="#ga9e9e67e755fe3a7d4db8f3fe2ceb89d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gae27f3f88ec0e797b2c1a7df9d029b2a7">llapi_hsm_state_get_fd</a> (int fd, struct <a class="el" href="structhsm__user__state.html">hsm_user_state</a> *hus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current HSM states and HSM requests related to file pointed by <em>path</em>.  <a href="#gae27f3f88ec0e797b2c1a7df9d029b2a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga625517cdce6cc479801e10f24fe80bcb">llapi_hsm_state_get</a> (const char *path, struct <a class="el" href="structhsm__user__state.html">hsm_user_state</a> *hus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current HSM states and HSM requests related to file pointed by <em>path</em>.  <a href="#ga625517cdce6cc479801e10f24fe80bcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gaa69acaf39672b0964307795fac1f19db">llapi_hsm_state_set_fd</a> (int fd, __u64 setmask, __u64 clearmask, __u32 archive_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set HSM states of file pointed by <em>fd</em>.  <a href="#gaa69acaf39672b0964307795fac1f19db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga255ceef5caae75d4aee04f646bd71685">llapi_hsm_state_set</a> (const char *path, __u64 setmask, __u64 clearmask, __u32 archive_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set HSM states of file pointed by <em>path</em>.  <a href="#ga255ceef5caae75d4aee04f646bd71685"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga89cbac22a82ac6a421bb2aab980c1c3e">llapi_hsm_register_event_fifo</a> (const char *path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a path to a FIFO, create a filehandle for nonblocking writes to it.  <a href="#ga89cbac22a82ac6a421bb2aab980c1c3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gac7e96e99dacac05914034918fc2114b8">llapi_hsm_unregister_event_fifo</a> (const char *path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a path to a FIFO, close its filehandle and delete the FIFO.  <a href="#gac7e96e99dacac05914034918fc2114b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gac7cd8c58323ebb952e44bc3864a680f3">llapi_hsm_log_error</a> (enum llapi_message_level level, int _rc, const char *fmt, va_list args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Custom logging callback to be used when a monitoring FIFO has been registered.  <a href="#gac7cd8c58323ebb952e44bc3864a680f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga23022d8f82017891f4e69058e90129d7"></a><!-- doxytag: member="llapi::llapi_get_agent_uuid" ref="ga23022d8f82017891f4e69058e90129d7" args="(char *path, char *buf, size_t bufsize)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_get_agent_uuid</b> (char *path, char *buf, size_t bufsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb2157ad4b316a8ae7cf5f715c7eaf07"></a><!-- doxytag: member="llapi::llapi_create_volatile_idx" ref="gadb2157ad4b316a8ae7cf5f715c7eaf07" args="(char *directory, int idx, int mode)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_create_volatile_idx</b> (char *directory, int idx, int mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3789884eb6c61dd49e497ef5ce253ad5"></a><!-- doxytag: member="llapi::llapi_fswap_layouts_grouplock" ref="ga3789884eb6c61dd49e497ef5ce253ad5" args="(int fd1, int fd2, __u64 dv1, __u64 dv2, int gid, __u64 flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga3789884eb6c61dd49e497ef5ce253ad5">llapi_fswap_layouts_grouplock</a> (int fd1, int fd2, __u64 dv1, __u64 dv2, int gid, __u64 flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the layouts between 2 file descriptors the 2 files must be open for writing first fd received the ioctl, second fd is passed as arg this is assymetric but avoid use of root path for ioctl. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1253e1e81e3c37adc3f378007e80670c"></a><!-- doxytag: member="llapi::llapi_fswap_layouts" ref="ga1253e1e81e3c37adc3f378007e80670c" args="(int fd1, int fd2, __u64 dv1, __u64 dv2, __u64 flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_fswap_layouts</b> (int fd1, int fd2, __u64 dv1, __u64 dv2, __u64 flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga19efa4a2d79f761aee59ef5e01b15630"></a><!-- doxytag: member="llapi::llapi_swap_layouts" ref="ga19efa4a2d79f761aee59ef5e01b15630" args="(const char *path1, const char *path2, __u64 dv1, __u64 dv2, __u64 flags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga19efa4a2d79f761aee59ef5e01b15630">llapi_swap_layouts</a> (const char *path1, const char *path2, __u64 dv1, __u64 dv2, __u64 flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the layouts between 2 files the 2 files are open in write. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga73d536a65aab56fbc37cb4386460b120">llapi_changelog_start</a> (void **priv, enum changelog_send_flag flags, const char *mdtname, long long startrec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start reading from a changelog.  <a href="#ga73d536a65aab56fbc37cb4386460b120"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ee5507d6f2787dccb55b10cafddd05c"></a><!-- doxytag: member="llapi::llapi_changelog_fini" ref="ga1ee5507d6f2787dccb55b10cafddd05c" args="(void **priv)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga1ee5507d6f2787dccb55b10cafddd05c">llapi_changelog_fini</a> (void **priv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish reading from a changelog. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga926025458d520539c08b875a2b195624"></a><!-- doxytag: member="llapi::llapi_changelog_recv" ref="ga926025458d520539c08b875a2b195624" args="(void *priv, struct changelog_rec **rech)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_changelog_recv</b> (void *priv, struct <a class="el" href="structchangelog__rec.html">changelog_rec</a> **rech)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gaecd4f83399ed073c6c02237bdbeab5f4">llapi_changelog_free</a> (struct <a class="el" href="structchangelog__rec.html">changelog_rec</a> **rech)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the changelog record when done with it.  <a href="#gaecd4f83399ed073c6c02237bdbeab5f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b608ef896bc4b7c4b7037bfea72e949"></a><!-- doxytag: member="llapi::llapi_changelog_clear" ref="ga1b608ef896bc4b7c4b7037bfea72e949" args="(const char *mdtname, const char *idstr, long long endrec)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_changelog_clear</b> (const char *mdtname, const char *idstr, long long endrec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga56090f57d464ed01de0443ca66f39d18">llapi_hsm_copytool_register</a> (struct hsm_copytool_private **priv, const char *mnt, int archive_count, int *archives, int rfd_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a copytool.  <a href="#ga56090f57d464ed01de0443ca66f39d18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58f3918326074b092e6390939f79568a"></a><!-- doxytag: member="llapi::llapi_hsm_copytool_unregister" ref="ga58f3918326074b092e6390939f79568a" args="(struct hsm_copytool_private **priv)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga58f3918326074b092e6390939f79568a">llapi_hsm_copytool_unregister</a> (struct hsm_copytool_private **priv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister a copytool Note: under Linux, until llapi_hsm_copytool_unregister is called (or the program is killed), the libcfs module will be referenced and unremovable, even after Lustre services stop. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga694b0437493484e145b1713c7a1bb9cd">llapi_hsm_copytool_get_fd</a> (struct hsm_copytool_private *ct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a file descriptor to poll/select on.  <a href="#ga694b0437493484e145b1713c7a1bb9cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gad18af809c2dda475e759db9e2b066418">llapi_hsm_copytool_recv</a> (struct hsm_copytool_private *priv, struct <a class="el" href="structhsm__action__list.html">hsm_action_list</a> **hal, int *msgsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the next <a class="el" href="structhsm__action__list.html">hsm_action_list</a>.  <a href="#gad18af809c2dda475e759db9e2b066418"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gac3922a41eae3a32dc48ccf33f9c3d4ac">llapi_hsm_action_begin</a> (struct hsm_copyaction_private **phcp, const struct hsm_copytool_private *ct, const struct <a class="el" href="structhsm__action__item.html">hsm_action_item</a> *hai, int restore_mdt_index, int restore_open_flags, bool is_error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start processing an HSM action.  <a href="#gac3922a41eae3a32dc48ccf33f9c3d4ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gaea52ba36ba47870c0f8e6586b3d48ecc">llapi_hsm_action_end</a> (struct hsm_copyaction_private **phcp, const struct <a class="el" href="structhsm__extent.html">hsm_extent</a> *he, int hp_flags, int errval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate an HSM action processing.  <a href="#gaea52ba36ba47870c0f8e6586b3d48ecc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga5cc2899f0dbc4a8ec90d6bd0b9b6fe17">llapi_hsm_action_progress</a> (struct hsm_copyaction_private *hcp, const struct <a class="el" href="structhsm__extent.html">hsm_extent</a> *he, __u64 total, int hp_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify a progress in processing an HSM action.  <a href="#ga5cc2899f0dbc4a8ec90d6bd0b9b6fe17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga4ca1f4f67749a9a11d48ea661f8ec2f8">llapi_hsm_action_get_dfid</a> (const struct hsm_copyaction_private *hcp, <a class="el" href="structlu__fid.html">lustre_fid</a> *fid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the fid of object to be used for copying data.  <a href="#ga4ca1f4f67749a9a11d48ea661f8ec2f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gaba84da0225c8950975c3ad76aa402abd">llapi_hsm_action_get_fd</a> (const struct hsm_copyaction_private *hcp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a file descriptor to be used for copying data.  <a href="#gaba84da0225c8950975c3ad76aa402abd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga42de7c318652c45b7b86df855b6dd201">llapi_hsm_import</a> (const char *dst, int archive, const struct stat *st, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern, char *pool_name, <a class="el" href="structlu__fid.html">lustre_fid</a> *newfid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Import an existing hsm-archived file into Lustre.  <a href="#ga42de7c318652c45b7b86df855b6dd201"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structhsm__user__request.html">hsm_user_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gae20de186e5b139de98e0a772517676b4">llapi_hsm_user_request_alloc</a> (int itemcount, int data_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a <a class="el" href="structhsm__user__request.html">hsm_user_request</a> with the specified carateristics.  <a href="#gae20de186e5b139de98e0a772517676b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gaad5620c10129544e26bb083f32d0c8e2">llapi_hsm_request</a> (const char *path, const struct <a class="el" href="structhsm__user__request.html">hsm_user_request</a> *request)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a HSM request to Lustre, described in.  <a href="#gaad5620c10129544e26bb083f32d0c8e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gaf26452d9f0f67d7b3efa39bc790c8349">llapi_hsm_current_action</a> (const char *path, struct <a class="el" href="structhsm__current__action.html">hsm_current_action</a> *hca)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current HSM request related to file pointed by <em>path</em>.  <a href="#gaf26452d9f0f67d7b3efa39bc790c8349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gab01607fc36bd8fc5fef69a350b1bfc15">llapi_json_init_list</a> (struct <a class="el" href="structllapi__json__item__list.html">llapi_json_item_list</a> **item_list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a list to hold JSON items.  <a href="#gab01607fc36bd8fc5fef69a350b1bfc15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga4b4263f06c811155591bcd320ced1b2b">llapi_json_destroy_list</a> (struct <a class="el" href="structllapi__json__item__list.html">llapi_json_item_list</a> **item_list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate a list of JSON items.  <a href="#ga4b4263f06c811155591bcd320ced1b2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga988c169fbd79a5424e9890b6638fb88a">llapi_json_add_item</a> (struct <a class="el" href="structllapi__json__item__list.html">llapi_json_item_list</a> **item_list, char *key, __u32 type, void *val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an item to a list of JSON items.  <a href="#ga988c169fbd79a5424e9890b6638fb88a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga00638df4cbfdb25fbc73e9a38ca39a8d">llapi_json_write_list</a> (struct <a class="el" href="structllapi__json__item__list.html">llapi_json_item_list</a> **item_list, FILE *fp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a list of JSON items to a filehandle.  <a href="#ga00638df4cbfdb25fbc73e9a38ca39a8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga9ec0827918f89d7d933eedd3dbcfae3c">llapi_lease_get</a> (int fd, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a lease on an open file.  <a href="#ga9ec0827918f89d7d933eedd3dbcfae3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga1d487541bbb98f50f4c34ef1259541bc">llapi_lease_check</a> (int fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a lease is still set on a file.  <a href="#ga1d487541bbb98f50f4c34ef1259541bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga55e064e34e9b7c39ad03c5c4b1fb5af8">llapi_lease_put</a> (int fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a lease.  <a href="#ga55e064e34e9b7c39ad03c5c4b1fb5af8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#gacea5571bfa6ba5aedcdce8ad702ccce7">llapi_group_lock</a> (int fd, int gid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take group lock.  <a href="#gacea5571bfa6ba5aedcdce8ad702ccce7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llapi.html#ga050191a3e88b1a109dfd5cfc2fdf32cb">llapi_group_unlock</a> (int fd, int gid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put group lock.  <a href="#ga050191a3e88b1a109dfd5cfc2fdf32cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c3300473beec692ad3518817fc77219"></a><!-- doxytag: member="llapi::llapi_ladvise" ref="ga6c3300473beec692ad3518817fc77219" args="(int fd, unsigned long long flags, int num_advise, struct lu_ladvise *ladvise)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>llapi_ladvise</b> (int fd, unsigned long long flags, int num_advise, struct <a class="el" href="structlu__ladvise.html">lu_ladvise</a> *ladvise)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga443b06fff74be7d9bcb55e2f98b8a8a6"></a><!-- doxytag: member="llapi::liblustreapi_initialized" ref="ga443b06fff74be7d9bcb55e2f98b8a8a6" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>liblustreapi_initialized</b></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga3272ba7130a68924677ab1db2486275b"></a><!-- doxytag: member="lustreapi.h::VERBOSE_ALL" ref="ga3272ba7130a68924677ab1db2486275b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VERBOSE_ALL</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(VERBOSE_COUNT | VERBOSE_SIZE | \
                                 VERBOSE_OFFSET | VERBOSE_POOL | \
                                 VERBOSE_OBJID | VERBOSE_GENERATION |\
                                 VERBOSE_LAYOUT)
</pre></div>
<p>Definition at line <a class="el" href="lustreapi_8h_source.html#l00145">145</a> of file <a class="el" href="lustreapi_8h_source.html">lustreapi.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaecd4f83399ed073c6c02237bdbeab5f4"></a><!-- doxytag: member="lustreapi.h::llapi_changelog_free" ref="gaecd4f83399ed073c6c02237bdbeab5f4" args="(struct changelog_rec **rech)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_changelog_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structchangelog__rec.html">changelog_rec</a> **&nbsp;</td>
          <td class="paramname"> <em>rech</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the changelog record when done with it. </p>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l04077">4077</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l04078"></a>04078 {
<a name="l04079"></a>04079         <span class="keywordflow">if</span> (*rech) {
<a name="l04080"></a>04080                 <span class="comment">/* We allocated memory starting at the kuc_hdr, but passed</span>
<a name="l04081"></a>04081 <span class="comment">                 * the consumer a pointer to the payload.</span>
<a name="l04082"></a>04082 <span class="comment">                 * Use pointer math to get back to the header.</span>
<a name="l04083"></a>04083 <span class="comment">                 */</span>
<a name="l04084"></a>04084                 <span class="keyword">struct </span><a class="code" href="structkuc__hdr.html">kuc_hdr</a> *kuch = (<span class="keyword">struct </span><a class="code" href="structkuc__hdr.html">kuc_hdr</a> *)*rech - 1;
<a name="l04085"></a>04085                 free(kuch);
<a name="l04086"></a>04086         }
<a name="l04087"></a>04087         *rech = NULL;
<a name="l04088"></a>04088         <span class="keywordflow">return</span> 0;
<a name="l04089"></a>04089 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga73d536a65aab56fbc37cb4386460b120"></a><!-- doxytag: member="lustreapi.h::llapi_changelog_start" ref="ga73d536a65aab56fbc37cb4386460b120" args="(void **priv, enum changelog_send_flag flags, const char *mdtname, long long startrec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_changelog_start </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>priv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum changelog_send_flag&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>startrec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start reading from a changelog. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>priv</em>&nbsp;</td><td>Opaque private control structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Start flags (e.g. CHANGELOG_FLAG_BLOCK) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Report changes recorded on this MDT </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startrec</em>&nbsp;</td><td>Report changes beginning with this record number (just call llapi_changelog_fini when done; don't need an endrec) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l03938">3938</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p>References <a class="el" href="liblustreapi_8c_source.html#l03988">llapi_changelog_fini()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l03940"></a>03940 {
<a name="l03941"></a>03941         <span class="keyword">struct </span>changelog_private        *cp;
<a name="l03942"></a>03942         <span class="keyword">static</span> <span class="keywordtype">bool</span>                      warned;
<a name="l03943"></a>03943         <span class="keywordtype">int</span>                              rc;
<a name="l03944"></a>03944 
<a name="l03945"></a>03945         <span class="comment">/* Set up the receiver control struct */</span>
<a name="l03946"></a>03946         cp = calloc(1, <span class="keyword">sizeof</span>(*cp));
<a name="l03947"></a>03947         <span class="keywordflow">if</span> (cp == NULL)
<a name="l03948"></a>03948                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l03949"></a>03949 
<a name="l03950"></a>03950         cp-&gt;magic = CHANGELOG_PRIV_MAGIC;
<a name="l03951"></a>03951         cp-&gt;flags = flags;
<a name="l03952"></a>03952 
<a name="l03953"></a>03953         <span class="comment">/* Set up the receiver */</span>
<a name="l03954"></a>03954         rc = libcfs_ukuc_start(&amp;cp-&gt;kuc, 0 <span class="comment">/* no group registration */</span>, 0);
<a name="l03955"></a>03955         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l03956"></a>03956                 <span class="keywordflow">goto</span> out_free;
<a name="l03957"></a>03957 
<a name="l03958"></a>03958         *priv = cp;
<a name="l03959"></a>03959 
<a name="l03960"></a>03960         <span class="comment">/* CHANGELOG_FLAG_JOBID will eventually become mandatory. Display a</span>
<a name="l03961"></a>03961 <span class="comment">         * warning if it&apos;s missing. */</span>
<a name="l03962"></a>03962         <span class="keywordflow">if</span> (!(flags &amp; CHANGELOG_FLAG_JOBID) &amp;&amp; !warned) {
<a name="l03963"></a>03963                 llapi_err_noerrno(LLAPI_MSG_WARN, <span class="stringliteral">&quot;warning: %s() called &quot;</span>
<a name="l03964"></a>03964                                   <span class="stringliteral">&quot;w/o CHANGELOG_FLAG_JOBID&quot;</span>, __func__);
<a name="l03965"></a>03965                 warned = <span class="keyword">true</span>;
<a name="l03966"></a>03966         }
<a name="l03967"></a>03967 
<a name="l03968"></a>03968         <span class="comment">/* Tell the kernel to start sending */</span>
<a name="l03969"></a>03969         rc = changelog_ioctl(device, OBD_IOC_CHANGELOG_SEND, cp-&gt;kuc.lk_wfd,
<a name="l03970"></a>03970                              startrec, flags);
<a name="l03971"></a>03971         <span class="comment">/* Only the kernel reference keeps the write side open */</span>
<a name="l03972"></a>03972         close(cp-&gt;kuc.lk_wfd);
<a name="l03973"></a>03973         cp-&gt;kuc.lk_wfd = LK_NOFD;
<a name="l03974"></a>03974         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l03975"></a>03975                 <span class="comment">/* frees and clears priv */</span>
<a name="l03976"></a>03976                 <a class="code" href="group__llapi.html#ga1ee5507d6f2787dccb55b10cafddd05c" title="Finish reading from a changelog.">llapi_changelog_fini</a>(priv);
<a name="l03977"></a>03977                 <span class="keywordflow">return</span> rc;
<a name="l03978"></a>03978         }
<a name="l03979"></a>03979 
<a name="l03980"></a>03980         <span class="keywordflow">return</span> 0;
<a name="l03981"></a>03981 
<a name="l03982"></a>03982 out_free:
<a name="l03983"></a>03983         free(cp);
<a name="l03984"></a>03984         <span class="keywordflow">return</span> rc;
<a name="l03985"></a>03985 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__llapi_ga73d536a65aab56fbc37cb4386460b120_cgraph.png" border="0" usemap="#group__llapi_ga73d536a65aab56fbc37cb4386460b120_cgraph_map" alt=""></div>
<map name="group__llapi_ga73d536a65aab56fbc37cb4386460b120_cgraph_map" id="group__llapi_ga73d536a65aab56fbc37cb4386460b120_cgraph">
<area shape="rect" id="node3" href="group__llapi.html#ga1ee5507d6f2787dccb55b10cafddd05c" title="Finish reading from a changelog." alt="" coords="217,5,364,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga8db697eb702075e7bd1b7a3eee23dae8"></a><!-- doxytag: member="lustreapi.h::llapi_error_callback_set" ref="ga8db697eb702075e7bd1b7a3eee23dae8" args="(llapi_log_callback_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llapi_log_callback_t llapi_error_callback_set </td>
          <td>(</td>
          <td class="paramtype">llapi_log_callback_t&nbsp;</td>
          <td class="paramname"> <em>cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a custom error logging function. </p>
<p>Passing in NULL will reset the logging callback to its default value.</p>
<p>This function returns the value of the old callback. </p>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l00156">156</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00157"></a>00157 {
<a name="l00158"></a>00158         llapi_log_callback_t    old = llapi_error_callback;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         <span class="keywordflow">if</span> (cb != NULL)
<a name="l00161"></a>00161                 llapi_error_callback = cb;
<a name="l00162"></a>00162         <span class="keywordflow">else</span>
<a name="l00163"></a>00163                 llapi_error_callback = error_callback_default;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165         <span class="keywordflow">return</span> old;
<a name="l00166"></a>00166 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac3a99b881313d663dbf6babea2b8202c"></a><!-- doxytag: member="lustreapi.h::llapi_file_open_param" ref="gac3a99b881313d663dbf6babea2b8202c" args="(const char *name, int flags, mode_t mode, const struct llapi_stripe_param *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_file_open_param </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structllapi__stripe__param.html">llapi_stripe_param</a> *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a Lustre file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the file to be opened </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>access mode, see flags in open(2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>permission of the file if it is created, see mode in open(2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>stripe pattern of the newly created file</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>descriptor of opened file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>errno on failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l00466">466</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00468"></a>00468 {
<a name="l00469"></a>00469         <span class="keywordtype">char</span> fsname[MAX_OBD_NAME + 1] = { 0 };
<a name="l00470"></a>00470         <span class="keywordtype">char</span> *pool_name = param-&gt;lsp_pool;
<a name="l00471"></a>00471         <span class="keyword">struct </span>lov_user_md *lum = NULL;
<a name="l00472"></a>00472         <span class="keywordtype">size_t</span> lum_size = <span class="keyword">sizeof</span>(*lum);
<a name="l00473"></a>00473         <span class="keywordtype">int</span> fd, rc;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         <span class="comment">/* Make sure we are on a Lustre file system */</span>
<a name="l00476"></a>00476         rc = llapi_search_fsname(name, fsname);
<a name="l00477"></a>00477         <span class="keywordflow">if</span> (rc) {
<a name="l00478"></a>00478                 llapi_error(LLAPI_MSG_ERROR, rc,
<a name="l00479"></a>00479                             <span class="stringliteral">&quot;&apos;%s&apos; is not on a Lustre filesystem&quot;</span>,
<a name="l00480"></a>00480                             name);
<a name="l00481"></a>00481                 <span class="keywordflow">return</span> rc;
<a name="l00482"></a>00482         }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         <span class="comment">/* Check if the stripe pattern is sane. */</span>
<a name="l00485"></a>00485         rc = llapi_stripe_limit_check(param-&gt;lsp_stripe_size,
<a name="l00486"></a>00486                                       param-&gt;lsp_stripe_offset,
<a name="l00487"></a>00487                                       param-&gt;lsp_stripe_count,
<a name="l00488"></a>00488                                       param-&gt;lsp_stripe_pattern);
<a name="l00489"></a>00489         <span class="keywordflow">if</span> (rc != 0)
<a name="l00490"></a>00490                 <span class="keywordflow">return</span> rc;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         <span class="comment">/* Make sure we have a good pool */</span>
<a name="l00493"></a>00493         <span class="keywordflow">if</span> (pool_name != NULL) {
<a name="l00494"></a>00494                 <span class="comment">/* in case user gives the full pool name &lt;fsname&gt;.&lt;poolname&gt;,</span>
<a name="l00495"></a>00495 <span class="comment">                 * strip the fsname */</span>
<a name="l00496"></a>00496                 <span class="keywordtype">char</span> *ptr = strchr(pool_name, <span class="charliteral">&apos;.&apos;</span>);
<a name="l00497"></a>00497                 <span class="keywordflow">if</span> (ptr != NULL) {
<a name="l00498"></a>00498                         *ptr = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00499"></a>00499                         <span class="keywordflow">if</span> (strcmp(pool_name, fsname) != 0) {
<a name="l00500"></a>00500                                 *ptr = <span class="charliteral">&apos;.&apos;</span>;
<a name="l00501"></a>00501                                 llapi_err_noerrno(LLAPI_MSG_ERROR,
<a name="l00502"></a>00502                                         <span class="stringliteral">&quot;Pool &apos;%s&apos; is not on filesystem &apos;%s&apos;&quot;</span>,
<a name="l00503"></a>00503                                         pool_name, fsname);
<a name="l00504"></a>00504                                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00505"></a>00505                         }
<a name="l00506"></a>00506                         pool_name = ptr + 1;
<a name="l00507"></a>00507                 }
<a name="l00508"></a>00508 
<a name="l00509"></a>00509                 <span class="comment">/* Make sure the pool exists and is non-empty */</span>
<a name="l00510"></a>00510                 rc = llapi_search_ost(fsname, pool_name, NULL);
<a name="l00511"></a>00511                 <span class="keywordflow">if</span> (rc &lt; 1) {
<a name="l00512"></a>00512                         <span class="keywordtype">char</span> *err = rc == 0 ? <span class="stringliteral">&quot;has no OSTs&quot;</span> : <span class="stringliteral">&quot;does not exist&quot;</span>;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514                         llapi_err_noerrno(LLAPI_MSG_ERROR, <span class="stringliteral">&quot;pool &apos;%s.%s&apos; %s&quot;</span>,
<a name="l00515"></a>00515                                           fsname, pool_name, err);
<a name="l00516"></a>00516                         <span class="keywordflow">return</span> -EINVAL;
<a name="l00517"></a>00517                 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519                 lum_size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a>);
<a name="l00520"></a>00520         }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522         <span class="comment">/* sanity check of target list */</span>
<a name="l00523"></a>00523         <span class="keywordflow">if</span> (param-&gt;lsp_is_specific) {
<a name="l00524"></a>00524                 <span class="keywordtype">char</span> ostname[MAX_OBD_NAME + 1];
<a name="l00525"></a>00525                 <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
<a name="l00526"></a>00526                 <span class="keywordtype">int</span> i;
<a name="l00527"></a>00527 
<a name="l00528"></a>00528                 <span class="keywordflow">for</span> (i = 0; i &lt; param-&gt;lsp_stripe_count; i++) {
<a name="l00529"></a>00529                         snprintf(ostname, <span class="keyword">sizeof</span>(ostname), <span class="stringliteral">&quot;%s-OST%04x_UUID&quot;</span>,
<a name="l00530"></a>00530                                  fsname, param-&gt;lsp_osts[i]);
<a name="l00531"></a>00531                         rc = llapi_search_ost(fsname, pool_name, ostname);
<a name="l00532"></a>00532                         <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l00533"></a>00533                                 <span class="keywordflow">if</span> (rc == 0)
<a name="l00534"></a>00534                                         rc = -ENODEV;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536                                 llapi_error(LLAPI_MSG_ERROR, rc,
<a name="l00537"></a>00537                                             <span class="stringliteral">&quot;%s: cannot find OST %s in %s&quot;</span>,
<a name="l00538"></a>00538                                             __func__, ostname,
<a name="l00539"></a>00539                                             pool_name != NULL ?
<a name="l00540"></a>00540                                             <span class="stringliteral">&quot;pool&quot;</span> : <span class="stringliteral">&quot;system&quot;</span>);
<a name="l00541"></a>00541                                 <span class="keywordflow">return</span> rc;
<a name="l00542"></a>00542                         }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544                         <span class="comment">/* Make sure stripe offset is in OST list. */</span>
<a name="l00545"></a>00545                         <span class="keywordflow">if</span> (param-&gt;lsp_osts[i] == param-&gt;lsp_stripe_offset)
<a name="l00546"></a>00546                                 found = <span class="keyword">true</span>;
<a name="l00547"></a>00547                 }
<a name="l00548"></a>00548                 <span class="keywordflow">if</span> (!found) {
<a name="l00549"></a>00549                         llapi_error(LLAPI_MSG_ERROR, -EINVAL,
<a name="l00550"></a>00550                                     <span class="stringliteral">&quot;%s: stripe offset &apos;%d&apos; is not in the &quot;</span>
<a name="l00551"></a>00551                                     <span class="stringliteral">&quot;target list&quot;</span>,
<a name="l00552"></a>00552                                     __func__, param-&gt;lsp_stripe_offset);
<a name="l00553"></a>00553                         <span class="keywordflow">return</span> -EINVAL;
<a name="l00554"></a>00554                 }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556                 lum_size = lov_user_md_size(param-&gt;lsp_stripe_count,
<a name="l00557"></a>00557                                             LOV_USER_MAGIC_SPECIFIC);
<a name="l00558"></a>00558         }
<a name="l00559"></a>00559 
<a name="l00560"></a>00560         lum = calloc(1, lum_size);
<a name="l00561"></a>00561         <span class="keywordflow">if</span> (lum == NULL)
<a name="l00562"></a>00562                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 retry_open:
<a name="l00565"></a>00565         fd = open(name, flags | O_LOV_DELAY_CREATE, mode);
<a name="l00566"></a>00566         <span class="keywordflow">if</span> (fd &lt; 0) {
<a name="l00567"></a>00567                 <span class="keywordflow">if</span> (errno == EISDIR &amp;&amp; !(flags &amp; O_DIRECTORY)) {
<a name="l00568"></a>00568                         flags = O_DIRECTORY | O_RDONLY;
<a name="l00569"></a>00569                         <span class="keywordflow">goto</span> retry_open;
<a name="l00570"></a>00570                 }
<a name="l00571"></a>00571         }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573         <span class="keywordflow">if</span> (fd &lt; 0) {
<a name="l00574"></a>00574                 rc = -errno;
<a name="l00575"></a>00575                 llapi_error(LLAPI_MSG_ERROR, rc, <span class="stringliteral">&quot;unable to open &apos;%s&apos;&quot;</span>, name);
<a name="l00576"></a>00576                 free(lum);
<a name="l00577"></a>00577                 <span class="keywordflow">return</span> rc;
<a name="l00578"></a>00578         }
<a name="l00579"></a>00579 
<a name="l00580"></a>00580         <span class="comment">/*  Initialize IOCTL striping pattern structure */</span>
<a name="l00581"></a>00581         lum-&gt;lmm_magic = LOV_USER_MAGIC_V1;
<a name="l00582"></a>00582         lum-&gt;lmm_pattern = param-&gt;lsp_stripe_pattern;
<a name="l00583"></a>00583         lum-&gt;lmm_stripe_size = param-&gt;lsp_stripe_size;
<a name="l00584"></a>00584         lum-&gt;lmm_stripe_count = param-&gt;lsp_stripe_count;
<a name="l00585"></a>00585         lum-&gt;lmm_stripe_offset = param-&gt;lsp_stripe_offset;
<a name="l00586"></a>00586         <span class="keywordflow">if</span> (pool_name != NULL) {
<a name="l00587"></a>00587                 <span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a> *lumv3 = (<span class="keywordtype">void</span> *)lum;
<a name="l00588"></a>00588 
<a name="l00589"></a>00589                 lumv3-&gt;lmm_magic = LOV_USER_MAGIC_V3;
<a name="l00590"></a>00590                 strncpy(lumv3-&gt;lmm_pool_name, pool_name, LOV_MAXPOOLNAME);
<a name="l00591"></a>00591         }
<a name="l00592"></a>00592         <span class="keywordflow">if</span> (param-&gt;lsp_is_specific) {
<a name="l00593"></a>00593                 <span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a> *lumv3 = (<span class="keywordtype">void</span> *)lum;
<a name="l00594"></a>00594                 <span class="keywordtype">int</span> i;
<a name="l00595"></a>00595 
<a name="l00596"></a>00596                 lumv3-&gt;lmm_magic = LOV_USER_MAGIC_SPECIFIC;
<a name="l00597"></a>00597                 <span class="keywordflow">if</span> (pool_name == NULL) {
<a name="l00598"></a>00598                         <span class="comment">/* LOV_USER_MAGIC_SPECIFIC uses v3 format plus specified</span>
<a name="l00599"></a>00599 <span class="comment">                         * OST list, therefore if pool is not specified we have</span>
<a name="l00600"></a>00600 <span class="comment">                         * to pack a null pool name for placeholder. */</span>
<a name="l00601"></a>00601                         memset(lumv3-&gt;lmm_pool_name, 0, LOV_MAXPOOLNAME);
<a name="l00602"></a>00602                 }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604                 <span class="keywordflow">for</span> (i = 0; i &lt; param-&gt;lsp_stripe_count; i++)
<a name="l00605"></a>00605                         lumv3-&gt;lmm_objects[i].l_ost_idx = param-&gt;lsp_osts[i];
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         <span class="keywordflow">if</span> (ioctl(fd, LL_IOC_LOV_SETSTRIPE, lum) != 0) {
<a name="l00609"></a>00609                 <span class="keywordtype">char</span> *errmsg = <span class="stringliteral">&quot;stripe already set&quot;</span>;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611                 rc = -errno;
<a name="l00612"></a>00612                 <span class="keywordflow">if</span> (errno != EEXIST &amp;&amp; errno != EALREADY)
<a name="l00613"></a>00613                         errmsg = strerror(errno);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615                 llapi_err_noerrno(LLAPI_MSG_ERROR,
<a name="l00616"></a>00616                                   <span class="stringliteral">&quot;error on ioctl %#jx for &apos;%s&apos; (%d): %s&quot;</span>,
<a name="l00617"></a>00617                                   (uintmax_t)LL_IOC_LOV_SETSTRIPE, name, fd,
<a name="l00618"></a>00618                                   errmsg);
<a name="l00619"></a>00619 
<a name="l00620"></a>00620                 close(fd);
<a name="l00621"></a>00621                 fd = rc;
<a name="l00622"></a>00622         }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624         free(lum);
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="keywordflow">return</span> fd;
<a name="l00627"></a>00627 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9e9e67e755fe3a7d4db8f3fe2ceb89d0"></a><!-- doxytag: member="lustreapi.h::llapi_get_data_version" ref="ga9e9e67e755fe3a7d4db8f3fe2ceb89d0" args="(int fd, __u64 *data_version, __u64 flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_get_data_version </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64 *&nbsp;</td>
          <td class="paramname"> <em>data_version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a 64-bit value representing the version of file data pointed by fd. </p>
<p>Each write or truncate, flushed on OST, will change this value. You can use this value to verify if file data was modified. This only checks the file data, not metadata.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>0: no flush pages, usually used it the process has already taken locks; LL_DV_RD_FLUSH: OSTs will take LCK_PR to flush dirty pages from clients; LL_DV_WR_FLUSH: OSTs will take LCK_PW to flush all caching pages from clients.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l04336">4336</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l04337"></a>04337 {
<a name="l04338"></a>04338         <span class="keywordtype">int</span> rc;
<a name="l04339"></a>04339         <span class="keyword">struct </span><a class="code" href="structioc__data__version.html">ioc_data_version</a> idv;
<a name="l04340"></a>04340 
<a name="l04341"></a>04341         idv.idv_flags = flags;
<a name="l04342"></a>04342 
<a name="l04343"></a>04343         rc = ioctl(fd, LL_IOC_DATA_VERSION, &amp;idv);
<a name="l04344"></a>04344         <span class="keywordflow">if</span> (rc)
<a name="l04345"></a>04345                 rc = -errno;
<a name="l04346"></a>04346         <span class="keywordflow">else</span>
<a name="l04347"></a>04347                 *data_version = idv.idv_version;
<a name="l04348"></a>04348 
<a name="l04349"></a>04349         <span class="keywordflow">return</span> rc;
<a name="l04350"></a>04350 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga65ff2acbd45636796734faad3f8afc81"></a><!-- doxytag: member="lustreapi.h::llapi_get_poollist" ref="ga65ff2acbd45636796734faad3f8afc81" args="(const char *name, char **poollist, int list_size, char *buffer, int buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_get_poollist </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>poollist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the list of pools in a filesystem. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>filesystem name or path </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poollist</em>&nbsp;</td><td>caller-allocated array of char* </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>list_size</em>&nbsp;</td><td>size of the poollist array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>caller-allocated buffer for storing pool names </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of pools retrieved for this filesystem </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-error</em>&nbsp;</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l01138">1138</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01140"></a>01140 {
<a name="l01141"></a>01141         <span class="keywordtype">char</span> rname[PATH_MAX];
<a name="l01142"></a>01142         glob_t pathname;
<a name="l01143"></a>01143         <span class="keywordtype">char</span> *fsname;
<a name="l01144"></a>01144         <span class="keywordtype">char</span> *ptr;
<a name="l01145"></a>01145         DIR *dir;
<a name="l01146"></a>01146         <span class="keyword">struct </span>dirent pool;
<a name="l01147"></a>01147         <span class="keyword">struct </span>dirent *cookie = NULL;
<a name="l01148"></a>01148         <span class="keywordtype">int</span> rc = 0;
<a name="l01149"></a>01149         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_entries = 0;
<a name="l01150"></a>01150         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> used = 0;
<a name="l01151"></a>01151         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l01152"></a>01152 
<a name="l01153"></a>01153         <span class="comment">/* initialize output array */</span>
<a name="l01154"></a>01154         <span class="keywordflow">for</span> (i = 0; i &lt; list_size; i++)
<a name="l01155"></a>01155                 poollist[i] = NULL;
<a name="l01156"></a>01156 
<a name="l01157"></a>01157         <span class="comment">/* is name a pathname ? */</span>
<a name="l01158"></a>01158         ptr = strchr(name, <span class="charliteral">&apos;/&apos;</span>);
<a name="l01159"></a>01159         <span class="keywordflow">if</span> (ptr != NULL) {
<a name="l01160"></a>01160                 <span class="comment">/* only absolute pathname is supported */</span>
<a name="l01161"></a>01161                 <span class="keywordflow">if</span> (*name != <span class="charliteral">&apos;/&apos;</span>)
<a name="l01162"></a>01162                         <span class="keywordflow">return</span> -EINVAL;
<a name="l01163"></a>01163 
<a name="l01164"></a>01164                 <span class="keywordflow">if</span> (!realpath(name, rname)) {
<a name="l01165"></a>01165                         rc = -errno;
<a name="l01166"></a>01166                         llapi_error(LLAPI_MSG_ERROR, rc, <span class="stringliteral">&quot;invalid path &apos;%s&apos;&quot;</span>,
<a name="l01167"></a>01167                                     name);
<a name="l01168"></a>01168                         <span class="keywordflow">return</span> rc;
<a name="l01169"></a>01169                 }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171                 fsname = strdup(rname);
<a name="l01172"></a>01172                 <span class="keywordflow">if</span> (!fsname)
<a name="l01173"></a>01173                         <span class="keywordflow">return</span> -ENOMEM;
<a name="l01174"></a>01174 
<a name="l01175"></a>01175                 rc = poolpath(&amp;pathname, NULL, rname);
<a name="l01176"></a>01176         } <span class="keywordflow">else</span> {
<a name="l01177"></a>01177                 <span class="comment">/* name is FSNAME */</span>
<a name="l01178"></a>01178                 fsname = strdup(name);
<a name="l01179"></a>01179                 <span class="keywordflow">if</span> (!fsname)
<a name="l01180"></a>01180                         <span class="keywordflow">return</span> -ENOMEM;
<a name="l01181"></a>01181                 rc = poolpath(&amp;pathname, fsname, NULL);
<a name="l01182"></a>01182         }
<a name="l01183"></a>01183         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01184"></a>01184                 llapi_error(LLAPI_MSG_ERROR, rc,
<a name="l01185"></a>01185                             <span class="stringliteral">&quot;Lustre filesystem &apos;%s&apos; not found&quot;</span>, name);
<a name="l01186"></a>01186                 <span class="keywordflow">goto</span> free_path;
<a name="l01187"></a>01187         }
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         llapi_printf(LLAPI_MSG_NORMAL, <span class="stringliteral">&quot;Pools from %s:\n&quot;</span>, fsname);
<a name="l01190"></a>01190         dir = opendir(pathname.gl_pathv[0]);
<a name="l01191"></a>01191         <span class="keywordflow">if</span> (dir == NULL) {
<a name="l01192"></a>01192                 rc = -errno;
<a name="l01193"></a>01193                 llapi_error(LLAPI_MSG_ERROR, rc,
<a name="l01194"></a>01194                             <span class="stringliteral">&quot;Could not open pool list for &apos;%s&apos;&quot;</span>,
<a name="l01195"></a>01195                             name);
<a name="l01196"></a>01196                 <span class="keywordflow">goto</span> free_path;
<a name="l01197"></a>01197         }
<a name="l01198"></a>01198 
<a name="l01199"></a>01199         <span class="keywordflow">while</span>(1) {
<a name="l01200"></a>01200                 rc = readdir_r(dir, &amp;pool, &amp;cookie);
<a name="l01201"></a>01201                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01202"></a>01202                         rc = -errno;
<a name="l01203"></a>01203                         llapi_error(LLAPI_MSG_ERROR, rc,
<a name="l01204"></a>01204                                     <span class="stringliteral">&quot;Error reading pool list for &apos;%s&apos;&quot;</span>, name);
<a name="l01205"></a>01205                         <span class="keywordflow">goto</span> free_path;
<a name="l01206"></a>01206                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((rc == 0) &amp;&amp; (cookie == NULL)) {
<a name="l01207"></a>01207                         <span class="comment">/* end of directory */</span>
<a name="l01208"></a>01208                         <span class="keywordflow">break</span>;
<a name="l01209"></a>01209                 }
<a name="l01210"></a>01210 
<a name="l01211"></a>01211                 <span class="comment">/* ignore . and .. */</span>
<a name="l01212"></a>01212                 <span class="keywordflow">if</span> (!strcmp(pool.d_name, <span class="stringliteral">&quot;.&quot;</span>) || !strcmp(pool.d_name, <span class="stringliteral">&quot;..&quot;</span>))
<a name="l01213"></a>01213                         <span class="keywordflow">continue</span>;
<a name="l01214"></a>01214 
<a name="l01215"></a>01215                 <span class="comment">/* check output bounds */</span>
<a name="l01216"></a>01216                 <span class="keywordflow">if</span> (nb_entries &gt;= list_size) {
<a name="l01217"></a>01217                         rc = -EOVERFLOW;
<a name="l01218"></a>01218                         <span class="keywordflow">goto</span> free_dir;
<a name="l01219"></a>01219                 }
<a name="l01220"></a>01220 
<a name="l01221"></a>01221                 <span class="comment">/* +2 for &apos;.&apos; and final &apos;\0&apos; */</span>
<a name="l01222"></a>01222                 <span class="keywordflow">if</span> (used + strlen(pool.d_name) + strlen(fsname) + 2
<a name="l01223"></a>01223                     &gt; buffer_size) {
<a name="l01224"></a>01224                         rc = -EOVERFLOW;
<a name="l01225"></a>01225                         <span class="keywordflow">goto</span> free_dir;
<a name="l01226"></a>01226                 }
<a name="l01227"></a>01227 
<a name="l01228"></a>01228                 sprintf(buffer + used, <span class="stringliteral">&quot;%s.%s&quot;</span>, fsname, pool.d_name);
<a name="l01229"></a>01229                 poollist[nb_entries] = buffer + used;
<a name="l01230"></a>01230                 used += strlen(pool.d_name) + strlen(fsname) + 2;
<a name="l01231"></a>01231                 nb_entries++;
<a name="l01232"></a>01232         }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 free_dir:
<a name="l01235"></a>01235         closedir(dir);
<a name="l01236"></a>01236 free_path:
<a name="l01237"></a>01237         cfs_free_param_data(&amp;pathname);
<a name="l01238"></a>01238         <span class="keywordflow">if</span> (fsname)
<a name="l01239"></a>01239                 free(fsname);
<a name="l01240"></a>01240         <span class="keywordflow">return</span> rc != 0 ? rc : nb_entries;
<a name="l01241"></a>01241 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa3e9bdb0dfe48d7ed11d10630b34f3fe"></a><!-- doxytag: member="lustreapi.h::llapi_get_poolmembers" ref="gaa3e9bdb0dfe48d7ed11d10630b34f3fe" args="(const char *poolname, char **members, int list_size, char *buffer, int buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_get_poolmembers </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>poolname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>members</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the list of pool members. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poolname</em>&nbsp;</td><td>string of format &lt;fsname&gt;.&lt;poolname&gt; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>members</em>&nbsp;</td><td>caller-allocated array of char* </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>list_size</em>&nbsp;</td><td>size of the members array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>caller-allocated buffer for storing OST names </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of members retrieved for this pool </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-error</em>&nbsp;</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l01057">1057</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01059"></a>01059 {
<a name="l01060"></a>01060         <span class="keywordtype">char</span> fsname[PATH_MAX];
<a name="l01061"></a>01061         <span class="keywordtype">char</span> *pool, *tmp;
<a name="l01062"></a>01062         glob_t pathname;
<a name="l01063"></a>01063         <span class="keywordtype">char</span> buf[PATH_MAX];
<a name="l01064"></a>01064         FILE *fd;
<a name="l01065"></a>01065         <span class="keywordtype">int</span> rc = 0;
<a name="l01066"></a>01066         <span class="keywordtype">int</span> nb_entries = 0;
<a name="l01067"></a>01067         <span class="keywordtype">int</span> used = 0;
<a name="l01068"></a>01068 
<a name="l01069"></a>01069         <span class="comment">/* name is FSNAME.POOLNAME */</span>
<a name="l01070"></a>01070         <span class="keywordflow">if</span> (strlen(poolname) &gt;= <span class="keyword">sizeof</span>(fsname))
<a name="l01071"></a>01071                 <span class="keywordflow">return</span> -EOVERFLOW;
<a name="l01072"></a>01072         strlcpy(fsname, poolname, <span class="keyword">sizeof</span>(fsname));
<a name="l01073"></a>01073         pool = strchr(fsname, <span class="charliteral">&apos;.&apos;</span>);
<a name="l01074"></a>01074         <span class="keywordflow">if</span> (pool == NULL)
<a name="l01075"></a>01075                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01076"></a>01076 
<a name="l01077"></a>01077         *pool = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01078"></a>01078         pool++;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080         rc = poolpath(&amp;pathname, fsname, NULL);
<a name="l01081"></a>01081         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01082"></a>01082                 llapi_error(LLAPI_MSG_ERROR, rc,
<a name="l01083"></a>01083                             <span class="stringliteral">&quot;Lustre filesystem &apos;%s&apos; not found&quot;</span>,
<a name="l01084"></a>01084                             fsname);
<a name="l01085"></a>01085                 <span class="keywordflow">return</span> rc;
<a name="l01086"></a>01086         }
<a name="l01087"></a>01087 
<a name="l01088"></a>01088         llapi_printf(LLAPI_MSG_NORMAL, <span class="stringliteral">&quot;Pool: %s.%s\n&quot;</span>, fsname, pool);
<a name="l01089"></a>01089         rc = snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;%s/%s&quot;</span>, pathname.gl_pathv[0], pool);
<a name="l01090"></a>01090         cfs_free_param_data(&amp;pathname);
<a name="l01091"></a>01091         <span class="keywordflow">if</span> (rc &gt;= <span class="keyword">sizeof</span>(buf))
<a name="l01092"></a>01092                 <span class="keywordflow">return</span> -EOVERFLOW;
<a name="l01093"></a>01093         fd = fopen(buf, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l01094"></a>01094         <span class="keywordflow">if</span> (fd == NULL) {
<a name="l01095"></a>01095                 rc = -errno;
<a name="l01096"></a>01096                 llapi_error(LLAPI_MSG_ERROR, rc, <span class="stringliteral">&quot;cannot open %s&quot;</span>, buf);
<a name="l01097"></a>01097                 <span class="keywordflow">return</span> rc;
<a name="l01098"></a>01098         }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100         rc = 0;
<a name="l01101"></a>01101         <span class="keywordflow">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), fd) != NULL) {
<a name="l01102"></a>01102                 <span class="keywordflow">if</span> (nb_entries &gt;= list_size) {
<a name="l01103"></a>01103                         rc = -EOVERFLOW;
<a name="l01104"></a>01104                         <span class="keywordflow">break</span>;
<a name="l01105"></a>01105                 }
<a name="l01106"></a>01106                 buf[<span class="keyword">sizeof</span>(buf) - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01107"></a>01107                 <span class="comment">/* remove &apos;\n&apos; */</span>
<a name="l01108"></a>01108                 tmp = strchr(buf, <span class="charliteral">&apos;\n&apos;</span>);
<a name="l01109"></a>01109                 <span class="keywordflow">if</span> (tmp != NULL)
<a name="l01110"></a>01110                         *tmp=<span class="charliteral">&apos;\0&apos;</span>;
<a name="l01111"></a>01111                 <span class="keywordflow">if</span> (used + strlen(buf) + 1 &gt; buffer_size) {
<a name="l01112"></a>01112                         rc = -EOVERFLOW;
<a name="l01113"></a>01113                         <span class="keywordflow">break</span>;
<a name="l01114"></a>01114                 }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116                 strcpy(buffer + used, buf);
<a name="l01117"></a>01117                 members[nb_entries] = buffer + used;
<a name="l01118"></a>01118                 used += strlen(buf) + 1;
<a name="l01119"></a>01119                 nb_entries++;
<a name="l01120"></a>01120                 rc = nb_entries;
<a name="l01121"></a>01121         }
<a name="l01122"></a>01122 
<a name="l01123"></a>01123         fclose(fd);
<a name="l01124"></a>01124         <span class="keywordflow">return</span> rc;
<a name="l01125"></a>01125 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gacea5571bfa6ba5aedcdce8ad702ccce7"></a><!-- doxytag: member="lustreapi.h::llapi_group_lock" ref="gacea5571bfa6ba5aedcdce8ad702ccce7" args="(int fd, int gid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_group_lock </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take group lock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>File to lock. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gid</em>&nbsp;</td><td>Group Identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on failure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l04577">4577</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l04578"></a>04578 {
<a name="l04579"></a>04579         <span class="keywordtype">int</span> rc;
<a name="l04580"></a>04580 
<a name="l04581"></a>04581         rc = ioctl(fd, LL_IOC_GROUP_LOCK, gid);
<a name="l04582"></a>04582         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l04583"></a>04583                 rc = -errno;
<a name="l04584"></a>04584                 llapi_error(LLAPI_MSG_ERROR, rc, <span class="stringliteral">&quot;cannot get group lock&quot;</span>);
<a name="l04585"></a>04585         }
<a name="l04586"></a>04586         <span class="keywordflow">return</span> rc;
<a name="l04587"></a>04587 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga050191a3e88b1a109dfd5cfc2fdf32cb"></a><!-- doxytag: member="lustreapi.h::llapi_group_unlock" ref="ga050191a3e88b1a109dfd5cfc2fdf32cb" args="(int fd, int gid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_group_unlock </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put group lock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>File to unlock. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gid</em>&nbsp;</td><td>Group Identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on failure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l04598">4598</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l04599"></a>04599 {
<a name="l04600"></a>04600         <span class="keywordtype">int</span> rc;
<a name="l04601"></a>04601 
<a name="l04602"></a>04602         rc = ioctl(fd, LL_IOC_GROUP_UNLOCK, gid);
<a name="l04603"></a>04603         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l04604"></a>04604                 rc = -errno;
<a name="l04605"></a>04605                 llapi_error(LLAPI_MSG_ERROR, rc, <span class="stringliteral">&quot;cannot put group lock&quot;</span>);
<a name="l04606"></a>04606         }
<a name="l04607"></a>04607         <span class="keywordflow">return</span> rc;
<a name="l04608"></a>04608 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac3922a41eae3a32dc48ccf33f9c3d4ac"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_action_begin" ref="gac3922a41eae3a32dc48ccf33f9c3d4ac" args="(struct hsm_copyaction_private **phcp, const struct hsm_copytool_private *ct, const struct hsm_action_item *hai, int restore_mdt_index, int restore_open_flags, bool is_error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_action_begin </td>
          <td>(</td>
          <td class="paramtype">struct hsm_copyaction_private **&nbsp;</td>
          <td class="paramname"> <em>phcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct hsm_copytool_private *&nbsp;</td>
          <td class="paramname"> <em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhsm__action__item.html">hsm_action_item</a> *&nbsp;</td>
          <td class="paramname"> <em>hai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>restore_mdt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>restore_open_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start processing an HSM action. </p>
<p>Should be called by copytools just before starting handling a request. It could be skipped if copytool only want to directly report an error, </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__llapi.html#gaea52ba36ba47870c0f8e6586b3d48ecc" title="Terminate an HSM action processing.">llapi_hsm_action_end()</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hcp</em>&nbsp;</td><td>Opaque action handle to be passed to llapi_hsm_action_progress and llapi_hsm_action_end. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ct</em>&nbsp;</td><td>Copytool handle acquired at registration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hai</em>&nbsp;</td><td>The <a class="el" href="structhsm__action__item.html">hsm_action_item</a> describing the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>restore_mdt_index</em>&nbsp;</td><td>On restore: MDT index where to create the volatile file. Use -1 for default. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>restore_open_flags</em>&nbsp;</td><td>On restore: volatile file creation mode. Use O_LOV_DELAY_CREATE to manually set the LOVEA afterwards. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_error</em>&nbsp;</td><td>Whether this call is just to report an error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01096">1096</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01101"></a>01101 {
<a name="l01102"></a>01102         <span class="keyword">struct </span>hsm_copyaction_private   *hcp;
<a name="l01103"></a>01103         <span class="keywordtype">int</span>                              rc;
<a name="l01104"></a>01104 
<a name="l01105"></a>01105         hcp = calloc(1, <span class="keyword">sizeof</span>(*hcp));
<a name="l01106"></a>01106         <span class="keywordflow">if</span> (hcp == NULL)
<a name="l01107"></a>01107                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01108"></a>01108 
<a name="l01109"></a>01109         hcp-&gt;data_fd = -1;
<a name="l01110"></a>01110         hcp-&gt;ct_priv = ct;
<a name="l01111"></a>01111         hcp-&gt;copy.hc_hai = *hai;
<a name="l01112"></a>01112         hcp-&gt;copy.hc_hai.hai_len = <span class="keyword">sizeof</span>(*hai);
<a name="l01113"></a>01113 
<a name="l01114"></a>01114         <span class="keywordflow">if</span> (is_error)
<a name="l01115"></a>01115                 <span class="keywordflow">goto</span> ok_out;
<a name="l01116"></a>01116 
<a name="l01117"></a>01117         <span class="keywordflow">if</span> (hai-&gt;hai_action == HSMA_RESTORE) {
<a name="l01118"></a>01118                 rc = ct_md_getattr(hcp-&gt;ct_priv, &amp;hai-&gt;hai_fid, &amp;hcp-&gt;stat);
<a name="l01119"></a>01119                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01120"></a>01120                         <span class="keywordflow">goto</span> err_out;
<a name="l01121"></a>01121 
<a name="l01122"></a>01122                 rc = create_restore_volatile(hcp, restore_mdt_index,
<a name="l01123"></a>01123                                              restore_open_flags);
<a name="l01124"></a>01124                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01125"></a>01125                         <span class="keywordflow">goto</span> err_out;
<a name="l01126"></a>01126         }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128         rc = ioctl(ct-&gt;mnt_fd, LL_IOC_HSM_COPY_START, &amp;hcp-&gt;copy);
<a name="l01129"></a>01129         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01130"></a>01130                 rc = -errno;
<a name="l01131"></a>01131                 <span class="keywordflow">goto</span> err_out;
<a name="l01132"></a>01132         }
<a name="l01133"></a>01133 
<a name="l01134"></a>01134         llapi_hsm_log_ct_progress(&amp;hcp, hai, CT_START, 0, 0);
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 ok_out:
<a name="l01137"></a>01137         hcp-&gt;magic = CP_PRIV_MAGIC;
<a name="l01138"></a>01138         *phcp = hcp;
<a name="l01139"></a>01139         <span class="keywordflow">return</span> 0;
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 err_out:
<a name="l01142"></a>01142         <span class="keywordflow">if</span> (!(hcp-&gt;data_fd &lt; 0))
<a name="l01143"></a>01143                 close(hcp-&gt;data_fd);
<a name="l01144"></a>01144 
<a name="l01145"></a>01145         free(hcp);
<a name="l01146"></a>01146 
<a name="l01147"></a>01147         <span class="keywordflow">return</span> rc;
<a name="l01148"></a>01148 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaea52ba36ba47870c0f8e6586b3d48ecc"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_action_end" ref="gaea52ba36ba47870c0f8e6586b3d48ecc" args="(struct hsm_copyaction_private **phcp, const struct hsm_extent *he, int hp_flags, int errval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_action_end </td>
          <td>(</td>
          <td class="paramtype">struct hsm_copyaction_private **&nbsp;</td>
          <td class="paramname"> <em>phcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhsm__extent.html">hsm_extent</a> *&nbsp;</td>
          <td class="paramname"> <em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hp_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>errval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Terminate an HSM action processing. </p>
<p>Should be called by copytools just having finished handling the request. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hdl[in,out]</em>&nbsp;</td><td>Handle returned by llapi_hsm_action_start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>he[in]</em>&nbsp;</td><td>The final range of copied data (for copy actions). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errval[in]</em>&nbsp;</td><td>The status code of the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags[in]</em>&nbsp;</td><td>The flags about the termination status (HP_FLAG_RETRY if the error is retryable).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01160">1160</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01162"></a>01162 {
<a name="l01163"></a>01163         <span class="keyword">struct </span>hsm_copyaction_private   *hcp;
<a name="l01164"></a>01164         <span class="keyword">struct </span><a class="code" href="structhsm__action__item.html">hsm_action_item</a>          *hai;
<a name="l01165"></a>01165         <span class="keywordtype">int</span>                              rc;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167         <span class="keywordflow">if</span> (phcp == NULL || *phcp == NULL || he == NULL)
<a name="l01168"></a>01168                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01169"></a>01169 
<a name="l01170"></a>01170         hcp = *phcp;
<a name="l01171"></a>01171 
<a name="l01172"></a>01172         <span class="keywordflow">if</span> (hcp-&gt;magic != CP_PRIV_MAGIC)
<a name="l01173"></a>01173                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01174"></a>01174 
<a name="l01175"></a>01175         hai = &amp;hcp-&gt;copy.hc_hai;
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         <span class="keywordflow">if</span> (hai-&gt;hai_action == HSMA_RESTORE &amp;&amp; errval == 0) {
<a name="l01178"></a>01178                 <span class="keyword">struct </span><a class="code" href="structll__futimes__3.html">ll_futimes_3</a> lfu = {
<a name="l01179"></a>01179                         .lfu_atime_sec = hcp-&gt;stat.st_atim.tv_sec,
<a name="l01180"></a>01180                         .lfu_atime_nsec = hcp-&gt;stat.st_atim.tv_nsec,
<a name="l01181"></a>01181                         .lfu_mtime_sec = hcp-&gt;stat.st_mtim.tv_sec,
<a name="l01182"></a>01182                         .lfu_mtime_nsec = hcp-&gt;stat.st_mtim.tv_nsec,
<a name="l01183"></a>01183                         .lfu_ctime_sec = hcp-&gt;stat.st_ctim.tv_sec,
<a name="l01184"></a>01184                         .lfu_ctime_nsec = hcp-&gt;stat.st_ctim.tv_nsec,
<a name="l01185"></a>01185                 };
<a name="l01186"></a>01186 
<a name="l01187"></a>01187                 rc = fsync(hcp-&gt;data_fd);
<a name="l01188"></a>01188                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01189"></a>01189                         errval = -errno;
<a name="l01190"></a>01190                         <span class="keywordflow">goto</span> end;
<a name="l01191"></a>01191                 }
<a name="l01192"></a>01192 
<a name="l01193"></a>01193                 <span class="comment">/* Set {a,m,c}time of volatile file to that of original. */</span>
<a name="l01194"></a>01194                 rc = ioctl(hcp-&gt;data_fd, LL_IOC_FUTIMES_3, &amp;lfu);
<a name="l01195"></a>01195                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01196"></a>01196                         errval = -errno;
<a name="l01197"></a>01197                         <span class="keywordflow">goto</span> end;
<a name="l01198"></a>01198                 }
<a name="l01199"></a>01199         }
<a name="l01200"></a>01200 
<a name="l01201"></a>01201 end:
<a name="l01202"></a>01202         <span class="comment">/* In some cases, like restore, 2 FIDs are used.</span>
<a name="l01203"></a>01203 <span class="comment">         * Set the right FID to use here. */</span>
<a name="l01204"></a>01204         <span class="keywordflow">if</span> (hai-&gt;hai_action == HSMA_ARCHIVE || hai-&gt;hai_action == HSMA_RESTORE)
<a name="l01205"></a>01205                 hai-&gt;hai_fid = hai-&gt;hai_dfid;
<a name="l01206"></a>01206 
<a name="l01207"></a>01207         <span class="comment">/* Fill the last missing data that will be needed by</span>
<a name="l01208"></a>01208 <span class="comment">         * kernel to send a hsm_progress. */</span>
<a name="l01209"></a>01209         hcp-&gt;copy.hc_flags  = hp_flags;
<a name="l01210"></a>01210         hcp-&gt;copy.hc_errval = abs(errval);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212         hcp-&gt;copy.hc_hai.hai_extent = *he;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214         rc = ioctl(hcp-&gt;ct_priv-&gt;mnt_fd, LL_IOC_HSM_COPY_END, &amp;hcp-&gt;copy);
<a name="l01215"></a>01215         <span class="keywordflow">if</span> (rc) {
<a name="l01216"></a>01216                 rc = -errno;
<a name="l01217"></a>01217                 <span class="keywordflow">goto</span> err_cleanup;
<a name="l01218"></a>01218         }
<a name="l01219"></a>01219 
<a name="l01220"></a>01220         llapi_hsm_log_ct_progress(&amp;hcp, hai, CT_FINISH, 0, 0);
<a name="l01221"></a>01221 
<a name="l01222"></a>01222 err_cleanup:
<a name="l01223"></a>01223         <span class="keywordflow">if</span> (!(hcp-&gt;data_fd &lt; 0))
<a name="l01224"></a>01224                 close(hcp-&gt;data_fd);
<a name="l01225"></a>01225 
<a name="l01226"></a>01226         free(hcp);
<a name="l01227"></a>01227         *phcp = NULL;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229         <span class="keywordflow">return</span> rc;
<a name="l01230"></a>01230 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4ca1f4f67749a9a11d48ea661f8ec2f8"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_action_get_dfid" ref="ga4ca1f4f67749a9a11d48ea661f8ec2f8" args="(const struct hsm_copyaction_private *hcp, lustre_fid *fid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_action_get_dfid </td>
          <td>(</td>
          <td class="paramtype">const struct hsm_copyaction_private *&nbsp;</td>
          <td class="paramname"> <em>hcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlu__fid.html">lustre_fid</a> *&nbsp;</td>
          <td class="paramname"> <em>fid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the fid of object to be used for copying data. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>error code if the action is not a copy operation. </dd></dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01276">1276</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01278"></a>01278 {
<a name="l01279"></a>01279         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structhsm__action__item.html">hsm_action_item</a>    *hai = &amp;hcp-&gt;copy.hc_hai;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281         <span class="keywordflow">if</span> (hcp-&gt;magic != CP_PRIV_MAGIC)
<a name="l01282"></a>01282                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01283"></a>01283 
<a name="l01284"></a>01284         <span class="keywordflow">if</span> (hai-&gt;hai_action != HSMA_RESTORE &amp;&amp; hai-&gt;hai_action != HSMA_ARCHIVE)
<a name="l01285"></a>01285                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287         *fid = hai-&gt;hai_dfid;
<a name="l01288"></a>01288 
<a name="l01289"></a>01289         <span class="keywordflow">return</span> 0;
<a name="l01290"></a>01290 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaba84da0225c8950975c3ad76aa402abd"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_action_get_fd" ref="gaba84da0225c8950975c3ad76aa402abd" args="(const struct hsm_copyaction_private *hcp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_action_get_fd </td>
          <td>(</td>
          <td class="paramtype">const struct hsm_copyaction_private *&nbsp;</td>
          <td class="paramname"> <em>hcp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a file descriptor to be used for copying data. </p>
<p>It's up to the caller to close the FDs obtained from this function.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>file descriptor on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>negative error code on failure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01299">1299</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01300"></a>01300 {
<a name="l01301"></a>01301         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structhsm__action__item.html">hsm_action_item</a>    *hai = &amp;hcp-&gt;copy.hc_hai;
<a name="l01302"></a>01302         <span class="keywordtype">int</span> fd;
<a name="l01303"></a>01303 
<a name="l01304"></a>01304         <span class="keywordflow">if</span> (hcp-&gt;magic != CP_PRIV_MAGIC)
<a name="l01305"></a>01305                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01306"></a>01306 
<a name="l01307"></a>01307         <span class="keywordflow">if</span> (hai-&gt;hai_action == HSMA_ARCHIVE) {
<a name="l01308"></a>01308                 <span class="keywordflow">return</span> ct_open_by_fid(hcp-&gt;ct_priv, &amp;hai-&gt;hai_dfid,
<a name="l01309"></a>01309                                 O_RDONLY | O_NOATIME | O_NOFOLLOW | O_NONBLOCK);
<a name="l01310"></a>01310         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hai-&gt;hai_action == HSMA_RESTORE) {
<a name="l01311"></a>01311                 fd = dup(hcp-&gt;data_fd);
<a name="l01312"></a>01312                 <span class="keywordflow">return</span> fd &lt; 0 ? -errno : fd;
<a name="l01313"></a>01313         } <span class="keywordflow">else</span> {
<a name="l01314"></a>01314                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01315"></a>01315         }
<a name="l01316"></a>01316 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga5cc2899f0dbc4a8ec90d6bd0b9b6fe17"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_action_progress" ref="ga5cc2899f0dbc4a8ec90d6bd0b9b6fe17" args="(struct hsm_copyaction_private *hcp, const struct hsm_extent *he, __u64 total, int hp_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_action_progress </td>
          <td>(</td>
          <td class="paramtype">struct hsm_copyaction_private *&nbsp;</td>
          <td class="paramname"> <em>hcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhsm__extent.html">hsm_extent</a> *&nbsp;</td>
          <td class="paramname"> <em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hp_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify a progress in processing an HSM action. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hdl[in,out]</em>&nbsp;</td><td>handle returned by llapi_hsm_action_start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>he[in]</em>&nbsp;</td><td>the range of copied data (for copy actions). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>total[in]</em>&nbsp;</td><td>the expected total of copied data (for copy actions). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hp_flags[in]</em>&nbsp;</td><td>HSM progress flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01239">1239</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01242"></a>01242 {
<a name="l01243"></a>01243         <span class="keywordtype">int</span>                      rc;
<a name="l01244"></a>01244         <span class="keyword">struct </span><a class="code" href="structhsm__progress.html">hsm_progress</a>      hp;
<a name="l01245"></a>01245         <span class="keyword">struct </span><a class="code" href="structhsm__action__item.html">hsm_action_item</a>  *hai;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247         <span class="keywordflow">if</span> (hcp == NULL || he == NULL)
<a name="l01248"></a>01248                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01249"></a>01249 
<a name="l01250"></a>01250         <span class="keywordflow">if</span> (hcp-&gt;magic != CP_PRIV_MAGIC)
<a name="l01251"></a>01251                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01252"></a>01252 
<a name="l01253"></a>01253         hai = &amp;hcp-&gt;copy.hc_hai;
<a name="l01254"></a>01254 
<a name="l01255"></a>01255         memset(&amp;hp, 0, <span class="keyword">sizeof</span>(hp));
<a name="l01256"></a>01256 
<a name="l01257"></a>01257         hp.hp_cookie = hai-&gt;hai_cookie;
<a name="l01258"></a>01258         hp.hp_flags  = hp_flags;
<a name="l01259"></a>01259 
<a name="l01260"></a>01260         <span class="comment">/* Progress is made on the data fid */</span>
<a name="l01261"></a>01261         hp.hp_fid = hai-&gt;hai_dfid;
<a name="l01262"></a>01262         hp.hp_extent = *he;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264         rc = ioctl(hcp-&gt;ct_priv-&gt;mnt_fd, LL_IOC_HSM_PROGRESS, &amp;hp);
<a name="l01265"></a>01265         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01266"></a>01266                 rc = -errno;
<a name="l01267"></a>01267 
<a name="l01268"></a>01268         llapi_hsm_log_ct_progress(&amp;hcp, hai, CT_RUNNING, total, he-&gt;length);
<a name="l01269"></a>01269 
<a name="l01270"></a>01270         <span class="keywordflow">return</span> rc;
<a name="l01271"></a>01271 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga694b0437493484e145b1713c7a1bb9cd"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_copytool_get_fd" ref="ga694b0437493484e145b1713c7a1bb9cd" args="(struct hsm_copytool_private *ct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_copytool_get_fd </td>
          <td>(</td>
          <td class="paramtype">struct hsm_copytool_private *&nbsp;</td>
          <td class="paramname"> <em>ct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a file descriptor to poll/select on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ct</em>&nbsp;</td><td>Opaque private control structure </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>on error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>the</em>&nbsp;</td><td>file descriptor for reading HSM events from the kernel </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l00838">838</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00839"></a>00839 {
<a name="l00840"></a>00840         <span class="keywordflow">if</span> (ct == NULL || ct-&gt;magic != CT_PRIV_MAGIC)
<a name="l00841"></a>00841                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843         <span class="keywordflow">return</span> libcfs_ukuc_get_rfd(&amp;ct-&gt;kuc);
<a name="l00844"></a>00844 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad18af809c2dda475e759db9e2b066418"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_copytool_recv" ref="gad18af809c2dda475e759db9e2b066418" args="(struct hsm_copytool_private *priv, struct hsm_action_list **hal, int *msgsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_copytool_recv </td>
          <td>(</td>
          <td class="paramtype">struct hsm_copytool_private *&nbsp;</td>
          <td class="paramname"> <em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhsm__action__list.html">hsm_action_list</a> **&nbsp;</td>
          <td class="paramname"> <em>halh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>msgsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the next <a class="el" href="structhsm__action__list.html">hsm_action_list</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ct</em>&nbsp;</td><td>Opaque private control structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>halh</em>&nbsp;</td><td>Action list handle, will be allocated here </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msgsize</em>&nbsp;</td><td>Number of bytes in the message, will be set here </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 valid message received; halh and msgsize are set &lt;0 error code Note: The application must not call llapi_hsm_copytool_recv until it has cleared the data in ct-&gt;kuch from the previous call. </dd></dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l00855">855</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00857"></a>00857 {
<a name="l00858"></a>00858         <span class="keyword">struct </span><a class="code" href="structkuc__hdr.html">kuc_hdr</a>          *kuch;
<a name="l00859"></a>00859         <span class="keyword">struct </span><a class="code" href="structhsm__action__list.html">hsm_action_list</a>  *hal;
<a name="l00860"></a>00860         <span class="keywordtype">int</span>                      rc = 0;
<a name="l00861"></a>00861 
<a name="l00862"></a>00862         <span class="keywordflow">if</span> (ct == NULL || ct-&gt;magic != CT_PRIV_MAGIC)
<a name="l00863"></a>00863                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865         <span class="keywordflow">if</span> (halh == NULL || msgsize == NULL)
<a name="l00866"></a>00866                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868         kuch = ct-&gt;kuch;
<a name="l00869"></a>00869 
<a name="l00870"></a>00870 repeat:
<a name="l00871"></a>00871         rc = libcfs_ukuc_msg_get(&amp;ct-&gt;kuc, (<span class="keywordtype">char</span> *)kuch,
<a name="l00872"></a>00872                                  HAL_MAXSIZE + <span class="keyword">sizeof</span>(*kuch),
<a name="l00873"></a>00873                                  KUC_TRANSPORT_HSM);
<a name="l00874"></a>00874         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00875"></a>00875                 <span class="keywordflow">goto</span> out_err;
<a name="l00876"></a>00876 
<a name="l00877"></a>00877         <span class="comment">/* Handle generic messages */</span>
<a name="l00878"></a>00878         <span class="keywordflow">if</span> (kuch-&gt;kuc_transport == KUC_TRANSPORT_GENERIC &amp;&amp;
<a name="l00879"></a>00879             kuch-&gt;kuc_msgtype == KUC_MSG_SHUTDOWN) {
<a name="l00880"></a>00880                 rc = -ESHUTDOWN;
<a name="l00881"></a>00881                 <span class="keywordflow">goto</span> out_err;
<a name="l00882"></a>00882         }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884         <span class="keywordflow">if</span> (kuch-&gt;kuc_transport != KUC_TRANSPORT_HSM ||
<a name="l00885"></a>00885             kuch-&gt;kuc_msgtype != HMT_ACTION_LIST) {
<a name="l00886"></a>00886                 llapi_err_noerrno(LLAPI_MSG_ERROR,
<a name="l00887"></a>00887                                   <span class="stringliteral">&quot;Unknown HSM message type %d:%d\n&quot;</span>,
<a name="l00888"></a>00888                                   kuch-&gt;kuc_transport, kuch-&gt;kuc_msgtype);
<a name="l00889"></a>00889                 rc = -EPROTO;
<a name="l00890"></a>00890                 <span class="keywordflow">goto</span> out_err;
<a name="l00891"></a>00891         }
<a name="l00892"></a>00892 
<a name="l00893"></a>00893         <span class="keywordflow">if</span> (kuch-&gt;kuc_msglen &lt; <span class="keyword">sizeof</span>(*kuch) + <span class="keyword">sizeof</span>(*hal)) {
<a name="l00894"></a>00894                 llapi_err_noerrno(LLAPI_MSG_ERROR, <span class="stringliteral">&quot;Short HSM message %d&quot;</span>,
<a name="l00895"></a>00895                                   kuch-&gt;kuc_msglen);
<a name="l00896"></a>00896                 rc = -EPROTO;
<a name="l00897"></a>00897                 <span class="keywordflow">goto</span> out_err;
<a name="l00898"></a>00898         }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900         <span class="comment">/* Our message is a hsm_action_list. Use pointer math to skip</span>
<a name="l00901"></a>00901 <span class="comment">        * kuch_hdr and point directly to the message payload.</span>
<a name="l00902"></a>00902 <span class="comment">        */</span>
<a name="l00903"></a>00903         hal = (<span class="keyword">struct </span><a class="code" href="structhsm__action__list.html">hsm_action_list</a> *)(kuch + 1);
<a name="l00904"></a>00904 
<a name="l00905"></a>00905         <span class="comment">/* Check that we have registered for this archive #</span>
<a name="l00906"></a>00906 <span class="comment">         * if 0 registered, we serve any archive */</span>
<a name="l00907"></a>00907         <span class="keywordflow">if</span> (ct-&gt;archives &amp;&amp;
<a name="l00908"></a>00908             ((1 &lt;&lt; (hal-&gt;hal_archive_id - 1)) &amp; ct-&gt;archives) == 0) {
<a name="l00909"></a>00909                 llapi_err_noerrno(LLAPI_MSG_INFO,
<a name="l00910"></a>00910                                   <span class="stringliteral">&quot;This copytool does not service archive #%d,&quot;</span>
<a name="l00911"></a>00911                                   <span class="stringliteral">&quot; ignoring this request.&quot;</span>
<a name="l00912"></a>00912                                   <span class="stringliteral">&quot; Mask of served archive is 0x%.8X&quot;</span>,
<a name="l00913"></a>00913                                   hal-&gt;hal_archive_id, ct-&gt;archives);
<a name="l00914"></a>00914 
<a name="l00915"></a>00915                 <span class="keywordflow">goto</span> repeat;
<a name="l00916"></a>00916         }
<a name="l00917"></a>00917 
<a name="l00918"></a>00918         *halh = hal;
<a name="l00919"></a>00919         *msgsize = kuch-&gt;kuc_msglen - <span class="keyword">sizeof</span>(*kuch);
<a name="l00920"></a>00920         <span class="keywordflow">return</span> 0;
<a name="l00921"></a>00921 
<a name="l00922"></a>00922 out_err:
<a name="l00923"></a>00923         *halh = NULL;
<a name="l00924"></a>00924         *msgsize = 0;
<a name="l00925"></a>00925         <span class="keywordflow">return</span> rc;
<a name="l00926"></a>00926 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga56090f57d464ed01de0443ca66f39d18"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_copytool_register" ref="ga56090f57d464ed01de0443ca66f39d18" args="(struct hsm_copytool_private **priv, const char *mnt, int archive_count, int *archives, int rfd_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_copytool_register </td>
          <td>(</td>
          <td class="paramtype">struct hsm_copytool_private **&nbsp;</td>
          <td class="paramname"> <em>priv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>archive_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>archives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rfd_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a copytool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>priv</em>&nbsp;</td><td>Opaque private control structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mnt</em>&nbsp;</td><td>Lustre filesystem mount point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>archive_count</em>&nbsp;</td><td>Number of valid archive IDs in <em>archives</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>archives</em>&nbsp;</td><td>Which archive numbers this copytool is responsible for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rfd_flags</em>&nbsp;</td><td>flags applied to read fd of pipe (e.g. O_NONBLOCK)</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l00676">676</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00679"></a>00679 {
<a name="l00680"></a>00680         <span class="keyword">struct </span>hsm_copytool_private     *ct;
<a name="l00681"></a>00681         <span class="keywordtype">int</span>                              rc;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         <span class="keywordflow">if</span> (archive_count &gt; 0 &amp;&amp; archives == NULL) {
<a name="l00684"></a>00684                 llapi_err_noerrno(LLAPI_MSG_ERROR,
<a name="l00685"></a>00685                                   <span class="stringliteral">&quot;NULL archive numbers&quot;</span>);
<a name="l00686"></a>00686                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00687"></a>00687         }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         <span class="keywordflow">if</span> (archive_count &gt; LL_HSM_MAX_ARCHIVE) {
<a name="l00690"></a>00690                 llapi_err_noerrno(LLAPI_MSG_ERROR, <span class="stringliteral">&quot;%d requested when maximum &quot;</span>
<a name="l00691"></a>00691                                   <span class="stringliteral">&quot;of %zu archives supported&quot;</span>, archive_count,
<a name="l00692"></a>00692                                   LL_HSM_MAX_ARCHIVE);
<a name="l00693"></a>00693                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00694"></a>00694         }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696         ct = calloc(1, <span class="keyword">sizeof</span>(*ct));
<a name="l00697"></a>00697         <span class="keywordflow">if</span> (ct == NULL)
<a name="l00698"></a>00698                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00699"></a>00699 
<a name="l00700"></a>00700         ct-&gt;magic = CT_PRIV_MAGIC;
<a name="l00701"></a>00701         ct-&gt;mnt_fd = -1;
<a name="l00702"></a>00702         ct-&gt;open_by_fid_fd = -1;
<a name="l00703"></a>00703         ct-&gt;kuc.lk_rfd = LK_NOFD;
<a name="l00704"></a>00704         ct-&gt;kuc.lk_wfd = LK_NOFD;
<a name="l00705"></a>00705 
<a name="l00706"></a>00706         ct-&gt;mnt = strdup(mnt);
<a name="l00707"></a>00707         <span class="keywordflow">if</span> (ct-&gt;mnt == NULL) {
<a name="l00708"></a>00708                 rc = -ENOMEM;
<a name="l00709"></a>00709                 <span class="keywordflow">goto</span> out_err;
<a name="l00710"></a>00710         }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         ct-&gt;kuch = malloc(HAL_MAXSIZE + <span class="keyword">sizeof</span>(*ct-&gt;kuch));
<a name="l00713"></a>00713         <span class="keywordflow">if</span> (ct-&gt;kuch == NULL) {
<a name="l00714"></a>00714                 rc = -ENOMEM;
<a name="l00715"></a>00715                 <span class="keywordflow">goto</span> out_err;
<a name="l00716"></a>00716         }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718         ct-&gt;mnt_fd = open(ct-&gt;mnt, O_RDONLY);
<a name="l00719"></a>00719         <span class="keywordflow">if</span> (ct-&gt;mnt_fd &lt; 0) {
<a name="l00720"></a>00720                 rc = -errno;
<a name="l00721"></a>00721                 <span class="keywordflow">goto</span> out_err;
<a name="l00722"></a>00722         }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         ct-&gt;open_by_fid_fd = openat(ct-&gt;mnt_fd, OPEN_BY_FID_PATH, O_RDONLY);
<a name="l00725"></a>00725         <span class="keywordflow">if</span> (ct-&gt;open_by_fid_fd &lt; 0) {
<a name="l00726"></a>00726                 rc = -errno;
<a name="l00727"></a>00727                 <span class="keywordflow">goto</span> out_err;
<a name="l00728"></a>00728         }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="comment">/* no archives specified means &quot;match all&quot;. */</span>
<a name="l00731"></a>00731         ct-&gt;archives = 0;
<a name="l00732"></a>00732         <span class="keywordflow">for</span> (rc = 0; rc &lt; archive_count; rc++) {
<a name="l00733"></a>00733                 <span class="keywordflow">if</span> ((archives[rc] &gt; LL_HSM_MAX_ARCHIVE) || (archives[rc] &lt; 0)) {
<a name="l00734"></a>00734                         llapi_err_noerrno(LLAPI_MSG_ERROR, <span class="stringliteral">&quot;%d requested when &quot;</span>
<a name="l00735"></a>00735                                           <span class="stringliteral">&quot;archive id [0 - %zu] is supported&quot;</span>,
<a name="l00736"></a>00736                                           archives[rc], LL_HSM_MAX_ARCHIVE);
<a name="l00737"></a>00737                         rc = -EINVAL;
<a name="l00738"></a>00738                         <span class="keywordflow">goto</span> out_err;
<a name="l00739"></a>00739                 }
<a name="l00740"></a>00740                 <span class="comment">/* in the list we have an all archive wildcard</span>
<a name="l00741"></a>00741 <span class="comment">                 * so move to all archives mode</span>
<a name="l00742"></a>00742 <span class="comment">                 */</span>
<a name="l00743"></a>00743                 <span class="keywordflow">if</span> (archives[rc] == 0) {
<a name="l00744"></a>00744                         ct-&gt;archives = 0;
<a name="l00745"></a>00745                         archive_count = 0;
<a name="l00746"></a>00746                         <span class="keywordflow">break</span>;
<a name="l00747"></a>00747                 }
<a name="l00748"></a>00748                 ct-&gt;archives |= (1 &lt;&lt; (archives[rc] - 1));
<a name="l00749"></a>00749         }
<a name="l00750"></a>00750 
<a name="l00751"></a>00751         rc = libcfs_ukuc_start(&amp;ct-&gt;kuc, KUC_GRP_HSM, rfd_flags);
<a name="l00752"></a>00752         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00753"></a>00753                 <span class="keywordflow">goto</span> out_err;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755         <span class="comment">/* Storing archive(s) in lk_data; see mdc_ioc_hsm_ct_start */</span>
<a name="l00756"></a>00756         ct-&gt;kuc.lk_data = ct-&gt;archives;
<a name="l00757"></a>00757         rc = ioctl(ct-&gt;mnt_fd, LL_IOC_HSM_CT_START, &amp;ct-&gt;kuc);
<a name="l00758"></a>00758         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00759"></a>00759                 rc = -errno;
<a name="l00760"></a>00760                 llapi_error(LLAPI_MSG_ERROR, rc,
<a name="l00761"></a>00761                             <span class="stringliteral">&quot;cannot start copytool on &apos;%s&apos;&quot;</span>, mnt);
<a name="l00762"></a>00762                 <span class="keywordflow">goto</span> out_kuc;
<a name="l00763"></a>00763         }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765         llapi_hsm_log_ct_registration(&amp;ct, CT_REGISTER);
<a name="l00766"></a>00766 
<a name="l00767"></a>00767         <span class="comment">/* Only the kernel reference keeps the write side open */</span>
<a name="l00768"></a>00768         close(ct-&gt;kuc.lk_wfd);
<a name="l00769"></a>00769         ct-&gt;kuc.lk_wfd = LK_NOFD;
<a name="l00770"></a>00770         *priv = ct;
<a name="l00771"></a>00771 
<a name="l00772"></a>00772         <span class="keywordflow">return</span> 0;
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 out_kuc:
<a name="l00775"></a>00775         <span class="comment">/* cleanup the kuc channel */</span>
<a name="l00776"></a>00776         libcfs_ukuc_stop(&amp;ct-&gt;kuc);
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 out_err:
<a name="l00779"></a>00779         <span class="keywordflow">if</span> (!(ct-&gt;mnt_fd &lt; 0))
<a name="l00780"></a>00780                 close(ct-&gt;mnt_fd);
<a name="l00781"></a>00781 
<a name="l00782"></a>00782         <span class="keywordflow">if</span> (!(ct-&gt;open_by_fid_fd &lt; 0))
<a name="l00783"></a>00783                 close(ct-&gt;open_by_fid_fd);
<a name="l00784"></a>00784 
<a name="l00785"></a>00785         free(ct-&gt;mnt);
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         free(ct-&gt;kuch);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789         free(ct);
<a name="l00790"></a>00790 
<a name="l00791"></a>00791         <span class="keywordflow">return</span> rc;
<a name="l00792"></a>00792 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf26452d9f0f67d7b3efa39bc790c8349"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_current_action" ref="gaf26452d9f0f67d7b3efa39bc790c8349" args="(const char *path, struct hsm_current_action *hca)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_current_action </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhsm__current__action.html">hsm_current_action</a> *&nbsp;</td>
          <td class="paramname"> <em>hca</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current HSM request related to file pointed by <em>path</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hca</em>&nbsp;</td><td>Should be allocated by caller. Will be filled with current file actions.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01495">1495</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01496"></a>01496 {
<a name="l01497"></a>01497         <span class="keywordtype">int</span> fd;
<a name="l01498"></a>01498         <span class="keywordtype">int</span> rc;
<a name="l01499"></a>01499 
<a name="l01500"></a>01500         fd = open(path, O_RDONLY | O_NONBLOCK);
<a name="l01501"></a>01501         <span class="keywordflow">if</span> (fd &lt; 0)
<a name="l01502"></a>01502                 <span class="keywordflow">return</span> -errno;
<a name="l01503"></a>01503 
<a name="l01504"></a>01504         rc = ioctl(fd, LL_IOC_HSM_ACTION, hca);
<a name="l01505"></a>01505         <span class="comment">/* If error, save errno value */</span>
<a name="l01506"></a>01506         rc = rc ? -errno : 0;
<a name="l01507"></a>01507 
<a name="l01508"></a>01508         close(fd);
<a name="l01509"></a>01509         <span class="keywordflow">return</span> rc;
<a name="l01510"></a>01510 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga42de7c318652c45b7b86df855b6dd201"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_import" ref="ga42de7c318652c45b7b86df855b6dd201" args="(const char *dst, int archive, const struct stat *st, unsigned long long stripe_size, int stripe_offset, int stripe_count, int stripe_pattern, char *pool_name, lustre_fid *newfid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_import </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct stat *&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>stripe_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stripe_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stripe_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stripe_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pool_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlu__fid.html">lustre_fid</a> *&nbsp;</td>
          <td class="paramname"> <em>newfid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Import an existing hsm-archived file into Lustre. </p>
<p>Caller must access file by (returned) newfid value from now on.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>path to Lustre destination (e.g. /mnt/lustre/my/file). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>archive</em>&nbsp;</td><td>archive number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td>struct stat buffer containing file ownership, perm, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stripe_*</em>&nbsp;</td><td>Striping options. Currently ignored, since the restore operation will set the striping. In V2, this striping might be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newfid[out]</em>&nbsp;</td><td>Filled with new Lustre fid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01331">1331</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01335"></a>01335 {
<a name="l01336"></a>01336         <span class="keyword">struct </span><a class="code" href="structhsm__user__import.html">hsm_user_import</a>   hui;
<a name="l01337"></a>01337         <span class="keywordtype">int</span>                      fd;
<a name="l01338"></a>01338         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01339"></a>01339 
<a name="l01340"></a>01340         <span class="keywordflow">if</span> (stripe_pattern == 0)
<a name="l01341"></a>01341                 stripe_pattern = LOV_PATTERN_RAID0;
<a name="l01342"></a>01342 
<a name="l01343"></a>01343         <span class="comment">/* Create a non-striped file */</span>
<a name="l01344"></a>01344         fd = llapi_file_open_pool(dst, O_CREAT | O_WRONLY, st-&gt;st_mode,
<a name="l01345"></a>01345                                   stripe_size, stripe_offset, stripe_count,
<a name="l01346"></a>01346                                   stripe_pattern | LOV_PATTERN_F_RELEASED,
<a name="l01347"></a>01347                                   pool_name);
<a name="l01348"></a>01348         <span class="keywordflow">if</span> (fd &lt; 0) {
<a name="l01349"></a>01349                 llapi_error(LLAPI_MSG_ERROR, fd,
<a name="l01350"></a>01350                             <span class="stringliteral">&quot;cannot create &apos;%s&apos; for import&quot;</span>, dst);
<a name="l01351"></a>01351                 <span class="keywordflow">return</span> fd;
<a name="l01352"></a>01352         }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354         <span class="comment">/* Get the new fid in Lustre. Caller needs to use this fid</span>
<a name="l01355"></a>01355 <span class="comment">           from now on. */</span>
<a name="l01356"></a>01356         rc = llapi_fd2fid(fd, newfid);
<a name="l01357"></a>01357         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01358"></a>01358                 llapi_error(LLAPI_MSG_ERROR, rc,
<a name="l01359"></a>01359                             <span class="stringliteral">&quot;cannot get fid of &apos;%s&apos; for import&quot;</span>, dst);
<a name="l01360"></a>01360                 <span class="keywordflow">goto</span> out_unlink;
<a name="l01361"></a>01361         }
<a name="l01362"></a>01362 
<a name="l01363"></a>01363         hui.hui_uid = st-&gt;st_uid;
<a name="l01364"></a>01364         hui.hui_gid = st-&gt;st_gid;
<a name="l01365"></a>01365         hui.hui_mode = st-&gt;st_mode;
<a name="l01366"></a>01366         hui.hui_size = st-&gt;st_size;
<a name="l01367"></a>01367         hui.hui_archive_id = archive;
<a name="l01368"></a>01368         hui.hui_atime = st-&gt;st_atime;
<a name="l01369"></a>01369         hui.hui_atime_ns = st-&gt;st_atim.tv_nsec;
<a name="l01370"></a>01370         hui.hui_mtime = st-&gt;st_mtime;
<a name="l01371"></a>01371         hui.hui_mtime_ns = st-&gt;st_mtim.tv_nsec;
<a name="l01372"></a>01372         rc = ioctl(fd, LL_IOC_HSM_IMPORT, &amp;hui);
<a name="l01373"></a>01373         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01374"></a>01374                 rc = -errno;
<a name="l01375"></a>01375                 llapi_error(LLAPI_MSG_ERROR, rc, <span class="stringliteral">&quot;cannot import &apos;%s&apos;&quot;</span>, dst);
<a name="l01376"></a>01376                 <span class="keywordflow">goto</span> out_unlink;
<a name="l01377"></a>01377         }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379 out_unlink:
<a name="l01380"></a>01380         <span class="keywordflow">if</span> (fd &gt;= 0)
<a name="l01381"></a>01381                 close(fd);
<a name="l01382"></a>01382         <span class="keywordflow">if</span> (rc)
<a name="l01383"></a>01383                 unlink(dst);
<a name="l01384"></a>01384         <span class="keywordflow">return</span> rc;
<a name="l01385"></a>01385 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac7cd8c58323ebb952e44bc3864a680f3"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_log_error" ref="gac7cd8c58323ebb952e44bc3864a680f3" args="(enum llapi_message_level level, int _rc, const char *fmt, va_list args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void llapi_hsm_log_error </td>
          <td>(</td>
          <td class="paramtype">enum llapi_message_level&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>_rc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Custom logging callback to be used when a monitoring FIFO has been registered. </p>
<p>Formats log entries as JSON events suitable for consumption by a copytool monitoring process.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>The message loglevel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_rc</em>&nbsp;</td><td>The returncode associated with the message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>The message format string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>Arguments to be formatted by the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l00574">574</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p>References <a class="el" href="liblustreapi__json_8c_source.html#l00255">llapi_json_add_item()</a>, <a class="el" href="liblustreapi__json_8c_source.html#l00207">llapi_json_destroy_list()</a>, and <a class="el" href="liblustreapi__json_8c_source.html#l00186">llapi_json_init_list()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00576"></a>00576 {
<a name="l00577"></a>00577         <span class="keywordtype">int</span>                             rc;
<a name="l00578"></a>00578         <span class="keywordtype">int</span>                             msg_len;
<a name="l00579"></a>00579         <span class="keywordtype">int</span>                             real_level;
<a name="l00580"></a>00580         <span class="keywordtype">char</span>                            *msg = NULL;
<a name="l00581"></a>00581         va_list                         args2;
<a name="l00582"></a>00582         <span class="keyword">struct </span><a class="code" href="structllapi__json__item__list.html">llapi_json_item_list</a>     *json_items;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584         <span class="comment">/* Noop unless the event fd was initialized */</span>
<a name="l00585"></a>00585         <span class="keywordflow">if</span> (llapi_hsm_event_fd &lt; 0)
<a name="l00586"></a>00586                 <span class="keywordflow">return</span>;
<a name="l00587"></a>00587 
<a name="l00588"></a>00588         rc = <a class="code" href="group__llapi.html#gab01607fc36bd8fc5fef69a350b1bfc15" title="Create a list to hold JSON items.">llapi_json_init_list</a>(&amp;json_items);
<a name="l00589"></a>00589         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00590"></a>00590                 <span class="keywordflow">goto</span> err;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         <span class="keywordflow">if</span> ((level &amp; LLAPI_MSG_NO_ERRNO) == 0) {
<a name="l00593"></a>00593                 rc = <a class="code" href="group__llapi.html#ga988c169fbd79a5424e9890b6638fb88a" title="Add an item to a list of JSON items.">llapi_json_add_item</a>(&amp;json_items, <span class="stringliteral">&quot;errno&quot;</span>,
<a name="l00594"></a>00594                                          LLAPI_JSON_INTEGER,
<a name="l00595"></a>00595                                          &amp;_rc);
<a name="l00596"></a>00596                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00597"></a>00597                         <span class="keywordflow">goto</span> err;
<a name="l00598"></a>00598 
<a name="l00599"></a>00599                 rc = <a class="code" href="group__llapi.html#ga988c169fbd79a5424e9890b6638fb88a" title="Add an item to a list of JSON items.">llapi_json_add_item</a>(&amp;json_items, <span class="stringliteral">&quot;error&quot;</span>,
<a name="l00600"></a>00600                                          LLAPI_JSON_STRING,
<a name="l00601"></a>00601                                          strerror(abs(_rc)));
<a name="l00602"></a>00602                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00603"></a>00603                         <span class="keywordflow">goto</span> err;
<a name="l00604"></a>00604         }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606         va_copy(args2, args);
<a name="l00607"></a>00607         msg_len = vsnprintf(NULL, 0, fmt, args2) + 1;
<a name="l00608"></a>00608         va_end(args2);
<a name="l00609"></a>00609         <span class="keywordflow">if</span> (msg_len &gt;= 0) {
<a name="l00610"></a>00610                 msg = (<span class="keywordtype">char</span> *) alloca(msg_len);
<a name="l00611"></a>00611                 <span class="keywordflow">if</span> (msg == NULL) {
<a name="l00612"></a>00612                         rc = -ENOMEM;
<a name="l00613"></a>00613                         <span class="keywordflow">goto</span> err;
<a name="l00614"></a>00614                 }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616                 rc = vsnprintf(msg, msg_len, fmt, args);
<a name="l00617"></a>00617                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00618"></a>00618                         <span class="keywordflow">goto</span> err;
<a name="l00619"></a>00619 
<a name="l00620"></a>00620                 rc = <a class="code" href="group__llapi.html#ga988c169fbd79a5424e9890b6638fb88a" title="Add an item to a list of JSON items.">llapi_json_add_item</a>(&amp;json_items, <span class="stringliteral">&quot;message&quot;</span>,
<a name="l00621"></a>00621                                          LLAPI_JSON_STRING,
<a name="l00622"></a>00622                                          msg);
<a name="l00623"></a>00623                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00624"></a>00624                         <span class="keywordflow">goto</span> err;
<a name="l00625"></a>00625         } <span class="keywordflow">else</span> {
<a name="l00626"></a>00626                 rc = <a class="code" href="group__llapi.html#ga988c169fbd79a5424e9890b6638fb88a" title="Add an item to a list of JSON items.">llapi_json_add_item</a>(&amp;json_items, <span class="stringliteral">&quot;message&quot;</span>,
<a name="l00627"></a>00627                                          LLAPI_JSON_STRING,
<a name="l00628"></a>00628                                          <span class="stringliteral">&quot;INTERNAL ERROR: message failed&quot;</span>);
<a name="l00629"></a>00629                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00630"></a>00630                         <span class="keywordflow">goto</span> err;
<a name="l00631"></a>00631         }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633         real_level = level &amp; LLAPI_MSG_NO_ERRNO;
<a name="l00634"></a>00634         real_level = real_level &gt; 0 ? level - LLAPI_MSG_NO_ERRNO : level;
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         rc = <a class="code" href="group__llapi.html#ga988c169fbd79a5424e9890b6638fb88a" title="Add an item to a list of JSON items.">llapi_json_add_item</a>(&amp;json_items, <span class="stringliteral">&quot;level&quot;</span>, LLAPI_JSON_STRING,
<a name="l00637"></a>00637                                  (<span class="keywordtype">void</span> *)llapi_msg_level2str(real_level));
<a name="l00638"></a>00638         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00639"></a>00639                 <span class="keywordflow">goto</span> err;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641         rc = <a class="code" href="group__llapi.html#ga988c169fbd79a5424e9890b6638fb88a" title="Add an item to a list of JSON items.">llapi_json_add_item</a>(&amp;json_items, <span class="stringliteral">&quot;event_type&quot;</span>, LLAPI_JSON_STRING,
<a name="l00642"></a>00642                                  <span class="stringliteral">&quot;LOGGED_MESSAGE&quot;</span>);
<a name="l00643"></a>00643         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00644"></a>00644                 <span class="keywordflow">goto</span> err;
<a name="l00645"></a>00645 
<a name="l00646"></a>00646         rc = llapi_hsm_write_json_event(&amp;json_items);
<a name="l00647"></a>00647         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00648"></a>00648                 <span class="keywordflow">goto</span> err;
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         <span class="keywordflow">goto</span> out_free;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 err:
<a name="l00653"></a>00653         <span class="comment">/* Write directly to stderr to avoid llapi_error, which now</span>
<a name="l00654"></a>00654 <span class="comment">         * emits JSON event messages. */</span>
<a name="l00655"></a>00655         fprintf(stderr, <span class="stringliteral">&quot;\nFATAL ERROR IN llapi_hsm_log_error(): rc %d,&quot;</span>, rc);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657 out_free:
<a name="l00658"></a>00658         <span class="keywordflow">if</span> (json_items != NULL)
<a name="l00659"></a>00659                 <a class="code" href="group__llapi.html#ga4b4263f06c811155591bcd320ced1b2b" title="Deallocate a list of JSON items.">llapi_json_destroy_list</a>(&amp;json_items);
<a name="l00660"></a>00660 
<a name="l00661"></a>00661         <span class="keywordflow">return</span>;
<a name="l00662"></a>00662 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__llapi_gac7cd8c58323ebb952e44bc3864a680f3_cgraph.png" border="0" usemap="#group__llapi_gac7cd8c58323ebb952e44bc3864a680f3_cgraph_map" alt=""></div>
<map name="group__llapi_gac7cd8c58323ebb952e44bc3864a680f3_cgraph_map" id="group__llapi_gac7cd8c58323ebb952e44bc3864a680f3_cgraph">
<area shape="rect" id="node3" href="group__llapi.html#ga988c169fbd79a5424e9890b6638fb88a" title="Add an item to a list of JSON items." alt="" coords="209,5,359,35"/><area shape="rect" id="node5" href="group__llapi.html#ga4b4263f06c811155591bcd320ced1b2b" title="Deallocate a list of JSON items." alt="" coords="201,59,367,88"/><area shape="rect" id="node7" href="group__llapi.html#gab01607fc36bd8fc5fef69a350b1bfc15" title="Create a list to hold JSON items." alt="" coords="216,112,352,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga89cbac22a82ac6a421bb2aab980c1c3e"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_register_event_fifo" ref="ga89cbac22a82ac6a421bb2aab980c1c3e" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_register_event_fifo </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a path to a FIFO, create a filehandle for nonblocking writes to it. </p>
<p>Intended to be used for copytool monitoring processes that read an event stream from the FIFO. Events written in the absence of a reader are lost.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>Path to monitor FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l00473">473</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00474"></a>00474 {
<a name="l00475"></a>00475         <span class="keywordtype">int</span> read_fd;
<a name="l00476"></a>00476         <span class="keyword">struct </span>stat statbuf;
<a name="l00477"></a>00477         <span class="keyword">struct </span>sigaction ignore_action;
<a name="l00478"></a>00478         <span class="keywordtype">int</span> rc;
<a name="l00479"></a>00479 
<a name="l00480"></a>00480         <span class="comment">/* Create the FIFO if necessary. */</span>
<a name="l00481"></a>00481         <span class="keywordflow">if</span> ((mkfifo(path, 0644) &lt; 0) &amp;&amp; (errno != EEXIST)) {
<a name="l00482"></a>00482                 llapi_error(LLAPI_MSG_ERROR, errno, <span class="stringliteral">&quot;mkfifo(%s) failed&quot;</span>, path);
<a name="l00483"></a>00483                 <span class="keywordflow">return</span> -errno;
<a name="l00484"></a>00484         }
<a name="l00485"></a>00485         <span class="keywordflow">if</span> (errno == EEXIST) {
<a name="l00486"></a>00486                 <span class="keywordflow">if</span> (stat(path, &amp;statbuf) &lt; 0) {
<a name="l00487"></a>00487                         llapi_error(LLAPI_MSG_ERROR, errno, <span class="stringliteral">&quot;mkfifo(%s) failed&quot;</span>,
<a name="l00488"></a>00488                                     path);
<a name="l00489"></a>00489                         <span class="keywordflow">return</span> -errno;
<a name="l00490"></a>00490                 }
<a name="l00491"></a>00491                 <span class="keywordflow">if</span> (!S_ISFIFO(statbuf.st_mode) ||
<a name="l00492"></a>00492                     ((statbuf.st_mode &amp; 0777) != 0644)) {
<a name="l00493"></a>00493                         llapi_error(LLAPI_MSG_ERROR, errno, <span class="stringliteral">&quot;%s exists but is &quot;</span>
<a name="l00494"></a>00494                                     <span class="stringliteral">&quot;not a pipe or has a wrong mode&quot;</span>, path);
<a name="l00495"></a>00495                         <span class="keywordflow">return</span> -errno;
<a name="l00496"></a>00496                 }
<a name="l00497"></a>00497         } <span class="keywordflow">else</span> {
<a name="l00498"></a>00498                 created_hsm_event_fifo = <span class="keyword">true</span>;
<a name="l00499"></a>00499         }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501         <span class="comment">/* Open the FIFO for read so that the subsequent open for write</span>
<a name="l00502"></a>00502 <span class="comment">         * doesn&apos;t immediately fail. */</span>
<a name="l00503"></a>00503         read_fd = open(path, O_RDONLY | O_NONBLOCK);
<a name="l00504"></a>00504         <span class="keywordflow">if</span> (read_fd &lt; 0) {
<a name="l00505"></a>00505                 llapi_error(LLAPI_MSG_ERROR, errno,
<a name="l00506"></a>00506                             <span class="stringliteral">&quot;cannot open(%s) for read&quot;</span>, path);
<a name="l00507"></a>00507                 <span class="keywordflow">return</span> -errno;
<a name="l00508"></a>00508         }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         <span class="comment">/* Open the FIFO for writes, but don&apos;t block on waiting</span>
<a name="l00511"></a>00511 <span class="comment">         * for a reader. */</span>
<a name="l00512"></a>00512         llapi_hsm_event_fd = open(path, O_WRONLY | O_NONBLOCK);
<a name="l00513"></a>00513         rc = -errno;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <span class="comment">/* Now close the reader. An external monitoring process can</span>
<a name="l00516"></a>00516 <span class="comment">         * now open the FIFO for reads. If no reader comes along the</span>
<a name="l00517"></a>00517 <span class="comment">         * events are lost. NOTE: Only one reader at a time! */</span>
<a name="l00518"></a>00518         close(read_fd);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520         <span class="keywordflow">if</span> (llapi_hsm_event_fd &lt; 0) {
<a name="l00521"></a>00521                 llapi_error(LLAPI_MSG_ERROR, -rc,
<a name="l00522"></a>00522                             <span class="stringliteral">&quot;cannot open(%s) for write&quot;</span>, path);
<a name="l00523"></a>00523                 <span class="keywordflow">return</span> rc;
<a name="l00524"></a>00524         }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <span class="comment">/* Ignore SIGPIPEs -- can occur if the reader goes away. */</span>
<a name="l00527"></a>00527         memset(&amp;ignore_action, 0, <span class="keyword">sizeof</span>(ignore_action));
<a name="l00528"></a>00528         ignore_action.sa_handler = SIG_IGN;
<a name="l00529"></a>00529         sigemptyset(&amp;ignore_action.sa_mask);
<a name="l00530"></a>00530         sigaction(SIGPIPE, &amp;ignore_action, NULL);
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         <span class="keywordflow">return</span> 0;
<a name="l00533"></a>00533 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaad5620c10129544e26bb083f32d0c8e2"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_request" ref="gaad5620c10129544e26bb083f32d0c8e2" args="(const char *path, const struct hsm_user_request *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_request </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhsm__user__request.html">hsm_user_request</a> *&nbsp;</td>
          <td class="paramname"> <em>request</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a HSM request to Lustre, described in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>request.</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>Fullpath to the file to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>request</em>&nbsp;</td><td>The request, allocated with <a class="el" href="group__llapi.html#gae20de186e5b139de98e0a772517676b4" title="Allocate a hsm_user_request with the specified carateristics.">llapi_hsm_user_request_alloc()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, an error code otherwise. </dd></dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01538">1538</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01539"></a>01539 {
<a name="l01540"></a>01540         <span class="keywordtype">int</span> rc;
<a name="l01541"></a>01541         <span class="keywordtype">int</span> fd;
<a name="l01542"></a>01542 
<a name="l01543"></a>01543         rc = get_root_path(WANT_FD, NULL, &amp;fd, (<span class="keywordtype">char</span> *)path, -1);
<a name="l01544"></a>01544         <span class="keywordflow">if</span> (rc)
<a name="l01545"></a>01545                 <span class="keywordflow">return</span> rc;
<a name="l01546"></a>01546 
<a name="l01547"></a>01547         rc = ioctl(fd, LL_IOC_HSM_REQUEST, request);
<a name="l01548"></a>01548         <span class="comment">/* If error, save errno value */</span>
<a name="l01549"></a>01549         rc = rc ? -errno : 0;
<a name="l01550"></a>01550 
<a name="l01551"></a>01551         close(fd);
<a name="l01552"></a>01552         <span class="keywordflow">return</span> rc;
<a name="l01553"></a>01553 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga625517cdce6cc479801e10f24fe80bcb"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_state_get" ref="ga625517cdce6cc479801e10f24fe80bcb" args="(const char *path, struct hsm_user_state *hus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_state_get </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhsm__user__state.html">hsm_user_state</a> *&nbsp;</td>
          <td class="paramname"> <em>hus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current HSM states and HSM requests related to file pointed by <em>path</em>. </p>
<p>see <a class="el" href="group__llapi.html#gae27f3f88ec0e797b2c1a7df9d029b2a7" title="Return the current HSM states and HSM requests related to file pointed by path.">llapi_hsm_state_get_fd()</a> for args use and return </p>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01414">1414</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p>References <a class="el" href="liblustreapi__hsm_8c_source.html#l01397">llapi_hsm_state_get_fd()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01415"></a>01415 {
<a name="l01416"></a>01416         <span class="keywordtype">int</span> fd;
<a name="l01417"></a>01417         <span class="keywordtype">int</span> rc;
<a name="l01418"></a>01418 
<a name="l01419"></a>01419         fd = open(path, O_RDONLY | O_NONBLOCK);
<a name="l01420"></a>01420         <span class="keywordflow">if</span> (fd &lt; 0)
<a name="l01421"></a>01421                 <span class="keywordflow">return</span> -errno;
<a name="l01422"></a>01422 
<a name="l01423"></a>01423         rc = <a class="code" href="group__llapi.html#gae27f3f88ec0e797b2c1a7df9d029b2a7" title="Return the current HSM states and HSM requests related to file pointed by path.">llapi_hsm_state_get_fd</a>(fd, hus);
<a name="l01424"></a>01424 
<a name="l01425"></a>01425         close(fd);
<a name="l01426"></a>01426         <span class="keywordflow">return</span> rc;
<a name="l01427"></a>01427 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__llapi_ga625517cdce6cc479801e10f24fe80bcb_cgraph.png" border="0" usemap="#group__llapi_ga625517cdce6cc479801e10f24fe80bcb_cgraph_map" alt=""></div>
<map name="group__llapi_ga625517cdce6cc479801e10f24fe80bcb_cgraph_map" id="group__llapi_ga625517cdce6cc479801e10f24fe80bcb_cgraph">
<area shape="rect" id="node3" href="group__llapi.html#gae27f3f88ec0e797b2c1a7df9d029b2a7" title="Return the current HSM states and HSM requests related to file pointed by path." alt="" coords="213,5,392,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gae27f3f88ec0e797b2c1a7df9d029b2a7"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_state_get_fd" ref="gae27f3f88ec0e797b2c1a7df9d029b2a7" args="(int fd, struct hsm_user_state *hus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_state_get_fd </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhsm__user__state.html">hsm_user_state</a> *&nbsp;</td>
          <td class="paramname"> <em>hus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current HSM states and HSM requests related to file pointed by <em>path</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hus</em>&nbsp;</td><td>Should be allocated by caller. Will be filled with current file states.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01397">1397</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p>Referenced by <a class="el" href="liblustreapi__hsm_8c_source.html#l01414">llapi_hsm_state_get()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01398"></a>01398 {
<a name="l01399"></a>01399         <span class="keywordtype">int</span> rc;
<a name="l01400"></a>01400 
<a name="l01401"></a>01401         rc = ioctl(fd, LL_IOC_HSM_STATE_GET, hus);
<a name="l01402"></a>01402         <span class="comment">/* If error, save errno value */</span>
<a name="l01403"></a>01403         rc = rc ? -errno : 0;
<a name="l01404"></a>01404 
<a name="l01405"></a>01405         <span class="keywordflow">return</span> rc;
<a name="l01406"></a>01406 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__llapi_gae27f3f88ec0e797b2c1a7df9d029b2a7_icgraph.png" border="0" usemap="#group__llapi_gae27f3f88ec0e797b2c1a7df9d029b2a7_icgraph_map" alt=""></div>
<map name="group__llapi_gae27f3f88ec0e797b2c1a7df9d029b2a7_icgraph_map" id="group__llapi_gae27f3f88ec0e797b2c1a7df9d029b2a7_icgraph">
<area shape="rect" id="node3" href="group__llapi.html#ga625517cdce6cc479801e10f24fe80bcb" title="Return the current HSM states and HSM requests related to file pointed by path." alt="" coords="233,5,391,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga255ceef5caae75d4aee04f646bd71685"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_state_set" ref="ga255ceef5caae75d4aee04f646bd71685" args="(const char *path, __u64 setmask, __u64 clearmask, __u32 archive_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_state_set </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>setmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>clearmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>archive_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set HSM states of file pointed by <em>path</em>. </p>
<p>see <a class="el" href="group__llapi.html#gaa69acaf39672b0964307795fac1f19db" title="Set HSM states of file pointed by fd.">llapi_hsm_state_set_fd()</a> for args use and return </p>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01470">1470</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p>References <a class="el" href="liblustreapi__hsm_8c_source.html#l01443">llapi_hsm_state_set_fd()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01472"></a>01472 {
<a name="l01473"></a>01473         <span class="keywordtype">int</span> fd;
<a name="l01474"></a>01474         <span class="keywordtype">int</span> rc;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476         fd = open(path, O_WRONLY | O_LOV_DELAY_CREATE | O_NONBLOCK);
<a name="l01477"></a>01477         <span class="keywordflow">if</span> (fd &lt; 0)
<a name="l01478"></a>01478                 <span class="keywordflow">return</span> -errno;
<a name="l01479"></a>01479 
<a name="l01480"></a>01480         rc = <a class="code" href="group__llapi.html#gaa69acaf39672b0964307795fac1f19db" title="Set HSM states of file pointed by fd.">llapi_hsm_state_set_fd</a>(fd, setmask, clearmask, archive_id);
<a name="l01481"></a>01481 
<a name="l01482"></a>01482         close(fd);
<a name="l01483"></a>01483         <span class="keywordflow">return</span> rc;
<a name="l01484"></a>01484 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__llapi_ga255ceef5caae75d4aee04f646bd71685_cgraph.png" border="0" usemap="#group__llapi_ga255ceef5caae75d4aee04f646bd71685_cgraph_map" alt=""></div>
<map name="group__llapi_ga255ceef5caae75d4aee04f646bd71685_cgraph_map" id="group__llapi_ga255ceef5caae75d4aee04f646bd71685_cgraph">
<area shape="rect" id="node3" href="group__llapi.html#gaa69acaf39672b0964307795fac1f19db" title="Set HSM states of file pointed by fd." alt="" coords="212,5,388,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa69acaf39672b0964307795fac1f19db"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_state_set_fd" ref="gaa69acaf39672b0964307795fac1f19db" args="(int fd, __u64 setmask, __u64 clearmask, __u32 archive_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_state_set_fd </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>setmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>clearmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>archive_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set HSM states of file pointed by <em>fd</em>. </p>
<p>Using the provided bitmasks, the current HSM states for this file will be changed. <em>archive_id</em> could be used to change the archive number also. Set it to 0 if you do not want to change it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setmask</em>&nbsp;</td><td>Bitmask for flag to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clearmask</em>&nbsp;</td><td>Bitmask for flag to be cleared. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>archive_id</em>&nbsp;</td><td>Archive number identifier to use. 0 means no change.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01443">1443</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p>Referenced by <a class="el" href="liblustreapi__hsm_8c_source.html#l01470">llapi_hsm_state_set()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01445"></a>01445 {
<a name="l01446"></a>01446         <span class="keyword">struct </span><a class="code" href="structhsm__state__set.html">hsm_state_set</a>     hss;
<a name="l01447"></a>01447         <span class="keywordtype">int</span>                      rc;
<a name="l01448"></a>01448 
<a name="l01449"></a>01449         hss.hss_valid = HSS_SETMASK|HSS_CLEARMASK;
<a name="l01450"></a>01450         hss.hss_setmask = setmask;
<a name="l01451"></a>01451         hss.hss_clearmask = clearmask;
<a name="l01452"></a>01452         <span class="comment">/* Change archive_id if provided. We can only change</span>
<a name="l01453"></a>01453 <span class="comment">         * to set something different than 0. */</span>
<a name="l01454"></a>01454         <span class="keywordflow">if</span> (archive_id &gt; 0) {
<a name="l01455"></a>01455                 hss.hss_valid |= HSS_ARCHIVE_ID;
<a name="l01456"></a>01456                 hss.hss_archive_id = archive_id;
<a name="l01457"></a>01457         }
<a name="l01458"></a>01458         rc = ioctl(fd, LL_IOC_HSM_STATE_SET, &amp;hss);
<a name="l01459"></a>01459         <span class="comment">/* If error, save errno value */</span>
<a name="l01460"></a>01460         rc = rc ? -errno : 0;
<a name="l01461"></a>01461 
<a name="l01462"></a>01462         <span class="keywordflow">return</span> rc;
<a name="l01463"></a>01463 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__llapi_gaa69acaf39672b0964307795fac1f19db_icgraph.png" border="0" usemap="#group__llapi_gaa69acaf39672b0964307795fac1f19db_icgraph_map" alt=""></div>
<map name="group__llapi_gaa69acaf39672b0964307795fac1f19db_icgraph_map" id="group__llapi_gaa69acaf39672b0964307795fac1f19db_icgraph">
<area shape="rect" id="node3" href="group__llapi.html#ga255ceef5caae75d4aee04f646bd71685" title="Set HSM states of file pointed by path." alt="" coords="232,5,389,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gac7e96e99dacac05914034918fc2114b8"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_unregister_event_fifo" ref="gac7e96e99dacac05914034918fc2114b8" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_hsm_unregister_event_fifo </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a path to a FIFO, close its filehandle and delete the FIFO. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>Path to monitor FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l00543">543</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00544"></a>00544 {
<a name="l00545"></a>00545         <span class="comment">/* Noop unless the event fd was initialized */</span>
<a name="l00546"></a>00546         <span class="keywordflow">if</span> (llapi_hsm_event_fd &lt; 0)
<a name="l00547"></a>00547                 <span class="keywordflow">return</span> 0;
<a name="l00548"></a>00548 
<a name="l00549"></a>00549         <span class="keywordflow">if</span> (close(llapi_hsm_event_fd) &lt; 0)
<a name="l00550"></a>00550                 <span class="keywordflow">return</span> -errno;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         <span class="keywordflow">if</span> (created_hsm_event_fifo) {
<a name="l00553"></a>00553                 unlink(path);
<a name="l00554"></a>00554                 created_hsm_event_fifo = <span class="keyword">false</span>;
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         llapi_hsm_event_fd = -1;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559         <span class="keywordflow">return</span> 0;
<a name="l00560"></a>00560 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae20de186e5b139de98e0a772517676b4"></a><!-- doxytag: member="lustreapi.h::llapi_hsm_user_request_alloc" ref="gae20de186e5b139de98e0a772517676b4" args="(int itemcount, int data_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structhsm__user__request.html">hsm_user_request</a>* llapi_hsm_user_request_alloc </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>itemcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>data_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a <a class="el" href="structhsm__user__request.html">hsm_user_request</a> with the specified carateristics. </p>
<p>This structure should be freed with free().</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an allocated structure on success, NULL otherwise. </dd></dl>

<p>Definition at line <a class="el" href="liblustreapi__hsm_8c_source.html#l01518">1518</a> of file <a class="el" href="liblustreapi__hsm_8c_source.html">liblustreapi_hsm.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01520"></a>01520 {
<a name="l01521"></a>01521         <span class="keywordtype">int</span> len = 0;
<a name="l01522"></a>01522 
<a name="l01523"></a>01523         len += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structhsm__user__request.html">hsm_user_request</a>);
<a name="l01524"></a>01524         len += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structhsm__user__item.html">hsm_user_item</a>) * itemcount;
<a name="l01525"></a>01525         len += data_len;
<a name="l01526"></a>01526 
<a name="l01527"></a>01527         <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structhsm__user__request.html">hsm_user_request</a> *)malloc(len);
<a name="l01528"></a>01528 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa794f0f94fc56b7d5ded3b97ad8f966c"></a><!-- doxytag: member="lustreapi.h::llapi_info_callback_set" ref="gaa794f0f94fc56b7d5ded3b97ad8f966c" args="(llapi_log_callback_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llapi_log_callback_t llapi_info_callback_set </td>
          <td>(</td>
          <td class="paramtype">llapi_log_callback_t&nbsp;</td>
          <td class="paramname"> <em>cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a custom info logging function. </p>
<p>Passing in NULL will reset the logging callback to its default value.</p>
<p>This function returns the value of the old callback. </p>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l00174">174</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00175"></a>00175 {
<a name="l00176"></a>00176         llapi_log_callback_t    old = llapi_info_callback;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178         <span class="keywordflow">if</span> (cb != NULL)
<a name="l00179"></a>00179                 llapi_info_callback = cb;
<a name="l00180"></a>00180         <span class="keywordflow">else</span>
<a name="l00181"></a>00181                 llapi_info_callback = info_callback_default;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183         <span class="keywordflow">return</span> old;
<a name="l00184"></a>00184 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga988c169fbd79a5424e9890b6638fb88a"></a><!-- doxytag: member="lustreapi.h::llapi_json_add_item" ref="ga988c169fbd79a5424e9890b6638fb88a" args="(struct llapi_json_item_list **item_list, char *key, __u32 type, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_json_add_item </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structllapi__json__item__list.html">llapi_json_item_list</a> **&nbsp;</td>
          <td class="paramname"> <em>json_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an item to a list of JSON items. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>json_items</em>&nbsp;</td><td>Item list handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Item key name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Item key type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Item key value</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__json_8c_source.html#l00255">255</a> of file <a class="el" href="liblustreapi__json_8c_source.html">liblustreapi_json.c</a>.</p>

<p>Referenced by <a class="el" href="liblustreapi__hsm_8c_source.html#l00574">llapi_hsm_log_error()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00257"></a>00257 {
<a name="l00258"></a>00258         <span class="keyword">struct </span><a class="code" href="structllapi__json__item__list.html">llapi_json_item_list</a>     *list;
<a name="l00259"></a>00259         <span class="keyword">struct </span><a class="code" href="structllapi__json__item.html">llapi_json_item</a>          *new_item;
<a name="l00260"></a>00260         <span class="keywordtype">size_t</span> len;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         <span class="keywordflow">if</span> (json_items == NULL || *json_items == NULL)
<a name="l00263"></a>00263                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265         <span class="keywordflow">if</span> (val == NULL)
<a name="l00266"></a>00266                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         list = *json_items;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         new_item = calloc(1, <span class="keyword">sizeof</span>(*new_item));
<a name="l00271"></a>00271         <span class="keywordflow">if</span> (new_item == NULL)
<a name="l00272"></a>00272                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274         len = strlen(key) + 1;
<a name="l00275"></a>00275         new_item-&gt;lji_key = calloc(len, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00276"></a>00276         <span class="keywordflow">if</span> (new_item-&gt;lji_key == NULL)
<a name="l00277"></a>00277                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279         strlcpy(new_item-&gt;lji_key, key, len);
<a name="l00280"></a>00280         new_item-&gt;lji_type = type;
<a name="l00281"></a>00281         new_item-&gt;lji_next = NULL;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283         <span class="keywordflow">switch</span> (new_item-&gt;lji_type) {
<a name="l00284"></a>00284         <span class="keywordflow">case</span> LLAPI_JSON_INTEGER:
<a name="l00285"></a>00285                 new_item-&gt;lji_integer = *(<span class="keywordtype">int</span> *)val;
<a name="l00286"></a>00286                 <span class="keywordflow">break</span>;
<a name="l00287"></a>00287         <span class="keywordflow">case</span> LLAPI_JSON_BIGNUM:
<a name="l00288"></a>00288                 new_item-&gt;lji_u64 = *(__u64 *)val;
<a name="l00289"></a>00289                 <span class="keywordflow">break</span>;
<a name="l00290"></a>00290         <span class="keywordflow">case</span> LLAPI_JSON_REAL:
<a name="l00291"></a>00291                 new_item-&gt;lji_real = *(<span class="keywordtype">double</span> *)val;
<a name="l00292"></a>00292                 <span class="keywordflow">break</span>;
<a name="l00293"></a>00293         <span class="keywordflow">case</span> LLAPI_JSON_STRING:
<a name="l00294"></a>00294                 len = strlen((<span class="keywordtype">char</span> *)val) + 1;
<a name="l00295"></a>00295                 new_item-&gt;lji_string = calloc(len, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00296"></a>00296                 <span class="keywordflow">if</span> (new_item-&gt;lji_string == NULL)
<a name="l00297"></a>00297                         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00298"></a>00298                 strlcpy(new_item-&gt;lji_string, (<span class="keywordtype">char</span> *)val, len);
<a name="l00299"></a>00299                 <span class="keywordflow">break</span>;
<a name="l00300"></a>00300         <span class="keywordflow">default</span>:
<a name="l00301"></a>00301                 llapi_err_noerrno(LLAPI_MSG_ERROR, <span class="stringliteral">&quot;Unknown JSON type: %d&quot;</span>,
<a name="l00302"></a>00302                                   new_item-&gt;lji_type);
<a name="l00303"></a>00303                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00304"></a>00304         }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306         <span class="keywordflow">if</span> (list-&gt;ljil_item_count == 0) {
<a name="l00307"></a>00307                 list-&gt;ljil_items = new_item;
<a name="l00308"></a>00308         } <span class="keywordflow">else</span> {
<a name="l00309"></a>00309                 new_item-&gt;lji_next = list-&gt;ljil_items;
<a name="l00310"></a>00310                 list-&gt;ljil_items = new_item;
<a name="l00311"></a>00311         }
<a name="l00312"></a>00312         list-&gt;ljil_item_count++;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314         <span class="keywordflow">return</span> 0;
<a name="l00315"></a>00315 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__llapi_ga988c169fbd79a5424e9890b6638fb88a_icgraph.png" border="0" usemap="#group__llapi_ga988c169fbd79a5424e9890b6638fb88a_icgraph_map" alt=""></div>
<map name="group__llapi_ga988c169fbd79a5424e9890b6638fb88a_icgraph_map" id="group__llapi_ga988c169fbd79a5424e9890b6638fb88a_icgraph">
<area shape="rect" id="node3" href="group__llapi.html#gac7cd8c58323ebb952e44bc3864a680f3" title="Custom logging callback to be used when a monitoring FIFO has been registered." alt="" coords="205,5,352,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga4b4263f06c811155591bcd320ced1b2b"></a><!-- doxytag: member="lustreapi.h::llapi_json_destroy_list" ref="ga4b4263f06c811155591bcd320ced1b2b" args="(struct llapi_json_item_list **item_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_json_destroy_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structllapi__json__item__list.html">llapi_json_item_list</a> **&nbsp;</td>
          <td class="paramname"> <em>json_items</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate a list of JSON items. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>json_items</em>&nbsp;</td><td>Item list handle, deallocated here</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__json_8c_source.html#l00207">207</a> of file <a class="el" href="liblustreapi__json_8c_source.html">liblustreapi_json.c</a>.</p>

<p>Referenced by <a class="el" href="liblustreapi__hsm_8c_source.html#l00574">llapi_hsm_log_error()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00208"></a>00208 {
<a name="l00209"></a>00209         <span class="keywordtype">int</span>                             i;
<a name="l00210"></a>00210         <span class="keyword">struct </span><a class="code" href="structllapi__json__item__list.html">llapi_json_item_list</a>     *list;
<a name="l00211"></a>00211         <span class="keyword">struct </span><a class="code" href="structllapi__json__item.html">llapi_json_item</a>          *cur_item;
<a name="l00212"></a>00212         <span class="keyword">struct </span><a class="code" href="structllapi__json__item.html">llapi_json_item</a>          *last_item;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (json_items == NULL || *json_items == NULL)
<a name="l00215"></a>00215                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         list = *json_items;
<a name="l00218"></a>00218         cur_item = list-&gt;ljil_items;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         <span class="keywordflow">for</span> (i = 0; i &lt; list-&gt;ljil_item_count; i++) {
<a name="l00221"></a>00221                 <span class="keywordflow">if</span> (cur_item == NULL) {
<a name="l00222"></a>00222                         llapi_err_noerrno(LLAPI_MSG_ERROR,
<a name="l00223"></a>00223                                           <span class="stringliteral">&quot;%d json items but %d is NULL!&quot;</span>,
<a name="l00224"></a>00224                                           list-&gt;ljil_item_count, i);
<a name="l00225"></a>00225                         <span class="keywordflow">return</span> -EINVAL;
<a name="l00226"></a>00226                 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228                 <span class="keywordflow">if</span> (cur_item-&gt;lji_key != NULL)
<a name="l00229"></a>00229                         free(cur_item-&gt;lji_key);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231                 <span class="keywordflow">if</span> (cur_item-&gt;lji_type == LLAPI_JSON_STRING
<a name="l00232"></a>00232                     &amp;&amp; cur_item-&gt;lji_string != NULL)
<a name="l00233"></a>00233                         free(cur_item-&gt;lji_string);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235                 last_item = cur_item;
<a name="l00236"></a>00236                 cur_item = last_item-&gt;lji_next;
<a name="l00237"></a>00237                 free(last_item);
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240         free(list);
<a name="l00241"></a>00241         *json_items = NULL;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243         <span class="keywordflow">return</span> 0;
<a name="l00244"></a>00244 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__llapi_ga4b4263f06c811155591bcd320ced1b2b_icgraph.png" border="0" usemap="#group__llapi_ga4b4263f06c811155591bcd320ced1b2b_icgraph_map" alt=""></div>
<map name="group__llapi_ga4b4263f06c811155591bcd320ced1b2b_icgraph_map" id="group__llapi_ga4b4263f06c811155591bcd320ced1b2b_icgraph">
<area shape="rect" id="node3" href="group__llapi.html#gac7cd8c58323ebb952e44bc3864a680f3" title="Custom logging callback to be used when a monitoring FIFO has been registered." alt="" coords="221,5,368,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gab01607fc36bd8fc5fef69a350b1bfc15"></a><!-- doxytag: member="lustreapi.h::llapi_json_init_list" ref="gab01607fc36bd8fc5fef69a350b1bfc15" args="(struct llapi_json_item_list **item_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_json_init_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structllapi__json__item__list.html">llapi_json_item_list</a> **&nbsp;</td>
          <td class="paramname"> <em>json_items</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a list to hold JSON items. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>json_items</em>&nbsp;</td><td>Item list handle, allocated here</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__json_8c_source.html#l00186">186</a> of file <a class="el" href="liblustreapi__json_8c_source.html">liblustreapi_json.c</a>.</p>

<p>Referenced by <a class="el" href="liblustreapi__hsm_8c_source.html#l00574">llapi_hsm_log_error()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00187"></a>00187 {
<a name="l00188"></a>00188         <span class="keyword">struct </span><a class="code" href="structllapi__json__item__list.html">llapi_json_item_list</a>     *new_list;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         new_list = calloc(1, <span class="keyword">sizeof</span>(*new_list));
<a name="l00191"></a>00191         <span class="keywordflow">if</span> (new_list == NULL)
<a name="l00192"></a>00192                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         new_list-&gt;ljil_item_count = 0;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         *json_items = new_list;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198         <span class="keywordflow">return</span> 0;
<a name="l00199"></a>00199 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__llapi_gab01607fc36bd8fc5fef69a350b1bfc15_icgraph.png" border="0" usemap="#group__llapi_gab01607fc36bd8fc5fef69a350b1bfc15_icgraph_map" alt=""></div>
<map name="group__llapi_gab01607fc36bd8fc5fef69a350b1bfc15_icgraph_map" id="group__llapi_gab01607fc36bd8fc5fef69a350b1bfc15_icgraph">
<area shape="rect" id="node3" href="group__llapi.html#gac7cd8c58323ebb952e44bc3864a680f3" title="Custom logging callback to be used when a monitoring FIFO has been registered." alt="" coords="189,5,336,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga00638df4cbfdb25fbc73e9a38ca39a8d"></a><!-- doxytag: member="lustreapi.h::llapi_json_write_list" ref="ga00638df4cbfdb25fbc73e9a38ca39a8d" args="(struct llapi_json_item_list **item_list, FILE *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_json_write_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structllapi__json__item__list.html">llapi_json_item_list</a> **&nbsp;</td>
          <td class="paramname"> <em>json_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a list of JSON items to a filehandle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>json_items</em>&nbsp;</td><td>list of JSON items to be written </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>open filehandle to use for write</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__json_8c_source.html#l00114">114</a> of file <a class="el" href="liblustreapi__json_8c_source.html">liblustreapi_json.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00115"></a>00115 {
<a name="l00116"></a>00116         <span class="keywordtype">int</span>                             i;
<a name="l00117"></a>00117         <span class="keywordtype">char</span>                            *escaped_string = NULL;
<a name="l00118"></a>00118         <span class="keyword">struct </span><a class="code" href="structllapi__json__item__list.html">llapi_json_item_list</a>     *list;
<a name="l00119"></a>00119         <span class="keyword">struct </span><a class="code" href="structllapi__json__item.html">llapi_json_item</a>          *item;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121         <span class="keywordflow">if</span> (json_items == NULL || *json_items == NULL)
<a name="l00122"></a>00122                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         list = *json_items;
<a name="l00125"></a>00125         item = list-&gt;ljil_items;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         fprintf(fp, <span class="stringliteral">&quot;{&quot;</span>);
<a name="l00128"></a>00128         <span class="keywordflow">for</span> (i = 0; i &lt; list-&gt;ljil_item_count; i++) {
<a name="l00129"></a>00129                 <span class="keywordflow">if</span> (item == NULL) {
<a name="l00130"></a>00130                         llapi_err_noerrno(LLAPI_MSG_ERROR,
<a name="l00131"></a>00131                                           <span class="stringliteral">&quot;%d json items but %d is NULL!&quot;</span>,
<a name="l00132"></a>00132                                           list-&gt;ljil_item_count, i);
<a name="l00133"></a>00133                         <span class="comment">/* Don&apos;t bomb out here so that we still emit</span>
<a name="l00134"></a>00134 <span class="comment">                         * valid JSON. */</span>
<a name="l00135"></a>00135                         <span class="keywordflow">break</span>;
<a name="l00136"></a>00136                 }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138                 fprintf(fp, <span class="stringliteral">&quot;\&quot;%s\&quot;: &quot;</span>, item-&gt;lji_key);
<a name="l00139"></a>00139                 <span class="keywordflow">switch</span> (item-&gt;lji_type) {
<a name="l00140"></a>00140                 <span class="keywordflow">case</span> LLAPI_JSON_INTEGER:
<a name="l00141"></a>00141                         fprintf(fp, <span class="stringliteral">&quot;%d&quot;</span>, item-&gt;lji_integer);
<a name="l00142"></a>00142                         <span class="keywordflow">break</span>;
<a name="l00143"></a>00143                 <span class="keywordflow">case</span> LLAPI_JSON_BIGNUM:
<a name="l00144"></a>00144                         fprintf(fp, <span class="stringliteral">&quot;%llu&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)item-&gt;lji_u64);
<a name="l00145"></a>00145                         <span class="keywordflow">break</span>;
<a name="l00146"></a>00146                 <span class="keywordflow">case</span> LLAPI_JSON_REAL:
<a name="l00147"></a>00147                         fprintf(fp, <span class="stringliteral">&quot;%f&quot;</span>, item-&gt;lji_real);
<a name="l00148"></a>00148                         <span class="keywordflow">break</span>;
<a name="l00149"></a>00149                 <span class="keywordflow">case</span> LLAPI_JSON_STRING:
<a name="l00150"></a>00150                         <span class="keywordflow">if</span> (llapi_json_escape_string(&amp;escaped_string,
<a name="l00151"></a>00151                                                      item-&gt;lji_string) &lt; 0) {
<a name="l00152"></a>00152                                 <span class="keywordflow">if</span> (escaped_string != NULL)
<a name="l00153"></a>00153                                         free(escaped_string);
<a name="l00154"></a>00154                                 <span class="keywordflow">return</span> -errno;
<a name="l00155"></a>00155                         }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157                         fprintf(fp, <span class="stringliteral">&quot;\&quot;%s\&quot;&quot;</span>, escaped_string);
<a name="l00158"></a>00158 
<a name="l00159"></a>00159                         <span class="keywordflow">if</span> (escaped_string != NULL)
<a name="l00160"></a>00160                                 free(escaped_string);
<a name="l00161"></a>00161                         <span class="keywordflow">break</span>;
<a name="l00162"></a>00162                 <span class="keywordflow">default</span>:
<a name="l00163"></a>00163                         llapi_err_noerrno(LLAPI_MSG_ERROR,
<a name="l00164"></a>00164                                     <span class="stringliteral">&quot;Invalid item type: %d&quot;</span>, item-&gt;lji_type);
<a name="l00165"></a>00165                         <span class="comment">/* Ensure valid JSON */</span>
<a name="l00166"></a>00166                         fprintf(fp, <span class="stringliteral">&quot;\&quot;\&quot;&quot;</span>);
<a name="l00167"></a>00167                         <span class="keywordflow">break</span>;
<a name="l00168"></a>00168                 }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170                 <span class="keywordflow">if</span> (i &lt; list-&gt;ljil_item_count - 1)
<a name="l00171"></a>00171                         fprintf(fp, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173                 item = item-&gt;lji_next;
<a name="l00174"></a>00174         }
<a name="l00175"></a>00175         fprintf(fp, <span class="stringliteral">&quot;}\n&quot;</span>);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         <span class="keywordflow">return</span> 0;
<a name="l00178"></a>00178 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga1d487541bbb98f50f4c34ef1259541bc"></a><!-- doxytag: member="lustreapi.h::llapi_lease_check" ref="ga1d487541bbb98f50f4c34ef1259541bc" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_lease_check </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a lease is still set on a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>File to check the lease on.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lease</em>&nbsp;</td><td>type if present (LL_LEASE_READ or LL_LEASE_WRITE). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if no lease is present. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__lease_8c_source.html#l00082">82</a> of file <a class="el" href="liblustreapi__lease_8c_source.html">liblustreapi_lease.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00083"></a>00083 {
<a name="l00084"></a>00084         <span class="keywordtype">int</span> rc;
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         rc = ioctl(fd, LL_IOC_GET_LEASE);
<a name="l00087"></a>00087         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00088"></a>00088                 rc = -errno;
<a name="l00089"></a>00089                 llapi_error(LLAPI_MSG_ERROR, rc, <span class="stringliteral">&quot;cannot check lease&quot;</span>);
<a name="l00090"></a>00090         }
<a name="l00091"></a>00091         <span class="keywordflow">return</span> rc;
<a name="l00092"></a>00092 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9ec0827918f89d7d933eedd3dbcfae3c"></a><!-- doxytag: member="lustreapi.h::llapi_lease_get" ref="ga9ec0827918f89d7d933eedd3dbcfae3c" args="(int fd, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_lease_get </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a lease on an open file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>File to get the lease on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Lease mode, either LL_LEASE_RDLCK or LL_LEASE_WRLCK.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__lease_8c_source.html#l00057">57</a> of file <a class="el" href="liblustreapi__lease_8c_source.html">liblustreapi_lease.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00058"></a>00058 {
<a name="l00059"></a>00059         <span class="keywordtype">int</span> rc;
<a name="l00060"></a>00060 
<a name="l00061"></a>00061         <span class="keywordflow">if</span> (mode != LL_LEASE_RDLCK &amp;&amp; mode != LL_LEASE_WRLCK)
<a name="l00062"></a>00062                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064         rc = ioctl(fd, LL_IOC_SET_LEASE, mode);
<a name="l00065"></a>00065         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00066"></a>00066                 rc = -errno;
<a name="l00067"></a>00067                 llapi_error(LLAPI_MSG_ERROR, rc, <span class="stringliteral">&quot;cannot get %s lease&quot;</span>,
<a name="l00068"></a>00068                             lease_mode2str(mode));
<a name="l00069"></a>00069         }
<a name="l00070"></a>00070         <span class="keywordflow">return</span> rc;
<a name="l00071"></a>00071 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga55e064e34e9b7c39ad03c5c4b1fb5af8"></a><!-- doxytag: member="lustreapi.h::llapi_lease_put" ref="ga55e064e34e9b7c39ad03c5c4b1fb5af8" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_lease_put </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a lease. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>File to remove the lease from.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>of the lease that was removed (LL_LEASE_READ or LL_LEASE_WRITE). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if no lease was present. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi__lease_8c_source.html#l00103">103</a> of file <a class="el" href="liblustreapi__lease_8c_source.html">liblustreapi_lease.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00104"></a>00104 {
<a name="l00105"></a>00105         <span class="keywordtype">int</span> rc;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         rc = ioctl(fd, LL_IOC_SET_LEASE, LL_LEASE_UNLCK);
<a name="l00108"></a>00108         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00109"></a>00109                 rc = -errno;
<a name="l00110"></a>00110                 llapi_error(LLAPI_MSG_ERROR, rc, <span class="stringliteral">&quot;cannot put lease&quot;</span>);
<a name="l00111"></a>00111         }
<a name="l00112"></a>00112         <span class="keywordflow">return</span> rc;
<a name="l00113"></a>00113 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga3ff3a2f29406fd45315a6ef7fc084bf0"></a><!-- doxytag: member="lustreapi.h::llapi_open_by_fid" ref="ga3ff3a2f29406fd45315a6ef7fc084bf0" args="(const char *dir, const lustre_fid *fid, int open_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int llapi_open_by_fid </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>lustre_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlu__fid.html">lustre_fid</a> *&nbsp;</td>
          <td class="paramname"> <em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to open a file with Lustre file identifier <em>fid</em> and return an open file descriptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lustre_dir</em>&nbsp;</td><td>path within Lustre filesystem containing <em>fid</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>Lustre file identifier of file to open </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>open() flags</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>non-negative</em>&nbsp;</td><td>file descriptor on successful open </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>if an error occurred </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="liblustreapi_8c_source.html#l04554">4554</a> of file <a class="el" href="liblustreapi_8c_source.html">liblustreapi.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l04555"></a>04555 {
<a name="l04556"></a>04556         <span class="keywordtype">char</span> mntdir[PATH_MAX];
<a name="l04557"></a>04557         <span class="keywordtype">char</span> path[PATH_MAX];
<a name="l04558"></a>04558         <span class="keywordtype">int</span> rc;
<a name="l04559"></a>04559 
<a name="l04560"></a>04560         rc = llapi_search_mounts(lustre_dir, 0, mntdir, NULL);
<a name="l04561"></a>04561         <span class="keywordflow">if</span> (rc != 0)
<a name="l04562"></a>04562                 <span class="keywordflow">return</span> -1;
<a name="l04563"></a>04563 
<a name="l04564"></a>04564         snprintf(path, <span class="keyword">sizeof</span>(path), <span class="stringliteral">&quot;%s/.lustre/fid/&quot;</span>DFID, mntdir, PFID(fid));
<a name="l04565"></a>04565         <span class="keywordflow">return</span> open(path, flags);
<a name="l04566"></a>04566 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:40 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
