<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/osp/osp_md_object.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/osp/osp_md_object.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.gnu.org/licenses/gpl-2.0.html</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * GPL HEADER END</span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 <span class="comment">/*</span>
<a name="l00023"></a>00023 <span class="comment"> * Copyright (c) 2013, 2015, Intel Corporation.</span>
<a name="l00024"></a>00024 <span class="comment"> */</span>
<a name="l00025"></a>00025 <span class="comment">/*</span>
<a name="l00026"></a>00026 <span class="comment"> * lustre/osp/osp_md_object.c</span>
<a name="l00027"></a>00027 <span class="comment"> *</span>
<a name="l00028"></a>00028 <span class="comment"> * OST/MDT proxy device (OSP) Metadata methods</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * This file implements methods for remote MD object, which include</span>
<a name="l00031"></a>00031 <span class="comment"> * dt_object_operations, dt_index_operations and dt_body_operations.</span>
<a name="l00032"></a>00032 <span class="comment"> *</span>
<a name="l00033"></a>00033 <span class="comment"> * If there are multiple MDTs in one filesystem, one operation might</span>
<a name="l00034"></a>00034 <span class="comment"> * include modifications in several MDTs. In such cases, clients</span>
<a name="l00035"></a>00035 <span class="comment"> * send the RPC to the master MDT, then the operation is decomposed into</span>
<a name="l00036"></a>00036 <span class="comment"> * object updates which will be dispatched to OSD or OSP. The local updates</span>
<a name="l00037"></a>00037 <span class="comment"> * go to local OSD and the remote updates go to OSP. In OSP, these remote</span>
<a name="l00038"></a>00038 <span class="comment"> * object updates will be packed into an update RPC, sent to the remote MDT</span>
<a name="l00039"></a>00039 <span class="comment"> * and handled by Object Update Target (OUT).</span>
<a name="l00040"></a>00040 <span class="comment"> *</span>
<a name="l00041"></a>00041 <span class="comment"> * In DNE phase I, because of missing complete recovery solution, updates</span>
<a name="l00042"></a>00042 <span class="comment"> * will be executed in order and synchronously.</span>
<a name="l00043"></a>00043 <span class="comment"> *     1. The transaction is created.</span>
<a name="l00044"></a>00044 <span class="comment"> *     2. In transaction declare, it collects and packs remote</span>
<a name="l00045"></a>00045 <span class="comment"> *        updates (in osp_md_declare_xxx()).</span>
<a name="l00046"></a>00046 <span class="comment"> *     3. In transaction start, it sends these remote updates</span>
<a name="l00047"></a>00047 <span class="comment"> *        to remote MDTs, which will execute these updates synchronously.</span>
<a name="l00048"></a>00048 <span class="comment"> *     4. In transaction execute phase, the local updates will be executed</span>
<a name="l00049"></a>00049 <span class="comment"> *        synchronously.</span>
<a name="l00050"></a>00050 <span class="comment"> *</span>
<a name="l00051"></a>00051 <span class="comment"> * Author: Di Wang &lt;di.wang@intel.com&gt;</span>
<a name="l00052"></a>00052 <span class="comment"> */</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_MDS</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;llog_swab.h&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;lustre_log.h&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;osp_internal.h&quot;</span>
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="preprocessor">#define OUT_UPDATE_BUFFER_SIZE_ADD      4096</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define OUT_UPDATE_BUFFER_SIZE_MAX      (256 * 4096)  </span><span class="comment">/*  1M update size now */</span>
<a name="l00062"></a>00062 
<a name="l00080"></a>00080 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_object_create_interpreter(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00081"></a>00081                                          <span class="keyword">struct</span> <a class="code" href="structobject__update__reply.html">object_update_reply</a> *reply,
<a name="l00082"></a>00082                                          <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00083"></a>00083                                          <span class="keyword">struct</span> <a class="code" href="structosp__object.html">osp_object</a> *obj,
<a name="l00084"></a>00084                                          <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> rc)
<a name="l00085"></a>00085 {
<a name="l00086"></a>00086         <span class="keywordflow">if</span> (rc != 0 &amp;&amp; rc != -EEXIST) {
<a name="l00087"></a>00087                 obj-&gt;opo_obj.do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a> &amp;= ~LOHA_EXISTS;
<a name="l00088"></a>00088                 obj-&gt;opo_non_exist = 1;
<a name="l00089"></a>00089         }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         <span class="comment">/* Invalid the opo cache for the object after the object</span>
<a name="l00092"></a>00092 <span class="comment">         * is being created, so attr_get will try to get attr</span>
<a name="l00093"></a>00093 <span class="comment">         * from the remote object. XXX this can be improved when</span>
<a name="l00094"></a>00094 <span class="comment">         * we have object lock/cache invalidate mechanism in OSP</span>
<a name="l00095"></a>00095 <span class="comment">         * layer */</span>
<a name="l00096"></a>00096         <span class="keywordflow">if</span> (obj-&gt;opo_ooa != NULL) {
<a name="l00097"></a>00097                 spin_lock(&amp;obj-&gt;opo_lock);
<a name="l00098"></a>00098                 obj-&gt;opo_ooa-&gt;ooa_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = 0;
<a name="l00099"></a>00099                 spin_unlock(&amp;obj-&gt;opo_lock);
<a name="l00100"></a>00100         }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102         <span class="keywordflow">return</span> 0;
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00121"></a>00121 <span class="keywordtype">int</span> osp_md_declare_object_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00122"></a>00122                                  <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00123"></a>00123                                  <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l00124"></a>00124                                  <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint,
<a name="l00125"></a>00125                                  <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof,
<a name="l00126"></a>00126                                  <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128         <span class="keyword">struct </span><a class="code" href="structosp__object.html">osp_object</a> *obj = dt2osp_obj(dt);
<a name="l00129"></a>00129         <span class="keywordtype">int</span>               rc;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <span class="keywordflow">if</span> (obj-&gt;opo_ooa == NULL) {
<a name="l00132"></a>00132                 rc = osp_oac_init(obj);
<a name="l00133"></a>00133                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00134"></a>00134                         <span class="keywordflow">return</span> rc;
<a name="l00135"></a>00135         }
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         <span class="keywordflow">return</span> osp_trans_update_request_create(th);
<a name="l00138"></a>00138 }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="keyword">struct </span><a class="code" href="structobject__update.html">object_update</a> *
<a name="l00141"></a>00141 update_buffer_get_update(<span class="keyword">struct</span> <a class="code" href="structobject__update__request.html">object_update_request</a> *request,
<a name="l00142"></a>00142                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)
<a name="l00143"></a>00143 {
<a name="l00144"></a>00144         <span class="keywordtype">void</span>    *ptr;
<a name="l00145"></a>00145         <span class="keywordtype">int</span>     i;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147         <span class="keywordflow">if</span> (index &gt; request-&gt;ourq_count)
<a name="l00148"></a>00148                 <span class="keywordflow">return</span> NULL;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150         ptr = &amp;request-&gt;ourq_updates[0];
<a name="l00151"></a>00151         <span class="keywordflow">for</span> (i = 0; i &lt; index; i++)
<a name="l00152"></a>00152                 ptr += object_update_size(ptr);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         <span class="keywordflow">return</span> ptr;
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00173"></a>00173 <span class="keywordtype">int</span> osp_md_object_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00174"></a>00174                          <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr, <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint,
<a name="l00175"></a>00175                          <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00176"></a>00176 {
<a name="l00177"></a>00177         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a>       *update;
<a name="l00178"></a>00178         <span class="keyword">struct </span><a class="code" href="structosp__object.html">osp_object</a>               *obj = dt2osp_obj(dt);
<a name="l00179"></a>00179         <span class="keywordtype">int</span>                             rc;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181         update = thandle_to_osp_update_request(th);
<a name="l00182"></a>00182         LASSERT(update != NULL);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         LASSERT(attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; LA_TYPE);
<a name="l00185"></a>00185         rc = osp_update_rpc_pack(env, create, update, OUT_CREATE,
<a name="l00186"></a>00186                                  lu_object_fid(&amp;dt-&gt;do_lu), attr, hint, dof);
<a name="l00187"></a>00187         <span class="keywordflow">if</span> (rc != 0)
<a name="l00188"></a>00188                 GOTO(out, rc);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         rc = osp_insert_update_callback(env, update, dt2osp_obj(dt), NULL,
<a name="l00191"></a>00191                                         osp_object_create_interpreter);
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00194"></a>00194                 GOTO(out, rc);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a> |= LOHA_EXISTS | (attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> &amp; S_IFMT);
<a name="l00197"></a>00197         dt2osp_obj(dt)-&gt;opo_non_exist = 0;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         LASSERT(obj-&gt;opo_ooa != NULL);
<a name="l00200"></a>00200         obj-&gt;opo_ooa-&gt;ooa_attr = *attr;
<a name="l00201"></a>00201 out:
<a name="l00202"></a>00202         <span class="keywordflow">return</span> rc;
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00218"></a>00218 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_declare_ref_del(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00219"></a>00219                                   <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00220"></a>00220 {
<a name="l00221"></a>00221         <span class="keywordflow">return</span> osp_trans_update_request_create(th);
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00237"></a>00237 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_ref_del(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00238"></a>00238                           <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00239"></a>00239 {
<a name="l00240"></a>00240         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a>       *update;
<a name="l00241"></a>00241         <span class="keywordtype">int</span>                             rc;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243         update = thandle_to_osp_update_request(th);
<a name="l00244"></a>00244         LASSERT(update != NULL);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246         rc = osp_update_rpc_pack(env, ref_del, update, OUT_REF_DEL,
<a name="l00247"></a>00247                                  lu_object_fid(&amp;dt-&gt;do_lu));
<a name="l00248"></a>00248         <span class="keywordflow">return</span> rc;
<a name="l00249"></a>00249 }
<a name="l00250"></a>00250 
<a name="l00264"></a>00264 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_declare_ref_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00265"></a>00265                                   <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00266"></a>00266 {
<a name="l00267"></a>00267         <span class="keywordflow">return</span> osp_trans_update_request_create(th);
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00283"></a>00283 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_ref_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00284"></a>00284                           <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00285"></a>00285 {
<a name="l00286"></a>00286         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a>       *update;
<a name="l00287"></a>00287         <span class="keywordtype">int</span>                             rc;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         update = thandle_to_osp_update_request(th);
<a name="l00290"></a>00290         LASSERT(update != NULL);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292         rc = osp_update_rpc_pack(env, ref_add, update, OUT_REF_ADD,
<a name="l00293"></a>00293                                  lu_object_fid(&amp;dt-&gt;do_lu));
<a name="l00294"></a>00294         <span class="keywordflow">return</span> rc;
<a name="l00295"></a>00295 }
<a name="l00296"></a>00296 
<a name="l00311"></a>00311 <span class="keyword">static</span> <span class="keywordtype">void</span> osp_md_ah_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00312"></a>00312                            <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *ah,
<a name="l00313"></a>00313                            <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *parent,
<a name="l00314"></a>00314                            <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child,
<a name="l00315"></a>00315                            umode_t child_mode)
<a name="l00316"></a>00316 {
<a name="l00317"></a>00317         LASSERT(ah);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319         ah-&gt;dah_parent = parent;
<a name="l00320"></a>00320         ah-&gt;dah_mode = child_mode;
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00337"></a>00337 <span class="keywordtype">int</span> osp_md_declare_attr_set(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00338"></a>00338                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340         <span class="keywordflow">return</span> osp_trans_update_request_create(th);
<a name="l00341"></a>00341 }
<a name="l00342"></a>00342 
<a name="l00359"></a>00359 <span class="keywordtype">int</span> osp_md_attr_set(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00360"></a>00360                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00361"></a>00361 {
<a name="l00362"></a>00362         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a>       *update;
<a name="l00363"></a>00363         <span class="keywordtype">int</span>                             rc;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365         update = thandle_to_osp_update_request(th);
<a name="l00366"></a>00366         LASSERT(update != NULL);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368         rc = osp_update_rpc_pack(env, attr_set, update, OUT_ATTR_SET,
<a name="l00369"></a>00369                                  lu_object_fid(&amp;dt-&gt;do_lu), attr);
<a name="l00370"></a>00370         <span class="keywordflow">return</span> rc;
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00385"></a>00385 <span class="keyword">static</span> <span class="keywordtype">void</span> osp_md_object_read_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00386"></a>00386                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keywordtype">unsigned</span> role)
<a name="l00387"></a>00387 {
<a name="l00388"></a>00388         <span class="keyword">struct </span><a class="code" href="structosp__object.html">osp_object</a>  *obj = dt2osp_obj(dt);
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         LASSERT(obj-&gt;opo_owner != env);
<a name="l00391"></a>00391         down_read_nested(&amp;obj-&gt;opo_sem, role);
<a name="l00392"></a>00392 
<a name="l00393"></a>00393         LASSERT(obj-&gt;opo_owner == NULL);
<a name="l00394"></a>00394 }
<a name="l00395"></a>00395 
<a name="l00405"></a>00405 <span class="keyword">static</span> <span class="keywordtype">void</span> osp_md_object_write_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00406"></a>00406                                      <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keywordtype">unsigned</span> role)
<a name="l00407"></a>00407 {
<a name="l00408"></a>00408         <span class="keyword">struct </span><a class="code" href="structosp__object.html">osp_object</a> *obj = dt2osp_obj(dt);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410         down_write_nested(&amp;obj-&gt;opo_sem, role);
<a name="l00411"></a>00411 
<a name="l00412"></a>00412         LASSERT(obj-&gt;opo_owner == NULL);
<a name="l00413"></a>00413         obj-&gt;opo_owner = env;
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00424"></a>00424 <span class="keyword">static</span> <span class="keywordtype">void</span> osp_md_object_read_unlock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00425"></a>00425                                       <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt)
<a name="l00426"></a>00426 {
<a name="l00427"></a>00427         <span class="keyword">struct </span><a class="code" href="structosp__object.html">osp_object</a> *obj = dt2osp_obj(dt);
<a name="l00428"></a>00428 
<a name="l00429"></a>00429         up_read(&amp;obj-&gt;opo_sem);
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00440"></a>00440 <span class="keyword">static</span> <span class="keywordtype">void</span> osp_md_object_write_unlock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00441"></a>00441                                        <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443         <span class="keyword">struct </span><a class="code" href="structosp__object.html">osp_object</a> *obj = dt2osp_obj(dt);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445         LASSERT(obj-&gt;opo_owner == env);
<a name="l00446"></a>00446         obj-&gt;opo_owner = NULL;
<a name="l00447"></a>00447         up_write(&amp;obj-&gt;opo_sem);
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00458"></a>00458 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_object_write_locked(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00459"></a>00459                                       <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt)
<a name="l00460"></a>00460 {
<a name="l00461"></a>00461         <span class="keyword">struct </span><a class="code" href="structosp__object.html">osp_object</a> *obj = dt2osp_obj(dt);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463         <span class="keywordflow">return</span> obj-&gt;opo_owner == env;
<a name="l00464"></a>00464 }
<a name="l00465"></a>00465 
<a name="l00480"></a>00480 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_index_lookup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00481"></a>00481                                <span class="keyword">struct</span> dt_rec *rec, <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key)
<a name="l00482"></a>00482 {
<a name="l00483"></a>00483         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           *lbuf   = &amp;osp_env_info(env)-&gt;osi_lb2;
<a name="l00484"></a>00484         <span class="keyword">struct </span><a class="code" href="structosp__device.html">osp_device</a>       *osp    = lu2osp_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l00485"></a>00485         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>        *dt_dev = &amp;osp-&gt;opd_dt_dev;
<a name="l00486"></a>00486         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a>   *update;
<a name="l00487"></a>00487         <span class="keyword">struct </span><a class="code" href="structobject__update__reply.html">object_update_reply</a> *reply;
<a name="l00488"></a>00488         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>      *req = NULL;
<a name="l00489"></a>00489         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>              *fid;
<a name="l00490"></a>00490         <span class="keywordtype">int</span>                        rc;
<a name="l00491"></a>00491         ENTRY;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493         <span class="comment">/* Because it needs send the update buffer right away,</span>
<a name="l00494"></a>00494 <span class="comment">         * just create an update buffer, instead of attaching the</span>
<a name="l00495"></a>00495 <span class="comment">         * update_remote list of the thandle.</span>
<a name="l00496"></a>00496 <span class="comment">         */</span>
<a name="l00497"></a>00497         update = osp_update_request_create(dt_dev);
<a name="l00498"></a>00498         <span class="keywordflow">if</span> (IS_ERR(update))
<a name="l00499"></a>00499                 RETURN(PTR_ERR(update));
<a name="l00500"></a>00500 
<a name="l00501"></a>00501         rc = osp_update_rpc_pack(env, index_lookup, update, OUT_INDEX_LOOKUP,
<a name="l00502"></a>00502                                  lu_object_fid(&amp;dt-&gt;do_lu), rec, key);
<a name="l00503"></a>00503         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00504"></a>00504                 CERROR(<span class="stringliteral">&quot;%s: Insert update error: rc = %d\n&quot;</span>,
<a name="l00505"></a>00505                        dt_dev-&gt;dd_lu_dev.<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name, rc);
<a name="l00506"></a>00506                 GOTO(out, rc);
<a name="l00507"></a>00507         }
<a name="l00508"></a>00508 
<a name="l00509"></a>00509         rc = osp_remote_sync(env, osp, update, &amp;req);
<a name="l00510"></a>00510         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00511"></a>00511                 GOTO(out, rc);
<a name="l00512"></a>00512 
<a name="l00513"></a>00513         reply = <a class="code" href="group__req__layout.html#gaebc460299194b773def6ad6960826860" title="Utility that combines req_capsule_set_size() and req_capsule_server_get().">req_capsule_server_sized_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>,
<a name="l00514"></a>00514                                              &amp;RMF_OUT_UPDATE_REPLY,
<a name="l00515"></a>00515                                              OUT_UPDATE_REPLY_SIZE);
<a name="l00516"></a>00516         <span class="keywordflow">if</span> (reply-&gt;ourp_magic != UPDATE_REPLY_MAGIC) {
<a name="l00517"></a>00517                 CERROR(<span class="stringliteral">&quot;%s: Wrong version %x expected %x: rc = %d\n&quot;</span>,
<a name="l00518"></a>00518                        dt_dev-&gt;dd_lu_dev.<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name,
<a name="l00519"></a>00519                        reply-&gt;ourp_magic, UPDATE_REPLY_MAGIC, -EPROTO);
<a name="l00520"></a>00520                 GOTO(out, rc = -EPROTO);
<a name="l00521"></a>00521         }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         rc = object_update_result_data_get(reply, lbuf, 0);
<a name="l00524"></a>00524         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00525"></a>00525                 GOTO(out, rc);
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         <span class="keywordflow">if</span> (lbuf-&gt;lb_len != <span class="keyword">sizeof</span>(*fid)) {
<a name="l00528"></a>00528                 CERROR(<span class="stringliteral">&quot;%s: lookup &quot;</span>DFID<span class="stringliteral">&quot; %s wrong size %d\n&quot;</span>,
<a name="l00529"></a>00529                        dt_dev-&gt;dd_lu_dev.<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name,
<a name="l00530"></a>00530                        PFID(lu_object_fid(&amp;dt-&gt;do_lu)), (<span class="keywordtype">char</span> *)key,
<a name="l00531"></a>00531                        (<span class="keywordtype">int</span>)lbuf-&gt;lb_len);
<a name="l00532"></a>00532                 GOTO(out, rc = -EINVAL);
<a name="l00533"></a>00533         }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         fid = lbuf-&gt;lb_buf;
<a name="l00536"></a>00536         <span class="keywordflow">if</span> (ptlrpc_rep_need_swab(req))
<a name="l00537"></a>00537                 lustre_swab_lu_fid(fid);
<a name="l00538"></a>00538         <span class="keywordflow">if</span> (!fid_is_sane(fid)) {
<a name="l00539"></a>00539                 CERROR(<span class="stringliteral">&quot;%s: lookup &quot;</span>DFID<span class="stringliteral">&quot; %s invalid fid &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00540"></a>00540                        dt_dev-&gt;dd_lu_dev.<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name,
<a name="l00541"></a>00541                        PFID(lu_object_fid(&amp;dt-&gt;do_lu)), (<span class="keywordtype">char</span> *)key, PFID(fid));
<a name="l00542"></a>00542                 GOTO(out, rc = -EINVAL);
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545         memcpy(rec, fid, <span class="keyword">sizeof</span>(*fid));
<a name="l00546"></a>00546 
<a name="l00547"></a>00547         GOTO(out, rc = 1);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 out:
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (req != NULL)
<a name="l00551"></a>00551                 <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l00552"></a>00552 
<a name="l00553"></a>00553         osp_update_request_destroy(update);
<a name="l00554"></a>00554 
<a name="l00555"></a>00555         <span class="keywordflow">return</span> rc;
<a name="l00556"></a>00556 }
<a name="l00557"></a>00557 
<a name="l00573"></a>00573 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_declare_index_insert(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00574"></a>00574                                        <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00575"></a>00575                                        <span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *rec,
<a name="l00576"></a>00576                                        <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key,
<a name="l00577"></a>00577                                        <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00578"></a>00578 {
<a name="l00579"></a>00579         <span class="keywordflow">return</span> osp_trans_update_request_create(th);
<a name="l00580"></a>00580 }
<a name="l00581"></a>00581 
<a name="l00598"></a>00598 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_index_insert(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00599"></a>00599                                <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00600"></a>00600                                <span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *rec,
<a name="l00601"></a>00601                                <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key,
<a name="l00602"></a>00602                                <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th,
<a name="l00603"></a>00603                                <span class="keywordtype">int</span> ignore_quota)
<a name="l00604"></a>00604 {
<a name="l00605"></a>00605         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a> *update;
<a name="l00606"></a>00606         <span class="keywordtype">int</span>                      rc;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         update = thandle_to_osp_update_request(th);
<a name="l00609"></a>00609         LASSERT(update != NULL);
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         rc = osp_update_rpc_pack(env, index_insert, update, OUT_INDEX_INSERT,
<a name="l00612"></a>00612                                  lu_object_fid(&amp;dt-&gt;do_lu), rec, key);
<a name="l00613"></a>00613         <span class="keywordflow">return</span> rc;
<a name="l00614"></a>00614 }
<a name="l00615"></a>00615 
<a name="l00630"></a>00630 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_declare_index_delete(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00631"></a>00631                                        <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00632"></a>00632                                        <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key,
<a name="l00633"></a>00633                                        <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00634"></a>00634 {
<a name="l00635"></a>00635         <span class="keywordflow">return</span> osp_trans_update_request_create(th);
<a name="l00636"></a>00636 }
<a name="l00637"></a>00637 
<a name="l00652"></a>00652 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_index_delete(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00653"></a>00653                                <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00654"></a>00654                                <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key,
<a name="l00655"></a>00655                                <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00656"></a>00656 {
<a name="l00657"></a>00657         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a> *update;
<a name="l00658"></a>00658         <span class="keywordtype">int</span>                      rc;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660         update = thandle_to_osp_update_request(th);
<a name="l00661"></a>00661         LASSERT(update != NULL);
<a name="l00662"></a>00662 
<a name="l00663"></a>00663         rc = osp_update_rpc_pack(env, index_delete, update, OUT_INDEX_DELETE,
<a name="l00664"></a>00664                                  lu_object_fid(&amp;dt-&gt;do_lu), key);
<a name="l00665"></a>00665 
<a name="l00666"></a>00666         <span class="keywordflow">return</span> rc;
<a name="l00667"></a>00667 }
<a name="l00668"></a>00668 
<a name="l00683"></a>00683 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_index_it_next(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> dt_it *di)
<a name="l00684"></a>00684 {
<a name="l00685"></a>00685         <span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a>           *it = (<span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a> *)di;
<a name="l00686"></a>00686         <span class="keyword">struct </span><a class="code" href="structlu__idxpage.html">lu_idxpage</a>       *idxpage;
<a name="l00687"></a>00687         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>        *ent = (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)it-&gt;ooi_ent;
<a name="l00688"></a>00688         <span class="keywordtype">int</span>                     rc;
<a name="l00689"></a>00689         ENTRY;
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 again:
<a name="l00692"></a>00692         idxpage = it-&gt;ooi_cur_idxpage;
<a name="l00693"></a>00693         if (idxpage != NULL) {
<a name="l00694"></a>00694                 <span class="keywordflow">if</span> (idxpage-&gt;lip_nr == 0)
<a name="l00695"></a>00695                         RETURN(1);
<a name="l00696"></a>00696 
<a name="l00697"></a>00697                 it-&gt;ooi_pos_ent++;
<a name="l00698"></a>00698                 <span class="keywordflow">if</span> (ent == NULL) {
<a name="l00699"></a>00699                         it-&gt;ooi_ent =
<a name="l00700"></a>00700                               (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)idxpage-&gt;lip_entries;
<a name="l00701"></a>00701                         RETURN(0);
<a name="l00702"></a>00702                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (le16_to_cpu(ent-&gt;<a class="code" href="structlu__dirent.html#a241bc48a83ebfb3219722f6a6afbe66a" title="total record length, including all attributes.">lde_reclen</a>) != 0 &amp;&amp;
<a name="l00703"></a>00703                            it-&gt;ooi_pos_ent &lt; idxpage-&gt;lip_nr) {
<a name="l00704"></a>00704                         ent = (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)(((<span class="keywordtype">char</span> *)ent) +
<a name="l00705"></a>00705                                         le16_to_cpu(ent-&gt;<a class="code" href="structlu__dirent.html#a241bc48a83ebfb3219722f6a6afbe66a" title="total record length, including all attributes.">lde_reclen</a>));
<a name="l00706"></a>00706                         it-&gt;ooi_ent = ent;
<a name="l00707"></a>00707                         RETURN(0);
<a name="l00708"></a>00708                 } <span class="keywordflow">else</span> {
<a name="l00709"></a>00709                         it-&gt;ooi_ent = NULL;
<a name="l00710"></a>00710                 }
<a name="l00711"></a>00711         }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713         rc = osp_it_next_page(env, di);
<a name="l00714"></a>00714         <span class="keywordflow">if</span> (rc == 0)
<a name="l00715"></a>00715                 <span class="keywordflow">goto</span> again;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         RETURN(rc);
<a name="l00718"></a>00718 }
<a name="l00719"></a>00719 
<a name="l00732"></a>00732 <span class="keyword">static</span> <span class="keyword">struct </span>dt_key *osp_it_key(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00733"></a>00733                                  <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di)
<a name="l00734"></a>00734 {
<a name="l00735"></a>00735         <span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a>           *it = (<span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a> *)di;
<a name="l00736"></a>00736         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>        *ent = (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)it-&gt;ooi_ent;
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         return (<span class="keyword">struct</span> dt_key *)ent-&gt;<a class="code" href="structlu__dirent.html#a3e3b5a552269757293891e23de373a3f" title="name is followed by the attributes indicated in -&amp;gt;ldp_attrs, in their natural...">lde_name</a>;
<a name="l00739"></a>00739 }
<a name="l00740"></a>00740 
<a name="l00754"></a>00754 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_it_key_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di)
<a name="l00755"></a>00755 {
<a name="l00756"></a>00756         <span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a>           *it = (<span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a> *)di;
<a name="l00757"></a>00757         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>        *ent = (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)it-&gt;ooi_ent;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759         return (<span class="keywordtype">int</span>)le16_to_cpu(ent-&gt;<a class="code" href="structlu__dirent.html#a6cf011f9cdc36e619bad6e893a537c02" title="name length">lde_namelen</a>);
<a name="l00760"></a>00760 }
<a name="l00761"></a>00761 
<a name="l00777"></a>00777 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_index_it_rec(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di,
<a name="l00778"></a>00778                                <span class="keyword">struct</span> dt_rec *rec, __u32 attr)
<a name="l00779"></a>00779 {
<a name="l00780"></a>00780         <span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a>           *it = (<span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a> *)di;
<a name="l00781"></a>00781         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>        *ent = (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)it-&gt;ooi_ent;
<a name="l00782"></a>00782         <span class="keywordtype">size_t</span>                  reclen;
<a name="l00783"></a>00783 
<a name="l00784"></a>00784         reclen = lu_dirent_calc_size(le16_to_cpu(ent-&gt;<a class="code" href="structlu__dirent.html#a6cf011f9cdc36e619bad6e893a537c02" title="name length">lde_namelen</a>), attr);
<a name="l00785"></a>00785         memcpy(rec, ent, reclen);
<a name="l00786"></a>00786         <span class="keywordflow">return</span> 0;
<a name="l00787"></a>00787 }
<a name="l00788"></a>00788 
<a name="l00803"></a>00803 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_it_load(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di,
<a name="l00804"></a>00804                        __u64 hash)
<a name="l00805"></a>00805 {
<a name="l00806"></a>00806         <span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a>   *it     = (<span class="keyword">struct </span><a class="code" href="structosp__it.html">osp_it</a> *)di;
<a name="l00807"></a>00807         <span class="keywordtype">int</span>              rc;
<a name="l00808"></a>00808 
<a name="l00809"></a>00809         it-&gt;ooi_next = hash;
<a name="l00810"></a>00810         rc = osp_md_index_it_next(env, (<span class="keyword">struct</span> dt_it *)di);
<a name="l00811"></a>00811         <span class="keywordflow">if</span> (rc == 1)
<a name="l00812"></a>00812                 <span class="keywordflow">return</span> 0;
<a name="l00813"></a>00813 
<a name="l00814"></a>00814         <span class="keywordflow">if</span> (rc == 0)
<a name="l00815"></a>00815                 <span class="keywordflow">return</span> 1;
<a name="l00816"></a>00816 
<a name="l00817"></a>00817         <span class="keywordflow">return</span> rc;
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__index__operations.html" title="Per-dt-object operations on object as index.">dt_index_operations</a> osp_md_index_ops = {
<a name="l00821"></a>00821         .<a class="code" href="structdt__index__operations.html#aab6a7632adfce2297c022b12f0d61791" title="Lookup in an index by key.">dio_lookup</a>         = osp_md_index_lookup,
<a name="l00822"></a>00822         .dio_declare_insert = osp_md_declare_index_insert,
<a name="l00823"></a>00823         .dio_insert         = osp_md_index_insert,
<a name="l00824"></a>00824         .dio_declare_delete = osp_md_declare_index_delete,
<a name="l00825"></a>00825         .dio_delete         = osp_md_index_delete,
<a name="l00826"></a>00826         .dio_it     = {
<a name="l00827"></a>00827                 .init     = osp_it_init,
<a name="l00828"></a>00828                 .fini     = osp_it_fini,
<a name="l00829"></a>00829                 .get      = osp_it_get,
<a name="l00830"></a>00830                 .put      = osp_it_put,
<a name="l00831"></a>00831                 .next     = osp_md_index_it_next,
<a name="l00832"></a>00832                 .key      = osp_it_key,
<a name="l00833"></a>00833                 .key_size = osp_it_key_size,
<a name="l00834"></a>00834                 .rec      = osp_md_index_it_rec,
<a name="l00835"></a>00835                 .store    = osp_it_store,
<a name="l00836"></a>00836                 .load     = osp_it_load,
<a name="l00837"></a>00837                 .key_rec  = osp_it_key_rec,
<a name="l00838"></a>00838         }
<a name="l00839"></a>00839 };
<a name="l00840"></a>00840 
<a name="l00855"></a>00855 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_index_try(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00856"></a>00856                             <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00857"></a>00857                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdt__index__features.html">dt_index_features</a> *feat)
<a name="l00858"></a>00858 {
<a name="l00859"></a>00859         dt-&gt;do_index_ops = &amp;osp_md_index_ops;
<a name="l00860"></a>00860         <span class="keywordflow">return</span> 0;
<a name="l00861"></a>00861 }
<a name="l00862"></a>00862 
<a name="l00880"></a>00880 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_object_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00881"></a>00881                               <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00882"></a>00882                               <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lh,
<a name="l00883"></a>00883                               <span class="keyword">struct</span> <a class="code" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters.">ldlm_enqueue_info</a> *einfo,
<a name="l00884"></a>00884                               <span class="keyword">union</span> <a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)
<a name="l00885"></a>00885 {
<a name="l00886"></a>00886         <span class="keyword">struct </span><a class="code" href="structldlm__res__id.html">ldlm_res_id</a>      *res_id;
<a name="l00887"></a>00887         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>        *dt_dev = lu2dt_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l00888"></a>00888         <span class="keyword">struct </span><a class="code" href="structosp__device.html">osp_device</a>       *osp = dt2osp_dev(dt_dev);
<a name="l00889"></a>00889         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *top_device;
<a name="l00890"></a>00890         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *req;
<a name="l00891"></a>00891         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00892"></a>00892         __u64                   flags = <a class="code" href="group__LDLM.html#ga628bde1454443ba6f69043120c61acb9" title="Don&amp;#39;t put lock into the LRU list, so that it is not canceled due to aging.">LDLM_FL_NO_LRU</a>;
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         res_id = einfo-&gt;ei_res_id;
<a name="l00895"></a>00895         LASSERT(res_id != NULL);
<a name="l00896"></a>00896 
<a name="l00897"></a>00897         <span class="keywordflow">if</span> (einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#ab7eaef7f96129b8b5f0c9d37f481ea02" title="whether enqueue slave stripes">ei_nonblock</a>)
<a name="l00898"></a>00898                 flags |= <a class="code" href="group__LDLM.html#ga34a11c94b46a7cd00e464a9063ff3879" title="Server told not to wait if blocked.">LDLM_FL_BLOCK_NOWAIT</a>;
<a name="l00899"></a>00899         <span class="keywordflow">if</span> (einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a> &amp; (LCK_EX | LCK_PW))
<a name="l00900"></a>00900                 flags |= <a class="code" href="group__LDLM.html#ga0b1ea8608da80462dc9948160ebe5cdc" title="Flag whether a lock is enqueued from a distributed transaction, and the requesting...">LDLM_FL_COS_INCOMPAT</a>;
<a name="l00901"></a>00901 
<a name="l00902"></a>00902         req = ldlm_enqueue_pack(osp-&gt;opd_exp, 0);
<a name="l00903"></a>00903         <span class="keywordflow">if</span> (IS_ERR(req))
<a name="l00904"></a>00904                 RETURN(PTR_ERR(req));
<a name="l00905"></a>00905 
<a name="l00906"></a>00906         <span class="comment">/* During recovery, it needs to let OSP send enqueue</span>
<a name="l00907"></a>00907 <span class="comment">         * without checking recoverying status, in case the</span>
<a name="l00908"></a>00908 <span class="comment">         * other target is being recovered at the same time,</span>
<a name="l00909"></a>00909 <span class="comment">         * and if we wait here for the import to be recovered,</span>
<a name="l00910"></a>00910 <span class="comment">         * it might cause deadlock */</span>
<a name="l00911"></a>00911         top_device = dt_dev-&gt;dd_lu_dev.<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>-&gt;<a class="code" href="structlu__site.html#a371ff1de170feccd1c80e3d7a0202965" title="Top-level device for this stack.">ls_top_dev</a>;
<a name="l00912"></a>00912         <span class="keywordflow">if</span> (top_device-&gt;<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_recovering)
<a name="l00913"></a>00913                 req-&gt;rq_allow_replay = 1;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915         rc = <a class="code" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client-side lock enqueue.">ldlm_cli_enqueue</a>(osp-&gt;opd_exp, &amp;req, einfo, res_id,
<a name="l00916"></a>00916                               (<span class="keyword">const</span> <span class="keyword">union</span> <a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *)policy,
<a name="l00917"></a>00917                               &amp;flags, NULL, 0, LVB_T_NONE, lh, 0);
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l00920"></a>00920 
<a name="l00921"></a>00921         <span class="keywordflow">return</span> rc == ELDLM_OK ? 0 : -EIO;
<a name="l00922"></a>00922 }
<a name="l00923"></a>00923 
<a name="l00936"></a>00936 <span class="keyword">static</span> <span class="keywordtype">int</span> osp_md_object_unlock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00937"></a>00937                                 <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00938"></a>00938                                 <span class="keyword">struct</span> <a class="code" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters.">ldlm_enqueue_info</a> *einfo,
<a name="l00939"></a>00939                                 <span class="keyword">union</span> <a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)
<a name="l00940"></a>00940 {
<a name="l00941"></a>00941         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    *lockh = einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af0ba62d8b646a2164ec979fb9bca48d4" title="lock glimpse callback">ei_cbdata</a>;
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <span class="comment">/* unlock finally */</span>
<a name="l00944"></a>00944         <a class="code" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref</a>(lockh, einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a>);
<a name="l00945"></a>00945 
<a name="l00946"></a>00946         <span class="keywordflow">return</span> 0;
<a name="l00947"></a>00947 }
<a name="l00948"></a>00948 
<a name="l00962"></a>00962 <span class="keywordtype">int</span> osp_md_declare_object_destroy(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00963"></a>00963                                <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00964"></a>00964 {
<a name="l00965"></a>00965         <span class="keywordflow">return</span> osp_trans_update_request_create(th);
<a name="l00966"></a>00966 }
<a name="l00967"></a>00967 
<a name="l00983"></a>00983 <span class="keywordtype">int</span> osp_md_object_destroy(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00984"></a>00984                           <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00985"></a>00985 {
<a name="l00986"></a>00986         <span class="keyword">struct </span><a class="code" href="structosp__object.html">osp_object</a>               *o = dt2osp_obj(dt);
<a name="l00987"></a>00987         <span class="keyword">struct </span><a class="code" href="structosp__device.html">osp_device</a>               *osp = lu2osp_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l00988"></a>00988         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a>       *update;
<a name="l00989"></a>00989         <span class="keywordtype">int</span>                             rc = 0;
<a name="l00990"></a>00990 
<a name="l00991"></a>00991         ENTRY;
<a name="l00992"></a>00992         o-&gt;opo_non_exist = 1;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994         LASSERT(osp-&gt;opd_connect_mdt);
<a name="l00995"></a>00995         update = thandle_to_osp_update_request(th);
<a name="l00996"></a>00996         LASSERT(update != NULL);
<a name="l00997"></a>00997 
<a name="l00998"></a>00998         rc = osp_update_rpc_pack(env, object_destroy, update, OUT_DESTROY,
<a name="l00999"></a>00999                                  lu_object_fid(&amp;dt-&gt;do_lu));
<a name="l01000"></a>01000         <span class="keywordflow">if</span> (rc != 0)
<a name="l01001"></a>01001                 RETURN(rc);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003         set_bit(<a class="code" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985aca9a04f530d5436e7996a1ff142d01d0" title="Don&amp;#39;t keep this object in cache.">LU_OBJECT_HEARD_BANSHEE</a>, &amp;dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#a85952a1c723e48ffa0bb7024438ac08f" title="Object flags from enum lu_object_header_flags.">loh_flags</a>);
<a name="l01004"></a>01004         rc = osp_insert_update_callback(env, update, dt2osp_obj(dt), NULL,
<a name="l01005"></a>01005                                         NULL);
<a name="l01006"></a>01006 
<a name="l01007"></a>01007         RETURN(rc);
<a name="l01008"></a>01008 }
<a name="l01009"></a>01009 
<a name="l01010"></a>01010 <span class="keyword">struct </span><a class="code" href="structdt__object__operations.html" title="A dt_object provides common operations to create and destroy objects and to manage...">dt_object_operations</a> osp_md_obj_ops = {
<a name="l01011"></a>01011         .<a class="code" href="structdt__object__operations.html#a32a37f3abca0903ec9fa5c70b2b7a423" title="Get read lock on object.">do_read_lock</a>         = osp_md_object_read_lock,
<a name="l01012"></a>01012         .do_write_lock        = osp_md_object_write_lock,
<a name="l01013"></a>01013         .do_read_unlock       = osp_md_object_read_unlock,
<a name="l01014"></a>01014         .do_write_unlock      = osp_md_object_write_unlock,
<a name="l01015"></a>01015         .do_write_locked      = osp_md_object_write_locked,
<a name="l01016"></a>01016         .do_declare_create    = osp_md_declare_object_create,
<a name="l01017"></a>01017         .do_create            = osp_md_object_create,
<a name="l01018"></a>01018         .do_declare_ref_add   = osp_md_declare_ref_add,
<a name="l01019"></a>01019         .do_ref_add           = osp_md_ref_add,
<a name="l01020"></a>01020         .do_declare_ref_del   = osp_md_declare_ref_del,
<a name="l01021"></a>01021         .do_ref_del           = osp_md_ref_del,
<a name="l01022"></a>01022         .do_declare_destroy   = osp_md_declare_object_destroy,
<a name="l01023"></a>01023         .do_destroy           = osp_md_object_destroy,
<a name="l01024"></a>01024         .do_ah_init           = osp_md_ah_init,
<a name="l01025"></a>01025         .do_attr_get          = osp_attr_get,
<a name="l01026"></a>01026         .do_declare_attr_set  = osp_md_declare_attr_set,
<a name="l01027"></a>01027         .do_attr_set          = osp_md_attr_set,
<a name="l01028"></a>01028         .do_xattr_get         = osp_xattr_get,
<a name="l01029"></a>01029         .do_declare_xattr_set = osp_declare_xattr_set,
<a name="l01030"></a>01030         .do_xattr_set         = osp_xattr_set,
<a name="l01031"></a>01031         .do_declare_xattr_del = osp_declare_xattr_del,
<a name="l01032"></a>01032         .do_xattr_del         = osp_xattr_del,
<a name="l01033"></a>01033         .do_index_try         = osp_md_index_try,
<a name="l01034"></a>01034         .do_object_lock       = osp_md_object_lock,
<a name="l01035"></a>01035         .do_object_unlock     = osp_md_object_unlock,
<a name="l01036"></a>01036 };
<a name="l01037"></a>01037 
<a name="l01053"></a>01053 <span class="keyword">static</span> ssize_t osp_md_declare_write(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01054"></a>01054                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01055"></a>01055                                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l01056"></a>01056                                     loff_t pos, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l01057"></a>01057 {
<a name="l01058"></a>01058         <span class="keyword">struct </span><a class="code" href="structosp__device.html">osp_device</a> *osp = dt2osp_dev(th-&gt;<a class="code" href="structthandle.html#ade585afae0d30b274a8259d402e918b6" title="the dt device on which the transactions are executed">th_dev</a>);
<a name="l01059"></a>01059         <span class="keywordtype">int</span> rc;
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         rc = osp_trans_update_request_create(th);
<a name="l01062"></a>01062         <span class="keywordflow">if</span> (rc != 0)
<a name="l01063"></a>01063                 <span class="keywordflow">return</span> rc;
<a name="l01064"></a>01064 
<a name="l01065"></a>01065         <span class="keywordflow">if</span> (osp-&gt;opd_update == NULL)
<a name="l01066"></a>01066                 <span class="keywordflow">return</span> 0;
<a name="l01067"></a>01067 
<a name="l01068"></a>01068         <span class="keywordflow">if</span> (dt2osp_obj(dt)-&gt;opo_stale)
<a name="l01069"></a>01069                 <span class="keywordflow">return</span> -ESTALE;
<a name="l01070"></a>01070 
<a name="l01071"></a>01071         <span class="keywordflow">return</span> 0;
<a name="l01072"></a>01072 }
<a name="l01073"></a>01073 
<a name="l01090"></a>01090 <span class="keyword">static</span> ssize_t osp_md_write(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01091"></a>01091                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf, loff_t *pos,
<a name="l01092"></a>01092                             <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th, <span class="keywordtype">int</span> ignore_quota)
<a name="l01093"></a>01093 {
<a name="l01094"></a>01094         <span class="keyword">struct </span><a class="code" href="structosp__object.html">osp_object</a>         *obj = dt2osp_obj(dt);
<a name="l01095"></a>01095         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a>  *update;
<a name="l01096"></a>01096         <span class="keyword">struct </span><a class="code" href="structosp__thandle.html">osp_thandle</a>        *oth = thandle_to_osp_thandle(th);
<a name="l01097"></a>01097         ssize_t                   rc;
<a name="l01098"></a>01098         ENTRY;
<a name="l01099"></a>01099 
<a name="l01100"></a>01100         update = thandle_to_osp_update_request(th);
<a name="l01101"></a>01101         LASSERT(update != NULL);
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         CDEBUG(D_INFO, <span class="stringliteral">&quot;write &quot;</span>DFID<span class="stringliteral">&quot; offset = &quot;</span>LPU64<span class="stringliteral">&quot; length = %zu\n&quot;</span>,
<a name="l01104"></a>01104                PFID(lu_object_fid(&amp;dt-&gt;do_lu)), *pos, buf-&gt;lb_len);
<a name="l01105"></a>01105 
<a name="l01106"></a>01106         rc = osp_update_rpc_pack(env, write, update, OUT_WRITE,
<a name="l01107"></a>01107                                  lu_object_fid(&amp;dt-&gt;do_lu), buf, *pos);
<a name="l01108"></a>01108         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01109"></a>01109                 RETURN(rc);
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         rc = osp_check_and_set_rpc_version(oth, obj);
<a name="l01112"></a>01112         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01113"></a>01113                 RETURN(rc);
<a name="l01114"></a>01114 
<a name="l01115"></a>01115         <span class="comment">/* XXX: how about the write error happened later? */</span>
<a name="l01116"></a>01116         *pos += buf-&gt;lb_len;
<a name="l01117"></a>01117 
<a name="l01118"></a>01118         <span class="keywordflow">if</span> (obj-&gt;opo_ooa != NULL &amp;&amp;
<a name="l01119"></a>01119             obj-&gt;opo_ooa-&gt;ooa_attr.<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; LA_SIZE &amp;&amp;
<a name="l01120"></a>01120             obj-&gt;opo_ooa-&gt;ooa_attr.<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a> &lt; *pos)
<a name="l01121"></a>01121                 obj-&gt;opo_ooa-&gt;ooa_attr.<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a> = *pos;
<a name="l01122"></a>01122 
<a name="l01123"></a>01123         RETURN(buf-&gt;lb_len);
<a name="l01124"></a>01124 }
<a name="l01125"></a>01125 
<a name="l01126"></a>01126 <span class="keyword">static</span> ssize_t osp_md_read(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01127"></a>01127                            <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *rbuf, loff_t *pos)
<a name="l01128"></a>01128 {
<a name="l01129"></a>01129         <span class="keyword">struct </span><a class="code" href="structosp__device.html">osp_device</a> *osp = lu2osp_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l01130"></a>01130         <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a> *dt_dev        = &amp;osp-&gt;opd_dt_dev;
<a name="l01131"></a>01131         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *lbuf = &amp;osp_env_info(env)-&gt;osi_lb2;
<a name="l01132"></a>01132         <span class="keywordtype">char</span> *ptr = rbuf-&gt;lb_buf;
<a name="l01133"></a>01133         <span class="keyword">struct </span><a class="code" href="structosp__update__request.html">osp_update_request</a> *update;
<a name="l01134"></a>01134         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = NULL;
<a name="l01135"></a>01135         <span class="keyword">struct </span><a class="code" href="structout__read__reply.html">out_read_reply</a> *orr;
<a name="l01136"></a>01136         <span class="keyword">struct </span><a class="code" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc;
<a name="l01137"></a>01137         <span class="keyword">struct </span><a class="code" href="structobject__update__reply.html">object_update_reply</a> *reply;
<a name="l01138"></a>01138         __u32 left_size;
<a name="l01139"></a>01139         <span class="keywordtype">int</span> nbufs;
<a name="l01140"></a>01140         <span class="keywordtype">int</span> i;
<a name="l01141"></a>01141         <span class="keywordtype">int</span> rc;
<a name="l01142"></a>01142         ENTRY;
<a name="l01143"></a>01143 
<a name="l01144"></a>01144         <span class="comment">/* Because it needs send the update buffer right away,</span>
<a name="l01145"></a>01145 <span class="comment">         * just create an update buffer, instead of attaching the</span>
<a name="l01146"></a>01146 <span class="comment">         * update_remote list of the thandle.  */</span>
<a name="l01147"></a>01147         update = osp_update_request_create(dt_dev);
<a name="l01148"></a>01148         <span class="keywordflow">if</span> (IS_ERR(update))
<a name="l01149"></a>01149                 RETURN(PTR_ERR(update));
<a name="l01150"></a>01150 
<a name="l01151"></a>01151         rc = osp_update_rpc_pack(env, read, update, OUT_READ,
<a name="l01152"></a>01152                                  lu_object_fid(&amp;dt-&gt;do_lu),
<a name="l01153"></a>01153                                  rbuf-&gt;lb_len, *pos);
<a name="l01154"></a>01154         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01155"></a>01155                 CERROR(<span class="stringliteral">&quot;%s: cannot insert update: rc = %d\n&quot;</span>,
<a name="l01156"></a>01156                        dt_dev-&gt;dd_lu_dev.<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name, rc);
<a name="l01157"></a>01157                 GOTO(out_update, rc);
<a name="l01158"></a>01158         }
<a name="l01159"></a>01159 
<a name="l01160"></a>01160         CDEBUG(D_INFO, <span class="stringliteral">&quot;%s &quot;</span>DFID<span class="stringliteral">&quot; read offset %llu size %zu\n&quot;</span>,
<a name="l01161"></a>01161                dt_dev-&gt;dd_lu_dev.<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name,
<a name="l01162"></a>01162                PFID(lu_object_fid(&amp;dt-&gt;do_lu)), *pos, rbuf-&gt;lb_len);
<a name="l01163"></a>01163         rc = osp_prep_update_req(env, osp-&gt;opd_obd-&gt;u.cli.cl_import, update,
<a name="l01164"></a>01164                                  &amp;req);
<a name="l01165"></a>01165         <span class="keywordflow">if</span> (rc != 0)
<a name="l01166"></a>01166                 GOTO(out_update, rc);
<a name="l01167"></a>01167 
<a name="l01168"></a>01168         nbufs = (rbuf-&gt;lb_len + OUT_BULK_BUFFER_SIZE - 1) /
<a name="l01169"></a>01169                                         OUT_BULK_BUFFER_SIZE;
<a name="l01170"></a>01170         <span class="comment">/* allocate bulk descriptor */</span>
<a name="l01171"></a>01171         desc = <a class="code" href="group__net.html#ga42ea756e2d84491e4b6ea2e53616d7cb" title="Prepare bulk descriptor for specified outgoing request req that can fit nfrags *...">ptlrpc_prep_bulk_imp</a>(req, nbufs, 1,
<a name="l01172"></a>01172                                     PTLRPC_BULK_PUT_SINK | PTLRPC_BULK_BUF_KVEC,
<a name="l01173"></a>01173                                     MDS_BULK_PORTAL, &amp;ptlrpc_bulk_kvec_ops);
<a name="l01174"></a>01174         <span class="keywordflow">if</span> (desc == NULL)
<a name="l01175"></a>01175                 GOTO(out, rc = -ENOMEM);
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         <span class="comment">/* split the buffer into small chunk size */</span>
<a name="l01178"></a>01178         left_size = rbuf-&gt;lb_len;
<a name="l01179"></a>01179         <span class="keywordflow">for</span> (i = 0; i &lt; nbufs; i++) {
<a name="l01180"></a>01180                 <span class="keywordtype">int</span> read_size;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182                 read_size = left_size &gt; OUT_BULK_BUFFER_SIZE ?
<a name="l01183"></a>01183                                 OUT_BULK_BUFFER_SIZE : left_size;
<a name="l01184"></a>01184                 desc-&gt;bd_frag_ops-&gt;add_iov_frag(desc, ptr, read_size);
<a name="l01185"></a>01185 
<a name="l01186"></a>01186                 ptr += read_size;
<a name="l01187"></a>01187         }
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         <span class="comment">/* This will only be called with read-only update, and these updates</span>
<a name="l01190"></a>01190 <span class="comment">         * might be used to retrieve update log during recovery process, so</span>
<a name="l01191"></a>01191 <span class="comment">         * it will be allowed to send during recovery process */</span>
<a name="l01192"></a>01192         req-&gt;rq_allow_replay = 1;
<a name="l01193"></a>01193         req-&gt;rq_bulk_read = 1;
<a name="l01194"></a>01194         <span class="comment">/* send request to master and wait for RPC to complete */</span>
<a name="l01195"></a>01195         rc = <a class="code" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes.">ptlrpc_queue_wait</a>(req);
<a name="l01196"></a>01196         <span class="keywordflow">if</span> (rc != 0)
<a name="l01197"></a>01197                 GOTO(out, rc);
<a name="l01198"></a>01198 
<a name="l01199"></a>01199         rc = <a class="code" href="group__sptlrpc.html#ga40f686bb862f149e189cf81f3a51a7c3" title="This is called after unwrap the reply message.">sptlrpc_cli_unwrap_bulk_read</a>(req, req-&gt;rq_bulk,
<a name="l01200"></a>01200                                           req-&gt;rq_bulk-&gt;bd_nob_transferred);
<a name="l01201"></a>01201         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01202"></a>01202                 GOTO(out, rc);
<a name="l01203"></a>01203 
<a name="l01204"></a>01204         reply = <a class="code" href="group__req__layout.html#gaebc460299194b773def6ad6960826860" title="Utility that combines req_capsule_set_size() and req_capsule_server_get().">req_capsule_server_sized_get</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>,
<a name="l01205"></a>01205                                              &amp;RMF_OUT_UPDATE_REPLY,
<a name="l01206"></a>01206                                              OUT_UPDATE_REPLY_SIZE);
<a name="l01207"></a>01207 
<a name="l01208"></a>01208         <span class="keywordflow">if</span> (reply-&gt;ourp_magic != UPDATE_REPLY_MAGIC) {
<a name="l01209"></a>01209                 CERROR(<span class="stringliteral">&quot;%s: invalid update reply magic %x expected %x:&quot;</span>
<a name="l01210"></a>01210                        <span class="stringliteral">&quot; rc = %d\n&quot;</span>, dt_dev-&gt;dd_lu_dev.<a class="code" href="structlu__device.html#af35351bd6a533fa48c8a0f0eda83172a">ld_obd</a>-&gt;obd_name,
<a name="l01211"></a>01211                        reply-&gt;ourp_magic, UPDATE_REPLY_MAGIC, -EPROTO);
<a name="l01212"></a>01212                 GOTO(out, rc = -EPROTO);
<a name="l01213"></a>01213         }
<a name="l01214"></a>01214 
<a name="l01215"></a>01215         rc = object_update_result_data_get(reply, lbuf, 0);
<a name="l01216"></a>01216         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01217"></a>01217                 GOTO(out, rc);
<a name="l01218"></a>01218 
<a name="l01219"></a>01219         <span class="keywordflow">if</span> (lbuf-&gt;lb_len &lt; <span class="keyword">sizeof</span>(*orr))
<a name="l01220"></a>01220                 GOTO(out, rc = -EPROTO);
<a name="l01221"></a>01221 
<a name="l01222"></a>01222         orr = lbuf-&gt;lb_buf;
<a name="l01223"></a>01223         orr_le_to_cpu(orr, orr);
<a name="l01224"></a>01224         rc = orr-&gt;orr_size;
<a name="l01225"></a>01225         *pos = orr-&gt;orr_offset;
<a name="l01226"></a>01226 out:
<a name="l01227"></a>01227         <a class="code" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request.">ptlrpc_req_finished</a>(req);
<a name="l01228"></a>01228 
<a name="l01229"></a>01229 out_update:
<a name="l01230"></a>01230         osp_update_request_destroy(update);
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         RETURN(rc);
<a name="l01233"></a>01233 }
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 <span class="comment">/* These body operation will be used to write symlinks during migration etc */</span>
<a name="l01236"></a>01236 <span class="keyword">struct </span><a class="code" href="structdt__body__operations.html" title="Per-dt-object operations on &amp;quot;file body&amp;quot; - unstructure raw data.">dt_body_operations</a> osp_md_body_ops = {
<a name="l01237"></a>01237         .<a class="code" href="structdt__body__operations.html#aa4d64d407e2b442c1e418fa9ca46ab44" title="Declare intention to write data to object.">dbo_declare_write</a>      = osp_md_declare_write,
<a name="l01238"></a>01238         .dbo_write              = osp_md_write,
<a name="l01239"></a>01239         .dbo_read               = osp_md_read,
<a name="l01240"></a>01240 };
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:19 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
