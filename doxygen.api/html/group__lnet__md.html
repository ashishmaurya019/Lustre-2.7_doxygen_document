<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: Memory descriptors</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Memory descriptors<br/>
<small>
[<a class="el" href="group__lnet.html">LNet</a>]</small>
</h1>
<p>A memory descriptor contains information about a region of a user's memory (either in kernel or user space) and optionally points to an event queue where information about the operations performed on the memory descriptor are recorded.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Memory descriptors:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__lnet__md.png" border="0" alt="" usemap="#group____lnet____md_map"/>
<map name="group____lnet____md_map" id="group____lnet____md">
<area shape="rect" id="node1" href="group__lnet.html" title="The Lustre Networking subsystem." alt="" coords="5,5,61,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__md__t.html">lnet_md_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines the visible parts of a memory descriptor.  <a href="structlnet__md__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__kiov__t.html">lnet_kiov_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A page-based fragment of a MD.  <a href="structlnet__kiov__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga940bf275936204c687ca9178062c8168"></a><!-- doxytag: member="lnet_md::LNET_MTU_BITS" ref="ga940bf275936204c687ca9178062c8168" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_MTU_BITS</b>&nbsp;&nbsp;&nbsp;20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f0473c1f8801dc40fe285939f6d5d0b"></a><!-- doxytag: member="lnet_md::LNET_MTU" ref="ga3f0473c1f8801dc40fe285939f6d5d0b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_MTU</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; LNET_MTU_BITS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5c5481fe02371e7bf253b2b1cf0d030"></a><!-- doxytag: member="lnet_md::LNET_MAX_IOV" ref="gae5c5481fe02371e7bf253b2b1cf0d030" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#gae5c5481fe02371e7bf253b2b1cf0d030">LNET_MAX_IOV</a>&nbsp;&nbsp;&nbsp;256</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">limit on the number of fragments in discontiguous MDs <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#ga653ba41bd3978635e420cfa4601193e1">LNET_MD_OP_PUT</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Options for the MD structure.  <a href="#ga653ba41bd3978635e420cfa4601193e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#ga2f9879433bdc5c8f77f13359f74e5df5">LNET_MD_OP_GET</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>.  <a href="#ga2f9879433bdc5c8f77f13359f74e5df5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#ga972b76d71cbb0e446c273d2edf83cad6">LNET_MD_MANAGE_REMOTE</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>.  <a href="#ga972b76d71cbb0e446c273d2edf83cad6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#gab42e05f052fae51874fb3b60471d7c30">LNET_MD_TRUNCATE</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>.  <a href="#gab42e05f052fae51874fb3b60471d7c30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#ga364d206ea5fb9d05f09871faf1e10bd3">LNET_MD_ACK_DISABLE</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 5)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>.  <a href="#ga364d206ea5fb9d05f09871faf1e10bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#gacd7ecdcabac21b089dc8e101048bffc1">LNET_MD_IOVEC</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 6)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>.  <a href="#gacd7ecdcabac21b089dc8e101048bffc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#ga05bfd5b03abc8ded1b209b51bf65973f">LNET_MD_MAX_SIZE</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 7)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>.  <a href="#ga05bfd5b03abc8ded1b209b51bf65973f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#gad9555865426bac84ce57b5ed4a0059a2">LNET_MD_KIOV</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 8)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>.  <a href="#gad9555865426bac84ce57b5ed4a0059a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb8a095aed7dae7ea5919b3b57f215e7"></a><!-- doxytag: member="lnet_md::LNET_MD_PHYS" ref="gabb8a095aed7dae7ea5919b3b57f215e7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_MD_PHYS</b>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#gab5ce273fe5d92ed9f27f71519592e0d2">LNET_MD_THRESH_INF</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Infinite threshold on MD operations.  <a href="#gab5ce273fe5d92ed9f27f71519592e0d2"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad848ede18fff1097e842dc9dca2fc9a3"></a><!-- doxytag: member="lnet_md::lnet_md_iovec_t" ref="gad848ede18fff1097e842dc9dca2fc9a3" args="" -->
typedef struct iovec&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_md_iovec_t</b></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc">LNetMDAttach</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a> current_in, <a class="el" href="structlnet__md__t.html">lnet_md_t</a> md_in, <a class="el" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9">lnet_unlink_t</a> unlink_in, <a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a> *handle_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a memory descriptor and attach it to a ME.  <a href="#ga958972d35fc04d0716f4f6b71cd804fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#ga07ee1df9cd78eb3f002e76d371a29888">LNetMDBind</a> (<a class="el" href="structlnet__md__t.html">lnet_md_t</a> md_in, <a class="el" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9">lnet_unlink_t</a> unlink_in, <a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a> *handle_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a "free floating" memory descriptor - a MD that is not associated with a ME.  <a href="#ga07ee1df9cd78eb3f002e76d371a29888"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9">LNetMDUnlink</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a> md_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlink the memory descriptor from any ME it may be linked to and release the internal resources associated with it.  <a href="#ga2a0ce03253bcaae1e35be920f6029ca9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A memory descriptor contains information about a region of a user's memory (either in kernel or user space) and optionally points to an event queue where information about the operations performed on the memory descriptor are recorded. </p>
<p>Memory descriptor is abbreviated as MD and can be used interchangeably with the memory region it describes.</p>
<p>The LNet API provides two operations to create MDs: <a class="el" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME.">LNetMDAttach()</a> and <a class="el" href="group__lnet__md.html#ga07ee1df9cd78eb3f002e76d371a29888" title="Create a &quot;free floating&quot; memory descriptor - a MD that is not associated...">LNetMDBind()</a>; one operation to unlink and release the resources associated with a MD: <a class="el" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink()</a>. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga364d206ea5fb9d05f09871faf1e10bd3"></a><!-- doxytag: member="types.h::LNET_MD_ACK_DISABLE" ref="ga364d206ea5fb9d05f09871faf1e10bd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_MD_ACK_DISABLE&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 5)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00464">464</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a class="anchor" id="gacd7ecdcabac21b089dc8e101048bffc1"></a><!-- doxytag: member="types.h::LNET_MD_IOVEC" ref="gacd7ecdcabac21b089dc8e101048bffc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_MD_IOVEC&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 6)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00466">466</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad9555865426bac84ce57b5ed4a0059a2"></a><!-- doxytag: member="types.h::LNET_MD_KIOV" ref="gad9555865426bac84ce57b5ed4a0059a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_MD_KIOV&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 8)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00470">470</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga972b76d71cbb0e446c273d2edf83cad6"></a><!-- doxytag: member="types.h::LNET_MD_MANAGE_REMOTE" ref="ga972b76d71cbb0e446c273d2edf83cad6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_MD_MANAGE_REMOTE&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00459">459</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>.</p>

</div>
</div>
<a class="anchor" id="ga05bfd5b03abc8ded1b209b51bf65973f"></a><!-- doxytag: member="types.h::LNET_MD_MAX_SIZE" ref="ga05bfd5b03abc8ded1b209b51bf65973f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_MD_MAX_SIZE&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 7)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00468">468</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00900">ptlrpc_register_rqbd()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2f9879433bdc5c8f77f13359f74e5df5"></a><!-- doxytag: member="types.h::LNET_MD_OP_GET" ref="ga2f9879433bdc5c8f77f13359f74e5df5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_MD_OP_GET&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00457">457</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="lib-md_8c_source.html#l00263">LNetMDAttach()</a>, <a class="el" href="lib-md_8c_source.html#l00343">LNetMDBind()</a>, and <a class="el" href="niobuf_8c_source.html#l00301">ptlrpc_register_bulk()</a>.</p>

</div>
</div>
<a class="anchor" id="ga653ba41bd3978635e420cfa4601193e1"></a><!-- doxytag: member="types.h::LNET_MD_OP_PUT" ref="ga653ba41bd3978635e420cfa4601193e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_MD_OP_PUT&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Options for the MD structure. </p>
<p>See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00455">455</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="lib-md_8c_source.html#l00263">LNetMDAttach()</a>, <a class="el" href="lib-md_8c_source.html#l00343">LNetMDBind()</a>, <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, <a class="el" href="niobuf_8c_source.html#l00301">ptlrpc_register_bulk()</a>, and <a class="el" href="niobuf_8c_source.html#l00900">ptlrpc_register_rqbd()</a>.</p>

</div>
</div>
<a class="anchor" id="gab5ce273fe5d92ed9f27f71519592e0d2"></a><!-- doxytag: member="types.h::LNET_MD_THRESH_INF" ref="gab5ce273fe5d92ed9f27f71519592e0d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_MD_THRESH_INF&nbsp;&nbsp;&nbsp;(-1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Infinite threshold on MD operations. </p>
<p>See <a class="el" href="structlnet__md__t.html#a60130fbc7253f41b3b6cd8da947ff023" title="Specifies the maximum number of operations that can be performed on the memory descriptor...">lnet_md_t::threshold</a> </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00476">476</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, and <a class="el" href="niobuf_8c_source.html#l00900">ptlrpc_register_rqbd()</a>.</p>

</div>
</div>
<a class="anchor" id="gab42e05f052fae51874fb3b60471d7c30"></a><!-- doxytag: member="types.h::LNET_MD_TRUNCATE" ref="gab42e05f052fae51874fb3b60471d7c30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LNET_MD_TRUNCATE&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">lnet_md_t::options</a>. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00462">462</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga958972d35fc04d0716f4f6b71cd804fc"></a><!-- doxytag: member="api.h::LNetMDAttach" ref="ga958972d35fc04d0716f4f6b71cd804fc" args="(lnet_handle_me_t current_in, lnet_md_t md_in, lnet_unlink_t unlink_in, lnet_handle_md_t *handle_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetMDAttach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_me_t</a>&nbsp;</td>
          <td class="paramname"> <em>meh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__md__t.html">lnet_md_t</a>&nbsp;</td>
          <td class="paramname"> <em>umd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9">lnet_unlink_t</a>&nbsp;</td>
          <td class="paramname"> <em>unlink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a memory descriptor and attach it to a ME. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>meh</em>&nbsp;</td><td>A handle for a ME to associate the new MD with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>umd</em>&nbsp;</td><td>Provides initial values for the user-visible parts of a MD. Other than its use for initialization, there is no linkage between this structure and the MD maintained by the LNet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unlink</em>&nbsp;</td><td>A flag to indicate whether the MD is automatically unlinked when it becomes inactive, either because the operation threshold drops to zero or because the available memory becomes less than <em>umd.max_size</em>. (Note that the check for unlinking a MD only occurs after the completion of a successful operation on the MD.) The value LNET_UNLINK enables auto unlinking; the value LNET_RETAIN disables it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>On successful returns, a handle to the newly created MD is saved here. This handle can be used later in <a class="el" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>On success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>If <em>umd</em> is not valid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>If new MD cannot be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>Either <em>meh</em> or <em>umd.eq_handle</em> does not point to a valid object. Note that it's OK to supply a NULL <em>umd.eq_handle</em> by calling LNetInvalidateHandle() on it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EBUSY</em>&nbsp;</td><td>If the ME pointed to by <em>meh</em> is already associated with a MD. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-md_8c_source.html#l00263">263</a> of file <a class="el" href="lib-md_8c_source.html">lib-md.c</a>.</p>

<p>References <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00440">lnet_md_t::eq_handle</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00457">LNET_MD_OP_GET</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00455">LNET_MD_OP_PUT</a>, and <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00426">lnet_md_t::options</a>.</p>

<p>Referenced by <a class="el" href="niobuf_8c_source.html#l00660">ptl_send_rpc()</a>, <a class="el" href="niobuf_8c_source.html#l00301">ptlrpc_register_bulk()</a>, and <a class="el" href="niobuf_8c_source.html#l00900">ptlrpc_register_rqbd()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00265"></a>00265 {
<a name="l00266"></a>00266         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        matches = LIST_HEAD_INIT(matches);
<a name="l00267"></a>00267         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        drops = LIST_HEAD_INIT(drops);
<a name="l00268"></a>00268         <span class="keyword">struct </span><a class="code" href="structlnet__me.html">lnet_me</a>          *me;
<a name="l00269"></a>00269         <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a>       *md;
<a name="l00270"></a>00270         <span class="keywordtype">int</span>                     cpt;
<a name="l00271"></a>00271         <span class="keywordtype">int</span>                     rc;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273         LASSERT (the_lnet.ln_refcount &gt; 0);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         <span class="keywordflow">if</span> (lnet_md_validate(&amp;umd) != 0)
<a name="l00276"></a>00276                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278         <span class="keywordflow">if</span> ((umd.<a class="code" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">options</a> &amp; (<a class="code" href="group__lnet__md.html#ga2f9879433bdc5c8f77f13359f74e5df5" title="See lnet_md_t::options.">LNET_MD_OP_GET</a> | <a class="code" href="group__lnet__md.html#ga653ba41bd3978635e420cfa4601193e1" title="Options for the MD structure.">LNET_MD_OP_PUT</a>)) == 0) {
<a name="l00279"></a>00279                 CERROR(<span class="stringliteral">&quot;Invalid option: no MD_OP set\n&quot;</span>);
<a name="l00280"></a>00280                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00281"></a>00281         }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283         md = lnet_md_alloc(&amp;umd);
<a name="l00284"></a>00284         <span class="keywordflow">if</span> (md == NULL)
<a name="l00285"></a>00285                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287         rc = lnet_md_build(md, &amp;umd, unlink);
<a name="l00288"></a>00288         cpt = lnet_cpt_of_cookie(meh.cookie);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         lnet_res_lock(cpt);
<a name="l00291"></a>00291         <span class="keywordflow">if</span> (rc != 0)
<a name="l00292"></a>00292                 <span class="keywordflow">goto</span> failed;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         me = lnet_handle2me(&amp;meh);
<a name="l00295"></a>00295         <span class="keywordflow">if</span> (me == NULL)
<a name="l00296"></a>00296                 rc = -ENOENT;
<a name="l00297"></a>00297         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (me-&gt;me_md != NULL)
<a name="l00298"></a>00298                 rc = -EBUSY;
<a name="l00299"></a>00299         <span class="keywordflow">else</span>
<a name="l00300"></a>00300                 rc = lnet_md_link(md, umd.<a class="code" href="structlnet__md__t.html#a568b34498bd37af0973c749f5e856a3b" title="A handle for the event queue used to log the operations performed on the memory region...">eq_handle</a>, cpt);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302         <span class="keywordflow">if</span> (rc != 0)
<a name="l00303"></a>00303                 <span class="keywordflow">goto</span> failed;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305         <span class="comment">/* attach this MD to portal of ME and check if it matches any</span>
<a name="l00306"></a>00306 <span class="comment">         * blocked msgs on this portal */</span>
<a name="l00307"></a>00307         lnet_ptl_attach_md(me, md, &amp;matches, &amp;drops);
<a name="l00308"></a>00308 
<a name="l00309"></a>00309         lnet_md2handle(handle, md);
<a name="l00310"></a>00310 
<a name="l00311"></a>00311         lnet_res_unlock(cpt);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313         lnet_drop_delayed_msg_list(&amp;drops, <span class="stringliteral">&quot;Bad match&quot;</span>);
<a name="l00314"></a>00314         lnet_recv_delayed_msg_list(&amp;matches);
<a name="l00315"></a>00315 
<a name="l00316"></a>00316         <span class="keywordflow">return</span> 0;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318  failed:
<a name="l00319"></a>00319         lnet_md_free(md);
<a name="l00320"></a>00320 
<a name="l00321"></a>00321         lnet_res_unlock(cpt);
<a name="l00322"></a>00322         <span class="keywordflow">return</span> rc;
<a name="l00323"></a>00323 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lnet__md_ga958972d35fc04d0716f4f6b71cd804fc_icgraph.png" border="0" usemap="#group__lnet__md_ga958972d35fc04d0716f4f6b71cd804fc_icgraph_map" alt=""></div>
<map name="group__lnet__md_ga958972d35fc04d0716f4f6b71cd804fc_icgraph_map" id="group__lnet__md_ga958972d35fc04d0716f4f6b71cd804fc_icgraph">
<area shape="rect" id="node3" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="387,84,493,113"/><area shape="rect" id="node38" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Register bulk at the sender for later transfer." alt="" coords="183,109,337,139"/><area shape="rect" id="node41" href="group__net.html#gaf7557fc8aa34bbf889ee11612ece2315" title="Register request buffer descriptor for request receiving." alt="" coords="181,163,339,192"/><area shape="rect" id="node5" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="541,84,680,113"/><area shape="rect" id="node7" href="group__lib.html#gafc5cf9a5b2924b90734e720301742315" title="Send a remote set_info_async." alt="" coords="1103,56,1247,85"/><area shape="rect" id="node9" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="729,109,855,139"/><area shape="rect" id="node11" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="904,109,1051,139"/><area shape="rect" id="node14" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="1100,109,1249,139"/><area shape="rect" id="node36" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client&#45;side lock enqueue." alt="" coords="1107,163,1243,192"/><area shape="rect" id="node16" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="1300,109,1447,139"/><area shape="rect" id="node18" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="1529,29,1649,59"/><area shape="rect" id="node25" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149" title="Locally cancel up to count locks in list cancels." alt="" coords="1497,83,1681,112"/><area shape="rect" id="node29" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66" title="Cancel all locks on a resource that have 0 readers/writers." alt="" coords="1981,108,2224,137"/><area shape="rect" id="node34" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f" title="Cancel LRU locks and pack them into the enqueue request." alt="" coords="1519,187,1660,216"/><area shape="rect" id="node20" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="1732,29,1932,59"/><area shape="rect" id="node22" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="2033,29,2172,59"/><area shape="rect" id="node27" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy..." alt="" coords="1731,83,1933,112"/><area shape="rect" id="node31" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a" title="Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers..." alt="" coords="2272,108,2448,137"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga07ee1df9cd78eb3f002e76d371a29888"></a><!-- doxytag: member="api.h::LNetMDBind" ref="ga07ee1df9cd78eb3f002e76d371a29888" args="(lnet_md_t md_in, lnet_unlink_t unlink_in, lnet_handle_md_t *handle_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetMDBind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__md__t.html">lnet_md_t</a>&nbsp;</td>
          <td class="paramname"> <em>umd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9">lnet_unlink_t</a>&nbsp;</td>
          <td class="paramname"> <em>unlink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a "free floating" memory descriptor - a MD that is not associated with a ME. </p>
<p>Such MDs are usually used in <a class="el" href="group__lnet__data.html#gaf8261191429eaa8b9290ec056c6d40d2" title="Initiate an asynchronous PUT operation.">LNetPut()</a> and <a class="el" href="group__lnet__data.html#ga85a33eba7b0992e1924a3ced45ccb017" title="Initiate an asynchronous GET operation.">LNetGet()</a> operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>umd,unlink</em>&nbsp;</td><td>See the discussion for <a class="el" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME.">LNetMDAttach()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>On successful returns, a handle to the newly created MD is saved here. This handle can be used later in <a class="el" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink()</a>, <a class="el" href="group__lnet__data.html#gaf8261191429eaa8b9290ec056c6d40d2" title="Initiate an asynchronous PUT operation.">LNetPut()</a>, and <a class="el" href="group__lnet__data.html#ga85a33eba7b0992e1924a3ced45ccb017" title="Initiate an asynchronous GET operation.">LNetGet()</a> operations.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>On success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>If <em>umd</em> is not valid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>If new MD cannot be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td><em>umd.eq_handle</em> does not point to a valid EQ. Note that it's OK to supply a NULL <em>umd.eq_handle</em> by calling LNetInvalidateHandle() on it. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-md_8c_source.html#l00343">343</a> of file <a class="el" href="lib-md_8c_source.html">lib-md.c</a>.</p>

<p>References <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00440">lnet_md_t::eq_handle</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00457">LNET_MD_OP_GET</a>, <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00455">LNET_MD_OP_PUT</a>, and <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00426">lnet_md_t::options</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00344"></a>00344 {
<a name="l00345"></a>00345         <a class="code" href="structlnet__libmd.html">lnet_libmd_t</a>    *md;
<a name="l00346"></a>00346         <span class="keywordtype">int</span>             cpt;
<a name="l00347"></a>00347         <span class="keywordtype">int</span>             rc;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349         LASSERT (the_lnet.ln_refcount &gt; 0);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351         <span class="keywordflow">if</span> (lnet_md_validate(&amp;umd) != 0)
<a name="l00352"></a>00352                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354         <span class="keywordflow">if</span> ((umd.<a class="code" href="structlnet__md__t.html#af37df46d5729b86dd662a2bcecb2fe13" title="Specifies the behavior of the memory descriptor.">options</a> &amp; (<a class="code" href="group__lnet__md.html#ga2f9879433bdc5c8f77f13359f74e5df5" title="See lnet_md_t::options.">LNET_MD_OP_GET</a> | <a class="code" href="group__lnet__md.html#ga653ba41bd3978635e420cfa4601193e1" title="Options for the MD structure.">LNET_MD_OP_PUT</a>)) != 0) {
<a name="l00355"></a>00355                 CERROR(<span class="stringliteral">&quot;Invalid option: GET|PUT illegal on active MDs\n&quot;</span>);
<a name="l00356"></a>00356                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00357"></a>00357         }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359         md = lnet_md_alloc(&amp;umd);
<a name="l00360"></a>00360         <span class="keywordflow">if</span> (md == NULL)
<a name="l00361"></a>00361                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363         rc = lnet_md_build(md, &amp;umd, unlink);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365         cpt = lnet_res_lock_current();
<a name="l00366"></a>00366         <span class="keywordflow">if</span> (rc != 0)
<a name="l00367"></a>00367                 <span class="keywordflow">goto</span> failed;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369         rc = lnet_md_link(md, umd.<a class="code" href="structlnet__md__t.html#a568b34498bd37af0973c749f5e856a3b" title="A handle for the event queue used to log the operations performed on the memory region...">eq_handle</a>, cpt);
<a name="l00370"></a>00370         <span class="keywordflow">if</span> (rc != 0)
<a name="l00371"></a>00371                 <span class="keywordflow">goto</span> failed;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373         lnet_md2handle(handle, md);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         lnet_res_unlock(cpt);
<a name="l00376"></a>00376         <span class="keywordflow">return</span> 0;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378  failed:
<a name="l00379"></a>00379         lnet_md_free(md);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381         lnet_res_unlock(cpt);
<a name="l00382"></a>00382         <span class="keywordflow">return</span> rc;
<a name="l00383"></a>00383 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2a0ce03253bcaae1e35be920f6029ca9"></a><!-- doxytag: member="api.h::LNetMDUnlink" ref="ga2a0ce03253bcaae1e35be920f6029ca9" args="(lnet_handle_md_t md_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetMDUnlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_md_t</a>&nbsp;</td>
          <td class="paramname"> <em>mdh</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlink the memory descriptor from any ME it may be linked to and release the internal resources associated with it. </p>
<p>As a result, active messages associated with the MD may get aborted.</p>
<p>This function does not free the memory region associated with the MD; i.e., the memory the user allocated for this MD. If the ME associated with this MD is not NULL and was created with auto unlink enabled, the ME is unlinked as well (see <a class="el" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal.">LNetMEAttach()</a>).</p>
<p>Explicitly unlinking a MD via this function call has the same behavior as a MD that has been automatically unlinked, except that no LNET_EVENT_UNLINK is generated in the latter case.</p>
<p>An unlinked event can be reported in two ways:</p>
<ul>
<li>If there's no pending operations on the MD, it's unlinked immediately and an LNET_EVENT_UNLINK event is logged before this function returns.</li>
<li>Otherwise, the MD is only marked for deletion when this function returns, and the unlinked event will be piggybacked on the event of the completion of the last operation by setting the unlinked field of the event. No dedicated LNET_EVENT_UNLINK event is generated.</li>
</ul>
<p>Note that in both cases the unlinked field of the event is always set; no more event will happen on the MD after such an event is logged.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mdh</em>&nbsp;</td><td>A handle for the MD to be unlinked.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>On success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If <em>mdh</em> does not point to a valid MD object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-md_8c_source.html#l00417">417</a> of file <a class="el" href="lib-md_8c_source.html">lib-md.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00418"></a>00418 {
<a name="l00419"></a>00419         <a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>    ev;
<a name="l00420"></a>00420         <a class="code" href="structlnet__libmd.html">lnet_libmd_t</a>    *md;
<a name="l00421"></a>00421         <span class="keywordtype">int</span>             cpt;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         LASSERT(the_lnet.ln_refcount &gt; 0);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425         cpt = lnet_cpt_of_cookie(mdh.cookie);
<a name="l00426"></a>00426         lnet_res_lock(cpt);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428         md = lnet_handle2md(&amp;mdh);
<a name="l00429"></a>00429         <span class="keywordflow">if</span> (md == NULL) {
<a name="l00430"></a>00430                 lnet_res_unlock(cpt);
<a name="l00431"></a>00431                 <span class="keywordflow">return</span> -ENOENT;
<a name="l00432"></a>00432         }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434         md-&gt;md_flags |= LNET_MD_FLAG_ABORTED;
<a name="l00435"></a>00435         <span class="comment">/* If the MD is busy, lnet_md_unlink just marks it for deletion, and</span>
<a name="l00436"></a>00436 <span class="comment">         * when the LND is done, the completion event flags that the MD was</span>
<a name="l00437"></a>00437 <span class="comment">         * unlinked. Otherwise, we enqueue an event now... */</span>
<a name="l00438"></a>00438         <span class="keywordflow">if</span> (md-&gt;md_eq != NULL &amp;&amp; md-&gt;md_refcount == 0) {
<a name="l00439"></a>00439                 lnet_build_unlink_event(md, &amp;ev);
<a name="l00440"></a>00440                 lnet_eq_enqueue_event(md-&gt;md_eq, &amp;ev);
<a name="l00441"></a>00441         }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443         lnet_md_unlink(md);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445         lnet_res_unlock(cpt);
<a name="l00446"></a>00446         <span class="keywordflow">return</span> 0;
<a name="l00447"></a>00447 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:48 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
