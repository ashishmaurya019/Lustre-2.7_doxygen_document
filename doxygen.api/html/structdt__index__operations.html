<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: dt_index_operations Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dt_index_operations Struct Reference<br/>
<small>
[<a class="el" href="group__dt.html">dt</a>]</small>
</h1><!-- doxytag: class="dt_index_operations" -->
<p>Per-dt-object operations on object as index.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dt__object_8h_source.html">dt_object.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for dt_index_operations:</div>
<div class="dynsection">
<div class="center"><img src="structdt__index__operations__coll__graph.png" border="0" usemap="#dt__index__operations_coll__map" alt="Collaboration graph"/></div>
<map name="dt__index__operations_coll__map" id="dt__index__operations_coll__map">
<area shape="rect" id="node2" href="structdt__index__operations_1_1dt__it__ops.html" title="Iterator interface." alt="" coords="5,6,235,282"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations_1_1dt__it__ops.html">dt_it_ops</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator interface.  <a href="structdt__index__operations_1_1dt__it__ops.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations.html#aab6a7632adfce2297c022b12f0d61791">dio_lookup</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct dt_rec *rec, const struct dt_key *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup in an index by key.  <a href="#aab6a7632adfce2297c022b12f0d61791"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations.html#af077ea7c9f156cb161f9c361109e1f68">dio_declare_insert</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct dt_rec *rec, const struct dt_key *key, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to insert a key/value into an index.  <a href="#af077ea7c9f156cb161f9c361109e1f68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations.html#af1e0507f0ca4df0ed3f486bab027dbda">dio_insert</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct dt_rec *rec, const struct dt_key *key, struct <a class="el" href="structthandle.html">thandle</a> *th, int ignore)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new key/value pair into an index.  <a href="#af1e0507f0ca4df0ed3f486bab027dbda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations.html#aa25f7e5f60a5b9055e3f9b0898b2888b">dio_declare_delete</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct dt_key *key, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to delete a key/value from an index.  <a href="#aa25f7e5f60a5b9055e3f9b0898b2888b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations.html#abe3c3c85ed6a910700306482ba8fcd0d">dio_delete</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct dt_key *key, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete key/value pair from an index.  <a href="#abe3c3c85ed6a910700306482ba8fcd0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="el" href="structdt__index__operations_1_1dt__it__ops.html">dt_index_operations::dt_it_ops</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb">dio_it</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator interface.  <a href="#a16b19879e71b5cb1aaa459d731d580cb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Per-dt-object operations on object as index. </p>
<p>Index is a set of key/value pairs abstracted from an on-disk representation. An index supports the number of operations including lookup by key, insert and delete. Also, an index can be iterated to find the pairs one by one, from a beginning or specified point. </p>

<p>Definition at line <a class="el" href="dt__object_8h_source.html#l01366">1366</a> of file <a class="el" href="dt__object_8h_source.html">dt_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="aa25f7e5f60a5b9055e3f9b0898b2888b"></a><!-- doxytag: member="dt_index_operations::dio_declare_delete" ref="aa25f7e5f60a5b9055e3f9b0898b2888b" args=")(const struct lu_env *env, struct dt_object *dt, const struct dt_key *key, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations.html#aa25f7e5f60a5b9055e3f9b0898b2888b">dt_index_operations::dio_declare_delete</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct dt_key *key, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to delete a key/value from an index. </p>
<p>Notify the underlying filesystem that key/value may be deleted in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. Key/value format and size is subject to -&gt;do_index_try(). The object need not exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af077ea7c9f156cb161f9c361109e1f68"></a><!-- doxytag: member="dt_index_operations::dio_declare_insert" ref="af077ea7c9f156cb161f9c361109e1f68" args=")(const struct lu_env *env, struct dt_object *dt, const struct dt_rec *rec, const struct dt_key *key, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations.html#af077ea7c9f156cb161f9c361109e1f68">dt_index_operations::dio_declare_insert</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct dt_rec *rec, const struct dt_key *key, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to insert a key/value into an index. </p>
<p>Notify the underlying filesystem that new key/value may be inserted in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. key/value format and size is subject to -&gt;do_index_try().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rec</em>&nbsp;</td><td>buffer storing value </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe3c3c85ed6a910700306482ba8fcd0d"></a><!-- doxytag: member="dt_index_operations::dio_delete" ref="abe3c3c85ed6a910700306482ba8fcd0d" args=")(const struct lu_env *env, struct dt_object *dt, const struct dt_key *key, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations.html#abe3c3c85ed6a910700306482ba8fcd0d">dt_index_operations::dio_delete</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct dt_key *key, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete key/value pair from an index. </p>
<p>The method deletes specified key and corresponding value from the given index object. The internal consistency is maintained by the method or the functionality below. The format and size of the key should have been negotiated before using -&gt;do_index_try(), no additional information can be specified to the method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1e0507f0ca4df0ed3f486bab027dbda"></a><!-- doxytag: member="dt_index_operations::dio_insert" ref="af1e0507f0ca4df0ed3f486bab027dbda" args=")(const struct lu_env *env, struct dt_object *dt, const struct dt_rec *rec, const struct dt_key *key, struct thandle *th, int ignore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations.html#af1e0507f0ca4df0ed3f486bab027dbda">dt_index_operations::dio_insert</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct dt_rec *rec, const struct dt_key *key, struct <a class="el" href="structthandle.html">thandle</a> *th, int ignore)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a new key/value pair into an index. </p>
<p>The method inserts specified key/value pair into the given index object. The internal consistency is maintained by the method or the functionality below. The format and size of key/value should have been negotiated before using -&gt;do_index_try(), no additional information can be specified to the method. The keys are unique in a given index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rec</em>&nbsp;</td><td>buffer storing value </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore</em>&nbsp;</td><td>unused (was used to request quota ignorance)</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16b19879e71b5cb1aaa459d731d580cb"></a><!-- doxytag: member="dt_index_operations::dio_it" ref="a16b19879e71b5cb1aaa459d731d580cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structdt__index__operations_1_1dt__it__ops.html">dt_index_operations::dt_it_ops</a>  <a class="el" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb">dt_index_operations::dio_it</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator interface. </p>
<p>Methods to iterate over an existing index, list the keys stored and associated values, get key/value size, etc. </p>

</div>
</div>
<a class="anchor" id="aab6a7632adfce2297c022b12f0d61791"></a><!-- doxytag: member="dt_index_operations::dio_lookup" ref="aab6a7632adfce2297c022b12f0d61791" args=")(const struct lu_env *env, struct dt_object *dt, struct dt_rec *rec, const struct dt_key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__index__operations.html#aab6a7632adfce2297c022b12f0d61791">dt_index_operations::dio_lookup</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct dt_rec *rec, const struct dt_key *key)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup in an index by key. </p>
<p>The method returns a value for the given key. Key/value format and size should have been negotiated with -&gt;do_index_try() before. Thus it's the caller's responsibility to provide the method with proper key and big enough buffer. No external locking is required, all the internal consistency should be implemented by the method or lower layers. The object should should have been created with type DFT_INDEX or DFT_DIR.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>rec</em>&nbsp;</td><td>buffer where value will be stored </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>key</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>if key isn't found </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="dt__object_8h_source.html">dt_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:56:51 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
