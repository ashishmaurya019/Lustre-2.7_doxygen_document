<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/utils/mount_lustre.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/utils/mount_lustre.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2014, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lustre/utils/mount_lustre.c</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Author: Robert Read &lt;rread@clusterfs.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> * Author: Nathan Rutman &lt;nathan@clusterfs.com&gt;</span>
<a name="l00040"></a>00040 <span class="comment"> */</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#ifndef _GNU_SOURCE</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define _GNU_SOURCE</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;getopt.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;mntent.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;stdbool.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;sys/mount.h&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;lustre_ver.h&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;limits.h&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;lnet/nidstr.h&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;lustre/lustre_idl.h&gt;</span>
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;obdctl.h&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;mount_utils.h&quot;</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="preprocessor">#if LUSTRE_VERSION_CODE &lt; OBD_OCD_VERSION(2, 10, 53, 0)</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00066"></a>00066 <span class="comment"> * LU-1783</span>
<a name="l00067"></a>00067 <span class="comment"> * We only #include a kernel level include file here because</span>
<a name="l00068"></a>00068 <span class="comment"> * important MS_ flag #defines are missing from the SLES version</span>
<a name="l00069"></a>00069 <span class="comment"> * of sys/mount.h</span>
<a name="l00070"></a>00070 <span class="comment"> * In the future if SLES updates sys/mount.h to have a more complete</span>
<a name="l00071"></a>00071 <span class="comment"> * set of flag #defines we should stop including linux/fs.h</span>
<a name="l00072"></a>00072 <span class="comment"> */</span>
<a name="l00073"></a>00073 <span class="preprocessor">#if !defined(MS_RDONLY)</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/fs.h&gt;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#endif</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 <span class="preprocessor">#ifdef HAVE_LIBMOUNT</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor"># define WITH_LIBMOUNT  &quot;(libmount)&quot;</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor"># define WITH_LIBMOUNT  &quot;&quot;</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00084"></a>00084 <span class="preprocessor">#define MAXOPT 4096</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#define MAX_RETRIES 99</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00087"></a>00087 <span class="keywordtype">int</span>     verbose;
<a name="l00088"></a>00088 <span class="keywordtype">int</span>     version;
<a name="l00089"></a>00089 <span class="keywordtype">char</span>    *progname;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keywordtype">void</span> usage(FILE *out)
<a name="l00092"></a>00092 {
<a name="l00093"></a>00093         fprintf(out, <span class="stringliteral">&quot;\nThis mount helper should only be invoked via the &quot;</span>
<a name="l00094"></a>00094                 <span class="stringliteral">&quot;mount (8) command,\ne.g. mount -t lustre dev dir\n\n&quot;</span>);
<a name="l00095"></a>00095         fprintf(out, <span class="stringliteral">&quot;usage: %s [-fhnvV] [-o &lt;mntopt&gt;] &lt;device&gt; &lt;mountpt&gt;\n&quot;</span>,
<a name="l00096"></a>00096                 progname);
<a name="l00097"></a>00097         fprintf(out,
<a name="l00098"></a>00098                 <span class="stringliteral">&quot;\t&lt;device&gt;: the disk device, or for a client:\n&quot;</span>
<a name="l00099"></a>00099                 <span class="stringliteral">&quot;\t\t&lt;mgsnid&gt;[:&lt;altmgsnid&gt;...]:/&lt;filesystem&gt;[/&lt;subdir&gt;]\n&quot;</span>
<a name="l00100"></a>00100                 <span class="stringliteral">&quot;\t&lt;filesystem&gt;: name of the Lustre filesystem (e.g. lustre1)\n&quot;</span>
<a name="l00101"></a>00101                 <span class="stringliteral">&quot;\t&lt;mountpt&gt;: filesystem mountpoint (e.g. /mnt/lustre)\n&quot;</span>
<a name="l00102"></a>00102                 <span class="stringliteral">&quot;\t-f|--fake: fake mount (updates /etc/mtab)\n&quot;</span>
<a name="l00103"></a>00103                 <span class="stringliteral">&quot;\t-o force|--force: force mount even if already in /etc/mtab\n&quot;</span>
<a name="l00104"></a>00104                 <span class="stringliteral">&quot;\t-h|--help: print this usage message\n&quot;</span>
<a name="l00105"></a>00105                 <span class="stringliteral">&quot;\t-n|--nomtab: do not update /etc/mtab after mount\n&quot;</span>
<a name="l00106"></a>00106                 <span class="stringliteral">&quot;\t-v|--verbose: print verbose config settings\n&quot;</span>
<a name="l00107"></a>00107                 <span class="stringliteral">&quot;\t-V|--version: output build version of the utility and exit\n&quot;</span>
<a name="l00108"></a>00108                 <span class="stringliteral">&quot;\t&lt;mntopt&gt;: one or more comma separated of:\n&quot;</span>
<a name="l00109"></a>00109                 <span class="stringliteral">&quot;\t\t(no)flock,(no)user_xattr,(no)acl\n&quot;</span>
<a name="l00110"></a>00110                 <span class="stringliteral">&quot;\t\tabort_recov: abort server recovery handling\n&quot;</span>
<a name="l00111"></a>00111                 <span class="stringliteral">&quot;\t\tnosvc: only start MGC/MGS obds\n&quot;</span>
<a name="l00112"></a>00112                 <span class="stringliteral">&quot;\t\tnomgs: only start target obds, using existing MGS\n&quot;</span>
<a name="l00113"></a>00113                 <span class="stringliteral">&quot;\t\tnoscrub: NOT auto start OI scrub unless start explicitly\n&quot;</span>
<a name="l00114"></a>00114                 <span class="stringliteral">&quot;\t\tskip_lfsck: NOT auto resume the paused/crashed LFSCK\n&quot;</span>
<a name="l00115"></a>00115                 <span class="stringliteral">&quot;\t\texclude=&lt;ostname&gt;[:&lt;ostname&gt;] : colon-separated list of &quot;</span>
<a name="l00116"></a>00116                 <span class="stringliteral">&quot;inactive OSTs (e.g. lustre-OST0001)\n&quot;</span>
<a name="l00117"></a>00117                 <span class="stringliteral">&quot;\t\tretry=&lt;num&gt;: number of times mount is retried by client\n&quot;</span>
<a name="l00118"></a>00118                 <span class="stringliteral">&quot;\t\tmd_stripe_cache_size=&lt;num&gt;: set the raid stripe cache &quot;</span>
<a name="l00119"></a>00119                 <span class="stringliteral">&quot;size for the underlying raid if present\n&quot;</span>);
<a name="l00120"></a>00120         exit((out != stdout) ? EINVAL : 0);
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="comment">/* Get rid of symbolic hostnames for tcp, since kernel can&apos;t do lookups */</span>
<a name="l00124"></a>00124 <span class="preprocessor">#define MAXNIDSTR 1024</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">char</span> *convert_hostnames(<span class="keywordtype">char</span> *s1)
<a name="l00126"></a>00126 {
<a name="l00127"></a>00127         <span class="keywordtype">char</span> *converted, *s2 = 0, *c;
<a name="l00128"></a>00128         <span class="keywordtype">char</span> sep;
<a name="l00129"></a>00129         <span class="keywordtype">int</span> left = MAXNIDSTR;
<a name="l00130"></a>00130         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132         converted = malloc(left);
<a name="l00133"></a>00133         <span class="keywordflow">if</span> (converted == NULL) {
<a name="l00134"></a>00134                 fprintf(stderr, <span class="stringliteral">&quot;out of memory: needed %d bytes\n&quot;</span>,
<a name="l00135"></a>00135                         MAXNIDSTR);
<a name="l00136"></a>00136                 <span class="keywordflow">return</span> NULL;
<a name="l00137"></a>00137         }
<a name="l00138"></a>00138         c = converted;
<a name="l00139"></a>00139         <span class="keywordflow">while</span> ((left &gt; 0) &amp;&amp; (*s1 != <span class="charliteral">&apos;/&apos;</span>)) {
<a name="l00140"></a>00140                 s2 = strpbrk(s1, <span class="stringliteral">&quot;,:&quot;</span>);
<a name="l00141"></a>00141                 <span class="keywordflow">if</span> (!s2)
<a name="l00142"></a>00142                         <span class="keywordflow">goto</span> out_free;
<a name="l00143"></a>00143                 sep = *s2;
<a name="l00144"></a>00144                 *s2 = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00145"></a>00145                 nid = libcfs_str2nid(s1);
<a name="l00146"></a>00146                 *s2 = sep;                      <span class="comment">/* back to original string */</span>
<a name="l00147"></a>00147                 <span class="keywordflow">if</span> (nid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>)
<a name="l00148"></a>00148                         <span class="keywordflow">goto</span> out_free;
<a name="l00149"></a>00149                 c += snprintf(c, left, <span class="stringliteral">&quot;%s%c&quot;</span>, libcfs_nid2str(nid), sep);
<a name="l00150"></a>00150                 left = converted + MAXNIDSTR - c;
<a name="l00151"></a>00151                 s1 = s2 + 1;
<a name="l00152"></a>00152         }
<a name="l00153"></a>00153         snprintf(c, left, <span class="stringliteral">&quot;%s&quot;</span>, s1);
<a name="l00154"></a>00154         <span class="keywordflow">return</span> converted;
<a name="l00155"></a>00155 out_free:
<a name="l00156"></a>00156         fprintf(stderr, <span class="stringliteral">&quot;%s: Can&apos;t parse NID &apos;%s&apos;\n&quot;</span>, progname, s1);
<a name="l00157"></a>00157         free(converted);
<a name="l00158"></a>00158         <span class="keywordflow">return</span> NULL;
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment">/*****************************************************************************</span>
<a name="l00162"></a>00162 <span class="comment"> *</span>
<a name="l00163"></a>00163 <span class="comment"> * This part was cribbed from util-linux/mount/mount.c.  There was no clear</span>
<a name="l00164"></a>00164 <span class="comment"> * license information, but many other files in the package are identified as</span>
<a name="l00165"></a>00165 <span class="comment"> * GNU GPL, so it&apos;s a pretty safe bet that was their intent.</span>
<a name="l00166"></a>00166 <span class="comment"> *</span>
<a name="l00167"></a>00167 <span class="comment"> ****************************************************************************/</span>
<a name="l00168"></a>00168 <span class="keyword">struct </span>opt_map {
<a name="l00169"></a>00169         <span class="keyword">const</span> <span class="keywordtype">char</span> *opt;        <span class="comment">/* option name */</span>
<a name="l00170"></a>00170         <span class="keywordtype">int</span> inv;                <span class="comment">/* true if flag value should be inverted */</span>
<a name="l00171"></a>00171         <span class="keywordtype">int</span> mask;               <span class="comment">/* flag mask value */</span>
<a name="l00172"></a>00172 };
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>opt_map opt_map[] = {
<a name="l00175"></a>00175   <span class="comment">/*&quot;optname&quot;, inv,ms_mask */</span>
<a name="l00176"></a>00176   <span class="comment">/* These flags are parsed by mount, not lustre */</span>
<a name="l00177"></a>00177   { <span class="stringliteral">&quot;defaults&quot;</span>, 0, 0         },      <span class="comment">/* default options */</span>
<a name="l00178"></a>00178   { <span class="stringliteral">&quot;remount&quot;</span>,  0, MS_REMOUNT},      <span class="comment">/* remount with different options */</span>
<a name="l00179"></a>00179   { <span class="stringliteral">&quot;rw&quot;</span>,       1, MS_RDONLY },      <span class="comment">/* read-write */</span>
<a name="l00180"></a>00180   { <span class="stringliteral">&quot;ro&quot;</span>,       0, MS_RDONLY },      <span class="comment">/* read-only */</span>
<a name="l00181"></a>00181   { <span class="stringliteral">&quot;exec&quot;</span>,     1, MS_NOEXEC },      <span class="comment">/* permit execution of binaries */</span>
<a name="l00182"></a>00182   { <span class="stringliteral">&quot;noexec&quot;</span>,   0, MS_NOEXEC },      <span class="comment">/* don&apos;t execute binaries */</span>
<a name="l00183"></a>00183   { <span class="stringliteral">&quot;suid&quot;</span>,     1, MS_NOSUID },      <span class="comment">/* honor suid executables */</span>
<a name="l00184"></a>00184   { <span class="stringliteral">&quot;nosuid&quot;</span>,   0, MS_NOSUID },      <span class="comment">/* don&apos;t honor suid executables */</span>
<a name="l00185"></a>00185   { <span class="stringliteral">&quot;dev&quot;</span>,      1, MS_NODEV  },      <span class="comment">/* interpret device files  */</span>
<a name="l00186"></a>00186   { <span class="stringliteral">&quot;nodev&quot;</span>,    0, MS_NODEV  },      <span class="comment">/* don&apos;t interpret devices */</span>
<a name="l00187"></a>00187   { <span class="stringliteral">&quot;sync&quot;</span>,     0, MS_SYNCHRONOUS},  <span class="comment">/* synchronous I/O */</span>
<a name="l00188"></a>00188   { <span class="stringliteral">&quot;async&quot;</span>,    1, MS_SYNCHRONOUS},  <span class="comment">/* asynchronous I/O */</span>
<a name="l00189"></a>00189   { <span class="stringliteral">&quot;atime&quot;</span>,    1, MS_NOATIME  },    <span class="comment">/* set file access time on read */</span>
<a name="l00190"></a>00190   { <span class="stringliteral">&quot;noatime&quot;</span>,  0, MS_NOATIME  },    <span class="comment">/* do not set file access time on read */</span>
<a name="l00191"></a>00191 <span class="preprocessor">#ifdef MS_NODIRATIME</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span>  { <span class="stringliteral">&quot;diratime&quot;</span>, 1, MS_NODIRATIME },  <span class="comment">/* set file access time on read */</span>
<a name="l00193"></a>00193   { <span class="stringliteral">&quot;nodiratime&quot;</span>,0,MS_NODIRATIME },  <span class="comment">/* do not set file access time on read */</span>
<a name="l00194"></a>00194 <span class="preprocessor">#endif</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span><span class="preprocessor">#ifdef MS_RELATIME</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span>  { <span class="stringliteral">&quot;relatime&quot;</span>, 0, MS_RELATIME },  <span class="comment">/* set file access time on read */</span>
<a name="l00197"></a>00197   { <span class="stringliteral">&quot;norelatime&quot;</span>,1,MS_RELATIME },  <span class="comment">/* do not set file access time on read */</span>
<a name="l00198"></a>00198 <span class="preprocessor">#endif</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span><span class="preprocessor">#ifdef MS_STRICTATIME</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span>  { <span class="stringliteral">&quot;strictatime&quot;</span>,0,MS_STRICTATIME },  <span class="comment">/* update access time strictly */</span>
<a name="l00201"></a>00201 <span class="preprocessor">#endif</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span>  { <span class="stringliteral">&quot;auto&quot;</span>,     0, 0         },      <span class="comment">/* Can be mounted using -a */</span>
<a name="l00203"></a>00203   { <span class="stringliteral">&quot;noauto&quot;</span>,   0, 0         },      <span class="comment">/* Can only be mounted explicitly */</span>
<a name="l00204"></a>00204   { <span class="stringliteral">&quot;nousers&quot;</span>,  1, 0         },      <span class="comment">/* Forbid ordinary user to mount */</span>
<a name="l00205"></a>00205   { <span class="stringliteral">&quot;nouser&quot;</span>,   1, 0         },      <span class="comment">/* Forbid ordinary user to mount */</span>
<a name="l00206"></a>00206   { <span class="stringliteral">&quot;noowner&quot;</span>,  1, 0         },      <span class="comment">/* Device owner has no special privs */</span>
<a name="l00207"></a>00207   { <span class="stringliteral">&quot;_netdev&quot;</span>,  0, 0         },      <span class="comment">/* Device accessible only via network */</span>
<a name="l00208"></a>00208   { <span class="stringliteral">&quot;loop&quot;</span>,     0, 0         },
<a name="l00209"></a>00209   { NULL,       0, 0         }
<a name="l00210"></a>00210 };
<a name="l00211"></a>00211 <span class="comment">/****************************************************************************/</span>
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="comment">/* 1  = don&apos;t pass on to lustre</span>
<a name="l00214"></a>00214 <span class="comment">   0  = pass on to lustre */</span>
<a name="l00215"></a>00215 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_one_option(<span class="keyword">const</span> <span class="keywordtype">char</span> *check, <span class="keywordtype">int</span> *flagp)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217         <span class="keyword">const</span> <span class="keyword">struct </span>opt_map *opt;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <span class="keywordflow">for</span> (opt = &amp;opt_map[0]; opt-&gt;opt != NULL; opt++) {
<a name="l00220"></a>00220                 <span class="keywordflow">if</span> (strncmp(check, opt-&gt;opt, strlen(opt-&gt;opt)) == 0) {
<a name="l00221"></a>00221                         <span class="keywordflow">if</span> (opt-&gt;mask) {
<a name="l00222"></a>00222                                 <span class="keywordflow">if</span> (opt-&gt;inv)
<a name="l00223"></a>00223                                         *flagp &amp;= ~(opt-&gt;mask);
<a name="l00224"></a>00224                                 <span class="keywordflow">else</span>
<a name="l00225"></a>00225                                         *flagp |= opt-&gt;mask;
<a name="l00226"></a>00226                         }
<a name="l00227"></a>00227                         <span class="keywordflow">return</span> 1;
<a name="l00228"></a>00228                 }
<a name="l00229"></a>00229         }
<a name="l00230"></a>00230         <span class="comment">/* Assume any unknown options are valid and pass them on.  The mount</span>
<a name="l00231"></a>00231 <span class="comment">           will fail if lmd_parse, ll_options or ldiskfs doesn&apos;t recognize it.*/</span>
<a name="l00232"></a>00232         <span class="keywordflow">return</span> 0;
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="keyword">static</span> <span class="keywordtype">void</span> append_option(<span class="keywordtype">char</span> *options, <span class="keyword">const</span> <span class="keywordtype">char</span> *one)
<a name="l00236"></a>00236 {
<a name="l00237"></a>00237         <span class="keywordflow">if</span> (*options)
<a name="l00238"></a>00238                 strcat(options, <span class="stringliteral">&quot;,&quot;</span>);
<a name="l00239"></a>00239         strcat(options, one);
<a name="l00240"></a>00240 }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="comment">/* Replace options with subset of Lustre-specific options, and</span>
<a name="l00243"></a>00243 <span class="comment">   fill in mount flags */</span>
<a name="l00244"></a>00244 <span class="keywordtype">int</span> parse_options(<span class="keyword">struct</span> <a class="code" href="structmount__opts.html">mount_opts</a> *mop, <span class="keywordtype">char</span> *orig_options, <span class="keywordtype">int</span> *flagp)
<a name="l00245"></a>00245 {
<a name="l00246"></a>00246         <span class="keywordtype">char</span> *options, *opt, *nextopt, *arg, *val;
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         options = calloc(strlen(orig_options) + 1, 1);
<a name="l00249"></a>00249         *flagp = 0;
<a name="l00250"></a>00250         nextopt = orig_options;
<a name="l00251"></a>00251         <span class="keywordflow">while</span> ((opt = strsep(&amp;nextopt, <span class="stringliteral">&quot;,&quot;</span>))) {
<a name="l00252"></a>00252                 <span class="keywordflow">if</span> (!*opt)
<a name="l00253"></a>00253                         <span class="comment">/* empty option */</span>
<a name="l00254"></a>00254                         <span class="keywordflow">continue</span>;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256                 <span class="comment">/* Handle retries in a slightly different</span>
<a name="l00257"></a>00257 <span class="comment">                 * manner */</span>
<a name="l00258"></a>00258                 arg = opt;
<a name="l00259"></a>00259                 val = strchr(opt, <span class="charliteral">&apos;=&apos;</span>);
<a name="l00260"></a>00260                 <span class="comment">/* please note that some ldiskfs mount options are also in the form</span>
<a name="l00261"></a>00261 <span class="comment">                 * of param=value. We should pay attention not to remove those</span>
<a name="l00262"></a>00262 <span class="comment">                 * mount options, see bug 22097. */</span>
<a name="l00263"></a>00263                 <span class="keywordflow">if</span> (val &amp;&amp; strncmp(arg, <span class="stringliteral">&quot;md_stripe_cache_size&quot;</span>, 20) == 0) {
<a name="l00264"></a>00264                         mop-&gt;mo_md_stripe_cache_size = atoi(val + 1);
<a name="l00265"></a>00265                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val &amp;&amp; strncmp(arg, <span class="stringliteral">&quot;retry&quot;</span>, 5) == 0) {
<a name="l00266"></a>00266                         mop-&gt;mo_retry = atoi(val + 1);
<a name="l00267"></a>00267                         <span class="keywordflow">if</span> (mop-&gt;mo_retry &gt; MAX_RETRIES)
<a name="l00268"></a>00268                                 mop-&gt;mo_retry = MAX_RETRIES;
<a name="l00269"></a>00269                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mop-&gt;mo_retry &lt; 0)
<a name="l00270"></a>00270                                 mop-&gt;mo_retry = 0;
<a name="l00271"></a>00271                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val &amp;&amp; strncmp(arg, <span class="stringliteral">&quot;mgssec&quot;</span>, 6) == 0) {
<a name="l00272"></a>00272                         append_option(options, opt);
<a name="l00273"></a>00273                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(arg, <span class="stringliteral">&quot;nosvc&quot;</span>, 5) == 0) {
<a name="l00274"></a>00274                         mop-&gt;mo_nosvc = 1;
<a name="l00275"></a>00275                         append_option(options, opt);
<a name="l00276"></a>00276                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;force&quot;</span>) == 0) {
<a name="l00277"></a>00277                         <span class="comment">/* XXX special check for &apos;force&apos; option */</span>
<a name="l00278"></a>00278                         ++mop-&gt;mo_force;
<a name="l00279"></a>00279                         printf(<span class="stringliteral">&quot;force: %d\n&quot;</span>, mop-&gt;mo_force);
<a name="l00280"></a>00280                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parse_one_option(opt, flagp) == 0) {
<a name="l00281"></a>00281                         <span class="comment">/* pass this on as an option */</span>
<a name="l00282"></a>00282                         append_option(options, opt);
<a name="l00283"></a>00283                 }
<a name="l00284"></a>00284         }
<a name="l00285"></a>00285 <span class="preprocessor">#ifdef MS_STRICTATIME</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span><span class="preprocessor">#if LUSTRE_VERSION_CODE &gt; OBD_OCD_VERSION(3, 2, 53, 0)</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span>        <span class="comment">/*</span>
<a name="l00288"></a>00288 <span class="comment">         * LU-1783</span>
<a name="l00289"></a>00289 <span class="comment">         * In the future when upstream fixes land in all supported kernels</span>
<a name="l00290"></a>00290 <span class="comment">         * we should stop forcing MS_STRICTATIME in lustre mounts.</span>
<a name="l00291"></a>00291 <span class="comment">         * We override the kernel level default of MS_RELATIME for now</span>
<a name="l00292"></a>00292 <span class="comment">         * due to a kernel vfs level bug in atime updates that fails</span>
<a name="l00293"></a>00293 <span class="comment">         * to reset timestamps from the future.</span>
<a name="l00294"></a>00294 <span class="comment">         */</span>
<a name="l00295"></a>00295 <span class="preprocessor">#warn &quot;remove MS_STRICTATIME override if kernel updates atime from the future&quot;</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span>        <span class="comment">/* set strictatime to default if NOATIME or RELATIME</span>
<a name="l00298"></a>00298 <span class="comment">           not given explicit */</span>
<a name="l00299"></a>00299         <span class="keywordflow">if</span> (!(*flagp &amp; (MS_NOATIME | MS_RELATIME)))
<a name="l00300"></a>00300                 *flagp |= MS_STRICTATIME;
<a name="l00301"></a>00301 <span class="preprocessor">#endif</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span>        strcpy(orig_options, options);
<a name="l00303"></a>00303         free(options);
<a name="l00304"></a>00304 
<a name="l00305"></a>00305         <span class="keywordflow">return</span> 0;
<a name="l00306"></a>00306 }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="comment">/* Add mgsnids from ldd params */</span>
<a name="l00309"></a>00309 <span class="keyword">static</span> <span class="keywordtype">int</span> add_mgsnids(<span class="keyword">struct</span> <a class="code" href="structmount__opts.html">mount_opts</a> *mop, <span class="keywordtype">char</span> *options,
<a name="l00310"></a>00310                        <span class="keyword">const</span> <span class="keywordtype">char</span> *params)
<a name="l00311"></a>00311 {
<a name="l00312"></a>00312         <span class="keywordtype">char</span> *ptr = (<span class="keywordtype">char</span> *)params;
<a name="l00313"></a>00313         <span class="keywordtype">char</span> tmp, *sep;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315         <span class="keywordflow">while</span> ((ptr = strstr(ptr, PARAM_MGSNODE)) != NULL) {
<a name="l00316"></a>00316                 sep = strchr(ptr, <span class="charliteral">&apos; &apos;</span>);
<a name="l00317"></a>00317                 <span class="keywordflow">if</span> (sep != NULL) {
<a name="l00318"></a>00318                         tmp = *sep;
<a name="l00319"></a>00319                         *sep = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00320"></a>00320                 }
<a name="l00321"></a>00321                 append_option(options, ptr);
<a name="l00322"></a>00322                 mop-&gt;mo_have_mgsnid++;
<a name="l00323"></a>00323                 <span class="keywordflow">if</span> (sep) {
<a name="l00324"></a>00324                         *sep = tmp;
<a name="l00325"></a>00325                         ptr = sep;
<a name="l00326"></a>00326                 } <span class="keywordflow">else</span> {
<a name="l00327"></a>00327                         <span class="keywordflow">break</span>;
<a name="l00328"></a>00328                 }
<a name="l00329"></a>00329         }
<a name="l00330"></a>00330 
<a name="l00331"></a>00331         <span class="keywordflow">return</span> 0;
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="keyword">static</span> <span class="keywordtype">int</span> clear_update_ondisk(<span class="keywordtype">char</span> *source, <span class="keyword">struct</span> <a class="code" href="structlustre__disk__data.html">lustre_disk_data</a> *ldd)
<a name="l00335"></a>00335 {
<a name="l00336"></a>00336         <span class="keywordtype">char</span> wanted_mountopts[512] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00337"></a>00337         <span class="keyword">struct </span><a class="code" href="structmkfs__opts.html">mkfs_opts</a> mkop;
<a name="l00338"></a>00338         <span class="keywordtype">int</span> ret;
<a name="l00339"></a>00339         <span class="keywordtype">int</span> ret2;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341         memset(&amp;mkop, 0, <span class="keyword">sizeof</span>(mkop));
<a name="l00342"></a>00342         mkop.mo_ldd = *ldd;
<a name="l00343"></a>00343         mkop.mo_ldd.ldd_flags &amp;= ~<a class="code" href="group__disk.html#gaa75f3fef040b421a74d6831ca5aedd3b" title="update the config logs for this server">LDD_F_UPDATE</a>;
<a name="l00344"></a>00344         <span class="keywordflow">if</span> (strlen(source) &gt; <span class="keyword">sizeof</span>(mkop.mo_device)-1) {
<a name="l00345"></a>00345                 fatal();
<a name="l00346"></a>00346                 fprintf(stderr, <span class="stringliteral">&quot;Device name too long: %s\n&quot;</span>, source);
<a name="l00347"></a>00347                 <span class="keywordflow">return</span> -E2BIG;
<a name="l00348"></a>00348         }
<a name="l00349"></a>00349         strncpy(mkop.mo_device, source, <span class="keyword">sizeof</span>(mkop.mo_device));
<a name="l00350"></a>00350 
<a name="l00351"></a>00351         ret = osd_prepare_lustre(&amp;mkop,
<a name="l00352"></a>00352                                  wanted_mountopts, <span class="keyword">sizeof</span>(wanted_mountopts));
<a name="l00353"></a>00353         <span class="keywordflow">if</span> (ret) {
<a name="l00354"></a>00354                 fatal();
<a name="l00355"></a>00355                 fprintf(stderr, <span class="stringliteral">&quot;Can&apos;t prepare device %s: %s\n&quot;</span>,
<a name="l00356"></a>00356                         source, strerror(ret));
<a name="l00357"></a>00357                 <span class="keywordflow">return</span> ret;
<a name="l00358"></a>00358         }
<a name="l00359"></a>00359 
<a name="l00360"></a>00360         <span class="comment">/* Create the loopback file */</span>
<a name="l00361"></a>00361         <span class="keywordflow">if</span> (mkop.mo_flags &amp; MO_IS_LOOP) {
<a name="l00362"></a>00362                 ret = access(mkop.mo_device, F_OK);
<a name="l00363"></a>00363                 <span class="keywordflow">if</span> (ret) {
<a name="l00364"></a>00364                         ret = errno;
<a name="l00365"></a>00365                         fatal();
<a name="l00366"></a>00366                         fprintf(stderr, <span class="stringliteral">&quot;Can&apos;t access device %s: %s\n&quot;</span>,
<a name="l00367"></a>00367                                         source, strerror(ret));
<a name="l00368"></a>00368                         <span class="keywordflow">return</span> ret;
<a name="l00369"></a>00369                 }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371                 ret = loop_setup(&amp;mkop);
<a name="l00372"></a>00372                 <span class="keywordflow">if</span> (ret) {
<a name="l00373"></a>00373                         fatal();
<a name="l00374"></a>00374                         fprintf(stderr, <span class="stringliteral">&quot;Loop device setup for %s failed: %s\n&quot;</span>,
<a name="l00375"></a>00375                                         mkop.mo_device, strerror(ret));
<a name="l00376"></a>00376                         <span class="keywordflow">return</span> ret;
<a name="l00377"></a>00377                 }
<a name="l00378"></a>00378         }
<a name="l00379"></a>00379         ret = osd_write_ldd(&amp;mkop);
<a name="l00380"></a>00380         <span class="keywordflow">if</span> (ret != 0) {
<a name="l00381"></a>00381                 fatal();
<a name="l00382"></a>00382                 fprintf(stderr, <span class="stringliteral">&quot;failed to write local files: %s\n&quot;</span>,
<a name="l00383"></a>00383                         strerror(ret));
<a name="l00384"></a>00384         }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         ret2 = loop_cleanup(&amp;mkop);
<a name="l00387"></a>00387         <span class="keywordflow">if</span> (ret == 0)
<a name="l00388"></a>00388                 ret = ret2;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         <span class="keywordflow">return</span> ret;
<a name="l00391"></a>00391 }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_ldd(<span class="keywordtype">char</span> *source, <span class="keyword">struct</span> <a class="code" href="structmount__opts.html">mount_opts</a> *mop, <span class="keywordtype">char</span> *options)
<a name="l00394"></a>00394 {
<a name="l00395"></a>00395         <span class="keyword">struct </span><a class="code" href="structlustre__disk__data.html">lustre_disk_data</a> *ldd = &amp;mop-&gt;mo_ldd;
<a name="l00396"></a>00396         <span class="keywordtype">char</span> *cur, *start;
<a name="l00397"></a>00397         <span class="keywordtype">int</span> rc;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399         rc = osd_is_lustre(source, &amp;ldd-&gt;ldd_mount_type);
<a name="l00400"></a>00400         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00401"></a>00401                 fprintf(stderr, <span class="stringliteral">&quot;%s: %s has not been formatted with mkfs.lustre&quot;</span>
<a name="l00402"></a>00402                         <span class="stringliteral">&quot; or the backend filesystem type is not supported by &quot;</span>
<a name="l00403"></a>00403                         <span class="stringliteral">&quot;this tool\n&quot;</span>, progname, source);
<a name="l00404"></a>00404                 <span class="keywordflow">return</span> ENODEV;
<a name="l00405"></a>00405         }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407         rc = osd_read_ldd(source, ldd);
<a name="l00408"></a>00408         <span class="keywordflow">if</span> (rc) {
<a name="l00409"></a>00409                 fprintf(stderr, <span class="stringliteral">&quot;%s: %s failed to read permanent mount&quot;</span>
<a name="l00410"></a>00410                         <span class="stringliteral">&quot; data: %s\n&quot;</span>, progname, source,
<a name="l00411"></a>00411                         rc &gt;= 0 ? strerror(rc) : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00412"></a>00412                 <span class="keywordflow">return</span> rc;
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415         <span class="keywordflow">if</span> ((IS_MDT(ldd) || IS_OST(ldd)) &amp;&amp;
<a name="l00416"></a>00416             (ldd-&gt;ldd_flags &amp; <a class="code" href="group__disk.html#ga9fce74a12d3a51b34593e3564f568cb3" title="need an index assignment">LDD_F_NEED_INDEX</a>)) {
<a name="l00417"></a>00417                 fprintf(stderr, <span class="stringliteral">&quot;%s: %s has no index assigned &quot;</span>
<a name="l00418"></a>00418                         <span class="stringliteral">&quot;(probably formatted with old mkfs)\n&quot;</span>,
<a name="l00419"></a>00419                         progname, source);
<a name="l00420"></a>00420                 <span class="keywordflow">return</span> EINVAL;
<a name="l00421"></a>00421         }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         <span class="keywordflow">if</span> (ldd-&gt;ldd_flags &amp; <a class="code" href="group__disk.html#ga3e4e463c72276acee4dd93d475ed61ac" title="COMPAT_14.">LDD_F_UPGRADE14</a>) {
<a name="l00424"></a>00424                 fprintf(stderr, <span class="stringliteral">&quot;%s: we cannot upgrade %s from this (very old) &quot;</span>
<a name="l00425"></a>00425                         <span class="stringliteral">&quot;Lustre version\n&quot;</span>, progname, source);
<a name="l00426"></a>00426                 <span class="keywordflow">return</span> EINVAL;
<a name="l00427"></a>00427         }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429         <span class="keywordflow">if</span> (ldd-&gt;ldd_flags &amp; <a class="code" href="group__disk.html#gaa75f3fef040b421a74d6831ca5aedd3b" title="update the config logs for this server">LDD_F_UPDATE</a>)
<a name="l00430"></a>00430                 clear_update_ondisk(source, ldd);
<a name="l00431"></a>00431 
<a name="l00432"></a>00432         <span class="comment">/* Since we never rewrite ldd, ignore temp flags */</span>
<a name="l00433"></a>00433         ldd-&gt;ldd_flags &amp;= ~(<a class="code" href="group__disk.html#ga4102f845e0b2ff614a190a910fd6e980" title="never registered">LDD_F_VIRGIN</a> | <a class="code" href="group__disk.html#gaa1fbb85f93ed3c121aae3ec558b1b41e" title="regenerate config logs for this fs or server">LDD_F_WRITECONF</a>);
<a name="l00434"></a>00434 
<a name="l00435"></a>00435         <span class="comment">/* svname of the form lustre:OST1234 means never registered */</span>
<a name="l00436"></a>00436         rc = strlen(ldd-&gt;ldd_svname);
<a name="l00437"></a>00437         <span class="keywordflow">if</span> (strcmp(ldd-&gt;ldd_svname, <span class="stringliteral">&quot;MGS&quot;</span>) != 0) {
<a name="l00438"></a>00438                 <span class="keywordflow">if</span> (rc &lt; 8) {
<a name="l00439"></a>00439                         fprintf(stderr, <span class="stringliteral">&quot;%s: invalid name &apos;%s&apos;\n&quot;</span>,
<a name="l00440"></a>00440                                 progname, ldd-&gt;ldd_svname);
<a name="l00441"></a>00441                         <span class="keywordflow">return</span> EINVAL;
<a name="l00442"></a>00442                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ldd-&gt;ldd_svname[rc - 8] == <span class="charliteral">&apos;:&apos;</span>) {
<a name="l00443"></a>00443                         ldd-&gt;ldd_svname[rc - 8] = <span class="charliteral">&apos;-&apos;</span>;
<a name="l00444"></a>00444                         ldd-&gt;ldd_flags |= <a class="code" href="group__disk.html#ga4102f845e0b2ff614a190a910fd6e980" title="never registered">LDD_F_VIRGIN</a>;
<a name="l00445"></a>00445                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ldd-&gt;ldd_svname[rc - 8] == <span class="charliteral">&apos;=&apos;</span>) {
<a name="l00446"></a>00446                         ldd-&gt;ldd_svname[rc - 8] = <span class="charliteral">&apos;-&apos;</span>;
<a name="l00447"></a>00447                         ldd-&gt;ldd_flags |= <a class="code" href="group__disk.html#gaa1fbb85f93ed3c121aae3ec558b1b41e" title="regenerate config logs for this fs or server">LDD_F_WRITECONF</a>;
<a name="l00448"></a>00448                 }
<a name="l00449"></a>00449         }
<a name="l00450"></a>00450         <span class="comment">/* backend osd type */</span>
<a name="l00451"></a>00451         append_option(options, <span class="stringliteral">&quot;osd=&quot;</span>);
<a name="l00452"></a>00452         strcat(options, mt_type(ldd-&gt;ldd_mount_type));
<a name="l00453"></a>00453 
<a name="l00454"></a>00454         append_option(options, ldd-&gt;ldd_mount_opts);
<a name="l00455"></a>00455 
<a name="l00456"></a>00456         <span class="keywordflow">if</span> (!mop-&gt;mo_have_mgsnid) {
<a name="l00457"></a>00457                 <span class="comment">/* Only use disk data if mount -o mgsnode=nid wasn&apos;t</span>
<a name="l00458"></a>00458 <span class="comment">                 * specified */</span>
<a name="l00459"></a>00459                 <span class="keywordflow">if</span> (ldd-&gt;ldd_flags &amp; LDD_F_SV_TYPE_MGS) {
<a name="l00460"></a>00460                         append_option(options, <span class="stringliteral">&quot;mgs&quot;</span>);
<a name="l00461"></a>00461                         mop-&gt;mo_have_mgsnid++;
<a name="l00462"></a>00462                 } <span class="keywordflow">else</span> {
<a name="l00463"></a>00463                         add_mgsnids(mop, options, ldd-&gt;ldd_params);
<a name="l00464"></a>00464                 }
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466         <span class="comment">/* Better have an mgsnid by now */</span>
<a name="l00467"></a>00467         <span class="keywordflow">if</span> (!mop-&gt;mo_have_mgsnid) {
<a name="l00468"></a>00468                 fprintf(stderr, <span class="stringliteral">&quot;%s: missing option mgsnode=&lt;nid&gt;\n&quot;</span>,
<a name="l00469"></a>00469                         progname);
<a name="l00470"></a>00470                 <span class="keywordflow">return</span> EINVAL;
<a name="l00471"></a>00471         }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         <span class="keywordflow">if</span> (ldd-&gt;ldd_flags &amp; <a class="code" href="group__disk.html#ga4102f845e0b2ff614a190a910fd6e980" title="never registered">LDD_F_VIRGIN</a>)
<a name="l00474"></a>00474                 append_option(options, <span class="stringliteral">&quot;virgin&quot;</span>);
<a name="l00475"></a>00475         <span class="keywordflow">if</span> (ldd-&gt;ldd_flags &amp; <a class="code" href="group__disk.html#gaa75f3fef040b421a74d6831ca5aedd3b" title="update the config logs for this server">LDD_F_UPDATE</a>)
<a name="l00476"></a>00476                 append_option(options, <span class="stringliteral">&quot;update&quot;</span>);
<a name="l00477"></a>00477         <span class="keywordflow">if</span> (ldd-&gt;ldd_flags &amp; <a class="code" href="group__disk.html#gaa1fbb85f93ed3c121aae3ec558b1b41e" title="regenerate config logs for this fs or server">LDD_F_WRITECONF</a>)
<a name="l00478"></a>00478                 append_option(options, <span class="stringliteral">&quot;writeconf&quot;</span>);
<a name="l00479"></a>00479         <span class="keywordflow">if</span> (ldd-&gt;ldd_flags &amp; <a class="code" href="group__disk.html#gafda4395ad502fc3e35ff75526f1224ca" title="all nodes are specified as service nodes">LDD_F_NO_PRIMNODE</a>)
<a name="l00480"></a>00480                 append_option(options, <span class="stringliteral">&quot;noprimnode&quot;</span>);
<a name="l00481"></a>00481 
<a name="l00482"></a>00482         <span class="comment">/* prefix every lustre parameter with param= so that in-kernel</span>
<a name="l00483"></a>00483 <span class="comment">         * mount can recognize them properly and send to MGS at registration */</span>
<a name="l00484"></a>00484         start = ldd-&gt;ldd_params;
<a name="l00485"></a>00485         <span class="keywordflow">while</span> (start &amp;&amp; *start != <span class="charliteral">&apos;\0&apos;</span>) {
<a name="l00486"></a>00486                 <span class="keywordflow">while</span> (*start == <span class="charliteral">&apos; &apos;</span>) start++;
<a name="l00487"></a>00487                 <span class="keywordflow">if</span> (*start == <span class="charliteral">&apos;\0&apos;</span>)
<a name="l00488"></a>00488                         <span class="keywordflow">break</span>;
<a name="l00489"></a>00489                 cur = start;
<a name="l00490"></a>00490                 start = strchr(cur, <span class="charliteral">&apos; &apos;</span>);
<a name="l00491"></a>00491                 <span class="keywordflow">if</span> (start) {
<a name="l00492"></a>00492                         *start = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00493"></a>00493                         start++;
<a name="l00494"></a>00494                 }
<a name="l00495"></a>00495                 append_option(options, <span class="stringliteral">&quot;param=&quot;</span>);
<a name="l00496"></a>00496                 strcat(options, cur);
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499         <span class="comment">/* svname must be last option */</span>
<a name="l00500"></a>00500         append_option(options, <span class="stringliteral">&quot;svname=&quot;</span>);
<a name="l00501"></a>00501         strcat(options, ldd-&gt;ldd_svname);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503         <span class="keywordflow">return</span> 0;
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="keyword">static</span> <span class="keywordtype">void</span> set_defaults(<span class="keyword">struct</span> <a class="code" href="structmount__opts.html">mount_opts</a> *mop)
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508         memset(mop, 0, <span class="keyword">sizeof</span>(*mop));
<a name="l00509"></a>00509         mop-&gt;mo_usource = NULL;
<a name="l00510"></a>00510         mop-&gt;mo_source = NULL;
<a name="l00511"></a>00511         mop-&gt;mo_nomtab = 0;
<a name="l00512"></a>00512         mop-&gt;mo_fake = 0;
<a name="l00513"></a>00513         mop-&gt;mo_force = 0;
<a name="l00514"></a>00514         mop-&gt;mo_retry = 0;
<a name="l00515"></a>00515         mop-&gt;mo_have_mgsnid = 0;
<a name="l00516"></a>00516         mop-&gt;mo_md_stripe_cache_size = 16384;
<a name="l00517"></a>00517         mop-&gt;mo_orig_options = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00518"></a>00518         mop-&gt;mo_nosvc = 0;
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_opts(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">struct</span> <a class="code" href="structmount__opts.html">mount_opts</a> *mop)
<a name="l00522"></a>00522 {
<a name="l00523"></a>00523         <span class="keyword">static</span> <span class="keyword">struct </span>option long_opt[] = {
<a name="l00524"></a>00524                 {<span class="stringliteral">&quot;fake&quot;</span>, 0, 0, <span class="charliteral">&apos;f&apos;</span>},
<a name="l00525"></a>00525                 {<span class="stringliteral">&quot;force&quot;</span>, 0, 0, 1},
<a name="l00526"></a>00526                 {<span class="stringliteral">&quot;help&quot;</span>, 0, 0, <span class="charliteral">&apos;h&apos;</span>},
<a name="l00527"></a>00527                 {<span class="stringliteral">&quot;nomtab&quot;</span>, 0, 0, <span class="charliteral">&apos;n&apos;</span>},
<a name="l00528"></a>00528                 {<span class="stringliteral">&quot;options&quot;</span>, 1, 0, <span class="charliteral">&apos;o&apos;</span>},
<a name="l00529"></a>00529                 {<span class="stringliteral">&quot;verbose&quot;</span>, 0, 0, <span class="charliteral">&apos;v&apos;</span>},
<a name="l00530"></a>00530                 {<span class="stringliteral">&quot;version&quot;</span>, 0, 0, <span class="charliteral">&apos;V&apos;</span>},
<a name="l00531"></a>00531                 {0, 0, 0, 0}
<a name="l00532"></a>00532         };
<a name="l00533"></a>00533         <span class="keywordtype">char</span> real_path[PATH_MAX] = {<span class="charliteral">&apos;\0&apos;</span>};
<a name="l00534"></a>00534         FILE *f;
<a name="l00535"></a>00535         <span class="keywordtype">char</span> path[256], name[256];
<a name="l00536"></a>00536         <span class="keywordtype">size_t</span> sz;
<a name="l00537"></a>00537         <span class="keywordtype">char</span> *ptr;
<a name="l00538"></a>00538         <span class="keywordtype">int</span> opt, rc;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540         <span class="keywordflow">while</span> ((opt = getopt_long(argc, argv, <span class="stringliteral">&quot;fhno:vV&quot;</span>,
<a name="l00541"></a>00541                                   long_opt, NULL)) != EOF){
<a name="l00542"></a>00542                 <span class="keywordflow">switch</span> (opt) {
<a name="l00543"></a>00543                 <span class="keywordflow">case</span> 1:
<a name="l00544"></a>00544                         ++mop-&gt;mo_force;
<a name="l00545"></a>00545                         printf(<span class="stringliteral">&quot;force: %d\n&quot;</span>, mop-&gt;mo_force);
<a name="l00546"></a>00546                         <span class="keywordflow">break</span>;
<a name="l00547"></a>00547                 <span class="keywordflow">case</span> <span class="charliteral">&apos;f&apos;</span>:
<a name="l00548"></a>00548                         ++mop-&gt;mo_fake;
<a name="l00549"></a>00549                         printf(<span class="stringliteral">&quot;fake: %d\n&quot;</span>, mop-&gt;mo_fake);
<a name="l00550"></a>00550                         <span class="keywordflow">break</span>;
<a name="l00551"></a>00551                 <span class="keywordflow">case</span> <span class="charliteral">&apos;h&apos;</span>:
<a name="l00552"></a>00552                         usage(stdout);
<a name="l00553"></a>00553                         <span class="keywordflow">break</span>;
<a name="l00554"></a>00554                 <span class="keywordflow">case</span> <span class="charliteral">&apos;n&apos;</span>:
<a name="l00555"></a>00555                         ++mop-&gt;mo_nomtab;
<a name="l00556"></a>00556                         printf(<span class="stringliteral">&quot;nomtab: %d\n&quot;</span>, mop-&gt;mo_nomtab);
<a name="l00557"></a>00557                         <span class="keywordflow">break</span>;
<a name="l00558"></a>00558                 <span class="keywordflow">case</span> <span class="charliteral">&apos;o&apos;</span>:
<a name="l00559"></a>00559                         mop-&gt;mo_orig_options = optarg;
<a name="l00560"></a>00560                         <span class="keywordflow">break</span>;
<a name="l00561"></a>00561                 <span class="keywordflow">case</span> <span class="charliteral">&apos;v&apos;</span>:
<a name="l00562"></a>00562                         ++verbose;
<a name="l00563"></a>00563                         <span class="keywordflow">break</span>;
<a name="l00564"></a>00564                 <span class="keywordflow">case</span> <span class="charliteral">&apos;V&apos;</span>:
<a name="l00565"></a>00565                         ++version;
<a name="l00566"></a>00566                         fprintf(stdout, <span class="stringliteral">&quot;%s %s %s\n&quot;</span>, progname,
<a name="l00567"></a>00567                                 LUSTRE_VERSION_STRING, WITH_LIBMOUNT);
<a name="l00568"></a>00568                         <span class="keywordflow">return</span> 0;
<a name="l00569"></a>00569                 <span class="keywordflow">default</span>:
<a name="l00570"></a>00570                         fprintf(stderr, <span class="stringliteral">&quot;%s: unknown option &apos;%c&apos;\n&quot;</span>,
<a name="l00571"></a>00571                                         progname, opt);
<a name="l00572"></a>00572                         usage(stderr);
<a name="l00573"></a>00573                         <span class="keywordflow">break</span>;
<a name="l00574"></a>00574                 }
<a name="l00575"></a>00575         }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577         <span class="keywordflow">if</span> (optind + 2 &gt; argc) {
<a name="l00578"></a>00578                 fprintf(stderr, <span class="stringliteral">&quot;%s: too few arguments\n&quot;</span>, progname);
<a name="l00579"></a>00579                 usage(stderr);
<a name="l00580"></a>00580         }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582         mop-&gt;mo_usource = argv[optind];
<a name="l00583"></a>00583         <span class="keywordflow">if</span> (!mop-&gt;mo_usource) {
<a name="l00584"></a>00584                 usage(stderr);
<a name="l00585"></a>00585         }
<a name="l00586"></a>00586 
<a name="l00591"></a>00591         <span class="keywordflow">if</span> (realpath(mop-&gt;mo_usource, real_path) != NULL) {
<a name="l00592"></a>00592                 ptr = strrchr(real_path, <span class="charliteral">&apos;/&apos;</span>);
<a name="l00593"></a>00593                 <span class="keywordflow">if</span> (ptr &amp;&amp; strncmp(ptr, <span class="stringliteral">&quot;/dm-&quot;</span>, 4) == 0 &amp;&amp; isdigit(*(ptr + 4))) {
<a name="l00594"></a>00594                         snprintf(path, <span class="keyword">sizeof</span>(path), <span class="stringliteral">&quot;/sys/block/%s/dm/name&quot;</span>, ptr+1);
<a name="l00595"></a>00595                         <span class="keywordflow">if</span> ((f = fopen(path, <span class="stringliteral">&quot;r&quot;</span>))) {
<a name="l00596"></a>00596                                 <span class="comment">/* read &quot;&lt;name&gt;\n&quot; from sysfs */</span>
<a name="l00597"></a>00597                                 <span class="keywordflow">if</span> (fgets(name, <span class="keyword">sizeof</span>(name), f) &amp;&amp; (sz = strlen(name)) &gt; 1) {
<a name="l00598"></a>00598                                         name[sz - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00599"></a>00599                                         snprintf(real_path, <span class="keyword">sizeof</span>(real_path), <span class="stringliteral">&quot;/dev/mapper/%s&quot;</span>, name);
<a name="l00600"></a>00600                                 }
<a name="l00601"></a>00601                                 fclose(f);
<a name="l00602"></a>00602                         }
<a name="l00603"></a>00603                 }
<a name="l00604"></a>00604                 mop-&gt;mo_usource = strdup(real_path);
<a name="l00605"></a>00605         }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607         ptr = strstr(mop-&gt;mo_usource, <span class="stringliteral">&quot;:/&quot;</span>);
<a name="l00608"></a>00608         <span class="keywordflow">if</span> (ptr != NULL) {
<a name="l00609"></a>00609                 mop-&gt;mo_source = convert_hostnames(mop-&gt;mo_usource);
<a name="l00610"></a>00610                 <span class="keywordflow">if</span> (!mop-&gt;mo_source)
<a name="l00611"></a>00611                         usage(stderr);
<a name="l00612"></a>00612         } <span class="keywordflow">else</span> {
<a name="l00613"></a>00613                 mop-&gt;mo_source = strdup(mop-&gt;mo_usource);
<a name="l00614"></a>00614         }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616         <span class="keywordflow">if</span> (realpath(argv[optind + 1], mop-&gt;mo_target) == NULL) {
<a name="l00617"></a>00617                 rc = errno;
<a name="l00618"></a>00618                 fprintf(stderr, <span class="stringliteral">&quot;warning: %s: cannot resolve: %s\n&quot;</span>,
<a name="l00619"></a>00619                                 argv[optind + 1], strerror(errno));
<a name="l00620"></a>00620                 <span class="keywordflow">return</span> rc;
<a name="l00621"></a>00621         }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623         <span class="keywordflow">return</span> 0;
<a name="l00624"></a>00624 }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *<span class="keyword">const</span> argv[])
<a name="l00627"></a>00627 {
<a name="l00628"></a>00628         <span class="keyword">struct </span><a class="code" href="structmount__opts.html">mount_opts</a> mop;
<a name="l00629"></a>00629         <span class="keywordtype">char</span> *options;
<a name="l00630"></a>00630         <span class="keywordtype">int</span> i, rc, flags;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632         progname = strrchr(argv[0], <span class="charliteral">&apos;/&apos;</span>);
<a name="l00633"></a>00633         progname = progname ? progname + 1 : argv[0];
<a name="l00634"></a>00634 
<a name="l00635"></a>00635         set_defaults(&amp;mop);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637         rc = parse_opts(argc, argv, &amp;mop);
<a name="l00638"></a>00638         <span class="keywordflow">if</span> (rc || version)
<a name="l00639"></a>00639                 <span class="keywordflow">return</span> rc;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641         <span class="keywordflow">if</span> (verbose) {
<a name="l00642"></a>00642                 <span class="keywordflow">for</span> (i = 0; i &lt; argc; i++)
<a name="l00643"></a>00643                         printf(<span class="stringliteral">&quot;arg[%d] = %s\n&quot;</span>, i, argv[i]);
<a name="l00644"></a>00644                 printf(<span class="stringliteral">&quot;source = %s (%s), target = %s\n&quot;</span>, mop.mo_usource,
<a name="l00645"></a>00645                        mop.mo_source, mop.mo_target);
<a name="l00646"></a>00646                 printf(<span class="stringliteral">&quot;options = %s\n&quot;</span>, mop.mo_orig_options);
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         options = malloc(MAXOPT);
<a name="l00650"></a>00650         <span class="keywordflow">if</span> (options == NULL) {
<a name="l00651"></a>00651                 fprintf(stderr, <span class="stringliteral">&quot;can&apos;t allocate memory for options\n&quot;</span>);
<a name="l00652"></a>00652                 <span class="keywordflow">return</span> -1;
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654         strcpy(options, mop.mo_orig_options);
<a name="l00655"></a>00655         rc = parse_options(&amp;mop, options, &amp;flags);
<a name="l00656"></a>00656         <span class="keywordflow">if</span> (rc) {
<a name="l00657"></a>00657                 fprintf(stderr, <span class="stringliteral">&quot;%s: can&apos;t parse options: %s\n&quot;</span>,
<a name="l00658"></a>00658                         progname, options);
<a name="l00659"></a>00659                 <span class="keywordflow">return</span>(EINVAL);
<a name="l00660"></a>00660         }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662         <span class="keywordflow">if</span> (!mop.mo_force) {
<a name="l00663"></a>00663                 rc = check_mtab_entry(mop.mo_usource, mop.mo_source,
<a name="l00664"></a>00664                                       mop.mo_target, <span class="stringliteral">&quot;lustre&quot;</span>);
<a name="l00665"></a>00665                 <span class="keywordflow">if</span> (rc &amp;&amp; !(flags &amp; MS_REMOUNT)) {
<a name="l00666"></a>00666                         fprintf(stderr, <span class="stringliteral">&quot;%s: according to %s %s is &quot;</span>
<a name="l00667"></a>00667                                 <span class="stringliteral">&quot;already mounted on %s\n&quot;</span>, progname, MOUNTED,
<a name="l00668"></a>00668                                 mop.mo_usource, mop.mo_target);
<a name="l00669"></a>00669                         <span class="keywordflow">return</span>(EEXIST);
<a name="l00670"></a>00670                 }
<a name="l00671"></a>00671                 <span class="keywordflow">if</span> (!rc &amp;&amp; (flags &amp; MS_REMOUNT)) {
<a name="l00672"></a>00672                         fprintf(stderr, <span class="stringliteral">&quot;%s: according to %s %s is &quot;</span>
<a name="l00673"></a>00673                                 <span class="stringliteral">&quot;not already mounted on %s\n&quot;</span>, progname, MOUNTED,
<a name="l00674"></a>00674                                 mop.mo_usource, mop.mo_target);
<a name="l00675"></a>00675                         <span class="keywordflow">return</span>(ENOENT);
<a name="l00676"></a>00676                 }
<a name="l00677"></a>00677         }
<a name="l00678"></a>00678         <span class="keywordflow">if</span> (flags &amp; MS_REMOUNT)
<a name="l00679"></a>00679                 mop.mo_nomtab++;
<a name="l00680"></a>00680 
<a name="l00681"></a>00681         rc = access(mop.mo_target, F_OK);
<a name="l00682"></a>00682         <span class="keywordflow">if</span> (rc) {
<a name="l00683"></a>00683                 rc = errno;
<a name="l00684"></a>00684                 fprintf(stderr, <span class="stringliteral">&quot;%s: %s inaccessible: %s\n&quot;</span>, progname,
<a name="l00685"></a>00685                         mop.mo_target, strerror(errno));
<a name="l00686"></a>00686                 <span class="keywordflow">return</span> rc;
<a name="l00687"></a>00687         }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         <span class="keywordflow">if</span> (strstr(mop.mo_usource, <span class="stringliteral">&quot;:/&quot;</span>) == NULL) {
<a name="l00690"></a>00690                 rc = osd_init();
<a name="l00691"></a>00691                 <span class="keywordflow">if</span> (rc)
<a name="l00692"></a>00692                         <span class="keywordflow">return</span> rc;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694                 rc = parse_ldd(mop.mo_source, &amp;mop, options);
<a name="l00695"></a>00695                 <span class="keywordflow">if</span> (rc)
<a name="l00696"></a>00696                         <span class="keywordflow">return</span> rc;
<a name="l00697"></a>00697         }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         <span class="comment">/* In Linux 2.4, the target device doesn&apos;t get passed to any of our</span>
<a name="l00700"></a>00700 <span class="comment">           functions.  So we&apos;ll stick it on the end of the options. */</span>
<a name="l00701"></a>00701         append_option(options, <span class="stringliteral">&quot;device=&quot;</span>);
<a name="l00702"></a>00702         strcat(options, mop.mo_source);
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         <span class="keywordflow">if</span> (verbose)
<a name="l00705"></a>00705                 printf(<span class="stringliteral">&quot;mounting device %s at %s, flags=%#x options=%s\n&quot;</span>,
<a name="l00706"></a>00706                        mop.mo_source, mop.mo_target, flags, options);
<a name="l00707"></a>00707 
<a name="l00708"></a>00708         <span class="keywordflow">if</span> (strstr(mop.mo_usource, <span class="stringliteral">&quot;:/&quot;</span>) == NULL &amp;&amp;
<a name="l00709"></a>00709             osd_tune_lustre(mop.mo_source, &amp;mop)) {
<a name="l00710"></a>00710                 <span class="keywordflow">if</span> (verbose)
<a name="l00711"></a>00711                         fprintf(stderr, <span class="stringliteral">&quot;%s: unable to set tunables for %s&quot;</span>
<a name="l00712"></a>00712                                         <span class="stringliteral">&quot; (may cause reduced IO performance)\n&quot;</span>,
<a name="l00713"></a>00713                                         argv[0], mop.mo_source);
<a name="l00714"></a>00714         }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716         <span class="keywordflow">if</span> (!mop.mo_fake) {
<a name="l00717"></a>00717                 <span class="comment">/* flags and target get to lustre_get_sb(), but not</span>
<a name="l00718"></a>00718 <span class="comment">                 * lustre_fill_super().  Lustre ignores the flags, but mount</span>
<a name="l00719"></a>00719 <span class="comment">                 * does not. */</span>
<a name="l00720"></a>00720                 <span class="keywordflow">for</span> (i = 0, rc = -EAGAIN; i &lt;= mop.mo_retry &amp;&amp; rc != 0; i++) {
<a name="l00721"></a>00721                         rc = mount(mop.mo_source, mop.mo_target, <span class="stringliteral">&quot;lustre&quot;</span>,
<a name="l00722"></a>00722                                    flags, (<span class="keywordtype">void</span> *)options);
<a name="l00723"></a>00723                         <span class="keywordflow">if</span> (rc == 0) {
<a name="l00724"></a>00724                                 <span class="comment">/* change label from &lt;fsname&gt;:&lt;index&gt; to</span>
<a name="l00725"></a>00725 <span class="comment">                                 * &lt;fsname&gt;-&lt;index&gt; to indicate the device has</span>
<a name="l00726"></a>00726 <span class="comment">                                 *  been registered. only if the label is</span>
<a name="l00727"></a>00727 <span class="comment">                                 *  supposed to be changed and target service</span>
<a name="l00728"></a>00728 <span class="comment">                                 *  is supposed to start */</span>
<a name="l00729"></a>00729                                 <span class="keywordflow">if</span> (mop.mo_ldd.ldd_flags &amp;
<a name="l00730"></a>00730                                    (<a class="code" href="group__disk.html#ga4102f845e0b2ff614a190a910fd6e980" title="never registered">LDD_F_VIRGIN</a> | <a class="code" href="group__disk.html#gaa1fbb85f93ed3c121aae3ec558b1b41e" title="regenerate config logs for this fs or server">LDD_F_WRITECONF</a>)) {
<a name="l00731"></a>00731                                         <span class="keywordflow">if</span> (mop.mo_nosvc == 0)
<a name="l00732"></a>00732                                                 (void)osd_label_lustre(&amp;mop);
<a name="l00733"></a>00733                                 }
<a name="l00734"></a>00734                         } <span class="keywordflow">else</span> {
<a name="l00735"></a>00735                                 <span class="keywordflow">if</span> (verbose) {
<a name="l00736"></a>00736                                         fprintf(stderr, <span class="stringliteral">&quot;%s: mount %s at %s &quot;</span>
<a name="l00737"></a>00737                                                 <span class="stringliteral">&quot;failed: %s retries left: &quot;</span>
<a name="l00738"></a>00738                                                 <span class="stringliteral">&quot;%d\n&quot;</span>, basename(progname),
<a name="l00739"></a>00739                                                 mop.mo_usource, mop.mo_target,
<a name="l00740"></a>00740                                                 strerror(errno),
<a name="l00741"></a>00741                                                 mop.mo_retry - i);
<a name="l00742"></a>00742                                 }
<a name="l00743"></a>00743 
<a name="l00744"></a>00744                                 <span class="keywordflow">if</span> (mop.mo_retry) {
<a name="l00745"></a>00745                                         <span class="keywordtype">int</span> limit = i/2 &gt; 5 ? i/2 : 5;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747                                         sleep(1 &lt;&lt; limit);
<a name="l00748"></a>00748                                 } <span class="keywordflow">else</span> {
<a name="l00749"></a>00749                                         rc = errno;
<a name="l00750"></a>00750                                 }
<a name="l00751"></a>00751                         }
<a name="l00752"></a>00752                 }
<a name="l00753"></a>00753         }
<a name="l00754"></a>00754 
<a name="l00755"></a>00755         <span class="keywordflow">if</span> (rc) {
<a name="l00756"></a>00756                 <span class="keywordtype">char</span> *cli;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758                 rc = errno;
<a name="l00759"></a>00759 
<a name="l00760"></a>00760                 cli = strrchr(mop.mo_usource, <span class="charliteral">&apos;:&apos;</span>);
<a name="l00761"></a>00761                 <span class="keywordflow">if</span> (cli &amp;&amp; (strlen(cli) &gt; 2))
<a name="l00762"></a>00762                         cli += 2;
<a name="l00763"></a>00763                 <span class="keywordflow">else</span>
<a name="l00764"></a>00764                         cli = NULL;
<a name="l00765"></a>00765 
<a name="l00766"></a>00766                 fprintf(stderr, <span class="stringliteral">&quot;%s: mount %s at %s failed: %s\n&quot;</span>, progname,
<a name="l00767"></a>00767                         mop.mo_usource, mop.mo_target, strerror(errno));
<a name="l00768"></a>00768                 <span class="keywordflow">if</span> (errno == EBUSY)
<a name="l00769"></a>00769                         fprintf(stderr, <span class="stringliteral">&quot;Is the backend filesystem mounted?\n&quot;</span>
<a name="l00770"></a>00770                                         <span class="stringliteral">&quot;Check /etc/mtab and /proc/mounts\n&quot;</span>);
<a name="l00771"></a>00771                 <span class="keywordflow">if</span> (errno == ENODEV)
<a name="l00772"></a>00772                         fprintf(stderr, <span class="stringliteral">&quot;Are the lustre modules loaded?\n&quot;</span>
<a name="l00773"></a>00773                                 <span class="stringliteral">&quot;Check /etc/modprobe.conf and &quot;</span>
<a name="l00774"></a>00774                                 <span class="stringliteral">&quot;/proc/filesystems\n&quot;</span>);
<a name="l00775"></a>00775                 <span class="keywordflow">if</span> (errno == ENOTBLK)
<a name="l00776"></a>00776                         fprintf(stderr, <span class="stringliteral">&quot;Do you need -o loop?\n&quot;</span>);
<a name="l00777"></a>00777                 <span class="keywordflow">if</span> (errno == ENOMEDIUM)
<a name="l00778"></a>00778                         fprintf(stderr,
<a name="l00779"></a>00779                                 <span class="stringliteral">&quot;This filesystem needs at least 1 OST\n&quot;</span>);
<a name="l00780"></a>00780                 <span class="keywordflow">if</span> (errno == ENOENT) {
<a name="l00781"></a>00781                         fprintf(stderr, <span class="stringliteral">&quot;Is the MGS specification correct?\n&quot;</span>);
<a name="l00782"></a>00782                         fprintf(stderr, <span class="stringliteral">&quot;Is the filesystem name correct?\n&quot;</span>);
<a name="l00783"></a>00783                         fprintf(stderr, <span class="stringliteral">&quot;If upgrading, is the copied client log&quot;</span>
<a name="l00784"></a>00784                                 <span class="stringliteral">&quot; valid? (see upgrade docs)\n&quot;</span>);
<a name="l00785"></a>00785                 }
<a name="l00786"></a>00786                 <span class="keywordflow">if</span> (errno == EALREADY)
<a name="l00787"></a>00787                         fprintf(stderr, <span class="stringliteral">&quot;The target service is already running.&quot;</span>
<a name="l00788"></a>00788                                 <span class="stringliteral">&quot; (%s)\n&quot;</span>, mop.mo_usource);
<a name="l00789"></a>00789                 <span class="keywordflow">if</span> (errno == ENXIO)
<a name="l00790"></a>00790                         fprintf(stderr, <span class="stringliteral">&quot;The target service failed to start &quot;</span>
<a name="l00791"></a>00791                                 <span class="stringliteral">&quot;(bad config log?) (%s).  &quot;</span>
<a name="l00792"></a>00792                                 <span class="stringliteral">&quot;See /var/log/messages.\n&quot;</span>, mop.mo_usource);
<a name="l00793"></a>00793                 <span class="keywordflow">if</span> (errno == EIO)
<a name="l00794"></a>00794                         fprintf(stderr, <span class="stringliteral">&quot;Is the MGS running?\n&quot;</span>);
<a name="l00795"></a>00795                 <span class="keywordflow">if</span> (errno == EADDRINUSE)
<a name="l00796"></a>00796                         fprintf(stderr, <span class="stringliteral">&quot;The target service&apos;s index is already &quot;</span>
<a name="l00797"></a>00797                                 <span class="stringliteral">&quot;in use. (%s)\n&quot;</span>, mop.mo_usource);
<a name="l00798"></a>00798                 <span class="keywordflow">if</span> (errno == EINVAL) {
<a name="l00799"></a>00799                         fprintf(stderr, <span class="stringliteral">&quot;This may have multiple causes.\n&quot;</span>);
<a name="l00800"></a>00800                         <span class="keywordflow">if</span> (cli)
<a name="l00801"></a>00801                                 fprintf(stderr, <span class="stringliteral">&quot;Is &apos;%s&apos; the correct filesystem&quot;</span>
<a name="l00802"></a>00802                                         <span class="stringliteral">&quot; name?\n&quot;</span>, cli);
<a name="l00803"></a>00803                         fprintf(stderr, <span class="stringliteral">&quot;Are the mount options correct?\n&quot;</span>);
<a name="l00804"></a>00804                         fprintf(stderr, <span class="stringliteral">&quot;Check the syslog for more info.\n&quot;</span>);
<a name="l00805"></a>00805                 }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807                 <span class="comment">/* May as well try to clean up loop devs */</span>
<a name="l00808"></a>00808                 <span class="keywordflow">if</span> (strncmp(mop.mo_usource, <span class="stringliteral">&quot;/dev/loop&quot;</span>, 9) == 0) {
<a name="l00809"></a>00809                         <span class="keywordtype">char</span> cmd[256];
<a name="l00810"></a>00810                         <span class="keywordtype">int</span> ret;
<a name="l00811"></a>00811                         sprintf(cmd, <span class="stringliteral">&quot;/sbin/losetup -d %s&quot;</span>, mop.mo_usource);
<a name="l00812"></a>00812                         <span class="keywordflow">if</span> ((ret = system(cmd)) &lt; 0)
<a name="l00813"></a>00813                                 rc = errno;
<a name="l00814"></a>00814                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt; 0)
<a name="l00815"></a>00815                                 rc = WEXITSTATUS(ret);
<a name="l00816"></a>00816                 }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818         } <span class="keywordflow">else</span> {
<a name="l00819"></a>00819                 <span class="comment">/* Deal with utab just for client. Note that we ignore</span>
<a name="l00820"></a>00820 <span class="comment">                 * the return value here since it is not worth to fail</span>
<a name="l00821"></a>00821 <span class="comment">                 * mount by prevent some rare cases */</span>
<a name="l00822"></a>00822                 <span class="keywordflow">if</span> (strstr(mop.mo_usource, <span class="stringliteral">&quot;:/&quot;</span>) != NULL)
<a name="l00823"></a>00823                         update_utab_entry(&amp;mop);
<a name="l00824"></a>00824                 <span class="keywordflow">if</span> (!mop.mo_nomtab) {
<a name="l00825"></a>00825                         rc = update_mtab_entry(mop.mo_usource, mop.mo_target,
<a name="l00826"></a>00826                                                <span class="stringliteral">&quot;lustre&quot;</span>, mop.mo_orig_options,
<a name="l00827"></a>00827                                                0, 0, 0);
<a name="l00828"></a>00828                 }
<a name="l00829"></a>00829         }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831         free(options);
<a name="l00832"></a>00832         <span class="comment">/* mo_usource should be freed, but we can rely on the kernel */</span>
<a name="l00833"></a>00833         free(mop.mo_source);
<a name="l00834"></a>00834 
<a name="l00835"></a>00835         <span class="keywordflow">if</span> (strstr(mop.mo_usource, <span class="stringliteral">&quot;:/&quot;</span>) == NULL)
<a name="l00836"></a>00836                 osd_fini();
<a name="l00837"></a>00837 
<a name="l00838"></a>00838         <span class="keywordflow">return</span> rc;
<a name="l00839"></a>00839 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:36 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
