<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: Events and event queues</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Events and event queues<br/>
<small>
[<a class="el" href="group__lnet.html">LNet</a>]</small>
</h1>
<p>Event queues (abbreviated as EQ) are used to log operations performed on local MDs.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Events and event queues:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__lnet__eq.png" border="0" alt="" usemap="#group____lnet____eq_map"/>
<map name="group____lnet____eq_map" id="group____lnet____eq">
<area shape="rect" id="node1" href="group__lnet.html" title="The Lustre Networking subsystem." alt="" coords="5,5,61,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlnet__event__t.html">lnet_event_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information about an event on a MD.  <a href="structlnet__event__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d29f84babe23bedcc4391c2c6fabb3a"></a><!-- doxytag: member="lnet_eq::LNET_SEQ_BASETYPE" ref="ga1d29f84babe23bedcc4391c2c6fabb3a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_SEQ_BASETYPE</b>&nbsp;&nbsp;&nbsp;long</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab910a092c7399ac0079f306ee843dd43"></a><!-- doxytag: member="lnet_eq::LNET_SEQ_GT" ref="gab910a092c7399ac0079f306ee843dd43" args="(a, b)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_SEQ_GT</b>(a, b)&nbsp;&nbsp;&nbsp;(((signed LNET_SEQ_BASETYPE)((a) - (b))) &gt; 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga19f17d1046e4b07f4a82b6b09fa89821"></a><!-- doxytag: member="lnet_eq::LNET_EQ_HANDLER_NONE" ref="ga19f17d1046e4b07f4a82b6b09fa89821" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LNET_EQ_HANDLER_NONE</b>&nbsp;&nbsp;&nbsp;NULL</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa852e678ebaca5da7e2de48b659e50a6"></a><!-- doxytag: member="lnet_eq::lnet_seq_t" ref="gaa852e678ebaca5da7e2de48b659e50a6" args="" -->
typedef unsigned LNET_SEQ_BASETYPE&nbsp;</td><td class="memItemRight" valign="bottom"><b>lnet_seq_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e">lnet_eq_handler_t</a> )(<a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event queue handler function type.  <a href="#ga79dedea26148b7a6e911c83996f7ae2e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a">lnet_event_kind_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa5dc43f23cb1d74bf99c4952f3206c495">LNET_EVENT_GET</a> =  1, 
<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa74946c8fd311bc8acc467975d832c559">LNET_EVENT_PUT</a>, 
<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa1b02ad74ed81049d556529d071db1554">LNET_EVENT_REPLY</a>, 
<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa3a2821c6f27ccc1c14e52f0578cecfba">LNET_EVENT_ACK</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aaea6bb2f0a78fad06bd24c8d43ab61fa5">LNET_EVENT_SEND</a>, 
<a class="el" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa33fef2f8ab7fb7bbe66b5e322302922d">LNET_EVENT_UNLINK</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Six types of events can be logged in an event queue. </p>
 <a href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga6af2966611a22331fc4905d17e5a2779">LNetEQAlloc</a> (unsigned int count_in, <a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e">lnet_eq_handler_t</a> handler, <a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> *handle_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an event queue that has room for <em>count</em> number of events.  <a href="#ga6af2966611a22331fc4905d17e5a2779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#gad960a84b5325f9e518e0eef419a8c741">LNetEQFree</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> eventq_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the resources associated with an event queue if it's idle; otherwise do nothing and it's up to the user to try again.  <a href="#gad960a84b5325f9e518e0eef419a8c741"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#gae6d5740f0da715e176d47af9f638521b">LNetEQGet</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> eventq_in, <a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A nonblocking function that can be used to get the next event in an EQ.  <a href="#gae6d5740f0da715e176d47af9f638521b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#ga7cefc01394a06655eec46dcf3904ea21">LNetEQWait</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> eventq_in, <a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block the calling process until there is an event in the EQ.  <a href="#ga7cefc01394a06655eec46dcf3904ea21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30">LNetEQPoll</a> (<a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> *eventqs_in, int neq_in, int timeout_ms, <a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event_out, int *which_eq_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block the calling process until there's an event from a set of EQs or timeout happens.  <a href="#gaa723e6bf5041559683351354208f8a30"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Event queues (abbreviated as EQ) are used to log operations performed on local MDs. </p>
<p>In particular, they signal the completion of a data transmission into or out of a MD. They can also be used to hold acknowledgments for completed PUT operations and indicate when a MD has been unlinked. Multiple MDs can share a single EQ. An EQ may have an optional event handler associated with it. If an event handler exists, it will be run for each event that is deposited into the EQ.</p>
<p>In addition to the lnet_handle_eq_t, the LNet API defines two types associated with events: The <a class="el" href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a" title="Six types of events can be logged in an event queue.">lnet_event_kind_t</a> defines the kinds of events that can be stored in an EQ. The <a class="el" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a> defines a structure that holds the information about with an event.</p>
<p>There are five functions for dealing with EQs: <a class="el" href="group__lnet__eq.html#ga6af2966611a22331fc4905d17e5a2779" title="Create an event queue that has room for count number of events.">LNetEQAlloc()</a> is used to create an EQ and allocate the resources needed, while <a class="el" href="group__lnet__eq.html#gad960a84b5325f9e518e0eef419a8c741" title="Release the resources associated with an event queue if it&#39;s idle; otherwise...">LNetEQFree()</a> releases these resources and free the EQ. <a class="el" href="group__lnet__eq.html#gae6d5740f0da715e176d47af9f638521b" title="A nonblocking function that can be used to get the next event in an EQ.">LNetEQGet()</a> retrieves the next event from an EQ, and <a class="el" href="group__lnet__eq.html#ga7cefc01394a06655eec46dcf3904ea21" title="Block the calling process until there is an event in the EQ.">LNetEQWait()</a> can be used to block a process until an EQ has at least one event. <a class="el" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&#39;s an event from a set of EQs or timeout...">LNetEQPoll()</a> can be used to test or wait on multiple EQs. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga79dedea26148b7a6e911c83996f7ae2e"></a><!-- doxytag: member="types.h::lnet_eq_handler_t" ref="ga79dedea26148b7a6e911c83996f7ae2e" args=")(lnet_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e">lnet_eq_handler_t</a>)(<a class="el" href="structlnet__event__t.html">lnet_event_t</a> *event)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event queue handler function type. </p>
<p>The EQ handler runs for each event that is deposited into the EQ. The handler is supplied with a pointer to the event that triggered the handler invocation.</p>
<p>The handler must not block, must be reentrant, and must not call any LNet API functions. It should return as quickly as possible. </p>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00628">628</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga03bee040520d7fabad1b3b661bd7228a"></a><!-- doxytag: member="types.h::lnet_event_kind_t" ref="ga03bee040520d7fabad1b3b661bd7228a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a">lnet_event_kind_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Six types of events can be logged in an event queue. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa5dc43f23cb1d74bf99c4952f3206c495"></a><!-- doxytag: member="LNET_EVENT_GET" ref="gga03bee040520d7fabad1b3b661bd7228aa5dc43f23cb1d74bf99c4952f3206c495" args="" -->LNET_EVENT_GET</em>&nbsp;</td><td>
<p>An incoming GET operation has completed on the MD. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa74946c8fd311bc8acc467975d832c559"></a><!-- doxytag: member="LNET_EVENT_PUT" ref="gga03bee040520d7fabad1b3b661bd7228aa74946c8fd311bc8acc467975d832c559" args="" -->LNET_EVENT_PUT</em>&nbsp;</td><td>
<p>An incoming PUT operation has completed on the MD. </p>
<p>The underlying layers will not alter the memory (on behalf of this operation) once this event has been logged. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa1b02ad74ed81049d556529d071db1554"></a><!-- doxytag: member="LNET_EVENT_REPLY" ref="gga03bee040520d7fabad1b3b661bd7228aa1b02ad74ed81049d556529d071db1554" args="" -->LNET_EVENT_REPLY</em>&nbsp;</td><td>
<p>A REPLY operation has completed. </p>
<p>This event is logged after the data (if any) from the REPLY has been written into the MD. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa3a2821c6f27ccc1c14e52f0578cecfba"></a><!-- doxytag: member="LNET_EVENT_ACK" ref="gga03bee040520d7fabad1b3b661bd7228aa3a2821c6f27ccc1c14e52f0578cecfba" args="" -->LNET_EVENT_ACK</em>&nbsp;</td><td>
<p>An acknowledgment has been received. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aaea6bb2f0a78fad06bd24c8d43ab61fa5"></a><!-- doxytag: member="LNET_EVENT_SEND" ref="gga03bee040520d7fabad1b3b661bd7228aaea6bb2f0a78fad06bd24c8d43ab61fa5" args="" -->LNET_EVENT_SEND</em>&nbsp;</td><td>
<p>An outgoing send (PUT or GET) operation has completed. </p>
<p>This event is logged after the entire buffer has been sent and it is safe for the caller to reuse the buffer.</p>
<p>Note:</p>
<ul>
<li>The LNET_EVENT_SEND doesn't guarantee message delivery. It can happen even when the message has not yet been put out on wire.</li>
<li>It's unsafe to assume that in an outgoing GET operation the LNET_EVENT_SEND event would happen before the LNET_EVENT_REPLY event. The same holds for LNET_EVENT_SEND and LNET_EVENT_ACK events in an outgoing PUT operation. </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga03bee040520d7fabad1b3b661bd7228aa33fef2f8ab7fb7bbe66b5e322302922d"></a><!-- doxytag: member="LNET_EVENT_UNLINK" ref="gga03bee040520d7fabad1b3b661bd7228aa33fef2f8ab7fb7bbe66b5e322302922d" args="" -->LNET_EVENT_UNLINK</em>&nbsp;</td><td>
<p>A MD has been unlinked. </p>
<p>Note that <a class="el" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink()</a> does not necessarily trigger an LNET_EVENT_UNLINK event. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink</a> </dd></dl>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lnet_2include_2lnet_2types_8h_source.html#l00504">504</a> of file <a class="el" href="lnet_2include_2lnet_2types_8h_source.html">types.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00504"></a>00504              {
<a name="l00506"></a>00506         <a class="code" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa5dc43f23cb1d74bf99c4952f3206c495" title="An incoming GET operation has completed on the MD.">LNET_EVENT_GET</a>          = 1,
<a name="l00512"></a>00512         <a class="code" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa74946c8fd311bc8acc467975d832c559" title="An incoming PUT operation has completed on the MD.">LNET_EVENT_PUT</a>,
<a name="l00517"></a>00517         <a class="code" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa1b02ad74ed81049d556529d071db1554" title="A REPLY operation has completed.">LNET_EVENT_REPLY</a>,
<a name="l00519"></a>00519         <a class="code" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa3a2821c6f27ccc1c14e52f0578cecfba" title="An acknowledgment has been received.">LNET_EVENT_ACK</a>,
<a name="l00533"></a>00533         <a class="code" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aaea6bb2f0a78fad06bd24c8d43ab61fa5" title="An outgoing send (PUT or GET) operation has completed.">LNET_EVENT_SEND</a>,
<a name="l00539"></a>00539         <a class="code" href="group__lnet__eq.html#gga03bee040520d7fabad1b3b661bd7228aa33fef2f8ab7fb7bbe66b5e322302922d" title="A MD has been unlinked.">LNET_EVENT_UNLINK</a>,
<a name="l00540"></a>00540 } <a class="code" href="group__lnet__eq.html#ga03bee040520d7fabad1b3b661bd7228a" title="Six types of events can be logged in an event queue.">lnet_event_kind_t</a>;
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6af2966611a22331fc4905d17e5a2779"></a><!-- doxytag: member="api.h::LNetEQAlloc" ref="ga6af2966611a22331fc4905d17e5a2779" args="(unsigned int count_in, lnet_eq_handler_t handler, lnet_handle_eq_t *handle_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQAlloc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e">lnet_eq_handler_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an event queue that has room for <em>count</em> number of events. </p>
<p>The event queue is circular and older events will be overwritten by new ones if they are not removed in time by the user using the functions <a class="el" href="group__lnet__eq.html#gae6d5740f0da715e176d47af9f638521b" title="A nonblocking function that can be used to get the next event in an EQ.">LNetEQGet()</a>, <a class="el" href="group__lnet__eq.html#ga7cefc01394a06655eec46dcf3904ea21" title="Block the calling process until there is an event in the EQ.">LNetEQWait()</a>, or <a class="el" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&#39;s an event from a set of EQs or timeout...">LNetEQPoll()</a>. It is up to the user to determine the appropriate size of the event queue to prevent this loss of events. Note that when EQ handler is specified in <em>callback</em>, no event loss can happen, since the handler is run for each event deposited into the EQ.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of events to be stored in the event queue. It will be rounded up to the next power of two. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A handler function that runs when an event is deposited into the EQ. The constant value LNET_EQ_HANDLER_NONE can be used to indicate that no event handler is desired. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>On successful return, this location will hold a handle for the newly created EQ.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>On success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>If an parameter is not valid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>If memory for the EQ can't be allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e" title="Event queue handler function type.">lnet_eq_handler_t</a> for the discussion on EQ handler semantics. </dd></dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00070">70</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00072"></a>00072 {
<a name="l00073"></a>00073         <a class="code" href="structlnet__eq.html">lnet_eq_t</a>     *eq;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         LASSERT (the_lnet.ln_refcount &gt; 0);
<a name="l00076"></a>00076 
<a name="l00077"></a>00077         <span class="comment">/* We need count to be a power of 2 so that when eq_{enq,deq}_seq</span>
<a name="l00078"></a>00078 <span class="comment">         * overflow, they don&apos;t skip entries, so the queue has the same</span>
<a name="l00079"></a>00079 <span class="comment">         * apparent capacity at all times */</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081         <span class="keywordflow">if</span> (count)
<a name="l00082"></a>00082                 count = roundup_pow_of_two(count);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084         <span class="keywordflow">if</span> (callback != LNET_EQ_HANDLER_NONE &amp;&amp; count != 0) {
<a name="l00085"></a>00085                 CWARN(<span class="stringliteral">&quot;EQ callback is guaranteed to get every event, &quot;</span>
<a name="l00086"></a>00086                       <span class="stringliteral">&quot;do you still want to set eqcount %d for polling &quot;</span>
<a name="l00087"></a>00087                       <span class="stringliteral">&quot;event which will have locking overhead? &quot;</span>
<a name="l00088"></a>00088                       <span class="stringliteral">&quot;Please contact with developer to confirm\n&quot;</span>, count);
<a name="l00089"></a>00089         }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         <span class="comment">/* count can be 0 if only need callback, we can eliminate</span>
<a name="l00092"></a>00092 <span class="comment">         * overhead of enqueue event */</span>
<a name="l00093"></a>00093         <span class="keywordflow">if</span> (count == 0 &amp;&amp; callback == LNET_EQ_HANDLER_NONE)
<a name="l00094"></a>00094                 <span class="keywordflow">return</span> -EINVAL;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         eq = lnet_eq_alloc();
<a name="l00097"></a>00097         <span class="keywordflow">if</span> (eq == NULL)
<a name="l00098"></a>00098                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100         <span class="keywordflow">if</span> (count != 0) {
<a name="l00101"></a>00101                 LIBCFS_ALLOC(eq-&gt;eq_events, count * <span class="keyword">sizeof</span>(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>));
<a name="l00102"></a>00102                 <span class="keywordflow">if</span> (eq-&gt;eq_events == NULL)
<a name="l00103"></a>00103                         <span class="keywordflow">goto</span> failed;
<a name="l00104"></a>00104                 <span class="comment">/* NB allocator has set all event sequence numbers to 0,</span>
<a name="l00105"></a>00105 <span class="comment">                 * so all them should be earlier than eq_deq_seq */</span>
<a name="l00106"></a>00106         }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108         eq-&gt;eq_deq_seq = 1;
<a name="l00109"></a>00109         eq-&gt;eq_enq_seq = 1;
<a name="l00110"></a>00110         eq-&gt;eq_size = count;
<a name="l00111"></a>00111         eq-&gt;eq_callback = callback;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         eq-&gt;eq_refs = cfs_percpt_alloc(lnet_cpt_table(),
<a name="l00114"></a>00114                                        <span class="keyword">sizeof</span>(*eq-&gt;eq_refs[0]));
<a name="l00115"></a>00115         <span class="keywordflow">if</span> (eq-&gt;eq_refs == NULL)
<a name="l00116"></a>00116                 <span class="keywordflow">goto</span> failed;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         <span class="comment">/* MUST hold both exclusive lnet_res_lock */</span>
<a name="l00119"></a>00119         lnet_res_lock(LNET_LOCK_EX);
<a name="l00120"></a>00120         <span class="comment">/* NB: hold lnet_eq_wait_lock for EQ link/unlink, so we can do</span>
<a name="l00121"></a>00121 <span class="comment">         * both EQ lookup and poll event with only lnet_eq_wait_lock */</span>
<a name="l00122"></a>00122         lnet_eq_wait_lock();
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         lnet_res_lh_initialize(&amp;the_lnet.ln_eq_container, &amp;eq-&gt;eq_lh);
<a name="l00125"></a>00125         list_add(&amp;eq-&gt;eq_list, &amp;the_lnet.ln_eq_container.rec_active);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         lnet_eq_wait_unlock();
<a name="l00128"></a>00128         lnet_res_unlock(LNET_LOCK_EX);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130         lnet_eq2handle(handle, eq);
<a name="l00131"></a>00131         <span class="keywordflow">return</span> 0;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 failed:
<a name="l00134"></a>00134         <span class="keywordflow">if</span> (eq-&gt;eq_events != NULL)
<a name="l00135"></a>00135                 LIBCFS_FREE(eq-&gt;eq_events, count * <span class="keyword">sizeof</span>(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>));
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         <span class="keywordflow">if</span> (eq-&gt;eq_refs != NULL)
<a name="l00138"></a>00138                 cfs_percpt_free(eq-&gt;eq_refs);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         lnet_eq_free(eq);
<a name="l00141"></a>00141         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00142"></a>00142 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad960a84b5325f9e518e0eef419a8c741"></a><!-- doxytag: member="api.h::LNetEQFree" ref="gad960a84b5325f9e518e0eef419a8c741" args="(lnet_handle_eq_t eventq_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a>&nbsp;</td>
          <td class="paramname"> <em>eqh</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the resources associated with an event queue if it's idle; otherwise do nothing and it's up to the user to try again. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eqh</em>&nbsp;</td><td>A handle for the event queue to be released.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>If the EQ is not in use and freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If <em>eqh</em> does not point to a valid EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EBUSY</em>&nbsp;</td><td>If the EQ is still in use by some MDs. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00156">156</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00157"></a>00157 {
<a name="l00158"></a>00158         <span class="keyword">struct </span><a class="code" href="structlnet__eq.html">lnet_eq</a>  *eq;
<a name="l00159"></a>00159         <a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>    *events = NULL;
<a name="l00160"></a>00160         <span class="keywordtype">int</span>             **refs = NULL;
<a name="l00161"></a>00161         <span class="keywordtype">int</span>             *ref;
<a name="l00162"></a>00162         <span class="keywordtype">int</span>             rc = 0;
<a name="l00163"></a>00163         <span class="keywordtype">int</span>             size = 0;
<a name="l00164"></a>00164         <span class="keywordtype">int</span>             i;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         LASSERT(the_lnet.ln_refcount &gt; 0);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168         lnet_res_lock(LNET_LOCK_EX);
<a name="l00169"></a>00169         <span class="comment">/* NB: hold lnet_eq_wait_lock for EQ link/unlink, so we can do</span>
<a name="l00170"></a>00170 <span class="comment">         * both EQ lookup and poll event with only lnet_eq_wait_lock */</span>
<a name="l00171"></a>00171         lnet_eq_wait_lock();
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         eq = lnet_handle2eq(&amp;eqh);
<a name="l00174"></a>00174         <span class="keywordflow">if</span> (eq == NULL) {
<a name="l00175"></a>00175                 rc = -ENOENT;
<a name="l00176"></a>00176                 <span class="keywordflow">goto</span> out;
<a name="l00177"></a>00177         }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         cfs_percpt_for_each(ref, i, eq-&gt;eq_refs) {
<a name="l00180"></a>00180                 LASSERT(*ref &gt;= 0);
<a name="l00181"></a>00181                 <span class="keywordflow">if</span> (*ref == 0)
<a name="l00182"></a>00182                         <span class="keywordflow">continue</span>;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184                 CDEBUG(D_NET, <span class="stringliteral">&quot;Event equeue (%d: %d) busy on destroy.\n&quot;</span>,
<a name="l00185"></a>00185                        i, *ref);
<a name="l00186"></a>00186                 rc = -EBUSY;
<a name="l00187"></a>00187                 <span class="keywordflow">goto</span> out;
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         <span class="comment">/* stash for free after lock dropped */</span>
<a name="l00191"></a>00191         events  = eq-&gt;eq_events;
<a name="l00192"></a>00192         size    = eq-&gt;eq_size;
<a name="l00193"></a>00193         refs    = eq-&gt;eq_refs;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         lnet_res_lh_invalidate(&amp;eq-&gt;eq_lh);
<a name="l00196"></a>00196         list_del(&amp;eq-&gt;eq_list);
<a name="l00197"></a>00197         lnet_eq_free(eq);
<a name="l00198"></a>00198  out:
<a name="l00199"></a>00199         lnet_eq_wait_unlock();
<a name="l00200"></a>00200         lnet_res_unlock(LNET_LOCK_EX);
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="keywordflow">if</span> (events != NULL)
<a name="l00203"></a>00203                 LIBCFS_FREE(events, size * <span class="keyword">sizeof</span>(<a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>));
<a name="l00204"></a>00204         <span class="keywordflow">if</span> (refs != NULL)
<a name="l00205"></a>00205                 cfs_percpt_free(refs);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207         <span class="keywordflow">return</span> rc;
<a name="l00208"></a>00208 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae6d5740f0da715e176d47af9f638521b"></a><!-- doxytag: member="api.h::LNetEQGet" ref="gae6d5740f0da715e176d47af9f638521b" args="(lnet_handle_eq_t eventq_in, lnet_event_t *event_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a>&nbsp;</td>
          <td class="paramname"> <em>eventq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__event__t.html">lnet_event_t</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A nonblocking function that can be used to get the next event in an EQ. </p>
<p>If an event handler is associated with the EQ, the handler will run before this function returns successfully. The event is removed from the queue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventq</em>&nbsp;</td><td>A handle for the event queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>On successful return (1 or -EOVERFLOW), this location will hold the next event in the EQ.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>No pending event in the EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicates success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If <em>eventq</em> does not point to a valid EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EOVERFLOW</em>&nbsp;</td><td>Indicates success (i.e., an event is returned) and that at least one event between this event and the last event obtained from the EQ has been dropped due to limited space in the EQ. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00290">290</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p>References <a class="el" href="lib-eq_8c_source.html#l00392">LNetEQPoll()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00291"></a>00291 {
<a name="l00292"></a>00292         <span class="keywordtype">int</span> which;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         <span class="keywordflow">return</span> <a class="code" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&amp;#39;s an event from a set of EQs or timeout...">LNetEQPoll</a>(&amp;eventq, 1, 0,
<a name="l00295"></a>00295                          event, &amp;which);
<a name="l00296"></a>00296 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lnet__eq_gae6d5740f0da715e176d47af9f638521b_cgraph.png" border="0" usemap="#group__lnet__eq_gae6d5740f0da715e176d47af9f638521b_cgraph_map" alt=""></div>
<map name="group__lnet__eq_gae6d5740f0da715e176d47af9f638521b_cgraph_map" id="group__lnet__eq_gae6d5740f0da715e176d47af9f638521b_cgraph">
<area shape="rect" id="node3" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&#39;s an event from a set of EQs or timeout..." alt="" coords="157,5,256,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa723e6bf5041559683351354208f8a30"></a><!-- doxytag: member="api.h::LNetEQPoll" ref="gaa723e6bf5041559683351354208f8a30" args="(lnet_handle_eq_t *eventqs_in, int neq_in, int timeout_ms, lnet_event_t *event_out, int *which_eq_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQPoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a> *&nbsp;</td>
          <td class="paramname"> <em>eventqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>neq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__event__t.html">lnet_event_t</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>which</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block the calling process until there's an event from a set of EQs or timeout happens. </p>
<p>If an event handler is associated with the EQ, the handler will run before this function returns successfully, in which case the corresponding event is consumed.</p>
<p><a class="el" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&#39;s an event from a set of EQs or timeout...">LNetEQPoll()</a> provides a timeout to allow applications to poll, block for a fixed period, or block indefinitely.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventqs,neq</em>&nbsp;</td><td>An array of EQ handles, and size of the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_ms</em>&nbsp;</td><td>Time in milliseconds to wait for an event to occur on one of the EQs. The constant LNET_TIME_FOREVER can be used to indicate an infinite timeout. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event,which</em>&nbsp;</td><td>On successful return (1 or -EOVERFLOW), <em>event</em> will hold the next event in the EQs, and <em>which</em> will contain the index of the EQ from which the event was taken.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>No pending event in the EQs after timeout. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicates success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EOVERFLOW</em>&nbsp;</td><td>Indicates success (i.e., an event is returned) and that at least one event between this event and the last event obtained from the EQ indicated by <em>which</em> has been dropped due to limited space in the EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If there's an invalid handle in <em>eventqs</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00392">392</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p>Referenced by <a class="el" href="lib-eq_8c_source.html#l00290">LNetEQGet()</a>, and <a class="el" href="lib-eq_8c_source.html#l00316">LNetEQWait()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00394"></a>00394 {
<a name="l00395"></a>00395         <span class="keywordtype">int</span>     wait = 1;
<a name="l00396"></a>00396         <span class="keywordtype">int</span>     rc;
<a name="l00397"></a>00397         <span class="keywordtype">int</span>     i;
<a name="l00398"></a>00398         ENTRY;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400         LASSERT (the_lnet.ln_refcount &gt; 0);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402         <span class="keywordflow">if</span> (neq &lt; 1)
<a name="l00403"></a>00403                 RETURN(-ENOENT);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         lnet_eq_wait_lock();
<a name="l00406"></a>00406 
<a name="l00407"></a>00407         <span class="keywordflow">for</span> (;;) {
<a name="l00408"></a>00408                 <span class="keywordflow">for</span> (i = 0; i &lt; neq; i++) {
<a name="l00409"></a>00409                         <a class="code" href="structlnet__eq.html">lnet_eq_t</a> *eq = lnet_handle2eq(&amp;eventqs[i]);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411                         <span class="keywordflow">if</span> (eq == NULL) {
<a name="l00412"></a>00412                                 lnet_eq_wait_unlock();
<a name="l00413"></a>00413                                 RETURN(-ENOENT);
<a name="l00414"></a>00414                         }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416                         rc = lnet_eq_dequeue_event(eq, event);
<a name="l00417"></a>00417                         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00418"></a>00418                                 lnet_eq_wait_unlock();
<a name="l00419"></a>00419                                 *which = i;
<a name="l00420"></a>00420                                 RETURN(rc);
<a name="l00421"></a>00421                         }
<a name="l00422"></a>00422                 }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424                 <span class="keywordflow">if</span> (wait == 0)
<a name="l00425"></a>00425                         <span class="keywordflow">break</span>;
<a name="l00426"></a>00426 
<a name="l00427"></a>00427                 <span class="comment">/*</span>
<a name="l00428"></a>00428 <span class="comment">                 * return value of lnet_eq_wait_locked:</span>
<a name="l00429"></a>00429 <span class="comment">                 * -1 : did nothing and it&apos;s sure no new event</span>
<a name="l00430"></a>00430 <span class="comment">                 *  1 : sleep inside and wait until new event</span>
<a name="l00431"></a>00431 <span class="comment">                 *  0 : don&apos;t want to wait anymore, but might have new event</span>
<a name="l00432"></a>00432 <span class="comment">                 *      so need to call dequeue again</span>
<a name="l00433"></a>00433 <span class="comment">                 */</span>
<a name="l00434"></a>00434                 wait = lnet_eq_wait_locked(&amp;timeout_ms);
<a name="l00435"></a>00435                 <span class="keywordflow">if</span> (wait &lt; 0) <span class="comment">/* no new event */</span>
<a name="l00436"></a>00436                         <span class="keywordflow">break</span>;
<a name="l00437"></a>00437         }
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         lnet_eq_wait_unlock();
<a name="l00440"></a>00440         RETURN(0);
<a name="l00441"></a>00441 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lnet__eq_gaa723e6bf5041559683351354208f8a30_icgraph.png" border="0" usemap="#group__lnet__eq_gaa723e6bf5041559683351354208f8a30_icgraph_map" alt=""></div>
<map name="group__lnet__eq_gaa723e6bf5041559683351354208f8a30_icgraph_map" id="group__lnet__eq_gaa723e6bf5041559683351354208f8a30_icgraph">
<area shape="rect" id="node3" href="group__lnet__eq.html#gae6d5740f0da715e176d47af9f638521b" title="A nonblocking function that can be used to get the next event in an EQ." alt="" coords="155,5,256,35"/><area shape="rect" id="node5" href="group__lnet__eq.html#ga7cefc01394a06655eec46dcf3904ea21" title="Block the calling process until there is an event in the EQ." alt="" coords="152,59,259,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7cefc01394a06655eec46dcf3904ea21"></a><!-- doxytag: member="api.h::LNetEQWait" ref="ga7cefc01394a06655eec46dcf3904ea21" args="(lnet_handle_eq_t eventq_in, lnet_event_t *event_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LNetEQWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlnet__handle__any__t.html">lnet_handle_eq_t</a>&nbsp;</td>
          <td class="paramname"> <em>eventq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlnet__event__t.html">lnet_event_t</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block the calling process until there is an event in the EQ. </p>
<p>If an event handler is associated with the EQ, the handler will run before this function returns successfully. This function returns the next event in the EQ and removes it from the EQ.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventq</em>&nbsp;</td><td>A handle for the event queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>On successful return (1 or -EOVERFLOW), this location will hold the next event in the EQ.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Indicates success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOENT</em>&nbsp;</td><td>If <em>eventq</em> does not point to a valid EQ. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EOVERFLOW</em>&nbsp;</td><td>Indicates success (i.e., an event is returned) and that at least one event between this event and the last event obtained from the EQ has been dropped due to limited space in the EQ. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lib-eq_8c_source.html#l00316">316</a> of file <a class="el" href="lib-eq_8c_source.html">lib-eq.c</a>.</p>

<p>References <a class="el" href="lib-eq_8c_source.html#l00392">LNetEQPoll()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00317"></a>00317 {
<a name="l00318"></a>00318         <span class="keywordtype">int</span> which;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320         <span class="keywordflow">return</span> <a class="code" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&amp;#39;s an event from a set of EQs or timeout...">LNetEQPoll</a>(&amp;eventq, 1, LNET_TIME_FOREVER,
<a name="l00321"></a>00321                          event, &amp;which);
<a name="l00322"></a>00322 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lnet__eq_ga7cefc01394a06655eec46dcf3904ea21_cgraph.png" border="0" usemap="#group__lnet__eq_ga7cefc01394a06655eec46dcf3904ea21_cgraph_map" alt=""></div>
<map name="group__lnet__eq_ga7cefc01394a06655eec46dcf3904ea21_cgraph_map" id="group__lnet__eq_ga7cefc01394a06655eec46dcf3904ea21_cgraph">
<area shape="rect" id="node3" href="group__lnet__eq.html#gaa723e6bf5041559683351354208f8a30" title="Block the calling process until there&#39;s an event from a set of EQs or timeout..." alt="" coords="160,5,259,35"/></map>
</div>
</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:48 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
