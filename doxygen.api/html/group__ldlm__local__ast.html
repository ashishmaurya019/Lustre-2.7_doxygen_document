<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: Default AST handlers for local locks</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Default AST handlers for local locks<br/>
<small>
[<a class="el" href="group__LDLM.html">Lustre Distributed Lock Manager</a>]</small>
</h1>
<p>These AST handlers are typically used for server-side local locks and are also used by client-side lock handlers to perform minimum level base processing.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Default AST handlers for local locks:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__ldlm__local__ast.png" border="0" alt="" usemap="#group____ldlm____local____ast_map"/>
<map name="group____ldlm____local____ast_map" id="group____ldlm____local____ast">
<area shape="rect" id="node2" href="group__LDLM.html" title="Lustre DLM is based on VAX DLM." alt="" coords="5,5,248,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3">ldlm_blocking_ast_nocheck</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper to build a blocking AST function.  <a href="#ga9962ac0cc2bd7e279cf0b977d822feb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb">ldlm_blocking_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, struct <a class="el" href="structldlm__lock__desc.html">ldlm_lock_desc</a> *desc, void *data, int flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Server blocking AST.  <a href="#gacc93548bb07532aa1d816dee71bd2ecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#ga158dc17797fe9252638377c70f5f9558">ldlm_glimpse_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, void *reqp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements <a class="el" href="structldlm__lock.html#aaa0d1608f452158ab011eecc6f978058" title="Lock glimpse handler.">ldlm_lock::l_glimpse_ast</a> for extent locks acquired on the server.  <a href="#ga158dc17797fe9252638377c70f5f9558"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#ga44a28deab27f79e7a1ab7e77c7a59208">ldlm_completion_ast_async</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, __u64 flags, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of -&gt;l_completion_ast() for a client, that doesn't wait until lock is granted.  <a href="#ga44a28deab27f79e7a1ab7e77c7a59208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#gaae5738d417a8624f65b5418d57fef359">ldlm_completion_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, __u64 flags, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic LDLM "completion" AST.  <a href="#gaae5738d417a8624f65b5418d57fef359"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>These AST handlers are typically used for server-side local locks and are also used by client-side lock handlers to perform minimum level base processing. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gacc93548bb07532aa1d816dee71bd2ecb"></a><!-- doxytag: member="lustre_dlm.h::ldlm_blocking_ast" ref="gacc93548bb07532aa1d816dee71bd2ecb" args="(struct ldlm_lock *lock, struct ldlm_lock_desc *desc, void *data, int flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_blocking_ast </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock__desc.html">ldlm_lock_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Server blocking AST. </p>
<p>-&gt;l_blocking_ast() callback for LDLM locks acquired by server-side OBDs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>the lock which blocks a request or cancelling lock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>desc</em>&nbsp;</td><td>unused </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>unused </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>indicates whether this cancelling or blocking callback </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function.">ldlm_blocking_ast_nocheck</a> </dd></dl>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00354">354</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00741">ldlm_lock::l_blocking_ast</a>, <a class="el" href="ldlm__request_8c_source.html#l00354">ldlm_blocking_ast()</a>, <a class="el" href="ldlm__request_8c_source.html#l00315">ldlm_blocking_ast_nocheck()</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00354">ldlm_blocking_ast()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00356"></a>00356 {
<a name="l00357"></a>00357         ENTRY;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359         <span class="keywordflow">if</span> (flag == LDLM_CB_CANCELING) {
<a name="l00360"></a>00360                 <span class="comment">/* Don&apos;t need to do anything here. */</span>
<a name="l00361"></a>00361                 RETURN(0);
<a name="l00362"></a>00362         }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(lock);
<a name="l00365"></a>00365         <span class="comment">/* Get this: if ldlm_blocking_ast is racing with intent_policy, such</span>
<a name="l00366"></a>00366 <span class="comment">         * that ldlm_blocking_ast is called just before intent_policy method</span>
<a name="l00367"></a>00367 <span class="comment">         * takes the lr_lock, then by the time we get the lock, we might not</span>
<a name="l00368"></a>00368 <span class="comment">         * be the correct blocking function anymore.  So check, and return</span>
<a name="l00369"></a>00369 <span class="comment">         * early, if so. */</span>
<a name="l00370"></a>00370         <span class="keywordflow">if</span> (lock-&gt;<a class="code" href="structldlm__lock.html#ac1baaa1cb6f8c57cd0e574dff1dcdfd8" title="Lock blocking AST handler pointer.">l_blocking_ast</a> != <a class="code" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST.">ldlm_blocking_ast</a>) {
<a name="l00371"></a>00371                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00372"></a>00372                 RETURN(0);
<a name="l00373"></a>00373         }
<a name="l00374"></a>00374         RETURN(<a class="code" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function.">ldlm_blocking_ast_nocheck</a>(lock));
<a name="l00375"></a>00375 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__ldlm__local__ast_gacc93548bb07532aa1d816dee71bd2ecb_cgraph.png" border="0" usemap="#group__ldlm__local__ast_gacc93548bb07532aa1d816dee71bd2ecb_cgraph_map" alt=""></div>
<map name="group__ldlm__local__ast_gacc93548bb07532aa1d816dee71bd2ecb_cgraph_map" id="group__ldlm__local__ast_gacc93548bb07532aa1d816dee71bd2ecb_cgraph">
<area shape="rect" id="node4" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3" title="A helper to build a blocking AST function." alt="" coords="193,243,393,272"/><area shape="rect" id="node85" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="636,348,775,377"/><area shape="rect" id="node87" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="628,191,783,220"/><area shape="rect" id="node6" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="451,296,571,325"/><area shape="rect" id="node89" href="group__LDLM.html#ga35362f3605ec8dec52464f153c932c85" title="Fills in handle for LDLM lock lock into supplied lockh Does not take any references..." alt="" coords="444,243,577,272"/><area shape="rect" id="node8" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="632,295,779,324"/><area shape="rect" id="node10" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="833,295,983,324"/><area shape="rect" id="node12" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e." alt="" coords="1033,5,1236,35"/><area shape="rect" id="node14" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="1061,188,1208,217"/><area shape="rect" id="node24" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request." alt="" coords="2001,5,2148,35"/><area shape="rect" id="node64" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure..." alt="" coords="1056,241,1213,271"/><area shape="rect" id="node66" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure." alt="" coords="1057,295,1212,324"/><area shape="rect" id="node68" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps..." alt="" coords="1056,348,1213,377"/><area shape="rect" id="node79" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check&#45;&gt;ptlrpc_check_set()..." alt="" coords="1071,401,1199,431"/><area shape="rect" id="node81" href="group__req__layout.html#gab0f7a8e2a51867454ce8f87bb48b0f77" title="Fills in any parts of the rc_area of a pill that haven&#39;t been filled in yet." alt="" coords="1044,455,1225,484"/><area shape="rect" id="node83" href="group__req__layout.html#ga6d0a3a11367bcd9fe40dc723243e7b0d" title="Set the size of the PTLRPC request/reply (loc) buffer for the given field of the..." alt="" coords="1052,508,1217,537"/><area shape="rect" id="node16" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT." alt="" coords="1297,161,1425,191"/><area shape="rect" id="node18" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req." alt="" coords="1989,424,2160,453"/><area shape="rect" id="node20" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set." alt="" coords="1287,268,1436,297"/><area shape="rect" id="node22" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set..." alt="" coords="1509,109,1659,139"/><area shape="rect" id="node26" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="1299,215,1424,244"/><area shape="rect" id="node28" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="1515,215,1653,244"/><area shape="rect" id="node30" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="1769,213,1876,243"/><area shape="rect" id="node45" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network." alt="" coords="1989,371,2160,400"/><area shape="rect" id="node55" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="1732,317,1913,347"/><area shape="rect" id="node32" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME." alt="" coords="2253,227,2379,256"/><area shape="rect" id="node34" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal." alt="" coords="2255,71,2377,100"/><area shape="rect" id="node36" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list." alt="" coords="2259,148,2373,177"/><area shape="rect" id="node38" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Actual interfacing with LNet to put/get/register/unregister stuff." alt="" coords="1997,160,2152,189"/><area shape="rect" id="node47" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req." alt="" coords="1987,213,2163,243"/><area shape="rect" id="node49" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre&#45;defined security transformation upon the..." alt="" coords="1981,317,2168,347"/><area shape="rect" id="node51" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc." alt="" coords="2236,317,2396,347"/><area shape="rect" id="node57" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="1963,477,2187,507"/><area shape="rect" id="node59" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="2237,451,2395,480"/><area shape="rect" id="node61" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="2237,504,2395,533"/><area shape="rect" id="node70" href="group__req__layout.html#gaf42efe506903884592711902e9276e99" title="This function shrinks the size of the _buffer_ of the pill&#39;s PTLRPC request or..." alt="" coords="1288,448,1435,477"/><area shape="rect" id="node72" href="group__net.html#ga8ddfe4bfdb34b2159b8281fb3c6e09a4" title="lustre_msg_buflen &#45; return the length of buffer n in message m " alt="" coords="1512,421,1656,451"/><area shape="rect" id="node74" href="group__req__layout.html#gad281812fde0bdb0aaaed8a022e0008f2" title="Returns a non&#45;zero value if the given field is present in the given pill&#39;s PTLRPC..." alt="" coords="1485,525,1683,555"/><area shape="rect" id="node76" href="group__req__layout.html#ga35302dbfc2517d692579948a9742d3ba" title="This function returns a non&#45;zero value if the given field is present in the format..." alt="" coords="1740,499,1905,528"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__ldlm__local__ast_gacc93548bb07532aa1d816dee71bd2ecb_icgraph.png" border="0" usemap="#group__ldlm__local__ast_gacc93548bb07532aa1d816dee71bd2ecb_icgraph_map" alt=""></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9962ac0cc2bd7e279cf0b977d822feb3"></a><!-- doxytag: member="lustre_dlm.h::ldlm_blocking_ast_nocheck" ref="ga9962ac0cc2bd7e279cf0b977d822feb3" args="(struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_blocking_ast_nocheck </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A helper to build a blocking AST function. </p>
<p>Perform a common operation for blocking ASTs: defferred lock cancellation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>the lock blocking or canceling AST was called on </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>mdt_blocking_ast </dd>
<dd>
<a class="el" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST.">ldlm_blocking_ast</a> </dd></dl>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00315">315</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00784">ldlm_lock::l_readers</a>, <a class="el" href="ldlm__request_8c_source.html#l01345">ldlm_cli_cancel()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00582">ldlm_lock2handle()</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00354">ldlm_blocking_ast()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00316"></a>00316 {
<a name="l00317"></a>00317         <span class="keywordtype">int</span> do_ast;
<a name="l00318"></a>00318         ENTRY;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320         ldlm_set_cbpending(lock);
<a name="l00321"></a>00321         do_ast = (!lock-&gt;<a class="code" href="structldlm__lock.html#abb8a2696003a5ba2a21c2365ecc2d275" title="Lock r/w usage counters.">l_readers</a> &amp;&amp; !lock-&gt;l_writers);
<a name="l00322"></a>00322         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(lock);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324         <span class="keywordflow">if</span> (do_ast) {
<a name="l00325"></a>00325                 <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lockh;
<a name="l00326"></a>00326                 <span class="keywordtype">int</span> rc;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328                 LDLM_DEBUG(lock, <span class="stringliteral">&quot;already unused, calling ldlm_cli_cancel&quot;</span>);
<a name="l00329"></a>00329                 <a class="code" href="group__LDLM.html#ga35362f3605ec8dec52464f153c932c85" title="Fills in handle for LDLM lock lock into supplied lockh Does not take any references...">ldlm_lock2handle</a>(lock, &amp;lockh);
<a name="l00330"></a>00330                 rc = <a class="code" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel.">ldlm_cli_cancel</a>(&amp;lockh, LCF_ASYNC);
<a name="l00331"></a>00331                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00332"></a>00332                         CERROR(<span class="stringliteral">&quot;ldlm_cli_cancel: %d\n&quot;</span>, rc);
<a name="l00333"></a>00333         } <span class="keywordflow">else</span> {
<a name="l00334"></a>00334                 LDLM_DEBUG(lock, <span class="stringliteral">&quot;Lock still has references, will be &quot;</span>
<a name="l00335"></a>00335                            <span class="stringliteral">&quot;cancelled later&quot;</span>);
<a name="l00336"></a>00336         }
<a name="l00337"></a>00337         RETURN(0);
<a name="l00338"></a>00338 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__ldlm__local__ast_ga9962ac0cc2bd7e279cf0b977d822feb3_cgraph.png" border="0" usemap="#group__ldlm__local__ast_ga9962ac0cc2bd7e279cf0b977d822feb3_cgraph_map" alt=""></div>
<map name="group__ldlm__local__ast_ga9962ac0cc2bd7e279cf0b977d822feb3_cgraph_map" id="group__ldlm__local__ast_ga9962ac0cc2bd7e279cf0b977d822feb3_cgraph">
<area shape="rect" id="node3" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel." alt="" coords="264,295,384,324"/><area shape="rect" id="node84" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock." alt="" coords="441,348,596,377"/><area shape="rect" id="node86" href="group__LDLM.html#ga35362f3605ec8dec52464f153c932c85" title="Fills in handle for LDLM lock lock into supplied lockh Does not take any references..." alt="" coords="257,399,391,428"/><area shape="rect" id="node5" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872" title="Cancel client&#45;side locks from a list and send/prepare cancel RPCs to the server." alt="" coords="445,295,592,324"/><area shape="rect" id="node82" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource." alt="" coords="449,241,588,271"/><area shape="rect" id="node7" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70" title="Prepare and send a batched cancel RPC." alt="" coords="647,295,796,324"/><area shape="rect" id="node9" href="group__net.html#ga476170376a6f1bb9bb7f85ade4c774f7" title="Set server timelimit for this req, i.e." alt="" coords="847,5,1049,35"/><area shape="rect" id="node11" href="group__net.html#ga003cd2f0c09fd578821500e8084f8c48" title="Send request and wait until it completes." alt="" coords="875,188,1021,217"/><area shape="rect" id="node21" href="group__net.html#gaf16bb640b9f0c667d79b7254ac965288" title="Drops one reference count for a request." alt="" coords="1815,5,1961,35"/><area shape="rect" id="node61" href="group__net.html#ga2bf080a905f488f676248838514e264a" title="Allocate new request structure for import imp and initialize its buffer structure..." alt="" coords="869,241,1027,271"/><area shape="rect" id="node63" href="group__net.html#ga35e91945e5dfe7314c1b31519907929f" title="For requests not from pool, free memory of the request structure." alt="" coords="871,295,1025,324"/><area shape="rect" id="node65" href="group__net.html#gaa1d6f5834629cf755c8f1f0b1a4349de" title="Pack request buffers for network transfer, performing necessary encryption steps..." alt="" coords="869,348,1027,377"/><area shape="rect" id="node76" href="group__net.html#gad8a1fd19f62cb6e52ee2b145c63f5dd1" title="Requests that are added to the ptlrpcd queue are sent via ptlrpcd_check&#45;&gt;ptlrpc_check_set()..." alt="" coords="884,401,1012,431"/><area shape="rect" id="node78" href="group__req__layout.html#gab0f7a8e2a51867454ce8f87bb48b0f77" title="Fills in any parts of the rc_area of a pill that haven&#39;t been filled in yet." alt="" coords="857,455,1039,484"/><area shape="rect" id="node80" href="group__req__layout.html#ga6d0a3a11367bcd9fe40dc723243e7b0d" title="Set the size of the PTLRPC request/reply (loc) buffer for the given field of the..." alt="" coords="865,508,1031,537"/><area shape="rect" id="node13" href="group__net.html#ga7e29af1c85aba7368cea369f091d09b4" title="Allocate and initialize new request set structure on the current CPT." alt="" coords="1111,161,1239,191"/><area shape="rect" id="node15" href="group__net.html#ga60499b3efd5caf2e7bc59c308332aff3" title="Grab additional reference on a request req." alt="" coords="1803,477,1973,507"/><area shape="rect" id="node17" href="group__net.html#ga5da56461932d974b4c2487f179d8e6d8" title="Add a new request to the general purpose request set." alt="" coords="1100,268,1249,297"/><area shape="rect" id="node19" href="group__net.html#ga862d0349489e1b216f7b1be96ac3baf8" title="Wind down and free request set structure previously allocated with ptlrpc_prep_set..." alt="" coords="1323,109,1472,139"/><area shape="rect" id="node23" href="group__net.html#gac072432ff0e3366be99c8456895e28d1" title="Send all unset request from the set and then wait untill all requests in the set..." alt="" coords="1112,215,1237,244"/><area shape="rect" id="node25" href="group__net.html#ga63613680c8953223c8efc4331656b11a" title="this sends any unsent RPCs in set and returns 1 if all are sent and no more replies..." alt="" coords="1328,215,1467,244"/><area shape="rect" id="node27" href="group__net.html#ga52f0aef010b62759e4c2f9e6ef6aea3d" title="Send request request." alt="" coords="1583,213,1689,243"/><area shape="rect" id="node42" href="group__net.html#gaea9a5e62d5d55ace491db905c9a474f7" title="Disconnect a bulk desc from the network." alt="" coords="1803,371,1973,400"/><area shape="rect" id="node52" href="group__sptlrpc.html#ga94cbed545313e8c7bc6a682a438c89b0" title="To refresh the context of , if it&#39;s not up&#45;to&#45;date." alt="" coords="1545,317,1727,347"/><area shape="rect" id="node29" href="group__lnet__md.html#ga958972d35fc04d0716f4f6b71cd804fc" title="Create a memory descriptor and attach it to a ME." alt="" coords="2067,227,2192,256"/><area shape="rect" id="node31" href="group__lnet__me.html#ga581025ed43fdf21741691e82253b1b50" title="Create and attach a match entry to the match list of portal." alt="" coords="2068,71,2191,100"/><area shape="rect" id="node33" href="group__lnet__me.html#gad38e0c2462a6e9a1735783c853345422" title="Unlink a match entry from its match list." alt="" coords="2072,149,2187,179"/><area shape="rect" id="node35" href="group__net.html#gaa1cf14602e33836d92101141c3a0d67d" title="Actual interfacing with LNet to put/get/register/unregister stuff." alt="" coords="1811,109,1965,139"/><area shape="rect" id="node44" href="group__sptlrpc.html#ga2059ff503d15d0b06699e153845bc66f" title="Used by ptlrpc client to allocate reply buffer of req." alt="" coords="1800,213,1976,243"/><area shape="rect" id="node46" href="group__sptlrpc.html#ga2b508842c18d6c0a32c9678445565ce2" title="Used by ptlrpc client, to perform the pre&#45;defined security transformation upon the..." alt="" coords="1795,317,1981,347"/><area shape="rect" id="node48" href="group__sptlrpc.html#gae9ac9239c38fc5eb10c0951976a38512" title="Perform transformation upon bulk data pointed by desc." alt="" coords="2049,317,2209,347"/><area shape="rect" id="node54" href="group__sptlrpc.html#ga7254cf32b0cefed6242f298d3326e8dd" title="If current context of req is dead somehow, e.g." alt="" coords="1776,424,2000,453"/><area shape="rect" id="node56" href="group__sptlrpc.html#ga5aafb085a9167ed0295a28d4bddb5847" title="Given a req, find or allocate an appropriate context for it." alt="" coords="2051,397,2208,427"/><area shape="rect" id="node58" href="group__sptlrpc.html#ga9c506dfa976b8fa42f6d351f1a67098c" title="Drop the context for req." alt="" coords="2051,451,2208,480"/><area shape="rect" id="node67" href="group__req__layout.html#gaf42efe506903884592711902e9276e99" title="This function shrinks the size of the _buffer_ of the pill&#39;s PTLRPC request or..." alt="" coords="1101,448,1248,477"/><area shape="rect" id="node69" href="group__net.html#ga8ddfe4bfdb34b2159b8281fb3c6e09a4" title="lustre_msg_buflen &#45; return the length of buffer n in message m " alt="" coords="1325,421,1469,451"/><area shape="rect" id="node71" href="group__req__layout.html#gad281812fde0bdb0aaaed8a022e0008f2" title="Returns a non&#45;zero value if the given field is present in the given pill&#39;s PTLRPC..." alt="" coords="1299,525,1496,555"/><area shape="rect" id="node73" href="group__req__layout.html#ga35302dbfc2517d692579948a9742d3ba" title="This function returns a non&#45;zero value if the given field is present in the format..." alt="" coords="1553,499,1719,528"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__ldlm__local__ast_ga9962ac0cc2bd7e279cf0b977d822feb3_icgraph.png" border="0" usemap="#group__ldlm__local__ast_ga9962ac0cc2bd7e279cf0b977d822feb3_icgraph_map" alt=""></div>
<map name="group__ldlm__local__ast_ga9962ac0cc2bd7e279cf0b977d822feb3_icgraph_map" id="group__ldlm__local__ast_ga9962ac0cc2bd7e279cf0b977d822feb3_icgraph">
<area shape="rect" id="node3" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb" title="Server blocking AST." alt="" coords="256,29,395,59"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaae5738d417a8624f65b5418d57fef359"></a><!-- doxytag: member="lustre_dlm.h::ldlm_completion_ast" ref="gaae5738d417a8624f65b5418d57fef359" args="(struct ldlm_lock *lock, __u64 flags, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_completion_ast </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic LDLM "completion" AST. </p>
<p>This is called in several cases:</p>
<ul>
<li>when a reply to an ENQUEUE RPC is received from the server (<a class="el" href="group__ldlm__cli__api.html#gac421005283912bb5186b035013aa58c0" title="Finishing portion of client lock enqueue code.">ldlm_cli_enqueue_fini()</a>). Lock might be granted or not granted at this point (determined by flags);</li>
</ul>
<ul>
<li>when LDLM_CP_CALLBACK RPC comes to client to notify it that lock has been granted;</li>
</ul>
<ul>
<li>when ldlm_lock_match(LDLM_FL_LVB_READY) is about to wait until lock gets correct lvb;</li>
</ul>
<ul>
<li>to force all locks when resource is destroyed (cleanup_resource());</li>
</ul>
<ul>
<li>during lock conversion (not used currently).</li>
</ul>
<p>If lock is not granted in the first case, this function waits until second or penultimate cases happen in some other thread. </p>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00230">230</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00239">obd_import::imp_conn_cnt</a>, <a class="el" href="lustre__import_8h_source.html#l00274">obd_import::imp_lock</a>, <a class="el" href="lustre__dlm_8h_source.html#l00759">ldlm_lock::l_conn_export</a>, <a class="el" href="lustre__dlm_8h_source.html#l00797">ldlm_lock::l_last_activity</a>, <a class="el" href="lustre__dlm_8h_source.html#l00791">ldlm_lock::l_waitq</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00370">LDLM_FL_BLOCKED_MASK</a>, and <a class="el" href="lustre__dlm__flags_8h_source.html#l00179">LDLM_FL_WAIT_NOREPROC</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00231"></a>00231 {
<a name="l00232"></a>00232         <span class="comment">/* XXX ALLOCATE - 160 bytes */</span>
<a name="l00233"></a>00233         <span class="keyword">struct </span>lock_wait_data lwd;
<a name="l00234"></a>00234         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd;
<a name="l00235"></a>00235         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp = NULL;
<a name="l00236"></a>00236         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi;
<a name="l00237"></a>00237         __u32 timeout;
<a name="l00238"></a>00238         <span class="keywordtype">int</span> rc = 0;
<a name="l00239"></a>00239         ENTRY;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         <span class="keywordflow">if</span> (flags == <a class="code" href="group__LDLM.html#gae36b9cddb3e68705d21f384ad3a3e1e6" title="not a real flag, not saved in lock">LDLM_FL_WAIT_NOREPROC</a>) {
<a name="l00242"></a>00242                 LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue waiting on pending lock&quot;</span>);
<a name="l00243"></a>00243                 <span class="keywordflow">goto</span> noreproc;
<a name="l00244"></a>00244         }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (!(flags &amp; <a class="code" href="group__LDLM.html#ga6316c2ca1fd038c2cc96402b744d16c9" title="l_flags bits marked as &amp;quot;blocked&amp;quot; bits">LDLM_FL_BLOCKED_MASK</a>)) {
<a name="l00247"></a>00247                 wake_up(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a0ca58a0480ef9503c3548499e27c2e43" title="If the lock is granted, a process sleeps on this waitq to learn when it&amp;#39;s no...">l_waitq</a>);
<a name="l00248"></a>00248                 RETURN(0);
<a name="l00249"></a>00249         }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251         LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue returned a blocked lock, &quot;</span>
<a name="l00252"></a>00252                    <span class="stringliteral">&quot;sleeping&quot;</span>);
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 noreproc:
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         obd = class_exp2obd(lock-&gt;<a class="code" href="structldlm__lock.html#ae11dfeaaf68f7217bc5defa97b58b1b1" title="Lock connection export.">l_conn_export</a>);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         <span class="comment">/* if this is a local lock, then there is no import */</span>
<a name="l00259"></a>00259         <span class="keywordflow">if</span> (obd != NULL) {
<a name="l00260"></a>00260                 imp = obd-&gt;u.cli.cl_import;
<a name="l00261"></a>00261         }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263         timeout = ldlm_cp_timeout(lock);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265         lwd.lwd_lock = lock;
<a name="l00266"></a>00266         lock-&gt;<a class="code" href="structldlm__lock.html#af1f00870111fa501c0fb07a97c642fb1" title="Seconds.">l_last_activity</a> = cfs_time_current_sec();
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         <span class="keywordflow">if</span> (ldlm_is_no_timeout(lock)) {
<a name="l00269"></a>00269                 LDLM_DEBUG(lock, <span class="stringliteral">&quot;waiting indefinitely because of NO_TIMEOUT&quot;</span>);
<a name="l00270"></a>00270                 lwi = LWI_INTR(interrupted_completion_wait, &amp;lwd);
<a name="l00271"></a>00271         } <span class="keywordflow">else</span> {
<a name="l00272"></a>00272                 lwi = LWI_TIMEOUT_INTR(cfs_time_seconds(timeout),
<a name="l00273"></a>00273                                        ldlm_expired_completion_wait,
<a name="l00274"></a>00274                                        interrupted_completion_wait, &amp;lwd);
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         <span class="keywordflow">if</span> (imp != NULL) {
<a name="l00278"></a>00278                 spin_lock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00279"></a>00279                 lwd.lwd_conn_cnt = imp-&gt;<a class="code" href="structobd__import.html#ac3b8409237b9f6fc17e80bdfed39a1d5" title="Incremented every time we send reconnection request.">imp_conn_cnt</a>;
<a name="l00280"></a>00280                 spin_unlock(&amp;imp-&gt;<a class="code" href="structobd__import.html#a09a565a2b8f619c888dd51cd673fdffb" title="Protects flags, level, generation, conn_cnt, *_list.">imp_lock</a>);
<a name="l00281"></a>00281         }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283         <span class="keywordflow">if</span> (ns_is_client(ldlm_lock_to_ns(lock)) &amp;&amp;
<a name="l00284"></a>00284             OBD_FAIL_CHECK_RESET(OBD_FAIL_LDLM_INTR_CP_AST,
<a name="l00285"></a>00285                                  OBD_FAIL_LDLM_CP_BL_RACE | OBD_FAIL_ONCE)) {
<a name="l00286"></a>00286                 ldlm_set_fail_loc(lock);
<a name="l00287"></a>00287                 rc = -EINTR;
<a name="l00288"></a>00288         } <span class="keywordflow">else</span> {
<a name="l00289"></a>00289                 <span class="comment">/* Go to sleep until the lock is granted or cancelled. */</span>
<a name="l00290"></a>00290                 rc = l_wait_event(lock-&gt;<a class="code" href="structldlm__lock.html#a0ca58a0480ef9503c3548499e27c2e43" title="If the lock is granted, a process sleeps on this waitq to learn when it&amp;#39;s no...">l_waitq</a>,
<a name="l00291"></a>00291                                   is_granted_or_cancelled(lock), &amp;lwi);
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         <span class="keywordflow">if</span> (rc) {
<a name="l00295"></a>00295                 LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue waking up: failed (%d)&quot;</span>,
<a name="l00296"></a>00296                            rc);
<a name="l00297"></a>00297                 RETURN(rc);
<a name="l00298"></a>00298         }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300         RETURN(ldlm_completion_tail(lock, data));
<a name="l00301"></a>00301 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga44a28deab27f79e7a1ab7e77c7a59208"></a><!-- doxytag: member="lustre_dlm.h::ldlm_completion_ast_async" ref="ga44a28deab27f79e7a1ab7e77c7a59208" args="(struct ldlm_lock *lock, __u64 flags, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_completion_ast_async </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of -&gt;l_completion_ast() for a client, that doesn't wait until lock is granted. </p>
<p>Suitable for locks enqueued through ptlrpcd, of other threads that cannot block for long. </p>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00188">188</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>, <a class="el" href="lustre__dlm_8h_source.html#l00791">ldlm_lock::l_waitq</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00370">LDLM_FL_BLOCKED_MASK</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00179">LDLM_FL_WAIT_NOREPROC</a>, and <a class="el" href="ldlm__lock_8c_source.html#l02147">ldlm_reprocess_all()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00189"></a>00189 {
<a name="l00190"></a>00190         ENTRY;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         <span class="keywordflow">if</span> (flags == <a class="code" href="group__LDLM.html#gae36b9cddb3e68705d21f384ad3a3e1e6" title="not a real flag, not saved in lock">LDLM_FL_WAIT_NOREPROC</a>) {
<a name="l00193"></a>00193                 LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue waiting on pending lock&quot;</span>);
<a name="l00194"></a>00194                 RETURN(0);
<a name="l00195"></a>00195         }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         <span class="keywordflow">if</span> (!(flags &amp; <a class="code" href="group__LDLM.html#ga6316c2ca1fd038c2cc96402b744d16c9" title="l_flags bits marked as &amp;quot;blocked&amp;quot; bits">LDLM_FL_BLOCKED_MASK</a>)) {
<a name="l00198"></a>00198                 wake_up(&amp;lock-&gt;<a class="code" href="structldlm__lock.html#a0ca58a0480ef9503c3548499e27c2e43" title="If the lock is granted, a process sleeps on this waitq to learn when it&amp;#39;s no...">l_waitq</a>);
<a name="l00199"></a>00199                 RETURN(ldlm_completion_tail(lock, data));
<a name="l00200"></a>00200         }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         LDLM_DEBUG(lock, <span class="stringliteral">&quot;client-side enqueue returned a blocked lock, &quot;</span>
<a name="l00203"></a>00203                    <span class="stringliteral">&quot;going forward&quot;</span>);
<a name="l00204"></a>00204         <a class="code" href="group__LDLM.html#ga6fea368fc4ea7002b0dcd068bbe8771a" title="Try to grant all waiting locks on a resource.">ldlm_reprocess_all</a>(lock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>);
<a name="l00205"></a>00205         RETURN(0);
<a name="l00206"></a>00206 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__ldlm__local__ast_ga44a28deab27f79e7a1ab7e77c7a59208_cgraph.png" border="0" usemap="#group__ldlm__local__ast_ga44a28deab27f79e7a1ab7e77c7a59208_cgraph_map" alt=""></div>
<map name="group__ldlm__local__ast_ga44a28deab27f79e7a1ab7e77c7a59208_cgraph_map" id="group__ldlm__local__ast_ga44a28deab27f79e7a1ab7e77c7a59208_cgraph">
<area shape="rect" id="node3" href="group__LDLM.html#ga6fea368fc4ea7002b0dcd068bbe8771a" title="Try to grant all waiting locks on a resource." alt="" coords="263,5,404,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga158dc17797fe9252638377c70f5f9558"></a><!-- doxytag: member="lustre_dlm.h::ldlm_glimpse_ast" ref="ga158dc17797fe9252638377c70f5f9558" args="(struct ldlm_lock *lock, void *reqp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_glimpse_ast </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>reqp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="structldlm__lock.html#aaa0d1608f452158ab011eecc6f978058" title="Lock glimpse handler.">ldlm_lock::l_glimpse_ast</a> for extent locks acquired on the server. </p>
<p>Returning -ELDLM_NO_LOCK_DATA actually works, but the reason for that is rather subtle: with OST-side locking, it may so happen that _all_ extent locks are held by the OST. If client wants to obtain the current file size it calls ll_glimpse_size(), and (as all locks are held only on the server), this dummy glimpse callback fires and does nothing. The client still receives the correct file size due to the following fragment of code in ldlm_cb_interpret():</p>
<p>if (rc == -ELDLM_NO_LOCK_DATA) { LDLM_DEBUG(lock, "lost race - client has a lock but no" "inode"); ldlm_res_lvbo_update(lock-&gt;l_resource, NULL, 1); }</p>
<p>That is, after the glimpse returns this error, ofd_lvbo_update() is called and returns the updated file attributes from the inode to the client.</p>
<p>See also comment in ofd_intent_policy() on why servers must set a non-NULL l_glimpse_ast when grabbing DLM locks. Otherwise, the server will assume that the object is in the process of being destroyed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>DLM lock being glimpsed, unused </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reqp</em>&nbsp;</td><td>pointer to <a class="el" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, unused</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ELDLM_NO_LOCK_DATA</em>&nbsp;</td><td>to get attributes from disk object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00407">407</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00408"></a>00408 {
<a name="l00409"></a>00409         <span class="keywordflow">return</span> -ELDLM_NO_LOCK_DATA;
<a name="l00410"></a>00410 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:41 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
