<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/lod/lod_object.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/lod/lod_object.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment"> * GNU General Public License version 2 for more details.  A copy is</span>
<a name="l00014"></a>00014 <span class="comment"> * included in the COPYING file that accompanied this code.</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * along with this program; if not, write to the Free Software</span>
<a name="l00018"></a>00018 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * GPL HEADER END</span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 <span class="comment">/*</span>
<a name="l00023"></a>00023 <span class="comment"> * Copyright  2009 Sun Microsystems, Inc. All rights reserved</span>
<a name="l00024"></a>00024 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00025"></a>00025 <span class="comment"> *</span>
<a name="l00026"></a>00026 <span class="comment"> * Copyright (c) 2012, 2015, Intel Corporation.</span>
<a name="l00027"></a>00027 <span class="comment"> */</span>
<a name="l00028"></a>00028 <span class="comment">/*</span>
<a name="l00029"></a>00029 <span class="comment"> * lustre/lod/lod_object.c</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> * This file contains implementations of methods for the OSD API</span>
<a name="l00032"></a>00032 <span class="comment"> * for the Logical Object Device (LOD) layer, which provides a virtual</span>
<a name="l00033"></a>00033 <span class="comment"> * local OSD object interface to the MDD layer, and abstracts the</span>
<a name="l00034"></a>00034 <span class="comment"> * addressing of local (OSD) and remote (OSP) objects. The API is</span>
<a name="l00035"></a>00035 <span class="comment"> * described in the file lustre/include/dt_object.h and in</span>
<a name="l00036"></a>00036 <span class="comment"> * Documentation/osd-api.txt.</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Author: Alex Zhuravlev &lt;alexey.zhuravlev@intel.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> */</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#define DEBUG_SUBSYSTEM S_MDS</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;obd.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;obd_class.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;obd_support.h&gt;</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;lustre_fid.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;lustre_linkea.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;lustre_lmv.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;lustre_param.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;lustre_swab.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;lustre_ver.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;lprocfs_status.h&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;md_object.h&gt;</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;lod_internal.h&quot;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> dot[] = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l00059"></a>00059 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> dotdot[] = <span class="stringliteral">&quot;..&quot;</span>;
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__body__operations.html" title="Per-dt-object operations on &amp;quot;file body&amp;quot; - unstructure raw data.">dt_body_operations</a> lod_body_lnk_ops;
<a name="l00062"></a>00062 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__body__operations.html" title="Per-dt-object operations on &amp;quot;file body&amp;quot; - unstructure raw data.">dt_body_operations</a> lod_body_ops;
<a name="l00063"></a>00063 
<a name="l00071"></a>00071 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_index_lookup(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00072"></a>00072                             <span class="keyword">struct</span> dt_rec *rec, <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key)
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *next = dt_object_child(dt);
<a name="l00075"></a>00075         <span class="keywordflow">return</span> next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#aab6a7632adfce2297c022b12f0d61791" title="Lookup in an index by key.">dio_lookup</a>(env, next, rec, key);
<a name="l00076"></a>00076 }
<a name="l00077"></a>00077 
<a name="l00086"></a>00086 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_index_insert(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00087"></a>00087                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00088"></a>00088                                     <span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *rec,
<a name="l00089"></a>00089                                     <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key,
<a name="l00090"></a>00090                                     <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00091"></a>00091 {
<a name="l00092"></a>00092         <span class="keywordflow">return</span> lod_sub_object_declare_insert(env, dt_object_child(dt),
<a name="l00093"></a>00093                                              rec, key, th);
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00103"></a>00103 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_index_insert(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00104"></a>00104                             <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00105"></a>00105                             <span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *rec,
<a name="l00106"></a>00106                             <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key,
<a name="l00107"></a>00107                             <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th,
<a name="l00108"></a>00108                             <span class="keywordtype">int</span> ign)
<a name="l00109"></a>00109 {
<a name="l00110"></a>00110         <span class="keywordflow">return</span> lod_sub_object_index_insert(env, dt_object_child(dt), rec, key,
<a name="l00111"></a>00111                                            th, ign);
<a name="l00112"></a>00112 }
<a name="l00113"></a>00113 
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_index_delete(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00123"></a>00123                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00124"></a>00124                                     <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key,
<a name="l00125"></a>00125                                     <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00126"></a>00126 {
<a name="l00127"></a>00127         <span class="keywordflow">return</span> lod_sub_object_declare_delete(env, dt_object_child(dt), key,
<a name="l00128"></a>00128                                              th);
<a name="l00129"></a>00129 }
<a name="l00130"></a>00130 
<a name="l00138"></a>00138 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_index_delete(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00139"></a>00139                             <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00140"></a>00140                             <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key,
<a name="l00141"></a>00141                             <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l00142"></a>00142 {
<a name="l00143"></a>00143         <span class="keywordflow">return</span> lod_sub_object_delete(env, dt_object_child(dt), key, th);
<a name="l00144"></a>00144 }
<a name="l00145"></a>00145 
<a name="l00153"></a>00153 <span class="keyword">static</span> <span class="keyword">struct </span>dt_it *lod_it_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00154"></a>00154                                  <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, __u32 attr)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = dt_object_child(dt);
<a name="l00157"></a>00157         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>           *it = &amp;lod_env_info(env)-&gt;lti_it;
<a name="l00158"></a>00158         <span class="keyword">struct </span>dt_it            *it_next;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         it_next = next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a74b9db7e1791f6accf99c80a3a0c43e2" title="Allocate and initialize new iterator.">init</a>(env, next, attr);
<a name="l00161"></a>00161         <span class="keywordflow">if</span> (IS_ERR(it_next))
<a name="l00162"></a>00162                 <span class="keywordflow">return</span> it_next;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         <span class="comment">/* currently we do not use more than one iterator per thread</span>
<a name="l00165"></a>00165 <span class="comment">         * so we store it in thread info. if at some point we need</span>
<a name="l00166"></a>00166 <span class="comment">         * more active iterators in a single thread, we can allocate</span>
<a name="l00167"></a>00167 <span class="comment">         * additional ones */</span>
<a name="l00168"></a>00168         LASSERT(it-&gt;lit_obj == NULL);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         it-&gt;lit_it = it_next;
<a name="l00171"></a>00171         it-&gt;lit_obj = next;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         <span class="keywordflow">return</span> (<span class="keyword">struct</span> dt_it *)it;
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="preprocessor">#define LOD_CHECK_IT(env, it)                                   \</span>
<a name="l00177"></a>00177 <span class="preprocessor">do {                                                            \</span>
<a name="l00178"></a>00178 <span class="preprocessor">        LASSERT((it)-&gt;lit_obj != NULL);                         \</span>
<a name="l00179"></a>00179 <span class="preprocessor">        LASSERT((it)-&gt;lit_it != NULL);                          \</span>
<a name="l00180"></a>00180 <span class="preprocessor">} while (0)</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>
<a name="l00189"></a>00189 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_it_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> dt_it *di)
<a name="l00190"></a>00190 {
<a name="l00191"></a>00191         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         LOD_CHECK_IT(env, it);
<a name="l00194"></a>00194         it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a9bde98040f4ba4fd69f69aa73c606cdd" title="Release iterator.">fini</a>(env, it-&gt;lit_it);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         <span class="comment">/* the iterator not in use any more */</span>
<a name="l00197"></a>00197         it-&gt;lit_obj = NULL;
<a name="l00198"></a>00198         it-&gt;lit_it = NULL;
<a name="l00199"></a>00199 }
<a name="l00200"></a>00200 
<a name="l00208"></a>00208 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_it_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> dt_it *di,
<a name="l00209"></a>00209                       <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213         LOD_CHECK_IT(env, it);
<a name="l00214"></a>00214         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a6f4864859efe4a643b4597f0fb87f229" title="Move position of iterator.">get</a>(env, it-&gt;lit_it, key);
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00224"></a>00224 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_it_put(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> dt_it *di)
<a name="l00225"></a>00225 {
<a name="l00226"></a>00226         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228         LOD_CHECK_IT(env, it);
<a name="l00229"></a>00229         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a0a49bc42af0733f3a82dd0e8c6cbe1e5" title="Release position.">put</a>(env, it-&gt;lit_it);
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00239"></a>00239 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_it_next(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> dt_it *di)
<a name="l00240"></a>00240 {
<a name="l00241"></a>00241         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243         LOD_CHECK_IT(env, it);
<a name="l00244"></a>00244         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#aa41e28336a93af94d1c5e629d9394631" title="Move to next record.">next</a>(env, it-&gt;lit_it);
<a name="l00245"></a>00245 }
<a name="l00246"></a>00246 
<a name="l00254"></a>00254 <span class="keyword">static</span> <span class="keyword">struct </span>dt_key *lod_it_key(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00255"></a>00255                                  <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di)
<a name="l00256"></a>00256 {
<a name="l00257"></a>00257         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         LOD_CHECK_IT(env, it);
<a name="l00260"></a>00260         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a426dff3fc53f2cfed2fe22713d990ddc" title="Return key.">key</a>(env, it-&gt;lit_it);
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 
<a name="l00270"></a>00270 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_it_key_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di)
<a name="l00271"></a>00271 {
<a name="l00272"></a>00272         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274         LOD_CHECK_IT(env, it);
<a name="l00275"></a>00275         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a0e2180d888668bf163ebf81fd27dc857" title="Return key size.">key_size</a>(env, it-&gt;lit_it);
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00285"></a>00285 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_it_rec(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di,
<a name="l00286"></a>00286                       <span class="keyword">struct</span> dt_rec *rec, __u32 attr)
<a name="l00287"></a>00287 {
<a name="l00288"></a>00288         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         LOD_CHECK_IT(env, it);
<a name="l00291"></a>00291         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a1b24018fcd837461771bb59a4d0c0d05" title="Return record.">rec</a>(env, it-&gt;lit_it, rec,
<a name="l00292"></a>00292                                                      attr);
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00302"></a>00302 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_it_rec_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di,
<a name="l00303"></a>00303                            __u32 attr)
<a name="l00304"></a>00304 {
<a name="l00305"></a>00305         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307         LOD_CHECK_IT(env, it);
<a name="l00308"></a>00308         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a5a85dfb5e79d606a1abba1c1fd9986cc" title="Return record size.">rec_size</a>(env, it-&gt;lit_it,
<a name="l00309"></a>00309                                                           attr);
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 
<a name="l00319"></a>00319 <span class="keyword">static</span> __u64 lod_it_store(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di)
<a name="l00320"></a>00320 {
<a name="l00321"></a>00321         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323         LOD_CHECK_IT(env, it);
<a name="l00324"></a>00324         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a2966e2ef5ccc21df92b6a31b7c4a56f5" title="Return a cookie (hash).">store</a>(env, it-&gt;lit_it);
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 
<a name="l00334"></a>00334 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_it_load(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di,
<a name="l00335"></a>00335                        __u64 hash)
<a name="l00336"></a>00336 {
<a name="l00337"></a>00337         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339         LOD_CHECK_IT(env, it);
<a name="l00340"></a>00340         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a3ca6f6284e09ac4853574a011d4bd649" title="Initialize position using cookie/hash.">load</a>(env, it-&gt;lit_it, hash);
<a name="l00341"></a>00341 }
<a name="l00342"></a>00342 
<a name="l00350"></a>00350 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_it_key_rec(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di,
<a name="l00351"></a>00351                           <span class="keywordtype">void</span> *key_rec)
<a name="l00352"></a>00352 {
<a name="l00353"></a>00353         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         LOD_CHECK_IT(env, it);
<a name="l00356"></a>00356         <span class="keywordflow">return</span> it-&gt;lit_obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a26fde1d3c4f5e818827e667418f6f4ba" title="Not used.">key_rec</a>(env, it-&gt;lit_it,
<a name="l00357"></a>00357                                                          key_rec);
<a name="l00358"></a>00358 }
<a name="l00359"></a>00359 
<a name="l00360"></a>00360 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdt__index__operations.html" title="Per-dt-object operations on object as index.">dt_index_operations</a> lod_index_ops = {
<a name="l00361"></a>00361         .<a class="code" href="structdt__index__operations.html#aab6a7632adfce2297c022b12f0d61791" title="Lookup in an index by key.">dio_lookup</a>             = lod_index_lookup,
<a name="l00362"></a>00362         .dio_declare_insert     = lod_declare_index_insert,
<a name="l00363"></a>00363         .dio_insert             = lod_index_insert,
<a name="l00364"></a>00364         .dio_declare_delete     = lod_declare_index_delete,
<a name="l00365"></a>00365         .dio_delete             = lod_index_delete,
<a name="l00366"></a>00366         .dio_it = {
<a name="l00367"></a>00367                 .init           = lod_it_init,
<a name="l00368"></a>00368                 .fini           = lod_it_fini,
<a name="l00369"></a>00369                 .get            = lod_it_get,
<a name="l00370"></a>00370                 .put            = lod_it_put,
<a name="l00371"></a>00371                 .next           = lod_it_next,
<a name="l00372"></a>00372                 .key            = lod_it_key,
<a name="l00373"></a>00373                 .key_size       = lod_it_key_size,
<a name="l00374"></a>00374                 .rec            = lod_it_rec,
<a name="l00375"></a>00375                 .rec_size       = lod_it_rec_size,
<a name="l00376"></a>00376                 .store          = lod_it_store,
<a name="l00377"></a>00377                 .load           = lod_it_load,
<a name="l00378"></a>00378                 .key_rec        = lod_it_key_rec,
<a name="l00379"></a>00379         }
<a name="l00380"></a>00380 };
<a name="l00381"></a>00381 
<a name="l00390"></a>00390 <span class="keyword">static</span> <span class="keyword">struct </span>dt_it *lod_striped_it_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00391"></a>00391                                          <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, __u32 attr)
<a name="l00392"></a>00392 {
<a name="l00393"></a>00393         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l00394"></a>00394         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00395"></a>00395         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>           *it = &amp;lod_env_info(env)-&gt;lti_it;
<a name="l00396"></a>00396         <span class="keyword">struct </span>dt_it            *it_next;
<a name="l00397"></a>00397         ENTRY;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399         LASSERT(lo-&gt;ldo_stripenr &gt; 0);
<a name="l00400"></a>00400         next = lo-&gt;ldo_stripe[0];
<a name="l00401"></a>00401         LASSERT(next != NULL);
<a name="l00402"></a>00402         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00403"></a>00403 
<a name="l00404"></a>00404         it_next = next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a74b9db7e1791f6accf99c80a3a0c43e2" title="Allocate and initialize new iterator.">init</a>(env, next, attr);
<a name="l00405"></a>00405         <span class="keywordflow">if</span> (IS_ERR(it_next))
<a name="l00406"></a>00406                 <span class="keywordflow">return</span> it_next;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408         <span class="comment">/* currently we do not use more than one iterator per thread</span>
<a name="l00409"></a>00409 <span class="comment">         * so we store it in thread info. if at some point we need</span>
<a name="l00410"></a>00410 <span class="comment">         * more active iterators in a single thread, we can allocate</span>
<a name="l00411"></a>00411 <span class="comment">         * additional ones */</span>
<a name="l00412"></a>00412         LASSERT(it-&gt;lit_obj == NULL);
<a name="l00413"></a>00413 
<a name="l00414"></a>00414         it-&gt;lit_stripe_index = 0;
<a name="l00415"></a>00415         it-&gt;lit_attr = attr;
<a name="l00416"></a>00416         it-&gt;lit_it = it_next;
<a name="l00417"></a>00417         it-&gt;lit_obj = dt;
<a name="l00418"></a>00418 
<a name="l00419"></a>00419         <span class="keywordflow">return</span> (<span class="keyword">struct</span> dt_it *)it;
<a name="l00420"></a>00420 }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="preprocessor">#define LOD_CHECK_STRIPED_IT(env, it, lo)                       \</span>
<a name="l00423"></a>00423 <span class="preprocessor">do {                                                            \</span>
<a name="l00424"></a>00424 <span class="preprocessor">        LASSERT((it)-&gt;lit_obj != NULL);                         \</span>
<a name="l00425"></a>00425 <span class="preprocessor">        LASSERT((it)-&gt;lit_it != NULL);                          \</span>
<a name="l00426"></a>00426 <span class="preprocessor">        LASSERT((lo)-&gt;ldo_stripenr &gt; 0);                        \</span>
<a name="l00427"></a>00427 <span class="preprocessor">        LASSERT((it)-&gt;lit_stripe_index &lt; (lo)-&gt;ldo_stripenr);   \</span>
<a name="l00428"></a>00428 <span class="preprocessor">} while (0)</span>
<a name="l00429"></a>00429 <span class="preprocessor"></span>
<a name="l00437"></a>00437 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_striped_it_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> dt_it *di)
<a name="l00438"></a>00438 {
<a name="l00439"></a>00439         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>           *it = (<span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00440"></a>00440         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00441"></a>00441         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443         <span class="comment">/* If lit_it == NULL, then it means the sub_it has been finished,</span>
<a name="l00444"></a>00444 <span class="comment">         * which only happens in failure cases, see lod_striped_it_next() */</span>
<a name="l00445"></a>00445         <span class="keywordflow">if</span> (it-&gt;lit_it != NULL) {
<a name="l00446"></a>00446                 LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00447"></a>00447 
<a name="l00448"></a>00448                 next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00449"></a>00449                 LASSERT(next != NULL);
<a name="l00450"></a>00450                 LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00451"></a>00451 
<a name="l00452"></a>00452                 next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a9bde98040f4ba4fd69f69aa73c606cdd" title="Release iterator.">fini</a>(env, it-&gt;lit_it);
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         <span class="comment">/* the iterator not in use any more */</span>
<a name="l00456"></a>00456         it-&gt;lit_obj = NULL;
<a name="l00457"></a>00457         it-&gt;lit_it = NULL;
<a name="l00458"></a>00458         it-&gt;lit_stripe_index = 0;
<a name="l00459"></a>00459 }
<a name="l00460"></a>00460 
<a name="l00470"></a>00470 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_striped_it_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> dt_it *di,
<a name="l00471"></a>00471                               <span class="keyword">const</span> <span class="keyword">struct</span> dt_key *key)
<a name="l00472"></a>00472 {
<a name="l00473"></a>00473         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>     *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00474"></a>00474         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00475"></a>00475         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00476"></a>00476         ENTRY;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00479"></a>00479 
<a name="l00480"></a>00480         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00481"></a>00481         LASSERT(next != NULL);
<a name="l00482"></a>00482         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         <span class="keywordflow">return</span> next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a6f4864859efe4a643b4597f0fb87f229" title="Move position of iterator.">get</a>(env, it-&gt;lit_it, key);
<a name="l00485"></a>00485 }
<a name="l00486"></a>00486 
<a name="l00494"></a>00494 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_striped_it_put(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> dt_it *di)
<a name="l00495"></a>00495 {
<a name="l00496"></a>00496         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>           *it = (<span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00497"></a>00497         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00498"></a>00498         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500         LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00503"></a>00503         LASSERT(next != NULL);
<a name="l00504"></a>00504         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506         <span class="keywordflow">return</span> next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a0a49bc42af0733f3a82dd0e8c6cbe1e5" title="Release position.">put</a>(env, it-&gt;lit_it);
<a name="l00507"></a>00507 }
<a name="l00508"></a>00508 
<a name="l00517"></a>00517 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_striped_it_next(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> dt_it *di)
<a name="l00518"></a>00518 {
<a name="l00519"></a>00519         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>           *it = (<span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00520"></a>00520         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00521"></a>00521         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00522"></a>00522         <span class="keyword">struct </span>dt_it            *it_next;
<a name="l00523"></a>00523         <span class="keywordtype">int</span>                     rc;
<a name="l00524"></a>00524         ENTRY;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00527"></a>00527 
<a name="l00528"></a>00528         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00529"></a>00529         LASSERT(next != NULL);
<a name="l00530"></a>00530         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00531"></a>00531 again:
<a name="l00532"></a>00532         rc = next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#aa41e28336a93af94d1c5e629d9394631" title="Move to next record.">next</a>(env, it-&gt;lit_it);
<a name="l00533"></a>00533         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00534"></a>00534                 RETURN(rc);
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; it-&gt;lit_stripe_index == 0)
<a name="l00537"></a>00537                 RETURN(rc);
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; it-&gt;lit_stripe_index &gt; 0) {
<a name="l00540"></a>00540                 <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *ent;
<a name="l00541"></a>00541 
<a name="l00542"></a>00542                 ent = (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)lod_env_info(env)-&gt;lti_key;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544                 rc = next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a1b24018fcd837461771bb59a4d0c0d05" title="Return record.">rec</a>(env, it-&gt;lit_it,
<a name="l00545"></a>00545                                                     (<span class="keyword">struct</span> dt_rec *)ent,
<a name="l00546"></a>00546                                                     it-&gt;lit_attr);
<a name="l00547"></a>00547                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00548"></a>00548                         RETURN(rc);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550                 <span class="comment">/* skip . and .. for slave stripe */</span>
<a name="l00551"></a>00551                 <span class="keywordflow">if</span> ((strncmp(ent-&gt;lde_name, <span class="stringliteral">&quot;.&quot;</span>,
<a name="l00552"></a>00552                              le16_to_cpu(ent-&gt;lde_namelen)) == 0 &amp;&amp;
<a name="l00553"></a>00553                      le16_to_cpu(ent-&gt;lde_namelen) == 1) ||
<a name="l00554"></a>00554                     (strncmp(ent-&gt;lde_name, <span class="stringliteral">&quot;..&quot;</span>,
<a name="l00555"></a>00555                              le16_to_cpu(ent-&gt;lde_namelen)) == 0 &amp;&amp;
<a name="l00556"></a>00556                      le16_to_cpu(ent-&gt;lde_namelen) == 2))
<a name="l00557"></a>00557                         <span class="keywordflow">goto</span> again;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559                 RETURN(rc);
<a name="l00560"></a>00560         }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562         <span class="comment">/* go to next stripe */</span>
<a name="l00563"></a>00563         <span class="keywordflow">if</span> (it-&gt;lit_stripe_index + 1 &gt;= lo-&gt;ldo_stripenr)
<a name="l00564"></a>00564                 RETURN(1);
<a name="l00565"></a>00565 
<a name="l00566"></a>00566         it-&gt;lit_stripe_index++;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568         next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a0a49bc42af0733f3a82dd0e8c6cbe1e5" title="Release position.">put</a>(env, it-&gt;lit_it);
<a name="l00569"></a>00569         next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a9bde98040f4ba4fd69f69aa73c606cdd" title="Release iterator.">fini</a>(env, it-&gt;lit_it);
<a name="l00570"></a>00570         it-&gt;lit_it = NULL;
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00573"></a>00573         LASSERT(next != NULL);
<a name="l00574"></a>00574         rc = next-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2" title="Try object as an index.">do_index_try</a>(env, next, &amp;<a class="code" href="group__dt.html#ga7c4fc0f51c05675af9609faa67c6cdea" title="Features, required from index to support file system directories (mapping names to...">dt_directory_features</a>);
<a name="l00575"></a>00575         <span class="keywordflow">if</span> (rc != 0)
<a name="l00576"></a>00576                 RETURN(rc);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00579"></a>00579 
<a name="l00580"></a>00580         it_next = next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a74b9db7e1791f6accf99c80a3a0c43e2" title="Allocate and initialize new iterator.">init</a>(env, next, it-&gt;lit_attr);
<a name="l00581"></a>00581         <span class="keywordflow">if</span> (!IS_ERR(it_next)) {
<a name="l00582"></a>00582                 it-&gt;lit_it = it_next;
<a name="l00583"></a>00583                 <span class="keywordflow">goto</span> again;
<a name="l00584"></a>00584         } <span class="keywordflow">else</span> {
<a name="l00585"></a>00585                 rc = PTR_ERR(it_next);
<a name="l00586"></a>00586         }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588         RETURN(rc);
<a name="l00589"></a>00589 }
<a name="l00590"></a>00590 
<a name="l00598"></a>00598 <span class="keyword">static</span> <span class="keyword">struct </span>dt_key *lod_striped_it_key(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00599"></a>00599                                          <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>     *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00602"></a>00602         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00603"></a>00603         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00604"></a>00604 
<a name="l00605"></a>00605         LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00608"></a>00608         LASSERT(next != NULL);
<a name="l00609"></a>00609         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         <span class="keywordflow">return</span> next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a426dff3fc53f2cfed2fe22713d990ddc" title="Return key.">key</a>(env, it-&gt;lit_it);
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 
<a name="l00621"></a>00621 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_striped_it_key_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00622"></a>00622                                    <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di)
<a name="l00623"></a>00623 {
<a name="l00624"></a>00624         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>           *it = (<span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00625"></a>00625         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00626"></a>00626         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628         LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00631"></a>00631         LASSERT(next != NULL);
<a name="l00632"></a>00632         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634         <span class="keywordflow">return</span> next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a0e2180d888668bf163ebf81fd27dc857" title="Return key size.">key_size</a>(env, it-&gt;lit_it);
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 
<a name="l00644"></a>00644 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_striped_it_rec(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di,
<a name="l00645"></a>00645                               <span class="keyword">struct</span> dt_rec *rec, __u32 attr)
<a name="l00646"></a>00646 {
<a name="l00647"></a>00647         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>     *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00648"></a>00648         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00649"></a>00649         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00650"></a>00650 
<a name="l00651"></a>00651         LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00654"></a>00654         LASSERT(next != NULL);
<a name="l00655"></a>00655         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         <span class="keywordflow">return</span> next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a1b24018fcd837461771bb59a4d0c0d05" title="Return record.">rec</a>(env, it-&gt;lit_it, rec, attr);
<a name="l00658"></a>00658 }
<a name="l00659"></a>00659 
<a name="l00667"></a>00667 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_striped_it_rec_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00668"></a>00668                                    <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di, __u32 attr)
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670         <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>           *it = (<span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00671"></a>00671         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00672"></a>00672         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00675"></a>00675 
<a name="l00676"></a>00676         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00677"></a>00677         LASSERT(next != NULL);
<a name="l00678"></a>00678         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00679"></a>00679 
<a name="l00680"></a>00680         <span class="keywordflow">return</span> next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a5a85dfb5e79d606a1abba1c1fd9986cc" title="Return record size.">rec_size</a>(env, it-&gt;lit_it, attr);
<a name="l00681"></a>00681 }
<a name="l00682"></a>00682 
<a name="l00690"></a>00690 <span class="keyword">static</span> __u64 lod_striped_it_store(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00691"></a>00691                                   <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di)
<a name="l00692"></a>00692 {
<a name="l00693"></a>00693         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>     *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00694"></a>00694         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00695"></a>00695         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00696"></a>00696 
<a name="l00697"></a>00697         LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00700"></a>00700         LASSERT(next != NULL);
<a name="l00701"></a>00701         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         <span class="keywordflow">return</span> next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a2966e2ef5ccc21df92b6a31b7c4a56f5" title="Return a cookie (hash).">store</a>(env, it-&gt;lit_it);
<a name="l00704"></a>00704 }
<a name="l00705"></a>00705 
<a name="l00713"></a>00713 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_striped_it_load(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00714"></a>00714                                <span class="keyword">const</span> <span class="keyword">struct</span> dt_it *di, __u64 hash)
<a name="l00715"></a>00715 {
<a name="l00716"></a>00716         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a>     *it = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlod__it.html">lod_it</a> *)di;
<a name="l00717"></a>00717         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(it-&gt;lit_obj);
<a name="l00718"></a>00718         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720         LOD_CHECK_STRIPED_IT(env, it, lo);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722         next = lo-&gt;ldo_stripe[it-&gt;lit_stripe_index];
<a name="l00723"></a>00723         LASSERT(next != NULL);
<a name="l00724"></a>00724         LASSERT(next-&gt;do_index_ops != NULL);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         <span class="keywordflow">return</span> next-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>.<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a3ca6f6284e09ac4853574a011d4bd649" title="Initialize position using cookie/hash.">load</a>(env, it-&gt;lit_it, hash);
<a name="l00727"></a>00727 }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdt__index__operations.html" title="Per-dt-object operations on object as index.">dt_index_operations</a> lod_striped_index_ops = {
<a name="l00730"></a>00730         .<a class="code" href="structdt__index__operations.html#aab6a7632adfce2297c022b12f0d61791" title="Lookup in an index by key.">dio_lookup</a>             = lod_index_lookup,
<a name="l00731"></a>00731         .dio_declare_insert     = lod_declare_index_insert,
<a name="l00732"></a>00732         .dio_insert             = lod_index_insert,
<a name="l00733"></a>00733         .dio_declare_delete     = lod_declare_index_delete,
<a name="l00734"></a>00734         .dio_delete             = lod_index_delete,
<a name="l00735"></a>00735         .dio_it = {
<a name="l00736"></a>00736                 .init           = lod_striped_it_init,
<a name="l00737"></a>00737                 .fini           = lod_striped_it_fini,
<a name="l00738"></a>00738                 .get            = lod_striped_it_get,
<a name="l00739"></a>00739                 .put            = lod_striped_it_put,
<a name="l00740"></a>00740                 .next           = lod_striped_it_next,
<a name="l00741"></a>00741                 .key            = lod_striped_it_key,
<a name="l00742"></a>00742                 .key_size       = lod_striped_it_key_size,
<a name="l00743"></a>00743                 .rec            = lod_striped_it_rec,
<a name="l00744"></a>00744                 .rec_size       = lod_striped_it_rec_size,
<a name="l00745"></a>00745                 .store          = lod_striped_it_store,
<a name="l00746"></a>00746                 .load           = lod_striped_it_load,
<a name="l00747"></a>00747         }
<a name="l00748"></a>00748 };
<a name="l00749"></a>00749 
<a name="l00776"></a>00776 <span class="keywordtype">int</span> lod_load_lmv_shards(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlod__object.html">lod_object</a> *lo,
<a name="l00777"></a>00777                         <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf, <span class="keywordtype">bool</span> resize)
<a name="l00778"></a>00778 {
<a name="l00779"></a>00779         <span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a>        *ent    =
<a name="l00780"></a>00780                         (<span class="keyword">struct </span><a class="code" href="structlu__dirent.html" title="Layout of readdir pages, as transmitted on wire.">lu_dirent</a> *)lod_env_info(env)-&gt;lti_key;
<a name="l00781"></a>00781         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a>       *lod    = lu2lod_dev(lo-&gt;ldo_obj.do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l00782"></a>00782         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *obj    = dt_object_child(&amp;lo-&gt;ldo_obj);
<a name="l00783"></a>00783         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>    *lmv1   = buf-&gt;lb_buf;
<a name="l00784"></a>00784         <span class="keyword">struct </span>dt_it            *it;
<a name="l00785"></a>00785         <span class="keyword">const</span> <span class="keyword">struct </span>dt_it_ops  *iops;
<a name="l00786"></a>00786         __u32                    stripes;
<a name="l00787"></a>00787         __u32                    magic  = le32_to_cpu(lmv1-&gt;lmv_magic);
<a name="l00788"></a>00788         <span class="keywordtype">size_t</span>                   lmv1_size;
<a name="l00789"></a>00789         <span class="keywordtype">int</span>                      rc;
<a name="l00790"></a>00790         ENTRY;
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         <span class="comment">/* If it is not a striped directory, then load nothing. */</span>
<a name="l00793"></a>00793         <span class="keywordflow">if</span> (magic != LMV_MAGIC_V1)
<a name="l00794"></a>00794                 RETURN(0);
<a name="l00795"></a>00795 
<a name="l00796"></a>00796         <span class="comment">/* If it is in migration (or failure), then load nothing. */</span>
<a name="l00797"></a>00797         <span class="keywordflow">if</span> (le32_to_cpu(lmv1-&gt;lmv_hash_type) &amp; LMV_HASH_FLAG_MIGRATION)
<a name="l00798"></a>00798                 RETURN(0);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800         stripes = le32_to_cpu(lmv1-&gt;lmv_stripe_count);
<a name="l00801"></a>00801         <span class="keywordflow">if</span> (stripes &lt; 1)
<a name="l00802"></a>00802                 RETURN(0);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         rc = lmv_mds_md_size(stripes, magic);
<a name="l00805"></a>00805         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00806"></a>00806                 RETURN(rc);
<a name="l00807"></a>00807         lmv1_size = rc;
<a name="l00808"></a>00808         <span class="keywordflow">if</span> (buf-&gt;lb_len &lt; lmv1_size) {
<a name="l00809"></a>00809                 <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> tbuf;
<a name="l00810"></a>00810 
<a name="l00811"></a>00811                 <span class="keywordflow">if</span> (!resize)
<a name="l00812"></a>00812                         RETURN(-ERANGE);
<a name="l00813"></a>00813 
<a name="l00814"></a>00814                 tbuf = *buf;
<a name="l00815"></a>00815                 buf-&gt;lb_buf = NULL;
<a name="l00816"></a>00816                 buf-&gt;lb_len = 0;
<a name="l00817"></a>00817                 lu_buf_alloc(buf, lmv1_size);
<a name="l00818"></a>00818                 lmv1 = buf-&gt;lb_buf;
<a name="l00819"></a>00819                 <span class="keywordflow">if</span> (lmv1 == NULL)
<a name="l00820"></a>00820                         RETURN(-ENOMEM);
<a name="l00821"></a>00821 
<a name="l00822"></a>00822                 memcpy(buf-&gt;lb_buf, tbuf.lb_buf, tbuf.lb_len);
<a name="l00823"></a>00823         }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         <span class="keywordflow">if</span> (unlikely(!dt_try_as_dir(env, obj)))
<a name="l00826"></a>00826                 RETURN(-ENOTDIR);
<a name="l00827"></a>00827 
<a name="l00828"></a>00828         memset(&amp;lmv1-&gt;lmv_stripe_fids[0], 0, stripes * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>));
<a name="l00829"></a>00829         iops = &amp;obj-&gt;do_index_ops-&gt;<a class="code" href="structdt__index__operations.html#a16b19879e71b5cb1aaa459d731d580cb" title="Iterator interface.">dio_it</a>;
<a name="l00830"></a>00830         it = iops-&gt;<a class="code" href="structdt__index__operations_1_1dt__it__ops.html#a74b9db7e1791f6accf99c80a3a0c43e2" title="Allocate and initialize new iterator.">init</a>(env, obj, LUDA_64BITHASH);
<a name="l00831"></a>00831         <span class="keywordflow">if</span> (IS_ERR(it))
<a name="l00832"></a>00832                 RETURN(PTR_ERR(it));
<a name="l00833"></a>00833 
<a name="l00834"></a>00834         rc = iops-&gt;load(env, it, 0);
<a name="l00835"></a>00835         <span class="keywordflow">if</span> (rc == 0)
<a name="l00836"></a>00836                 rc = iops-&gt;next(env, it);
<a name="l00837"></a>00837         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l00838"></a>00838                 rc = 0;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840         <span class="keywordflow">while</span> (rc == 0) {
<a name="l00841"></a>00841                 <span class="keywordtype">char</span>             name[FID_LEN + 2] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00842"></a>00842                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>    fid;
<a name="l00843"></a>00843                 __u32            index;
<a name="l00844"></a>00844                 <span class="keywordtype">int</span>              len;
<a name="l00845"></a>00845 
<a name="l00846"></a>00846                 rc = iops-&gt;rec(env, it, (<span class="keyword">struct</span> dt_rec *)ent, LUDA_64BITHASH);
<a name="l00847"></a>00847                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00848"></a>00848                         <span class="keywordflow">break</span>;
<a name="l00849"></a>00849 
<a name="l00850"></a>00850                 rc = -EIO;
<a name="l00851"></a>00851 
<a name="l00852"></a>00852                 fid_le_to_cpu(&amp;fid, &amp;ent-&gt;lde_fid);
<a name="l00853"></a>00853                 ent-&gt;lde_namelen = le16_to_cpu(ent-&gt;lde_namelen);
<a name="l00854"></a>00854                 <span class="keywordflow">if</span> (ent-&gt;lde_name[0] == <span class="charliteral">&apos;.&apos;</span>) {
<a name="l00855"></a>00855                         <span class="keywordflow">if</span> (ent-&gt;lde_namelen == 1)
<a name="l00856"></a>00856                                 <span class="keywordflow">goto</span> next;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858                         <span class="keywordflow">if</span> (ent-&gt;lde_namelen == 2 &amp;&amp; ent-&gt;lde_name[1] == <span class="charliteral">&apos;.&apos;</span>)
<a name="l00859"></a>00859                                 <span class="keywordflow">goto</span> next;
<a name="l00860"></a>00860                 }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862                 len = snprintf(name, <span class="keyword">sizeof</span>(name),
<a name="l00863"></a>00863                                DFID<span class="stringliteral">&quot;:&quot;</span>, PFID(&amp;ent-&gt;lde_fid));
<a name="l00864"></a>00864                 <span class="comment">/* The ent-&gt;lde_name is composed of ${FID}:${index} */</span>
<a name="l00865"></a>00865                 <span class="keywordflow">if</span> (ent-&gt;lde_namelen &lt; len + 1 ||
<a name="l00866"></a>00866                     memcmp(ent-&gt;lde_name, name, len) != 0) {
<a name="l00867"></a>00867                         CDEBUG(lod-&gt;lod_lmv_failout ? D_ERROR : D_INFO,
<a name="l00868"></a>00868                                <span class="stringliteral">&quot;%s: invalid shard name %.*s with the FID &quot;</span>DFID
<a name="l00869"></a>00869                                <span class="stringliteral">&quot; for the striped directory &quot;</span>DFID<span class="stringliteral">&quot;, %s\n&quot;</span>,
<a name="l00870"></a>00870                                lod2obd(lod)-&gt;obd_name, ent-&gt;lde_namelen,
<a name="l00871"></a>00871                                ent-&gt;lde_name, PFID(&amp;fid),
<a name="l00872"></a>00872                                PFID(lu_object_fid(&amp;obj-&gt;do_lu)),
<a name="l00873"></a>00873                                lod-&gt;lod_lmv_failout ? <span class="stringliteral">&quot;failout&quot;</span> : <span class="stringliteral">&quot;skip&quot;</span>);
<a name="l00874"></a>00874 
<a name="l00875"></a>00875                         <span class="keywordflow">if</span> (lod-&gt;lod_lmv_failout)
<a name="l00876"></a>00876                                 <span class="keywordflow">break</span>;
<a name="l00877"></a>00877 
<a name="l00878"></a>00878                         <span class="keywordflow">goto</span> next;
<a name="l00879"></a>00879                 }
<a name="l00880"></a>00880 
<a name="l00881"></a>00881                 index = 0;
<a name="l00882"></a>00882                 <span class="keywordflow">do</span> {
<a name="l00883"></a>00883                         <span class="keywordflow">if</span> (ent-&gt;lde_name[len] &lt; <span class="charliteral">&apos;0&apos;</span> ||
<a name="l00884"></a>00884                             ent-&gt;lde_name[len] &gt; <span class="charliteral">&apos;9&apos;</span>) {
<a name="l00885"></a>00885                                 CDEBUG(lod-&gt;lod_lmv_failout ? D_ERROR : D_INFO,
<a name="l00886"></a>00886                                        <span class="stringliteral">&quot;%s: invalid shard name %.*s with the &quot;</span>
<a name="l00887"></a>00887                                        <span class="stringliteral">&quot;FID &quot;</span>DFID<span class="stringliteral">&quot; for the striped directory &quot;</span>
<a name="l00888"></a>00888                                        DFID<span class="stringliteral">&quot;, %s\n&quot;</span>,
<a name="l00889"></a>00889                                        lod2obd(lod)-&gt;obd_name, ent-&gt;lde_namelen,
<a name="l00890"></a>00890                                        ent-&gt;lde_name, PFID(&amp;fid),
<a name="l00891"></a>00891                                        PFID(lu_object_fid(&amp;obj-&gt;do_lu)),
<a name="l00892"></a>00892                                        lod-&gt;lod_lmv_failout ?
<a name="l00893"></a>00893                                        <span class="stringliteral">&quot;failout&quot;</span> : <span class="stringliteral">&quot;skip&quot;</span>);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895                                 <span class="keywordflow">if</span> (lod-&gt;lod_lmv_failout)
<a name="l00896"></a>00896                                         <span class="keywordflow">break</span>;
<a name="l00897"></a>00897 
<a name="l00898"></a>00898                                 <span class="keywordflow">goto</span> next;
<a name="l00899"></a>00899                         }
<a name="l00900"></a>00900 
<a name="l00901"></a>00901                         index = index * 10 + ent-&gt;lde_name[len++] - <span class="charliteral">&apos;0&apos;</span>;
<a name="l00902"></a>00902                 } <span class="keywordflow">while</span> (len &lt; ent-&gt;lde_namelen);
<a name="l00903"></a>00903 
<a name="l00904"></a>00904                 <span class="keywordflow">if</span> (len == ent-&gt;lde_namelen) {
<a name="l00905"></a>00905                         <span class="comment">/* Out of LMV EA range. */</span>
<a name="l00906"></a>00906                         <span class="keywordflow">if</span> (index &gt;= stripes) {
<a name="l00907"></a>00907                                 CERROR(<span class="stringliteral">&quot;%s: the shard %.*s for the striped &quot;</span>
<a name="l00908"></a>00908                                        <span class="stringliteral">&quot;directory &quot;</span>DFID<span class="stringliteral">&quot; is out of the known &quot;</span>
<a name="l00909"></a>00909                                        <span class="stringliteral">&quot;LMV EA range [0 - %u], failout\n&quot;</span>,
<a name="l00910"></a>00910                                        lod2obd(lod)-&gt;obd_name, ent-&gt;lde_namelen,
<a name="l00911"></a>00911                                        ent-&gt;lde_name,
<a name="l00912"></a>00912                                        PFID(lu_object_fid(&amp;obj-&gt;do_lu)),
<a name="l00913"></a>00913                                        stripes - 1);
<a name="l00914"></a>00914 
<a name="l00915"></a>00915                                 <span class="keywordflow">break</span>;
<a name="l00916"></a>00916                         }
<a name="l00917"></a>00917 
<a name="l00918"></a>00918                         <span class="comment">/* The slot has been occupied. */</span>
<a name="l00919"></a>00919                         <span class="keywordflow">if</span> (!fid_is_zero(&amp;lmv1-&gt;lmv_stripe_fids[index])) {
<a name="l00920"></a>00920                                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> fid0;
<a name="l00921"></a>00921 
<a name="l00922"></a>00922                                 fid_le_to_cpu(&amp;fid0,
<a name="l00923"></a>00923                                         &amp;lmv1-&gt;lmv_stripe_fids[index]);
<a name="l00924"></a>00924                                 CERROR(<span class="stringliteral">&quot;%s: both the shard &quot;</span>DFID<span class="stringliteral">&quot; and &quot;</span>DFID
<a name="l00925"></a>00925                                        <span class="stringliteral">&quot; for the striped directory &quot;</span>DFID
<a name="l00926"></a>00926                                        <span class="stringliteral">&quot; claim the same LMV EA slot at the &quot;</span>
<a name="l00927"></a>00927                                        <span class="stringliteral">&quot;index %d, failout\n&quot;</span>,
<a name="l00928"></a>00928                                        lod2obd(lod)-&gt;obd_name,
<a name="l00929"></a>00929                                        PFID(&amp;fid0), PFID(&amp;fid),
<a name="l00930"></a>00930                                        PFID(lu_object_fid(&amp;obj-&gt;do_lu)), index);
<a name="l00931"></a>00931 
<a name="l00932"></a>00932                                 <span class="keywordflow">break</span>;
<a name="l00933"></a>00933                         }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935                         <span class="comment">/* stored as LE mode */</span>
<a name="l00936"></a>00936                         lmv1-&gt;lmv_stripe_fids[index] = ent-&gt;lde_fid;
<a name="l00937"></a>00937 
<a name="l00938"></a>00938 next:
<a name="l00939"></a>00939                         rc = iops-&gt;next(env, it);
<a name="l00940"></a>00940                 }
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         iops-&gt;put(env, it);
<a name="l00944"></a>00944         iops-&gt;fini(env, it);
<a name="l00945"></a>00945 
<a name="l00946"></a>00946         RETURN(rc &gt; 0 ? lmv_mds_md_size(stripes, magic) : rc);
<a name="l00947"></a>00947 }
<a name="l00948"></a>00948 
<a name="l00954"></a>00954 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_index_try(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l00955"></a>00955                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdt__index__features.html">dt_index_features</a> *feat)
<a name="l00956"></a>00956 {
<a name="l00957"></a>00957         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l00958"></a>00958         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = dt_object_child(dt);
<a name="l00959"></a>00959         <span class="keywordtype">int</span>                     rc;
<a name="l00960"></a>00960         ENTRY;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962         LASSERT(next-&gt;do_ops);
<a name="l00963"></a>00963         LASSERT(next-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2" title="Try object as an index.">do_index_try</a>);
<a name="l00964"></a>00964 
<a name="l00965"></a>00965         rc = lod_load_striping_locked(env, lo);
<a name="l00966"></a>00966         <span class="keywordflow">if</span> (rc != 0)
<a name="l00967"></a>00967                 RETURN(rc);
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         rc = next-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2" title="Try object as an index.">do_index_try</a>(env, next, feat);
<a name="l00970"></a>00970         <span class="keywordflow">if</span> (rc != 0)
<a name="l00971"></a>00971                 RETURN(rc);
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr &gt; 0) {
<a name="l00974"></a>00974                 <span class="keywordtype">int</span> i;
<a name="l00975"></a>00975 
<a name="l00976"></a>00976                 <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l00977"></a>00977                         <span class="keywordflow">if</span> (dt_object_exists(lo-&gt;ldo_stripe[i]) == 0)
<a name="l00978"></a>00978                                 <span class="keywordflow">continue</span>;
<a name="l00979"></a>00979                         rc = lo-&gt;ldo_stripe[i]-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2" title="Try object as an index.">do_index_try</a>(env,
<a name="l00980"></a>00980                                                 lo-&gt;ldo_stripe[i], feat);
<a name="l00981"></a>00981                         <span class="keywordflow">if</span> (rc != 0)
<a name="l00982"></a>00982                                 RETURN(rc);
<a name="l00983"></a>00983                 }
<a name="l00984"></a>00984                 dt-&gt;do_index_ops = &amp;lod_striped_index_ops;
<a name="l00985"></a>00985         } <span class="keywordflow">else</span> {
<a name="l00986"></a>00986                 dt-&gt;do_index_ops = &amp;lod_index_ops;
<a name="l00987"></a>00987         }
<a name="l00988"></a>00988 
<a name="l00989"></a>00989         RETURN(rc);
<a name="l00990"></a>00990 }
<a name="l00991"></a>00991 
<a name="l00997"></a>00997 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_object_read_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00998"></a>00998                                  <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keywordtype">unsigned</span> role)
<a name="l00999"></a>00999 {
<a name="l01000"></a>01000         dt_read_lock(env, dt_object_child(dt), role);
<a name="l01001"></a>01001 }
<a name="l01002"></a>01002 
<a name="l01009"></a>01009 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_object_write_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01010"></a>01010                                   <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keywordtype">unsigned</span> role)
<a name="l01011"></a>01011 {
<a name="l01012"></a>01012         dt_write_lock(env, dt_object_child(dt), role);
<a name="l01013"></a>01013 }
<a name="l01014"></a>01014 
<a name="l01021"></a>01021 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_object_read_unlock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01022"></a>01022                                    <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt)
<a name="l01023"></a>01023 {
<a name="l01024"></a>01024         dt_read_unlock(env, dt_object_child(dt));
<a name="l01025"></a>01025 }
<a name="l01026"></a>01026 
<a name="l01033"></a>01033 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_object_write_unlock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01034"></a>01034                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt)
<a name="l01035"></a>01035 {
<a name="l01036"></a>01036         dt_write_unlock(env, dt_object_child(dt));
<a name="l01037"></a>01037 }
<a name="l01038"></a>01038 
<a name="l01045"></a>01045 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_write_locked(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01046"></a>01046                                    <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt)
<a name="l01047"></a>01047 {
<a name="l01048"></a>01048         <span class="keywordflow">return</span> dt_write_locked(env, dt_object_child(dt));
<a name="l01049"></a>01049 }
<a name="l01050"></a>01050 
<a name="l01056"></a>01056 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_attr_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01057"></a>01057                         <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01058"></a>01058                         <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr)
<a name="l01059"></a>01059 {
<a name="l01060"></a>01060         <span class="comment">/* Note: for striped directory, client will merge attributes</span>
<a name="l01061"></a>01061 <span class="comment">         * from all of the sub-stripes see lmv_merge_attr(), and there</span>
<a name="l01062"></a>01062 <span class="comment">         * no MDD logic depend on directory nlink/size/time, so we can</span>
<a name="l01063"></a>01063 <span class="comment">         * always use master inode nlink and size for now. */</span>
<a name="l01064"></a>01064         <span class="keywordflow">return</span> dt_attr_get(env, dt_object_child(dt), attr);
<a name="l01065"></a>01065 }
<a name="l01066"></a>01066 
<a name="l01075"></a>01075 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_attr_set(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01076"></a>01076                                 <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01077"></a>01077                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l01078"></a>01078                                 <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l01079"></a>01079 {
<a name="l01080"></a>01080         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>  *next = dt_object_child(dt);
<a name="l01081"></a>01081         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *lo = lod_dt_obj(dt);
<a name="l01082"></a>01082         <span class="keywordtype">int</span>                rc, i;
<a name="l01083"></a>01083         ENTRY;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085         <span class="comment">/*</span>
<a name="l01086"></a>01086 <span class="comment">         * declare setattr on the local object</span>
<a name="l01087"></a>01087 <span class="comment">         */</span>
<a name="l01088"></a>01088         rc = lod_sub_object_declare_attr_set(env, next, attr, th);
<a name="l01089"></a>01089         <span class="keywordflow">if</span> (rc)
<a name="l01090"></a>01090                 RETURN(rc);
<a name="l01091"></a>01091 
<a name="l01092"></a>01092         <span class="comment">/* osp_declare_attr_set() ignores all attributes other than</span>
<a name="l01093"></a>01093 <span class="comment">         * UID, GID, and size, and osp_attr_set() ignores all but UID</span>
<a name="l01094"></a>01094 <span class="comment">         * and GID.  Declaration of size attr setting happens through</span>
<a name="l01095"></a>01095 <span class="comment">         * lod_declare_init_size(), and not through this function.</span>
<a name="l01096"></a>01096 <span class="comment">         * Therefore we need not load striping unless ownership is</span>
<a name="l01097"></a>01097 <span class="comment">         * changing.  This should save memory and (we hope) speed up</span>
<a name="l01098"></a>01098 <span class="comment">         * rename(). */</span>
<a name="l01099"></a>01099         <span class="keywordflow">if</span> (!S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>)) {
<a name="l01100"></a>01100                 <span class="keywordflow">if</span> (!(attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; (LA_UID | LA_GID)))
<a name="l01101"></a>01101                         RETURN(rc);
<a name="l01102"></a>01102 
<a name="l01103"></a>01103                 <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_BAD_OWNER))
<a name="l01104"></a>01104                         RETURN(0);
<a name="l01105"></a>01105         } <span class="keywordflow">else</span> {
<a name="l01106"></a>01106                 <span class="keywordflow">if</span> (!(attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; (LA_UID | LA_GID | LA_MODE |
<a name="l01107"></a>01107                                         LA_ATIME | LA_MTIME | LA_CTIME |
<a name="l01108"></a>01108                                         LA_FLAGS)))
<a name="l01109"></a>01109                         RETURN(rc);
<a name="l01110"></a>01110         }
<a name="l01111"></a>01111         <span class="comment">/*</span>
<a name="l01112"></a>01112 <span class="comment">         * load striping information, notice we don&apos;t do this when object</span>
<a name="l01113"></a>01113 <span class="comment">         * is being initialized as we don&apos;t need this information till</span>
<a name="l01114"></a>01114 <span class="comment">         * few specific cases like destroy, chown</span>
<a name="l01115"></a>01115 <span class="comment">         */</span>
<a name="l01116"></a>01116         rc = lod_load_striping(env, lo);
<a name="l01117"></a>01117         <span class="keywordflow">if</span> (rc)
<a name="l01118"></a>01118                 RETURN(rc);
<a name="l01119"></a>01119 
<a name="l01120"></a>01120         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l01121"></a>01121                 RETURN(0);
<a name="l01122"></a>01122 
<a name="l01123"></a>01123         <span class="comment">/*</span>
<a name="l01124"></a>01124 <span class="comment">         * if object is striped declare changes on the stripes</span>
<a name="l01125"></a>01125 <span class="comment">         */</span>
<a name="l01126"></a>01126         LASSERT(lo-&gt;ldo_stripe);
<a name="l01127"></a>01127         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l01128"></a>01128                 <span class="keywordflow">if</span> (lo-&gt;ldo_stripe[i] == NULL)
<a name="l01129"></a>01129                         <span class="keywordflow">continue</span>;
<a name="l01130"></a>01130                 rc = lod_sub_object_declare_attr_set(env,
<a name="l01131"></a>01131                                         lo-&gt;ldo_stripe[i], attr,
<a name="l01132"></a>01132                                         th);
<a name="l01133"></a>01133                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01134"></a>01134                         RETURN(rc);
<a name="l01135"></a>01135         }
<a name="l01136"></a>01136 
<a name="l01137"></a>01137         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LOST_STRIPE) &amp;&amp;
<a name="l01138"></a>01138             dt_object_exists(next) != 0 &amp;&amp;
<a name="l01139"></a>01139             dt_object_remote(next) == 0)
<a name="l01140"></a>01140                 lod_sub_object_declare_xattr_del(env, next,
<a name="l01141"></a>01141                                                 XATTR_NAME_LOV, th);
<a name="l01142"></a>01142 
<a name="l01143"></a>01143         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_CHANGE_STRIPE) &amp;&amp;
<a name="l01144"></a>01144             dt_object_exists(next) &amp;&amp;
<a name="l01145"></a>01145             dt_object_remote(next) == 0 &amp;&amp; S_ISREG(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l01146"></a>01146                 <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a> *info = lod_env_info(env);
<a name="l01147"></a>01147                 <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf = &amp;info-&gt;lti_buf;
<a name="l01148"></a>01148 
<a name="l01149"></a>01149                 buf-&gt;lb_buf = info-&gt;lti_ea_store;
<a name="l01150"></a>01150                 buf-&gt;lb_len = info-&gt;lti_ea_store_size;
<a name="l01151"></a>01151                 lod_sub_object_declare_xattr_set(env, next, buf,
<a name="l01152"></a>01152                                                  XATTR_NAME_LOV,
<a name="l01153"></a>01153                                                  LU_XATTR_REPLACE, th);
<a name="l01154"></a>01154         }
<a name="l01155"></a>01155 
<a name="l01156"></a>01156         RETURN(rc);
<a name="l01157"></a>01157 }
<a name="l01158"></a>01158 
<a name="l01167"></a>01167 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_attr_set(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01168"></a>01168                         <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01169"></a>01169                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l01170"></a>01170                         <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l01171"></a>01171 {
<a name="l01172"></a>01172         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = dt_object_child(dt);
<a name="l01173"></a>01173         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l01174"></a>01174         <span class="keywordtype">int</span>                     rc, i;
<a name="l01175"></a>01175         ENTRY;
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         <span class="comment">/*</span>
<a name="l01178"></a>01178 <span class="comment">         * apply changes to the local object</span>
<a name="l01179"></a>01179 <span class="comment">         */</span>
<a name="l01180"></a>01180         rc = lod_sub_object_attr_set(env, next, attr, th);
<a name="l01181"></a>01181         <span class="keywordflow">if</span> (rc)
<a name="l01182"></a>01182                 RETURN(rc);
<a name="l01183"></a>01183 
<a name="l01184"></a>01184         <span class="keywordflow">if</span> (!S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>)) {
<a name="l01185"></a>01185                 <span class="keywordflow">if</span> (!(attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; (LA_UID | LA_GID)))
<a name="l01186"></a>01186                         RETURN(rc);
<a name="l01187"></a>01187 
<a name="l01188"></a>01188                 <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_BAD_OWNER))
<a name="l01189"></a>01189                         RETURN(0);
<a name="l01190"></a>01190         } <span class="keywordflow">else</span> {
<a name="l01191"></a>01191                 <span class="keywordflow">if</span> (!(attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; (LA_UID | LA_GID | LA_MODE |
<a name="l01192"></a>01192                                         LA_ATIME | LA_MTIME | LA_CTIME |
<a name="l01193"></a>01193                                         LA_FLAGS)))
<a name="l01194"></a>01194                         RETURN(rc);
<a name="l01195"></a>01195         }
<a name="l01196"></a>01196 
<a name="l01197"></a>01197         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l01198"></a>01198                 RETURN(0);
<a name="l01199"></a>01199 
<a name="l01200"></a>01200         <span class="comment">/*</span>
<a name="l01201"></a>01201 <span class="comment">         * if object is striped, apply changes to all the stripes</span>
<a name="l01202"></a>01202 <span class="comment">         */</span>
<a name="l01203"></a>01203         LASSERT(lo-&gt;ldo_stripe);
<a name="l01204"></a>01204         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l01205"></a>01205                 <span class="keywordflow">if</span> (unlikely(lo-&gt;ldo_stripe[i] == NULL))
<a name="l01206"></a>01206                         <span class="keywordflow">continue</span>;
<a name="l01207"></a>01207 
<a name="l01208"></a>01208                 <span class="keywordflow">if</span> (S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>) &amp;&amp;
<a name="l01209"></a>01209                     (dt_object_exists(lo-&gt;ldo_stripe[i]) == 0))
<a name="l01210"></a>01210                         <span class="keywordflow">continue</span>;
<a name="l01211"></a>01211 
<a name="l01212"></a>01212                 rc = lod_sub_object_attr_set(env, lo-&gt;ldo_stripe[i], attr, th);
<a name="l01213"></a>01213                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01214"></a>01214                         <span class="keywordflow">break</span>;
<a name="l01215"></a>01215         }
<a name="l01216"></a>01216 
<a name="l01217"></a>01217         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LOST_STRIPE) &amp;&amp;
<a name="l01218"></a>01218             dt_object_exists(next) != 0 &amp;&amp;
<a name="l01219"></a>01219             dt_object_remote(next) == 0)
<a name="l01220"></a>01220                 rc = lod_sub_object_xattr_del(env, next, XATTR_NAME_LOV, th);
<a name="l01221"></a>01221 
<a name="l01222"></a>01222         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_CHANGE_STRIPE) &amp;&amp;
<a name="l01223"></a>01223             dt_object_exists(next) &amp;&amp;
<a name="l01224"></a>01224             dt_object_remote(next) == 0 &amp;&amp; S_ISREG(attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a>)) {
<a name="l01225"></a>01225                 <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a> *info = lod_env_info(env);
<a name="l01226"></a>01226                 <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf = &amp;info-&gt;lti_buf;
<a name="l01227"></a>01227                 <span class="keyword">struct </span><a class="code" href="structost__id.html" title="OST object IDentifier.">ost_id</a> *oi = &amp;info-&gt;lti_ostid;
<a name="l01228"></a>01228                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid = &amp;info-&gt;lti_fid;
<a name="l01229"></a>01229                 <span class="keyword">struct </span><a class="code" href="structlov__mds__md__v1.html">lov_mds_md_v1</a> *lmm;
<a name="l01230"></a>01230                 <span class="keyword">struct </span><a class="code" href="structlov__ost__data__v1.html">lov_ost_data_v1</a> *objs;
<a name="l01231"></a>01231                 __u32 magic;
<a name="l01232"></a>01232                 <span class="keywordtype">int</span> rc1;
<a name="l01233"></a>01233 
<a name="l01234"></a>01234                 rc1 = lod_get_lov_ea(env, lo);
<a name="l01235"></a>01235                 <span class="keywordflow">if</span> (rc1  &lt;= 0)
<a name="l01236"></a>01236                         RETURN(rc);
<a name="l01237"></a>01237 
<a name="l01238"></a>01238                 buf-&gt;lb_buf = info-&gt;lti_ea_store;
<a name="l01239"></a>01239                 buf-&gt;lb_len = info-&gt;lti_ea_store_size;
<a name="l01240"></a>01240                 lmm = info-&gt;lti_ea_store;
<a name="l01241"></a>01241                 magic = le32_to_cpu(lmm-&gt;lmm_magic);
<a name="l01242"></a>01242                 <span class="keywordflow">if</span> (magic == LOV_MAGIC_V1)
<a name="l01243"></a>01243                         objs = &amp;(lmm-&gt;lmm_objects[0]);
<a name="l01244"></a>01244                 <span class="keywordflow">else</span>
<a name="l01245"></a>01245                         objs = &amp;((<span class="keyword">struct </span><a class="code" href="structlov__mds__md__v3.html">lov_mds_md_v3</a> *)lmm)-&gt;lmm_objects[0];
<a name="l01246"></a>01246                 ostid_le_to_cpu(&amp;objs-&gt;l_ost_oi, oi);
<a name="l01247"></a>01247                 ostid_to_fid(fid, oi, le32_to_cpu(objs-&gt;l_ost_idx));
<a name="l01248"></a>01248                 fid-&gt;f_oid--;
<a name="l01249"></a>01249                 fid_to_ostid(fid, oi);
<a name="l01250"></a>01250                 ostid_cpu_to_le(oi, &amp;objs-&gt;l_ost_oi);
<a name="l01251"></a>01251 
<a name="l01252"></a>01252                 rc = lod_sub_object_xattr_set(env, next, buf, XATTR_NAME_LOV,
<a name="l01253"></a>01253                                               LU_XATTR_REPLACE, th);
<a name="l01254"></a>01254         }
<a name="l01255"></a>01255 
<a name="l01256"></a>01256         RETURN(rc);
<a name="l01257"></a>01257 }
<a name="l01258"></a>01258 
<a name="l01267"></a>01267 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_xattr_get(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01268"></a>01268                          <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l01269"></a>01269 {
<a name="l01270"></a>01270         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l01271"></a>01271         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a>       *dev = lu2lod_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l01272"></a>01272         <span class="keywordtype">int</span>                      rc, is_root;
<a name="l01273"></a>01273         ENTRY;
<a name="l01274"></a>01274 
<a name="l01275"></a>01275         rc = dt_xattr_get(env, dt_object_child(dt), buf, name);
<a name="l01276"></a>01276         <span class="keywordflow">if</span> (strcmp(name, XATTR_NAME_LMV) == 0) {
<a name="l01277"></a>01277                 <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>    *lmv1;
<a name="l01278"></a>01278                 <span class="keywordtype">int</span>                      rc1 = 0;
<a name="l01279"></a>01279 
<a name="l01280"></a>01280                 <span class="keywordflow">if</span> (rc &gt; (typeof(rc))<span class="keyword">sizeof</span>(*lmv1))
<a name="l01281"></a>01281                         RETURN(rc);
<a name="l01282"></a>01282 
<a name="l01283"></a>01283                 <span class="keywordflow">if</span> (rc &lt; (typeof(rc))<span class="keyword">sizeof</span>(*lmv1))
<a name="l01284"></a>01284                         RETURN(rc = rc &gt; 0 ? -EINVAL : rc);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286                 <span class="keywordflow">if</span> (buf-&gt;lb_buf == NULL || buf-&gt;lb_len == 0) {
<a name="l01287"></a>01287                         CLASSERT(<span class="keyword">sizeof</span>(*lmv1) &lt;= <span class="keyword">sizeof</span>(info-&gt;lti_key));
<a name="l01288"></a>01288 
<a name="l01289"></a>01289                         info-&gt;lti_buf.lb_buf = info-&gt;lti_key;
<a name="l01290"></a>01290                         info-&gt;lti_buf.lb_len = <span class="keyword">sizeof</span>(*lmv1);
<a name="l01291"></a>01291                         rc = dt_xattr_get(env, dt_object_child(dt),
<a name="l01292"></a>01292                                           &amp;info-&gt;lti_buf, name);
<a name="l01293"></a>01293                         <span class="keywordflow">if</span> (unlikely(rc != <span class="keyword">sizeof</span>(*lmv1)))
<a name="l01294"></a>01294                                 RETURN(rc = rc &gt; 0 ? -EINVAL : rc);
<a name="l01295"></a>01295 
<a name="l01296"></a>01296                         lmv1 = info-&gt;lti_buf.lb_buf;
<a name="l01297"></a>01297                         <span class="comment">/* The on-disk LMV EA only contains header, but the</span>
<a name="l01298"></a>01298 <span class="comment">                         * returned LMV EA size should contain the space for</span>
<a name="l01299"></a>01299 <span class="comment">                         * the FIDs of all shards of the striped directory. */</span>
<a name="l01300"></a>01300                         <span class="keywordflow">if</span> (le32_to_cpu(lmv1-&gt;lmv_magic) == LMV_MAGIC_V1)
<a name="l01301"></a>01301                                 rc = lmv_mds_md_size(
<a name="l01302"></a>01302                                         le32_to_cpu(lmv1-&gt;lmv_stripe_count),
<a name="l01303"></a>01303                                         LMV_MAGIC_V1);
<a name="l01304"></a>01304                 } <span class="keywordflow">else</span> {
<a name="l01305"></a>01305                         rc1 = lod_load_lmv_shards(env, lod_dt_obj(dt),
<a name="l01306"></a>01306                                                   buf, <span class="keyword">false</span>);
<a name="l01307"></a>01307                 }
<a name="l01308"></a>01308 
<a name="l01309"></a>01309                 RETURN(rc = rc1 != 0 ? rc1 : rc);
<a name="l01310"></a>01310         }
<a name="l01311"></a>01311 
<a name="l01312"></a>01312         <span class="keywordflow">if</span> (rc != -ENODATA || !S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a> &amp; S_IFMT))
<a name="l01313"></a>01313                 RETURN(rc);
<a name="l01314"></a>01314 
<a name="l01315"></a>01315         <span class="comment">/*</span>
<a name="l01316"></a>01316 <span class="comment">         * lod returns default striping on the real root of the device</span>
<a name="l01317"></a>01317 <span class="comment">         * this is like the root stores default striping for the whole</span>
<a name="l01318"></a>01318 <span class="comment">         * filesystem. historically we&apos;ve been using a different approach</span>
<a name="l01319"></a>01319 <span class="comment">         * and store it in the config.</span>
<a name="l01320"></a>01320 <span class="comment">         */</span>
<a name="l01321"></a>01321         dt_root_get(env, dev-&gt;lod_child, &amp;info-&gt;lti_fid);
<a name="l01322"></a>01322         is_root = lu_fid_eq(&amp;info-&gt;lti_fid, lu_object_fid(&amp;dt-&gt;do_lu));
<a name="l01323"></a>01323 
<a name="l01324"></a>01324         <span class="keywordflow">if</span> (is_root &amp;&amp; strcmp(XATTR_NAME_LOV, name) == 0) {
<a name="l01325"></a>01325                 <span class="keyword">struct </span>lov_user_md *lum = buf-&gt;lb_buf;
<a name="l01326"></a>01326                 <span class="keyword">struct </span><a class="code" href="structlov__desc.html">lov_desc</a>    *desc = &amp;dev-&gt;lod_desc;
<a name="l01327"></a>01327 
<a name="l01328"></a>01328                 <span class="keywordflow">if</span> (buf-&gt;lb_buf == NULL) {
<a name="l01329"></a>01329                         rc = <span class="keyword">sizeof</span>(*lum);
<a name="l01330"></a>01330                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (buf-&gt;lb_len &gt;= <span class="keyword">sizeof</span>(*lum)) {
<a name="l01331"></a>01331                         lum-&gt;lmm_magic = cpu_to_le32(LOV_USER_MAGIC_V1);
<a name="l01332"></a>01332                         lmm_oi_set_seq(&amp;lum-&gt;lmm_oi, FID_SEQ_LOV_DEFAULT);
<a name="l01333"></a>01333                         lmm_oi_set_id(&amp;lum-&gt;lmm_oi, 0);
<a name="l01334"></a>01334                         lmm_oi_cpu_to_le(&amp;lum-&gt;lmm_oi, &amp;lum-&gt;lmm_oi);
<a name="l01335"></a>01335                         lum-&gt;lmm_pattern = cpu_to_le32(desc-&gt;ld_pattern);
<a name="l01336"></a>01336                         lum-&gt;lmm_stripe_size = cpu_to_le32(
<a name="l01337"></a>01337                                                 desc-&gt;ld_default_stripe_size);
<a name="l01338"></a>01338                         lum-&gt;lmm_stripe_count = cpu_to_le16(
<a name="l01339"></a>01339                                                 desc-&gt;ld_default_stripe_count);
<a name="l01340"></a>01340                         lum-&gt;lmm_stripe_offset = cpu_to_le16(
<a name="l01341"></a>01341                                                 desc-&gt;ld_default_stripe_offset);
<a name="l01342"></a>01342                         rc = <span class="keyword">sizeof</span>(*lum);
<a name="l01343"></a>01343                 } <span class="keywordflow">else</span> {
<a name="l01344"></a>01344                         rc = -ERANGE;
<a name="l01345"></a>01345                 }
<a name="l01346"></a>01346         }
<a name="l01347"></a>01347 
<a name="l01348"></a>01348         RETURN(rc);
<a name="l01349"></a>01349 }
<a name="l01350"></a>01350 
<a name="l01362"></a>01362 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_verify_md_striping(<span class="keyword">struct</span> <a class="code" href="structlod__device.html">lod_device</a> *lod,
<a name="l01363"></a>01363                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlmv__user__md__v1.html">lmv_user_md_v1</a> *lum)
<a name="l01364"></a>01364 {
<a name="l01365"></a>01365         <span class="keywordflow">if</span> (unlikely(le32_to_cpu(lum-&gt;lum_magic) != LMV_USER_MAGIC)) {
<a name="l01366"></a>01366                 CERROR(<span class="stringliteral">&quot;%s: invalid lmv_user_md: magic = %x, &quot;</span>
<a name="l01367"></a>01367                        <span class="stringliteral">&quot;stripe_offset = %d, stripe_count = %u: rc = %d\n&quot;</span>,
<a name="l01368"></a>01368                        lod2obd(lod)-&gt;obd_name, le32_to_cpu(lum-&gt;lum_magic),
<a name="l01369"></a>01369                        (<span class="keywordtype">int</span>)le32_to_cpu(lum-&gt;lum_stripe_offset),
<a name="l01370"></a>01370                        le32_to_cpu(lum-&gt;lum_stripe_count), -EINVAL);
<a name="l01371"></a>01371                 <span class="keywordflow">return</span> -EINVAL;
<a name="l01372"></a>01372         }
<a name="l01373"></a>01373 
<a name="l01374"></a>01374         <span class="keywordflow">return</span> 0;
<a name="l01375"></a>01375 }
<a name="l01376"></a>01376 
<a name="l01386"></a>01386 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_prep_slave_lmv_md(<span class="keyword">struct</span> <a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a> *slave_lmv,
<a name="l01387"></a>01387                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a> *master_lmv)
<a name="l01388"></a>01388 {
<a name="l01389"></a>01389         *slave_lmv = *master_lmv;
<a name="l01390"></a>01390         slave_lmv-&gt;lmv_magic = cpu_to_le32(LMV_MAGIC_STRIPE);
<a name="l01391"></a>01391 }
<a name="l01392"></a>01392 
<a name="l01406"></a>01406 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_prep_lmv_md(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01407"></a>01407                            <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *lmv_buf)
<a name="l01408"></a>01408 {
<a name="l01409"></a>01409         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l01410"></a>01410         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a>       *lod = lu2lod_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l01411"></a>01411         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l01412"></a>01412         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>    *lmm1;
<a name="l01413"></a>01413         <span class="keywordtype">int</span>                     stripe_count;
<a name="l01414"></a>01414         <span class="keywordtype">int</span>                     type = LU_SEQ_RANGE_ANY;
<a name="l01415"></a>01415         <span class="keywordtype">int</span>                     rc;
<a name="l01416"></a>01416         __u32                   mdtidx;
<a name="l01417"></a>01417         ENTRY;
<a name="l01418"></a>01418 
<a name="l01419"></a>01419         LASSERT(lo-&gt;ldo_dir_striped != 0);
<a name="l01420"></a>01420         LASSERT(lo-&gt;ldo_stripenr &gt; 0);
<a name="l01421"></a>01421         stripe_count = lo-&gt;ldo_stripenr;
<a name="l01422"></a>01422         <span class="comment">/* Only store the LMV EA heahder on the disk. */</span>
<a name="l01423"></a>01423         <span class="keywordflow">if</span> (info-&gt;lti_ea_store_size &lt; <span class="keyword">sizeof</span>(*lmm1)) {
<a name="l01424"></a>01424                 rc = lod_ea_store_resize(info, <span class="keyword">sizeof</span>(*lmm1));
<a name="l01425"></a>01425                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01426"></a>01426                         RETURN(rc);
<a name="l01427"></a>01427         } <span class="keywordflow">else</span> {
<a name="l01428"></a>01428                 memset(info-&gt;lti_ea_store, 0, <span class="keyword">sizeof</span>(*lmm1));
<a name="l01429"></a>01429         }
<a name="l01430"></a>01430 
<a name="l01431"></a>01431         lmm1 = (<span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a> *)info-&gt;lti_ea_store;
<a name="l01432"></a>01432         lmm1-&gt;lmv_magic = cpu_to_le32(LMV_MAGIC);
<a name="l01433"></a>01433         lmm1-&gt;lmv_stripe_count = cpu_to_le32(stripe_count);
<a name="l01434"></a>01434         lmm1-&gt;lmv_hash_type = cpu_to_le32(lo-&gt;ldo_dir_hash_type);
<a name="l01435"></a>01435         rc = lod_fld_lookup(env, lod, lu_object_fid(&amp;dt-&gt;do_lu),
<a name="l01436"></a>01436                             &amp;mdtidx, &amp;type);
<a name="l01437"></a>01437         <span class="keywordflow">if</span> (rc != 0)
<a name="l01438"></a>01438                 RETURN(rc);
<a name="l01439"></a>01439 
<a name="l01440"></a>01440         lmm1-&gt;lmv_master_mdt_index = cpu_to_le32(mdtidx);
<a name="l01441"></a>01441         lmv_buf-&gt;lb_buf = info-&gt;lti_ea_store;
<a name="l01442"></a>01442         lmv_buf-&gt;lb_len = <span class="keyword">sizeof</span>(*lmm1);
<a name="l01443"></a>01443 
<a name="l01444"></a>01444         RETURN(rc);
<a name="l01445"></a>01445 }
<a name="l01446"></a>01446 
<a name="l01462"></a>01462 <span class="keywordtype">int</span> lod_parse_dir_striping(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlod__object.html">lod_object</a> *lo,
<a name="l01463"></a>01463                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf)
<a name="l01464"></a>01464 {
<a name="l01465"></a>01465         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l01466"></a>01466         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a>       *lod = lu2lod_dev(lo-&gt;ldo_obj.do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l01467"></a>01467         <span class="keyword">struct </span><a class="code" href="structlod__tgt__descs.html">lod_tgt_descs</a>    *ltd = &amp;lod-&gt;lod_mdt_descs;
<a name="l01468"></a>01468         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        **stripe;
<a name="l01469"></a>01469         <span class="keyword">union </span><a class="code" href="unionlmv__mds__md.html">lmv_mds_md</a>        *lmm = buf-&gt;lb_buf;
<a name="l01470"></a>01470         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>    *lmv1 = &amp;lmm-&gt;lmv_md_v1;
<a name="l01471"></a>01471         <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           *fid = &amp;info-&gt;lti_fid;
<a name="l01472"></a>01472         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
<a name="l01473"></a>01473         <span class="keywordtype">int</span>                     rc = 0;
<a name="l01474"></a>01474         ENTRY;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476         <span class="keywordflow">if</span> (le32_to_cpu(lmv1-&gt;lmv_hash_type) &amp; LMV_HASH_FLAG_MIGRATION)
<a name="l01477"></a>01477                 RETURN(0);
<a name="l01478"></a>01478 
<a name="l01479"></a>01479         <span class="keywordflow">if</span> (le32_to_cpu(lmv1-&gt;lmv_magic) == LMV_MAGIC_STRIPE) {
<a name="l01480"></a>01480                 lo-&gt;ldo_dir_slave_stripe = 1;
<a name="l01481"></a>01481                 RETURN(0);
<a name="l01482"></a>01482         }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484         <span class="keywordflow">if</span> (le32_to_cpu(lmv1-&gt;lmv_magic) != LMV_MAGIC_V1)
<a name="l01485"></a>01485                 RETURN(-EINVAL);
<a name="l01486"></a>01486 
<a name="l01487"></a>01487         <span class="keywordflow">if</span> (le32_to_cpu(lmv1-&gt;lmv_stripe_count) &lt; 1)
<a name="l01488"></a>01488                 RETURN(0);
<a name="l01489"></a>01489 
<a name="l01490"></a>01490         LASSERT(lo-&gt;ldo_stripe == NULL);
<a name="l01491"></a>01491         OBD_ALLOC(stripe, <span class="keyword">sizeof</span>(stripe[0]) *
<a name="l01492"></a>01492                   (le32_to_cpu(lmv1-&gt;lmv_stripe_count)));
<a name="l01493"></a>01493         <span class="keywordflow">if</span> (stripe == NULL)
<a name="l01494"></a>01494                 RETURN(-ENOMEM);
<a name="l01495"></a>01495 
<a name="l01496"></a>01496         <span class="keywordflow">for</span> (i = 0; i &lt; le32_to_cpu(lmv1-&gt;lmv_stripe_count); i++) {
<a name="l01497"></a>01497                 <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>        *tgt_dt;
<a name="l01498"></a>01498                 <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *dto;
<a name="l01499"></a>01499                 <span class="keywordtype">int</span>                     type = LU_SEQ_RANGE_ANY;
<a name="l01500"></a>01500                 __u32                   idx;
<a name="l01501"></a>01501 
<a name="l01502"></a>01502                 fid_le_to_cpu(fid, &amp;lmv1-&gt;lmv_stripe_fids[i]);
<a name="l01503"></a>01503                 <span class="keywordflow">if</span> (!fid_is_sane(fid))
<a name="l01504"></a>01504                         GOTO(out, rc = -ESTALE);
<a name="l01505"></a>01505 
<a name="l01506"></a>01506                 rc = lod_fld_lookup(env, lod, fid, &amp;idx, &amp;type);
<a name="l01507"></a>01507                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01508"></a>01508                         GOTO(out, rc);
<a name="l01509"></a>01509 
<a name="l01510"></a>01510                 <span class="keywordflow">if</span> (idx == lod2lu_dev(lod)-&gt;ld_site-&gt;ld_seq_site-&gt;ss_node_id) {
<a name="l01511"></a>01511                         tgt_dt = lod-&gt;lod_child;
<a name="l01512"></a>01512                 } <span class="keywordflow">else</span> {
<a name="l01513"></a>01513                         <span class="keyword">struct </span><a class="code" href="structlod__tgt__desc.html">lod_tgt_desc</a>     *tgt;
<a name="l01514"></a>01514 
<a name="l01515"></a>01515                         tgt = LTD_TGT(ltd, idx);
<a name="l01516"></a>01516                         <span class="keywordflow">if</span> (tgt == NULL)
<a name="l01517"></a>01517                                 GOTO(out, rc = -ESTALE);
<a name="l01518"></a>01518                         tgt_dt = tgt-&gt;ltd_tgt;
<a name="l01519"></a>01519                 }
<a name="l01520"></a>01520 
<a name="l01521"></a>01521                 dto = dt_locate_at(env, tgt_dt, fid,
<a name="l01522"></a>01522                                   lo-&gt;ldo_obj.do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>-&gt;<a class="code" href="structlu__site.html#a371ff1de170feccd1c80e3d7a0202965" title="Top-level device for this stack.">ls_top_dev</a>,
<a name="l01523"></a>01523                                   NULL);
<a name="l01524"></a>01524                 <span class="keywordflow">if</span> (IS_ERR(dto))
<a name="l01525"></a>01525                         GOTO(out, rc = PTR_ERR(dto));
<a name="l01526"></a>01526 
<a name="l01527"></a>01527                 stripe[i] = dto;
<a name="l01528"></a>01528         }
<a name="l01529"></a>01529 out:
<a name="l01530"></a>01530         lo-&gt;ldo_stripe = stripe;
<a name="l01531"></a>01531         lo-&gt;ldo_stripenr = le32_to_cpu(lmv1-&gt;lmv_stripe_count);
<a name="l01532"></a>01532         lo-&gt;ldo_stripes_allocated = le32_to_cpu(lmv1-&gt;lmv_stripe_count);
<a name="l01533"></a>01533         <span class="keywordflow">if</span> (rc != 0)
<a name="l01534"></a>01534                 lod_object_free_striping(env, lo);
<a name="l01535"></a>01535 
<a name="l01536"></a>01536         RETURN(rc);
<a name="l01537"></a>01537 }
<a name="l01538"></a>01538 
<a name="l01558"></a>01558 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_dir_declare_create_stripes(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01559"></a>01559                                           <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01560"></a>01560                                           <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l01561"></a>01561                                           <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof,
<a name="l01562"></a>01562                                           <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l01563"></a>01563 {
<a name="l01564"></a>01564         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l01565"></a>01565         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           lmv_buf;
<a name="l01566"></a>01566         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           slave_lmv_buf;
<a name="l01567"></a>01567         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>    *lmm;
<a name="l01568"></a>01568         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>    *slave_lmm = NULL;
<a name="l01569"></a>01569         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>    *rec = &amp;info-&gt;lti_dt_rec;
<a name="l01570"></a>01570         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l01571"></a>01571         <span class="keywordtype">int</span>                     rc;
<a name="l01572"></a>01572         __u32                   i;
<a name="l01573"></a>01573         ENTRY;
<a name="l01574"></a>01574 
<a name="l01575"></a>01575         rc = lod_prep_lmv_md(env, dt, &amp;lmv_buf);
<a name="l01576"></a>01576         <span class="keywordflow">if</span> (rc != 0)
<a name="l01577"></a>01577                 GOTO(out, rc);
<a name="l01578"></a>01578         lmm = lmv_buf.lb_buf;
<a name="l01579"></a>01579 
<a name="l01580"></a>01580         OBD_ALLOC_PTR(slave_lmm);
<a name="l01581"></a>01581         <span class="keywordflow">if</span> (slave_lmm == NULL)
<a name="l01582"></a>01582                 GOTO(out, rc = -ENOMEM);
<a name="l01583"></a>01583 
<a name="l01584"></a>01584         lod_prep_slave_lmv_md(slave_lmm, lmm);
<a name="l01585"></a>01585         slave_lmv_buf.lb_buf = slave_lmm;
<a name="l01586"></a>01586         slave_lmv_buf.lb_len = <span class="keyword">sizeof</span>(*slave_lmm);
<a name="l01587"></a>01587 
<a name="l01588"></a>01588         <span class="keywordflow">if</span> (!dt_try_as_dir(env, dt_object_child(dt)))
<a name="l01589"></a>01589                 GOTO(out, rc = -EINVAL);
<a name="l01590"></a>01590 
<a name="l01591"></a>01591         rec-&gt;rec_type = S_IFDIR;
<a name="l01592"></a>01592         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l01593"></a>01593                 <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *dto = lo-&gt;ldo_stripe[i];
<a name="l01594"></a>01594                 <span class="keywordtype">char</span>                    *stripe_name = info-&gt;lti_key;
<a name="l01595"></a>01595                 <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          *sname;
<a name="l01596"></a>01596                 <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>       ldata          = { NULL };
<a name="l01597"></a>01597                 <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           linkea_buf;
<a name="l01598"></a>01598 
<a name="l01599"></a>01599                 rc = lod_sub_object_declare_create(env, dto, attr, NULL,
<a name="l01600"></a>01600                                                    dof, th);
<a name="l01601"></a>01601                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01602"></a>01602                         GOTO(out, rc);
<a name="l01603"></a>01603 
<a name="l01604"></a>01604                 <span class="keywordflow">if</span> (!dt_try_as_dir(env, dto))
<a name="l01605"></a>01605                         GOTO(out, rc = -EINVAL);
<a name="l01606"></a>01606 
<a name="l01607"></a>01607                 rc = lod_sub_object_declare_ref_add(env, dto, th);
<a name="l01608"></a>01608                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01609"></a>01609                         GOTO(out, rc);
<a name="l01610"></a>01610 
<a name="l01611"></a>01611                 rec-&gt;rec_fid = lu_object_fid(&amp;dto-&gt;do_lu);
<a name="l01612"></a>01612                 rc = lod_sub_object_declare_insert(env, dto,
<a name="l01613"></a>01613                                         (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01614"></a>01614                                         (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dot, th);
<a name="l01615"></a>01615                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01616"></a>01616                         GOTO(out, rc);
<a name="l01617"></a>01617 
<a name="l01618"></a>01618                 <span class="comment">/* master stripe FID will be put to .. */</span>
<a name="l01619"></a>01619                 rec-&gt;rec_fid = lu_object_fid(&amp;dt-&gt;do_lu);
<a name="l01620"></a>01620                 rc = lod_sub_object_declare_insert(env, dto,
<a name="l01621"></a>01621                                         (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01622"></a>01622                                         (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot,
<a name="l01623"></a>01623                                         th);
<a name="l01624"></a>01624                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01625"></a>01625                         GOTO(out, rc);
<a name="l01626"></a>01626 
<a name="l01627"></a>01627                 <span class="keywordflow">if</span> (!OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LOST_SLAVE_LMV) ||
<a name="l01628"></a>01628                     cfs_fail_val != i) {
<a name="l01629"></a>01629                         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_BAD_SLAVE_LMV) &amp;&amp;
<a name="l01630"></a>01630                             cfs_fail_val == i)
<a name="l01631"></a>01631                                 slave_lmm-&gt;lmv_master_mdt_index =
<a name="l01632"></a>01632                                                         cpu_to_le32(i + 1);
<a name="l01633"></a>01633                         <span class="keywordflow">else</span>
<a name="l01634"></a>01634                                 slave_lmm-&gt;lmv_master_mdt_index =
<a name="l01635"></a>01635                                                         cpu_to_le32(i);
<a name="l01636"></a>01636                         rc = lod_sub_object_declare_xattr_set(env, dto,
<a name="l01637"></a>01637                                         &amp;slave_lmv_buf, XATTR_NAME_LMV, 0, th);
<a name="l01638"></a>01638                         <span class="keywordflow">if</span> (rc != 0)
<a name="l01639"></a>01639                                 GOTO(out, rc);
<a name="l01640"></a>01640                 }
<a name="l01641"></a>01641 
<a name="l01642"></a>01642                 <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_BAD_SLAVE_NAME) &amp;&amp;
<a name="l01643"></a>01643                     cfs_fail_val == i)
<a name="l01644"></a>01644                         snprintf(stripe_name, <span class="keyword">sizeof</span>(info-&gt;lti_key), DFID<span class="stringliteral">&quot;:%u&quot;</span>,
<a name="l01645"></a>01645                                 PFID(lu_object_fid(&amp;dto-&gt;do_lu)), i + 1);
<a name="l01646"></a>01646                 <span class="keywordflow">else</span>
<a name="l01647"></a>01647                         snprintf(stripe_name, <span class="keyword">sizeof</span>(info-&gt;lti_key), DFID<span class="stringliteral">&quot;:%u&quot;</span>,
<a name="l01648"></a>01648                                 PFID(lu_object_fid(&amp;dto-&gt;do_lu)), i);
<a name="l01649"></a>01649 
<a name="l01650"></a>01650                 sname = lod_name_get(env, stripe_name, strlen(stripe_name));
<a name="l01651"></a>01651                 rc = linkea_data_new(&amp;ldata, &amp;info-&gt;lti_linkea_buf);
<a name="l01652"></a>01652                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01653"></a>01653                         GOTO(out, rc);
<a name="l01654"></a>01654 
<a name="l01655"></a>01655                 rc = linkea_add_buf(&amp;ldata, sname, lu_object_fid(&amp;dt-&gt;do_lu));
<a name="l01656"></a>01656                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01657"></a>01657                         GOTO(out, rc);
<a name="l01658"></a>01658 
<a name="l01659"></a>01659                 linkea_buf.lb_buf = ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf;
<a name="l01660"></a>01660                 linkea_buf.lb_len = ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len;
<a name="l01661"></a>01661                 rc = lod_sub_object_declare_xattr_set(env, dto, &amp;linkea_buf,
<a name="l01662"></a>01662                                           XATTR_NAME_LINK, 0, th);
<a name="l01663"></a>01663                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01664"></a>01664                         GOTO(out, rc);
<a name="l01665"></a>01665 
<a name="l01666"></a>01666                 rec-&gt;rec_fid = lu_object_fid(&amp;dto-&gt;do_lu);
<a name="l01667"></a>01667                 rc = lod_sub_object_declare_insert(env, dt_object_child(dt),
<a name="l01668"></a>01668                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l01669"></a>01669                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)stripe_name,
<a name="l01670"></a>01670                                        th);
<a name="l01671"></a>01671                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01672"></a>01672                         GOTO(out, rc);
<a name="l01673"></a>01673 
<a name="l01674"></a>01674                 rc = lod_sub_object_declare_ref_add(env, dt_object_child(dt),
<a name="l01675"></a>01675                                                     th);
<a name="l01676"></a>01676                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01677"></a>01677                         GOTO(out, rc);
<a name="l01678"></a>01678         }
<a name="l01679"></a>01679 
<a name="l01680"></a>01680         rc = lod_sub_object_declare_xattr_set(env, dt_object_child(dt),
<a name="l01681"></a>01681                                 &amp;lmv_buf, XATTR_NAME_LMV, 0, th);
<a name="l01682"></a>01682         <span class="keywordflow">if</span> (rc != 0)
<a name="l01683"></a>01683                 GOTO(out, rc);
<a name="l01684"></a>01684 out:
<a name="l01685"></a>01685         <span class="keywordflow">if</span> (slave_lmm != NULL)
<a name="l01686"></a>01686                 OBD_FREE_PTR(slave_lmm);
<a name="l01687"></a>01687 
<a name="l01688"></a>01688         RETURN(rc);
<a name="l01689"></a>01689 }
<a name="l01690"></a>01690 
<a name="l01691"></a>01691 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_prep_md_striped_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01692"></a>01692                                       <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01693"></a>01693                                       <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l01694"></a>01694                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlmv__user__md__v1.html">lmv_user_md_v1</a> *lum,
<a name="l01695"></a>01695                                       <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof,
<a name="l01696"></a>01696                                       <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l01697"></a>01697 {
<a name="l01698"></a>01698         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a>       *lod = lu2lod_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l01699"></a>01699         <span class="keyword">struct </span><a class="code" href="structlod__tgt__descs.html">lod_tgt_descs</a>    *ltd = &amp;lod-&gt;lod_mdt_descs;
<a name="l01700"></a>01700         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l01701"></a>01701         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        **stripe;
<a name="l01702"></a>01702         __u32                   stripe_count;
<a name="l01703"></a>01703         <span class="keywordtype">int</span>                     *idx_array;
<a name="l01704"></a>01704         __u32                   master_index;
<a name="l01705"></a>01705         <span class="keywordtype">int</span>                     rc = 0;
<a name="l01706"></a>01706         __u32                   i;
<a name="l01707"></a>01707         __u32                   j;
<a name="l01708"></a>01708         ENTRY;
<a name="l01709"></a>01709 
<a name="l01710"></a>01710         <span class="comment">/* The lum has been verifed in lod_verify_md_striping */</span>
<a name="l01711"></a>01711         LASSERT(le32_to_cpu(lum-&gt;lum_magic) == LMV_USER_MAGIC);
<a name="l01712"></a>01712         LASSERT(le32_to_cpu(lum-&gt;lum_stripe_count) &gt; 0);
<a name="l01713"></a>01713 
<a name="l01714"></a>01714         stripe_count = le32_to_cpu(lum-&gt;lum_stripe_count);
<a name="l01715"></a>01715 
<a name="l01716"></a>01716         OBD_ALLOC(idx_array, <span class="keyword">sizeof</span>(idx_array[0]) * stripe_count);
<a name="l01717"></a>01717         <span class="keywordflow">if</span> (idx_array == NULL)
<a name="l01718"></a>01718                 RETURN(-ENOMEM);
<a name="l01719"></a>01719 
<a name="l01720"></a>01720         OBD_ALLOC(stripe, <span class="keyword">sizeof</span>(stripe[0]) * stripe_count);
<a name="l01721"></a>01721         <span class="keywordflow">if</span> (stripe == NULL)
<a name="l01722"></a>01722                 GOTO(out_free, rc = -ENOMEM);
<a name="l01723"></a>01723 
<a name="l01724"></a>01724         <span class="comment">/* Start index will be the master MDT */</span>
<a name="l01725"></a>01725         master_index = lu_site2seq(lod2lu_dev(lod)-&gt;ld_site)-&gt;ss_node_id;
<a name="l01726"></a>01726         idx_array[0] = master_index;
<a name="l01727"></a>01727         <span class="keywordflow">for</span> (i = 0; i &lt; stripe_count; i++) {
<a name="l01728"></a>01728                 <span class="keyword">struct </span><a class="code" href="structlod__tgt__desc.html">lod_tgt_desc</a>     *tgt = NULL;
<a name="l01729"></a>01729                 <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *dto;
<a name="l01730"></a>01730                 <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>           fid = { 0 };
<a name="l01731"></a>01731                 <span class="keywordtype">int</span>                     idx;
<a name="l01732"></a>01732                 <span class="keyword">struct </span><a class="code" href="structlu__object__conf.html" title="Object configuration, describing particulars of object being created.">lu_object_conf</a>   conf = { 0 };
<a name="l01733"></a>01733                 <span class="keyword">struct </span><a class="code" href="structdt__device.html">dt_device</a>        *tgt_dt = NULL;
<a name="l01734"></a>01734 
<a name="l01735"></a>01735                 <span class="comment">/* Try to find next avaible target */</span>
<a name="l01736"></a>01736                 idx = idx_array[i];
<a name="l01737"></a>01737                 <span class="keywordflow">for</span> (j = 0; j &lt; lod-&gt;lod_remote_mdt_count;
<a name="l01738"></a>01738                      j++, idx = (idx + 1) % (lod-&gt;lod_remote_mdt_count + 1)) {
<a name="l01739"></a>01739                         <span class="keywordtype">bool</span> already_allocated = <span class="keyword">false</span>;
<a name="l01740"></a>01740                         __u32 k;
<a name="l01741"></a>01741 
<a name="l01742"></a>01742                         CDEBUG(D_INFO, <span class="stringliteral">&quot;try idx %d, mdt cnt %u, allocated %u\n&quot;</span>,
<a name="l01743"></a>01743                                idx, lod-&gt;lod_remote_mdt_count + 1, i);
<a name="l01744"></a>01744                         <span class="keywordflow">if</span> (idx == master_index) {
<a name="l01745"></a>01745                                 <span class="comment">/* Allocate the FID locally */</span>
<a name="l01746"></a>01746                                 rc = obd_fid_alloc(env, lod-&gt;lod_child_exp,
<a name="l01747"></a>01747                                                    &amp;fid, NULL);
<a name="l01748"></a>01748                                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01749"></a>01749                                         GOTO(out_put, rc);
<a name="l01750"></a>01750                                 tgt_dt = lod-&gt;lod_child;
<a name="l01751"></a>01751                                 <span class="keywordflow">break</span>;
<a name="l01752"></a>01752                         }
<a name="l01753"></a>01753 
<a name="l01754"></a>01754                         <span class="comment">/* Find next available target */</span>
<a name="l01755"></a>01755                         <span class="keywordflow">if</span> (!cfs_bitmap_check(ltd-&gt;ltd_tgt_bitmap, idx))
<a name="l01756"></a>01756                                 <span class="keywordflow">continue</span>;
<a name="l01757"></a>01757 
<a name="l01758"></a>01758                         <span class="keywordflow">if</span> (likely(!OBD_FAIL_CHECK(OBD_FAIL_LARGE_STRIPE))) {
<a name="l01759"></a>01759                                 <span class="comment">/* check whether the idx already exists</span>
<a name="l01760"></a>01760 <span class="comment">                                 * in current allocated array */</span>
<a name="l01761"></a>01761                                 <span class="keywordflow">for</span> (k = 0; k &lt; i; k++) {
<a name="l01762"></a>01762                                         <span class="keywordflow">if</span> (idx_array[k] == idx) {
<a name="l01763"></a>01763                                                 already_allocated = <span class="keyword">true</span>;
<a name="l01764"></a>01764                                                 <span class="keywordflow">break</span>;
<a name="l01765"></a>01765                                         }
<a name="l01766"></a>01766                                 }
<a name="l01767"></a>01767 
<a name="l01768"></a>01768                                 <span class="keywordflow">if</span> (already_allocated)
<a name="l01769"></a>01769                                         <span class="keywordflow">continue</span>;
<a name="l01770"></a>01770                         }
<a name="l01771"></a>01771 
<a name="l01772"></a>01772                         <span class="comment">/* check the status of the OSP */</span>
<a name="l01773"></a>01773                         tgt = LTD_TGT(ltd, idx);
<a name="l01774"></a>01774                         <span class="keywordflow">if</span> (tgt == NULL)
<a name="l01775"></a>01775                                 <span class="keywordflow">continue</span>;
<a name="l01776"></a>01776 
<a name="l01777"></a>01777                         tgt_dt = tgt-&gt;ltd_tgt;
<a name="l01778"></a>01778                         rc = dt_statfs(env, tgt_dt, NULL);
<a name="l01779"></a>01779                         <span class="keywordflow">if</span> (rc) {
<a name="l01780"></a>01780                                 <span class="comment">/* this OSP doesn&apos;t feel well */</span>
<a name="l01781"></a>01781                                 rc = 0;
<a name="l01782"></a>01782                                 <span class="keywordflow">continue</span>;
<a name="l01783"></a>01783                         }
<a name="l01784"></a>01784 
<a name="l01785"></a>01785                         rc = obd_fid_alloc(env, tgt-&gt;ltd_exp, &amp;fid, NULL);
<a name="l01786"></a>01786                         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01787"></a>01787                                 rc = 0;
<a name="l01788"></a>01788                                 <span class="keywordflow">continue</span>;
<a name="l01789"></a>01789                         }
<a name="l01790"></a>01790 
<a name="l01791"></a>01791                         <span class="keywordflow">break</span>;
<a name="l01792"></a>01792                 }
<a name="l01793"></a>01793 
<a name="l01794"></a>01794                 <span class="comment">/* Can not allocate more stripes */</span>
<a name="l01795"></a>01795                 <span class="keywordflow">if</span> (j == lod-&gt;lod_remote_mdt_count) {
<a name="l01796"></a>01796                         CDEBUG(D_INFO, <span class="stringliteral">&quot;%s: require stripes %u only get %d\n&quot;</span>,
<a name="l01797"></a>01797                                lod2obd(lod)-&gt;obd_name, stripe_count, i - 1);
<a name="l01798"></a>01798                         <span class="keywordflow">break</span>;
<a name="l01799"></a>01799                 }
<a name="l01800"></a>01800 
<a name="l01801"></a>01801                 CDEBUG(D_INFO, <span class="stringliteral">&quot;Get idx %d, for stripe %d &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01802"></a>01802                        idx, i, PFID(&amp;fid));
<a name="l01803"></a>01803                 idx_array[i] = idx;
<a name="l01804"></a>01804                 <span class="comment">/* Set the start index for next stripe allocation */</span>
<a name="l01805"></a>01805                 <span class="keywordflow">if</span> (i &lt; stripe_count - 1)
<a name="l01806"></a>01806                         idx_array[i + 1] = (idx + 1) %
<a name="l01807"></a>01807                                            (lod-&gt;lod_remote_mdt_count + 1);
<a name="l01808"></a>01808                 <span class="comment">/* tgt_dt and fid must be ready after search avaible OSP</span>
<a name="l01809"></a>01809 <span class="comment">                 * in the above loop */</span>
<a name="l01810"></a>01810                 LASSERT(tgt_dt != NULL);
<a name="l01811"></a>01811                 LASSERT(fid_is_sane(&amp;fid));
<a name="l01812"></a>01812                 conf.<a class="code" href="structlu__object__conf.html#ac9e27ea1ac308a8d3b2e8e9813056b93" title="Some hints for obj find and alloc.">loc_flags</a> = LOC_F_NEW;
<a name="l01813"></a>01813                 dto = dt_locate_at(env, tgt_dt, &amp;fid,
<a name="l01814"></a>01814                                    dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>-&gt;<a class="code" href="structlu__site.html#a371ff1de170feccd1c80e3d7a0202965" title="Top-level device for this stack.">ls_top_dev</a>,
<a name="l01815"></a>01815                                    &amp;conf);
<a name="l01816"></a>01816                 <span class="keywordflow">if</span> (IS_ERR(dto))
<a name="l01817"></a>01817                         GOTO(out_put, rc = PTR_ERR(dto));
<a name="l01818"></a>01818                 stripe[i] = dto;
<a name="l01819"></a>01819         }
<a name="l01820"></a>01820 
<a name="l01821"></a>01821         lo-&gt;ldo_dir_striped = 1;
<a name="l01822"></a>01822         lo-&gt;ldo_stripe = stripe;
<a name="l01823"></a>01823         lo-&gt;ldo_stripenr = i;
<a name="l01824"></a>01824         lo-&gt;ldo_stripes_allocated = stripe_count;
<a name="l01825"></a>01825 
<a name="l01826"></a>01826         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l01827"></a>01827                 GOTO(out_put, rc = -ENOSPC);
<a name="l01828"></a>01828 
<a name="l01829"></a>01829         rc = lod_dir_declare_create_stripes(env, dt, attr, dof, th);
<a name="l01830"></a>01830         <span class="keywordflow">if</span> (rc != 0)
<a name="l01831"></a>01831                 GOTO(out_put, rc);
<a name="l01832"></a>01832 
<a name="l01833"></a>01833 out_put:
<a name="l01834"></a>01834         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01835"></a>01835                 <span class="keywordflow">for</span> (i = 0; i &lt; stripe_count; i++)
<a name="l01836"></a>01836                         <span class="keywordflow">if</span> (stripe[i] != NULL)
<a name="l01837"></a>01837                                 <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, &amp;stripe[i]-&gt;do_lu);
<a name="l01838"></a>01838                 OBD_FREE(stripe, <span class="keyword">sizeof</span>(stripe[0]) * stripe_count);
<a name="l01839"></a>01839                 lo-&gt;ldo_stripenr = 0;
<a name="l01840"></a>01840                 lo-&gt;ldo_stripes_allocated = 0;
<a name="l01841"></a>01841                 lo-&gt;ldo_stripe = NULL;
<a name="l01842"></a>01842         }
<a name="l01843"></a>01843 
<a name="l01844"></a>01844 out_free:
<a name="l01845"></a>01845         OBD_FREE(idx_array, <span class="keyword">sizeof</span>(idx_array[0]) * stripe_count);
<a name="l01846"></a>01846 
<a name="l01847"></a>01847         RETURN(rc);
<a name="l01848"></a>01848 }
<a name="l01849"></a>01849 
<a name="l01869"></a>01869 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_xattr_set_lmv(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01870"></a>01870                                      <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01871"></a>01871                                      <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l01872"></a>01872                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *lum_buf,
<a name="l01873"></a>01873                                      <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof,
<a name="l01874"></a>01874                                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l01875"></a>01875 {
<a name="l01876"></a>01876         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l01877"></a>01877         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a>       *lod = lu2lod_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l01878"></a>01878         <span class="keyword">struct </span><a class="code" href="structlmv__user__md__v1.html">lmv_user_md_v1</a>   *lum;
<a name="l01879"></a>01879         <span class="keywordtype">int</span>                     rc;
<a name="l01880"></a>01880         ENTRY;
<a name="l01881"></a>01881 
<a name="l01882"></a>01882         lum = lum_buf-&gt;lb_buf;
<a name="l01883"></a>01883         LASSERT(lum != NULL);
<a name="l01884"></a>01884 
<a name="l01885"></a>01885         CDEBUG(D_INFO, <span class="stringliteral">&quot;lum magic = %x count = %u offset = %d\n&quot;</span>,
<a name="l01886"></a>01886                le32_to_cpu(lum-&gt;lum_magic), le32_to_cpu(lum-&gt;lum_stripe_count),
<a name="l01887"></a>01887                (<span class="keywordtype">int</span>)le32_to_cpu(lum-&gt;lum_stripe_offset));
<a name="l01888"></a>01888 
<a name="l01889"></a>01889         <span class="keywordflow">if</span> (le32_to_cpu(lum-&gt;lum_stripe_count) == 0)
<a name="l01890"></a>01890                 GOTO(out, rc = 0);
<a name="l01891"></a>01891 
<a name="l01892"></a>01892         rc = lod_verify_md_striping(lod, lum);
<a name="l01893"></a>01893         <span class="keywordflow">if</span> (rc != 0)
<a name="l01894"></a>01894                 GOTO(out, rc);
<a name="l01895"></a>01895 
<a name="l01896"></a>01896         <span class="comment">/* prepare dir striped objects */</span>
<a name="l01897"></a>01897         rc = lod_prep_md_striped_create(env, dt, attr, lum, dof, th);
<a name="l01898"></a>01898         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01899"></a>01899                 <span class="comment">/* failed to create striping, let&apos;s reset</span>
<a name="l01900"></a>01900 <span class="comment">                 * config so that others don&apos;t get confused */</span>
<a name="l01901"></a>01901                 lod_object_free_striping(env, lo);
<a name="l01902"></a>01902                 GOTO(out, rc);
<a name="l01903"></a>01903         }
<a name="l01904"></a>01904 out:
<a name="l01905"></a>01905         RETURN(rc);
<a name="l01906"></a>01906 }
<a name="l01907"></a>01907 
<a name="l01918"></a>01918 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_dir_declare_xattr_set(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01919"></a>01919                                      <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01920"></a>01920                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l01921"></a>01921                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> fl,
<a name="l01922"></a>01922                                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l01923"></a>01923 {
<a name="l01924"></a>01924         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = dt_object_child(dt);
<a name="l01925"></a>01925         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a>       *d = lu2lod_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l01926"></a>01926         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l01927"></a>01927         <span class="keywordtype">int</span>                     i;
<a name="l01928"></a>01928         <span class="keywordtype">int</span>                     rc;
<a name="l01929"></a>01929         ENTRY;
<a name="l01930"></a>01930 
<a name="l01931"></a>01931         <span class="keywordflow">if</span> (strcmp(name, XATTR_NAME_DEFAULT_LMV) == 0) {
<a name="l01932"></a>01932                 <span class="keyword">struct </span><a class="code" href="structlmv__user__md__v1.html">lmv_user_md_v1</a> *lum;
<a name="l01933"></a>01933 
<a name="l01934"></a>01934                 LASSERT(buf != NULL &amp;&amp; buf-&gt;lb_buf != NULL);
<a name="l01935"></a>01935                 lum = buf-&gt;lb_buf;
<a name="l01936"></a>01936                 rc = lod_verify_md_striping(d, lum);
<a name="l01937"></a>01937                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01938"></a>01938                         RETURN(rc);
<a name="l01939"></a>01939         }
<a name="l01940"></a>01940 
<a name="l01941"></a>01941         rc = lod_sub_object_declare_xattr_set(env, next, buf, name, fl, th);
<a name="l01942"></a>01942         <span class="keywordflow">if</span> (rc != 0)
<a name="l01943"></a>01943                 RETURN(rc);
<a name="l01944"></a>01944 
<a name="l01945"></a>01945         <span class="comment">/* Note: Do not set LinkEA on sub-stripes, otherwise</span>
<a name="l01946"></a>01946 <span class="comment">         * it will confuse the fid2path process(see mdt_path_current()).</span>
<a name="l01947"></a>01947 <span class="comment">         * The linkEA between master and sub-stripes is set in</span>
<a name="l01948"></a>01948 <span class="comment">         * lod_xattr_set_lmv(). */</span>
<a name="l01949"></a>01949         <span class="keywordflow">if</span> (strcmp(name, XATTR_NAME_LINK) == 0)
<a name="l01950"></a>01950                 RETURN(0);
<a name="l01951"></a>01951 
<a name="l01952"></a>01952         <span class="comment">/* set xattr to each stripes, if needed */</span>
<a name="l01953"></a>01953         rc = lod_load_striping(env, lo);
<a name="l01954"></a>01954         <span class="keywordflow">if</span> (rc != 0)
<a name="l01955"></a>01955                 RETURN(rc);
<a name="l01956"></a>01956 
<a name="l01957"></a>01957         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l01958"></a>01958                 RETURN(0);
<a name="l01959"></a>01959 
<a name="l01960"></a>01960         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l01961"></a>01961                 LASSERT(lo-&gt;ldo_stripe[i]);
<a name="l01962"></a>01962 
<a name="l01963"></a>01963                 rc = lod_sub_object_declare_xattr_set(env, lo-&gt;ldo_stripe[i],
<a name="l01964"></a>01964                                                 buf, name, fl, th);
<a name="l01965"></a>01965                 <span class="keywordflow">if</span> (rc != 0)
<a name="l01966"></a>01966                         <span class="keywordflow">break</span>;
<a name="l01967"></a>01967         }
<a name="l01968"></a>01968 
<a name="l01969"></a>01969         RETURN(rc);
<a name="l01970"></a>01970 }
<a name="l01971"></a>01971 
<a name="l01987"></a>01987 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_replace_parent_fid(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01988"></a>01988                                          <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l01989"></a>01989                                          <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th, <span class="keywordtype">bool</span> declare)
<a name="l01990"></a>01990 {
<a name="l01991"></a>01991         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *lo = lod_dt_obj(dt);
<a name="l01992"></a>01992         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l01993"></a>01993         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf = &amp;info-&gt;lti_buf;
<a name="l01994"></a>01994         <span class="keyword">struct </span><a class="code" href="structfilter__fid.html">filter_fid</a> *ff;
<a name="l01995"></a>01995         <span class="keywordtype">int</span> i, rc;
<a name="l01996"></a>01996         ENTRY;
<a name="l01997"></a>01997 
<a name="l01998"></a>01998         LASSERT(S_ISREG(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>));
<a name="l01999"></a>01999 
<a name="l02000"></a>02000         <span class="comment">/* set xattr to each stripes, if needed */</span>
<a name="l02001"></a>02001         rc = lod_load_striping(env, lo);
<a name="l02002"></a>02002         <span class="keywordflow">if</span> (rc != 0)
<a name="l02003"></a>02003                 RETURN(rc);
<a name="l02004"></a>02004 
<a name="l02005"></a>02005         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l02006"></a>02006                 RETURN(0);
<a name="l02007"></a>02007 
<a name="l02008"></a>02008         <span class="keywordflow">if</span> (info-&gt;lti_ea_store_size &lt; <span class="keyword">sizeof</span>(*ff)) {
<a name="l02009"></a>02009                 rc = lod_ea_store_resize(info, <span class="keyword">sizeof</span>(*ff));
<a name="l02010"></a>02010                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02011"></a>02011                         RETURN(rc);
<a name="l02012"></a>02012         }
<a name="l02013"></a>02013 
<a name="l02014"></a>02014         buf-&gt;lb_buf = info-&gt;lti_ea_store;
<a name="l02015"></a>02015         buf-&gt;lb_len = info-&gt;lti_ea_store_size;
<a name="l02016"></a>02016 
<a name="l02017"></a>02017         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l02018"></a>02018                 <span class="keywordflow">if</span> (lo-&gt;ldo_stripe[i] == NULL)
<a name="l02019"></a>02019                         <span class="keywordflow">continue</span>;
<a name="l02020"></a>02020 
<a name="l02021"></a>02021                 rc = dt_xattr_get(env, lo-&gt;ldo_stripe[i], buf,
<a name="l02022"></a>02022                                   XATTR_NAME_FID);
<a name="l02023"></a>02023                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02024"></a>02024                         rc = 0;
<a name="l02025"></a>02025                         <span class="keywordflow">continue</span>;
<a name="l02026"></a>02026                 }
<a name="l02027"></a>02027 
<a name="l02028"></a>02028                 ff = buf-&gt;lb_buf;
<a name="l02029"></a>02029                 fid_le_to_cpu(&amp;ff-&gt;ff_parent, &amp;ff-&gt;ff_parent);
<a name="l02030"></a>02030                 ff-&gt;ff_parent.<a class="code" href="structlu__fid.html#a05477e45a42f0e5ae1b438c2d9e6cf30" title="FID sequence.">f_seq</a> = lu_object_fid(&amp;dt-&gt;do_lu)-&gt;f_seq;
<a name="l02031"></a>02031                 ff-&gt;ff_parent.f_oid = lu_object_fid(&amp;dt-&gt;do_lu)-&gt;f_oid;
<a name="l02032"></a>02032                 fid_cpu_to_le(&amp;ff-&gt;ff_parent, &amp;ff-&gt;ff_parent);
<a name="l02033"></a>02033 
<a name="l02034"></a>02034                 <span class="keywordflow">if</span> (declare) {
<a name="l02035"></a>02035                         rc = lod_sub_object_declare_xattr_set(env,
<a name="l02036"></a>02036                                                 lo-&gt;ldo_stripe[i], buf,
<a name="l02037"></a>02037                                                 XATTR_NAME_FID,
<a name="l02038"></a>02038                                                 LU_XATTR_REPLACE, th);
<a name="l02039"></a>02039                 } <span class="keywordflow">else</span> {
<a name="l02040"></a>02040                         rc = lod_sub_object_xattr_set(env, lo-&gt;ldo_stripe[i],
<a name="l02041"></a>02041                                                       buf, XATTR_NAME_FID,
<a name="l02042"></a>02042                                                       LU_XATTR_REPLACE, th);
<a name="l02043"></a>02043                 }
<a name="l02044"></a>02044                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02045"></a>02045                         <span class="keywordflow">break</span>;
<a name="l02046"></a>02046         }
<a name="l02047"></a>02047 
<a name="l02048"></a>02048         RETURN(rc);
<a name="l02049"></a>02049 }
<a name="l02050"></a>02050 
<a name="l02061"></a>02061 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_xattr_set(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02062"></a>02062                                  <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02063"></a>02063                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l02064"></a>02064                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> fl,
<a name="l02065"></a>02065                                  <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02066"></a>02066 {
<a name="l02067"></a>02067         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *next = dt_object_child(dt);
<a name="l02068"></a>02068         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>   *attr = &amp;lod_env_info(env)-&gt;lti_attr;
<a name="l02069"></a>02069         __u32             mode;
<a name="l02070"></a>02070         <span class="keywordtype">int</span>               rc;
<a name="l02071"></a>02071         ENTRY;
<a name="l02072"></a>02072 
<a name="l02073"></a>02073         <span class="comment">/*</span>
<a name="l02074"></a>02074 <span class="comment">         * allow to declare predefined striping on a new (!mode) object</span>
<a name="l02075"></a>02075 <span class="comment">         * which is supposed to be replay of regular file creation</span>
<a name="l02076"></a>02076 <span class="comment">         * (when LOV setting is declared)</span>
<a name="l02077"></a>02077 <span class="comment">         * LU_XATTR_REPLACE is set to indicate a layout swap</span>
<a name="l02078"></a>02078 <span class="comment">         */</span>
<a name="l02079"></a>02079         mode = dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a> &amp; S_IFMT;
<a name="l02080"></a>02080         <span class="keywordflow">if</span> ((S_ISREG(mode) || mode == 0) &amp;&amp; strcmp(name, XATTR_NAME_LOV) == 0 &amp;&amp;
<a name="l02081"></a>02081              !(fl &amp; LU_XATTR_REPLACE)) {
<a name="l02082"></a>02082                 <span class="comment">/*</span>
<a name="l02083"></a>02083 <span class="comment">                 * this is a request to manipulate object&apos;s striping</span>
<a name="l02084"></a>02084 <span class="comment">                 */</span>
<a name="l02085"></a>02085                 <span class="keywordflow">if</span> (dt_object_exists(dt)) {
<a name="l02086"></a>02086                         rc = dt_attr_get(env, next, attr);
<a name="l02087"></a>02087                         <span class="keywordflow">if</span> (rc)
<a name="l02088"></a>02088                                 RETURN(rc);
<a name="l02089"></a>02089                 } <span class="keywordflow">else</span> {
<a name="l02090"></a>02090                         memset(attr, 0, <span class="keyword">sizeof</span>(*attr));
<a name="l02091"></a>02091                         attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_TYPE | LA_MODE;
<a name="l02092"></a>02092                         attr-&gt;<a class="code" href="structlu__attr.html#a25c3372427e8af220848881798990e4e" title="permission bits and file type">la_mode</a> = S_IFREG;
<a name="l02093"></a>02093                 }
<a name="l02094"></a>02094                 rc = lod_declare_striped_object(env, dt, attr, buf, th);
<a name="l02095"></a>02095         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (S_ISDIR(mode)) {
<a name="l02096"></a>02096                 rc = lod_dir_declare_xattr_set(env, dt, buf, name, fl, th);
<a name="l02097"></a>02097         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(name, XATTR_NAME_FID) == 0) {
<a name="l02098"></a>02098                 rc = lod_object_replace_parent_fid(env, dt, th, <span class="keyword">true</span>);
<a name="l02099"></a>02099         } <span class="keywordflow">else</span> {
<a name="l02100"></a>02100                 rc = lod_sub_object_declare_xattr_set(env, next, buf, name,
<a name="l02101"></a>02101                                                       fl, th);
<a name="l02102"></a>02102         }
<a name="l02103"></a>02103 
<a name="l02104"></a>02104         RETURN(rc);
<a name="l02105"></a>02105 }
<a name="l02106"></a>02106 
<a name="l02112"></a>02112 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_lov_stripe_cache_clear(<span class="keyword">struct</span> <a class="code" href="structlod__object.html">lod_object</a> *lo)
<a name="l02113"></a>02113 {
<a name="l02114"></a>02114         lo-&gt;ldo_def_striping_set = 0;
<a name="l02115"></a>02115         lo-&gt;ldo_def_striping_cached = 0;
<a name="l02116"></a>02116         lod_object_set_pool(lo, NULL);
<a name="l02117"></a>02117         lo-&gt;ldo_def_stripe_size = 0;
<a name="l02118"></a>02118         lo-&gt;ldo_def_stripenr = 0;
<a name="l02119"></a>02119         <span class="keywordflow">if</span> (lo-&gt;ldo_dir_stripe != NULL)
<a name="l02120"></a>02120                 lo-&gt;ldo_dir_def_striping_cached = 0;
<a name="l02121"></a>02121 }
<a name="l02122"></a>02122 
<a name="l02138"></a>02138 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_xattr_set_internal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02139"></a>02139                                   <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02140"></a>02140                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l02141"></a>02141                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> fl,
<a name="l02142"></a>02142                                   <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02143"></a>02143 {
<a name="l02144"></a>02144         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = dt_object_child(dt);
<a name="l02145"></a>02145         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l02146"></a>02146         <span class="keywordtype">int</span>                     rc;
<a name="l02147"></a>02147         <span class="keywordtype">int</span>                     i;
<a name="l02148"></a>02148         ENTRY;
<a name="l02149"></a>02149 
<a name="l02150"></a>02150         rc = lod_sub_object_xattr_set(env, next, buf, name, fl, th);
<a name="l02151"></a>02151         <span class="keywordflow">if</span> (rc != 0 || !S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>))
<a name="l02152"></a>02152                 RETURN(rc);
<a name="l02153"></a>02153 
<a name="l02154"></a>02154         <span class="comment">/* Note: Do not set LinkEA on sub-stripes, otherwise</span>
<a name="l02155"></a>02155 <span class="comment">         * it will confuse the fid2path process(see mdt_path_current()).</span>
<a name="l02156"></a>02156 <span class="comment">         * The linkEA between master and sub-stripes is set in</span>
<a name="l02157"></a>02157 <span class="comment">         * lod_xattr_set_lmv(). */</span>
<a name="l02158"></a>02158         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0 || strcmp(name, XATTR_NAME_LINK) == 0)
<a name="l02159"></a>02159                 RETURN(0);
<a name="l02160"></a>02160 
<a name="l02161"></a>02161         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l02162"></a>02162                 LASSERT(lo-&gt;ldo_stripe[i]);
<a name="l02163"></a>02163 
<a name="l02164"></a>02164                 rc = lod_sub_object_xattr_set(env, lo-&gt;ldo_stripe[i], buf, name,
<a name="l02165"></a>02165                                               fl, th);
<a name="l02166"></a>02166                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02167"></a>02167                         <span class="keywordflow">break</span>;
<a name="l02168"></a>02168         }
<a name="l02169"></a>02169 
<a name="l02170"></a>02170         RETURN(rc);
<a name="l02171"></a>02171 }
<a name="l02172"></a>02172 
<a name="l02186"></a>02186 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_xattr_del_internal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02187"></a>02187                                   <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02188"></a>02188                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02189"></a>02189 {
<a name="l02190"></a>02190         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = dt_object_child(dt);
<a name="l02191"></a>02191         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l02192"></a>02192         <span class="keywordtype">int</span>                     rc;
<a name="l02193"></a>02193         <span class="keywordtype">int</span>                     i;
<a name="l02194"></a>02194         ENTRY;
<a name="l02195"></a>02195 
<a name="l02196"></a>02196         rc = lod_sub_object_xattr_del(env, next, name, th);
<a name="l02197"></a>02197         <span class="keywordflow">if</span> (rc != 0 || !S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>))
<a name="l02198"></a>02198                 RETURN(rc);
<a name="l02199"></a>02199 
<a name="l02200"></a>02200         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l02201"></a>02201                 RETURN(rc);
<a name="l02202"></a>02202 
<a name="l02203"></a>02203         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l02204"></a>02204                 LASSERT(lo-&gt;ldo_stripe[i]);
<a name="l02205"></a>02205 
<a name="l02206"></a>02206                 rc = lod_sub_object_xattr_del(env, lo-&gt;ldo_stripe[i], name,
<a name="l02207"></a>02207                                               th);
<a name="l02208"></a>02208                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02209"></a>02209                         <span class="keywordflow">break</span>;
<a name="l02210"></a>02210         }
<a name="l02211"></a>02211 
<a name="l02212"></a>02212         RETURN(rc);
<a name="l02213"></a>02213 }
<a name="l02214"></a>02214 
<a name="l02233"></a>02233 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_xattr_set_lov_on_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02234"></a>02234                                     <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02235"></a>02235                                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l02236"></a>02236                                     <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> fl,
<a name="l02237"></a>02237                                     <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02238"></a>02238 {
<a name="l02239"></a>02239         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a>       *d = lu2lod_dev(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l02240"></a>02240         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *l = lod_dt_obj(dt);
<a name="l02241"></a>02241         <span class="keyword">struct </span><a class="code" href="structlov__user__md__v1.html">lov_user_md_v1</a>   *lum;
<a name="l02242"></a>02242         <span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a>   *v3 = NULL;
<a name="l02243"></a>02243         <span class="keyword">const</span> <span class="keywordtype">char</span>              *pool_name = NULL;
<a name="l02244"></a>02244         <span class="keywordtype">int</span>                      rc;
<a name="l02245"></a>02245         ENTRY;
<a name="l02246"></a>02246 
<a name="l02247"></a>02247         <span class="comment">/* If it is striped dir, we should clear the stripe cache for</span>
<a name="l02248"></a>02248 <span class="comment">         * slave stripe as well, but there are no effective way to</span>
<a name="l02249"></a>02249 <span class="comment">         * notify the LOD on the slave MDT, so we do not cache stripe</span>
<a name="l02250"></a>02250 <span class="comment">         * information for slave stripe for now. XXX*/</span>
<a name="l02251"></a>02251         lod_lov_stripe_cache_clear(l);
<a name="l02252"></a>02252         LASSERT(buf != NULL &amp;&amp; buf-&gt;lb_buf != NULL);
<a name="l02253"></a>02253         lum = buf-&gt;lb_buf;
<a name="l02254"></a>02254 
<a name="l02255"></a>02255         rc = lod_verify_striping(d, buf, <span class="keyword">false</span>);
<a name="l02256"></a>02256         <span class="keywordflow">if</span> (rc)
<a name="l02257"></a>02257                 RETURN(rc);
<a name="l02258"></a>02258 
<a name="l02259"></a>02259         <span class="keywordflow">if</span> (lum-&gt;lmm_magic == LOV_USER_MAGIC_V3) {
<a name="l02260"></a>02260                 v3 = buf-&gt;lb_buf;
<a name="l02261"></a>02261                 <span class="keywordflow">if</span> (v3-&gt;lmm_pool_name[0] != <span class="charliteral">&apos;\0&apos;</span>)
<a name="l02262"></a>02262                         pool_name = v3-&gt;lmm_pool_name;
<a name="l02263"></a>02263         }
<a name="l02264"></a>02264 
<a name="l02265"></a>02265         <span class="comment">/* if { size, offset, count } = { 0, -1, 0 } and no pool</span>
<a name="l02266"></a>02266 <span class="comment">         * (i.e. all default values specified) then delete default</span>
<a name="l02267"></a>02267 <span class="comment">         * striping from dir. */</span>
<a name="l02268"></a>02268         CDEBUG(D_OTHER,
<a name="l02269"></a>02269                 <span class="stringliteral">&quot;set default striping: sz %u # %u offset %d %s %s\n&quot;</span>,
<a name="l02270"></a>02270                 (<span class="keywordtype">unsigned</span>)lum-&gt;lmm_stripe_size,
<a name="l02271"></a>02271                 (<span class="keywordtype">unsigned</span>)lum-&gt;lmm_stripe_count,
<a name="l02272"></a>02272                 (<span class="keywordtype">int</span>)lum-&gt;lmm_stripe_offset,
<a name="l02273"></a>02273                 v3 ? <span class="stringliteral">&quot;from&quot;</span> : <span class="stringliteral">&quot;&quot;</span>, v3 ? v3-&gt;lmm_pool_name : <span class="stringliteral">&quot;&quot;</span>);
<a name="l02274"></a>02274 
<a name="l02275"></a>02275         <span class="keywordflow">if</span> (LOVEA_DELETE_VALUES(lum-&gt;lmm_stripe_size, lum-&gt;lmm_stripe_count,
<a name="l02276"></a>02276                                 lum-&gt;lmm_stripe_offset, pool_name)) {
<a name="l02277"></a>02277                 rc = lod_xattr_del_internal(env, dt, name, th);
<a name="l02278"></a>02278                 <span class="keywordflow">if</span> (rc == -ENODATA)
<a name="l02279"></a>02279                         rc = 0;
<a name="l02280"></a>02280         } <span class="keywordflow">else</span> {
<a name="l02281"></a>02281                 rc = lod_xattr_set_internal(env, dt, buf, name, fl, th);
<a name="l02282"></a>02282         }
<a name="l02283"></a>02283 
<a name="l02284"></a>02284         RETURN(rc);
<a name="l02285"></a>02285 }
<a name="l02286"></a>02286 
<a name="l02305"></a>02305 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_xattr_set_default_lmv_on_dir(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02306"></a>02306                                             <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02307"></a>02307                                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l02308"></a>02308                                             <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> fl,
<a name="l02309"></a>02309                                             <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02310"></a>02310 {
<a name="l02311"></a>02311         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *l = lod_dt_obj(dt);
<a name="l02312"></a>02312         <span class="keyword">struct </span><a class="code" href="structlmv__user__md__v1.html">lmv_user_md_v1</a>   *lum;
<a name="l02313"></a>02313         <span class="keywordtype">int</span>                      rc;
<a name="l02314"></a>02314         ENTRY;
<a name="l02315"></a>02315 
<a name="l02316"></a>02316         LASSERT(buf != NULL &amp;&amp; buf-&gt;lb_buf != NULL);
<a name="l02317"></a>02317         lum = buf-&gt;lb_buf;
<a name="l02318"></a>02318 
<a name="l02319"></a>02319         CDEBUG(D_OTHER, <span class="stringliteral">&quot;set default stripe_count # %u stripe_offset %d\n&quot;</span>,
<a name="l02320"></a>02320               le32_to_cpu(lum-&gt;lum_stripe_count),
<a name="l02321"></a>02321               (<span class="keywordtype">int</span>)le32_to_cpu(lum-&gt;lum_stripe_offset));
<a name="l02322"></a>02322 
<a name="l02323"></a>02323         <span class="keywordflow">if</span> (LMVEA_DELETE_VALUES((le32_to_cpu(lum-&gt;lum_stripe_count)),
<a name="l02324"></a>02324                                  le32_to_cpu(lum-&gt;lum_stripe_offset)) &amp;&amp;
<a name="l02325"></a>02325                                 le32_to_cpu(lum-&gt;lum_magic) == LMV_USER_MAGIC) {
<a name="l02326"></a>02326                 rc = lod_xattr_del_internal(env, dt, name, th);
<a name="l02327"></a>02327                 <span class="keywordflow">if</span> (rc == -ENODATA)
<a name="l02328"></a>02328                         rc = 0;
<a name="l02329"></a>02329         } <span class="keywordflow">else</span> {
<a name="l02330"></a>02330                 rc = lod_xattr_set_internal(env, dt, buf, name, fl, th);
<a name="l02331"></a>02331                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02332"></a>02332                         RETURN(rc);
<a name="l02333"></a>02333         }
<a name="l02334"></a>02334 
<a name="l02335"></a>02335         <span class="comment">/* Update default stripe cache */</span>
<a name="l02336"></a>02336         <span class="keywordflow">if</span> (l-&gt;ldo_dir_stripe == NULL) {
<a name="l02337"></a>02337                 OBD_ALLOC_PTR(l-&gt;ldo_dir_stripe);
<a name="l02338"></a>02338                 <span class="keywordflow">if</span> (l-&gt;ldo_dir_stripe == NULL)
<a name="l02339"></a>02339                         RETURN(-ENOMEM);
<a name="l02340"></a>02340         }
<a name="l02341"></a>02341 
<a name="l02342"></a>02342         l-&gt;ldo_dir_def_striping_cached = 0;
<a name="l02343"></a>02343         RETURN(rc);
<a name="l02344"></a>02344 }
<a name="l02345"></a>02345 
<a name="l02365"></a>02365 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_xattr_set_lmv(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02366"></a>02366                              <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l02367"></a>02367                              <span class="keywordtype">int</span> fl, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02368"></a>02368 {
<a name="l02369"></a>02369         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l02370"></a>02370         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l02371"></a>02371         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>          *attr = &amp;info-&gt;lti_attr;
<a name="l02372"></a>02372         <span class="keyword">struct </span><a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof = &amp;info-&gt;lti_format;
<a name="l02373"></a>02373         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           lmv_buf;
<a name="l02374"></a>02374         <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>           slave_lmv_buf;
<a name="l02375"></a>02375         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>    *lmm;
<a name="l02376"></a>02376         <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a>    *slave_lmm = NULL;
<a name="l02377"></a>02377         <span class="keyword">struct </span><a class="code" href="structdt__insert__rec.html">dt_insert_rec</a>    *rec = &amp;info-&gt;lti_dt_rec;
<a name="l02378"></a>02378         <span class="keywordtype">int</span>                     i;
<a name="l02379"></a>02379         <span class="keywordtype">int</span>                     rc;
<a name="l02380"></a>02380         ENTRY;
<a name="l02381"></a>02381 
<a name="l02382"></a>02382         <span class="keywordflow">if</span> (!S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>))
<a name="l02383"></a>02383                 RETURN(-ENOTDIR);
<a name="l02384"></a>02384 
<a name="l02385"></a>02385         <span class="comment">/* The stripes are supposed to be allocated in declare phase,</span>
<a name="l02386"></a>02386 <span class="comment">         * if there are no stripes being allocated, it will skip */</span>
<a name="l02387"></a>02387         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l02388"></a>02388                 RETURN(0);
<a name="l02389"></a>02389 
<a name="l02390"></a>02390         rc = dt_attr_get(env, dt_object_child(dt), attr);
<a name="l02391"></a>02391         <span class="keywordflow">if</span> (rc != 0)
<a name="l02392"></a>02392                 RETURN(rc);
<a name="l02393"></a>02393 
<a name="l02394"></a>02394         attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_ATIME | LA_MTIME | LA_CTIME |
<a name="l02395"></a>02395                          LA_MODE | LA_UID | LA_GID | LA_TYPE;
<a name="l02396"></a>02396         dof-&gt;<a class="code" href="structdt__object__format.html#a7522bce1087145d78c749b182e10357c" title="type for dt object">dof_type</a> = DFT_DIR;
<a name="l02397"></a>02397 
<a name="l02398"></a>02398         rc = lod_prep_lmv_md(env, dt, &amp;lmv_buf);
<a name="l02399"></a>02399         <span class="keywordflow">if</span> (rc != 0)
<a name="l02400"></a>02400                 RETURN(rc);
<a name="l02401"></a>02401         lmm = lmv_buf.lb_buf;
<a name="l02402"></a>02402 
<a name="l02403"></a>02403         OBD_ALLOC_PTR(slave_lmm);
<a name="l02404"></a>02404         <span class="keywordflow">if</span> (slave_lmm == NULL)
<a name="l02405"></a>02405                 RETURN(-ENOMEM);
<a name="l02406"></a>02406 
<a name="l02407"></a>02407         lod_prep_slave_lmv_md(slave_lmm, lmm);
<a name="l02408"></a>02408         slave_lmv_buf.lb_buf = slave_lmm;
<a name="l02409"></a>02409         slave_lmv_buf.lb_len = <span class="keyword">sizeof</span>(*slave_lmm);
<a name="l02410"></a>02410 
<a name="l02411"></a>02411         rec-&gt;rec_type = S_IFDIR;
<a name="l02412"></a>02412         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l02413"></a>02413                 <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *dto;
<a name="l02414"></a>02414                 <span class="keywordtype">char</span>             *stripe_name = info-&gt;lti_key;
<a name="l02415"></a>02415                 <span class="keyword">struct </span><a class="code" href="structlu__name.html" title="Common name structure to be passed around for various name related methods.">lu_name</a>          *sname;
<a name="l02416"></a>02416                 <span class="keyword">struct </span><a class="code" href="structlinkea__data.html">linkea_data</a>       ldata          = { NULL };
<a name="l02417"></a>02417                 <span class="keyword">struct </span><a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a>            linkea_buf;
<a name="l02418"></a>02418 
<a name="l02419"></a>02419                 dto = lo-&gt;ldo_stripe[i];
<a name="l02420"></a>02420 
<a name="l02421"></a>02421                 dt_write_lock(env, dto, MOR_TGT_CHILD);
<a name="l02422"></a>02422                 rc = lod_sub_object_create(env, dto, attr, NULL, dof,
<a name="l02423"></a>02423                                            th);
<a name="l02424"></a>02424                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l02425"></a>02425                         dt_write_unlock(env, dto);
<a name="l02426"></a>02426                         GOTO(out, rc);
<a name="l02427"></a>02427                 }
<a name="l02428"></a>02428 
<a name="l02429"></a>02429                 rc = lod_sub_object_ref_add(env, dto, th);
<a name="l02430"></a>02430                 dt_write_unlock(env, dto);
<a name="l02431"></a>02431                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02432"></a>02432                         GOTO(out, rc);
<a name="l02433"></a>02433 
<a name="l02434"></a>02434                 rec-&gt;rec_fid = lu_object_fid(&amp;dto-&gt;do_lu);
<a name="l02435"></a>02435                 rc = lod_sub_object_index_insert(env, dto,
<a name="l02436"></a>02436                                 (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l02437"></a>02437                                 (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dot, th, 0);
<a name="l02438"></a>02438                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02439"></a>02439                         GOTO(out, rc);
<a name="l02440"></a>02440 
<a name="l02441"></a>02441                 rec-&gt;rec_fid = lu_object_fid(&amp;dt-&gt;do_lu);
<a name="l02442"></a>02442                 rc = lod_sub_object_index_insert(env, dto, (<span class="keyword">struct</span> dt_rec *)rec,
<a name="l02443"></a>02443                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)dotdot, th, 0);
<a name="l02444"></a>02444                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02445"></a>02445                         GOTO(out, rc);
<a name="l02446"></a>02446 
<a name="l02447"></a>02447                 <span class="keywordflow">if</span> (!OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LOST_SLAVE_LMV) ||
<a name="l02448"></a>02448                     cfs_fail_val != i) {
<a name="l02449"></a>02449                         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_BAD_SLAVE_LMV) &amp;&amp;
<a name="l02450"></a>02450                             cfs_fail_val == i)
<a name="l02451"></a>02451                                 slave_lmm-&gt;lmv_master_mdt_index =
<a name="l02452"></a>02452                                                         cpu_to_le32(i + 1);
<a name="l02453"></a>02453                         <span class="keywordflow">else</span>
<a name="l02454"></a>02454                                 slave_lmm-&gt;lmv_master_mdt_index =
<a name="l02455"></a>02455                                                         cpu_to_le32(i);
<a name="l02456"></a>02456 
<a name="l02457"></a>02457                         rc = lod_sub_object_xattr_set(env, dto, &amp;slave_lmv_buf,
<a name="l02458"></a>02458                                                       XATTR_NAME_LMV, fl, th);
<a name="l02459"></a>02459                         <span class="keywordflow">if</span> (rc != 0)
<a name="l02460"></a>02460                                 GOTO(out, rc);
<a name="l02461"></a>02461                 }
<a name="l02462"></a>02462 
<a name="l02463"></a>02463                 <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_BAD_SLAVE_NAME) &amp;&amp;
<a name="l02464"></a>02464                     cfs_fail_val == i)
<a name="l02465"></a>02465                         snprintf(stripe_name, <span class="keyword">sizeof</span>(info-&gt;lti_key), DFID<span class="stringliteral">&quot;:%d&quot;</span>,
<a name="l02466"></a>02466                                  PFID(lu_object_fid(&amp;dto-&gt;do_lu)), i + 1);
<a name="l02467"></a>02467                 <span class="keywordflow">else</span>
<a name="l02468"></a>02468                         snprintf(stripe_name, <span class="keyword">sizeof</span>(info-&gt;lti_key), DFID<span class="stringliteral">&quot;:%d&quot;</span>,
<a name="l02469"></a>02469                                  PFID(lu_object_fid(&amp;dto-&gt;do_lu)), i);
<a name="l02470"></a>02470 
<a name="l02471"></a>02471                 sname = lod_name_get(env, stripe_name, strlen(stripe_name));
<a name="l02472"></a>02472                 rc = linkea_data_new(&amp;ldata, &amp;info-&gt;lti_linkea_buf);
<a name="l02473"></a>02473                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02474"></a>02474                         GOTO(out, rc);
<a name="l02475"></a>02475 
<a name="l02476"></a>02476                 rc = linkea_add_buf(&amp;ldata, sname, lu_object_fid(&amp;dt-&gt;do_lu));
<a name="l02477"></a>02477                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02478"></a>02478                         GOTO(out, rc);
<a name="l02479"></a>02479 
<a name="l02480"></a>02480                 linkea_buf.lb_buf = ldata.<a class="code" href="structlinkea__data.html#a2728af8bed33786e0b43d7df9692e396" title="Buffer to keep link EA body.">ld_buf</a>-&gt;lb_buf;
<a name="l02481"></a>02481                 linkea_buf.lb_len = ldata.<a class="code" href="structlinkea__data.html#a07164abbd7f4b6e9982e89cdf591e700" title="The matched header, entry and its lenght in the EA.">ld_leh</a>-&gt;leh_len;
<a name="l02482"></a>02482                 rc = lod_sub_object_xattr_set(env, dto, &amp;linkea_buf,
<a name="l02483"></a>02483                                         XATTR_NAME_LINK, 0, th);
<a name="l02484"></a>02484                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02485"></a>02485                         GOTO(out, rc);
<a name="l02486"></a>02486 
<a name="l02487"></a>02487                 rec-&gt;rec_fid = lu_object_fid(&amp;dto-&gt;do_lu);
<a name="l02488"></a>02488                 rc = lod_sub_object_index_insert(env, dt_object_child(dt),
<a name="l02489"></a>02489                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_rec *)rec,
<a name="l02490"></a>02490                                (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)stripe_name, th, 0);
<a name="l02491"></a>02491                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02492"></a>02492                         GOTO(out, rc);
<a name="l02493"></a>02493 
<a name="l02494"></a>02494                 rc = lod_sub_object_ref_add(env, dt_object_child(dt), th);
<a name="l02495"></a>02495                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02496"></a>02496                         GOTO(out, rc);
<a name="l02497"></a>02497         }
<a name="l02498"></a>02498 
<a name="l02499"></a>02499         <span class="keywordflow">if</span> (!OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LOST_MASTER_LMV))
<a name="l02500"></a>02500                 rc = lod_sub_object_xattr_set(env, dt_object_child(dt),
<a name="l02501"></a>02501                                               &amp;lmv_buf, XATTR_NAME_LMV, fl, th);
<a name="l02502"></a>02502 out:
<a name="l02503"></a>02503         <span class="keywordflow">if</span> (slave_lmm != NULL)
<a name="l02504"></a>02504                 OBD_FREE_PTR(slave_lmm);
<a name="l02505"></a>02505 
<a name="l02506"></a>02506         RETURN(rc);
<a name="l02507"></a>02507 }
<a name="l02508"></a>02508 
<a name="l02531"></a>02531 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_dir_striping_create_internal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02532"></a>02532                                             <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02533"></a>02533                                             <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l02534"></a>02534                                             <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof,
<a name="l02535"></a>02535                                             <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th,
<a name="l02536"></a>02536                                             <span class="keywordtype">bool</span> declare)
<a name="l02537"></a>02537 {
<a name="l02538"></a>02538         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l02539"></a>02539         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l02540"></a>02540         <span class="keywordtype">int</span>                     rc;
<a name="l02541"></a>02541         ENTRY;
<a name="l02542"></a>02542 
<a name="l02543"></a>02543         <span class="keywordflow">if</span> (!LMVEA_DELETE_VALUES(lo-&gt;ldo_stripenr,
<a name="l02544"></a>02544                                  lo-&gt;ldo_dir_stripe_offset)) {
<a name="l02545"></a>02545                 <span class="keyword">struct </span><a class="code" href="structlmv__user__md__v1.html">lmv_user_md_v1</a> *v1 = info-&gt;lti_ea_store;
<a name="l02546"></a>02546                 <span class="keywordtype">int</span> stripe_count = lo-&gt;ldo_stripenr;
<a name="l02547"></a>02547 
<a name="l02548"></a>02548                 <span class="keywordflow">if</span> (info-&gt;lti_ea_store_size &lt; <span class="keyword">sizeof</span>(*v1)) {
<a name="l02549"></a>02549                         rc = lod_ea_store_resize(info, <span class="keyword">sizeof</span>(*v1));
<a name="l02550"></a>02550                         <span class="keywordflow">if</span> (rc != 0)
<a name="l02551"></a>02551                                 RETURN(rc);
<a name="l02552"></a>02552                         v1 = info-&gt;lti_ea_store;
<a name="l02553"></a>02553                 }
<a name="l02554"></a>02554 
<a name="l02555"></a>02555                 memset(v1, 0, <span class="keyword">sizeof</span>(*v1));
<a name="l02556"></a>02556                 v1-&gt;lum_magic = cpu_to_le32(LMV_USER_MAGIC);
<a name="l02557"></a>02557                 v1-&gt;lum_stripe_count = cpu_to_le32(stripe_count);
<a name="l02558"></a>02558                 v1-&gt;lum_stripe_offset =
<a name="l02559"></a>02559                                 cpu_to_le32(lo-&gt;ldo_dir_stripe_offset);
<a name="l02560"></a>02560 
<a name="l02561"></a>02561                 info-&gt;lti_buf.lb_buf = v1;
<a name="l02562"></a>02562                 info-&gt;lti_buf.lb_len = <span class="keyword">sizeof</span>(*v1);
<a name="l02563"></a>02563 
<a name="l02564"></a>02564                 <span class="keywordflow">if</span> (declare)
<a name="l02565"></a>02565                         rc = lod_declare_xattr_set_lmv(env, dt, attr,
<a name="l02566"></a>02566                                                        &amp;info-&gt;lti_buf, dof, th);
<a name="l02567"></a>02567                 <span class="keywordflow">else</span>
<a name="l02568"></a>02568                         rc = lod_xattr_set_lmv(env, dt, &amp;info-&gt;lti_buf,
<a name="l02569"></a>02569                                                XATTR_NAME_LMV, 0, th);
<a name="l02570"></a>02570                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02571"></a>02571                         RETURN(rc);
<a name="l02572"></a>02572         }
<a name="l02573"></a>02573 
<a name="l02574"></a>02574         <span class="comment">/* Transfer default LMV striping from the parent */</span>
<a name="l02575"></a>02575         <span class="keywordflow">if</span> (lo-&gt;ldo_dir_def_striping_set &amp;&amp;
<a name="l02576"></a>02576             !LMVEA_DELETE_VALUES(lo-&gt;ldo_dir_def_stripenr,
<a name="l02577"></a>02577                                  lo-&gt;ldo_dir_def_stripe_offset)) {
<a name="l02578"></a>02578                 <span class="keyword">struct </span><a class="code" href="structlmv__user__md__v1.html">lmv_user_md_v1</a> *v1 = info-&gt;lti_ea_store;
<a name="l02579"></a>02579                 <span class="keywordtype">int</span> def_stripe_count = lo-&gt;ldo_dir_def_stripenr;
<a name="l02580"></a>02580 
<a name="l02581"></a>02581                 <span class="keywordflow">if</span> (info-&gt;lti_ea_store_size &lt; <span class="keyword">sizeof</span>(*v1)) {
<a name="l02582"></a>02582                         rc = lod_ea_store_resize(info, <span class="keyword">sizeof</span>(*v1));
<a name="l02583"></a>02583                         <span class="keywordflow">if</span> (rc != 0)
<a name="l02584"></a>02584                                 RETURN(rc);
<a name="l02585"></a>02585                         v1 = info-&gt;lti_ea_store;
<a name="l02586"></a>02586                 }
<a name="l02587"></a>02587 
<a name="l02588"></a>02588                 memset(v1, 0, <span class="keyword">sizeof</span>(*v1));
<a name="l02589"></a>02589                 v1-&gt;lum_magic = cpu_to_le32(LMV_USER_MAGIC);
<a name="l02590"></a>02590                 v1-&gt;lum_stripe_count = cpu_to_le32(def_stripe_count);
<a name="l02591"></a>02591                 v1-&gt;lum_stripe_offset =
<a name="l02592"></a>02592                                 cpu_to_le32(lo-&gt;ldo_dir_def_stripe_offset);
<a name="l02593"></a>02593                 v1-&gt;lum_hash_type =
<a name="l02594"></a>02594                                 cpu_to_le32(lo-&gt;ldo_dir_def_hash_type);
<a name="l02595"></a>02595 
<a name="l02596"></a>02596                 info-&gt;lti_buf.lb_buf = v1;
<a name="l02597"></a>02597                 info-&gt;lti_buf.lb_len = <span class="keyword">sizeof</span>(*v1);
<a name="l02598"></a>02598                 <span class="keywordflow">if</span> (declare)
<a name="l02599"></a>02599                         rc = lod_dir_declare_xattr_set(env, dt, &amp;info-&gt;lti_buf,
<a name="l02600"></a>02600                                                        XATTR_NAME_DEFAULT_LMV,
<a name="l02601"></a>02601                                                        0, th);
<a name="l02602"></a>02602                 <span class="keywordflow">else</span>
<a name="l02603"></a>02603                         rc = lod_xattr_set_default_lmv_on_dir(env, dt,
<a name="l02604"></a>02604                                                   &amp;info-&gt;lti_buf,
<a name="l02605"></a>02605                                                   XATTR_NAME_DEFAULT_LMV, 0,
<a name="l02606"></a>02606                                                   th);
<a name="l02607"></a>02607                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02608"></a>02608                         RETURN(rc);
<a name="l02609"></a>02609         }
<a name="l02610"></a>02610 
<a name="l02611"></a>02611         <span class="comment">/* Transfer default LOV striping from the parent */</span>
<a name="l02612"></a>02612         <span class="keywordflow">if</span> (lo-&gt;ldo_def_striping_set &amp;&amp;
<a name="l02613"></a>02613             !LOVEA_DELETE_VALUES(lo-&gt;ldo_def_stripe_size,
<a name="l02614"></a>02614                                  lo-&gt;ldo_def_stripenr,
<a name="l02615"></a>02615                                  lo-&gt;ldo_def_stripe_offset,
<a name="l02616"></a>02616                                  lo-&gt;ldo_pool)) {
<a name="l02617"></a>02617                 <span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a> *v3 = info-&gt;lti_ea_store;
<a name="l02618"></a>02618 
<a name="l02619"></a>02619                 <span class="keywordflow">if</span> (info-&gt;lti_ea_store_size &lt; <span class="keyword">sizeof</span>(*v3)) {
<a name="l02620"></a>02620                         rc = lod_ea_store_resize(info, <span class="keyword">sizeof</span>(*v3));
<a name="l02621"></a>02621                         <span class="keywordflow">if</span> (rc != 0)
<a name="l02622"></a>02622                                 RETURN(rc);
<a name="l02623"></a>02623                         v3 = info-&gt;lti_ea_store;
<a name="l02624"></a>02624                 }
<a name="l02625"></a>02625 
<a name="l02626"></a>02626                 memset(v3, 0, <span class="keyword">sizeof</span>(*v3));
<a name="l02627"></a>02627                 v3-&gt;lmm_magic = cpu_to_le32(LOV_USER_MAGIC_V3);
<a name="l02628"></a>02628                 v3-&gt;lmm_stripe_count = cpu_to_le16(lo-&gt;ldo_def_stripenr);
<a name="l02629"></a>02629                 v3-&gt;lmm_stripe_offset = cpu_to_le16(lo-&gt;ldo_def_stripe_offset);
<a name="l02630"></a>02630                 v3-&gt;lmm_stripe_size = cpu_to_le32(lo-&gt;ldo_def_stripe_size);
<a name="l02631"></a>02631                 <span class="keywordflow">if</span> (lo-&gt;ldo_pool != NULL)
<a name="l02632"></a>02632                         strlcpy(v3-&gt;lmm_pool_name, lo-&gt;ldo_pool,
<a name="l02633"></a>02633                                 <span class="keyword">sizeof</span>(v3-&gt;lmm_pool_name));
<a name="l02634"></a>02634 
<a name="l02635"></a>02635                 info-&gt;lti_buf.lb_buf = v3;
<a name="l02636"></a>02636                 info-&gt;lti_buf.lb_len = <span class="keyword">sizeof</span>(*v3);
<a name="l02637"></a>02637 
<a name="l02638"></a>02638                 <span class="keywordflow">if</span> (declare)
<a name="l02639"></a>02639                         rc = lod_dir_declare_xattr_set(env, dt, &amp;info-&gt;lti_buf,
<a name="l02640"></a>02640                                                        XATTR_NAME_LOV, 0, th);
<a name="l02641"></a>02641                 <span class="keywordflow">else</span>
<a name="l02642"></a>02642                         rc = lod_xattr_set_lov_on_dir(env, dt, &amp;info-&gt;lti_buf,
<a name="l02643"></a>02643                                                       XATTR_NAME_LOV, 0, th);
<a name="l02644"></a>02644                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02645"></a>02645                         RETURN(rc);
<a name="l02646"></a>02646         }
<a name="l02647"></a>02647 
<a name="l02648"></a>02648         RETURN(0);
<a name="l02649"></a>02649 }
<a name="l02650"></a>02650 
<a name="l02651"></a>02651 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_dir_striping_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02652"></a>02652                                            <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02653"></a>02653                                            <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l02654"></a>02654                                            <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof,
<a name="l02655"></a>02655                                            <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02656"></a>02656 {
<a name="l02657"></a>02657         <span class="keywordflow">return</span> lod_dir_striping_create_internal(env, dt, attr, dof, th, <span class="keyword">true</span>);
<a name="l02658"></a>02658 }
<a name="l02659"></a>02659 
<a name="l02660"></a>02660 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_dir_striping_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02661"></a>02661                                    <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02662"></a>02662                                    <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l02663"></a>02663                                    <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof,
<a name="l02664"></a>02664                                    <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02665"></a>02665 {
<a name="l02666"></a>02666         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *lo = lod_dt_obj(dt);
<a name="l02667"></a>02667         <span class="keywordtype">int</span> rc;
<a name="l02668"></a>02668 
<a name="l02669"></a>02669         rc = lod_dir_striping_create_internal(env, dt, attr, dof, th, <span class="keyword">false</span>);
<a name="l02670"></a>02670         <span class="keywordflow">if</span> (rc == 0)
<a name="l02671"></a>02671                 lo-&gt;ldo_striping_cached = 1;
<a name="l02672"></a>02672 
<a name="l02673"></a>02673         <span class="keywordflow">return</span> rc;
<a name="l02674"></a>02674 }
<a name="l02675"></a>02675 
<a name="l02694"></a>02694 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_xattr_set(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02695"></a>02695                          <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf,
<a name="l02696"></a>02696                          <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> fl, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02697"></a>02697 {
<a name="l02698"></a>02698         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = dt_object_child(dt);
<a name="l02699"></a>02699         <span class="keywordtype">int</span>                      rc;
<a name="l02700"></a>02700         ENTRY;
<a name="l02701"></a>02701 
<a name="l02702"></a>02702         <span class="keywordflow">if</span> (S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>) &amp;&amp;
<a name="l02703"></a>02703             strcmp(name, XATTR_NAME_LMV) == 0) {
<a name="l02704"></a>02704                 <span class="keyword">struct </span><a class="code" href="structlmv__mds__md__v1.html">lmv_mds_md_v1</a> *lmm = buf-&gt;lb_buf;
<a name="l02705"></a>02705 
<a name="l02706"></a>02706                 <span class="keywordflow">if</span> (lmm != NULL &amp;&amp; le32_to_cpu(lmm-&gt;lmv_hash_type) &amp;
<a name="l02707"></a>02707                                                 LMV_HASH_FLAG_MIGRATION)
<a name="l02708"></a>02708                         rc = lod_sub_object_xattr_set(env, next, buf, name, fl,
<a name="l02709"></a>02709                                                       th);
<a name="l02710"></a>02710                 <span class="keywordflow">else</span>
<a name="l02711"></a>02711                         rc = lod_dir_striping_create(env, dt, NULL, NULL, th);
<a name="l02712"></a>02712 
<a name="l02713"></a>02713                 RETURN(rc);
<a name="l02714"></a>02714         }
<a name="l02715"></a>02715 
<a name="l02716"></a>02716         <span class="keywordflow">if</span> (S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>) &amp;&amp;
<a name="l02717"></a>02717             strcmp(name, XATTR_NAME_LOV) == 0) {
<a name="l02718"></a>02718                 <span class="comment">/* default LOVEA */</span>
<a name="l02719"></a>02719                 rc = lod_xattr_set_lov_on_dir(env, dt, buf, name, fl, th);
<a name="l02720"></a>02720                 RETURN(rc);
<a name="l02721"></a>02721         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>) &amp;&amp;
<a name="l02722"></a>02722                    strcmp(name, XATTR_NAME_DEFAULT_LMV) == 0) {
<a name="l02723"></a>02723                 <span class="comment">/* default LMVEA */</span>
<a name="l02724"></a>02724                 rc = lod_xattr_set_default_lmv_on_dir(env, dt, buf, name, fl,
<a name="l02725"></a>02725                                                       th);
<a name="l02726"></a>02726                 RETURN(rc);
<a name="l02727"></a>02727         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (S_ISREG(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>) &amp;&amp;
<a name="l02728"></a>02728                    !strcmp(name, XATTR_NAME_LOV)) {
<a name="l02729"></a>02729                 <span class="comment">/* in case of lov EA swap, just set it</span>
<a name="l02730"></a>02730 <span class="comment">                 * if not, it is a replay so check striping match what we</span>
<a name="l02731"></a>02731 <span class="comment">                 * already have during req replay, declare_xattr_set()</span>
<a name="l02732"></a>02732 <span class="comment">                 * defines striping, then create() does the work */</span>
<a name="l02733"></a>02733                 <span class="keywordflow">if</span> (fl &amp; LU_XATTR_REPLACE) {
<a name="l02734"></a>02734                         <span class="comment">/* free stripes, then update disk */</span>
<a name="l02735"></a>02735                         lod_object_free_striping(env, lod_dt_obj(dt));
<a name="l02736"></a>02736 
<a name="l02737"></a>02737                         rc = lod_sub_object_xattr_set(env, next, buf, name,
<a name="l02738"></a>02738                                                       fl, th);
<a name="l02739"></a>02739                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dt_object_remote(dt)) {
<a name="l02740"></a>02740                         <span class="comment">/* This only happens during migration, see</span>
<a name="l02741"></a>02741 <span class="comment">                         * mdd_migrate_create(), in which Master MDT will</span>
<a name="l02742"></a>02742 <span class="comment">                         * create a remote target object, and only set</span>
<a name="l02743"></a>02743 <span class="comment">                         * (migrating) stripe EA on the remote object,</span>
<a name="l02744"></a>02744 <span class="comment">                         * and does not need creating each stripes. */</span>
<a name="l02745"></a>02745                         rc = lod_sub_object_xattr_set(env, next, buf, name,
<a name="l02746"></a>02746                                                       fl, th);
<a name="l02747"></a>02747                 } <span class="keywordflow">else</span> {
<a name="l02748"></a>02748                         rc = lod_striping_create(env, dt, NULL, NULL, th);
<a name="l02749"></a>02749                 }
<a name="l02750"></a>02750                 RETURN(rc);
<a name="l02751"></a>02751         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(name, XATTR_NAME_FID) == 0) {
<a name="l02752"></a>02752                 rc = lod_object_replace_parent_fid(env, dt, th, <span class="keyword">false</span>);
<a name="l02753"></a>02753 
<a name="l02754"></a>02754                 RETURN(rc);
<a name="l02755"></a>02755         }
<a name="l02756"></a>02756 
<a name="l02757"></a>02757         <span class="comment">/* then all other xattr */</span>
<a name="l02758"></a>02758         rc = lod_xattr_set_internal(env, dt, buf, name, fl, th);
<a name="l02759"></a>02759 
<a name="l02760"></a>02760         RETURN(rc);
<a name="l02761"></a>02761 }
<a name="l02762"></a>02762 
<a name="l02769"></a>02769 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_xattr_del(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02770"></a>02770                                  <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l02771"></a>02771                                  <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02772"></a>02772 {
<a name="l02773"></a>02773         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l02774"></a>02774         <span class="keywordtype">int</span>                     rc;
<a name="l02775"></a>02775         <span class="keywordtype">int</span>                     i;
<a name="l02776"></a>02776         ENTRY;
<a name="l02777"></a>02777 
<a name="l02778"></a>02778         rc = lod_sub_object_declare_xattr_del(env, dt_object_child(dt),
<a name="l02779"></a>02779                                               name, th);
<a name="l02780"></a>02780         <span class="keywordflow">if</span> (rc != 0)
<a name="l02781"></a>02781                 RETURN(rc);
<a name="l02782"></a>02782 
<a name="l02783"></a>02783         <span class="keywordflow">if</span> (!S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>))
<a name="l02784"></a>02784                 RETURN(0);
<a name="l02785"></a>02785 
<a name="l02786"></a>02786         <span class="comment">/* set xattr to each stripes, if needed */</span>
<a name="l02787"></a>02787         rc = lod_load_striping(env, lo);
<a name="l02788"></a>02788         <span class="keywordflow">if</span> (rc != 0)
<a name="l02789"></a>02789                 RETURN(rc);
<a name="l02790"></a>02790 
<a name="l02791"></a>02791         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l02792"></a>02792                 RETURN(0);
<a name="l02793"></a>02793 
<a name="l02794"></a>02794         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l02795"></a>02795                 LASSERT(lo-&gt;ldo_stripe[i]);
<a name="l02796"></a>02796                 rc = lod_sub_object_declare_xattr_del(env, lo-&gt;ldo_stripe[i],
<a name="l02797"></a>02797                                                       name, th);
<a name="l02798"></a>02798                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02799"></a>02799                         <span class="keywordflow">break</span>;
<a name="l02800"></a>02800         }
<a name="l02801"></a>02801 
<a name="l02802"></a>02802         RETURN(rc);
<a name="l02803"></a>02803 }
<a name="l02804"></a>02804 
<a name="l02813"></a>02813 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_xattr_del(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l02814"></a>02814                          <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l02815"></a>02815 {
<a name="l02816"></a>02816         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = dt_object_child(dt);
<a name="l02817"></a>02817         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l02818"></a>02818         <span class="keywordtype">int</span>                     rc;
<a name="l02819"></a>02819         <span class="keywordtype">int</span>                     i;
<a name="l02820"></a>02820         ENTRY;
<a name="l02821"></a>02821 
<a name="l02822"></a>02822         <span class="keywordflow">if</span> (!strcmp(name, XATTR_NAME_LOV))
<a name="l02823"></a>02823                 lod_object_free_striping(env, lod_dt_obj(dt));
<a name="l02824"></a>02824 
<a name="l02825"></a>02825         rc = lod_sub_object_xattr_del(env, next, name, th);
<a name="l02826"></a>02826         <span class="keywordflow">if</span> (rc != 0 || !S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>))
<a name="l02827"></a>02827                 RETURN(rc);
<a name="l02828"></a>02828 
<a name="l02829"></a>02829         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l02830"></a>02830                 RETURN(0);
<a name="l02831"></a>02831 
<a name="l02832"></a>02832         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l02833"></a>02833                 LASSERT(lo-&gt;ldo_stripe[i]);
<a name="l02834"></a>02834 
<a name="l02835"></a>02835                 rc = lod_sub_object_xattr_del(env, lo-&gt;ldo_stripe[i], name, th);
<a name="l02836"></a>02836                 <span class="keywordflow">if</span> (rc != 0)
<a name="l02837"></a>02837                         <span class="keywordflow">break</span>;
<a name="l02838"></a>02838         }
<a name="l02839"></a>02839 
<a name="l02840"></a>02840         RETURN(rc);
<a name="l02841"></a>02841 }
<a name="l02842"></a>02842 
<a name="l02849"></a>02849 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_xattr_list(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02850"></a>02850                           <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf)
<a name="l02851"></a>02851 {
<a name="l02852"></a>02852         <span class="keywordflow">return</span> dt_xattr_list(env, dt_object_child(dt), buf);
<a name="l02853"></a>02853 }
<a name="l02854"></a>02854 
<a name="l02868"></a>02868 <span class="keywordtype">int</span> lod_object_set_pool(<span class="keyword">struct</span> <a class="code" href="structlod__object.html">lod_object</a> *o, <span class="keywordtype">char</span> *pool)
<a name="l02869"></a>02869 {
<a name="l02870"></a>02870         <span class="keywordtype">int</span> len;
<a name="l02871"></a>02871 
<a name="l02872"></a>02872         <span class="keywordflow">if</span> (o-&gt;ldo_pool) {
<a name="l02873"></a>02873                 len = strlen(o-&gt;ldo_pool);
<a name="l02874"></a>02874                 OBD_FREE(o-&gt;ldo_pool, len + 1);
<a name="l02875"></a>02875                 o-&gt;ldo_pool = NULL;
<a name="l02876"></a>02876         }
<a name="l02877"></a>02877         <span class="keywordflow">if</span> (pool) {
<a name="l02878"></a>02878                 len = strlen(pool);
<a name="l02879"></a>02879                 OBD_ALLOC(o-&gt;ldo_pool, len + 1);
<a name="l02880"></a>02880                 <span class="keywordflow">if</span> (o-&gt;ldo_pool == NULL)
<a name="l02881"></a>02881                         <span class="keywordflow">return</span> -ENOMEM;
<a name="l02882"></a>02882                 strcpy(o-&gt;ldo_pool, pool);
<a name="l02883"></a>02883         }
<a name="l02884"></a>02884         <span class="keywordflow">return</span> 0;
<a name="l02885"></a>02885 }
<a name="l02886"></a>02886 
<a name="l02887"></a>02887 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> lod_object_will_be_striped(<span class="keywordtype">int</span> is_reg, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a> *fid)
<a name="l02888"></a>02888 {
<a name="l02889"></a>02889         <span class="keywordflow">return</span> (is_reg &amp;&amp; <a class="code" href="group__lu__fid.html#ga962ff98f105cccff448c45b0c7b77e2f" title="Note that reserved SEQ numbers below 12 will conflict with ldiskfs inodes in the...">fid_seq</a>(fid) != FID_SEQ_LOCAL_FILE);
<a name="l02890"></a>02890 }
<a name="l02891"></a>02891 
<a name="l02892"></a>02892 
<a name="l02905"></a>02905 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_cache_parent_lov_striping(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02906"></a>02906                                          <span class="keyword">struct</span> <a class="code" href="structlod__object.html">lod_object</a> *lp)
<a name="l02907"></a>02907 {
<a name="l02908"></a>02908         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l02909"></a>02909         <span class="keyword">struct </span><a class="code" href="structlov__user__md__v1.html">lov_user_md_v1</a>   *v1 = NULL;
<a name="l02910"></a>02910         <span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a>   *v3 = NULL;
<a name="l02911"></a>02911         <span class="keywordtype">int</span>                      rc;
<a name="l02912"></a>02912         ENTRY;
<a name="l02913"></a>02913 
<a name="l02914"></a>02914         <span class="comment">/* called from MDD without parent being write locked,</span>
<a name="l02915"></a>02915 <span class="comment">         * lock it here */</span>
<a name="l02916"></a>02916         dt_write_lock(env, dt_object_child(&amp;lp-&gt;ldo_obj), 0);
<a name="l02917"></a>02917         rc = lod_get_lov_ea(env, lp);
<a name="l02918"></a>02918         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02919"></a>02919                 GOTO(unlock, rc);
<a name="l02920"></a>02920 
<a name="l02921"></a>02921         <span class="keywordflow">if</span> (rc &lt; (typeof(rc))<span class="keyword">sizeof</span>(<span class="keyword">struct</span> lov_user_md)) {
<a name="l02922"></a>02922                 <span class="comment">/* don&apos;t lookup for non-existing or invalid striping */</span>
<a name="l02923"></a>02923                 lp-&gt;ldo_def_striping_set = 0;
<a name="l02924"></a>02924                 lp-&gt;ldo_def_striping_cached = 1;
<a name="l02925"></a>02925                 lp-&gt;ldo_def_stripe_size = 0;
<a name="l02926"></a>02926                 lp-&gt;ldo_def_stripenr = 0;
<a name="l02927"></a>02927                 lp-&gt;ldo_def_stripe_offset = (typeof(v1-&gt;lmm_stripe_offset))(-1);
<a name="l02928"></a>02928                 GOTO(unlock, rc = 0);
<a name="l02929"></a>02929         }
<a name="l02930"></a>02930 
<a name="l02931"></a>02931         rc = 0;
<a name="l02932"></a>02932         v1 = info-&gt;lti_ea_store;
<a name="l02933"></a>02933         <span class="keywordflow">if</span> (v1-&gt;lmm_magic == __swab32(LOV_USER_MAGIC_V1)) {
<a name="l02934"></a>02934                 lustre_swab_lov_user_md_v1(v1);
<a name="l02935"></a>02935         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (v1-&gt;lmm_magic == __swab32(LOV_USER_MAGIC_V3)) {
<a name="l02936"></a>02936                 v3 = (<span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a> *)v1;
<a name="l02937"></a>02937                 lustre_swab_lov_user_md_v3(v3);
<a name="l02938"></a>02938         }
<a name="l02939"></a>02939 
<a name="l02940"></a>02940         <span class="keywordflow">if</span> (v1-&gt;lmm_magic != LOV_MAGIC_V3 &amp;&amp; v1-&gt;lmm_magic != LOV_MAGIC_V1)
<a name="l02941"></a>02941                 GOTO(unlock, rc = 0);
<a name="l02942"></a>02942 
<a name="l02943"></a>02943         <span class="keywordflow">if</span> (v1-&gt;lmm_pattern != LOV_PATTERN_RAID0 &amp;&amp; v1-&gt;lmm_pattern != 0)
<a name="l02944"></a>02944                 GOTO(unlock, rc = 0);
<a name="l02945"></a>02945 
<a name="l02946"></a>02946         CDEBUG(D_INFO, DFID<span class="stringliteral">&quot; stripe_count=%d stripe_size=%d stripe_offset=%d\n&quot;</span>,
<a name="l02947"></a>02947                PFID(lu_object_fid(&amp;lp-&gt;ldo_obj.do_lu)),
<a name="l02948"></a>02948                (<span class="keywordtype">int</span>)v1-&gt;lmm_stripe_count,
<a name="l02949"></a>02949                (<span class="keywordtype">int</span>)v1-&gt;lmm_stripe_size, (<span class="keywordtype">int</span>)v1-&gt;lmm_stripe_offset);
<a name="l02950"></a>02950 
<a name="l02951"></a>02951         lp-&gt;ldo_def_stripenr = v1-&gt;lmm_stripe_count;
<a name="l02952"></a>02952         lp-&gt;ldo_def_stripe_size = v1-&gt;lmm_stripe_size;
<a name="l02953"></a>02953         lp-&gt;ldo_def_stripe_offset = v1-&gt;lmm_stripe_offset;
<a name="l02954"></a>02954         lp-&gt;ldo_def_striping_cached = 1;
<a name="l02955"></a>02955         lp-&gt;ldo_def_striping_set = 1;
<a name="l02956"></a>02956         <span class="keywordflow">if</span> (v1-&gt;lmm_magic == LOV_USER_MAGIC_V3) {
<a name="l02957"></a>02957                 <span class="comment">/* XXX: sanity check here */</span>
<a name="l02958"></a>02958                 v3 = (<span class="keyword">struct </span><a class="code" href="structlov__user__md__v3.html">lov_user_md_v3</a> *) v1;
<a name="l02959"></a>02959                 <span class="keywordflow">if</span> (v3-&gt;lmm_pool_name[0])
<a name="l02960"></a>02960                         lod_object_set_pool(lp, v3-&gt;lmm_pool_name);
<a name="l02961"></a>02961         }
<a name="l02962"></a>02962         EXIT;
<a name="l02963"></a>02963 unlock:
<a name="l02964"></a>02964         dt_write_unlock(env, dt_object_child(&amp;lp-&gt;ldo_obj));
<a name="l02965"></a>02965         <span class="keywordflow">return</span> rc;
<a name="l02966"></a>02966 }
<a name="l02967"></a>02967 
<a name="l02968"></a>02968 
<a name="l02981"></a>02981 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_cache_parent_lmv_striping(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l02982"></a>02982                                          <span class="keyword">struct</span> <a class="code" href="structlod__object.html">lod_object</a> *lp)
<a name="l02983"></a>02983 {
<a name="l02984"></a>02984         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l02985"></a>02985         <span class="keyword">struct </span><a class="code" href="structlmv__user__md__v1.html">lmv_user_md_v1</a>   *v1 = NULL;
<a name="l02986"></a>02986         <span class="keywordtype">int</span>                      rc;
<a name="l02987"></a>02987         ENTRY;
<a name="l02988"></a>02988 
<a name="l02989"></a>02989         <span class="comment">/* called from MDD without parent being write locked,</span>
<a name="l02990"></a>02990 <span class="comment">         * lock it here */</span>
<a name="l02991"></a>02991         dt_write_lock(env, dt_object_child(&amp;lp-&gt;ldo_obj), 0);
<a name="l02992"></a>02992         rc = lod_get_default_lmv_ea(env, lp);
<a name="l02993"></a>02993         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l02994"></a>02994                 GOTO(unlock, rc);
<a name="l02995"></a>02995 
<a name="l02996"></a>02996         <span class="keywordflow">if</span> (rc &lt; (typeof(rc))<span class="keyword">sizeof</span>(<span class="keyword">struct</span> lmv_user_md)) {
<a name="l02997"></a>02997                 <span class="comment">/* don&apos;t lookup for non-existing or invalid striping */</span>
<a name="l02998"></a>02998                 lp-&gt;ldo_dir_def_striping_set = 0;
<a name="l02999"></a>02999                 lp-&gt;ldo_dir_def_striping_cached = 1;
<a name="l03000"></a>03000                 lp-&gt;ldo_dir_def_stripenr = 0;
<a name="l03001"></a>03001                 lp-&gt;ldo_dir_def_stripe_offset =
<a name="l03002"></a>03002                                         (typeof(v1-&gt;lum_stripe_offset))(-1);
<a name="l03003"></a>03003                 lp-&gt;ldo_dir_def_hash_type = LMV_HASH_TYPE_FNV_1A_64;
<a name="l03004"></a>03004                 GOTO(unlock, rc = 0);
<a name="l03005"></a>03005         }
<a name="l03006"></a>03006 
<a name="l03007"></a>03007         rc = 0;
<a name="l03008"></a>03008         v1 = info-&gt;lti_ea_store;
<a name="l03009"></a>03009 
<a name="l03010"></a>03010         lp-&gt;ldo_dir_def_stripenr = le32_to_cpu(v1-&gt;lum_stripe_count);
<a name="l03011"></a>03011         lp-&gt;ldo_dir_def_stripe_offset = le32_to_cpu(v1-&gt;lum_stripe_offset);
<a name="l03012"></a>03012         lp-&gt;ldo_dir_def_hash_type = le32_to_cpu(v1-&gt;lum_hash_type);
<a name="l03013"></a>03013         lp-&gt;ldo_dir_def_striping_set = 1;
<a name="l03014"></a>03014         lp-&gt;ldo_dir_def_striping_cached = 1;
<a name="l03015"></a>03015 
<a name="l03016"></a>03016         EXIT;
<a name="l03017"></a>03017 unlock:
<a name="l03018"></a>03018         dt_write_unlock(env, dt_object_child(&amp;lp-&gt;ldo_obj));
<a name="l03019"></a>03019         <span class="keywordflow">return</span> rc;
<a name="l03020"></a>03020 }
<a name="l03021"></a>03021 
<a name="l03038"></a>03038 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_cache_parent_striping(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03039"></a>03039                                      <span class="keyword">struct</span> <a class="code" href="structlod__object.html">lod_object</a> *lp,
<a name="l03040"></a>03040                                      umode_t child_mode)
<a name="l03041"></a>03041 {
<a name="l03042"></a>03042         <span class="keywordtype">int</span> rc = 0;
<a name="l03043"></a>03043         ENTRY;
<a name="l03044"></a>03044 
<a name="l03045"></a>03045         <span class="keywordflow">if</span> (!lp-&gt;ldo_def_striping_cached) {
<a name="l03046"></a>03046                 <span class="comment">/* we haven&apos;t tried to get default striping for</span>
<a name="l03047"></a>03047 <span class="comment">                 * the directory yet, let&apos;s cache it in the object */</span>
<a name="l03048"></a>03048                 rc = lod_cache_parent_lov_striping(env, lp);
<a name="l03049"></a>03049                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03050"></a>03050                         RETURN(rc);
<a name="l03051"></a>03051         }
<a name="l03052"></a>03052 
<a name="l03053"></a>03053         <span class="comment">/* If the parent is on the remote MDT, we should always</span>
<a name="l03054"></a>03054 <span class="comment">         * try to refresh the default stripeEA cache, because we</span>
<a name="l03055"></a>03055 <span class="comment">         * do not cache default striping information for remote</span>
<a name="l03056"></a>03056 <span class="comment">         * object. */</span>
<a name="l03057"></a>03057         <span class="keywordflow">if</span> (S_ISDIR(child_mode) &amp;&amp; (!lp-&gt;ldo_dir_def_striping_cached ||
<a name="l03058"></a>03058                                     dt_object_remote(&amp;lp-&gt;ldo_obj)))
<a name="l03059"></a>03059                 rc = lod_cache_parent_lmv_striping(env, lp);
<a name="l03060"></a>03060 
<a name="l03061"></a>03061         RETURN(rc);
<a name="l03062"></a>03062 }
<a name="l03063"></a>03063 
<a name="l03075"></a>03075 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_ah_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03076"></a>03076                         <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *ah,
<a name="l03077"></a>03077                         <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *parent,
<a name="l03078"></a>03078                         <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *child,
<a name="l03079"></a>03079                         umode_t child_mode)
<a name="l03080"></a>03080 {
<a name="l03081"></a>03081         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a> *d = lu2lod_dev(child-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l03082"></a>03082         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>  *nextp = NULL;
<a name="l03083"></a>03083         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>  *nextc;
<a name="l03084"></a>03084         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *lp = NULL;
<a name="l03085"></a>03085         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *lc;
<a name="l03086"></a>03086         <span class="keyword">struct </span><a class="code" href="structlov__desc.html">lov_desc</a>   *desc;
<a name="l03087"></a>03087         <span class="keywordtype">int</span>               rc;
<a name="l03088"></a>03088         ENTRY;
<a name="l03089"></a>03089 
<a name="l03090"></a>03090         LASSERT(child);
<a name="l03091"></a>03091 
<a name="l03092"></a>03092         <span class="keywordflow">if</span> (likely(parent)) {
<a name="l03093"></a>03093                 nextp = dt_object_child(parent);
<a name="l03094"></a>03094                 lp = lod_dt_obj(parent);
<a name="l03095"></a>03095                 rc = lod_load_striping(env, lp);
<a name="l03096"></a>03096                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03097"></a>03097                         <span class="keywordflow">return</span>;
<a name="l03098"></a>03098         }
<a name="l03099"></a>03099 
<a name="l03100"></a>03100         nextc = dt_object_child(child);
<a name="l03101"></a>03101         lc = lod_dt_obj(child);
<a name="l03102"></a>03102 
<a name="l03103"></a>03103         LASSERT(lc-&gt;ldo_stripenr == 0);
<a name="l03104"></a>03104         LASSERT(lc-&gt;ldo_stripe == NULL);
<a name="l03105"></a>03105 
<a name="l03106"></a>03106         <span class="keywordflow">if</span> (!dt_object_exists(nextc))
<a name="l03107"></a>03107                 nextc-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#a00fed99bee94890d3e36719af00d5595" title="Prepare allocation hint for a new object.">do_ah_init</a>(env, ah, nextp, nextc, child_mode);
<a name="l03108"></a>03108 
<a name="l03109"></a>03109         <span class="keywordflow">if</span> (S_ISDIR(child_mode)) {
<a name="l03110"></a>03110                 <span class="keywordflow">if</span> (lc-&gt;ldo_dir_stripe == NULL) {
<a name="l03111"></a>03111                         OBD_ALLOC_PTR(lc-&gt;ldo_dir_stripe);
<a name="l03112"></a>03112                         <span class="keywordflow">if</span> (lc-&gt;ldo_dir_stripe == NULL)
<a name="l03113"></a>03113                                 <span class="keywordflow">return</span>;
<a name="l03114"></a>03114                 }
<a name="l03115"></a>03115 
<a name="l03116"></a>03116                 LASSERT(lp != NULL);
<a name="l03117"></a>03117                 <span class="keywordflow">if</span> (lp-&gt;ldo_dir_stripe == NULL) {
<a name="l03118"></a>03118                         OBD_ALLOC_PTR(lp-&gt;ldo_dir_stripe);
<a name="l03119"></a>03119                         <span class="keywordflow">if</span> (lp-&gt;ldo_dir_stripe == NULL)
<a name="l03120"></a>03120                                 <span class="keywordflow">return</span>;
<a name="l03121"></a>03121                 }
<a name="l03122"></a>03122 
<a name="l03123"></a>03123                 rc = lod_cache_parent_striping(env, lp, child_mode);
<a name="l03124"></a>03124                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03125"></a>03125                         <span class="keywordflow">return</span>;
<a name="l03126"></a>03126 
<a name="l03127"></a>03127                 <span class="comment">/* transfer defaults to new directory */</span>
<a name="l03128"></a>03128                 <span class="keywordflow">if</span> (lp-&gt;ldo_def_striping_set) {
<a name="l03129"></a>03129                         <span class="keywordflow">if</span> (lp-&gt;ldo_pool)
<a name="l03130"></a>03130                                 lod_object_set_pool(lc, lp-&gt;ldo_pool);
<a name="l03131"></a>03131                         lc-&gt;ldo_def_stripenr = lp-&gt;ldo_def_stripenr;
<a name="l03132"></a>03132                         lc-&gt;ldo_def_stripe_size = lp-&gt;ldo_def_stripe_size;
<a name="l03133"></a>03133                         lc-&gt;ldo_def_stripe_offset = lp-&gt;ldo_def_stripe_offset;
<a name="l03134"></a>03134                         lc-&gt;ldo_def_striping_set = 1;
<a name="l03135"></a>03135                         lc-&gt;ldo_def_striping_cached = 1;
<a name="l03136"></a>03136                         CDEBUG(D_OTHER, <span class="stringliteral">&quot;inherite EA sz:%d off:%d nr:%d\n&quot;</span>,
<a name="l03137"></a>03137                                (<span class="keywordtype">int</span>)lc-&gt;ldo_def_stripe_size,
<a name="l03138"></a>03138                                (<span class="keywordtype">int</span>)lc-&gt;ldo_def_stripe_offset,
<a name="l03139"></a>03139                                (<span class="keywordtype">int</span>)lc-&gt;ldo_def_stripenr);
<a name="l03140"></a>03140                 }
<a name="l03141"></a>03141 
<a name="l03142"></a>03142                 <span class="comment">/* transfer dir defaults to new directory */</span>
<a name="l03143"></a>03143                 <span class="keywordflow">if</span> (lp-&gt;ldo_dir_def_striping_set) {
<a name="l03144"></a>03144                         lc-&gt;ldo_dir_def_stripenr = lp-&gt;ldo_dir_def_stripenr;
<a name="l03145"></a>03145                         lc-&gt;ldo_dir_def_stripe_offset =
<a name="l03146"></a>03146                                                   lp-&gt;ldo_dir_def_stripe_offset;
<a name="l03147"></a>03147                         lc-&gt;ldo_dir_def_hash_type =
<a name="l03148"></a>03148                                                   lp-&gt;ldo_dir_def_hash_type;
<a name="l03149"></a>03149                         lc-&gt;ldo_dir_def_striping_set = 1;
<a name="l03150"></a>03150                         lc-&gt;ldo_dir_def_striping_cached = 1;
<a name="l03151"></a>03151                         CDEBUG(D_INFO, <span class="stringliteral">&quot;inherit default EA nr:%d off:%d t%u\n&quot;</span>,
<a name="l03152"></a>03152                                (<span class="keywordtype">int</span>)lc-&gt;ldo_dir_def_stripenr,
<a name="l03153"></a>03153                                (<span class="keywordtype">int</span>)lc-&gt;ldo_dir_def_stripe_offset,
<a name="l03154"></a>03154                                lc-&gt;ldo_dir_def_hash_type);
<a name="l03155"></a>03155                 }
<a name="l03156"></a>03156 
<a name="l03157"></a>03157                 <span class="comment">/* It should always honour the specified stripes */</span>
<a name="l03158"></a>03158                 <span class="keywordflow">if</span> (ah-&gt;dah_eadata != NULL &amp;&amp; ah-&gt;dah_eadata_len != 0) {
<a name="l03159"></a>03159                         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlmv__user__md__v1.html">lmv_user_md_v1</a> *lum1 = ah-&gt;dah_eadata;
<a name="l03160"></a>03160 
<a name="l03161"></a>03161                         rc = lod_verify_md_striping(d, lum1);
<a name="l03162"></a>03162                         <span class="keywordflow">if</span> (rc == 0 &amp;&amp;
<a name="l03163"></a>03163                                 le32_to_cpu(lum1-&gt;lum_stripe_count) &gt; 1) {
<a name="l03164"></a>03164                                 lc-&gt;ldo_stripenr =
<a name="l03165"></a>03165                                         le32_to_cpu(lum1-&gt;lum_stripe_count);
<a name="l03166"></a>03166                                 lc-&gt;ldo_dir_stripe_offset =
<a name="l03167"></a>03167                                         le32_to_cpu(lum1-&gt;lum_stripe_offset);
<a name="l03168"></a>03168                                 lc-&gt;ldo_dir_hash_type =
<a name="l03169"></a>03169                                         le32_to_cpu(lum1-&gt;lum_hash_type);
<a name="l03170"></a>03170                                 CDEBUG(D_INFO, <span class="stringliteral">&quot;set stripe EA nr:%hu off:%d\n&quot;</span>,
<a name="l03171"></a>03171                                        lc-&gt;ldo_stripenr,
<a name="l03172"></a>03172                                        (<span class="keywordtype">int</span>)lc-&gt;ldo_dir_stripe_offset);
<a name="l03173"></a>03173                         }
<a name="l03174"></a>03174                 <span class="comment">/* then check whether there is default stripes from parent */</span>
<a name="l03175"></a>03175                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lp-&gt;ldo_dir_def_striping_set) {
<a name="l03176"></a>03176                         <span class="comment">/* If there are default dir stripe from parent */</span>
<a name="l03177"></a>03177                         lc-&gt;ldo_stripenr = lp-&gt;ldo_dir_def_stripenr;
<a name="l03178"></a>03178                         lc-&gt;ldo_dir_stripe_offset =
<a name="l03179"></a>03179                                         lp-&gt;ldo_dir_def_stripe_offset;
<a name="l03180"></a>03180                         lc-&gt;ldo_dir_hash_type =
<a name="l03181"></a>03181                                         lp-&gt;ldo_dir_def_hash_type;
<a name="l03182"></a>03182                         CDEBUG(D_INFO, <span class="stringliteral">&quot;inherit EA nr:%hu off:%d\n&quot;</span>,
<a name="l03183"></a>03183                                lc-&gt;ldo_stripenr,
<a name="l03184"></a>03184                                (<span class="keywordtype">int</span>)lc-&gt;ldo_dir_stripe_offset);
<a name="l03185"></a>03185                 } <span class="keywordflow">else</span> {
<a name="l03186"></a>03186                         <span class="comment">/* set default stripe for this directory */</span>
<a name="l03187"></a>03187                         lc-&gt;ldo_stripenr = 0;
<a name="l03188"></a>03188                         lc-&gt;ldo_dir_stripe_offset = -1;
<a name="l03189"></a>03189                 }
<a name="l03190"></a>03190 
<a name="l03191"></a>03191                 <span class="comment">/* shrink the stripe_count to the avaible MDT count */</span>
<a name="l03192"></a>03192                 <span class="keywordflow">if</span> (lc-&gt;ldo_stripenr &gt; d-&gt;lod_remote_mdt_count + 1 &amp;&amp;
<a name="l03193"></a>03193                     !OBD_FAIL_CHECK(OBD_FAIL_LARGE_STRIPE))
<a name="l03194"></a>03194                         lc-&gt;ldo_stripenr = d-&gt;lod_remote_mdt_count + 1;
<a name="l03195"></a>03195 
<a name="l03196"></a>03196                 <span class="comment">/* Directory will be striped only if stripe_count &gt; 1, if</span>
<a name="l03197"></a>03197 <span class="comment">                 * stripe_count == 1, let&apos;s reset stripenr = 0 to avoid</span>
<a name="l03198"></a>03198 <span class="comment">                 * create single master stripe and also help to unify the</span>
<a name="l03199"></a>03199 <span class="comment">                 * stripe handling of directories and files */</span>
<a name="l03200"></a>03200                 <span class="keywordflow">if</span> (lc-&gt;ldo_stripenr == 1)
<a name="l03201"></a>03201                         lc-&gt;ldo_stripenr = 0;
<a name="l03202"></a>03202 
<a name="l03203"></a>03203                 CDEBUG(D_INFO, <span class="stringliteral">&quot;final striping count:%hu, offset:%d\n&quot;</span>,
<a name="l03204"></a>03204                        lc-&gt;ldo_stripenr, (<span class="keywordtype">int</span>)lc-&gt;ldo_dir_stripe_offset);
<a name="l03205"></a>03205 
<a name="l03206"></a>03206                 <span class="keywordflow">goto</span> out;
<a name="l03207"></a>03207         }
<a name="l03208"></a>03208 
<a name="l03209"></a>03209         <span class="comment">/*</span>
<a name="l03210"></a>03210 <span class="comment">         * if object is going to be striped over OSTs, transfer default</span>
<a name="l03211"></a>03211 <span class="comment">         * striping information to the child, so that we can use it</span>
<a name="l03212"></a>03212 <span class="comment">         * during declaration and creation</span>
<a name="l03213"></a>03213 <span class="comment">         */</span>
<a name="l03214"></a>03214         <span class="keywordflow">if</span> (!lod_object_will_be_striped(S_ISREG(child_mode),
<a name="l03215"></a>03215                                         lu_object_fid(&amp;child-&gt;do_lu)))
<a name="l03216"></a>03216                 <span class="keywordflow">goto</span> out;
<a name="l03217"></a>03217         <span class="comment">/*</span>
<a name="l03218"></a>03218 <span class="comment">         * try from the parent</span>
<a name="l03219"></a>03219 <span class="comment">         */</span>
<a name="l03220"></a>03220         <span class="keywordflow">if</span> (likely(parent)) {
<a name="l03221"></a>03221                 lod_cache_parent_striping(env, lp, child_mode);
<a name="l03222"></a>03222 
<a name="l03223"></a>03223                 lc-&gt;ldo_def_stripe_offset = LOV_OFFSET_DEFAULT;
<a name="l03224"></a>03224 
<a name="l03225"></a>03225                 <span class="keywordflow">if</span> (lp-&gt;ldo_def_striping_set) {
<a name="l03226"></a>03226                         <span class="keywordflow">if</span> (lp-&gt;ldo_pool)
<a name="l03227"></a>03227                                 lod_object_set_pool(lc, lp-&gt;ldo_pool);
<a name="l03228"></a>03228                         lc-&gt;ldo_stripenr = lp-&gt;ldo_def_stripenr;
<a name="l03229"></a>03229                         lc-&gt;ldo_stripe_size = lp-&gt;ldo_def_stripe_size;
<a name="l03230"></a>03230                         lc-&gt;ldo_def_stripe_offset = lp-&gt;ldo_def_stripe_offset;
<a name="l03231"></a>03231                         CDEBUG(D_OTHER, <span class="stringliteral">&quot;striping from parent: #%d, sz %d %s\n&quot;</span>,
<a name="l03232"></a>03232                                lc-&gt;ldo_stripenr, lc-&gt;ldo_stripe_size,
<a name="l03233"></a>03233                                lp-&gt;ldo_pool ? lp-&gt;ldo_pool : <span class="stringliteral">&quot;&quot;</span>);
<a name="l03234"></a>03234                 }
<a name="l03235"></a>03235         }
<a name="l03236"></a>03236 
<a name="l03237"></a>03237         <span class="comment">/*</span>
<a name="l03238"></a>03238 <span class="comment">         * if the parent doesn&apos;t provide with specific pattern, grab fs-wide one</span>
<a name="l03239"></a>03239 <span class="comment">         */</span>
<a name="l03240"></a>03240         desc = &amp;d-&gt;lod_desc;
<a name="l03241"></a>03241         <span class="keywordflow">if</span> (lc-&gt;ldo_stripenr == 0)
<a name="l03242"></a>03242                 lc-&gt;ldo_stripenr = desc-&gt;ld_default_stripe_count;
<a name="l03243"></a>03243         <span class="keywordflow">if</span> (lc-&gt;ldo_stripe_size == 0)
<a name="l03244"></a>03244                 lc-&gt;ldo_stripe_size = desc-&gt;ld_default_stripe_size;
<a name="l03245"></a>03245         CDEBUG(D_OTHER, <span class="stringliteral">&quot;final striping: # %d stripes, sz %d from %s\n&quot;</span>,
<a name="l03246"></a>03246                lc-&gt;ldo_stripenr, lc-&gt;ldo_stripe_size,
<a name="l03247"></a>03247                lc-&gt;ldo_pool ? lc-&gt;ldo_pool : <span class="stringliteral">&quot;&quot;</span>);
<a name="l03248"></a>03248 
<a name="l03249"></a>03249 out:
<a name="l03250"></a>03250         <span class="comment">/* we do not cache stripe information for slave stripe, see</span>
<a name="l03251"></a>03251 <span class="comment">         * lod_xattr_set_lov_on_dir */</span>
<a name="l03252"></a>03252         <span class="keywordflow">if</span> (lp != NULL &amp;&amp; lp-&gt;ldo_dir_slave_stripe)
<a name="l03253"></a>03253                 lod_lov_stripe_cache_clear(lp);
<a name="l03254"></a>03254 
<a name="l03255"></a>03255         EXIT;
<a name="l03256"></a>03256 }
<a name="l03257"></a>03257 
<a name="l03258"></a>03258 <span class="preprocessor">#define ll_do_div64(aaa,bbb)    do_div((aaa), (bbb))</span>
<a name="l03259"></a>03259 <span class="preprocessor"></span>
<a name="l03275"></a>03275 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_init_size(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03276"></a>03276                                  <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03277"></a>03277 {
<a name="l03278"></a>03278         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>   *next = dt_object_child(dt);
<a name="l03279"></a>03279         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>  *lo = lod_dt_obj(dt);
<a name="l03280"></a>03280         <span class="keyword">struct </span><a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a>     *attr = &amp;lod_env_info(env)-&gt;lti_attr;
<a name="l03281"></a>03281         uint64_t            size, offs;
<a name="l03282"></a>03282         <span class="keywordtype">int</span>                 rc, stripe;
<a name="l03283"></a>03283         ENTRY;
<a name="l03284"></a>03284 
<a name="l03285"></a>03285         <span class="comment">/* XXX: we support the simplest (RAID0) striping so far */</span>
<a name="l03286"></a>03286         LASSERT(lo-&gt;ldo_stripe || lo-&gt;ldo_stripenr == 0);
<a name="l03287"></a>03287         LASSERT(lo-&gt;ldo_stripe_size &gt; 0);
<a name="l03288"></a>03288 
<a name="l03289"></a>03289         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr == 0)
<a name="l03290"></a>03290                 RETURN(0);
<a name="l03291"></a>03291 
<a name="l03292"></a>03292         rc = dt_attr_get(env, next, attr);
<a name="l03293"></a>03293         LASSERT(attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> &amp; LA_SIZE);
<a name="l03294"></a>03294         <span class="keywordflow">if</span> (rc)
<a name="l03295"></a>03295                 RETURN(rc);
<a name="l03296"></a>03296 
<a name="l03297"></a>03297         size = attr-&gt;<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a>;
<a name="l03298"></a>03298         <span class="keywordflow">if</span> (size == 0)
<a name="l03299"></a>03299                 RETURN(0);
<a name="l03300"></a>03300 
<a name="l03301"></a>03301         <span class="comment">/* ll_do_div64(a, b) returns a % b, and a = a / b */</span>
<a name="l03302"></a>03302         ll_do_div64(size, (__u64) lo-&gt;ldo_stripe_size);
<a name="l03303"></a>03303         stripe = ll_do_div64(size, (__u64) lo-&gt;ldo_stripenr);
<a name="l03304"></a>03304 
<a name="l03305"></a>03305         size = size * lo-&gt;ldo_stripe_size;
<a name="l03306"></a>03306         offs = attr-&gt;<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a>;
<a name="l03307"></a>03307         size += ll_do_div64(offs, lo-&gt;ldo_stripe_size);
<a name="l03308"></a>03308 
<a name="l03309"></a>03309         attr-&gt;<a class="code" href="structlu__attr.html#a6ebc7938388954da75a9b75f0689d469" title="valid bits">la_valid</a> = LA_SIZE;
<a name="l03310"></a>03310         attr-&gt;<a class="code" href="structlu__attr.html#a1a701b4d0d6a0c44590a0cda86be525f" title="size in bytes">la_size</a> = size;
<a name="l03311"></a>03311 
<a name="l03312"></a>03312         rc = lod_sub_object_declare_attr_set(env, lo-&gt;ldo_stripe[stripe], attr,
<a name="l03313"></a>03313                                              th);
<a name="l03314"></a>03314 
<a name="l03315"></a>03315         RETURN(rc);
<a name="l03316"></a>03316 }
<a name="l03317"></a>03317 
<a name="l03337"></a>03337 <span class="keywordtype">int</span> lod_declare_striped_object(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l03338"></a>03338                                <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l03339"></a>03339                                <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *lovea, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03340"></a>03340 {
<a name="l03341"></a>03341         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a>  *info = lod_env_info(env);
<a name="l03342"></a>03342         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>        *next = dt_object_child(dt);
<a name="l03343"></a>03343         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l03344"></a>03344         <span class="keywordtype">int</span>                      rc;
<a name="l03345"></a>03345         ENTRY;
<a name="l03346"></a>03346 
<a name="l03347"></a>03347         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_MDS_ALLOC_OBDO)) {
<a name="l03348"></a>03348                 <span class="comment">/* failed to create striping, let&apos;s reset</span>
<a name="l03349"></a>03349 <span class="comment">                 * config so that others don&apos;t get confused */</span>
<a name="l03350"></a>03350                 lod_object_free_striping(env, lo);
<a name="l03351"></a>03351                 GOTO(out, rc = -ENOMEM);
<a name="l03352"></a>03352         }
<a name="l03353"></a>03353 
<a name="l03354"></a>03354         <span class="keywordflow">if</span> (!dt_object_remote(next)) {
<a name="l03355"></a>03355                 <span class="comment">/* choose OST and generate appropriate objects */</span>
<a name="l03356"></a>03356                 rc = lod_qos_prep_create(env, lo, attr, lovea, th);
<a name="l03357"></a>03357                 <span class="keywordflow">if</span> (rc) {
<a name="l03358"></a>03358                         <span class="comment">/* failed to create striping, let&apos;s reset</span>
<a name="l03359"></a>03359 <span class="comment">                         * config so that others don&apos;t get confused */</span>
<a name="l03360"></a>03360                         lod_object_free_striping(env, lo);
<a name="l03361"></a>03361                         GOTO(out, rc);
<a name="l03362"></a>03362                 }
<a name="l03363"></a>03363 
<a name="l03364"></a>03364                 <span class="comment">/*</span>
<a name="l03365"></a>03365 <span class="comment">                 * declare storage for striping data</span>
<a name="l03366"></a>03366 <span class="comment">                 */</span>
<a name="l03367"></a>03367                 info-&gt;lti_buf.lb_len = lov_mds_md_size(lo-&gt;ldo_stripenr,
<a name="l03368"></a>03368                                 lo-&gt;ldo_pool ?  LOV_MAGIC_V3 : LOV_MAGIC_V1);
<a name="l03369"></a>03369         } <span class="keywordflow">else</span> {
<a name="l03370"></a>03370                 <span class="comment">/* LOD can not choose OST objects for remote objects, i.e.</span>
<a name="l03371"></a>03371 <span class="comment">                 * stripes must be ready before that. Right now, it can only</span>
<a name="l03372"></a>03372 <span class="comment">                 * happen during migrate, i.e. migrate process needs to create</span>
<a name="l03373"></a>03373 <span class="comment">                 * remote regular file (mdd_migrate_create), then the migrate</span>
<a name="l03374"></a>03374 <span class="comment">                 * process will provide stripeEA. */</span>
<a name="l03375"></a>03375                 LASSERT(lovea != NULL);
<a name="l03376"></a>03376                 info-&gt;lti_buf = *lovea;
<a name="l03377"></a>03377         }
<a name="l03378"></a>03378 
<a name="l03379"></a>03379         rc = lod_sub_object_declare_xattr_set(env, next, &amp;info-&gt;lti_buf,
<a name="l03380"></a>03380                                               XATTR_NAME_LOV, 0, th);
<a name="l03381"></a>03381         <span class="keywordflow">if</span> (rc)
<a name="l03382"></a>03382                 GOTO(out, rc);
<a name="l03383"></a>03383 
<a name="l03384"></a>03384         <span class="comment">/*</span>
<a name="l03385"></a>03385 <span class="comment">         * if striping is created with local object&apos;s size &gt; 0,</span>
<a name="l03386"></a>03386 <span class="comment">         * we have to propagate this size to specific object</span>
<a name="l03387"></a>03387 <span class="comment">         * the case is possible only when local object was created previously</span>
<a name="l03388"></a>03388 <span class="comment">         */</span>
<a name="l03389"></a>03389         <span class="keywordflow">if</span> (dt_object_exists(next))
<a name="l03390"></a>03390                 rc = lod_declare_init_size(env, dt, th);
<a name="l03391"></a>03391 
<a name="l03392"></a>03392 out:
<a name="l03393"></a>03393         RETURN(rc);
<a name="l03394"></a>03394 }
<a name="l03395"></a>03395 
<a name="l03407"></a>03407 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_object_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03408"></a>03408                                      <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l03409"></a>03409                                      <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l03410"></a>03410                                      <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint,
<a name="l03411"></a>03411                                      <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof,
<a name="l03412"></a>03412                                      <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03413"></a>03413 {
<a name="l03414"></a>03414         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>   *next = dt_object_child(dt);
<a name="l03415"></a>03415         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>  *lo = lod_dt_obj(dt);
<a name="l03416"></a>03416         <span class="keywordtype">int</span>                 rc;
<a name="l03417"></a>03417         ENTRY;
<a name="l03418"></a>03418 
<a name="l03419"></a>03419         LASSERT(dof);
<a name="l03420"></a>03420         LASSERT(attr);
<a name="l03421"></a>03421         LASSERT(th);
<a name="l03422"></a>03422 
<a name="l03423"></a>03423         <span class="comment">/*</span>
<a name="l03424"></a>03424 <span class="comment">         * first of all, we declare creation of local object</span>
<a name="l03425"></a>03425 <span class="comment">         */</span>
<a name="l03426"></a>03426         rc = lod_sub_object_declare_create(env, next, attr, hint, dof, th);
<a name="l03427"></a>03427         <span class="keywordflow">if</span> (rc != 0)
<a name="l03428"></a>03428                 GOTO(out, rc);
<a name="l03429"></a>03429 
<a name="l03430"></a>03430         <span class="keywordflow">if</span> (dof-&gt;<a class="code" href="structdt__object__format.html#a7522bce1087145d78c749b182e10357c" title="type for dt object">dof_type</a> == <a class="code" href="group__dt.html#gga51d4c45efee77175aa61574dbc46b53ea3ff5f1672deeb66303f63fc82b49fd11" title="for symbolic link">DFT_SYM</a>)
<a name="l03431"></a>03431                 dt-&gt;do_body_ops = &amp;lod_body_lnk_ops;
<a name="l03432"></a>03432         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dof-&gt;<a class="code" href="structdt__object__format.html#a7522bce1087145d78c749b182e10357c" title="type for dt object">dof_type</a> == DFT_REGULAR)
<a name="l03433"></a>03433                 dt-&gt;do_body_ops = &amp;lod_body_ops;
<a name="l03434"></a>03434 
<a name="l03435"></a>03435         <span class="comment">/*</span>
<a name="l03436"></a>03436 <span class="comment">         * it&apos;s lod_ah_init() that has decided the object will be striped</span>
<a name="l03437"></a>03437 <span class="comment">         */</span>
<a name="l03438"></a>03438         <span class="keywordflow">if</span> (dof-&gt;<a class="code" href="structdt__object__format.html#a7522bce1087145d78c749b182e10357c" title="type for dt object">dof_type</a> == DFT_REGULAR) {
<a name="l03439"></a>03439                 <span class="comment">/* callers don&apos;t want stripes */</span>
<a name="l03440"></a>03440                 <span class="comment">/* XXX: all tricky interactions with -&gt;ah_make_hint() decided</span>
<a name="l03441"></a>03441 <span class="comment">                 * to use striping, then -&gt;declare_create() behaving differently</span>
<a name="l03442"></a>03442 <span class="comment">                 * should be cleaned */</span>
<a name="l03443"></a>03443                 <span class="keywordflow">if</span> (dof-&gt;u.dof_reg.striped == 0)
<a name="l03444"></a>03444                         lo-&gt;ldo_stripenr = 0;
<a name="l03445"></a>03445                 <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr &gt; 0)
<a name="l03446"></a>03446                         rc = lod_declare_striped_object(env, dt, attr,
<a name="l03447"></a>03447                                                         NULL, th);
<a name="l03448"></a>03448         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dof-&gt;<a class="code" href="structdt__object__format.html#a7522bce1087145d78c749b182e10357c" title="type for dt object">dof_type</a> == DFT_DIR) {
<a name="l03449"></a>03449                 <span class="keyword">struct </span><a class="code" href="structseq__server__site.html">seq_server_site</a> *ss;
<a name="l03450"></a>03450 
<a name="l03451"></a>03451                 ss = lu_site2seq(dt-&gt;do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>);
<a name="l03452"></a>03452 
<a name="l03453"></a>03453                 <span class="comment">/* If the parent has default stripeEA, and client</span>
<a name="l03454"></a>03454 <span class="comment">                 * did not find it before sending create request,</span>
<a name="l03455"></a>03455 <span class="comment">                 * then MDT will return -EREMOTE, and client will</span>
<a name="l03456"></a>03456 <span class="comment">                 * retrieve the default stripeEA and re-create the</span>
<a name="l03457"></a>03457 <span class="comment">                 * sub directory.</span>
<a name="l03458"></a>03458 <span class="comment">                 *</span>
<a name="l03459"></a>03459 <span class="comment">                 * Note: if dah_eadata != NULL, it means creating the</span>
<a name="l03460"></a>03460 <span class="comment">                 * striped directory with specified stripeEA, then it</span>
<a name="l03461"></a>03461 <span class="comment">                 * should ignore the default stripeEA */</span>
<a name="l03462"></a>03462                 <span class="keywordflow">if</span> (hint != NULL &amp;&amp; hint-&gt;dah_eadata == NULL) {
<a name="l03463"></a>03463                         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_MDS_STALE_DIR_LAYOUT))
<a name="l03464"></a>03464                                 GOTO(out, rc = -EREMOTE);
<a name="l03465"></a>03465 
<a name="l03466"></a>03466                         <span class="keywordflow">if</span> (lo-&gt;ldo_dir_stripe_offset == -1) {
<a name="l03467"></a>03467                                 <span class="comment">/* child and parent should be in the same MDT */</span>
<a name="l03468"></a>03468                                 <span class="keywordflow">if</span> (hint-&gt;dah_parent != NULL &amp;&amp;
<a name="l03469"></a>03469                                     dt_object_remote(hint-&gt;dah_parent))
<a name="l03470"></a>03470                                         GOTO(out, rc = -EREMOTE);
<a name="l03471"></a>03471                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lo-&gt;ldo_dir_stripe_offset !=
<a name="l03472"></a>03472                                    ss-&gt;<a class="code" href="structseq__server__site.html#ac6ed0968d534f1eda5c11d36b6b9539f" title="mds number of this site.">ss_node_id</a>) {
<a name="l03473"></a>03473                                 <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a> *lod;
<a name="l03474"></a>03474                                 <span class="keyword">struct </span><a class="code" href="structlod__tgt__descs.html">lod_tgt_descs</a> *ltd;
<a name="l03475"></a>03475                                 <span class="keyword">struct </span><a class="code" href="structlod__tgt__desc.html">lod_tgt_desc</a> *tgt = NULL;
<a name="l03476"></a>03476                                 <span class="keywordtype">bool</span> found_mdt = <span class="keyword">false</span>;
<a name="l03477"></a>03477                                 <span class="keywordtype">int</span> i;
<a name="l03478"></a>03478 
<a name="l03479"></a>03479                                 lod = lu2lod_dev(lo-&gt;ldo_obj.do_lu.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l03480"></a>03480                                 ltd = &amp;lod-&gt;lod_mdt_descs;
<a name="l03481"></a>03481                                 cfs_foreach_bit(ltd-&gt;ltd_tgt_bitmap, i) {
<a name="l03482"></a>03482                                         tgt = LTD_TGT(ltd, i);
<a name="l03483"></a>03483                                         <span class="keywordflow">if</span> (tgt-&gt;ltd_index ==
<a name="l03484"></a>03484                                                 lo-&gt;ldo_dir_stripe_offset) {
<a name="l03485"></a>03485                                                 found_mdt = <span class="keyword">true</span>;
<a name="l03486"></a>03486                                                 <span class="keywordflow">break</span>;
<a name="l03487"></a>03487                                         }
<a name="l03488"></a>03488                                 }
<a name="l03489"></a>03489 
<a name="l03490"></a>03490                                 <span class="comment">/* If the MDT indicated by stripe_offset can be</span>
<a name="l03491"></a>03491 <span class="comment">                                 * found, then tell client to resend the create</span>
<a name="l03492"></a>03492 <span class="comment">                                 * request to the correct MDT, otherwise return</span>
<a name="l03493"></a>03493 <span class="comment">                                 * error to client */</span>
<a name="l03494"></a>03494                                 <span class="keywordflow">if</span> (found_mdt)
<a name="l03495"></a>03495                                         GOTO(out, rc = -EREMOTE);
<a name="l03496"></a>03496                                 <span class="keywordflow">else</span>
<a name="l03497"></a>03497                                         GOTO(out, rc = -EINVAL);
<a name="l03498"></a>03498                         }
<a name="l03499"></a>03499                 }
<a name="l03500"></a>03500 
<a name="l03501"></a>03501                 <span class="comment">/* Orphan object (like migrating object) does not have</span>
<a name="l03502"></a>03502 <span class="comment">                 * lod_dir_stripe, see lod_ah_init */</span>
<a name="l03503"></a>03503                 <span class="keywordflow">if</span> (lo-&gt;ldo_dir_stripe != NULL)
<a name="l03504"></a>03504                         rc = lod_declare_dir_striping_create(env, dt, attr,
<a name="l03505"></a>03505                                                              dof, th);
<a name="l03506"></a>03506         }
<a name="l03507"></a>03507 out:
<a name="l03508"></a>03508         RETURN(rc);
<a name="l03509"></a>03509 }
<a name="l03510"></a>03510 
<a name="l03530"></a>03530 <span class="keywordtype">int</span> lod_striping_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l03531"></a>03531                         <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr, <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof,
<a name="l03532"></a>03532                         <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03533"></a>03533 {
<a name="l03534"></a>03534         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *lo = lod_dt_obj(dt);
<a name="l03535"></a>03535         <span class="keywordtype">int</span>                rc = 0, i;
<a name="l03536"></a>03536         ENTRY;
<a name="l03537"></a>03537 
<a name="l03538"></a>03538         LASSERT(lo-&gt;ldo_striping_cached == 0);
<a name="l03539"></a>03539 
<a name="l03540"></a>03540         <span class="comment">/* create all underlying objects */</span>
<a name="l03541"></a>03541         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l03542"></a>03542                 LASSERT(lo-&gt;ldo_stripe[i]);
<a name="l03543"></a>03543                 rc = lod_sub_object_create(env, lo-&gt;ldo_stripe[i], attr, NULL,
<a name="l03544"></a>03544                                            dof, th);
<a name="l03545"></a>03545                 <span class="keywordflow">if</span> (rc)
<a name="l03546"></a>03546                         <span class="keywordflow">break</span>;
<a name="l03547"></a>03547         }
<a name="l03548"></a>03548 
<a name="l03549"></a>03549         <span class="keywordflow">if</span> (rc == 0) {
<a name="l03550"></a>03550                 rc = lod_generate_and_set_lovea(env, lo, th);
<a name="l03551"></a>03551                 <span class="keywordflow">if</span> (rc == 0)
<a name="l03552"></a>03552                         lo-&gt;ldo_striping_cached = 1;
<a name="l03553"></a>03553         }
<a name="l03554"></a>03554 
<a name="l03555"></a>03555         RETURN(rc);
<a name="l03556"></a>03556 }
<a name="l03557"></a>03557 
<a name="l03567"></a>03567 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_create(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l03568"></a>03568                              <span class="keyword">struct</span> <a class="code" href="structlu__attr.html" title="Common object attributes.">lu_attr</a> *attr,
<a name="l03569"></a>03569                              <span class="keyword">struct</span> <a class="code" href="structdt__allocation__hint.html" title="This is a general purpose dt allocation hint.">dt_allocation_hint</a> *hint,
<a name="l03570"></a>03570                              <span class="keyword">struct</span> <a class="code" href="structdt__object__format.html" title="object format specifier.">dt_object_format</a> *dof, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03571"></a>03571 {
<a name="l03572"></a>03572         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>  *lo = lod_dt_obj(dt);
<a name="l03573"></a>03573         <span class="keywordtype">int</span>                 rc;
<a name="l03574"></a>03574         ENTRY;
<a name="l03575"></a>03575 
<a name="l03576"></a>03576         <span class="comment">/* create local object */</span>
<a name="l03577"></a>03577         rc = lod_sub_object_create(env, dt_object_child(dt), attr, hint, dof,
<a name="l03578"></a>03578                                    th);
<a name="l03579"></a>03579         <span class="keywordflow">if</span> (rc != 0)
<a name="l03580"></a>03580                 RETURN(rc);
<a name="l03581"></a>03581 
<a name="l03582"></a>03582         <span class="keywordflow">if</span> (S_ISREG(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>) &amp;&amp;
<a name="l03583"></a>03583             lo-&gt;ldo_stripe &amp;&amp; dof-&gt;u.dof_reg.striped != 0)
<a name="l03584"></a>03584                 rc = lod_striping_create(env, dt, attr, dof, th);
<a name="l03585"></a>03585 
<a name="l03586"></a>03586         RETURN(rc);
<a name="l03587"></a>03587 }
<a name="l03588"></a>03588 
<a name="l03600"></a>03600 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_object_destroy(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03601"></a>03601                                       <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l03602"></a>03602                                       <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03603"></a>03603 {
<a name="l03604"></a>03604         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>   *next = dt_object_child(dt);
<a name="l03605"></a>03605         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>  *lo = lod_dt_obj(dt);
<a name="l03606"></a>03606         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a> *info = lod_env_info(env);
<a name="l03607"></a>03607         <span class="keywordtype">char</span>               *stripe_name = info-&gt;lti_key;
<a name="l03608"></a>03608         <span class="keywordtype">int</span>                 rc, i;
<a name="l03609"></a>03609         ENTRY;
<a name="l03610"></a>03610 
<a name="l03611"></a>03611         <span class="comment">/*</span>
<a name="l03612"></a>03612 <span class="comment">         * load striping information, notice we don&apos;t do this when object</span>
<a name="l03613"></a>03613 <span class="comment">         * is being initialized as we don&apos;t need this information till</span>
<a name="l03614"></a>03614 <span class="comment">         * few specific cases like destroy, chown</span>
<a name="l03615"></a>03615 <span class="comment">         */</span>
<a name="l03616"></a>03616         rc = lod_load_striping(env, lo);
<a name="l03617"></a>03617         <span class="keywordflow">if</span> (rc)
<a name="l03618"></a>03618                 RETURN(rc);
<a name="l03619"></a>03619 
<a name="l03620"></a>03620         <span class="comment">/* declare destroy for all underlying objects */</span>
<a name="l03621"></a>03621         <span class="keywordflow">if</span> (S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>)) {
<a name="l03622"></a>03622                 rc = next-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2" title="Try object as an index.">do_index_try</a>(env, next,
<a name="l03623"></a>03623                                                 &amp;<a class="code" href="group__dt.html#ga7c4fc0f51c05675af9609faa67c6cdea" title="Features, required from index to support file system directories (mapping names to...">dt_directory_features</a>);
<a name="l03624"></a>03624                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03625"></a>03625                         RETURN(rc);
<a name="l03626"></a>03626 
<a name="l03627"></a>03627                 <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l03628"></a>03628                         rc = lod_sub_object_declare_ref_del(env, next, th);
<a name="l03629"></a>03629                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03630"></a>03630                                 RETURN(rc);
<a name="l03631"></a>03631 
<a name="l03632"></a>03632                         snprintf(stripe_name, <span class="keyword">sizeof</span>(info-&gt;lti_key), DFID<span class="stringliteral">&quot;:%d&quot;</span>,
<a name="l03633"></a>03633                                 PFID(lu_object_fid(&amp;lo-&gt;ldo_stripe[i]-&gt;do_lu)),
<a name="l03634"></a>03634                                 i);
<a name="l03635"></a>03635                         rc = lod_sub_object_declare_delete(env, next,
<a name="l03636"></a>03636                                         (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)stripe_name, th);
<a name="l03637"></a>03637                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03638"></a>03638                                 RETURN(rc);
<a name="l03639"></a>03639                 }
<a name="l03640"></a>03640         }
<a name="l03641"></a>03641 
<a name="l03642"></a>03642         <span class="comment">/*</span>
<a name="l03643"></a>03643 <span class="comment">         * we declare destroy for the local object</span>
<a name="l03644"></a>03644 <span class="comment">         */</span>
<a name="l03645"></a>03645         rc = lod_sub_object_declare_destroy(env, next, th);
<a name="l03646"></a>03646         <span class="keywordflow">if</span> (rc)
<a name="l03647"></a>03647                 RETURN(rc);
<a name="l03648"></a>03648 
<a name="l03649"></a>03649         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LOST_MDTOBJ))
<a name="l03650"></a>03650                 RETURN(0);
<a name="l03651"></a>03651 
<a name="l03652"></a>03652         <span class="comment">/* declare destroy all striped objects */</span>
<a name="l03653"></a>03653         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l03654"></a>03654                 <span class="keywordflow">if</span> (lo-&gt;ldo_stripe[i] == NULL)
<a name="l03655"></a>03655                         <span class="keywordflow">continue</span>;
<a name="l03656"></a>03656 
<a name="l03657"></a>03657                 <span class="keywordflow">if</span> (S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>))
<a name="l03658"></a>03658                         rc = lod_sub_object_declare_ref_del(env,
<a name="l03659"></a>03659                                         lo-&gt;ldo_stripe[i], th);
<a name="l03660"></a>03660 
<a name="l03661"></a>03661                 rc = lod_sub_object_declare_destroy(env, lo-&gt;ldo_stripe[i],
<a name="l03662"></a>03662                                         th);
<a name="l03663"></a>03663                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03664"></a>03664                         <span class="keywordflow">break</span>;
<a name="l03665"></a>03665         }
<a name="l03666"></a>03666 
<a name="l03667"></a>03667         RETURN(rc);
<a name="l03668"></a>03668 }
<a name="l03669"></a>03669 
<a name="l03679"></a>03679 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_destroy(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03680"></a>03680                 <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03681"></a>03681 {
<a name="l03682"></a>03682         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a>  *next = dt_object_child(dt);
<a name="l03683"></a>03683         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *lo = lod_dt_obj(dt);
<a name="l03684"></a>03684         <span class="keyword">struct </span><a class="code" href="structlod__thread__info.html">lod_thread_info</a> *info = lod_env_info(env);
<a name="l03685"></a>03685         <span class="keywordtype">char</span>               *stripe_name = info-&gt;lti_key;
<a name="l03686"></a>03686         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       i;
<a name="l03687"></a>03687         <span class="keywordtype">int</span>                rc;
<a name="l03688"></a>03688         ENTRY;
<a name="l03689"></a>03689 
<a name="l03690"></a>03690         <span class="comment">/* destroy sub-stripe of master object */</span>
<a name="l03691"></a>03691         <span class="keywordflow">if</span> (S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>)) {
<a name="l03692"></a>03692                 rc = next-&gt;do_ops-&gt;<a class="code" href="structdt__object__operations.html#ac317771bd9f0827b4d8fcec4d51a63c2" title="Try object as an index.">do_index_try</a>(env, next,
<a name="l03693"></a>03693                                                 &amp;<a class="code" href="group__dt.html#ga7c4fc0f51c05675af9609faa67c6cdea" title="Features, required from index to support file system directories (mapping names to...">dt_directory_features</a>);
<a name="l03694"></a>03694                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03695"></a>03695                         RETURN(rc);
<a name="l03696"></a>03696 
<a name="l03697"></a>03697                 <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l03698"></a>03698                         rc = lod_sub_object_ref_del(env, next, th);
<a name="l03699"></a>03699                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03700"></a>03700                                 RETURN(rc);
<a name="l03701"></a>03701 
<a name="l03702"></a>03702                         snprintf(stripe_name, <span class="keyword">sizeof</span>(info-&gt;lti_key), DFID<span class="stringliteral">&quot;:%d&quot;</span>,
<a name="l03703"></a>03703                                 PFID(lu_object_fid(&amp;lo-&gt;ldo_stripe[i]-&gt;do_lu)),
<a name="l03704"></a>03704                                 i);
<a name="l03705"></a>03705 
<a name="l03706"></a>03706                         CDEBUG(D_INFO, DFID<span class="stringliteral">&quot; delete stripe %s &quot;</span>DFID<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l03707"></a>03707                                PFID(lu_object_fid(&amp;dt-&gt;do_lu)), stripe_name,
<a name="l03708"></a>03708                                PFID(lu_object_fid(&amp;lo-&gt;ldo_stripe[i]-&gt;do_lu)));
<a name="l03709"></a>03709 
<a name="l03710"></a>03710                         rc = lod_sub_object_delete(env, next,
<a name="l03711"></a>03711                                        (<span class="keyword">const</span> <span class="keyword">struct</span> dt_key *)stripe_name, th);
<a name="l03712"></a>03712                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03713"></a>03713                                 RETURN(rc);
<a name="l03714"></a>03714                 }
<a name="l03715"></a>03715         }
<a name="l03716"></a>03716 
<a name="l03717"></a>03717         rc = lod_sub_object_destroy(env, next, th);
<a name="l03718"></a>03718         <span class="keywordflow">if</span> (rc != 0)
<a name="l03719"></a>03719                 RETURN(rc);
<a name="l03720"></a>03720 
<a name="l03721"></a>03721         <span class="keywordflow">if</span> (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LOST_MDTOBJ))
<a name="l03722"></a>03722                 RETURN(0);
<a name="l03723"></a>03723 
<a name="l03724"></a>03724         <span class="comment">/* destroy all striped objects */</span>
<a name="l03725"></a>03725         <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l03726"></a>03726                 <span class="keywordflow">if</span> (likely(lo-&gt;ldo_stripe[i] != NULL) &amp;&amp;
<a name="l03727"></a>03727                     (!OBD_FAIL_CHECK(OBD_FAIL_LFSCK_LOST_SPEOBJ) ||
<a name="l03728"></a>03728                      i == cfs_fail_val)) {
<a name="l03729"></a>03729                         <span class="keywordflow">if</span> (S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>)) {
<a name="l03730"></a>03730                                 dt_write_lock(env, lo-&gt;ldo_stripe[i],
<a name="l03731"></a>03731                                               MOR_TGT_CHILD);
<a name="l03732"></a>03732                                 rc = lod_sub_object_ref_del(env,
<a name="l03733"></a>03733                                                 lo-&gt;ldo_stripe[i], th);
<a name="l03734"></a>03734                                 dt_write_unlock(env, lo-&gt;ldo_stripe[i]);
<a name="l03735"></a>03735                                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03736"></a>03736                                         <span class="keywordflow">break</span>;
<a name="l03737"></a>03737                         }
<a name="l03738"></a>03738 
<a name="l03739"></a>03739                         rc = lod_sub_object_destroy(env, lo-&gt;ldo_stripe[i], th);
<a name="l03740"></a>03740                         <span class="keywordflow">if</span> (rc != 0)
<a name="l03741"></a>03741                                 <span class="keywordflow">break</span>;
<a name="l03742"></a>03742                 }
<a name="l03743"></a>03743         }
<a name="l03744"></a>03744 
<a name="l03745"></a>03745         RETURN(rc);
<a name="l03746"></a>03746 }
<a name="l03747"></a>03747 
<a name="l03754"></a>03754 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_ref_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03755"></a>03755                                <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03756"></a>03756 {
<a name="l03757"></a>03757         <span class="keywordflow">return</span> lod_sub_object_declare_ref_add(env, dt_object_child(dt), th);
<a name="l03758"></a>03758 }
<a name="l03759"></a>03759 
<a name="l03765"></a>03765 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_ref_add(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03766"></a>03766                        <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03767"></a>03767 {
<a name="l03768"></a>03768         <span class="keywordflow">return</span> lod_sub_object_ref_add(env, dt_object_child(dt), th);
<a name="l03769"></a>03769 }
<a name="l03770"></a>03770 
<a name="l03777"></a>03777 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_ref_del(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03778"></a>03778                                <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03779"></a>03779 {
<a name="l03780"></a>03780         <span class="keywordflow">return</span> lod_sub_object_declare_ref_del(env, dt_object_child(dt), th);
<a name="l03781"></a>03781 }
<a name="l03782"></a>03782 
<a name="l03788"></a>03788 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_ref_del(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03789"></a>03789                        <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l03790"></a>03790 {
<a name="l03791"></a>03791         <span class="keywordflow">return</span> lod_sub_object_ref_del(env, dt_object_child(dt), th);
<a name="l03792"></a>03792 }
<a name="l03793"></a>03793 
<a name="l03800"></a>03800 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_sync(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l03801"></a>03801                            __u64 start, __u64 end)
<a name="l03802"></a>03802 {
<a name="l03803"></a>03803         <span class="keywordflow">return</span> dt_object_sync(env, dt_object_child(dt), start, end);
<a name="l03804"></a>03804 }
<a name="l03805"></a>03805 
<a name="l03820"></a>03820 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_unlock_internal(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03821"></a>03821                                       <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l03822"></a>03822                                       <span class="keyword">struct</span> <a class="code" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters.">ldlm_enqueue_info</a> *einfo,
<a name="l03823"></a>03823                                       <span class="keyword">union</span> <a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)
<a name="l03824"></a>03824 {
<a name="l03825"></a>03825         <span class="keyword">struct </span><a class="code" href="structlustre__handle__array.html">lustre_handle_array</a> *slave_locks = einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af0ba62d8b646a2164ec979fb9bca48d4" title="lock glimpse callback">ei_cbdata</a>;
<a name="l03826"></a>03826         <span class="keywordtype">int</span>                     rc = 0;
<a name="l03827"></a>03827         <span class="keywordtype">int</span>                     i;
<a name="l03828"></a>03828         ENTRY;
<a name="l03829"></a>03829 
<a name="l03830"></a>03830         <span class="keywordflow">if</span> (slave_locks == NULL)
<a name="l03831"></a>03831                 RETURN(0);
<a name="l03832"></a>03832 
<a name="l03833"></a>03833         <span class="keywordflow">for</span> (i = 1; i &lt; slave_locks-&gt;count; i++) {
<a name="l03834"></a>03834                 <span class="keywordflow">if</span> (lustre_handle_is_used(&amp;slave_locks-&gt;handles[i]))
<a name="l03835"></a>03835                         <a class="code" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref</a>(&amp;slave_locks-&gt;handles[i],
<a name="l03836"></a>03836                                          einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a>);
<a name="l03837"></a>03837         }
<a name="l03838"></a>03838 
<a name="l03839"></a>03839         RETURN(rc);
<a name="l03840"></a>03840 }
<a name="l03841"></a>03841 
<a name="l03850"></a>03850 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_unlock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l03851"></a>03851                              <span class="keyword">struct</span> <a class="code" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters.">ldlm_enqueue_info</a> *einfo,
<a name="l03852"></a>03852                              <span class="keyword">union</span> <a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)
<a name="l03853"></a>03853 {
<a name="l03854"></a>03854         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *lo = lod_dt_obj(dt);
<a name="l03855"></a>03855         <span class="keyword">struct </span><a class="code" href="structlustre__handle__array.html">lustre_handle_array</a> *slave_locks = einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af0ba62d8b646a2164ec979fb9bca48d4" title="lock glimpse callback">ei_cbdata</a>;
<a name="l03856"></a>03856         <span class="keywordtype">int</span> slave_locks_size;
<a name="l03857"></a>03857         <span class="keywordtype">int</span> i;
<a name="l03858"></a>03858         ENTRY;
<a name="l03859"></a>03859 
<a name="l03860"></a>03860         <span class="keywordflow">if</span> (slave_locks == NULL)
<a name="l03861"></a>03861                 RETURN(0);
<a name="l03862"></a>03862 
<a name="l03863"></a>03863         LASSERT(S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>));
<a name="l03864"></a>03864         LASSERT(lo-&gt;ldo_stripenr &gt; 1);
<a name="l03865"></a>03865         <span class="comment">/* Note: for remote lock for single stripe dir, MDT will cancel</span>
<a name="l03866"></a>03866 <span class="comment">         * the lock by lockh directly */</span>
<a name="l03867"></a>03867         LASSERT(!dt_object_remote(dt_object_child(dt)));
<a name="l03868"></a>03868 
<a name="l03869"></a>03869         <span class="comment">/* locks were unlocked in MDT layer */</span>
<a name="l03870"></a>03870         <span class="keywordflow">for</span> (i = 1; i &lt; slave_locks-&gt;count; i++)
<a name="l03871"></a>03871                 LASSERT(!lustre_handle_is_used(&amp;slave_locks-&gt;handles[i]));
<a name="l03872"></a>03872 
<a name="l03873"></a>03873         slave_locks_size = <span class="keyword">sizeof</span>(*slave_locks) + slave_locks-&gt;count *
<a name="l03874"></a>03874                            <span class="keyword">sizeof</span>(slave_locks-&gt;handles[0]);
<a name="l03875"></a>03875         OBD_FREE(slave_locks, slave_locks_size);
<a name="l03876"></a>03876         einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af0ba62d8b646a2164ec979fb9bca48d4" title="lock glimpse callback">ei_cbdata</a> = NULL;
<a name="l03877"></a>03877 
<a name="l03878"></a>03878         RETURN(0);
<a name="l03879"></a>03879 }
<a name="l03880"></a>03880 
<a name="l03889"></a>03889 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_lock(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l03890"></a>03890                            <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l03891"></a>03891                            <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lh,
<a name="l03892"></a>03892                            <span class="keyword">struct</span> <a class="code" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters.">ldlm_enqueue_info</a> *einfo,
<a name="l03893"></a>03893                            <span class="keyword">union</span> <a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)
<a name="l03894"></a>03894 {
<a name="l03895"></a>03895         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a>       *lo = lod_dt_obj(dt);
<a name="l03896"></a>03896         <span class="keywordtype">int</span>                     rc = 0;
<a name="l03897"></a>03897         <span class="keywordtype">int</span>                     i;
<a name="l03898"></a>03898         <span class="keywordtype">int</span>                     slave_locks_size;
<a name="l03899"></a>03899         <span class="keyword">struct </span><a class="code" href="structlustre__handle__array.html">lustre_handle_array</a> *slave_locks = NULL;
<a name="l03900"></a>03900         ENTRY;
<a name="l03901"></a>03901 
<a name="l03902"></a>03902         <span class="comment">/* remote object lock */</span>
<a name="l03903"></a>03903         <span class="keywordflow">if</span> (!einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#afb3bba9ba05dd54bce7d863dbad3a8cb" title="lock namespace">ei_enq_slave</a>) {
<a name="l03904"></a>03904                 LASSERT(dt_object_remote(dt));
<a name="l03905"></a>03905                 <span class="keywordflow">return</span> dt_object_lock(env, dt_object_child(dt), lh, einfo,
<a name="l03906"></a>03906                                       policy);
<a name="l03907"></a>03907         }
<a name="l03908"></a>03908 
<a name="l03909"></a>03909         <span class="keywordflow">if</span> (!S_ISDIR(dt-&gt;do_lu.<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a>))
<a name="l03910"></a>03910                 RETURN(-ENOTDIR);
<a name="l03911"></a>03911 
<a name="l03912"></a>03912         rc = lod_load_striping(env, lo);
<a name="l03913"></a>03913         <span class="keywordflow">if</span> (rc != 0)
<a name="l03914"></a>03914                 RETURN(rc);
<a name="l03915"></a>03915 
<a name="l03916"></a>03916         <span class="comment">/* No stripes */</span>
<a name="l03917"></a>03917         <span class="keywordflow">if</span> (lo-&gt;ldo_stripenr &lt;= 1)
<a name="l03918"></a>03918                 RETURN(0);
<a name="l03919"></a>03919 
<a name="l03920"></a>03920         slave_locks_size = <span class="keyword">sizeof</span>(*slave_locks) + lo-&gt;ldo_stripenr *
<a name="l03921"></a>03921                            <span class="keyword">sizeof</span>(slave_locks-&gt;handles[0]);
<a name="l03922"></a>03922         <span class="comment">/* Freed in lod_object_unlock */</span>
<a name="l03923"></a>03923         OBD_ALLOC(slave_locks, slave_locks_size);
<a name="l03924"></a>03924         <span class="keywordflow">if</span> (slave_locks == NULL)
<a name="l03925"></a>03925                 RETURN(-ENOMEM);
<a name="l03926"></a>03926         slave_locks-&gt;count = lo-&gt;ldo_stripenr;
<a name="l03927"></a>03927 
<a name="l03928"></a>03928         <span class="comment">/* striped directory lock */</span>
<a name="l03929"></a>03929         <span class="keywordflow">for</span> (i = 1; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l03930"></a>03930                 <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a>    lockh;
<a name="l03931"></a>03931                 <span class="keyword">struct </span><a class="code" href="structldlm__res__id.html">ldlm_res_id</a>      *res_id;
<a name="l03932"></a>03932 
<a name="l03933"></a>03933                 res_id = &amp;lod_env_info(env)-&gt;lti_res_id;
<a name="l03934"></a>03934                 fid_build_reg_res_name(lu_object_fid(&amp;lo-&gt;ldo_stripe[i]-&gt;do_lu),
<a name="l03935"></a>03935                                        res_id);
<a name="l03936"></a>03936                 einfo-&gt;ei_res_id = res_id;
<a name="l03937"></a>03937 
<a name="l03938"></a>03938                 LASSERT(lo-&gt;ldo_stripe[i] != NULL);
<a name="l03939"></a>03939                 <span class="keywordflow">if</span> (likely(dt_object_remote(lo-&gt;ldo_stripe[i]))) {
<a name="l03940"></a>03940                         rc = dt_object_lock(env, lo-&gt;ldo_stripe[i], &amp;lockh,
<a name="l03941"></a>03941                                             einfo, policy);
<a name="l03942"></a>03942                 } <span class="keywordflow">else</span> {
<a name="l03943"></a>03943                         <span class="keyword">struct </span><a class="code" href="structldlm__namespace.html" title="LDLM Namespace.">ldlm_namespace</a> *ns = einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#abb00c3085d1654b9fd3cf6842ff82e60" title="Data to be passed into callbacks.">ei_namespace</a>;
<a name="l03944"></a>03944                         <a class="code" href="group__LDLM.html#gac111233b56bdf7a4767dcd7a2f15b378" title="Type for blocking callback function of a lock.">ldlm_blocking_callback</a> blocking = einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#a24cf0bf24a24a88c75acbddc1d61b33f" title="blocking lock callback">ei_cb_local_bl</a>;
<a name="l03945"></a>03945                         <a class="code" href="group__LDLM.html#gac03b996dc38f767ddd9b2f5ae779b257" title="Type for completion callback function of a lock.">ldlm_completion_callback</a> completion = einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#a08e843216d2e582b026fb5379fac9814" title="blocking local lock callback">ei_cb_cp</a>;
<a name="l03946"></a>03946                         __u64   dlmflags = <a class="code" href="group__LDLM.html#gaf5ca91a80dd3fc578d5a9fc7fb815b74" title="optimization hint: LDLM can run blocking callback from current context w/o involving...">LDLM_FL_ATOMIC_CB</a>;
<a name="l03947"></a>03947 
<a name="l03948"></a>03948                         <span class="keywordflow">if</span> (einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a> == LCK_PW ||
<a name="l03949"></a>03949                             einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a> == LCK_EX)
<a name="l03950"></a>03950                                 dlmflags |= <a class="code" href="group__LDLM.html#ga0b1ea8608da80462dc9948160ebe5cdc" title="Flag whether a lock is enqueued from a distributed transaction, and the requesting...">LDLM_FL_COS_INCOMPAT</a>;
<a name="l03951"></a>03951 
<a name="l03952"></a>03952                         <span class="comment">/* This only happens if there are mulitple stripes</span>
<a name="l03953"></a>03953 <span class="comment">                         * on the master MDT, i.e. except stripe0, there are</span>
<a name="l03954"></a>03954 <span class="comment">                         * other stripes on the Master MDT as well, Only</span>
<a name="l03955"></a>03955 <span class="comment">                         * happens in the test case right now. */</span>
<a name="l03956"></a>03956                         LASSERT(ns != NULL);
<a name="l03957"></a>03957                         rc = <a class="code" href="group__ldlm__cli__api.html#ga1fc673f7fb2c06baaa796f09afc33487" title="Enqueue a local lock (typically on a server).">ldlm_cli_enqueue_local</a>(ns, res_id, LDLM_IBITS,
<a name="l03958"></a>03958                                                     policy, einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a>,
<a name="l03959"></a>03959                                                     &amp;dlmflags, blocking,
<a name="l03960"></a>03960                                                     completion, NULL,
<a name="l03961"></a>03961                                                     NULL, 0, LVB_T_NONE,
<a name="l03962"></a>03962                                                     NULL, &amp;lockh);
<a name="l03963"></a>03963                 }
<a name="l03964"></a>03964                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03965"></a>03965                         GOTO(out, rc);
<a name="l03966"></a>03966                 slave_locks-&gt;handles[i] = lockh;
<a name="l03967"></a>03967         }
<a name="l03968"></a>03968 
<a name="l03969"></a>03969         einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af0ba62d8b646a2164ec979fb9bca48d4" title="lock glimpse callback">ei_cbdata</a> = slave_locks;
<a name="l03970"></a>03970 
<a name="l03971"></a>03971 out:
<a name="l03972"></a>03972         <span class="keywordflow">if</span> (rc != 0 &amp;&amp; slave_locks != NULL) {
<a name="l03973"></a>03973                 einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af0ba62d8b646a2164ec979fb9bca48d4" title="lock glimpse callback">ei_cbdata</a> = slave_locks;
<a name="l03974"></a>03974                 lod_object_unlock_internal(env, dt, einfo, policy);
<a name="l03975"></a>03975                 OBD_FREE(slave_locks, slave_locks_size);
<a name="l03976"></a>03976                 einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af0ba62d8b646a2164ec979fb9bca48d4" title="lock glimpse callback">ei_cbdata</a> = NULL;
<a name="l03977"></a>03977         }
<a name="l03978"></a>03978 
<a name="l03979"></a>03979         RETURN(rc);
<a name="l03980"></a>03980 }
<a name="l03981"></a>03981 
<a name="l03982"></a>03982 <span class="keyword">struct </span><a class="code" href="structdt__object__operations.html" title="A dt_object provides common operations to create and destroy objects and to manage...">dt_object_operations</a> lod_obj_ops = {
<a name="l03983"></a>03983         .<a class="code" href="structdt__object__operations.html#a32a37f3abca0903ec9fa5c70b2b7a423" title="Get read lock on object.">do_read_lock</a>           = lod_object_read_lock,
<a name="l03984"></a>03984         .do_write_lock          = lod_object_write_lock,
<a name="l03985"></a>03985         .do_read_unlock         = lod_object_read_unlock,
<a name="l03986"></a>03986         .do_write_unlock        = lod_object_write_unlock,
<a name="l03987"></a>03987         .do_write_locked        = lod_object_write_locked,
<a name="l03988"></a>03988         .do_attr_get            = lod_attr_get,
<a name="l03989"></a>03989         .do_declare_attr_set    = lod_declare_attr_set,
<a name="l03990"></a>03990         .do_attr_set            = lod_attr_set,
<a name="l03991"></a>03991         .do_xattr_get           = lod_xattr_get,
<a name="l03992"></a>03992         .do_declare_xattr_set   = lod_declare_xattr_set,
<a name="l03993"></a>03993         .do_xattr_set           = lod_xattr_set,
<a name="l03994"></a>03994         .do_declare_xattr_del   = lod_declare_xattr_del,
<a name="l03995"></a>03995         .do_xattr_del           = lod_xattr_del,
<a name="l03996"></a>03996         .do_xattr_list          = lod_xattr_list,
<a name="l03997"></a>03997         .do_ah_init             = lod_ah_init,
<a name="l03998"></a>03998         .do_declare_create      = lod_declare_object_create,
<a name="l03999"></a>03999         .do_create              = lod_object_create,
<a name="l04000"></a>04000         .do_declare_destroy     = lod_declare_object_destroy,
<a name="l04001"></a>04001         .do_destroy             = lod_object_destroy,
<a name="l04002"></a>04002         .do_index_try           = lod_index_try,
<a name="l04003"></a>04003         .do_declare_ref_add     = lod_declare_ref_add,
<a name="l04004"></a>04004         .do_ref_add             = lod_ref_add,
<a name="l04005"></a>04005         .do_declare_ref_del     = lod_declare_ref_del,
<a name="l04006"></a>04006         .do_ref_del             = lod_ref_del,
<a name="l04007"></a>04007         .do_object_sync         = lod_object_sync,
<a name="l04008"></a>04008         .do_object_lock         = lod_object_lock,
<a name="l04009"></a>04009         .do_object_unlock       = lod_object_unlock,
<a name="l04010"></a>04010 };
<a name="l04011"></a>04011 
<a name="l04017"></a>04017 <span class="keyword">static</span> ssize_t lod_read(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l04018"></a>04018                         <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf, loff_t *pos)
<a name="l04019"></a>04019 {
<a name="l04020"></a>04020         <span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *next = dt_object_child(dt);
<a name="l04021"></a>04021         <span class="keywordflow">return</span> next-&gt;do_body_ops-&gt;<a class="code" href="structdt__body__operations.html#a6d7a363128fd4899b709b2ff18afd54c" title="Read data.">dbo_read</a>(env, next, buf, pos);
<a name="l04022"></a>04022 }
<a name="l04023"></a>04023 
<a name="l04030"></a>04030 <span class="keyword">static</span> ssize_t lod_declare_write(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l04031"></a>04031                                  <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l04032"></a>04032                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf, loff_t pos,
<a name="l04033"></a>04033                                  <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l04034"></a>04034 {
<a name="l04035"></a>04035         <span class="keywordflow">return</span> lod_sub_object_declare_write(env, dt_object_child(dt), buf, pos,
<a name="l04036"></a>04036                                             th);
<a name="l04037"></a>04037 }
<a name="l04038"></a>04038 
<a name="l04044"></a>04044 <span class="keyword">static</span> ssize_t lod_write(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l04045"></a>04045                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__buf.html" title="Common buffer structure to be passed around for various xattr_{s,g}et() methods.">lu_buf</a> *buf, loff_t *pos,
<a name="l04046"></a>04046                          <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th, <span class="keywordtype">int</span> iq)
<a name="l04047"></a>04047 {
<a name="l04048"></a>04048         <span class="keywordflow">return</span> lod_sub_object_write(env, dt_object_child(dt), buf, pos, th, iq);
<a name="l04049"></a>04049 }
<a name="l04050"></a>04050 
<a name="l04051"></a>04051 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_declare_punch(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l04052"></a>04052                              __u64 start, __u64 end, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l04053"></a>04053 {
<a name="l04054"></a>04054         <span class="keywordflow">if</span> (dt_object_remote(dt))
<a name="l04055"></a>04055                 <span class="keywordflow">return</span> -ENOTSUPP;
<a name="l04056"></a>04056 
<a name="l04057"></a>04057         <span class="keywordflow">return</span> lod_sub_object_declare_punch(env, dt_object_child(dt), start,
<a name="l04058"></a>04058                                             end, th);
<a name="l04059"></a>04059 }
<a name="l04060"></a>04060 
<a name="l04061"></a>04061 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_punch(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structdt__object.html">dt_object</a> *dt,
<a name="l04062"></a>04062                      __u64 start, __u64 end, <span class="keyword">struct</span> <a class="code" href="structthandle.html" title="This is the general purpose transaction handle.">thandle</a> *th)
<a name="l04063"></a>04063 {
<a name="l04064"></a>04064         <span class="keywordflow">if</span> (dt_object_remote(dt))
<a name="l04065"></a>04065                 <span class="keywordflow">return</span> -ENOTSUPP;
<a name="l04066"></a>04066 
<a name="l04067"></a>04067         <span class="keywordflow">return</span> lod_sub_object_punch(env, dt_object_child(dt), start, end, th);
<a name="l04068"></a>04068 }
<a name="l04069"></a>04069 
<a name="l04070"></a>04070 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__body__operations.html" title="Per-dt-object operations on &amp;quot;file body&amp;quot; - unstructure raw data.">dt_body_operations</a> lod_body_lnk_ops = {
<a name="l04071"></a>04071         .<a class="code" href="structdt__body__operations.html#a6d7a363128fd4899b709b2ff18afd54c" title="Read data.">dbo_read</a>               = lod_read,
<a name="l04072"></a>04072         .dbo_declare_write      = lod_declare_write,
<a name="l04073"></a>04073         .dbo_write              = lod_write
<a name="l04074"></a>04074 };
<a name="l04075"></a>04075 
<a name="l04076"></a>04076 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdt__body__operations.html" title="Per-dt-object operations on &amp;quot;file body&amp;quot; - unstructure raw data.">dt_body_operations</a> lod_body_ops = {
<a name="l04077"></a>04077         .<a class="code" href="structdt__body__operations.html#a6d7a363128fd4899b709b2ff18afd54c" title="Read data.">dbo_read</a>               = lod_read,
<a name="l04078"></a>04078         .dbo_declare_write      = lod_declare_write,
<a name="l04079"></a>04079         .dbo_write              = lod_write,
<a name="l04080"></a>04080         .dbo_declare_punch      = lod_declare_punch,
<a name="l04081"></a>04081         .dbo_punch              = lod_punch,
<a name="l04082"></a>04082 };
<a name="l04083"></a>04083 
<a name="l04095"></a>04095 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *lo,
<a name="l04096"></a>04096                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object__conf.html" title="Object configuration, describing particulars of object being created.">lu_object_conf</a> *conf)
<a name="l04097"></a>04097 {
<a name="l04098"></a>04098         <span class="keyword">struct </span><a class="code" href="structlod__device.html">lod_device</a>       *lod    = lu2lod_dev(lo-&gt;<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l04099"></a>04099         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a>        *cdev   = NULL;
<a name="l04100"></a>04100         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *cobj;
<a name="l04101"></a>04101         <span class="keyword">struct </span><a class="code" href="structlod__tgt__descs.html">lod_tgt_descs</a>    *ltd    = NULL;
<a name="l04102"></a>04102         <span class="keyword">struct </span><a class="code" href="structlod__tgt__desc.html">lod_tgt_desc</a>     *tgt;
<a name="l04103"></a>04103         u32                      idx    = 0;
<a name="l04104"></a>04104         <span class="keywordtype">int</span>                      type   = LU_SEQ_RANGE_ANY;
<a name="l04105"></a>04105         <span class="keywordtype">int</span>                      rc;
<a name="l04106"></a>04106         ENTRY;
<a name="l04107"></a>04107 
<a name="l04108"></a>04108         rc = lod_fld_lookup(env, lod, lu_object_fid(lo), &amp;idx, &amp;type);
<a name="l04109"></a>04109         <span class="keywordflow">if</span> (rc != 0) {
<a name="l04110"></a>04110                 <span class="comment">/* Note: Sometimes, it will Return EAGAIN here, see</span>
<a name="l04111"></a>04111 <span class="comment">                 * ptrlpc_import_delay_req(), which might confuse</span>
<a name="l04112"></a>04112 <span class="comment">                 * lu_object_find_at() and make it wait there incorrectly.</span>
<a name="l04113"></a>04113 <span class="comment">                 * so we convert it to EIO here.*/</span>
<a name="l04114"></a>04114                 <span class="keywordflow">if</span> (rc == -EAGAIN)
<a name="l04115"></a>04115                         rc = -EIO;
<a name="l04116"></a>04116 
<a name="l04117"></a>04117                 RETURN(rc);
<a name="l04118"></a>04118         }
<a name="l04119"></a>04119 
<a name="l04120"></a>04120         <span class="keywordflow">if</span> (type == LU_SEQ_RANGE_MDT &amp;&amp;
<a name="l04121"></a>04121             idx == lu_site2seq(lo-&gt;<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>)-&gt;ss_node_id) {
<a name="l04122"></a>04122                 cdev = &amp;lod-&gt;lod_child-&gt;dd_lu_dev;
<a name="l04123"></a>04123         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LU_SEQ_RANGE_MDT) {
<a name="l04124"></a>04124                 ltd = &amp;lod-&gt;lod_mdt_descs;
<a name="l04125"></a>04125                 lod_getref(ltd);
<a name="l04126"></a>04126         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LU_SEQ_RANGE_OST) {
<a name="l04127"></a>04127                 ltd = &amp;lod-&gt;lod_ost_descs;
<a name="l04128"></a>04128                 lod_getref(ltd);
<a name="l04129"></a>04129         } <span class="keywordflow">else</span> {
<a name="l04130"></a>04130                 LBUG();
<a name="l04131"></a>04131         }
<a name="l04132"></a>04132 
<a name="l04133"></a>04133         <span class="keywordflow">if</span> (ltd != NULL) {
<a name="l04134"></a>04134                 <span class="keywordflow">if</span> (ltd-&gt;ltd_tgts_size &gt; idx &amp;&amp;
<a name="l04135"></a>04135                     cfs_bitmap_check(ltd-&gt;ltd_tgt_bitmap, idx)) {
<a name="l04136"></a>04136                         tgt = LTD_TGT(ltd, idx);
<a name="l04137"></a>04137 
<a name="l04138"></a>04138                         LASSERT(tgt != NULL);
<a name="l04139"></a>04139                         LASSERT(tgt-&gt;ltd_tgt != NULL);
<a name="l04140"></a>04140 
<a name="l04141"></a>04141                         cdev = &amp;(tgt-&gt;ltd_tgt-&gt;dd_lu_dev);
<a name="l04142"></a>04142                 }
<a name="l04143"></a>04143                 lod_putref(lod, ltd);
<a name="l04144"></a>04144         }
<a name="l04145"></a>04145 
<a name="l04146"></a>04146         <span class="keywordflow">if</span> (unlikely(cdev == NULL))
<a name="l04147"></a>04147                 RETURN(-ENOENT);
<a name="l04148"></a>04148 
<a name="l04149"></a>04149         cobj = cdev-&gt;<a class="code" href="structlu__device.html#a4cab097ca33e55a7255ad1d848596827" title="Operation vector for this device.">ld_ops</a>-&gt;<a class="code" href="structlu__device__operations.html#a2d0d0803131da38c837d16ab6f979fb0" title="Allocate object for the given device (without lower-layer parts).">ldo_object_alloc</a>(env, lo-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>, cdev);
<a name="l04150"></a>04150         <span class="keywordflow">if</span> (unlikely(cobj == NULL))
<a name="l04151"></a>04151                 RETURN(-ENOMEM);
<a name="l04152"></a>04152 
<a name="l04153"></a>04153         <a class="code" href="group__lu.html#gaa0c00da42f82361409215468e0952e37" title="Add object o as a layer of compound object, going after before.">lu_object_add</a>(lo, cobj);
<a name="l04154"></a>04154 
<a name="l04155"></a>04155         RETURN(0);
<a name="l04156"></a>04156 }
<a name="l04157"></a>04157 
<a name="l04168"></a>04168 <span class="keywordtype">void</span> lod_object_free_striping(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlod__object.html">lod_object</a> *lo)
<a name="l04169"></a>04169 {
<a name="l04170"></a>04170         <span class="keywordtype">int</span> i;
<a name="l04171"></a>04171 
<a name="l04172"></a>04172         <span class="keywordflow">if</span> (lo-&gt;ldo_dir_stripe != NULL) {
<a name="l04173"></a>04173                 OBD_FREE_PTR(lo-&gt;ldo_dir_stripe);
<a name="l04174"></a>04174                 lo-&gt;ldo_dir_stripe = NULL;
<a name="l04175"></a>04175         }
<a name="l04176"></a>04176 
<a name="l04177"></a>04177         <span class="keywordflow">if</span> (lo-&gt;ldo_stripe) {
<a name="l04178"></a>04178                 LASSERT(lo-&gt;ldo_stripes_allocated &gt; 0);
<a name="l04179"></a>04179 
<a name="l04180"></a>04180                 <span class="keywordflow">for</span> (i = 0; i &lt; lo-&gt;ldo_stripenr; i++) {
<a name="l04181"></a>04181                         <span class="keywordflow">if</span> (lo-&gt;ldo_stripe[i])
<a name="l04182"></a>04182                                 <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, &amp;lo-&gt;ldo_stripe[i]-&gt;do_lu);
<a name="l04183"></a>04183                 }
<a name="l04184"></a>04184 
<a name="l04185"></a>04185                 i = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structdt__object.html">dt_object</a> *) * lo-&gt;ldo_stripes_allocated;
<a name="l04186"></a>04186                 OBD_FREE(lo-&gt;ldo_stripe, i);
<a name="l04187"></a>04187                 lo-&gt;ldo_stripe = NULL;
<a name="l04188"></a>04188                 lo-&gt;ldo_stripes_allocated = 0;
<a name="l04189"></a>04189         }
<a name="l04190"></a>04190         lo-&gt;ldo_striping_cached = 0;
<a name="l04191"></a>04191         lo-&gt;ldo_stripenr = 0;
<a name="l04192"></a>04192         lo-&gt;ldo_pattern = 0;
<a name="l04193"></a>04193 }
<a name="l04194"></a>04194 
<a name="l04201"></a>04201 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_start(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *o)
<a name="l04202"></a>04202 {
<a name="l04203"></a>04203         <span class="keywordflow">if</span> (S_ISLNK(o-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a> &amp; S_IFMT)) {
<a name="l04204"></a>04204                 lu2lod_obj(o)-&gt;ldo_obj.do_body_ops = &amp;lod_body_lnk_ops;
<a name="l04205"></a>04205         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (S_ISREG(o-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#afa57247d82217d07baf45d8e2f68c498" title="Common object attributes, cached for efficiency.">loh_attr</a> &amp; S_IFMT) ||
<a name="l04206"></a>04206                    fid_is_local_file(lu_object_fid(o))) {
<a name="l04207"></a>04207                 <span class="comment">/* Note: some local file (like last rcvd) is created</span>
<a name="l04208"></a>04208 <span class="comment">                 * through bottom layer (OSD), so the object initialization</span>
<a name="l04209"></a>04209 <span class="comment">                 * comes to lod, it does not set loh_attr yet, so</span>
<a name="l04210"></a>04210 <span class="comment">                 * set do_body_ops for local file anyway */</span>
<a name="l04211"></a>04211                 lu2lod_obj(o)-&gt;ldo_obj.do_body_ops = &amp;lod_body_ops;
<a name="l04212"></a>04212         }
<a name="l04213"></a>04213         <span class="keywordflow">return</span> 0;
<a name="l04214"></a>04214 }
<a name="l04215"></a>04215 
<a name="l04222"></a>04222 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_object_free(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *o)
<a name="l04223"></a>04223 {
<a name="l04224"></a>04224         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *mo = lu2lod_obj(o);
<a name="l04225"></a>04225 
<a name="l04226"></a>04226         <span class="comment">/*</span>
<a name="l04227"></a>04227 <span class="comment">         * release all underlying object pinned</span>
<a name="l04228"></a>04228 <span class="comment">         */</span>
<a name="l04229"></a>04229 
<a name="l04230"></a>04230         lod_object_free_striping(env, mo);
<a name="l04231"></a>04231 
<a name="l04232"></a>04232         lod_object_set_pool(mo, NULL);
<a name="l04233"></a>04233 
<a name="l04234"></a>04234         <a class="code" href="group__lu.html#ga0318f3c931fb2457b0cc4365c15611ca" title="Finalize object and release its resources.">lu_object_fini</a>(o);
<a name="l04235"></a>04235         OBD_SLAB_FREE_PTR(mo, lod_object_kmem);
<a name="l04236"></a>04236 }
<a name="l04237"></a>04237 
<a name="l04244"></a>04244 <span class="keyword">static</span> <span class="keywordtype">void</span> lod_object_release(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *o)
<a name="l04245"></a>04245 {
<a name="l04246"></a>04246         <span class="comment">/* XXX: shouldn&apos;t we release everything here in case if object</span>
<a name="l04247"></a>04247 <span class="comment">         * creation failed before? */</span>
<a name="l04248"></a>04248 }
<a name="l04249"></a>04249 
<a name="l04256"></a>04256 <span class="keyword">static</span> <span class="keywordtype">int</span> lod_object_print(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">void</span> *cookie,
<a name="l04257"></a>04257                             <a class="code" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc" title="Type of &amp;quot;printer&amp;quot; function used by lu_object_operations::loo_object_print()...">lu_printer_t</a> p, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *l)
<a name="l04258"></a>04258 {
<a name="l04259"></a>04259         <span class="keyword">struct </span><a class="code" href="structlod__object.html">lod_object</a> *o = lu2lod_obj((<span class="keyword">struct</span> <a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> *) l);
<a name="l04260"></a>04260 
<a name="l04261"></a>04261         <span class="keywordflow">return</span> (*p)(env, cookie, LUSTRE_LOD_NAME<span class="stringliteral">&quot;-object@%p&quot;</span>, o);
<a name="l04262"></a>04262 }
<a name="l04263"></a>04263 
<a name="l04264"></a>04264 <span class="keyword">struct </span><a class="code" href="structlu__object__operations.html" title="Operations specific for particular lu_object.">lu_object_operations</a> lod_lu_obj_ops = {
<a name="l04265"></a>04265         .<a class="code" href="structlu__object__operations.html#a15b69dd7ca43e31bee4023da49fbb8a8" title="Allocate lower-layer parts of the object by calling lu_device_operations::ldo_object_alloc()...">loo_object_init</a>        = lod_object_init,
<a name="l04266"></a>04266         .loo_object_start       = lod_object_start,
<a name="l04267"></a>04267         .loo_object_free        = lod_object_free,
<a name="l04268"></a>04268         .loo_object_release     = lod_object_release,
<a name="l04269"></a>04269         .loo_object_print       = lod_object_print,
<a name="l04270"></a>04270 };
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:16 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
