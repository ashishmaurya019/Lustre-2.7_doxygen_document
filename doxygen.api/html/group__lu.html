<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lu</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lu</h1>
<p>lu_* data-types represent server-side entities shared by data and meta-data stacks.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__device__operations.html">lu_device_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operations common for data and meta-data devices.  <a href="structlu__device__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__object__conf.html">lu_object_conf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object configuration, describing particulars of object being created.  <a href="structlu__object__conf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__object__operations.html">lu_object_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operations specific for particular <a class="el" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>.  <a href="structlu__object__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__device.html">lu_device</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device: a layer in the server side abstraction stacking.  <a href="structlu__device.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__device__type.html">lu_device_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of device.  <a href="structlu__device__type.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__device__type__operations.html">lu_device_type_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operations on a device type.  <a href="structlu__device__type__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__attr.html">lu_attr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common object attributes.  <a href="structlu__attr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__object.html">lu_object</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Layer in the layered object.  <a href="structlu__object.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__object__header.html">lu_object_header</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Compound" object, consisting of multiple layers.  <a href="structlu__object__header.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__site__bkt__data.html">lu_site_bkt_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__site.html">lu_site</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structlu__site.html" title="lu_site is a &quot;compartment&quot; within which objects are unique, and LRU discipline...">lu_site</a> is a "compartment" within which objects are unique, and LRU discipline is maintained.  <a href="structlu__site.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__rdpg.html">lu_rdpg</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">input params, should be filled out by mdt  <a href="structlu__rdpg.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context.html">lu_context</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structlu__context.html" title="lu_context.">lu_context</a>.  <a href="structlu__context.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__context__key.html">lu_context_key</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Key.  <a href="structlu__context__key.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__env.html">lu_env</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Environment.  <a href="structlu__env.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__name.html">lu_name</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common name structure to be passed around for various name related methods.  <a href="structlu__name.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__buf.html">lu_buf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common buffer structure to be passed around for various xattr_{s,g}et() methods.  <a href="structlu__buf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__rdbuf.html">lu_rdbuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlu__kmem__descr.html">lu_kmem_descr</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0e2b6cca5a8b80e840f4bfea4e3fae66"></a><!-- doxytag: member="lu::DNAME" ref="ga0e2b6cca5a8b80e840f4bfea4e3fae66" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DNAME</b>&nbsp;&nbsp;&nbsp;&quot;%.*s&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PNAME</b>(ln)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2e4fa17a26706e5f8fb3ec01bb9ac3a9"></a><!-- doxytag: member="lu::DLUBUF" ref="ga2e4fa17a26706e5f8fb3ec01bb9ac3a9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DLUBUF</b>&nbsp;&nbsp;&nbsp;&quot;(%p %zu)&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73e196e890e8a111101a8e9b4a3fa43c"></a><!-- doxytag: member="lu::PLUBUF" ref="ga73e196e890e8a111101a8e9b4a3fa43c" args="(buf)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PLUBUF</b>(buf)&nbsp;&nbsp;&nbsp;(buf)-&gt;lb_buf, (buf)-&gt;lb_len</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, const char *format,...) __attribute__((format(printf</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of "printer" function used by <a class="el" href="structlu__object__operations.html#acf091707006dc9d8d216351834d8d974" title="Optional debugging helper.">lu_object_operations::loo_object_print()</a> method.  <a href="#gac8ccca21472f6dc3ea91d73983740fdc"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga58f82afcd61f0bd5c9e35ad9940514b7">loc_flags_t</a> { <b>LOC_F_NEW</b> =  0x00000001, 
<b>LOC_F_NOWAIT</b> =  0x00000002
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>For <a class="el" href="structlu__object__conf.html" title="Object configuration, describing particulars of object being created.">lu_object_conf</a> flags. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gaa318f5b20c40de1d564f59dd72726345">lu_device_tag</a> { <a class="el" href="group__lu.html#ggaa318f5b20c40de1d564f59dd72726345a2a083e23924356952e08900b8a278798">LU_DEVICE_MD</a> =  (1 &lt;&lt; 0), 
<a class="el" href="group__lu.html#ggaa318f5b20c40de1d564f59dd72726345a5b8da75da353b465f5ddc30d87c931d9">LU_DEVICE_DT</a> =  (1 &lt;&lt; 1), 
<a class="el" href="group__lu.html#ggaa318f5b20c40de1d564f59dd72726345a6950d6daf539cb6aa3902679e6232783">LU_DEVICE_CL</a> =  (1 &lt;&lt; 2)
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Tag bits for device type. </p>
 <a href="group__lu.html#gaa318f5b20c40de1d564f59dd72726345">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga88a0b6df60974746bbc3b1a79da159a8">la_valid</a> { <br/>
&nbsp;&nbsp;<b>LA_ATIME</b> =  1 &lt;&lt; 0, 
<b>LA_MTIME</b> =  1 &lt;&lt; 1, 
<b>LA_CTIME</b> =  1 &lt;&lt; 2, 
<b>LA_SIZE</b> =  1 &lt;&lt; 3, 
<br/>
&nbsp;&nbsp;<b>LA_MODE</b> =  1 &lt;&lt; 4, 
<b>LA_UID</b> =  1 &lt;&lt; 5, 
<b>LA_GID</b> =  1 &lt;&lt; 6, 
<b>LA_BLOCKS</b> =  1 &lt;&lt; 7, 
<br/>
&nbsp;&nbsp;<b>LA_TYPE</b> =  1 &lt;&lt; 8, 
<b>LA_FLAGS</b> =  1 &lt;&lt; 9, 
<b>LA_NLINK</b> =  1 &lt;&lt; 10, 
<b>LA_RDEV</b> =  1 &lt;&lt; 11, 
<br/>
&nbsp;&nbsp;<b>LA_BLKSIZE</b> =  1 &lt;&lt; 12, 
<b>LA_KILL_SUID</b> =  1 &lt;&lt; 13, 
<b>LA_KILL_SGID</b> =  1 &lt;&lt; 14
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Bit-mask of valid attributes. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga519a2e6103ae639c8df1777d311cc985">lu_object_header_flags</a> { <a class="el" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985aca9a04f530d5436e7996a1ff142d01d0">LU_OBJECT_HEARD_BANSHEE</a> =  0, 
<a class="el" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985a5d6ad2787701c40ef595e1ccdb31ae45">LU_OBJECT_UNHASHED</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga58c79a7f6f5084aec5768a45526117dd">lu_object_header_attr</a> { <b>LOHA_EXISTS</b> =  1 &lt;&lt; 0, 
<b>LOHA_REMOTE</b> =  1 &lt;&lt; 1, 
<a class="el" href="group__lu.html#gga58c79a7f6f5084aec5768a45526117dda019e56dd8ff22350e1e002f92c9040ae">LOHA_FT_START</a> =  001 &lt;&lt; 12, 
<a class="el" href="group__lu.html#gga58c79a7f6f5084aec5768a45526117dda00cbfb5eebcc3d9c9c71040c957049ae">LOHA_FT_END</a> =  017 &lt;&lt; 12
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<b>LU_SS_CREATED</b> =  0, 
<b>LU_SS_CACHE_HIT</b>, 
<b>LU_SS_CACHE_MISS</b>, 
<b>LU_SS_CACHE_RACE</b>, 
<br/>
&nbsp;&nbsp;<b>LU_SS_CACHE_DEATH_RACE</b>, 
<b>LU_SS_LRU_PURGED</b>, 
<b>LU_SS_LRU_LEN</b>, 
<b>LU_SS_LAST_STAT</b>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gaab0f4c7f840a5d798e5a4f23d68abacd">lu_site_stats_seq_print</a> (const struct <a class="el" href="structlu__site.html">lu_site</a> *s, struct seq_file *m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output site statistical counters into a buffer.  <a href="#gaab0f4c7f840a5d798e5a4f23d68abacd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga25ead0509e25dab69f6c92ac1c465ce4">lu_global_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One-time initializers, called at obdclass module initialization, not exported.  <a href="#ga25ead0509e25dab69f6c92ac1c465ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga342d9d23d96d691f49863e21af40bbcd"></a><!-- doxytag: member="lu::lu_global_fini" ref="ga342d9d23d96d691f49863e21af40bbcd" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga342d9d23d96d691f49863e21af40bbcd">lu_global_fini</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dual to <a class="el" href="group__lu.html#ga25ead0509e25dab69f6c92ac1c465ce4" title="One-time initializers, called at obdclass module initialization, not exported.">lu_global_init()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga42de365ae8cbdaa97c604434937a4822"></a><!-- doxytag: member="lu::lu_kmem_init" ref="ga42de365ae8cbdaa97c604434937a4822" args="(struct lu_kmem_descr *caches)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga42de365ae8cbdaa97c604434937a4822">lu_kmem_init</a> (struct <a class="el" href="structlu__kmem__descr.html">lu_kmem_descr</a> *caches)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to initialize a number of kmem slab caches at once. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gac3834e0d4bd35c8a02d1003bf0f4331e">lu_kmem_fini</a> (struct <a class="el" href="structlu__kmem__descr.html">lu_kmem_descr</a> *caches)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to finalize a number of kmem slab cached at once.  <a href="#gac3834e0d4bd35c8a02d1003bf0f4331e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a39fd9c13b1d51b9382e40f327c626c"></a><!-- doxytag: member="lu::lu_object_assign_fid" ref="ga4a39fd9c13b1d51b9382e40f327c626c" args="(const struct lu_env *env, struct lu_object *o, const struct lu_fid *fid)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga4a39fd9c13b1d51b9382e40f327c626c">lu_object_assign_fid</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__object.html">lu_object</a> *o, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *fid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporary solution to be able to assign fid in -&gt;do_create() till we have fully-functional OST fids. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6ce21735ba52faf216eb2c67d5421d0"></a><!-- doxytag: member="lu::lu_object_anon" ref="gad6ce21735ba52faf216eb2c67d5421d0" args="(const struct lu_env *env, struct lu_device *dev, const struct lu_object_conf *conf)" -->
struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gad6ce21735ba52faf216eb2c67d5421d0">lu_object_anon</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__device.html">lu_device</a> *dev, const struct <a class="el" href="structlu__object__conf.html">lu_object_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocates object with 0 (non-assiged) fid XXX: temporary solution to be able to assign fid in -&gt;do_create() till we have fully-functional OST fids <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0da614115486ed4d3c86f78998c0a3a"></a><!-- doxytag: member="lu::lu_buf_free" ref="gaf0da614115486ed4d3c86f78998c0a3a" args="(struct lu_buf *buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_buf_free</b> (struct <a class="el" href="structlu__buf.html">lu_buf</a> *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3dcfa560c2c09f18fe2ef139317d541"></a><!-- doxytag: member="lu::lu_buf_alloc" ref="gad3dcfa560c2c09f18fe2ef139317d541" args="(struct lu_buf *buf, size_t size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_buf_alloc</b> (struct <a class="el" href="structlu__buf.html">lu_buf</a> *buf, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56534298d2cf8fb62d6d87c7ba76b848"></a><!-- doxytag: member="lu::lu_buf_realloc" ref="ga56534298d2cf8fb62d6d87c7ba76b848" args="(struct lu_buf *buf, size_t size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_buf_realloc</b> (struct <a class="el" href="structlu__buf.html">lu_buf</a> *buf, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga3943d5092fca7667ef0d3a48764f84aa">lu_buf_check_and_grow</a> (struct <a class="el" href="structlu__buf.html">lu_buf</a> *buf, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase the size of the <em>buf</em>.  <a href="#ga3943d5092fca7667ef0d3a48764f84aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5091d615af18058ea9cf77ec076fefc9"></a><!-- doxytag: member="lu::lu_buf_check_and_alloc" ref="ga5091d615af18058ea9cf77ec076fefc9" args="(struct lu_buf *buf, size_t len)" -->
struct <a class="el" href="structlu__buf.html">lu_buf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_buf_check_and_alloc</b> (struct <a class="el" href="structlu__buf.html">lu_buf</a> *buf, size_t len)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3daaf59b14be927dc4227c6fc6635c6d"></a><!-- doxytag: member="lu::LU_BUF_NULL" ref="ga3daaf59b14be927dc4227c6fc6635c6d" args="" -->
struct <a class="el" href="structlu__buf.html">lu_buf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga3daaf59b14be927dc4227c6fc6635c6d">LU_BUF_NULL</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">null buffer <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gaac7bd33ed56770c84e26b4553c6d0078">lu_context_tags_default</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lu_ctx_tags/lu_ses_tags will be updated if there are new types of obd being added.  <a href="#gaac7bd33ed56770c84e26b4553c6d0078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29ff903a940eb687fc01d4c01866ee86"></a><!-- doxytag: member="lu::lu_session_tags_default" ref="ga29ff903a940eb687fc01d4c01866ee86" args="" -->
__u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_session_tags_default</b></td></tr>
<tr><td colspan="2"><h2>helpers</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpc2c3081275569a523f7b887c77722c5b"></a>Helpers. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_xattr_flags</b> { <b>LU_XATTR_REPLACE</b> =  (1 &lt;&lt; 0), 
<b>LU_XATTR_CREATE</b> =  (1 &lt;&lt; 1)
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee34b6396491c109bd66e4c055dd7189"></a><!-- doxytag: member="lu::lu_object_locate" ref="gaee34b6396491c109bd66e4c055dd7189" args="(struct lu_object_header *h, const struct lu_device_type *dtype)" -->
struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gaee34b6396491c109bd66e4c055dd7189">lu_object_locate</a> (struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *h, const struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *dtype)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a compound object, find its slice, corresponding to the device type <em>dtype</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea04856d0829f02ff6e8b5b957cd8a52"></a><!-- doxytag: member="lu::lu_cdebug_printer" ref="gaea04856d0829f02ff6e8b5b957cd8a52" args="(const struct lu_env *env, void *cookie, const char *format,...)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gaea04856d0829f02ff6e8b5b957cd8a52">lu_cdebug_printer</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, const char *format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Printer function emitting messages through libcfs_debug_msg(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac48202c869a59a25988a89207f85ef7f"></a><!-- doxytag: member="lu::lu_object_print" ref="gac48202c869a59a25988a89207f85ef7f" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct lu_object *o)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gac48202c869a59a25988a89207f85ef7f">lu_object_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structlu__object.html">lu_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print human readable representation of the <em>o</em> to the <em>printer</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac087f3906c58d3f36fc8765c101be34c"></a><!-- doxytag: member="lu::lu_object_header_print" ref="gac087f3906c58d3f36fc8765c101be34c" args="(const struct lu_env *env, void *cookie, lu_printer_t printer, const struct lu_object_header *hdr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gac087f3906c58d3f36fc8765c101be34c">lu_object_header_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer, const struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *hdr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print object header. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd5347c354cc994ca7eaf3ca7ade011b"></a><!-- doxytag: member="lu::lu_object_invariant" ref="gacd5347c354cc994ca7eaf3ca7ade011b" args="(const struct lu_object *o)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gacd5347c354cc994ca7eaf3ca7ade011b">lu_object_invariant</a> (const struct <a class="el" href="structlu__object.html">lu_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check object consistency. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gae0469b00c8c93e0c85eaacfabd33f6aa">LU_OBJECT_DEBUG</a>(mask, env, object, format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print object description followed by a user-supplied message.  <a href="#gae0469b00c8c93e0c85eaacfabd33f6aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gab6811b221fe08d6e5b46ce532fdd1059">LU_OBJECT_HEADER</a>(mask, env, object, format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print short object description followed by a user-supplied message.  <a href="#gab6811b221fe08d6e5b46ce532fdd1059"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gacef4aec6c28892e386a8d3cca26aeb28">lu_object_exists</a>(o)&nbsp;&nbsp;&nbsp;((o)-&gt;lo_header-&gt;loh_attr &amp; LOHA_EXISTS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether object exists, no matter on local or remote storage.  <a href="#gacef4aec6c28892e386a8d3cca26aeb28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f1244491405504cc9adcc3b6ce78a91"></a><!-- doxytag: member="lu::lu_object_remote" ref="ga3f1244491405504cc9adcc3b6ce78a91" args="(o)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga3f1244491405504cc9adcc3b6ce78a91">lu_object_remote</a>(o)&nbsp;&nbsp;&nbsp;unlikely((o)-&gt;lo_header-&gt;loh_attr &amp; LOHA_REMOTE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether object on the remote storage. <br/></td></tr>
<tr><td colspan="2"><h2>lu_context</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp518fd274dfbcbbf822f34177e01d6a7d"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gac56fa70640d169266a36bd75a951f182">lu_context_state</a> { <b>LCS_INITIALIZED</b> =  1, 
<b>LCS_ENTERED</b>, 
<b>LCS_LEFT</b>, 
<b>LCS_FINALIZED</b>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>For <a class="el" href="structlu__context.html" title="lu_context.">lu_context</a> health-checks. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gad7e2d14b1b91480b0b25656f63169a0a">lu_context_tag</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa51f264f8e3ea36a381cf8aaaa9672752">LCT_MD_THREAD</a> =  1 &lt;&lt; 0, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f">LCT_DT_THREAD</a> =  1 &lt;&lt; 1, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aae4ff6019628711d8f1dbefee9e3edfee">LCT_TX_HANDLE</a> =  1 &lt;&lt; 2, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d">LCT_CL_THREAD</a> =  1 &lt;&lt; 3, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa76aa3f8e745622ced47e2687d27c4b84">LCT_SESSION</a> =  1 &lt;&lt; 4, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa24dc5414c9f1420be38e18a84e730d10">LCT_OSP_THREAD</a> =  1 &lt;&lt; 5, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa582fa482375137187e808b1f5f8662d1">LCT_MG_THREAD</a> =  1 &lt;&lt; 6, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa87bf2c0c71c5af685cf15e809a7ed551">LCT_LOCAL</a> =  1 &lt;&lt; 7, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aabaed253be3089b461b48756c519b654a">LCT_SERVER_SESSION</a> =  1 &lt;&lt; 8, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa17f47648c605de40856da551f04fe939">LCT_HAS_EXIT</a> =  1 &lt;&lt; 28, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084">LCT_NOREF</a> =  1 &lt;&lt; 29, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa2ed29d3105c69b17fc8fb72de22cb719">LCT_QUIESCENT</a> =  1 &lt;&lt; 30, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e">LCT_REMEMBER</a> =  1 &lt;&lt; 31, 
<a class="el" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aadc9da0a8f1ca7e5e219fc2a482ca7fc1">LCT_SHRINKER</a> =  LCT_MD_THREAD|LCT_DT_THREAD|LCT_CL_THREAD|LCT_NOREF
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><a class="el" href="structlu__context__key.html" title="Key.">lu_context_key</a> interface. </p>
 <a href="group__lu.html#gad7e2d14b1b91480b0b25656f63169a0a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1eef6b147da5ae4489576e136772d404"></a><!-- doxytag: member="lu::lu_context_key_register" ref="ga1eef6b147da5ae4489576e136772d404" args="(struct lu_context_key *key)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga1eef6b147da5ae4489576e136772d404">lu_context_key_register</a> (struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register new key. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga6e069db37ac446fe47b8b211c3d721c5">lu_context_key_degister</a> (struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister key.  <a href="#ga6e069db37ac446fe47b8b211c3d721c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8fcebe57d8fb288a73a39144693074af"></a><!-- doxytag: member="lu::lu_context_key_get" ref="ga8fcebe57d8fb288a73a39144693074af" args="(const struct lu_context *ctx, const struct lu_context_key *key)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga8fcebe57d8fb288a73a39144693074af">lu_context_key_get</a> (const struct <a class="el" href="structlu__context.html">lu_context</a> *ctx, const struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return value associated with key <em>key</em> in context <em>ctx</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga26d0d8d30e9702d38f9d2e372d48002e">lu_context_key_quiesce</a> (struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy <em>key</em> in all remembered contexts.  <a href="#ga26d0d8d30e9702d38f9d2e372d48002e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga828c06d45a01242d5533f4d20c04ece0"></a><!-- doxytag: member="lu::lu_context_key_revive" ref="ga828c06d45a01242d5533f4d20c04ece0" args="(struct lu_context_key *key)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_context_key_revive</b> (struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga952ae50ec5c4d109d2afecbb90c59a5c">lu_context_init</a> (struct <a class="el" href="structlu__context.html">lu_context</a> *ctx, __u32 tags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize context data-structure.  <a href="#ga952ae50ec5c4d109d2afecbb90c59a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693">lu_context_fini</a> (struct <a class="el" href="structlu__context.html">lu_context</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize context data-structure.  <a href="#ga1d2df80dc90294622ca45338757e2693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf86fb0a5bf6a1dadec88844694e2ad31"></a><!-- doxytag: member="lu::lu_context_enter" ref="gaf86fb0a5bf6a1dadec88844694e2ad31" args="(struct lu_context *ctx)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gaf86fb0a5bf6a1dadec88844694e2ad31">lu_context_enter</a> (struct <a class="el" href="structlu__context.html">lu_context</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called before entering context. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85625901fefb6948280ff1e0d4778f61"></a><!-- doxytag: member="lu::lu_context_exit" ref="ga85625901fefb6948280ff1e0d4778f61" args="(struct lu_context *ctx)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61">lu_context_exit</a> (struct <a class="el" href="structlu__context.html">lu_context</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called after exiting from <em>ctx</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga00d029e31ae6e5f4edc94121d8bc4a45">lu_context_refill</a> (struct <a class="el" href="structlu__context.html">lu_context</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate for context all missing keys that were registered after context creation.  <a href="#ga00d029e31ae6e5f4edc94121d8bc4a45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gabc82bcbb2d0d7e41ec7965f71878a606">lu_context_key_register_many</a> (struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *k,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a number of keys.  <a href="#gabc82bcbb2d0d7e41ec7965f71878a606"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga3826a7e5b3ea78a0a1be49390c5efe18">lu_context_key_degister_many</a> (struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *k,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">De-register a number of keys.  <a href="#ga3826a7e5b3ea78a0a1be49390c5efe18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b7314b65026c1731f2384a0ac5242b4"></a><!-- doxytag: member="lu::lu_context_key_revive_many" ref="ga4b7314b65026c1731f2384a0ac5242b4" args="(struct lu_context_key *k,...)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga4b7314b65026c1731f2384a0ac5242b4">lu_context_key_revive_many</a> (struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *k,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Revive a number of keys. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga48615706cf5edca3013bafd6f2f22059"></a><!-- doxytag: member="lu::lu_context_key_quiesce_many" ref="ga48615706cf5edca3013bafd6f2f22059" args="(struct lu_context_key *k,...)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga48615706cf5edca3013bafd6f2f22059">lu_context_key_quiesce_many</a> (struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *k,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quiescent a number of keys. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabd24006e112d8dd82dd65b26f0f76d80"></a><!-- doxytag: member="lu::lu_context_tags_update" ref="gabd24006e112d8dd82dd65b26f0f76d80" args="(__u32 tags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_context_tags_update</b> (__u32 tags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab468e750b29c0ee58c6f3b49871f45e2"></a><!-- doxytag: member="lu::lu_context_tags_clear" ref="gab468e750b29c0ee58c6f3b49871f45e2" args="(__u32 tags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_context_tags_clear</b> (__u32 tags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0df2f1de98458c9cd5c381d30a630577"></a><!-- doxytag: member="lu::lu_session_tags_update" ref="ga0df2f1de98458c9cd5c381d30a630577" args="(__u32 tags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_session_tags_update</b> (__u32 tags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba0180d4ce56629c1ebb8f981d43c6ea"></a><!-- doxytag: member="lu::lu_session_tags_clear" ref="gaba0180d4ce56629c1ebb8f981d43c6ea" args="(__u32 tags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_session_tags_clear</b> (__u32 tags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72f58647251d2a508798b09afba9c70f"></a><!-- doxytag: member="lu::lu_env_init" ref="ga72f58647251d2a508798b09afba9c70f" args="(struct lu_env *env, __u32 tags)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_env_init</b> (struct <a class="el" href="structlu__env.html">lu_env</a> *env, __u32 tags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9ead00ad92e122b8ad944ffeab3120b5"></a><!-- doxytag: member="lu::lu_env_fini" ref="ga9ead00ad92e122b8ad944ffeab3120b5" args="(struct lu_env *env)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_env_fini</b> (struct <a class="el" href="structlu__env.html">lu_env</a> *env)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3149440dd27a5c2618f6f940fae4c806"></a><!-- doxytag: member="lu::lu_env_refill" ref="ga3149440dd27a5c2618f6f940fae4c806" args="(struct lu_env *env)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_env_refill</b> (struct <a class="el" href="structlu__env.html">lu_env</a> *env)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gae86c05e9998dce0a3860d0456394c559">lu_env_refill_by_tags</a> (struct <a class="el" href="structlu__env.html">lu_env</a> *env, __u32 ctags, __u32 stags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Currently, this API will only be used by echo client.  <a href="#gae86c05e9998dce0a3860d0456394c559"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_KEY_INIT</b>(mod, type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_KEY_FINI</b>(mod, type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_KEY_INIT_FINI</b>(mod, type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_CONTEXT_KEY_DEFINE</b>(mod, tags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_CONTEXT_KEY_INIT</b>(key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_KEY_INIT_GENERIC</b>(mod)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_TYPE_INIT</b>(mod,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_TYPE_FINI</b>(mod,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_TYPE_START</b>(mod,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_TYPE_STOP</b>(mod,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LU_TYPE_INIT_FINI</b>(mod,...)</td></tr>
<tr><td colspan="2"><h2>ctors</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbea1ef77345b88212d5640bd251c4c32"></a>Constructors/destructors. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3776a9c76adcfa00202f6fe19751c96e"></a><!-- doxytag: member="lu::lu_site_init" ref="ga3776a9c76adcfa00202f6fe19751c96e" args="(struct lu_site *s, struct lu_device *d)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga3776a9c76adcfa00202f6fe19751c96e">lu_site_init</a> (struct <a class="el" href="structlu__site.html">lu_site</a> *s, struct <a class="el" href="structlu__device.html">lu_device</a> *d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize site <em>s</em>, with <em>d</em> as the top level device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91afa048e05c24fbd176d46dbc676f61"></a><!-- doxytag: member="lu::lu_site_fini" ref="ga91afa048e05c24fbd176d46dbc676f61" args="(struct lu_site *s)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga91afa048e05c24fbd176d46dbc676f61">lu_site_fini</a> (struct <a class="el" href="structlu__site.html">lu_site</a> *s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize <em>s</em> and release its resources. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f089514e7db6f839ca9cb259a1eab14"></a><!-- doxytag: member="lu::lu_site_init_finish" ref="ga8f089514e7db6f839ca9cb259a1eab14" args="(struct lu_site *s)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga8f089514e7db6f839ca9cb259a1eab14">lu_site_init_finish</a> (struct <a class="el" href="structlu__site.html">lu_site</a> *s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when initialization of stack for this site is completed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gadaddcc81c2131ec1158c21f009cf1739">lu_stack_fini</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__device.html">lu_device</a> *top)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize and free devices in the device stack.  <a href="#gadaddcc81c2131ec1158c21f009cf1739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29fe0250f218e64064069bcc3116e481"></a><!-- doxytag: member="lu::lu_device_get" ref="ga29fe0250f218e64064069bcc3116e481" args="(struct lu_device *d)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga29fe0250f218e64064069bcc3116e481">lu_device_get</a> (struct <a class="el" href="structlu__device.html">lu_device</a> *d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire additional reference on device <em>d</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c86262bfddc5bac1777e7f6fefb35f0"></a><!-- doxytag: member="lu::lu_device_put" ref="ga2c86262bfddc5bac1777e7f6fefb35f0" args="(struct lu_device *d)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga2c86262bfddc5bac1777e7f6fefb35f0">lu_device_put</a> (struct <a class="el" href="structlu__device.html">lu_device</a> *d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release reference on device <em>d</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae86081b11fb167137740f999abf11b2c"></a><!-- doxytag: member="lu::lu_device_init" ref="gae86081b11fb167137740f999abf11b2c" args="(struct lu_device *d, struct lu_device_type *t)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gae86081b11fb167137740f999abf11b2c">lu_device_init</a> (struct <a class="el" href="structlu__device.html">lu_device</a> *d, struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize device <em>d</em> of type <em>t</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7ed7dca0b6932c93db6be738aea16dff"></a><!-- doxytag: member="lu::lu_device_fini" ref="ga7ed7dca0b6932c93db6be738aea16dff" args="(struct lu_device *d)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga7ed7dca0b6932c93db6be738aea16dff">lu_device_fini</a> (struct <a class="el" href="structlu__device.html">lu_device</a> *d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize device <em>d</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8106fbade6a4bdb30caea80d7daf11c"></a><!-- doxytag: member="lu::lu_object_header_init" ref="gaa8106fbade6a4bdb30caea80d7daf11c" args="(struct lu_object_header *h)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gaa8106fbade6a4bdb30caea80d7daf11c">lu_object_header_init</a> (struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize compound object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3c4db0a912275b2966df3ab46f01ca5"></a><!-- doxytag: member="lu::lu_object_header_fini" ref="gad3c4db0a912275b2966df3ab46f01ca5" args="(struct lu_object_header *h)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gad3c4db0a912275b2966df3ab46f01ca5">lu_object_header_fini</a> (struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize compound object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ca561880240b82371ba59795e8832a4"></a><!-- doxytag: member="lu::lu_object_init" ref="ga2ca561880240b82371ba59795e8832a4" args="(struct lu_object *o, struct lu_object_header *h, struct lu_device *d)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga2ca561880240b82371ba59795e8832a4">lu_object_init</a> (struct <a class="el" href="structlu__object.html">lu_object</a> *o, struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *h, struct <a class="el" href="structlu__device.html">lu_device</a> *d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize object <em>o</em> that is part of compound object <em>h</em> and was created by device <em>d</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0318f3c931fb2457b0cc4365c15611ca"></a><!-- doxytag: member="lu::lu_object_fini" ref="ga0318f3c931fb2457b0cc4365c15611ca" args="(struct lu_object *o)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga0318f3c931fb2457b0cc4365c15611ca">lu_object_fini</a> (struct <a class="el" href="structlu__object.html">lu_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalize object and release its resources. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gaa83f38d5ed0268b449a3074d350c763d">lu_object_add_top</a> (struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *h, struct <a class="el" href="structlu__object.html">lu_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add object <em>o</em> as first layer of compound object <em>h</em>.  <a href="#gaa83f38d5ed0268b449a3074d350c763d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gaa0c00da42f82361409215468e0952e37">lu_object_add</a> (struct <a class="el" href="structlu__object.html">lu_object</a> *before, struct <a class="el" href="structlu__object.html">lu_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add object <em>o</em> as a layer of compound object, going after <em>before</em>.  <a href="#gaa0c00da42f82361409215468e0952e37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35981a6d70370aee9bcd5ccf2e7dfe74"></a><!-- doxytag: member="lu::lu_dev_add_linkage" ref="ga35981a6d70370aee9bcd5ccf2e7dfe74" args="(struct lu_site *s, struct lu_device *d)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_dev_add_linkage</b> (struct <a class="el" href="structlu__site.html">lu_site</a> *s, struct <a class="el" href="structlu__device.html">lu_device</a> *d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2d344d146e4c4a172bf22d8b7d4f8627"></a><!-- doxytag: member="lu::lu_dev_del_linkage" ref="ga2d344d146e4c4a172bf22d8b7d4f8627" args="(struct lu_site *s, struct lu_device *d)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_dev_del_linkage</b> (struct <a class="el" href="structlu__site.html">lu_site</a> *s, struct <a class="el" href="structlu__device.html">lu_device</a> *d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga45f56bf01601ed8840d9c1028ef88e43"></a><!-- doxytag: member="lu::lu_device_type_init" ref="ga45f56bf01601ed8840d9c1028ef88e43" args="(struct lu_device_type *ldt)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga45f56bf01601ed8840d9c1028ef88e43">lu_device_type_init</a> (struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *ldt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helpers to initialize and finalize device types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb614e4b36763f904780baf2678de990"></a><!-- doxytag: member="lu::lu_device_type_fini" ref="gabb614e4b36763f904780baf2678de990" args="(struct lu_device_type *ldt)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lu_device_type_fini</b> (struct <a class="el" href="structlu__device__type.html">lu_device_type</a> *ldt)</td></tr>
<tr><td colspan="2"><h2>caching</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp429f8e6e19e3887fdb9b70d9195bb3fd"></a>Caching and reference counting. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea">lu_object_put</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__object.html">lu_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease reference counter on object.  <a href="#ga0d53e3777af7b81492a1178c75b872ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga48ae307342778b2ffb56cae3dad5d012">lu_object_put_nocache</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__object.html">lu_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put object and don't keep in cache.  <a href="#ga48ae307342778b2ffb56cae3dad5d012"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga5efa3dbe314fd74875195c5a5aeb791d">lu_object_unhash</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__object.html">lu_object</a> *o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill the object and take it out of LRU cache.  <a href="#ga5efa3dbe314fd74875195c5a5aeb791d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00642c90cffacaa9db84e3bb03188f0d"></a><!-- doxytag: member="lu::lu_site_purge" ref="ga00642c90cffacaa9db84e3bb03188f0d" args="(const struct lu_env *env, struct lu_site *s, int nr)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga00642c90cffacaa9db84e3bb03188f0d">lu_site_purge</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__site.html">lu_site</a> *s, int nr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free <em>nr</em> objects from the cold end of the site LRU list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga44c706297b0647e426dac54206a8b298"></a><!-- doxytag: member="lu::lu_site_print" ref="ga44c706297b0647e426dac54206a8b298" args="(const struct lu_env *env, struct lu_site *s, void *cookie, lu_printer_t printer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga44c706297b0647e426dac54206a8b298">lu_site_print</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__site.html">lu_site</a> *s, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> printer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all objects in <em>s</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga507da2d12daef52e3859b9b96d0ae591">lu_object_find</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__device.html">lu_device</a> *dev, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *f, const struct <a class="el" href="structlu__object__conf.html">lu_object_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search cache for an object with the fid <em>f</em>.  <a href="#ga507da2d12daef52e3859b9b96d0ae591"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#gad0df5edda743e3ab2a9165faecb8656b">lu_object_find_at</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__device.html">lu_device</a> *dev, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *f, const struct <a class="el" href="structlu__object__conf.html">lu_object_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Much like <a class="el" href="group__lu.html#ga507da2d12daef52e3859b9b96d0ae591" title="Search cache for an object with the fid f.">lu_object_find()</a>, but top level device of object is specifically <em>dev</em> rather than top level device of the site.  <a href="#gad0df5edda743e3ab2a9165faecb8656b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54cb269068bb3767dde66b0bb58afb70"></a><!-- doxytag: member="lu::lu_object_find_slice" ref="ga54cb269068bb3767dde66b0bb58afb70" args="(const struct lu_env *env, struct lu_device *dev, const struct lu_fid *f, const struct lu_object_conf *conf)" -->
struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lu.html#ga54cb269068bb3767dde66b0bb58afb70">lu_object_find_slice</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structlu__device.html">lu_device</a> *dev, const struct <a class="el" href="structlu__fid.html">lu_fid</a> *f, const struct <a class="el" href="structlu__object__conf.html">lu_object_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find object with given fid, and return its slice belonging to given device. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>lu_* data-types represent server-side entities shared by data and meta-data stacks. </p>
<p>Design goals:</p>
<ol type="1">
<li>support for layering.</li>
</ol>
<p>Server side object is split into layers, one per device in the corresponding device stack. Individual layer is represented by struct <a class="el" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>. Compound layered object --- by struct <a class="el" href="structlu__object__header.html" title="&quot;Compound&quot; object, consisting of multiple layers.">lu_object_header</a>. Most interface functions take <a class="el" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> as an argument and operate on the whole compound object. This decision was made due to the following reasons:</p>
<ul>
<li>it's envisaged that <a class="el" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> will be used much more often than <a class="el" href="structlu__object__header.html" title="&quot;Compound&quot; object, consisting of multiple layers.">lu_object_header</a>;</li>
</ul>
<ul>
<li>we want lower (non-top) layers to be able to initiate operations on the whole object.</li>
</ul>
<p>Generic code supports layering more complex than simple stacking, e.g., it is possible that at some layer object "spawns" multiple sub-objects on the lower layer.</p>
<ol type="1">
<li>fid-based identification.</li>
</ol>
<p>Compound object is uniquely identified by its fid. Objects are indexed by their fids (hash table is used for index).</p>
<ol type="1">
<li>caching and life-cycle management.</li>
</ol>
<p>Object's life-time is controlled by reference counting. When reference count drops to 0, object is returned to cache. Cached objects still retain their identity (i.e., fid), and can be recovered from cache.</p>
<p>Objects are kept in the global LRU list, and <a class="el" href="group__lu.html#ga00642c90cffacaa9db84e3bb03188f0d" title="Free nr objects from the cold end of the site LRU list.">lu_site_purge()</a> function can be used to reclaim given number of unused objects from the tail of the LRU.</p>
<ol type="1">
<li>avoiding recursion.</li>
</ol>
<p>Generic code tries to replace recursion through layers by iterations where possible. Additionally to the end of reducing stack consumption, data, when practically possible, are allocated through <a class="el" href="structlu__context__key.html" title="Key.">lu_context_key</a> interface rather than on stack. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaa018139e0d1873e79fc3f2e5c167fc0f"></a><!-- doxytag: member="lu_object.h::LU_CONTEXT_KEY_DEFINE" ref="gaa018139e0d1873e79fc3f2e5c167fc0f" args="(mod, tags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_CONTEXT_KEY_DEFINE</td>
          <td>(</td>
          <td class="paramtype">mod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tags&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> mod##_thread_key = {      \
                .lct_tags = tags,                       \
                .lct_init = mod##_key_init,             \
                .lct_fini = mod##_key_fini              \
        }
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01165">1165</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b60b05b26d0478f05a27e4c18e51d40"></a><!-- doxytag: member="lu_object.h::LU_CONTEXT_KEY_INIT" ref="ga6b60b05b26d0478f05a27e4c18e51d40" args="(key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_CONTEXT_KEY_INIT</td>
          <td>(</td>
          <td class="paramtype">key&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                    \
        (key)-&gt;<a class="code" href="structlu__context__key.html#adaa9094d0c7925ce49a5fdc70f4e432f" title="Internal implementation detail: module for this key.">lct_owner</a> = THIS_MODULE;                 \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01172">1172</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c350e2b5d2d5813cfe127d58e4a14aa"></a><!-- doxytag: member="lu_object.h::LU_KEY_FINI" ref="ga7c350e2b5d2d5813cfe127d58e4a14aa" args="(mod, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_KEY_FINI</td>
          <td>(</td>
          <td class="paramtype">mod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> mod##_key_fini(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx,            \
                                    <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key, <span class="keywordtype">void</span>* data) \
        {                                                                   \
                type *info = data;                                          \
                                                                            \
                OBD_FREE_PTR(info);                                         \
        }                                                                   \
        <span class="keyword">struct </span>__##mod##__dummy_fini {;}
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01151">1151</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b29c45a8b7394108cd5565b0aae188d"></a><!-- doxytag: member="lu_object.h::LU_KEY_INIT" ref="ga0b29c45a8b7394108cd5565b0aae188d" args="(mod, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_KEY_INIT</td>
          <td>(</td>
          <td class="paramtype">mod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>* mod##_key_init(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx, \
                                    <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key)   \
        {                                                         \
                type *value;                                      \
                                                                  \
                CLASSERT(PAGE_CACHE_SIZE &gt;= <span class="keyword">sizeof</span> (*value));       \
                                                                  \
                OBD_ALLOC_PTR(value);                             \
                <span class="keywordflow">if</span> (value == NULL)                                \
                        value = ERR_PTR(-ENOMEM);                 \
                                                                  \
                <span class="keywordflow">return</span> value;                                     \
        }                                                         \
        <span class="keyword">struct </span>__##mod##__dummy_init {;}
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01135">1135</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab5c56aaa47f24ef048f913efc267f9c0"></a><!-- doxytag: member="lu_object.h::LU_KEY_INIT_FINI" ref="gab5c56aaa47f24ef048f913efc267f9c0" args="(mod, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_KEY_INIT_FINI</td>
          <td>(</td>
          <td class="paramtype">mod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">LU_KEY_INIT(mod,type);        \
        LU_KEY_FINI(mod,type)
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01161">1161</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae44eda3313c603a02014b7281ebcf53c"></a><!-- doxytag: member="lu_object.h::LU_KEY_INIT_GENERIC" ref="gae44eda3313c603a02014b7281ebcf53c" args="(mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_KEY_INIT_GENERIC</td>
          <td>(</td>
          <td class="paramtype">mod&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> mod##_key_init_generic(<span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *k, ...) \
        {                                                               \
                <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key = k;                         \
                va_list args;                                           \
                                                                        \
                va_start(args, k);                                      \
                <span class="keywordflow">do</span> {                                                    \
                        LU_CONTEXT_KEY_INIT(key);                       \
                        key = va_arg(args, <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *);    \
                } <span class="keywordflow">while</span> (key != NULL);                                  \
                va_end(args);                                           \
        }
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01190">1190</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae0469b00c8c93e0c85eaacfabd33f6aa"></a><!-- doxytag: member="lu_object.h::LU_OBJECT_DEBUG" ref="gae0469b00c8c93e0c85eaacfabd33f6aa" args="(mask, env, object, format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_OBJECT_DEBUG</td>
          <td>(</td>
          <td class="paramtype">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">env, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                      \
        <span class="keywordflow">if</span> (cfs_cdebug_show(mask, DEBUG_SUBSYSTEM)) {                     \
                LIBCFS_DEBUG_MSG_DATA_DECL(msgdata, mask, NULL);          \
                <a class="code" href="group__lu.html#gac48202c869a59a25988a89207f85ef7f" title="Print human readable representation of the o to the printer.">lu_object_print</a>(env, &amp;msgdata, <a class="code" href="group__lu.html#gaea04856d0829f02ff6e8b5b957cd8a52" title="Printer function emitting messages through libcfs_debug_msg().">lu_cdebug_printer</a>, <span class="keywordtype">object</span>);\
                CDEBUG(mask, format <span class="stringliteral">&quot;\n&quot;</span>, ## __VA_ARGS__);                \
        }                                                                 \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Print object description followed by a user-supplied message. </p>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l00800">800</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="gacef4aec6c28892e386a8d3cca26aeb28"></a><!-- doxytag: member="lu_object.h::lu_object_exists" ref="gacef4aec6c28892e386a8d3cca26aeb28" args="(o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lu_object_exists</td>
          <td>(</td>
          <td class="paramtype">o&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((o)-&gt;lo_header-&gt;loh_attr &amp; LOHA_EXISTS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether object exists, no matter on local or remote storage. </p>
<p>Note: LOHA_EXISTS will be set once some one created the object, and it does not needs to be committed to storage. </p>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l00840">840</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l00097">lu_object_put()</a>.</p>

</div>
</div>
<a class="anchor" id="gab6811b221fe08d6e5b46ce532fdd1059"></a><!-- doxytag: member="lu_object.h::LU_OBJECT_HEADER" ref="gab6811b221fe08d6e5b46ce532fdd1059" args="(mask, env, object, format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_OBJECT_HEADER</td>
          <td>(</td>
          <td class="paramtype">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">env, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                    \
        <span class="keywordflow">if</span> (cfs_cdebug_show(mask, DEBUG_SUBSYSTEM)) {                   \
                LIBCFS_DEBUG_MSG_DATA_DECL(msgdata, mask, NULL);        \
                <a class="code" href="group__lu.html#gac087f3906c58d3f36fc8765c101be34c" title="Print object header.">lu_object_header_print</a>(env, &amp;msgdata, <a class="code" href="group__lu.html#gaea04856d0829f02ff6e8b5b957cd8a52" title="Printer function emitting messages through libcfs_debug_msg().">lu_cdebug_printer</a>,\
                                       (<span class="keywordtype">object</span>)-&gt;lo_header);            \
                <a class="code" href="group__lu.html#gaea04856d0829f02ff6e8b5b957cd8a52" title="Printer function emitting messages through libcfs_debug_msg().">lu_cdebug_printer</a>(env, &amp;msgdata, <span class="stringliteral">&quot;\n&quot;</span>);                 \
                CDEBUG(mask, format , ## __VA_ARGS__);                  \
        }                                                               \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Print short object description followed by a user-supplied message. </p>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l00812">812</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__io_8c_source.html#l00229">cl_io_rw_init()</a>, and <a class="el" href="cl__object_8c_source.html#l00270">cl_object_glimpse()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf418c1e3881059195c1c4edafe78569d"></a><!-- doxytag: member="lu_object.h::LU_TYPE_FINI" ref="gaf418c1e3881059195c1c4edafe78569d" args="(mod,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_TYPE_FINI</td>
          <td>(</td>
          <td class="paramtype">mod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> mod##_type_fini(<span class="keyword">struct</span> <a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> *t)           \
        {                                                               \
                <a class="code" href="group__lu.html#ga3826a7e5b3ea78a0a1be49390c5efe18" title="De-register a number of keys.">lu_context_key_degister_many</a>(__VA_ARGS__, NULL);        \
        }                                                               \
        <span class="keyword">struct </span>__##mod##_dummy_type_fini {;}
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01213">1213</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadbf79988ad5791de6d6879cddc63164f"></a><!-- doxytag: member="lu_object.h::LU_TYPE_INIT" ref="gadbf79988ad5791de6d6879cddc63164f" args="(mod,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_TYPE_INIT</td>
          <td>(</td>
          <td class="paramtype">mod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">LU_KEY_INIT_GENERIC(mod)                                        \
        <span class="keyword">static</span> <span class="keywordtype">int</span> mod##_type_init(<span class="keyword">struct</span> <a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> *t)            \
        {                                                               \
                mod##_key_init_generic(__VA_ARGS__, NULL);              \
                <span class="keywordflow">return</span> <a class="code" href="group__lu.html#gabc82bcbb2d0d7e41ec7965f71878a606" title="Register a number of keys.">lu_context_key_register_many</a>(__VA_ARGS__, NULL); \
        }                                                               \
        <span class="keyword">struct </span>__##mod##_dummy_type_init {;}
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01204">1204</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga16fe0df178e6d395f6ca0a844871f586"></a><!-- doxytag: member="lu_object.h::LU_TYPE_INIT_FINI" ref="ga16fe0df178e6d395f6ca0a844871f586" args="(mod,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_TYPE_INIT_FINI</td>
          <td>(</td>
          <td class="paramtype">mod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">LU_TYPE_INIT(mod, __VA_ARGS__);         \
        LU_TYPE_FINI(mod, __VA_ARGS__);         \
        LU_TYPE_START(mod, __VA_ARGS__);        \
        LU_TYPE_STOP(mod, __VA_ARGS__)
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01236">1236</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae3decb8c1b206197c96788145f5ebb79"></a><!-- doxytag: member="lu_object.h::LU_TYPE_START" ref="gae3decb8c1b206197c96788145f5ebb79" args="(mod,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_TYPE_START</td>
          <td>(</td>
          <td class="paramtype">mod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> mod##_type_start(<span class="keyword">struct</span> <a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> *t)  \
        {                                                       \
                <a class="code" href="group__lu.html#ga4b7314b65026c1731f2384a0ac5242b4" title="Revive a number of keys.">lu_context_key_revive_many</a>(__VA_ARGS__, NULL);  \
        }                                                       \
        <span class="keyword">struct </span>__##mod##_dummy_type_start {;}
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01220">1220</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c781dce17584143f88426899c050a05"></a><!-- doxytag: member="lu_object.h::LU_TYPE_STOP" ref="ga8c781dce17584143f88426899c050a05" args="(mod,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LU_TYPE_STOP</td>
          <td>(</td>
          <td class="paramtype">mod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> mod##_type_stop(<span class="keyword">struct</span> <a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> *t)   \
        {                                                       \
                <a class="code" href="group__lu.html#ga48615706cf5edca3013bafd6f2f22059" title="Quiescent a number of keys.">lu_context_key_quiesce_many</a>(__VA_ARGS__, NULL); \
        }                                                       \
        <span class="keyword">struct </span>__##mod##_dummy_type_stop {;}
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01227">1227</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae6a1620e18d3832ad6e2442c39760d9a"></a><!-- doxytag: member="lu_object.h::PNAME" ref="gae6a1620e18d3832ad6e2442c39760d9a" args="(ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PNAME</td>
          <td>(</td>
          <td class="paramtype">ln&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(lu_name_is_valid(ln) ? (ln)-&gt;ln_namelen : 0),  \
        (lu_name_is_valid(ln) ? (ln)-&gt;ln_name : <span class="stringliteral">&quot;&quot;</span>)
</pre></div>
<p>Definition at line <a class="el" href="lu__object_8h_source.html#l01326">1326</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gac8ccca21472f6dc3ea91d73983740fdc"></a><!-- doxytag: member="lu_object.h::lu_printer_t" ref="gac8ccca21472f6dc3ea91d73983740fdc" args=")(const struct lu_env *env, void *cookie, const char *format,...) __attribute__((format(printf" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, void *cookie, const char *format,...) __attribute__((format(printf</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of "printer" function used by <a class="el" href="structlu__object__operations.html#acf091707006dc9d8d216351834d8d974" title="Optional debugging helper.">lu_object_operations::loo_object_print()</a> method. </p>
<p>Printer function is needed to provide some flexibility in (semi-)debugging output: possible implementations: printk, CDEBUG, sysfs/seq_file </p>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l00197">197</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gad7e2d14b1b91480b0b25656f63169a0a"></a><!-- doxytag: member="lu_object.h::lu_context_tag" ref="gad7e2d14b1b91480b0b25656f63169a0a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lu.html#gad7e2d14b1b91480b0b25656f63169a0a">lu_context_tag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="structlu__context__key.html" title="Key.">lu_context_key</a> interface. </p>
<p>Similar to pthread_key. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa51f264f8e3ea36a381cf8aaaa9672752"></a><!-- doxytag: member="LCT_MD_THREAD" ref="ggad7e2d14b1b91480b0b25656f63169a0aa51f264f8e3ea36a381cf8aaaa9672752" args="" -->LCT_MD_THREAD</em>&nbsp;</td><td>
<p>Thread on md server. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f"></a><!-- doxytag: member="LCT_DT_THREAD" ref="ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f" args="" -->LCT_DT_THREAD</em>&nbsp;</td><td>
<p>Thread on dt server. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aae4ff6019628711d8f1dbefee9e3edfee"></a><!-- doxytag: member="LCT_TX_HANDLE" ref="ggad7e2d14b1b91480b0b25656f63169a0aae4ff6019628711d8f1dbefee9e3edfee" args="" -->LCT_TX_HANDLE</em>&nbsp;</td><td>
<p>Context for transaction handle. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d"></a><!-- doxytag: member="LCT_CL_THREAD" ref="ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" args="" -->LCT_CL_THREAD</em>&nbsp;</td><td>
<p>Thread on client. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa76aa3f8e745622ced47e2687d27c4b84"></a><!-- doxytag: member="LCT_SESSION" ref="ggad7e2d14b1b91480b0b25656f63169a0aa76aa3f8e745622ced47e2687d27c4b84" args="" -->LCT_SESSION</em>&nbsp;</td><td>
<p>A per-request session on a server, and a per-system-call session on a client. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa24dc5414c9f1420be38e18a84e730d10"></a><!-- doxytag: member="LCT_OSP_THREAD" ref="ggad7e2d14b1b91480b0b25656f63169a0aa24dc5414c9f1420be38e18a84e730d10" args="" -->LCT_OSP_THREAD</em>&nbsp;</td><td>
<p>A per-request data on OSP device. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa582fa482375137187e808b1f5f8662d1"></a><!-- doxytag: member="LCT_MG_THREAD" ref="ggad7e2d14b1b91480b0b25656f63169a0aa582fa482375137187e808b1f5f8662d1" args="" -->LCT_MG_THREAD</em>&nbsp;</td><td>
<p>MGS device thread. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa87bf2c0c71c5af685cf15e809a7ed551"></a><!-- doxytag: member="LCT_LOCAL" ref="ggad7e2d14b1b91480b0b25656f63169a0aa87bf2c0c71c5af685cf15e809a7ed551" args="" -->LCT_LOCAL</em>&nbsp;</td><td>
<p>Context for local operations. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aabaed253be3089b461b48756c519b654a"></a><!-- doxytag: member="LCT_SERVER_SESSION" ref="ggad7e2d14b1b91480b0b25656f63169a0aabaed253be3089b461b48756c519b654a" args="" -->LCT_SERVER_SESSION</em>&nbsp;</td><td>
<p>session for server thread </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa17f47648c605de40856da551f04fe939"></a><!-- doxytag: member="LCT_HAS_EXIT" ref="ggad7e2d14b1b91480b0b25656f63169a0aa17f47648c605de40856da551f04fe939" args="" -->LCT_HAS_EXIT</em>&nbsp;</td><td>
<p>Set when at least one of keys, having values in this context has non-NULL <a class="el" href="structlu__context__key.html#ad9470ad16ac47ced77c65d8c70b12e44" title="Optional method called on lu_context_exit() for all allocated keys.">lu_context_key::lct_exit()</a> method. </p>
<p>This is used to optimize <a class="el" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit()</a> call. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084"></a><!-- doxytag: member="LCT_NOREF" ref="ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084" args="" -->LCT_NOREF</em>&nbsp;</td><td>
<p>Don't add references for modules creating key values in that context. </p>
<p>This is only for contexts used internally by <a class="el" href="structlu__object.html" title="Layer in the layered object.">lu_object</a> framework. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aa2ed29d3105c69b17fc8fb72de22cb719"></a><!-- doxytag: member="LCT_QUIESCENT" ref="ggad7e2d14b1b91480b0b25656f63169a0aa2ed29d3105c69b17fc8fb72de22cb719" args="" -->LCT_QUIESCENT</em>&nbsp;</td><td>
<p>Key is being prepared for retiring, don't create new values for it. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e"></a><!-- doxytag: member="LCT_REMEMBER" ref="ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e" args="" -->LCT_REMEMBER</em>&nbsp;</td><td>
<p>Context should be remembered. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad7e2d14b1b91480b0b25656f63169a0aadc9da0a8f1ca7e5e219fc2a482ca7fc1"></a><!-- doxytag: member="LCT_SHRINKER" ref="ggad7e2d14b1b91480b0b25656f63169a0aadc9da0a8f1ca7e5e219fc2a482ca7fc1" args="" -->LCT_SHRINKER</em>&nbsp;</td><td>
<p>Contexts usable in cache shrinker thread. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l00991">991</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00991"></a>00991                     {
<a name="l00995"></a>00995         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa51f264f8e3ea36a381cf8aaaa9672752" title="Thread on md server.">LCT_MD_THREAD</a> = 1 &lt;&lt; 0,
<a name="l00999"></a>00999         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f" title="Thread on dt server.">LCT_DT_THREAD</a> = 1 &lt;&lt; 1,
<a name="l01003"></a>01003         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aae4ff6019628711d8f1dbefee9e3edfee" title="Context for transaction handle.">LCT_TX_HANDLE</a> = 1 &lt;&lt; 2,
<a name="l01007"></a>01007         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" title="Thread on client.">LCT_CL_THREAD</a> = 1 &lt;&lt; 3,
<a name="l01012"></a>01012         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa76aa3f8e745622ced47e2687d27c4b84" title="A per-request session on a server, and a per-system-call session on a client.">LCT_SESSION</a>   = 1 &lt;&lt; 4,
<a name="l01016"></a>01016         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa24dc5414c9f1420be38e18a84e730d10" title="A per-request data on OSP device.">LCT_OSP_THREAD</a> = 1 &lt;&lt; 5,
<a name="l01020"></a>01020         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa582fa482375137187e808b1f5f8662d1" title="MGS device thread.">LCT_MG_THREAD</a> = 1 &lt;&lt; 6,
<a name="l01024"></a>01024         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa87bf2c0c71c5af685cf15e809a7ed551" title="Context for local operations.">LCT_LOCAL</a> = 1 &lt;&lt; 7,
<a name="l01028"></a>01028         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aabaed253be3089b461b48756c519b654a" title="session for server thread">LCT_SERVER_SESSION</a> = 1 &lt;&lt; 8,
<a name="l01034"></a>01034         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa17f47648c605de40856da551f04fe939" title="Set when at least one of keys, having values in this context has non-NULL lu_context_key::lct_exit()...">LCT_HAS_EXIT</a>  = 1 &lt;&lt; 28,
<a name="l01039"></a>01039         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084" title="Don&amp;#39;t add references for modules creating key values in that context.">LCT_NOREF</a>     = 1 &lt;&lt; 29,
<a name="l01043"></a>01043         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa2ed29d3105c69b17fc8fb72de22cb719" title="Key is being prepared for retiring, don&amp;#39;t create new values for it.">LCT_QUIESCENT</a> = 1 &lt;&lt; 30,
<a name="l01047"></a>01047         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e" title="Context should be remembered.">LCT_REMEMBER</a>  = 1 &lt;&lt; 31,
<a name="l01051"></a>01051         <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aadc9da0a8f1ca7e5e219fc2a482ca7fc1" title="Contexts usable in cache shrinker thread.">LCT_SHRINKER</a>  = <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa51f264f8e3ea36a381cf8aaaa9672752" title="Thread on md server.">LCT_MD_THREAD</a>|<a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa130ed4529679eed5a88d5dc63db1921f" title="Thread on dt server.">LCT_DT_THREAD</a>|<a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa40dab32b35c819b558399c29e75bd57d" title="Thread on client.">LCT_CL_THREAD</a>|<a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084" title="Don&amp;#39;t add references for modules creating key values in that context.">LCT_NOREF</a>
<a name="l01052"></a>01052 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa318f5b20c40de1d564f59dd72726345"></a><!-- doxytag: member="lu_object.h::lu_device_tag" ref="gaa318f5b20c40de1d564f59dd72726345" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lu.html#gaa318f5b20c40de1d564f59dd72726345">lu_device_tag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tag bits for device type. </p>
<p>They are used to distinguish certain groups of device types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaa318f5b20c40de1d564f59dd72726345a2a083e23924356952e08900b8a278798"></a><!-- doxytag: member="LU_DEVICE_MD" ref="ggaa318f5b20c40de1d564f59dd72726345a2a083e23924356952e08900b8a278798" args="" -->LU_DEVICE_MD</em>&nbsp;</td><td>
<p>this is meta-data device </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa318f5b20c40de1d564f59dd72726345a5b8da75da353b465f5ddc30d87c931d9"></a><!-- doxytag: member="LU_DEVICE_DT" ref="ggaa318f5b20c40de1d564f59dd72726345a5b8da75da353b465f5ddc30d87c931d9" args="" -->LU_DEVICE_DT</em>&nbsp;</td><td>
<p>this is data device </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa318f5b20c40de1d564f59dd72726345a6950d6daf539cb6aa3902679e6232783"></a><!-- doxytag: member="LU_DEVICE_CL" ref="ggaa318f5b20c40de1d564f59dd72726345a6950d6daf539cb6aa3902679e6232783" args="" -->LU_DEVICE_CL</em>&nbsp;</td><td>
<p>data device in the client stack </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l00304">304</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00304"></a>00304                    {
<a name="l00306"></a>00306         <a class="code" href="group__lu.html#ggaa318f5b20c40de1d564f59dd72726345a2a083e23924356952e08900b8a278798" title="this is meta-data device">LU_DEVICE_MD</a> = (1 &lt;&lt; 0),
<a name="l00308"></a>00308         <a class="code" href="group__lu.html#ggaa318f5b20c40de1d564f59dd72726345a5b8da75da353b465f5ddc30d87c931d9" title="this is data device">LU_DEVICE_DT</a> = (1 &lt;&lt; 1),
<a name="l00310"></a>00310         <a class="code" href="group__lu.html#ggaa318f5b20c40de1d564f59dd72726345a6950d6daf539cb6aa3902679e6232783" title="data device in the client stack">LU_DEVICE_CL</a> = (1 &lt;&lt; 2)
<a name="l00311"></a>00311 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga58c79a7f6f5084aec5768a45526117dd"></a><!-- doxytag: member="lu_object.h::lu_object_header_attr" ref="ga58c79a7f6f5084aec5768a45526117dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lu.html#ga58c79a7f6f5084aec5768a45526117dd">lu_object_header_attr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga58c79a7f6f5084aec5768a45526117dda019e56dd8ff22350e1e002f92c9040ae"></a><!-- doxytag: member="LOHA_FT_START" ref="gga58c79a7f6f5084aec5768a45526117dda019e56dd8ff22350e1e002f92c9040ae" args="" -->LOHA_FT_START</em>&nbsp;</td><td>
<p>UNIX file type is stored in S_IFMT bits. </p>
<p>S_IFIFO </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga58c79a7f6f5084aec5768a45526117dda00cbfb5eebcc3d9c9c71040c957049ae"></a><!-- doxytag: member="LOHA_FT_END" ref="gga58c79a7f6f5084aec5768a45526117dda00cbfb5eebcc3d9c9c71040c957049ae" args="" -->LOHA_FT_END</em>&nbsp;</td><td>
<p>S_IFMT. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l00500">500</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00500"></a>00500                            {
<a name="l00501"></a>00501         LOHA_EXISTS   = 1 &lt;&lt; 0,
<a name="l00502"></a>00502         LOHA_REMOTE   = 1 &lt;&lt; 1,
<a name="l00506"></a>00506         <a class="code" href="group__lu.html#gga58c79a7f6f5084aec5768a45526117dda019e56dd8ff22350e1e002f92c9040ae" title="UNIX file type is stored in S_IFMT bits.">LOHA_FT_START</a> = 001 &lt;&lt; 12, 
<a name="l00507"></a>00507         <a class="code" href="group__lu.html#gga58c79a7f6f5084aec5768a45526117dda00cbfb5eebcc3d9c9c71040c957049ae" title="S_IFMT.">LOHA_FT_END</a>   = 017 &lt;&lt; 12, 
<a name="l00508"></a>00508 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga519a2e6103ae639c8df1777d311cc985"></a><!-- doxytag: member="lu_object.h::lu_object_header_flags" ref="ga519a2e6103ae639c8df1777d311cc985" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lu.html#ga519a2e6103ae639c8df1777d311cc985">lu_object_header_flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga519a2e6103ae639c8df1777d311cc985aca9a04f530d5436e7996a1ff142d01d0"></a><!-- doxytag: member="LU_OBJECT_HEARD_BANSHEE" ref="gga519a2e6103ae639c8df1777d311cc985aca9a04f530d5436e7996a1ff142d01d0" args="" -->LU_OBJECT_HEARD_BANSHEE</em>&nbsp;</td><td>
<p>Don't keep this object in cache. </p>
<p>Object will be destroyed as soon as last reference to it is released. This flag cannot be cleared once set. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga519a2e6103ae639c8df1777d311cc985a5d6ad2787701c40ef595e1ccdb31ae45"></a><!-- doxytag: member="LU_OBJECT_UNHASHED" ref="gga519a2e6103ae639c8df1777d311cc985a5d6ad2787701c40ef595e1ccdb31ae45" args="" -->LU_OBJECT_UNHASHED</em>&nbsp;</td><td>
<p>Mark this object has already been taken out of cache. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="lu__object_8h_source.html#l00487">487</a> of file <a class="el" href="lu__object_8h_source.html">lu_object.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00487"></a>00487                             {
<a name="l00493"></a>00493         <a class="code" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985aca9a04f530d5436e7996a1ff142d01d0" title="Don&amp;#39;t keep this object in cache.">LU_OBJECT_HEARD_BANSHEE</a> = 0,
<a name="l00497"></a>00497         <a class="code" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985a5d6ad2787701c40ef595e1ccdb31ae45" title="Mark this object has already been taken out of cache.">LU_OBJECT_UNHASHED</a> = 1,
<a name="l00498"></a>00498 };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga3943d5092fca7667ef0d3a48764f84aa"></a><!-- doxytag: member="lu_object.h::lu_buf_check_and_grow" ref="ga3943d5092fca7667ef0d3a48764f84aa" args="(struct lu_buf *buf, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lu_buf_check_and_grow </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__buf.html">lu_buf</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase the size of the <em>buf</em>. </p>
<p>preserves old data in buffer old buffer remains unchanged on error </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>or -ENOMEM </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l02387">2387</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02388"></a>02388 {
<a name="l02389"></a>02389         <span class="keywordtype">char</span> *ptr;
<a name="l02390"></a>02390 
<a name="l02391"></a>02391         <span class="keywordflow">if</span> (len &lt;= buf-&gt;lb_len)
<a name="l02392"></a>02392                 <span class="keywordflow">return</span> 0;
<a name="l02393"></a>02393 
<a name="l02394"></a>02394         OBD_ALLOC_LARGE(ptr, len);
<a name="l02395"></a>02395         <span class="keywordflow">if</span> (ptr == NULL)
<a name="l02396"></a>02396                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l02397"></a>02397 
<a name="l02398"></a>02398         <span class="comment">/* Free the old buf */</span>
<a name="l02399"></a>02399         <span class="keywordflow">if</span> (buf-&gt;lb_buf != NULL) {
<a name="l02400"></a>02400                 memcpy(ptr, buf-&gt;lb_buf, buf-&gt;lb_len);
<a name="l02401"></a>02401                 OBD_FREE_LARGE(buf-&gt;lb_buf, buf-&gt;lb_len);
<a name="l02402"></a>02402         }
<a name="l02403"></a>02403 
<a name="l02404"></a>02404         buf-&gt;lb_buf = ptr;
<a name="l02405"></a>02405         buf-&gt;lb_len = len;
<a name="l02406"></a>02406         <span class="keywordflow">return</span> 0;
<a name="l02407"></a>02407 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga1d2df80dc90294622ca45338757e2693"></a><!-- doxytag: member="lu_object.h::lu_context_fini" ref="ga1d2df80dc90294622ca45338757e2693" args="(struct lu_context *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_context_fini </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__context.html">lu_context</a> *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalize context data-structure. </p>
<p>Destroy key values. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01755">1755</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00975">lu_context::lc_remember</a>, <a class="el" href="lu__object_8h_source.html#l00958">lu_context::lc_tags</a>, and <a class="el" href="lu__object_8h_source.html#l01047">LCT_REMEMBER</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l01729">lu_context_init()</a>, and <a class="el" href="service_8c_source.html#l00859">ptlrpc_server_drop_request()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01756"></a>01756 {
<a name="l01757"></a>01757         LINVRNT(ctx-&gt;lc_state == LCS_INITIALIZED || ctx-&gt;lc_state == LCS_LEFT);
<a name="l01758"></a>01758         ctx-&gt;lc_state = LCS_FINALIZED;
<a name="l01759"></a>01759 
<a name="l01760"></a>01760         <span class="keywordflow">if</span> ((ctx-&gt;<a class="code" href="structlu__context.html#af10e2b16ba4601b8625e8075068f6c14" title="lu_context is used on the client side too.">lc_tags</a> &amp; <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e" title="Context should be remembered.">LCT_REMEMBER</a>) == 0) {
<a name="l01761"></a>01761                 LASSERT(list_empty(&amp;ctx-&gt;<a class="code" href="structlu__context.html#ac24c6306dacd5f856b24dbee0062b0b5" title="Linkage into a list of all remembered contexts.">lc_remember</a>));
<a name="l01762"></a>01762                 keys_fini(ctx);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764         } <span class="keywordflow">else</span> { <span class="comment">/* could race with key degister */</span>
<a name="l01765"></a>01765                 write_lock(&amp;lu_keys_guard);
<a name="l01766"></a>01766                 keys_fini(ctx);
<a name="l01767"></a>01767                 list_del_init(&amp;ctx-&gt;<a class="code" href="structlu__context.html#ac24c6306dacd5f856b24dbee0062b0b5" title="Linkage into a list of all remembered contexts.">lc_remember</a>);
<a name="l01768"></a>01768                 write_unlock(&amp;lu_keys_guard);
<a name="l01769"></a>01769         }
<a name="l01770"></a>01770 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga1d2df80dc90294622ca45338757e2693_icgraph.png" border="0" usemap="#group__lu_ga1d2df80dc90294622ca45338757e2693_icgraph_map" alt=""></div>
<map name="group__lu_ga1d2df80dc90294622ca45338757e2693_icgraph_map" id="group__lu_ga1d2df80dc90294622ca45338757e2693_icgraph">
<area shape="rect" id="node3" href="group__lu.html#ga952ae50ec5c4d109d2afecbb90c59a5c" title="Initialize context data&#45;structure." alt="" coords="219,5,341,35"/><area shape="rect" id="node5" href="group__net.html#ga45bbc99a8cb3940b830d5ac581cd2f10" title="drop a reference count of the request." alt="" coords="177,59,383,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga952ae50ec5c4d109d2afecbb90c59a5c"></a><!-- doxytag: member="lu_object.h::lu_context_init" ref="ga952ae50ec5c4d109d2afecbb90c59a5c" args="(struct lu_context *ctx, __u32 tags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lu_context_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__context.html">lu_context</a> *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>tags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize context data-structure. </p>
<p>Create values for all keys. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01729">1729</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00975">lu_context::lc_remember</a>, <a class="el" href="lu__object_8h_source.html#l00958">lu_context::lc_tags</a>, <a class="el" href="lu__object_8h_source.html#l01047">LCT_REMEMBER</a>, and <a class="el" href="lu__object_8c_source.html#l01755">lu_context_fini()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01730"></a>01730 {
<a name="l01731"></a>01731         <span class="keywordtype">int</span>     rc;
<a name="l01732"></a>01732 
<a name="l01733"></a>01733         memset(ctx, 0, <span class="keyword">sizeof</span> *ctx);
<a name="l01734"></a>01734         ctx-&gt;lc_state = LCS_INITIALIZED;
<a name="l01735"></a>01735         ctx-&gt;<a class="code" href="structlu__context.html#af10e2b16ba4601b8625e8075068f6c14" title="lu_context is used on the client side too.">lc_tags</a> = tags;
<a name="l01736"></a>01736         <span class="keywordflow">if</span> (tags &amp; <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e" title="Context should be remembered.">LCT_REMEMBER</a>) {
<a name="l01737"></a>01737                 write_lock(&amp;lu_keys_guard);
<a name="l01738"></a>01738                 list_add(&amp;ctx-&gt;<a class="code" href="structlu__context.html#ac24c6306dacd5f856b24dbee0062b0b5" title="Linkage into a list of all remembered contexts.">lc_remember</a>, &amp;lu_context_remembered);
<a name="l01739"></a>01739                 write_unlock(&amp;lu_keys_guard);
<a name="l01740"></a>01740         } <span class="keywordflow">else</span> {
<a name="l01741"></a>01741                 INIT_LIST_HEAD(&amp;ctx-&gt;<a class="code" href="structlu__context.html#ac24c6306dacd5f856b24dbee0062b0b5" title="Linkage into a list of all remembered contexts.">lc_remember</a>);
<a name="l01742"></a>01742         }
<a name="l01743"></a>01743 
<a name="l01744"></a>01744         rc = keys_init(ctx);
<a name="l01745"></a>01745         <span class="keywordflow">if</span> (rc != 0)
<a name="l01746"></a>01746                 <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(ctx);
<a name="l01747"></a>01747 
<a name="l01748"></a>01748         <span class="keywordflow">return</span> rc;
<a name="l01749"></a>01749 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga952ae50ec5c4d109d2afecbb90c59a5c_cgraph.png" border="0" usemap="#group__lu_ga952ae50ec5c4d109d2afecbb90c59a5c_cgraph_map" alt=""></div>
<map name="group__lu_ga952ae50ec5c4d109d2afecbb90c59a5c_cgraph_map" id="group__lu_ga952ae50ec5c4d109d2afecbb90c59a5c_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data&#45;structure." alt="" coords="177,5,297,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga6e069db37ac446fe47b8b211c3d721c5"></a><!-- doxytag: member="lu_object.h::lu_context_key_degister" ref="ga6e069db37ac446fe47b8b211c3d721c5" args="(struct lu_context_key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_context_key_degister </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deregister key. </p>

<p><p>Wait until all transient contexts referencing this key have run <a class="el" href="structlu__context__key.html#aaf04b1fb0608ed408ead318f6237fd05" title="Value destructor.">lu_context_key::lct_fini()</a> method.</p>
</p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01455">1455</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l01119">lu_context_key::lct_index</a>, <a class="el" href="lu__object_8h_source.html#l01128">lu_context_key::lct_owner</a>, <a class="el" href="lu__object_8h_source.html#l01132">lu_context_key::lct_reference</a>, <a class="el" href="lu__object_8h_source.html#l01124">lu_context_key::lct_used</a>, <a class="el" href="lu__object_8h_source.html#l01273">lu_env::le_ctx</a>, and <a class="el" href="lu__object_8c_source.html#l01594">lu_context_key_quiesce()</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l01526">lu_context_key_degister_many()</a>, <a class="el" href="lu__object_8c_source.html#l01494">lu_context_key_register_many()</a>, and <a class="el" href="lu__object_8c_source.html#l02181">lu_global_fini()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01456"></a>01456 {
<a name="l01457"></a>01457         LASSERT(atomic_read(&amp;key-&gt;<a class="code" href="structlu__context__key.html#a0f6957a9be54ed17fd9bf071245bd9b3" title="Internal implementation detail: number of values created for this key.">lct_used</a>) &gt;= 1);
<a name="l01458"></a>01458         LINVRNT(0 &lt;= key-&gt;<a class="code" href="structlu__context__key.html#abf647842d414d925c7d75134f1c68b73" title="Internal implementation detail: index within lu_context::lc_value[] reserved for...">lct_index</a> &amp;&amp; key-&gt;<a class="code" href="structlu__context__key.html#abf647842d414d925c7d75134f1c68b73" title="Internal implementation detail: index within lu_context::lc_value[] reserved for...">lct_index</a> &lt; ARRAY_SIZE(lu_keys));
<a name="l01459"></a>01459 
<a name="l01460"></a>01460         <a class="code" href="group__lu.html#ga26d0d8d30e9702d38f9d2e372d48002e" title="Destroy key in all remembered contexts.">lu_context_key_quiesce</a>(key);
<a name="l01461"></a>01461 
<a name="l01462"></a>01462         ++key_set_version;
<a name="l01463"></a>01463         write_lock(&amp;lu_keys_guard);
<a name="l01464"></a>01464         key_fini(&amp;lu_shrink_env.<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>, key-&gt;<a class="code" href="structlu__context__key.html#abf647842d414d925c7d75134f1c68b73" title="Internal implementation detail: index within lu_context::lc_value[] reserved for...">lct_index</a>);
<a name="l01465"></a>01465 
<a name="l01470"></a>01470         <span class="keywordflow">while</span> (atomic_read(&amp;key-&gt;<a class="code" href="structlu__context__key.html#a0f6957a9be54ed17fd9bf071245bd9b3" title="Internal implementation detail: number of values created for this key.">lct_used</a>) &gt; 1) {
<a name="l01471"></a>01471                 write_unlock(&amp;lu_keys_guard);
<a name="l01472"></a>01472                 CDEBUG(D_INFO, <span class="stringliteral">&quot;lu_context_key_degister: \&quot;%s\&quot; %p, %d\n&quot;</span>,
<a name="l01473"></a>01473                        key-&gt;<a class="code" href="structlu__context__key.html#adaa9094d0c7925ce49a5fdc70f4e432f" title="Internal implementation detail: module for this key.">lct_owner</a> ? key-&gt;<a class="code" href="structlu__context__key.html#adaa9094d0c7925ce49a5fdc70f4e432f" title="Internal implementation detail: module for this key.">lct_owner</a>-&gt;name : <span class="stringliteral">&quot;&quot;</span>, key,
<a name="l01474"></a>01474                        atomic_read(&amp;key-&gt;<a class="code" href="structlu__context__key.html#a0f6957a9be54ed17fd9bf071245bd9b3" title="Internal implementation detail: number of values created for this key.">lct_used</a>));
<a name="l01475"></a>01475                 schedule();
<a name="l01476"></a>01476                 write_lock(&amp;lu_keys_guard);
<a name="l01477"></a>01477         }
<a name="l01478"></a>01478         <span class="keywordflow">if</span> (lu_keys[key-&gt;<a class="code" href="structlu__context__key.html#abf647842d414d925c7d75134f1c68b73" title="Internal implementation detail: index within lu_context::lc_value[] reserved for...">lct_index</a>]) {
<a name="l01479"></a>01479                 lu_keys[key-&gt;<a class="code" href="structlu__context__key.html#abf647842d414d925c7d75134f1c68b73" title="Internal implementation detail: index within lu_context::lc_value[] reserved for...">lct_index</a>] = NULL;
<a name="l01480"></a>01480                 lu_ref_fini(&amp;key-&gt;<a class="code" href="structlu__context__key.html#a92f1fcf5a0e9dfd42082ead350795976" title="References to this key.">lct_reference</a>);
<a name="l01481"></a>01481         }
<a name="l01482"></a>01482         write_unlock(&amp;lu_keys_guard);
<a name="l01483"></a>01483 
<a name="l01484"></a>01484         LASSERTF(atomic_read(&amp;key-&gt;<a class="code" href="structlu__context__key.html#a0f6957a9be54ed17fd9bf071245bd9b3" title="Internal implementation detail: number of values created for this key.">lct_used</a>) == 1,
<a name="l01485"></a>01485                  <span class="stringliteral">&quot;key has instances: %d\n&quot;</span>,
<a name="l01486"></a>01486                  atomic_read(&amp;key-&gt;<a class="code" href="structlu__context__key.html#a0f6957a9be54ed17fd9bf071245bd9b3" title="Internal implementation detail: number of values created for this key.">lct_used</a>));
<a name="l01487"></a>01487 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga6e069db37ac446fe47b8b211c3d721c5_cgraph.png" border="0" usemap="#group__lu_ga6e069db37ac446fe47b8b211c3d721c5_cgraph_map" alt=""></div>
<map name="group__lu_ga6e069db37ac446fe47b8b211c3d721c5_cgraph_map" id="group__lu_ga6e069db37ac446fe47b8b211c3d721c5_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga26d0d8d30e9702d38f9d2e372d48002e" title="Destroy key in all remembered contexts." alt="" coords="244,5,428,35"/><area shape="rect" id="node5" href="group__cl__env.html#ga865dfbdba69721fb16c551ec6ce996d1" title="Finalizes and frees a given number of cached environments." alt="" coords="479,5,636,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga6e069db37ac446fe47b8b211c3d721c5_icgraph.png" border="0" usemap="#group__lu_ga6e069db37ac446fe47b8b211c3d721c5_icgraph_map" alt=""></div>
<map name="group__lu_ga6e069db37ac446fe47b8b211c3d721c5_icgraph_map" id="group__lu_ga6e069db37ac446fe47b8b211c3d721c5_icgraph">
<area shape="rect" id="node3" href="group__lu.html#ga3826a7e5b3ea78a0a1be49390c5efe18" title="De&#45;register a number of keys." alt="" coords="244,5,476,35"/><area shape="rect" id="node5" href="group__lu.html#gabc82bcbb2d0d7e41ec7965f71878a606" title="Register a number of keys." alt="" coords="245,59,475,88"/><area shape="rect" id="node7" href="group__lu.html#ga342d9d23d96d691f49863e21af40bbcd" title="Dual to lu_global_init()." alt="" coords="308,112,412,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga3826a7e5b3ea78a0a1be49390c5efe18"></a><!-- doxytag: member="lu_object.h::lu_context_key_degister_many" ref="ga3826a7e5b3ea78a0a1be49390c5efe18" args="(struct lu_context_key *k,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_context_key_degister_many </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>De-register a number of keys. </p>
<p>This is a dual to <a class="el" href="group__lu.html#gabc82bcbb2d0d7e41ec7965f71878a606" title="Register a number of keys.">lu_context_key_register_many()</a>. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01526">1526</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8c_source.html#l01455">lu_context_key_degister()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01527"></a>01527 {
<a name="l01528"></a>01528         va_list args;
<a name="l01529"></a>01529 
<a name="l01530"></a>01530         va_start(args, k);
<a name="l01531"></a>01531         <span class="keywordflow">do</span> {
<a name="l01532"></a>01532                 <a class="code" href="group__lu.html#ga6e069db37ac446fe47b8b211c3d721c5" title="Deregister key.">lu_context_key_degister</a>(k);
<a name="l01533"></a>01533                 k = va_arg(args, <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a>*);
<a name="l01534"></a>01534         } <span class="keywordflow">while</span> (k != NULL);
<a name="l01535"></a>01535         va_end(args);
<a name="l01536"></a>01536 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga3826a7e5b3ea78a0a1be49390c5efe18_cgraph.png" border="0" usemap="#group__lu_ga3826a7e5b3ea78a0a1be49390c5efe18_cgraph_map" alt=""></div>
<map name="group__lu_ga3826a7e5b3ea78a0a1be49390c5efe18_cgraph_map" id="group__lu_ga3826a7e5b3ea78a0a1be49390c5efe18_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga6e069db37ac446fe47b8b211c3d721c5" title="Deregister key." alt="" coords="288,5,477,35"/><area shape="rect" id="node5" href="group__lu.html#ga26d0d8d30e9702d38f9d2e372d48002e" title="Destroy key in all remembered contexts." alt="" coords="527,5,711,35"/><area shape="rect" id="node7" href="group__cl__env.html#ga865dfbdba69721fb16c551ec6ce996d1" title="Finalizes and frees a given number of cached environments." alt="" coords="761,5,919,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga26d0d8d30e9702d38f9d2e372d48002e"></a><!-- doxytag: member="lu_object.h::lu_context_key_quiesce" ref="ga26d0d8d30e9702d38f9d2e372d48002e" args="(struct lu_context_key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_context_key_quiesce </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy <em>key</em> in all remembered contexts. </p>
<p>This is used to destroy key values in "shared" contexts (like service threads), when a module owning the key is about to be unloaded. </p>

<p><p>Wait until all <a class="el" href="structlu__context__key.html#a7f59b1993947e4bb87482fe2db59a0a2" title="Value constructor.">lu_context_key::lct_init()</a> methods have completed.</p>
</p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01594">1594</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="cl__object_8c_source.html#l00960">cl_env_cache_purge()</a>, <a class="el" href="lu__object_8h_source.html#l00975">lu_context::lc_remember</a>, <a class="el" href="lu__object_8h_source.html#l01119">lu_context_key::lct_index</a>, <a class="el" href="lu__object_8h_source.html#l01128">lu_context_key::lct_owner</a>, <a class="el" href="lu__object_8h_source.html#l01043">LCT_QUIESCENT</a>, <a class="el" href="lu__object_8h_source.html#l01094">lu_context_key::lct_tags</a>, and <a class="el" href="lu__object_8h_source.html#l01124">lu_context_key::lct_used</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l01455">lu_context_key_degister()</a>, and <a class="el" href="lu__object_8c_source.html#l01558">lu_context_key_quiesce_many()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01595"></a>01595 {
<a name="l01596"></a>01596         <span class="keyword">struct </span><a class="code" href="structlu__context.html" title="lu_context.">lu_context</a> *ctx;
<a name="l01597"></a>01597         <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <a class="code" href="group__cl__env.html#ga865dfbdba69721fb16c551ec6ce996d1" title="Finalizes and frees a given number of cached environments.">cl_env_cache_purge</a>(<span class="keywordtype">unsigned</span> nr);
<a name="l01598"></a>01598 
<a name="l01599"></a>01599         <span class="keywordflow">if</span> (!(key-&gt;<a class="code" href="structlu__context__key.html#a52c40318e941229b9b102d7b6b8746f6" title="Set of tags for which values of this key are to be instantiated.">lct_tags</a> &amp; <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa2ed29d3105c69b17fc8fb72de22cb719" title="Key is being prepared for retiring, don&amp;#39;t create new values for it.">LCT_QUIESCENT</a>)) {
<a name="l01600"></a>01600                 <span class="comment">/*</span>
<a name="l01601"></a>01601 <span class="comment">                 * XXX layering violation.</span>
<a name="l01602"></a>01602 <span class="comment">                 */</span>
<a name="l01603"></a>01603                 <a class="code" href="group__cl__env.html#ga865dfbdba69721fb16c551ec6ce996d1" title="Finalizes and frees a given number of cached environments.">cl_env_cache_purge</a>(~0);
<a name="l01604"></a>01604                 <span class="comment">/*</span>
<a name="l01605"></a>01605 <span class="comment">                 * XXX memory barrier has to go here.</span>
<a name="l01606"></a>01606 <span class="comment">                 */</span>
<a name="l01607"></a>01607                 write_lock(&amp;lu_keys_guard);
<a name="l01608"></a>01608                 key-&gt;<a class="code" href="structlu__context__key.html#a52c40318e941229b9b102d7b6b8746f6" title="Set of tags for which values of this key are to be instantiated.">lct_tags</a> |= <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa2ed29d3105c69b17fc8fb72de22cb719" title="Key is being prepared for retiring, don&amp;#39;t create new values for it.">LCT_QUIESCENT</a>;
<a name="l01609"></a>01609 
<a name="l01614"></a>01614                 <span class="keywordflow">while</span> (atomic_read(&amp;lu_key_initing_cnt) &gt; 0) {
<a name="l01615"></a>01615                         write_unlock(&amp;lu_keys_guard);
<a name="l01616"></a>01616                         CDEBUG(D_INFO, <span class="stringliteral">&quot;lu_context_key_quiesce: \&quot;%s\&quot;&quot;</span>
<a name="l01617"></a>01617                                <span class="stringliteral">&quot; %p, %d (%d)\n&quot;</span>,
<a name="l01618"></a>01618                                key-&gt;<a class="code" href="structlu__context__key.html#adaa9094d0c7925ce49a5fdc70f4e432f" title="Internal implementation detail: module for this key.">lct_owner</a> ? key-&gt;<a class="code" href="structlu__context__key.html#adaa9094d0c7925ce49a5fdc70f4e432f" title="Internal implementation detail: module for this key.">lct_owner</a>-&gt;name : <span class="stringliteral">&quot;&quot;</span>,
<a name="l01619"></a>01619                                key, atomic_read(&amp;key-&gt;<a class="code" href="structlu__context__key.html#a0f6957a9be54ed17fd9bf071245bd9b3" title="Internal implementation detail: number of values created for this key.">lct_used</a>),
<a name="l01620"></a>01620                                atomic_read(&amp;lu_key_initing_cnt));
<a name="l01621"></a>01621                         schedule();
<a name="l01622"></a>01622                         write_lock(&amp;lu_keys_guard);
<a name="l01623"></a>01623                 }
<a name="l01624"></a>01624 
<a name="l01625"></a>01625                 list_for_each_entry(ctx, &amp;lu_context_remembered,
<a name="l01626"></a>01626                                     <a class="code" href="structlu__context.html#ac24c6306dacd5f856b24dbee0062b0b5" title="Linkage into a list of all remembered contexts.">lc_remember</a>)
<a name="l01627"></a>01627                         key_fini(ctx, key-&gt;lct_index);
<a name="l01628"></a>01628                 write_unlock(&amp;lu_keys_guard);
<a name="l01629"></a>01629                 ++key_set_version;
<a name="l01630"></a>01630         }
<a name="l01631"></a>01631 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga26d0d8d30e9702d38f9d2e372d48002e_cgraph.png" border="0" usemap="#group__lu_ga26d0d8d30e9702d38f9d2e372d48002e_cgraph_map" alt=""></div>
<map name="group__lu_ga26d0d8d30e9702d38f9d2e372d48002e_cgraph_map" id="group__lu_ga26d0d8d30e9702d38f9d2e372d48002e_cgraph">
<area shape="rect" id="node3" href="group__cl__env.html#ga865dfbdba69721fb16c551ec6ce996d1" title="Finalizes and frees a given number of cached environments." alt="" coords="241,5,399,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga26d0d8d30e9702d38f9d2e372d48002e_icgraph.png" border="0" usemap="#group__lu_ga26d0d8d30e9702d38f9d2e372d48002e_icgraph_map" alt=""></div>
<map name="group__lu_ga26d0d8d30e9702d38f9d2e372d48002e_icgraph_map" id="group__lu_ga26d0d8d30e9702d38f9d2e372d48002e_icgraph">
<area shape="rect" id="node3" href="group__lu.html#ga6e069db37ac446fe47b8b211c3d721c5" title="Deregister key." alt="" coords="260,59,449,88"/><area shape="rect" id="node11" href="group__lu.html#ga48615706cf5edca3013bafd6f2f22059" title="Quiescent a number of keys." alt="" coords="240,112,469,141"/><area shape="rect" id="node5" href="group__lu.html#ga3826a7e5b3ea78a0a1be49390c5efe18" title="De&#45;register a number of keys." alt="" coords="519,5,751,35"/><area shape="rect" id="node7" href="group__lu.html#gabc82bcbb2d0d7e41ec7965f71878a606" title="Register a number of keys." alt="" coords="520,59,749,88"/><area shape="rect" id="node9" href="group__lu.html#ga342d9d23d96d691f49863e21af40bbcd" title="Dual to lu_global_init()." alt="" coords="583,112,687,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gabc82bcbb2d0d7e41ec7965f71878a606"></a><!-- doxytag: member="lu_object.h::lu_context_key_register_many" ref="gabc82bcbb2d0d7e41ec7965f71878a606" args="(struct lu_context_key *k,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lu_context_key_register_many </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__context__key.html">lu_context_key</a> *&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a number of keys. </p>
<p>This has to be called after all keys have been initialized by a call to LU_CONTEXT_KEY_INIT(). </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01494">1494</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8c_source.html#l01455">lu_context_key_degister()</a>, and <a class="el" href="lu__object_8c_source.html#l01401">lu_context_key_register()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01495"></a>01495 {
<a name="l01496"></a>01496         <span class="keyword">struct </span><a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *key = k;
<a name="l01497"></a>01497         va_list args;
<a name="l01498"></a>01498         <span class="keywordtype">int</span> result;
<a name="l01499"></a>01499 
<a name="l01500"></a>01500         va_start(args, k);
<a name="l01501"></a>01501         <span class="keywordflow">do</span> {
<a name="l01502"></a>01502                 result = <a class="code" href="group__lu.html#ga1eef6b147da5ae4489576e136772d404" title="Register new key.">lu_context_key_register</a>(key);
<a name="l01503"></a>01503                 <span class="keywordflow">if</span> (result)
<a name="l01504"></a>01504                         <span class="keywordflow">break</span>;
<a name="l01505"></a>01505                 key = va_arg(args, <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *);
<a name="l01506"></a>01506         } <span class="keywordflow">while</span> (key != NULL);
<a name="l01507"></a>01507         va_end(args);
<a name="l01508"></a>01508 
<a name="l01509"></a>01509         <span class="keywordflow">if</span> (result != 0) {
<a name="l01510"></a>01510                 va_start(args, k);
<a name="l01511"></a>01511                 <span class="keywordflow">while</span> (k != key) {
<a name="l01512"></a>01512                         <a class="code" href="group__lu.html#ga6e069db37ac446fe47b8b211c3d721c5" title="Deregister key.">lu_context_key_degister</a>(k);
<a name="l01513"></a>01513                         k = va_arg(args, <span class="keyword">struct</span> <a class="code" href="structlu__context__key.html" title="Key.">lu_context_key</a> *);
<a name="l01514"></a>01514                 }
<a name="l01515"></a>01515                 va_end(args);
<a name="l01516"></a>01516         }
<a name="l01517"></a>01517 
<a name="l01518"></a>01518         <span class="keywordflow">return</span> result;
<a name="l01519"></a>01519 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_gabc82bcbb2d0d7e41ec7965f71878a606_cgraph.png" border="0" usemap="#group__lu_gabc82bcbb2d0d7e41ec7965f71878a606_cgraph_map" alt=""></div>
<map name="group__lu_gabc82bcbb2d0d7e41ec7965f71878a606_cgraph_map" id="group__lu_gabc82bcbb2d0d7e41ec7965f71878a606_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga6e069db37ac446fe47b8b211c3d721c5" title="Deregister key." alt="" coords="285,5,475,35"/><area shape="rect" id="node9" href="group__lu.html#ga1eef6b147da5ae4489576e136772d404" title="Register new key." alt="" coords="287,59,473,88"/><area shape="rect" id="node5" href="group__lu.html#ga26d0d8d30e9702d38f9d2e372d48002e" title="Destroy key in all remembered contexts." alt="" coords="524,5,708,35"/><area shape="rect" id="node7" href="group__cl__env.html#ga865dfbdba69721fb16c551ec6ce996d1" title="Finalizes and frees a given number of cached environments." alt="" coords="759,5,916,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga00d029e31ae6e5f4edc94121d8bc4a45"></a><!-- doxytag: member="lu_object.h::lu_context_refill" ref="ga00d029e31ae6e5f4edc94121d8bc4a45" args="(struct lu_context *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lu_context_refill </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__context.html">lu_context</a> *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate for context all missing keys that were registered after context creation. </p>
<p>key_set_version is only changed in rare cases when modules are loaded and removed. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01818">1818</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00980">lu_context::lc_version</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l01166">lu_site_init_finish()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01819"></a>01819 {
<a name="l01820"></a>01820         <span class="keywordflow">return</span> likely(ctx-&gt;<a class="code" href="structlu__context.html#a85409d4859c7f422e2f211c7c260e8a3" title="Version counter used to skip calls to lu_context_refill() when no keys were registered...">lc_version</a> == key_set_version) ? 0 : keys_fill(ctx);
<a name="l01821"></a>01821 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga00d029e31ae6e5f4edc94121d8bc4a45_icgraph.png" border="0" usemap="#group__lu_ga00d029e31ae6e5f4edc94121d8bc4a45_icgraph_map" alt=""></div>
<map name="group__lu_ga00d029e31ae6e5f4edc94121d8bc4a45_icgraph_map" id="group__lu_ga00d029e31ae6e5f4edc94121d8bc4a45_icgraph">
<area shape="rect" id="node3" href="group__lu.html#ga8f089514e7db6f839ca9cb259a1eab14" title="Called when initialization of stack for this site is completed." alt="" coords="185,5,319,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gae86c05e9998dce0a3860d0456394c559"></a><!-- doxytag: member="lu_object.h::lu_env_refill_by_tags" ref="gae86c05e9998dce0a3860d0456394c559" args="(struct lu_env *env, __u32 ctags, __u32 stags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lu_env_refill_by_tags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>ctags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32&nbsp;</td>
          <td class="paramname"> <em>stags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Currently, this API will only be used by echo client. </p>
<p>Because echo client and normal lustre client will share same cl_env cache. So echo client needs to refresh the env context after it get one from the cache, especially when normal client and echo client co-exist in the same client. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01907">1907</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00958">lu_context::lc_tags</a>, <a class="el" href="lu__object_8h_source.html#l00980">lu_context::lc_version</a>, <a class="el" href="lu__object_8h_source.html#l01273">lu_env::le_ctx</a>, and <a class="el" href="lu__object_8h_source.html#l01277">lu_env::le_ses</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01909"></a>01909 {
<a name="l01910"></a>01910         <span class="keywordtype">int</span>    result;
<a name="l01911"></a>01911 
<a name="l01912"></a>01912         <span class="keywordflow">if</span> ((env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>.<a class="code" href="structlu__context.html#af10e2b16ba4601b8625e8075068f6c14" title="lu_context is used on the client side too.">lc_tags</a> &amp; ctags) != ctags) {
<a name="l01913"></a>01913                 env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>.<a class="code" href="structlu__context.html#a85409d4859c7f422e2f211c7c260e8a3" title="Version counter used to skip calls to lu_context_refill() when no keys were registered...">lc_version</a> = 0;
<a name="l01914"></a>01914                 env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>.<a class="code" href="structlu__context.html#af10e2b16ba4601b8625e8075068f6c14" title="lu_context is used on the client side too.">lc_tags</a> |= ctags;
<a name="l01915"></a>01915         }
<a name="l01916"></a>01916 
<a name="l01917"></a>01917         <span class="keywordflow">if</span> (env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a> &amp;&amp; (env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>-&gt;<a class="code" href="structlu__context.html#af10e2b16ba4601b8625e8075068f6c14" title="lu_context is used on the client side too.">lc_tags</a> &amp; stags) != stags) {
<a name="l01918"></a>01918                 env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>-&gt;<a class="code" href="structlu__context.html#a85409d4859c7f422e2f211c7c260e8a3" title="Version counter used to skip calls to lu_context_refill() when no keys were registered...">lc_version</a> = 0;
<a name="l01919"></a>01919                 env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a>-&gt;<a class="code" href="structlu__context.html#af10e2b16ba4601b8625e8075068f6c14" title="lu_context is used on the client side too.">lc_tags</a> |= stags;
<a name="l01920"></a>01920         }
<a name="l01921"></a>01921 
<a name="l01922"></a>01922         result = lu_env_refill(env);
<a name="l01923"></a>01923 
<a name="l01924"></a>01924         <span class="keywordflow">return</span> result;
<a name="l01925"></a>01925 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga25ead0509e25dab69f6c92ac1c465ce4"></a><!-- doxytag: member="lu_object.h::lu_global_init" ref="ga25ead0509e25dab69f6c92ac1c465ce4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lu_global_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>One-time initializers, called at obdclass module initialization, not exported. </p>
<p>Initialization of global lu_* data. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l02134">2134</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l01051">LCT_SHRINKER</a>, and <a class="el" href="lu__object_8c_source.html#l01401">lu_context_key_register()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02135"></a>02135 {
<a name="l02136"></a>02136         <span class="keywordtype">int</span> result;
<a name="l02137"></a>02137         DEF_SHRINKER_VAR(shvar, lu_cache_shrink,
<a name="l02138"></a>02138                          lu_cache_shrink_count, lu_cache_shrink_scan);
<a name="l02139"></a>02139 
<a name="l02140"></a>02140         CDEBUG(D_INFO, <span class="stringliteral">&quot;Lustre LU module (%p).\n&quot;</span>, &amp;lu_keys);
<a name="l02141"></a>02141 
<a name="l02142"></a>02142         INIT_LIST_HEAD(&amp;lu_device_types);
<a name="l02143"></a>02143         INIT_LIST_HEAD(&amp;lu_context_remembered);
<a name="l02144"></a>02144         INIT_LIST_HEAD(&amp;lu_sites);
<a name="l02145"></a>02145 
<a name="l02146"></a>02146         result = lu_ref_global_init();
<a name="l02147"></a>02147         <span class="keywordflow">if</span> (result != 0)
<a name="l02148"></a>02148                 <span class="keywordflow">return</span> result;
<a name="l02149"></a>02149 
<a name="l02150"></a>02150         LU_CONTEXT_KEY_INIT(&amp;lu_global_key);
<a name="l02151"></a>02151         result = <a class="code" href="group__lu.html#ga1eef6b147da5ae4489576e136772d404" title="Register new key.">lu_context_key_register</a>(&amp;lu_global_key);
<a name="l02152"></a>02152         <span class="keywordflow">if</span> (result != 0)
<a name="l02153"></a>02153                 <span class="keywordflow">return</span> result;
<a name="l02154"></a>02154 
<a name="l02155"></a>02155         <span class="comment">/*</span>
<a name="l02156"></a>02156 <span class="comment">         * At this level, we don&apos;t know what tags are needed, so allocate them</span>
<a name="l02157"></a>02157 <span class="comment">         * conservatively. This should not be too bad, because this</span>
<a name="l02158"></a>02158 <span class="comment">         * environment is global.</span>
<a name="l02159"></a>02159 <span class="comment">         */</span>
<a name="l02160"></a>02160         mutex_lock(&amp;lu_sites_guard);
<a name="l02161"></a>02161         result = lu_env_init(&amp;lu_shrink_env, <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aadc9da0a8f1ca7e5e219fc2a482ca7fc1" title="Contexts usable in cache shrinker thread.">LCT_SHRINKER</a>);
<a name="l02162"></a>02162         mutex_unlock(&amp;lu_sites_guard);
<a name="l02163"></a>02163         <span class="keywordflow">if</span> (result != 0)
<a name="l02164"></a>02164                 <span class="keywordflow">return</span> result;
<a name="l02165"></a>02165 
<a name="l02166"></a>02166         <span class="comment">/*</span>
<a name="l02167"></a>02167 <span class="comment">         * seeks estimation: 3 seeks to read a record from oi, one to read</span>
<a name="l02168"></a>02168 <span class="comment">         * inode, one for ea. Unfortunately setting this high value results in</span>
<a name="l02169"></a>02169 <span class="comment">         * lu_object/inode cache consuming all the memory.</span>
<a name="l02170"></a>02170 <span class="comment">         */</span>
<a name="l02171"></a>02171         lu_site_shrinker = set_shrinker(DEFAULT_SEEKS, &amp;shvar);
<a name="l02172"></a>02172         <span class="keywordflow">if</span> (lu_site_shrinker == NULL)
<a name="l02173"></a>02173                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l02174"></a>02174 
<a name="l02175"></a>02175         <span class="keywordflow">return</span> result;
<a name="l02176"></a>02176 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga25ead0509e25dab69f6c92ac1c465ce4_cgraph.png" border="0" usemap="#group__lu_ga25ead0509e25dab69f6c92ac1c465ce4_cgraph_map" alt=""></div>
<map name="group__lu_ga25ead0509e25dab69f6c92ac1c465ce4_cgraph_map" id="group__lu_ga25ead0509e25dab69f6c92ac1c465ce4_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga1eef6b147da5ae4489576e136772d404" title="Register new key." alt="" coords="160,5,347,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gac3834e0d4bd35c8a02d1003bf0f4331e"></a><!-- doxytag: member="lu_object.h::lu_kmem_fini" ref="gac3834e0d4bd35c8a02d1003bf0f4331e" args="(struct lu_kmem_descr *caches)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_kmem_fini </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__kmem__descr.html">lu_kmem_descr</a> *&nbsp;</td>
          <td class="paramname"> <em>caches</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to finalize a number of kmem slab cached at once. </p>
<p>Dual to <a class="el" href="group__lu.html#ga42de365ae8cbdaa97c604434937a4822" title="Helper function to initialize a number of kmem slab caches at once.">lu_kmem_init()</a>. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l02275">2275</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l02251">lu_kmem_init()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02276"></a>02276 {
<a name="l02277"></a>02277         <span class="keywordflow">for</span> (; caches-&gt;ckd_cache != NULL; ++caches) {
<a name="l02278"></a>02278                 <span class="keywordflow">if</span> (*caches-&gt;ckd_cache != NULL) {
<a name="l02279"></a>02279                         kmem_cache_destroy(*caches-&gt;ckd_cache);
<a name="l02280"></a>02280                         *caches-&gt;ckd_cache = NULL;
<a name="l02281"></a>02281                 }
<a name="l02282"></a>02282         }
<a name="l02283"></a>02283 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_gac3834e0d4bd35c8a02d1003bf0f4331e_icgraph.png" border="0" usemap="#group__lu_gac3834e0d4bd35c8a02d1003bf0f4331e_icgraph_map" alt=""></div>
<map name="group__lu_gac3834e0d4bd35c8a02d1003bf0f4331e_icgraph_map" id="group__lu_gac3834e0d4bd35c8a02d1003bf0f4331e_icgraph">
<area shape="rect" id="node3" href="group__lu.html#ga42de365ae8cbdaa97c604434937a4822" title="Helper function to initialize a number of kmem slab caches at once." alt="" coords="164,5,273,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa0c00da42f82361409215468e0952e37"></a><!-- doxytag: member="lu_object.h::lu_object_add" ref="gaa0c00da42f82361409215468e0952e37" args="(struct lu_object *before, struct lu_object *o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_object_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td>
          <td class="paramname"> <em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td>
          <td class="paramname"> <em>o</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add object <em>o</em> as a layer of compound object, going after <em>before</em>. </p>
<p>This is typically called by the -&gt;ldo_object_alloc() method of <em>before-&gt;lo_dev</em>. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01292">1292</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00480">lu_object::lo_linkage</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01293"></a>01293 {
<a name="l01294"></a>01294         list_move(&amp;o-&gt;<a class="code" href="structlu__object.html#a40275d310eb13538f41291f1cf7cba77" title="Linkage into list of all layers.">lo_linkage</a>, &amp;before-&gt;<a class="code" href="structlu__object.html#a40275d310eb13538f41291f1cf7cba77" title="Linkage into list of all layers.">lo_linkage</a>);
<a name="l01295"></a>01295 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa83f38d5ed0268b449a3074d350c763d"></a><!-- doxytag: member="lu_object.h::lu_object_add_top" ref="gaa83f38d5ed0268b449a3074d350c763d" args="(struct lu_object_header *h, struct lu_object *o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_object_add_top </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlu__object__header.html">lu_object_header</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td>
          <td class="paramname"> <em>o</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add object <em>o</em> as first layer of compound object <em>h</em>. </p>
<p>This is typically called by the -&gt;ldo_object_alloc() method of top-level device. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01280">1280</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00480">lu_object::lo_linkage</a>, and <a class="el" href="lu__object_8h_source.html#l00552">lu_object_header::loh_layers</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01281"></a>01281 {
<a name="l01282"></a>01282         list_move(&amp;o-&gt;<a class="code" href="structlu__object.html#a40275d310eb13538f41291f1cf7cba77" title="Linkage into list of all layers.">lo_linkage</a>, &amp;h-&gt;<a class="code" href="structlu__object__header.html#a1a4f1dbeb2aadfe34d9d11ed0ede12ec" title="Linkage into list of layers.">loh_layers</a>);
<a name="l01283"></a>01283 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga507da2d12daef52e3859b9b96d0ae591"></a><!-- doxytag: member="lu_object.h::lu_object_find" ref="ga507da2d12daef52e3859b9b96d0ae591" args="(const struct lu_env *env, struct lu_device *dev, const struct lu_fid *f, const struct lu_object_conf *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__object.html">lu_object</a>* lu_object_find </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__device.html">lu_device</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlu__fid.html">lu_fid</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlu__object__conf.html">lu_object_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search cache for an object with the fid <em>f</em>. </p>
<p>If such object is found, return it. Otherwise, create new object, insert it into cache and return it. In any case, additional reference is acquired on the returned object. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l00643">643</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00283">lu_device::ld_site</a>, <a class="el" href="lu__object_8h_source.html#l00619">lu_site::ls_top_dev</a>, and <a class="el" href="lu__object_8c_source.html#l00778">lu_object_find_at()</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l00808">lu_object_find_slice()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00646"></a>00646 {
<a name="l00647"></a>00647         <span class="keywordflow">return</span> <a class="code" href="group__lu.html#gad0df5edda743e3ab2a9165faecb8656b" title="Much like lu_object_find(), but top level device of object is specifically dev rather...">lu_object_find_at</a>(env, dev-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>-&gt;<a class="code" href="structlu__site.html#a371ff1de170feccd1c80e3d7a0202965" title="Top-level device for this stack.">ls_top_dev</a>, f, conf);
<a name="l00648"></a>00648 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga507da2d12daef52e3859b9b96d0ae591_cgraph.png" border="0" usemap="#group__lu_ga507da2d12daef52e3859b9b96d0ae591_cgraph_map" alt=""></div>
<map name="group__lu_ga507da2d12daef52e3859b9b96d0ae591_cgraph_map" id="group__lu_ga507da2d12daef52e3859b9b96d0ae591_cgraph">
<area shape="rect" id="node3" href="group__lu.html#gad0df5edda743e3ab2a9165faecb8656b" title="Much like lu_object_find(), but top level device of object is specifically dev rather..." alt="" coords="169,5,305,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga507da2d12daef52e3859b9b96d0ae591_icgraph.png" border="0" usemap="#group__lu_ga507da2d12daef52e3859b9b96d0ae591_icgraph_map" alt=""></div>
<map name="group__lu_ga507da2d12daef52e3859b9b96d0ae591_icgraph_map" id="group__lu_ga507da2d12daef52e3859b9b96d0ae591_icgraph">
<area shape="rect" id="node3" href="group__lu.html#ga54cb269068bb3767dde66b0bb58afb70" title="Find object with given fid, and return its slice belonging to given device." alt="" coords="168,5,320,35"/><area shape="rect" id="node5" href="group__cl__object.html#gacc02a64c0c65d5fab9a6fafc83771acd" title="Returns a cl_object with a given fid." alt="" coords="368,5,483,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad0df5edda743e3ab2a9165faecb8656b"></a><!-- doxytag: member="lu_object.h::lu_object_find_at" ref="gad0df5edda743e3ab2a9165faecb8656b" args="(const struct lu_env *env, struct lu_device *dev, const struct lu_fid *f, const struct lu_object_conf *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlu__object.html">lu_object</a>* lu_object_find_at </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__device.html">lu_device</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlu__fid.html">lu_fid</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlu__object__conf.html">lu_object_conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Much like <a class="el" href="group__lu.html#ga507da2d12daef52e3859b9b96d0ae591" title="Search cache for an object with the fid f.">lu_object_find()</a>, but top level device of object is specifically <em>dev</em> rather than top level device of the site. </p>
<p>This interface allows objects of different "stacking" to be created within the same site. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l00778">778</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00283">lu_device::ld_site</a>, <a class="el" href="lu__object_8h_source.html#l00187">lu_object_conf::loc_flags</a>, and <a class="el" href="lu__object_8h_source.html#l00583">lu_site_bkt_data::lsb_marche_funebre</a>.</p>

<p>Referenced by <a class="el" href="lu__object_8c_source.html#l00643">lu_object_find()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00782"></a>00782 {
<a name="l00783"></a>00783         <span class="keyword">struct </span><a class="code" href="structlu__site__bkt__data.html">lu_site_bkt_data</a> *bkt;
<a name="l00784"></a>00784         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *obj;
<a name="l00785"></a>00785         wait_queue_t           wait;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         <span class="keywordflow">if</span> (conf != NULL &amp;&amp; conf-&gt;<a class="code" href="structlu__object__conf.html#ac9e27ea1ac308a8d3b2e8e9813056b93" title="Some hints for obj find and alloc.">loc_flags</a> &amp; LOC_F_NOWAIT)
<a name="l00788"></a>00788                 <span class="keywordflow">return</span> lu_object_find_try(env, dev, f, conf, NULL);
<a name="l00789"></a>00789 
<a name="l00790"></a>00790         <span class="keywordflow">while</span> (1) {
<a name="l00791"></a>00791                 obj = lu_object_find_try(env, dev, f, conf, &amp;wait);
<a name="l00792"></a>00792                 <span class="keywordflow">if</span> (obj != ERR_PTR(-EAGAIN))
<a name="l00793"></a>00793                         <span class="keywordflow">return</span> obj;
<a name="l00794"></a>00794                 <span class="comment">/*</span>
<a name="l00795"></a>00795 <span class="comment">                 * lu_object_find_try() already added waiter into the</span>
<a name="l00796"></a>00796 <span class="comment">                 * wait queue.</span>
<a name="l00797"></a>00797 <span class="comment">                 */</span>
<a name="l00798"></a>00798                 schedule();
<a name="l00799"></a>00799                 bkt = lu_site_bkt_from_fid(dev-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>, (<span class="keywordtype">void</span> *)f);
<a name="l00800"></a>00800                 remove_wait_queue(&amp;bkt-&gt;<a class="code" href="structlu__site__bkt__data.html#aa8c931b8cee4b10da00fc2dc35ff5f39" title="Wait-queue signaled when an object in this site is ultimately destroyed (lu_object_free())...">lsb_marche_funebre</a>, &amp;wait);
<a name="l00801"></a>00801         }
<a name="l00802"></a>00802 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_gad0df5edda743e3ab2a9165faecb8656b_icgraph.png" border="0" usemap="#group__lu_gad0df5edda743e3ab2a9165faecb8656b_icgraph_map" alt=""></div>
<map name="group__lu_gad0df5edda743e3ab2a9165faecb8656b_icgraph_map" id="group__lu_gad0df5edda743e3ab2a9165faecb8656b_icgraph">
<area shape="rect" id="node3" href="group__lu.html#ga507da2d12daef52e3859b9b96d0ae591" title="Search cache for an object with the fid f." alt="" coords="192,5,307,35"/><area shape="rect" id="node5" href="group__lu.html#ga54cb269068bb3767dde66b0bb58afb70" title="Find object with given fid, and return its slice belonging to given device." alt="" coords="355,5,507,35"/><area shape="rect" id="node7" href="group__cl__object.html#gacc02a64c0c65d5fab9a6fafc83771acd" title="Returns a cl_object with a given fid." alt="" coords="555,5,669,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga0d53e3777af7b81492a1178c75b872ea"></a><!-- doxytag: member="lu_object.h::lu_object_put" ref="ga0d53e3777af7b81492a1178c75b872ea" args="(const struct lu_env *env, struct lu_object *o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_object_put </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td>
          <td class="paramname"> <em>o</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrease reference counter on object. </p>
<p>If last reference is freed, return object to the cache, unless lu_object_is_dying(o) holds. In the latter case, free object immediately. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l00097">97</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00283">lu_device::ld_site</a>, <a class="el" href="lu__object_8h_source.html#l00472">lu_object::lo_dev</a>, <a class="el" href="lu__object_8h_source.html#l00468">lu_object::lo_header</a>, <a class="el" href="lu__object_8h_source.html#l00476">lu_object::lo_ops</a>, <a class="el" href="lu__object_8h_source.html#l00525">lu_object_header::loh_fid</a>, <a class="el" href="lu__object_8h_source.html#l00530">lu_object_header::loh_flags</a>, <a class="el" href="lu__object_8h_source.html#l00543">lu_object_header::loh_hash</a>, <a class="el" href="lu__object_8h_source.html#l00552">lu_object_header::loh_layers</a>, <a class="el" href="lu__object_8h_source.html#l00547">lu_object_header::loh_lru</a>, <a class="el" href="lu__object_8h_source.html#l00534">lu_object_header::loh_ref</a>, <a class="el" href="structlu__object__operations.html#a4fa5d3edafc04a638d06465d57ebc20a">lu_object_operations::loo_object_release</a>, <a class="el" href="lu__object_8h_source.html#l00611">lu_site::ls_obj_hash</a>, <a class="el" href="lu__object_8h_source.html#l00641">lu_site::ls_stats</a>, <a class="el" href="lu__object_8h_source.html#l00574">lu_site_bkt_data::lsb_lru</a>, <a class="el" href="lu__object_8h_source.html#l00565">lu_site_bkt_data::lsb_lru_len</a>, <a class="el" href="lu__object_8h_source.html#l00583">lu_site_bkt_data::lsb_marche_funebre</a>, <a class="el" href="lu__object_8h_source.html#l00840">lu_object_exists</a>, and <a class="el" href="lu__object_8h_source.html#l00497">LU_OBJECT_UNHASHED</a>.</p>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l00120">cl_object_put()</a>, <a class="el" href="dt__object_8c_source.html#l00911">dt_index_read()</a>, <a class="el" href="dt__object_8c_source.html#l00368">dt_store_open()</a>, <a class="el" href="llog__osd_8c_source.html#l01913">llog_osd_get_cat_list()</a>, <a class="el" href="llog__osd_8c_source.html#l02031">llog_osd_put_cat_list()</a>, <a class="el" href="lu__object_8c_source.html#l00808">lu_object_find_slice()</a>, and <a class="el" href="lu__object_8c_source.html#l00193">lu_object_put_nocache()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00098"></a>00098 {
<a name="l00099"></a>00099         <span class="keyword">struct </span><a class="code" href="structlu__site__bkt__data.html">lu_site_bkt_data</a> *bkt;
<a name="l00100"></a>00100         <span class="keyword">struct </span><a class="code" href="structlu__object__header.html" title="&amp;quot;Compound&amp;quot; object, consisting of multiple layers.">lu_object_header</a> *top;
<a name="l00101"></a>00101         <span class="keyword">struct </span><a class="code" href="structlu__site.html" title="lu_site is a &amp;quot;compartment&amp;quot; within which objects are unique, and LRU discipline...">lu_site</a>          *site;
<a name="l00102"></a>00102         <span class="keyword">struct </span><a class="code" href="structlu__object.html" title="Layer in the layered object.">lu_object</a>        *orig;
<a name="l00103"></a>00103         <span class="keyword">struct </span><a class="code" href="structcfs__hash__bd.html" title="cfs_hash bucket descriptor, it&amp;#39;s normally in stack of caller">cfs_hash_bd</a>            bd;
<a name="l00104"></a>00104         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__fid.html" title="File IDentifier.">lu_fid</a>     *fid;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106         top  = o-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>;
<a name="l00107"></a>00107         site = o-&gt;<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>;
<a name="l00108"></a>00108         orig = o;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         <span class="comment">/*</span>
<a name="l00111"></a>00111 <span class="comment">         * till we have full fids-on-OST implemented anonymous objects</span>
<a name="l00112"></a>00112 <span class="comment">         * are possible in OSP. such an object isn&apos;t listed in the site</span>
<a name="l00113"></a>00113 <span class="comment">         * so we should not remove it from the site.</span>
<a name="l00114"></a>00114 <span class="comment">         */</span>
<a name="l00115"></a>00115         fid = lu_object_fid(o);
<a name="l00116"></a>00116         <span class="keywordflow">if</span> (fid_is_zero(fid)) {
<a name="l00117"></a>00117                 LASSERT(top-&gt;<a class="code" href="structlu__object__header.html#a272b56e8a50cb14702e8310ded111bef" title="Linkage into per-site hash table.">loh_hash</a>.next == NULL
<a name="l00118"></a>00118                         &amp;&amp; top-&gt;<a class="code" href="structlu__object__header.html#a272b56e8a50cb14702e8310ded111bef" title="Linkage into per-site hash table.">loh_hash</a>.pprev == NULL);
<a name="l00119"></a>00119                 LASSERT(list_empty(&amp;top-&gt;<a class="code" href="structlu__object__header.html#aff6d162a88fea57464bd62a52393172d" title="Linkage into per-site LRU list.">loh_lru</a>));
<a name="l00120"></a>00120                 <span class="keywordflow">if</span> (!atomic_dec_and_test(&amp;top-&gt;<a class="code" href="structlu__object__header.html#ab0171f571d26d9b358edfdda51b5fb90" title="Object reference count.">loh_ref</a>))
<a name="l00121"></a>00121                         <span class="keywordflow">return</span>;
<a name="l00122"></a>00122                 list_for_each_entry_reverse(o, &amp;top-&gt;<a class="code" href="structlu__object__header.html#a1a4f1dbeb2aadfe34d9d11ed0ede12ec" title="Linkage into list of layers.">loh_layers</a>, lo_linkage) {
<a name="l00123"></a>00123                         <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structlu__object.html#a9a5e60cbf9d474fb4039dbb0d39e0a0f" title="Operations for this object.">lo_ops</a>-&gt;<a class="code" href="structlu__object__operations.html#a4fa5d3edafc04a638d06465d57ebc20a" title="Called when last active reference to the object is released (and object returns to...">loo_object_release</a> != NULL)
<a name="l00124"></a>00124                                 o-&gt;<a class="code" href="structlu__object.html#a9a5e60cbf9d474fb4039dbb0d39e0a0f" title="Operations for this object.">lo_ops</a>-&gt;<a class="code" href="structlu__object__operations.html#a4fa5d3edafc04a638d06465d57ebc20a" title="Called when last active reference to the object is released (and object returns to...">loo_object_release</a>(env, o);
<a name="l00125"></a>00125                 }
<a name="l00126"></a>00126                 lu_object_free(env, orig);
<a name="l00127"></a>00127                 <span class="keywordflow">return</span>;
<a name="l00128"></a>00128         }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130         cfs_hash_bd_get(site-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>, &amp;top-&gt;<a class="code" href="structlu__object__header.html#ae1336fa61cf0b1730f951b8255b9a4d7" title="Fid, uniquely identifying this object.">loh_fid</a>, &amp;bd);
<a name="l00131"></a>00131         bkt = cfs_hash_bd_extra_get(site-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>, &amp;bd);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133         <span class="keywordflow">if</span> (!cfs_hash_bd_dec_and_lock(site-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>, &amp;bd, &amp;top-&gt;<a class="code" href="structlu__object__header.html#ab0171f571d26d9b358edfdda51b5fb90" title="Object reference count.">loh_ref</a>)) {
<a name="l00134"></a>00134                 <span class="keywordflow">if</span> (lu_object_is_dying(top)) {
<a name="l00135"></a>00135 
<a name="l00136"></a>00136                         <span class="comment">/*</span>
<a name="l00137"></a>00137 <span class="comment">                         * somebody may be waiting for this, currently only</span>
<a name="l00138"></a>00138 <span class="comment">                         * used for cl_object, see cl_object_put_last().</span>
<a name="l00139"></a>00139 <span class="comment">                         */</span>
<a name="l00140"></a>00140                         wake_up_all(&amp;bkt-&gt;<a class="code" href="structlu__site__bkt__data.html#aa8c931b8cee4b10da00fc2dc35ff5f39" title="Wait-queue signaled when an object in this site is ultimately destroyed (lu_object_free())...">lsb_marche_funebre</a>);
<a name="l00141"></a>00141                 }
<a name="l00142"></a>00142                 <span class="keywordflow">return</span>;
<a name="l00143"></a>00143         }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         <span class="comment">/*</span>
<a name="l00146"></a>00146 <span class="comment">         * When last reference is released, iterate over object</span>
<a name="l00147"></a>00147 <span class="comment">         * layers, and notify them that object is no longer busy.</span>
<a name="l00148"></a>00148 <span class="comment">         */</span>
<a name="l00149"></a>00149         list_for_each_entry_reverse(o, &amp;top-&gt;<a class="code" href="structlu__object__header.html#a1a4f1dbeb2aadfe34d9d11ed0ede12ec" title="Linkage into list of layers.">loh_layers</a>, lo_linkage) {
<a name="l00150"></a>00150                 <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structlu__object.html#a9a5e60cbf9d474fb4039dbb0d39e0a0f" title="Operations for this object.">lo_ops</a>-&gt;<a class="code" href="structlu__object__operations.html#a4fa5d3edafc04a638d06465d57ebc20a" title="Called when last active reference to the object is released (and object returns to...">loo_object_release</a> != NULL)
<a name="l00151"></a>00151                         o-&gt;<a class="code" href="structlu__object.html#a9a5e60cbf9d474fb4039dbb0d39e0a0f" title="Operations for this object.">lo_ops</a>-&gt;<a class="code" href="structlu__object__operations.html#a4fa5d3edafc04a638d06465d57ebc20a" title="Called when last active reference to the object is released (and object returns to...">loo_object_release</a>(env, o);
<a name="l00152"></a>00152         }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         <span class="keywordflow">if</span> (!lu_object_is_dying(top) &amp;&amp;
<a name="l00155"></a>00155             (<a class="code" href="group__lu.html#gacef4aec6c28892e386a8d3cca26aeb28" title="Check whether object exists, no matter on local or remote storage.">lu_object_exists</a>(orig) || lu_object_is_cl(orig))) {
<a name="l00156"></a>00156                 LASSERT(list_empty(&amp;top-&gt;<a class="code" href="structlu__object__header.html#aff6d162a88fea57464bd62a52393172d" title="Linkage into per-site LRU list.">loh_lru</a>));
<a name="l00157"></a>00157                 list_add_tail(&amp;top-&gt;<a class="code" href="structlu__object__header.html#aff6d162a88fea57464bd62a52393172d" title="Linkage into per-site LRU list.">loh_lru</a>, &amp;bkt-&gt;<a class="code" href="structlu__site__bkt__data.html#a00b13152bbc2577cd424f9ae36679a25" title="LRU list, updated on each access to object.">lsb_lru</a>);
<a name="l00158"></a>00158                 bkt-&gt;<a class="code" href="structlu__site__bkt__data.html#a224e97b74da74bc3709dda5476fd2e64" title="number of object in this bucket on the lsb_lru list.">lsb_lru_len</a>++;
<a name="l00159"></a>00159                 lprocfs_counter_incr(site-&gt;<a class="code" href="structlu__site.html#a8ad58aaa4f53edadbfed67c548bc3f77" title="lu_site stats">ls_stats</a>, LU_SS_LRU_LEN);
<a name="l00160"></a>00160                 CDEBUG(D_INODE, <span class="stringliteral">&quot;Add %p to site lru. hash: %p, bkt: %p, &quot;</span>
<a name="l00161"></a>00161                        <span class="stringliteral">&quot;lru_len: %ld\n&quot;</span>,
<a name="l00162"></a>00162                        o, site-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>, bkt, bkt-&gt;<a class="code" href="structlu__site__bkt__data.html#a224e97b74da74bc3709dda5476fd2e64" title="number of object in this bucket on the lsb_lru list.">lsb_lru_len</a>);
<a name="l00163"></a>00163                 cfs_hash_bd_unlock(site-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>, &amp;bd, 1);
<a name="l00164"></a>00164                 <span class="keywordflow">return</span>;
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167         <span class="comment">/*</span>
<a name="l00168"></a>00168 <span class="comment">         * If object is dying (will not be cached) then remove it</span>
<a name="l00169"></a>00169 <span class="comment">         * from hash table and LRU.</span>
<a name="l00170"></a>00170 <span class="comment">         *</span>
<a name="l00171"></a>00171 <span class="comment">         * This is done with hash table and LRU lists locked. As the only</span>
<a name="l00172"></a>00172 <span class="comment">         * way to acquire first reference to previously unreferenced</span>
<a name="l00173"></a>00173 <span class="comment">         * object is through hash-table lookup (lu_object_find()),</span>
<a name="l00174"></a>00174 <span class="comment">         * or LRU scanning (lu_site_purge()), that are done under hash-table</span>
<a name="l00175"></a>00175 <span class="comment">         * and LRU lock, no race with concurrent object lookup is possible</span>
<a name="l00176"></a>00176 <span class="comment">         * and we can safely destroy object below.</span>
<a name="l00177"></a>00177 <span class="comment">         */</span>
<a name="l00178"></a>00178         <span class="keywordflow">if</span> (!test_and_set_bit(<a class="code" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985a5d6ad2787701c40ef595e1ccdb31ae45" title="Mark this object has already been taken out of cache.">LU_OBJECT_UNHASHED</a>, &amp;top-&gt;<a class="code" href="structlu__object__header.html#a85952a1c723e48ffa0bb7024438ac08f" title="Object flags from enum lu_object_header_flags.">loh_flags</a>))
<a name="l00179"></a>00179                 cfs_hash_bd_del_locked(site-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>, &amp;bd, &amp;top-&gt;<a class="code" href="structlu__object__header.html#a272b56e8a50cb14702e8310ded111bef" title="Linkage into per-site hash table.">loh_hash</a>);
<a name="l00180"></a>00180         cfs_hash_bd_unlock(site-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>, &amp;bd, 1);
<a name="l00181"></a>00181         <span class="comment">/*</span>
<a name="l00182"></a>00182 <span class="comment">         * Object was already removed from hash and lru above, can</span>
<a name="l00183"></a>00183 <span class="comment">         * kill it.</span>
<a name="l00184"></a>00184 <span class="comment">         */</span>
<a name="l00185"></a>00185         lu_object_free(env, orig);
<a name="l00186"></a>00186 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga0d53e3777af7b81492a1178c75b872ea_icgraph.png" border="0" usemap="#group__lu_ga0d53e3777af7b81492a1178c75b872ea_icgraph_map" alt=""></div>
<map name="group__lu_ga0d53e3777af7b81492a1178c75b872ea_icgraph_map" id="group__lu_ga0d53e3777af7b81492a1178c75b872ea_icgraph">
<area shape="rect" id="node3" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o." alt="" coords="200,5,315,35"/><area shape="rect" id="node9" href="group__dt.html#ga311aa8b791e51a13353036585b1236a4" title="Walk key/record pairs of an index and copy them into 4KB containers to be transferred..." alt="" coords="199,59,316,88"/><area shape="rect" id="node11" href="group__dt.html#ga589d233b6276fc177086429e37221e36" title="Open dt object named filename from dirname directory." alt="" coords="197,112,317,141"/><area shape="rect" id="node13" href="group__log.html#gaf0dee2455ecbe5cbeeec044344224613" title="Read the special file which contains the list of llog catalogs IDs." alt="" coords="176,165,339,195"/><area shape="rect" id="node15" href="group__log.html#ga4b308f3bee04638c301ba0bead3ad070" title="Write the special file which contains the list of llog catalogs IDs." alt="" coords="177,219,337,248"/><area shape="rect" id="node17" href="group__lu.html#ga54cb269068bb3767dde66b0bb58afb70" title="Find object with given fid, and return its slice belonging to given device." alt="" coords="181,272,333,301"/><area shape="rect" id="node21" href="group__lu.html#ga48ae307342778b2ffb56cae3dad5d012" title="Put object and don&#39;t keep in cache." alt="" coords="168,325,347,355"/><area shape="rect" id="node5" href="group__osc.html#gacad2bab69d5c52c6248c0b76fcf1e93a" title="Drop &#160;of pages from LRU at most." alt="" coords="421,5,533,35"/><area shape="rect" id="node7" href="group__osc.html#ga084c788be8d116db87ebdd3c273d9a23" title="Scan and try to reclaim sc&#45;&gt;nr_to_scan cached LRU pages." alt="" coords="608,5,784,35"/><area shape="rect" id="node19" href="group__cl__object.html#gacc02a64c0c65d5fab9a6fafc83771acd" title="Returns a cl_object with a given fid." alt="" coords="420,272,535,301"/><area shape="rect" id="node23" href="group__dt.html#gacddd08c8c9a92143811432373ca8a057" title="Initialize local OID storage for required sequence." alt="" coords="395,325,560,355"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga48ae307342778b2ffb56cae3dad5d012"></a><!-- doxytag: member="lu_object.h::lu_object_put_nocache" ref="ga48ae307342778b2ffb56cae3dad5d012" args="(const struct lu_env *env, struct lu_object *o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_object_put_nocache </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td>
          <td class="paramname"> <em>o</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put object and don't keep in cache. </p>
<p>This is temporary solution for multi-site objects when its layering is not constant. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l00193">193</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00468">lu_object::lo_header</a>, <a class="el" href="lu__object_8h_source.html#l00530">lu_object_header::loh_flags</a>, <a class="el" href="lu__object_8h_source.html#l00493">LU_OBJECT_HEARD_BANSHEE</a>, and <a class="el" href="lu__object_8c_source.html#l00097">lu_object_put()</a>.</p>

<p>Referenced by <a class="el" href="local__storage_8c_source.html#l00803">local_oid_storage_init()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00194"></a>00194 {
<a name="l00195"></a>00195         set_bit(<a class="code" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985aca9a04f530d5436e7996a1ff142d01d0" title="Don&amp;#39;t keep this object in cache.">LU_OBJECT_HEARD_BANSHEE</a>, &amp;o-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>-&gt;<a class="code" href="structlu__object__header.html#a85952a1c723e48ffa0bb7024438ac08f" title="Object flags from enum lu_object_header_flags.">loh_flags</a>);
<a name="l00196"></a>00196         <span class="keywordflow">return</span> <a class="code" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object.">lu_object_put</a>(env, o);
<a name="l00197"></a>00197 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga48ae307342778b2ffb56cae3dad5d012_cgraph.png" border="0" usemap="#group__lu_ga48ae307342778b2ffb56cae3dad5d012_cgraph_map" alt=""></div>
<map name="group__lu_ga48ae307342778b2ffb56cae3dad5d012_cgraph_map" id="group__lu_ga48ae307342778b2ffb56cae3dad5d012_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga0d53e3777af7b81492a1178c75b872ea" title="Decrease reference counter on object." alt="" coords="232,5,347,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_ga48ae307342778b2ffb56cae3dad5d012_icgraph.png" border="0" usemap="#group__lu_ga48ae307342778b2ffb56cae3dad5d012_icgraph_map" alt=""></div>
<map name="group__lu_ga48ae307342778b2ffb56cae3dad5d012_icgraph_map" id="group__lu_ga48ae307342778b2ffb56cae3dad5d012_icgraph">
<area shape="rect" id="node3" href="group__dt.html#gacddd08c8c9a92143811432373ca8a057" title="Initialize local OID storage for required sequence." alt="" coords="232,5,397,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga5efa3dbe314fd74875195c5a5aeb791d"></a><!-- doxytag: member="lu_object.h::lu_object_unhash" ref="ga5efa3dbe314fd74875195c5a5aeb791d" args="(const struct lu_env *env, struct lu_object *o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_object_unhash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__object.html">lu_object</a> *&nbsp;</td>
          <td class="paramname"> <em>o</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kill the object and take it out of LRU cache. </p>
<p>Currently used by client code for layout change. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l00204">204</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00283">lu_device::ld_site</a>, <a class="el" href="lu__object_8h_source.html#l00472">lu_object::lo_dev</a>, <a class="el" href="lu__object_8h_source.html#l00468">lu_object::lo_header</a>, <a class="el" href="lu__object_8h_source.html#l00525">lu_object_header::loh_fid</a>, <a class="el" href="lu__object_8h_source.html#l00530">lu_object_header::loh_flags</a>, <a class="el" href="lu__object_8h_source.html#l00543">lu_object_header::loh_hash</a>, <a class="el" href="lu__object_8h_source.html#l00547">lu_object_header::loh_lru</a>, <a class="el" href="lu__object_8h_source.html#l00611">lu_site::ls_obj_hash</a>, <a class="el" href="lu__object_8h_source.html#l00641">lu_site::ls_stats</a>, <a class="el" href="lu__object_8h_source.html#l00565">lu_site_bkt_data::lsb_lru_len</a>, <a class="el" href="lu__object_8h_source.html#l00493">LU_OBJECT_HEARD_BANSHEE</a>, and <a class="el" href="lu__object_8h_source.html#l00497">LU_OBJECT_UNHASHED</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00205"></a>00205 {
<a name="l00206"></a>00206         <span class="keyword">struct </span><a class="code" href="structlu__object__header.html" title="&amp;quot;Compound&amp;quot; object, consisting of multiple layers.">lu_object_header</a> *top;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208         top = o-&gt;<a class="code" href="structlu__object.html#ab55ad0889ad4d306d0a5aad7ed0aa398" title="Header for this object.">lo_header</a>;
<a name="l00209"></a>00209         set_bit(<a class="code" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985aca9a04f530d5436e7996a1ff142d01d0" title="Don&amp;#39;t keep this object in cache.">LU_OBJECT_HEARD_BANSHEE</a>, &amp;top-&gt;<a class="code" href="structlu__object__header.html#a85952a1c723e48ffa0bb7024438ac08f" title="Object flags from enum lu_object_header_flags.">loh_flags</a>);
<a name="l00210"></a>00210         <span class="keywordflow">if</span> (!test_and_set_bit(<a class="code" href="group__lu.html#gga519a2e6103ae639c8df1777d311cc985a5d6ad2787701c40ef595e1ccdb31ae45" title="Mark this object has already been taken out of cache.">LU_OBJECT_UNHASHED</a>, &amp;top-&gt;<a class="code" href="structlu__object__header.html#a85952a1c723e48ffa0bb7024438ac08f" title="Object flags from enum lu_object_header_flags.">loh_flags</a>)) {
<a name="l00211"></a>00211                 <span class="keyword">struct </span><a class="code" href="structlu__site.html" title="lu_site is a &amp;quot;compartment&amp;quot; within which objects are unique, and LRU discipline...">lu_site</a> *site = o-&gt;<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>;
<a name="l00212"></a>00212                 <span class="keyword">struct </span><a class="code" href="structcfs__hash.html" title="cfs_hash is a hash-table implementation for general purpose, it can support: .">cfs_hash</a> *obj_hash = site-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>;
<a name="l00213"></a>00213                 <span class="keyword">struct </span><a class="code" href="structcfs__hash__bd.html" title="cfs_hash bucket descriptor, it&amp;#39;s normally in stack of caller">cfs_hash_bd</a> bd;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215                 cfs_hash_bd_get_and_lock(obj_hash, &amp;top-&gt;<a class="code" href="structlu__object__header.html#ae1336fa61cf0b1730f951b8255b9a4d7" title="Fid, uniquely identifying this object.">loh_fid</a>, &amp;bd, 1);
<a name="l00216"></a>00216                 <span class="keywordflow">if</span> (!list_empty(&amp;top-&gt;<a class="code" href="structlu__object__header.html#aff6d162a88fea57464bd62a52393172d" title="Linkage into per-site LRU list.">loh_lru</a>)) {
<a name="l00217"></a>00217                         <span class="keyword">struct </span><a class="code" href="structlu__site__bkt__data.html">lu_site_bkt_data</a> *bkt;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219                         list_del_init(&amp;top-&gt;<a class="code" href="structlu__object__header.html#aff6d162a88fea57464bd62a52393172d" title="Linkage into per-site LRU list.">loh_lru</a>);
<a name="l00220"></a>00220                         bkt = cfs_hash_bd_extra_get(obj_hash, &amp;bd);
<a name="l00221"></a>00221                         bkt-&gt;<a class="code" href="structlu__site__bkt__data.html#a224e97b74da74bc3709dda5476fd2e64" title="number of object in this bucket on the lsb_lru list.">lsb_lru_len</a>--;
<a name="l00222"></a>00222                         lprocfs_counter_decr(site-&gt;<a class="code" href="structlu__site.html#a8ad58aaa4f53edadbfed67c548bc3f77" title="lu_site stats">ls_stats</a>, LU_SS_LRU_LEN);
<a name="l00223"></a>00223                 }
<a name="l00224"></a>00224                 cfs_hash_bd_del_locked(obj_hash, &amp;bd, &amp;top-&gt;<a class="code" href="structlu__object__header.html#a272b56e8a50cb14702e8310ded111bef" title="Linkage into per-site hash table.">loh_hash</a>);
<a name="l00225"></a>00225                 cfs_hash_bd_unlock(obj_hash, &amp;bd, 1);
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaab0f4c7f840a5d798e5a4f23d68abacd"></a><!-- doxytag: member="lu_object.h::lu_site_stats_seq_print" ref="gaab0f4c7f840a5d798e5a4f23d68abacd" args="(const struct lu_site *s, struct seq_file *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lu_site_stats_seq_print </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__site.html">lu_site</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct seq_file *&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output site statistical counters into a buffer. </p>
<p>Suitable for ll_rd_*()-style functions.</p>
<p>Suitable for lprocfs_rd_*()-style functions. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l02224">2224</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00611">lu_site::ls_obj_hash</a>, and <a class="el" href="lu__object_8h_source.html#l00641">lu_site::ls_stats</a>.</p>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l00518">cl_site_stats_print()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02225"></a>02225 {
<a name="l02226"></a>02226         lu_site_stats_t stats;
<a name="l02227"></a>02227 
<a name="l02228"></a>02228         memset(&amp;stats, 0, <span class="keyword">sizeof</span>(stats));
<a name="l02229"></a>02229         lu_site_stats_get(s-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>, &amp;stats, 1);
<a name="l02230"></a>02230 
<a name="l02231"></a>02231         seq_printf(m, <span class="stringliteral">&quot;%d/%d %d/%d %d %d %d %d %d %d %d %d\n&quot;</span>,
<a name="l02232"></a>02232                    stats.lss_busy,
<a name="l02233"></a>02233                    stats.lss_total,
<a name="l02234"></a>02234                    stats.lss_populated,
<a name="l02235"></a>02235                    CFS_HASH_NHLIST(s-&gt;<a class="code" href="structlu__site.html#a7996224294b9ffc18b2fcf5b233f1ef3" title="objects hash table">ls_obj_hash</a>),
<a name="l02236"></a>02236                    stats.lss_max_search,
<a name="l02237"></a>02237                    ls_stats_read(s-&gt;<a class="code" href="structlu__site.html#a8ad58aaa4f53edadbfed67c548bc3f77" title="lu_site stats">ls_stats</a>, LU_SS_CREATED),
<a name="l02238"></a>02238                    ls_stats_read(s-&gt;<a class="code" href="structlu__site.html#a8ad58aaa4f53edadbfed67c548bc3f77" title="lu_site stats">ls_stats</a>, LU_SS_CACHE_HIT),
<a name="l02239"></a>02239                    ls_stats_read(s-&gt;<a class="code" href="structlu__site.html#a8ad58aaa4f53edadbfed67c548bc3f77" title="lu_site stats">ls_stats</a>, LU_SS_CACHE_MISS),
<a name="l02240"></a>02240                    ls_stats_read(s-&gt;<a class="code" href="structlu__site.html#a8ad58aaa4f53edadbfed67c548bc3f77" title="lu_site stats">ls_stats</a>, LU_SS_CACHE_RACE),
<a name="l02241"></a>02241                    ls_stats_read(s-&gt;<a class="code" href="structlu__site.html#a8ad58aaa4f53edadbfed67c548bc3f77" title="lu_site stats">ls_stats</a>, LU_SS_CACHE_DEATH_RACE),
<a name="l02242"></a>02242                    ls_stats_read(s-&gt;<a class="code" href="structlu__site.html#a8ad58aaa4f53edadbfed67c548bc3f77" title="lu_site stats">ls_stats</a>, LU_SS_LRU_PURGED),
<a name="l02243"></a>02243                    ls_stats_read(s-&gt;<a class="code" href="structlu__site.html#a8ad58aaa4f53edadbfed67c548bc3f77" title="lu_site stats">ls_stats</a>, LU_SS_LRU_LEN));
<a name="l02244"></a>02244         <span class="keywordflow">return</span> 0;
<a name="l02245"></a>02245 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_gaab0f4c7f840a5d798e5a4f23d68abacd_icgraph.png" border="0" usemap="#group__lu_gaab0f4c7f840a5d798e5a4f23d68abacd_icgraph_map" alt=""></div>
<map name="group__lu_gaab0f4c7f840a5d798e5a4f23d68abacd_icgraph_map" id="group__lu_gaab0f4c7f840a5d798e5a4f23d68abacd_icgraph">
<area shape="rect" id="node3" href="group__clio.html#ga5898f38acc8064feb8aecae6b0cbffd4" title="Outputs client site statistical counters into a buffer." alt="" coords="232,5,379,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gadaddcc81c2131ec1158c21f009cf1739"></a><!-- doxytag: member="lu_object.h::lu_stack_fini" ref="gadaddcc81c2131ec1158c21f009cf1739" args="(const struct lu_env *env, struct lu_device *top)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lu_stack_fini </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlu__device.html">lu_device</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalize and free devices in the device stack. </p>
<p>Finalize device stack by purging object cache, and calling <a class="el" href="structlu__device__type__operations.html#a9195fd4ea14e00bbe2d9318d60694263" title="Finalize device.">lu_device_type_operations::ldto_device_fini()</a> and <a class="el" href="structlu__device__type__operations.html#a190c1198c588f2ed23ab58052f4001bf" title="Free device.">lu_device_type_operations::ldto_device_free()</a> on all devices in the stack. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01349">1349</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

<p>References <a class="el" href="lu__object_8h_source.html#l00291">lu_device::ld_reference</a>, <a class="el" href="lu__object_8h_source.html#l00283">lu_device::ld_site</a>, <a class="el" href="lu__object_8h_source.html#l00275">lu_device::ld_type</a>, <a class="el" href="lu__object_8h_source.html#l00332">lu_device_type::ldt_obd_type</a>, <a class="el" href="lu__object_8h_source.html#l00328">lu_device_type::ldt_ops</a>, <a class="el" href="structlu__device__type__operations.html#a9195fd4ea14e00bbe2d9318d60694263">lu_device_type_operations::ldto_device_fini</a>, <a class="el" href="structlu__device__type__operations.html#a190c1198c588f2ed23ab58052f4001bf">lu_device_type_operations::ldto_device_free</a>, <a class="el" href="lu__object_8c_source.html#l01190">lu_device_put()</a>, <a class="el" href="lu__object_8c_source.html#l01058">lu_site_init()</a>, and <a class="el" href="lu__object_8c_source.html#l00352">lu_site_purge()</a>.</p>

<p>Referenced by <a class="el" href="cl__object_8c_source.html#l01282">cl_stack_fini()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01350"></a>01350 {
<a name="l01351"></a>01351         <span class="keyword">struct </span><a class="code" href="structlu__site.html" title="lu_site is a &amp;quot;compartment&amp;quot; within which objects are unique, and LRU discipline...">lu_site</a>   *site = top-&gt;<a class="code" href="structlu__device.html#aaa1ef1e1a330f307a9baf6e59fc9c39b" title="Stack this device belongs to.">ld_site</a>;
<a name="l01352"></a>01352         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *scan;
<a name="l01353"></a>01353         <span class="keyword">struct </span><a class="code" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> *next;
<a name="l01354"></a>01354 
<a name="l01355"></a>01355         <a class="code" href="group__lu.html#ga00642c90cffacaa9db84e3bb03188f0d" title="Free nr objects from the cold end of the site LRU list.">lu_site_purge</a>(env, site, ~0);
<a name="l01356"></a>01356         <span class="keywordflow">for</span> (scan = top; scan != NULL; scan = next) {
<a name="l01357"></a>01357                 next = scan-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>-&gt;<a class="code" href="structlu__device__type.html#a13b6c99cdcbae4f8eeb9e707d32ee8be" title="Operations for this type.">ldt_ops</a>-&gt;<a class="code" href="structlu__device__type__operations.html#a9195fd4ea14e00bbe2d9318d60694263" title="Finalize device.">ldto_device_fini</a>(env, scan);
<a name="l01358"></a>01358                 lu_ref_del(&amp;scan-&gt;<a class="code" href="structlu__device.html#ab239841238af7f4beb29b48bba2c6bc2" title="A list of references to this object, for debugging.">ld_reference</a>, <span class="stringliteral">&quot;lu-stack&quot;</span>, &amp;<a class="code" href="group__lu.html#ga3776a9c76adcfa00202f6fe19751c96e" title="Initialize site s, with d as the top level device.">lu_site_init</a>);
<a name="l01359"></a>01359                 <a class="code" href="group__lu.html#ga2c86262bfddc5bac1777e7f6fefb35f0" title="Release reference on device d.">lu_device_put</a>(scan);
<a name="l01360"></a>01360         }
<a name="l01361"></a>01361 
<a name="l01362"></a>01362         <span class="comment">/* purge again. */</span>
<a name="l01363"></a>01363         <a class="code" href="group__lu.html#ga00642c90cffacaa9db84e3bb03188f0d" title="Free nr objects from the cold end of the site LRU list.">lu_site_purge</a>(env, site, ~0);
<a name="l01364"></a>01364 
<a name="l01365"></a>01365         <span class="keywordflow">for</span> (scan = top; scan != NULL; scan = next) {
<a name="l01366"></a>01366                 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlu__device__type.html" title="Type of device.">lu_device_type</a> *ldt = scan-&gt;<a class="code" href="structlu__device.html#ad5886c6b5e9a91f07f22d33bbcdb5718" title="Pointer to device type.">ld_type</a>;
<a name="l01367"></a>01367                 <span class="keyword">struct </span><a class="code" href="structobd__type.html">obd_type</a>             *type;
<a name="l01368"></a>01368 
<a name="l01369"></a>01369                 next = ldt-&gt;<a class="code" href="structlu__device__type.html#a13b6c99cdcbae4f8eeb9e707d32ee8be" title="Operations for this type.">ldt_ops</a>-&gt;<a class="code" href="structlu__device__type__operations.html#a190c1198c588f2ed23ab58052f4001bf" title="Free device.">ldto_device_free</a>(env, scan);
<a name="l01370"></a>01370                 type = ldt-&gt;<a class="code" href="structlu__device__type.html#aac80ee520ebbbf8fc7b57226f38882a1">ldt_obd_type</a>;
<a name="l01371"></a>01371                 <span class="keywordflow">if</span> (type != NULL) {
<a name="l01372"></a>01372                         type-&gt;typ_refcnt--;
<a name="l01373"></a>01373                         class_put_type(type);
<a name="l01374"></a>01374                 }
<a name="l01375"></a>01375         }
<a name="l01376"></a>01376 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_gadaddcc81c2131ec1158c21f009cf1739_cgraph.png" border="0" usemap="#group__lu_gadaddcc81c2131ec1158c21f009cf1739_cgraph_map" alt=""></div>
<map name="group__lu_gadaddcc81c2131ec1158c21f009cf1739_cgraph_map" id="group__lu_gadaddcc81c2131ec1158c21f009cf1739_cgraph">
<area shape="rect" id="node3" href="group__lu.html#ga2c86262bfddc5bac1777e7f6fefb35f0" title="Release reference on device d." alt="" coords="157,5,272,35"/><area shape="rect" id="node5" href="group__lu.html#ga3776a9c76adcfa00202f6fe19751c96e" title="Initialize site s, with d as the top level device." alt="" coords="168,59,261,88"/><area shape="rect" id="node9" href="group__lu.html#ga00642c90cffacaa9db84e3bb03188f0d" title="Free nr objects from the cold end of the site LRU list." alt="" coords="160,112,269,141"/><area shape="rect" id="node7" href="group__lu.html#ga29fe0250f218e64064069bcc3116e481" title="Acquire additional reference on device d." alt="" coords="321,59,436,88"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__lu_gadaddcc81c2131ec1158c21f009cf1739_icgraph.png" border="0" usemap="#group__lu_gadaddcc81c2131ec1158c21f009cf1739_icgraph_map" alt=""></div>
<map name="group__lu_gadaddcc81c2131ec1158c21f009cf1739_icgraph_map" id="group__lu_gadaddcc81c2131ec1158c21f009cf1739_icgraph">
<area shape="rect" id="node3" href="group__clio.html#ga0f3ca66265a771105086ea8d48cd814d" title="Finalize device stack by calling lu_stack_fini()." alt="" coords="159,5,260,35"/></map>
</div>
</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gaac7bd33ed56770c84e26b4553c6d0078"></a><!-- doxytag: member="lu_object.h::lu_context_tags_default" ref="gaac7bd33ed56770c84e26b4553c6d0078" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__u32 <a class="el" href="group__lu.html#gaac7bd33ed56770c84e26b4553c6d0078">lu_context_tags_default</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lu_ctx_tags/lu_ses_tags will be updated if there are new types of obd being added. </p>
<p>Currently, this is only used on client side, specifically for echo device client, for other stack (like ptlrpc threads), context are predefined when the <a class="el" href="structlu__device.html" title="Device: a layer in the server side abstraction stacking.">lu_device</a> type are registered, during the module probe phase. </p>

<p>Definition at line <a class="el" href="lu__object_8c_source.html#l01830">1830</a> of file <a class="el" href="lu__object_8c_source.html">lu_object.c</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:55:39 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
