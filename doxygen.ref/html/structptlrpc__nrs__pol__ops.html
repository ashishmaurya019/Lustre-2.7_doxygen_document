<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: ptlrpc_nrs_pol_ops Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ptlrpc_nrs_pol_ops Struct Reference<br/>
<small>
[<a class="el" href="group__nrs.html">Network Request Scheduler</a>]</small>
</h1><!-- doxytag: class="ptlrpc_nrs_pol_ops" -->
<p>NRS policy operations.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a569dc08f6db72425acb3af23817016b5">op_policy_init</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called during policy registration; this operation is optional.  <a href="#a569dc08f6db72425acb3af23817016b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a19f8bfc734d211149596592a8381e336">op_policy_fini</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called during policy unregistration; this operation is optional.  <a href="#a19f8bfc734d211149596592a8381e336"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a04b4479f93de2fbd7380f10ffaf5f35c">op_policy_start</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, char *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when activating a policy via lprocfs; policies allocate and initialize their resources here; this operation is optional.  <a href="#a04b4479f93de2fbd7380f10ffaf5f35c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a858a315f60b599de84db2cadfb9d6784">op_policy_stop</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when deactivating a policy via lprocfs; policies deallocate their resources here; this operation is optional.  <a href="#a858a315f60b599de84db2cadfb9d6784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#ad5e959465f0b9fd65ae096036df926d3">op_policy_ctl</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a> opc, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for policy-specific operations; i.e.  <a href="#ad5e959465f0b9fd65ae096036df926d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#affec8ac80f98364807dfe58e82fe4afe">op_res_get</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq, const struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *parent, struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> **resp, bool moving_req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when obtaining references to the resources of the resource hierarchy for a request that has arrived for handling at the PTLRPC service.  <a href="#affec8ac80f98364807dfe58e82fe4afe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a1fc1f744ceed9307e93dc3ad6f9f882b">op_res_put</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, const struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *res)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when releasing references taken for resources in the resource hierarchy for the request; this operation is optional.  <a href="#a1fc1f744ceed9307e93dc3ad6f9f882b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#ad7f082871c0f527c8d6b1c27c40a88e6">op_req_get</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, bool peek, bool force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains a request for handling from the policy, and optionally removes the request from the policy; this operation is mandatory.  <a href="#ad7f082871c0f527c8d6b1c27c40a88e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#ae4c73dc673c0175574a7eee691f846a2">op_req_enqueue</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when attempting to add a request to a policy for later handling; this operation is mandatory.  <a href="#ae4c73dc673c0175574a7eee691f846a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a1eb83c9a1da21c4090e85c6711dbf6d6">op_req_dequeue</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a request from the policy's set of pending requests.  <a href="#a1eb83c9a1da21c4090e85c6711dbf6d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#afda655439032cd5103c48bfdafa6d98a">op_req_stop</a> )(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called after the request being carried out.  <a href="#afda655439032cd5103c48bfdafa6d98a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#ad81393abaf1277b8fdebc3f67903c55a">op_lprocfs_init</a> )(struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers the policy's lprocfs interface with a PTLRPC service.  <a href="#ad81393abaf1277b8fdebc3f67903c55a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__nrs__pol__ops.html#a4278270d8cf6849261467dd6a69bd19a">op_lprocfs_fini</a> )(struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unegisters the policy's lprocfs interface with a PTLRPC service.  <a href="#a4278270d8cf6849261467dd6a69bd19a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>NRS policy operations. </p>
<p>These determine the behaviour of a policy, and are called in response to NRS core events. </p>

<p>Definition at line <a class="el" href="lustre__nrs_8h_source.html#l00075">75</a> of file <a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a4278270d8cf6849261467dd6a69bd19a"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_lprocfs_fini" ref="a4278270d8cf6849261467dd6a69bd19a" args=")(struct ptlrpc_service *svc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a4278270d8cf6849261467dd6a69bd19a">ptlrpc_nrs_pol_ops::op_lprocfs_fini</a>)(struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unegisters the policy's lprocfs interface with a PTLRPC service. </p>
<p>In cases of failed policy registration in <em><a class="el" href="group__nrs.html#ga5de7e78460dcd401c48a46cf67ac9851" title="Registers a new policy with NRS core.">ptlrpc_nrs_policy_register()</a></em>, this function may be called for a service which has not registered the policy successfully, so implementations of this method should make sure their operations are safe in such cases.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svc</em>&nbsp;</td><td>The service </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01099">nrs_policy_unregister_locked()</a>, and <a class="el" href="nrs_8c_source.html#l01435">ptlrpc_service_nrs_cleanup()</a>.</p>

</div>
</div>
<a class="anchor" id="ad81393abaf1277b8fdebc3f67903c55a"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_lprocfs_init" ref="ad81393abaf1277b8fdebc3f67903c55a" args=")(struct ptlrpc_service *svc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#ad81393abaf1277b8fdebc3f67903c55a">ptlrpc_nrs_pol_ops::op_lprocfs_init</a>)(struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers the policy's lprocfs interface with a PTLRPC service. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svc</em>&nbsp;</td><td>The service</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>!=</em>&nbsp;</td><td>0 error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01165">ptlrpc_nrs_policy_register()</a>, and <a class="el" href="nrs_8c_source.html#l01390">ptlrpc_service_nrs_setup()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5e959465f0b9fd65ae096036df926d3"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_ctl" ref="ad5e959465f0b9fd65ae096036df926d3" args=")(struct ptlrpc_nrs_policy *policy, enum ptlrpc_nrs_ctl opc, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#ad5e959465f0b9fd65ae096036df926d3">ptlrpc_nrs_pol_ops::op_policy_ctl</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a> opc, void *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used for policy-specific operations; i.e. </p>
<p>not generic ones like <em>PTLRPC_NRS_CTL_START</em> and <em>PTLRPC_NRS_CTL_GET_INFO</em>; analogous to an ioctl; this operation is optional.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy carrying out operation <em>opc</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>opc</em>&nbsp;</td><td>The command operation being carried out </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>An generic buffer for communication between the user and the control operation</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#a4970fb4b913c82e5566a7ecbcd8a26b7" title="Carries out a control operation opc on the policy identified by the human-readable...">ptlrpc_nrs_policy_control()</a> </dd></dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00070">nrs_policy_ctl_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="a19f8bfc734d211149596592a8381e336"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_fini" ref="a19f8bfc734d211149596592a8381e336" args=")(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a19f8bfc734d211149596592a8381e336">ptlrpc_nrs_pol_ops::op_policy_fini</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called during policy unregistration; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy being unregistered/finalized </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00061">nrs_policy_fini()</a>.</p>

</div>
</div>
<a class="anchor" id="a569dc08f6db72425acb3af23817016b5"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_init" ref="a569dc08f6db72425acb3af23817016b5" args=")(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a569dc08f6db72425acb3af23817016b5">ptlrpc_nrs_pol_ops::op_policy_init</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called during policy registration; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy being initialized </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00055">nrs_policy_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a04b4479f93de2fbd7380f10ffaf5f35c"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_start" ref="a04b4479f93de2fbd7380f10ffaf5f35c" args=")(struct ptlrpc_nrs_policy *policy, char *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a04b4479f93de2fbd7380f10ffaf5f35c">ptlrpc_nrs_pol_ops::op_policy_start</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, char *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when activating a policy via lprocfs; policies allocate and initialize their resources here; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy being started </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>A generic char buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#a4630e3b5b9e989a55f772264a9621b78" title="Transitions a policy across the ptlrpc_nrs_pol_state range of values, in response...">nrs_policy_start_locked()</a> </dd></dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00192">nrs_policy_start_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="a858a315f60b599de84db2cadfb9d6784"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_policy_stop" ref="a858a315f60b599de84db2cadfb9d6784" args=")(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a858a315f60b599de84db2cadfb9d6784">ptlrpc_nrs_pol_ops::op_policy_stop</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when deactivating a policy via lprocfs; policies deallocate their resources here; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy being stopped</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#ab0431763f8af37f9f10dac5d884bab3b">nrs_policy_stop0()</a> </dd></dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00087">nrs_policy_stop0()</a>.</p>

</div>
</div>
<a class="anchor" id="a1eb83c9a1da21c4090e85c6711dbf6d6"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_req_dequeue" ref="a1eb83c9a1da21c4090e85c6711dbf6d6" args=")(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_request *nrq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a1eb83c9a1da21c4090e85c6711dbf6d6">ptlrpc_nrs_pol_ops::op_req_dequeue</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a request from the policy's set of pending requests. </p>
<p>Normally called after a request has been polled successfully from the policy for handling; this operation is mandatory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy the request <em>nrq</em> belongs to </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>The request to dequeue</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#a7da7205147ceea7096dc6bdfe96a2d4c" title="Dequeues request req from the policy it has been enqueued on.">ptlrpc_nrs_req_del_nolock()</a> </dd></dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>, and <a class="el" href="nrs_8c_source.html#l01619">ptlrpc_nrs_req_del_nolock()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4c73dc673c0175574a7eee691f846a2"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_req_enqueue" ref="ae4c73dc673c0175574a7eee691f846a2" args=")(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_request *nrq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#ae4c73dc673c0175574a7eee691f846a2">ptlrpc_nrs_pol_ops::op_req_enqueue</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when attempting to add a request to a policy for later handling; this operation is mandatory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy on which to enqueue <em>nrq</em> </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>The request to enqueue</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>!=</em>&nbsp;</td><td>0 error</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#adaa29dac38998de2d61c893c40692886" title="Enqueue request req using one of the policies its resources are referring to.">ptlrpc_nrs_req_add_nolock()</a> </dd></dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>, and <a class="el" href="nrs_8c_source.html#l00583">nrs_request_enqueue()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7f082871c0f527c8d6b1c27c40a88e6"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_req_get" ref="ad7f082871c0f527c8d6b1c27c40a88e6" args=")(struct ptlrpc_nrs_policy *policy, bool peek, bool force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a>*(* <a class="el" href="structptlrpc__nrs__pol__ops.html#ad7f082871c0f527c8d6b1c27c40a88e6">ptlrpc_nrs_pol_ops::op_req_get</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, bool peek, bool force)<code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a request for handling from the policy, and optionally removes the request from the policy; this operation is mandatory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy to poll </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peek</em>&nbsp;</td><td>When set, signifies that we just want to examine the request, and not handle it, so the request is not removed from the policy. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>When set, it will force a policy to return a request if it has one queued.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>No request available for handling </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valid-pointer</em>&nbsp;</td><td>The request polled for handling</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ptlrpc__internal_8h.html#ad92335242ec3763ecf8874e00c41efee">ptlrpc_nrs_req_get_nolock()</a> </dd></dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>, and <a class="el" href="nrs_8c_source.html#l00559">nrs_request_get()</a>.</p>

</div>
</div>
<a class="anchor" id="afda655439032cd5103c48bfdafa6d98a"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_req_stop" ref="afda655439032cd5103c48bfdafa6d98a" args=")(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_request *nrq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#afda655439032cd5103c48bfdafa6d98a">ptlrpc_nrs_pol_ops::op_req_stop</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called after the request being carried out. </p>
<p>Could be used for job/resource control; this operation is optional.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy which is stopping to handle request <em>nrq</em> </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>The request</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>assert_spin_locked(&amp;svcpt-&gt;scp_req_lock)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#a41d6af6b26aebda69530fe3537266dfd">ptlrpc_nrs_req_stop_nolock()</a> </dd></dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00623">nrs_request_stop()</a>.</p>

</div>
</div>
<a class="anchor" id="affec8ac80f98364807dfe58e82fe4afe"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_res_get" ref="affec8ac80f98364807dfe58e82fe4afe" args=")(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_request *nrq, const struct ptlrpc_nrs_resource *parent, struct ptlrpc_nrs_resource **resp, bool moving_req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__nrs__pol__ops.html#affec8ac80f98364807dfe58e82fe4afe">ptlrpc_nrs_pol_ops::op_res_get</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq, const struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *parent, struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> **resp, bool moving_req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when obtaining references to the resources of the resource hierarchy for a request that has arrived for handling at the PTLRPC service. </p>
<p>Policies should return -ve for requests they do not wish to handle. This operation is mandatory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy we're getting resources for. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>The request we are getting resources for. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parent</em>&nbsp;</td><td>The parent resource of the resource being requested; set to NULL if none. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>resp</em>&nbsp;</td><td>The resource is to be returned here; the fallback policy in an NRS head should <em>always</em> return a non-NULL pointer value. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>moving_req</em>&nbsp;</td><td>When set, signifies that this is an attempt to obtain resources for a request being moved to the high-priority NRS head by ldlm_lock_reorder_req(). This implies two things: 1. We are under <a class="el" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">obd_export::exp_rpc_lock</a> and so should not sleep. 2. We should not perform non-idempotent or can skip performing idempotent operations that were carried out when resources were first taken for the request when it was initialized in <a class="el" href="nrs_8c.html#a040685413af9d845199d4866c37316b8" title="Obtains NRS head resources for request req.">ptlrpc_nrs_req_initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0,+ve</em>&nbsp;</td><td>The level of the returned resource in the resource hierarchy; currently only 0 (for a non-leaf resource) and 1 (for a leaf resource) are supported by the framework. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#a040685413af9d845199d4866c37316b8" title="Obtains NRS head resources for request req.">ptlrpc_nrs_req_initialize()</a> </dd>
<dd>
<a class="el" href="nrs_8c.html#a12a7e4c91309d6d9c9ebac14e75cfb96" title="Enqueue a request on the high priority NRS head.">ptlrpc_nrs_hpreq_add_nolock()</a> </dd>
<dd>
<a class="el" href="group__nrs.html#gae517dc74ee0bcadf3b53f6ed4c57e6de" title="Moves request req from the regular to the high-priority NRS head.">ptlrpc_nrs_req_hp_move()</a> </dd></dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>, and <a class="el" href="nrs_8c_source.html#l00406">nrs_resource_get()</a>.</p>

</div>
</div>
<a class="anchor" id="a1fc1f744ceed9307e93dc3ad6f9f882b"></a><!-- doxytag: member="ptlrpc_nrs_pol_ops::op_res_put" ref="a1fc1f744ceed9307e93dc3ad6f9f882b" args=")(struct ptlrpc_nrs_policy *policy, const struct ptlrpc_nrs_resource *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__nrs__pol__ops.html#a1fc1f744ceed9307e93dc3ad6f9f882b">ptlrpc_nrs_pol_ops::op_res_put</a>)(struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, const struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *res)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when releasing references taken for resources in the resource hierarchy for the request; this operation is optional. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>The policy the resource belongs to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>res</em>&nbsp;</td><td>The resource to be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#aa35053963b23dd9e0dc17f6b214da481" title="Releases resources for a request; is called after the request has been handled.">ptlrpc_nrs_req_finalize()</a> </dd>
<dd>
<a class="el" href="nrs_8c.html#a12a7e4c91309d6d9c9ebac14e75cfb96" title="Enqueue a request on the high priority NRS head.">ptlrpc_nrs_hpreq_add_nolock()</a> </dd>
<dd>
<a class="el" href="group__nrs.html#gae517dc74ee0bcadf3b53f6ed4c57e6de" title="Moves request req from the regular to the high-priority NRS head.">ptlrpc_nrs_req_hp_move()</a> </dd></dl>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00375">nrs_resource_put()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="lustre__nrs_8h_source.html">lustre_nrs.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:54 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
