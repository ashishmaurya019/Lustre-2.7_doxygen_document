<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ldlm/ldlm_request.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lustre/ldlm/ldlm_request.c File Reference</h1><code>#include &lt;<a class="el" href="lustre__dlm_8h_source.html">lustre_dlm.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="obd__class_8h_source.html">obd_class.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="obd_8h_source.html">obd.h</a>&gt;</code><br/>
<code>#include &quot;<a class="el" href="ldlm__internal_8h_source.html">ldlm_internal.h</a>&quot;</code><br/>

<p><a href="ldlm__request_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__wait__data.html">lock_wait_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__async__args.html">ldlm_async_args</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldlm__cli__cancel__arg.html">ldlm_cli_cancel_arg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiter__helper__data.html">iter_helper_data</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">DEBUG_SUBSYSTEM</a>&nbsp;&nbsp;&nbsp;S_LDLM</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file contains Asynchronous System Trap (AST) handlers and related LDLM request-processing routines.  <a href="#abda60744d497fcfe370cfd6b2d65c7ed"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a3e8af84d65fd36480c7f90978edea82e">module_param</a> (<a class="el" href="ldlm__request_8c.html#a203c443910cb010024d2111b0126d31d">ldlm_enqueue_min</a>, uint, 0644)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a17197d5cc3101fe7444894dbbda07150">MODULE_PARM_DESC</a> (<a class="el" href="ldlm__request_8c.html#a203c443910cb010024d2111b0126d31d">ldlm_enqueue_min</a>,&quot;lock enqueue <a class="el" href="o2iblnd__modparams_8c.html#a493b57f443cc38b3d3df9c1e584d9d82">timeout</a> minimum&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a32023fb3ef95c015df3c033731e9d476">interrupted_completion_wait</a> (void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#gadc8dcde45df7d4bea889736aca442600">ldlm_expired_completion_wait</a> (void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#ae602d8aebbc02dff32295d786827e998">ldlm_cp_timeout</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the Completion timeout (covering enqueue, BL AST, data flush, lock cancel, and their replies).  <a href="#ae602d8aebbc02dff32295d786827e998"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a93ba40aeedcb493bcb12c82f23710202">ldlm_completion_tail</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for <a class="el" href="group__ldlm__local__ast.html#gaae5738d417a8624f65b5418d57fef359" title="Generic LDLM &quot;completion&quot; AST.">ldlm_completion_ast()</a>, updating timings when lock is actually granted.  <a href="#a93ba40aeedcb493bcb12c82f23710202"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#ga44a28deab27f79e7a1ab7e77c7a59208">ldlm_completion_ast_async</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> flags, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of -&gt;l_completion_ast() for a client, that doesn't wait until lock is granted.  <a href="group__ldlm__local__ast.html#ga44a28deab27f79e7a1ab7e77c7a59208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#gaae5738d417a8624f65b5418d57fef359">ldlm_completion_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> flags, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic LDLM "completion" AST.  <a href="group__ldlm__local__ast.html#gaae5738d417a8624f65b5418d57fef359"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3">ldlm_blocking_ast_nocheck</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper to build a blocking AST function.  <a href="group__ldlm__local__ast.html#ga9962ac0cc2bd7e279cf0b977d822feb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb">ldlm_blocking_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, struct <a class="el" href="structldlm__lock__desc.html">ldlm_lock_desc</a> *desc, void *data, int flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Server blocking AST.  <a href="group__ldlm__local__ast.html#gacc93548bb07532aa1d816dee71bd2ecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__local__ast.html#ga158dc17797fe9252638377c70f5f9558">ldlm_glimpse_ast</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, void *reqp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements <a class="el" href="structldlm__lock.html#aaa0d1608f452158ab011eecc6f978058" title="Lock glimpse handler.">ldlm_lock::l_glimpse_ast</a> for extent locks acquired on the server.  <a href="group__ldlm__local__ast.html#ga158dc17797fe9252638377c70f5f9558"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga1fc673f7fb2c06baaa796f09afc33487">ldlm_cli_enqueue_local</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *res_id, enum <a class="el" href="group__lustreidl.html#ga5ced9a6707006817f5e2409b368f36b5">ldlm_type</a> type, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy, enum <a class="el" href="group__lustreidl.html#ga78e7c1d7ad283002413a597e75aa7441">ldlm_mode</a> <a class="el" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> *flags, <a class="el" href="group__LDLM.html#gac111233b56bdf7a4767dcd7a2f15b378">ldlm_blocking_callback</a> blocking, <a class="el" href="group__LDLM.html#gac03b996dc38f767ddd9b2f5ae779b257">ldlm_completion_callback</a> completion, <a class="el" href="group__LDLM.html#ga6e5c291246d5e6fb302d99a6111cb03d">ldlm_glimpse_callback</a> glimpse, void *data, __u32 lvb_len, enum <a class="el" href="group__LDLM.html#ga2e4dbf6d38ddcec566ec40c96391622b">lvb_type</a> <a class="el" href="group__LDLM.html#ga2e4dbf6d38ddcec566ec40c96391622b">lvb_type</a>, const <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> *client_cookie, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a local lock (typically on a server).  <a href="group__ldlm__cli__api.html#ga1fc673f7fb2c06baaa796f09afc33487"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a08befdf835b7aa52da01108e1c285fe5">failed_lock_cleanup</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int <a class="el" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#gac421005283912bb5186b035013aa58c0">ldlm_cli_enqueue_fini</a> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, enum <a class="el" href="group__lustreidl.html#ga5ced9a6707006817f5e2409b368f36b5">ldlm_type</a> type, __u8 with_policy, enum <a class="el" href="group__lustreidl.html#ga78e7c1d7ad283002413a597e75aa7441">ldlm_mode</a> <a class="el" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> *flags, void *lvb, __u32 lvb_len, const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, int rc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finishing portion of client lock enqueue code.  <a href="group__ldlm__cli__api.html#gac421005283912bb5186b035013aa58c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#acd777667e24902002df1ab9dad165a56">ldlm_req_handles_avail</a> (int req_size, int off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimate number of lock handles that would fit into request of given size.  <a href="#acd777667e24902002df1ab9dad165a56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a9b1ad8fe3c6271925ec8c456e994fb60">ldlm_capsule_handles_avail</a> (struct <a class="el" href="structreq__capsule.html">req_capsule</a> *pill, enum <a class="el" href="group__req__layout.html#ga0c07ccef9ef768eb7bf6cb2946c28261">req_location</a> loc, int off)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a6f09b221e87cad49483fe400273056f5">ldlm_format_handles_avail</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, const struct <a class="el" href="structreq__format.html">req_format</a> *fmt, enum <a class="el" href="group__req__layout.html#ga0c07ccef9ef768eb7bf6cb2946c28261">req_location</a> loc, int off)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f">ldlm_prep_elc_req</a> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int <a class="el" href="mount__lustre_8c.html#aad880fc4455c253781e8968f2239d56f">version</a>, int opc, int canceloff, struct <a class="el" href="structlist__head.html">list_head</a> *cancels, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel LRU locks and pack them into the enqueue request.  <a href="group__ldlm__cli__api.html#gabae59a7ebeed8c6fd60b22f03cf88e1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga9fe4c63a5cd0fe654e29fd11aea415cc">ldlm_prep_enqueue_req</a> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structlist__head.html">list_head</a> *cancels, int count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga4bde4e4e32bab2c971297a5f065dec66">ldlm_enqueue_pack</a> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp, int lvb_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07">ldlm_cli_enqueue</a> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> **reqp, struct <a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a> *einfo, const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *res_id, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> const *policy, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> *flags, void *lvb, __u32 lvb_len, enum <a class="el" href="group__LDLM.html#ga2e4dbf6d38ddcec566ec40c96391622b">lvb_type</a> <a class="el" href="group__LDLM.html#ga2e4dbf6d38ddcec566ec40c96391622b">lvb_type</a>, struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, int async)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Client-side lock enqueue.  <a href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a8b303cd355181ee1016e3792585cc4df">ldlm_cli_convert_local</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int new_mode, __u32 *flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga2a5622167fd1e1543cef0addb8634f09">ldlm_cli_convert</a> (const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, int new_mode, __u32 *flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a5d78b4862ed117a571a802c953ba4e89">ldlm_cli_cancel_local</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel locks locally.  <a href="#a5d78b4862ed117a571a802c953ba4e89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#acb25a5062b346f7d7a863144dfbfa338">ldlm_cancel_pack</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structlist__head.html">list_head</a> *<a class="el" href="writemany_8c.html#af39400667a953a7c5c34e3964aa1ce9f">head</a>, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack <em>count</em> locks in <em>head</em> into <a class="el" href="structldlm__request.html">ldlm_request</a> buffer of request <em>req</em>.  <a href="#acb25a5062b346f7d7a863144dfbfa338"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70">ldlm_cli_cancel_req</a> (struct <a class="el" href="structobd__export.html">obd_export</a> *exp, struct <a class="el" href="structlist__head.html">list_head</a> *cancels, int count, enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare and send a batched cancel RPC.  <a href="group__ldlm__cli__api.html#ga677e9f9ff5fbe2174b139fe8c2b77b70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structldlm__pool.html">ldlm_pool</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a1433e55655bdca45846692b2e5448e9d">ldlm_imp2pl</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga83cbdc7f471f1c21e1200fb94d5be170">ldlm_cli_update_pool</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update client's OBD pool related fields with new SLV and Limit from <em>req</em>.  <a href="group__ldlm__cli__api.html#ga83cbdc7f471f1c21e1200fb94d5be170"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9">ldlm_cli_cancel</a> (const struct <a class="el" href="structlustre__handle.html">lustre_handle</a> *lockh, enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> cancel_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Client side lock cancel.  <a href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149">ldlm_cli_cancel_list_local</a> (struct <a class="el" href="structlist__head.html">list_head</a> *cancels, int count, enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> cancel_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locally cancel up to <em>count</em> locks in list <em>cancels</em>.  <a href="group__ldlm__cli__api.html#gac7dcd18ff549bf7b777a067e1c374149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a9c4ba06316a0cc99bf5091fe2d2fdd2e">ldlm_cancel_no_wait_policy</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int unused, int added, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel as many locks as possible w/o sending any RPCs (e.g.  <a href="#a9c4ba06316a0cc99bf5091fe2d2fdd2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a66b9b11a480efcb6fe115eaf23d5cff4">ldlm_cancel_lrur_policy</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int unused, int added, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for LRU-resize policy.  <a href="#a66b9b11a480efcb6fe115eaf23d5cff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a19f6ab524b08cdc6f7f737e24dae7b55">ldlm_cancel_lrur_no_wait_policy</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int unused, int added, int count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#aac0c4178620577cf700bfd651799584c">ldlm_cancel_passed_policy</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int unused, int added, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for proc used policy.  <a href="#aac0c4178620577cf700bfd651799584c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a4f3fa6befc15b788b717132cf854860a">ldlm_cancel_aged_policy</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int unused, int added, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for aged policy.  <a href="#a4f3fa6befc15b788b717132cf854860a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a643bdbaed1728e1fa2bc8428b9897431">ldlm_cancel_default_policy</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int unused, int added, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for default policy.  <a href="#a643bdbaed1728e1fa2bc8428b9897431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ldlm__request_8c.html#a6cce6a0acada8138e2b47454551f40ca">ldlm_cancel_lru_policy_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#ad8deb1c0058bab0ec385c96f23c7e34e">ldlm_cancel_lru_policy</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, enum <a class="el" href="ldlm__internal_8h.html#aaccb9c1f7e83484036c499491c4ec0a0">ldlm_lru_flags</a> lru_flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#aef330e0f68719c540a012ea9dfd2b464">ldlm_prepare_lru_list</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structlist__head.html">list_head</a> *cancels, int count, int <a class="el" href="lnet_2utils_2debug_8c.html#ae1e1dde676c120fa6d10f3bb2c14059e">max</a>, enum <a class="el" href="ldlm__internal_8h.html#aaccb9c1f7e83484036c499491c4ec0a0">ldlm_lru_flags</a> lru_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><ul>
<li>Free space in LRU for <em>count</em> new locks, redundant unused locks are canceled locally;<ul>
<li>also cancel locally unused aged locks;</li>
<li>do not cancel more than <em>max</em> locks;</li>
<li>GET the found locks and add them into the <em>cancels</em> list. </li>
</ul>
</li>
</ul>
 <a href="#aef330e0f68719c540a012ea9dfd2b464"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a5046292791619070fb577426506dbb0f">ldlm_cancel_lru_local</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structlist__head.html">list_head</a> *cancels, int count, int <a class="el" href="lnet_2utils_2debug_8c.html#ae1e1dde676c120fa6d10f3bb2c14059e">max</a>, enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> cancel_flags, enum <a class="el" href="ldlm__internal_8h.html#aaccb9c1f7e83484036c499491c4ec0a0">ldlm_lru_flags</a> lru_flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a61e0c780c8b9ae81e64eb3f90f4f4b50">ldlm_cancel_lru</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, int nr, enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> cancel_flags, enum <a class="el" href="ldlm__internal_8h.html#aaccb9c1f7e83484036c499491c4ec0a0">ldlm_lru_flags</a> lru_flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel at least <em>nr</em> locks from given namespace LRU.  <a href="#a61e0c780c8b9ae81e64eb3f90f4f4b50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253">ldlm_cancel_resource_local</a> (struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *res, struct <a class="el" href="structlist__head.html">list_head</a> *cancels, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy, enum <a class="el" href="group__lustreidl.html#ga78e7c1d7ad283002413a597e75aa7441">ldlm_mode</a> <a class="el" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> lock_flags, enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> cancel_flags, void *opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find and cancel locally unused locks found on resource, matched to the given policy, mode.  <a href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872">ldlm_cli_cancel_list</a> (struct <a class="el" href="structlist__head.html">list_head</a> *cancels, int count, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel client-side locks from a list and send/prepare cancel RPCs to the server.  <a href="group__ldlm__cli__api.html#ga96adcececc3c547888075de942fa1872"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66">ldlm_cli_cancel_unused_resource</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *res_id, union <a class="el" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy, enum <a class="el" href="group__lustreidl.html#ga78e7c1d7ad283002413a597e75aa7441">ldlm_mode</a> <a class="el" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> flags, void *opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all locks on a resource that have 0 readers/writers.  <a href="group__ldlm__cli__api.html#ga56914f0205e9d377eeceb78f8db71f66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a2b80a40f999ca2a3a456ba7c1eba079b">ldlm_cli_hash_cancel_unused</a> (struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *hs, struct <a class="el" href="structcfs__hash__bd.html">cfs_hash_bd</a> *bd, struct <a class="el" href="structhlist__node.html">hlist_node</a> *hnode, void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a">ldlm_cli_cancel_unused</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *res_id, enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a> flags, void *opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all locks on a namespace (or a specific resource, if given) that have 0 readers/writers.  <a href="group__ldlm__cli__api.html#ga8067f82d5a14a84d1c103d2de469501a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__iterator.html#ga69027ce9d6df10f0f7616afe7f57e41b">ldlm_resource_foreach</a> (struct <a class="el" href="structldlm__resource.html">ldlm_resource</a> *res, <a class="el" href="group__LDLM.html#ga755fb40aeaf77f3a7d1591645ce49ce3">ldlm_iterator_t</a> iter, void *closure)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#ac94a78ce0358c4deb086e49ee76ca3b6">ldlm_iter_helper</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, void *closure)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#aa74dce326e4e433329d8d04caaefd0e3">ldlm_res_iter_helper</a> (struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *hs, struct <a class="el" href="structcfs__hash__bd.html">cfs_hash_bd</a> *bd, struct <a class="el" href="structhlist__node.html">hlist_node</a> *hnode, void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__iterator.html#ga4388dfb252bc19c385f53fac404c94d1">ldlm_namespace_foreach</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, <a class="el" href="group__LDLM.html#ga755fb40aeaf77f3a7d1591645ce49ce3">ldlm_iterator_t</a> iter, void *closure)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ldlm__iterator.html#ga5c86e4d6012bca73aa85350d7b74b130">ldlm_resource_iterate</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, const struct <a class="el" href="structldlm__res__id.html">ldlm_res_id</a> *res_id, <a class="el" href="group__LDLM.html#ga755fb40aeaf77f3a7d1591645ce49ce3">ldlm_iterator_t</a> iter, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a28e8710f649ab420bc9be527a01b11aa">ldlm_chain_lock_for_replay</a> (struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, void *closure)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a54be6501cb9ee04fbec2d2e4f065e58b">replay_lock_interpret</a> (const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structldlm__async__args.html">ldlm_async_args</a> *aa, int rc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a6ad8564a094e2aa5a713852b452afe28">replay_one_lock</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#ac4618a1cd3f7b3c17a2d418257ef10f7">ldlm_cancel_unused_locks_for_replay</a> (struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel as many unused locks as possible before replay.  <a href="#ac4618a1cd3f7b3c17a2d418257ef10f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LDLM.html#ga878ffb8d1a87e3787eb2bb6170fed457">ldlm_replay_locks</a> (struct <a class="el" href="structobd__import.html">obd_import</a> *imp)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a203c443910cb010024d2111b0126d31d">ldlm_enqueue_min</a> = OBD_TIMEOUT_DEFAULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a27b7071107b0390cd461fa9679d8d67a">ldlm_cancel_unused_locks_before_replay</a> = 1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ldlm__request_8c.html#a6cce6a0acada8138e2b47454551f40ca">ldlm_cancel_lru_policy_t</a> )(struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int unused, int added, int count)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="abda60744d497fcfe370cfd6b2d65c7ed"></a><!-- doxytag: member="ldlm_request.c::DEBUG_SUBSYSTEM" ref="abda60744d497fcfe370cfd6b2d65c7ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_SUBSYSTEM&nbsp;&nbsp;&nbsp;S_LDLM</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This file contains Asynchronous System Trap (AST) handlers and related LDLM request-processing routines. </p>
<p>An AST is a callback issued on a lock when its state is changed. There are several different types of ASTs (callbacks) registered for each lock:</p>
<ul>
<li>completion AST: when a lock is enqueued by some process, but cannot be granted immediately due to other conflicting locks on the same resource, the completion AST is sent to notify the caller when the lock is eventually granted</li>
</ul>
<ul>
<li>blocking AST: when a lock is granted to some process, if another process enqueues a conflicting (blocking) lock on a resource, a blocking AST is sent to notify the holder(s) of the lock(s) of the conflicting lock request. The lock holder(s) must release their lock(s) on that resource in a timely manner or be evicted by the server.</li>
</ul>
<ul>
<li>glimpse AST: this is used when a process wants information about a lock (i.e. the lock value block (LVB)) but does not necessarily require holding the lock. If the resource is locked, the lock holder(s) are sent glimpse ASTs and the LVB is returned to the caller, and lock holder(s) may CANCEL their lock(s) if they are idle. If the resource is not locked, the server may grant the lock. </li>
</ul>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00062">62</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a08befdf835b7aa52da01108e1c285fe5"></a><!-- doxytag: member="ldlm_request.c::failed_lock_cleanup" ref="a08befdf835b7aa52da01108e1c285fe5" args="(struct ldlm_namespace *ns, struct ldlm_lock *lock, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void failed_lock_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00491">491</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00778">ldlm_lock::l_flags</a>, <a class="el" href="lustre__dlm_8h_source.html#l00728">ldlm_lock::l_granted_mode</a>, <a class="el" href="lustre__dlm_8h_source.html#l00724">ldlm_lock::l_req_mode</a>, <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>, <a class="el" href="lustre__dlm_8h_source.html#l01168">LDLM_DEBUG</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00258">LDLM_FL_ATOMIC_CB</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00173">LDLM_FL_CBPENDING</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00197">LDLM_FL_FAILED</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00191">LDLM_FL_LOCAL_ONLY</a>, <a class="el" href="packet-lustre_8c_source.html#l00300">LDLM_FLOCK</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00310">ldlm_is_destroyed</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00198">ldlm_is_failed</a>, <a class="el" href="ldlm__lock_8c_source.html#l00827">ldlm_lock_decref_internal()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00800">ldlm_lock_decref_internal_nolock()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00422">ldlm_lock_destroy_nolock()</a>, <a class="el" href="ldlm__resource_8c_source.html#l01366">ldlm_resource_unlink_lock()</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00970">ldlm_resource::lr_type</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00869">ldlm_cli_enqueue()</a>, and <a class="el" href="ldlm__request_8c_source.html#l00541">ldlm_cli_enqueue_fini()</a>.</p>

</div>
</div>
<a class="anchor" id="a32023fb3ef95c015df3c033731e9d476"></a><!-- doxytag: member="ldlm_request.c::interrupted_completion_wait" ref="a32023fb3ef95c015df3c033731e9d476" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void interrupted_completion_wait </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00077">77</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00230">ldlm_completion_ast()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3fa6befc15b788b717132cf854860a"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_aged_policy" ref="a4f3fa6befc15b788b717132cf854860a" args="(struct ldlm_namespace *ns, struct ldlm_lock *lock, int unused, int added, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a> ldlm_cancel_aged_policy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for aged policy. </p>
<p>Makes decision whether to keep <em>lock</em> in LRU for current LRU size <em>unused</em>, added in current scan <em>added</em> and number of locks to be preferably canceled <em>count</em>.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>LDLM_POLICY_KEEP_LOCK</em>&nbsp;</td><td>keep lock in LRU in stop scanning</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LDLM_POLICY_CANCEL_LOCK</em>&nbsp;</td><td>cancel lock from LRU </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01574">1574</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="libcfs__time_8h_source.html#l00046">cfs_time_add()</a>, <a class="el" href="linux-time_8h_source.html#l00142">cfs_time_before()</a>, <a class="el" href="linux-time_8h_source.html#l00152">cfs_time_current()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00803">ldlm_lock::l_last_used</a>, <a class="el" href="ldlm__internal_8h_source.html#l00257">LDLM_POLICY_CANCEL_LOCK</a>, <a class="el" href="ldlm__internal_8h_source.html#l00258">LDLM_POLICY_KEEP_LOCK</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00424">ldlm_namespace::ns_max_age</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01613">ldlm_cancel_lru_policy()</a>.</p>

</div>
</div>
<a class="anchor" id="a643bdbaed1728e1fa2bc8428b9897431"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_default_policy" ref="a643bdbaed1728e1fa2bc8428b9897431" args="(struct ldlm_namespace *ns, struct ldlm_lock *lock, int unused, int added, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a> ldlm_cancel_default_policy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for default policy. </p>
<p>Makes decision whether to keep <em>lock</em> in LRU for current LRU size <em>unused</em>, added in current scan <em>added</em> and number of locks to be preferably canceled <em>count</em>.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>LDLM_POLICY_KEEP_LOCK</em>&nbsp;</td><td>keep lock in LRU in stop scanning</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LDLM_POLICY_CANCEL_LOCK</em>&nbsp;</td><td>cancel lock from LRU </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01597">1597</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="ldlm__internal_8h_source.html#l00257">LDLM_POLICY_CANCEL_LOCK</a>, and <a class="el" href="ldlm__internal_8h_source.html#l00258">LDLM_POLICY_KEEP_LOCK</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01613">ldlm_cancel_lru_policy()</a>.</p>

</div>
</div>
<a class="anchor" id="a61e0c780c8b9ae81e64eb3f90f4f4b50"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_lru" ref="a61e0c780c8b9ae81e64eb3f90f4f4b50" args="(struct ldlm_namespace *ns, int nr, enum ldlm_cancel_flags cancel_flags, enum ldlm_lru_flags lru_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_cancel_lru </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a>&nbsp;</td>
          <td class="paramname"> <em>cancel_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ldlm__internal_8h.html#aaccb9c1f7e83484036c499491c4ec0a0">ldlm_lru_flags</a>&nbsp;</td>
          <td class="paramname"> <em>lru_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel at least <em>nr</em> locks from given namespace LRU. </p>
<p>When called with LCF_ASYNC the blocking callback will be handled in a thread and this function will return after the thread has been asked to call the callback. When called with LCF_ASYNC the blocking callback will be performed in this function. </p>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01831">1831</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="ldlm__lockd_8c_source.html#l02081">ldlm_bl_to_thread_list()</a>, <a class="el" href="ldlm__request_8c_source.html#l01669">ldlm_prepare_lru_list()</a>, <a class="el" href="list_8h_source.html#l00046">LIST_HEAD_INIT</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="ldlm__lock_8c_source.html#l00827">ldlm_lock_decref_internal()</a>.</p>

</div>
</div>
<a class="anchor" id="a5046292791619070fb577426506dbb0f"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_lru_local" ref="a5046292791619070fb577426506dbb0f" args="(struct ldlm_namespace *ns, struct list_head *cancels, int count, int max, enum ldlm_cancel_flags cancel_flags, enum ldlm_lru_flags lru_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ldlm_cancel_lru_local </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>cancels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__LDLM.html#ga0b718c2d27bc15f43205e50e4da16ec9">ldlm_cancel_flags</a>&nbsp;</td>
          <td class="paramname"> <em>cancel_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ldlm__internal_8h.html#aaccb9c1f7e83484036c499491c4ec0a0">ldlm_lru_flags</a>&nbsp;</td>
          <td class="paramname"> <em>lru_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01809">1809</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="ldlm__request_8c_source.html#l01407">ldlm_cli_cancel_list_local()</a>, and <a class="el" href="ldlm__request_8c_source.html#l01669">ldlm_prepare_lru_list()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l02319">ldlm_cancel_unused_locks_for_replay()</a>, <a class="el" href="ldlm__request_8c_source.html#l01345">ldlm_cli_cancel()</a>, and <a class="el" href="ldlm__request_8c_source.html#l00762">ldlm_prep_elc_req()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8deb1c0058bab0ec385c96f23c7e34e"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_lru_policy" ref="ad8deb1c0058bab0ec385c96f23c7e34e" args="(struct ldlm_namespace *ns, enum ldlm_lru_flags lru_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ldlm__request_8c.html#a6cce6a0acada8138e2b47454551f40ca">ldlm_cancel_lru_policy_t</a> ldlm_cancel_lru_policy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ldlm__internal_8h.html#aaccb9c1f7e83484036c499491c4ec0a0">ldlm_lru_flags</a>&nbsp;</td>
          <td class="paramname"> <em>lru_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01613">1613</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="ldlm__request_8c_source.html#l01574">ldlm_cancel_aged_policy()</a>, <a class="el" href="ldlm__request_8c_source.html#l01597">ldlm_cancel_default_policy()</a>, <a class="el" href="ldlm__request_8c_source.html#l01531">ldlm_cancel_lrur_no_wait_policy()</a>, <a class="el" href="ldlm__request_8c_source.html#l01492">ldlm_cancel_lrur_policy()</a>, <a class="el" href="ldlm__request_8c_source.html#l01458">ldlm_cancel_no_wait_policy()</a>, <a class="el" href="ldlm__request_8c_source.html#l01554">ldlm_cancel_passed_policy()</a>, <a class="el" href="ldlm__internal_8h_source.html#l00104">LDLM_LRU_FLAG_AGED</a>, <a class="el" href="ldlm__internal_8h_source.html#l00107">LDLM_LRU_FLAG_LRUR</a>, <a class="el" href="ldlm__internal_8h_source.html#l00110">LDLM_LRU_FLAG_LRUR_NO_WAIT</a>, <a class="el" href="ldlm__internal_8h_source.html#l00108">LDLM_LRU_FLAG_NO_WAIT</a>, <a class="el" href="ldlm__internal_8h_source.html#l00105">LDLM_LRU_FLAG_PASSED</a>, <a class="el" href="ldlm__internal_8h_source.html#l00106">LDLM_LRU_FLAG_SHRINK</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00553">ns_connect_lru_resize()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01669">ldlm_prepare_lru_list()</a>.</p>

</div>
</div>
<a class="anchor" id="a19f6ab524b08cdc6f7f737e24dae7b55"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_lrur_no_wait_policy" ref="a19f6ab524b08cdc6f7f737e24dae7b55" args="(struct ldlm_namespace *ns, struct ldlm_lock *lock, int unused, int added, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a> ldlm_cancel_lrur_no_wait_policy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01531">1531</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="ldlm__request_8c_source.html#l01492">ldlm_cancel_lrur_policy()</a>, <a class="el" href="ldlm__request_8c_source.html#l01458">ldlm_cancel_no_wait_policy()</a>, and <a class="el" href="ldlm__internal_8h_source.html#l00258">LDLM_POLICY_KEEP_LOCK</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01613">ldlm_cancel_lru_policy()</a>.</p>

</div>
</div>
<a class="anchor" id="a66b9b11a480efcb6fe115eaf23d5cff4"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_lrur_policy" ref="a66b9b11a480efcb6fe115eaf23d5cff4" args="(struct ldlm_namespace *ns, struct ldlm_lock *lock, int unused, int added, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a> ldlm_cancel_lrur_policy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for LRU-resize policy. </p>
<p>Decides whether to keep <em>lock</em> in LRU for current <em>LRU</em> size <em>unused</em>, added in current scan <em>added</em> and number of locks to be preferably canceled <em>count</em>.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>LDLM_POLICY_KEEP_LOCK</em>&nbsp;</td><td>keep lock in LRU in stop scanning</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LDLM_POLICY_CANCEL_LOCK</em>&nbsp;</td><td>cancel lock from LRU </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01492">1492</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>, <a class="el" href="linux-time_8h_source.html#l00188">cfs_duration_sec()</a>, <a class="el" href="libcfs__time_8h_source.html#l00046">cfs_time_add()</a>, <a class="el" href="libcfs__time_8h_source.html#l00056">cfs_time_after()</a>, <a class="el" href="linux-time_8h_source.html#l00152">cfs_time_current()</a>, <a class="el" href="libcfs__time_8h_source.html#l00051">cfs_time_sub()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00803">ldlm_lock::l_last_used</a>, <a class="el" href="ldlm__internal_8h_source.html#l00257">LDLM_POLICY_CANCEL_LOCK</a>, <a class="el" href="ldlm__internal_8h_source.html#l00258">LDLM_POLICY_KEEP_LOCK</a>, <a class="el" href="ldlm__pool_8c_source.html#l01576">ldlm_pool_get_lvf()</a>, <a class="el" href="ldlm__pool_8c_source.html#l01546">ldlm_pool_get_slv()</a>, <a class="el" href="ldlm__pool_8c_source.html#l01561">ldlm_pool_set_clv()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00424">ldlm_namespace::ns_max_age</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00466">ldlm_namespace::ns_pool</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01613">ldlm_cancel_lru_policy()</a>, and <a class="el" href="ldlm__request_8c_source.html#l01531">ldlm_cancel_lrur_no_wait_policy()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c4ba06316a0cc99bf5091fe2d2fdd2e"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_no_wait_policy" ref="a9c4ba06316a0cc99bf5091fe2d2fdd2e" args="(struct ldlm_namespace *ns, struct ldlm_lock *lock, int unused, int added, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a> ldlm_cancel_no_wait_policy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel as many locks as possible w/o sending any RPCs (e.g. </p>
<p>to write back dirty data, to close a file, ...) or waiting for any RPCs in-flight (e.g. readahead requests, ...) </p>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01458">1458</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>, <a class="el" href="packet-lustre_8c_source.html#l00299">LDLM_EXTENT</a>, <a class="el" href="packet-lustre_8c_source.html#l00301">LDLM_IBITS</a>, <a class="el" href="ldlm__internal_8h_source.html#l00257">LDLM_POLICY_CANCEL_LOCK</a>, <a class="el" href="ldlm__internal_8h_source.html#l00259">LDLM_POLICY_SKIP_LOCK</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00169">ldlm_set_skipped</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00970">ldlm_resource::lr_type</a>, <a class="el" href="lustre__dlm_8h_source.html#l00498">ldlm_namespace::ns_cancel</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01613">ldlm_cancel_lru_policy()</a>, and <a class="el" href="ldlm__request_8c_source.html#l01531">ldlm_cancel_lrur_no_wait_policy()</a>.</p>

</div>
</div>
<a class="anchor" id="acb25a5062b346f7d7a863144dfbfa338"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_pack" ref="acb25a5062b346f7d7a863144dfbfa338" args="(struct ptlrpc_request *req, struct list_head *head, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ldlm_cancel_pack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack <em>count</em> locks in <em>head</em> into <a class="el" href="structldlm__request.html">ldlm_request</a> buffer of request <em>req</em>. </p>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01148">1148</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00145">D_DLMTRACE</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="lustre__dlm_8h_source.html#l00759">ldlm_lock::l_conn_export</a>, <a class="el" href="lustre__dlm_8h_source.html#l00766">ldlm_lock::l_remote_handle</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__dlm_8h_source.html#l01168">LDLM_DEBUG</a>, <a class="el" href="lustre__idl_8h_source.html#l02903">LDLM_LOCKREQ_HANDLES</a>, <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, <a class="el" href="lustre__idl_8h_source.html#l02908">ldlm_request::lock_count</a>, <a class="el" href="lustre__idl_8h_source.html#l02910">ldlm_request::lock_handle</a>, <a class="el" href="lnet_2utils_2debug_8c_source.html#l00068">max</a>, <a class="el" href="group__lustreidl.html#ga30372a269f5fc08f064b7e94437589bb">packed</a>, <a class="el" href="lustre__req__layout_8h_source.html#l00058">RCL_CLIENT</a>, <a class="el" href="layout_8c_source.html#l02117">req_capsule_client_get()</a>, <a class="el" href="layout_8c_source.html#l02263">req_capsule_get_size()</a>, <a class="el" href="layout_8c_source.html#l01033">RMF_DLM_REQ</a>, and <a class="el" href="lustre__net_8h_source.html#l01121">ptlrpc_request::rq_pill</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01917">ldlm_cli_cancel_list()</a>, and <a class="el" href="ldlm__request_8c_source.html#l01185">ldlm_cli_cancel_req()</a>.</p>

</div>
</div>
<a class="anchor" id="aac0c4178620577cf700bfd651799584c"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_passed_policy" ref="aac0c4178620577cf700bfd651799584c" args="(struct ldlm_namespace *ns, struct ldlm_lock *lock, int unused, int added, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a> ldlm_cancel_passed_policy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for proc used policy. </p>
<p>Makes decision whether to keep <em>lock</em> in LRU for current <em>LRU</em> size <em>unused</em>, added in current scan <em>added</em> and number of locks to be preferably canceled <em>count</em>.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>LDLM_POLICY_KEEP_LOCK</em>&nbsp;</td><td>keep lock in LRU in stop scanning</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LDLM_POLICY_CANCEL_LOCK</em>&nbsp;</td><td>cancel lock from LRU </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01554">1554</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="ldlm__internal_8h_source.html#l00257">LDLM_POLICY_CANCEL_LOCK</a>, and <a class="el" href="ldlm__internal_8h_source.html#l00258">LDLM_POLICY_KEEP_LOCK</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01613">ldlm_cancel_lru_policy()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4618a1cd3f7b3c17a2d418257ef10f7"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_unused_locks_for_replay" ref="ac4618a1cd3f7b3c17a2d418257ef10f7" args="(struct ldlm_namespace *ns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ldlm_cancel_unused_locks_for_replay </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel as many unused locks as possible before replay. </p>
<p>since we are in recovery, we can't wait for any outstanding RPCs to send any RPC to the server.</p>
<p>Called only in recovery before replaying locks. there is no need to replay locks that are unused. since the clients may hold thousands of cached unused locks, dropping the unused locks can greatly reduce the load on the servers at recovery time. </p>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l02319">2319</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00145">D_DLMTRACE</a>, <a class="el" href="lustre__dlm_8h_source.html#l00617">LCF_LOCAL</a>, <a class="el" href="ldlm__request_8c_source.html#l01809">ldlm_cancel_lru_local()</a>, <a class="el" href="ldlm__internal_8h_source.html#l00108">LDLM_LRU_FLAG_NO_WAIT</a>, <a class="el" href="lustre__dlm_8h_source.html#l00994">ldlm_ns_name()</a>, <a class="el" href="list_8h_source.html#l00046">LIST_HEAD_INIT</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00415">ldlm_namespace::ns_nr_unused</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l02338">ldlm_replay_locks()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b1ad8fe3c6271925ec8c456e994fb60"></a><!-- doxytag: member="ldlm_request.c::ldlm_capsule_handles_avail" ref="a9b1ad8fe3c6271925ec8c456e994fb60" args="(struct req_capsule *pill, enum req_location loc, int off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_capsule_handles_avail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreq__capsule.html">req_capsule</a> *&nbsp;</td>
          <td class="paramname"> <em>pill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__req__layout.html#ga0c07ccef9ef768eb7bf6cb2946c28261">req_location</a>&nbsp;</td>
          <td class="paramname"> <em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00738">738</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="ldlm__request_8c_source.html#l00724">ldlm_req_handles_avail()</a>, <a class="el" href="layout_8c_source.html#l02281">req_capsule_msg_size()</a>, and <a class="el" href="cascading__rw_8c_source.html#l00061">size</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00762">ldlm_prep_elc_req()</a>.</p>

</div>
</div>
<a class="anchor" id="a28e8710f649ab420bc9be527a01b11aa"></a><!-- doxytag: member="ldlm_request.c::ldlm_chain_lock_for_replay" ref="a28e8710f649ab420bc9be527a01b11aa" args="(struct ldlm_lock *lock, void *closure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_chain_lock_for_replay </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>closure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l02155">2155</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__dlm_8h_source.html#l00778">ldlm_lock::l_flags</a>, <a class="el" href="lustre__dlm_8h_source.html#l00843">ldlm_lock::l_pending_chain</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00045">LASSERTF</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00203">LDLM_FL_CANCELING</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00197">LDLM_FL_FAILED</a>, <a class="el" href="lustre__dlm_8h_source.html#l01180">LDLM_ITER_CONTINUE</a>, <a class="el" href="lustre__dlm_8h_source.html#l01344">LDLM_LOCK_GET</a>, <a class="el" href="lnetctl_8c_source.html#l00969">list</a>, <a class="el" href="list_8h_source.html#l00076">list_add()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="list_8h_source.html#l00043">list_head::next</a>, and <a class="el" href="list_8h_source.html#l00043">list_head::prev</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l02338">ldlm_replay_locks()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d78b4862ed117a571a802c953ba4e89"></a><!-- doxytag: member="ldlm_request.c::ldlm_cli_cancel_local" ref="a5d78b4862ed117a571a802c953ba4e89" args="(struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> ldlm_cli_cancel_local </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel locks locally. </p>
<p>Returns: </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>LDLM_FL_LOCAL_ONLY</em>&nbsp;</td><td>if there is no need for a CANCEL RPC to the server </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LDLM_FL_CANCELING</em>&nbsp;</td><td>otherwise; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LDLM_FL_BL_AST</em>&nbsp;</td><td>if there is a need for a separate CANCEL RPC. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01107">1107</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>, <a class="el" href="libcfs__debug_8h_source.html#l00259">CDEBUG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00145">D_DLMTRACE</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="lustre__dlm_8h_source.html#l00759">ldlm_lock::l_conn_export</a>, <a class="el" href="lustre__dlm_8h_source.html#l00778">ldlm_lock::l_flags</a>, <a class="el" href="lustre__dlm_8h_source.html#l00694">ldlm_lock::l_resource</a>, <a class="el" href="libcfs__private_8h_source.html#l00281">LBUG</a>, <a class="el" href="ldlm__lock_8c_source.html#l02205">ldlm_cancel_callback()</a>, <a class="el" href="lustre__dlm_8h_source.html#l01168">LDLM_DEBUG</a>, <a class="el" href="lustre__dlm_8h_source.html#l01169">LDLM_ERROR</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00270">LDLM_FL_BL_AST</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00127">LDLM_FL_CANCEL_ON_BLOCK</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00203">LDLM_FL_CANCELING</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00191">LDLM_FL_LOCAL_ONLY</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00271">ldlm_is_bl_ast</a>, <a class="el" href="ldlm__lock_8c_source.html#l02249">ldlm_lock_cancel()</a>, <a class="el" href="lustre__dlm_8h_source.html#l01006">ldlm_lock_to_ns()</a>, <a class="el" href="ldlm__lock_8c_source.html#l02147">ldlm_reprocess_all()</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00175">ldlm_set_cbpending</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00518">ns_is_client()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01345">ldlm_cli_cancel()</a>, and <a class="el" href="ldlm__request_8c_source.html#l01407">ldlm_cli_cancel_list_local()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b303cd355181ee1016e3792585cc4df"></a><!-- doxytag: member="ldlm_request.c::ldlm_cli_convert_local" ref="a8b303cd355181ee1016e3792585cc4df" args="(struct ldlm_lock *lock, int new_mode, __u32 *flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_cli_convert_local </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>new_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__u32 *&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01001">1001</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="libcfs__private_8h_source.html#l00281">LBUG</a>, <a class="el" href="lustre__dlm_8h_source.html#l01168">LDLM_DEBUG</a>, <a class="el" href="ldlm__lock_8c_source.html#l02459">ldlm_lock_convert()</a>, <a class="el" href="lustre__dlm_8h_source.html#l01327">LDLM_LOCK_PUT</a>, <a class="el" href="lustre__dlm_8h_source.html#l01006">ldlm_lock_to_ns()</a>, <a class="el" href="ldlm__lock_8c_source.html#l02147">ldlm_reprocess_all()</a>, <a class="el" href="lustre__errno_8h_source.html#l00076">LUSTRE_EDEADLK</a>, <a class="el" href="lustre__dlm_8h_source.html#l00518">ns_is_client()</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01029">ldlm_cli_convert()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b80a40f999ca2a3a456ba7c1eba079b"></a><!-- doxytag: member="ldlm_request.c::ldlm_cli_hash_cancel_unused" ref="a2b80a40f999ca2a3a456ba7c1eba079b" args="(struct cfs_hash *hs, struct cfs_hash_bd *bd, struct hlist_node *hnode, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_cli_hash_cancel_unused </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *&nbsp;</td>
          <td class="paramname"> <em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcfs__hash__bd.html">cfs_hash_bd</a> *&nbsp;</td>
          <td class="paramname"> <em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhlist__node.html">hlist_node</a> *&nbsp;</td>
          <td class="paramname"> <em>hnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l02010">2010</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="libcfs__hash_8h_source.html#l00482">cfs_hash_object()</a>, <a class="el" href="ldlm__request_8c_source.html#l02005">ldlm_cli_cancel_arg::lc_flags</a>, <a class="el" href="ldlm__request_8c_source.html#l02006">ldlm_cli_cancel_arg::lc_opaque</a>, <a class="el" href="packet-lustre_8c_source.html#l00290">LCK_MINMODE</a>, <a class="el" href="ldlm__request_8c_source.html#l01971">ldlm_cli_cancel_unused_resource()</a>, <a class="el" href="lustre__dlm_8h_source.html#l01000">ldlm_res_to_ns()</a>, and <a class="el" href="lustre__dlm_8h_source.html#l00951">ldlm_resource::lr_name</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l02029">ldlm_cli_cancel_unused()</a>.</p>

</div>
</div>
<a class="anchor" id="a93ba40aeedcb493bcb12c82f23710202"></a><!-- doxytag: member="ldlm_request.c::ldlm_completion_tail" ref="a93ba40aeedcb493bcb12c82f23710202" args="(struct ldlm_lock *lock, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_completion_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for <a class="el" href="group__ldlm__local__ast.html#gaae5738d417a8624f65b5418d57fef359" title="Generic LDLM &quot;completion&quot; AST.">ldlm_completion_ast()</a>, updating timings when lock is actually granted. </p>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00160">160</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="import_8c_source.html#l01665">at_measured()</a>, <a class="el" href="linux-time_8h_source.html#l00263">CFS_DURATION_T</a>, <a class="el" href="linux-time_8h_source.html#l00157">cfs_time_current_sec()</a>, <a class="el" href="libcfs__time_8h_source.html#l00051">cfs_time_sub()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00797">ldlm_lock::l_last_activity</a>, <a class="el" href="lustre__dlm_8h_source.html#l01168">LDLM_DEBUG</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00310">ldlm_is_destroyed</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00198">ldlm_is_failed</a>, and <a class="el" href="lustre__dlm_8h_source.html#l01018">ldlm_lock_to_ns_at()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00230">ldlm_completion_ast()</a>, and <a class="el" href="ldlm__request_8c_source.html#l00188">ldlm_completion_ast_async()</a>.</p>

</div>
</div>
<a class="anchor" id="ae602d8aebbc02dff32295d786827e998"></a><!-- doxytag: member="ldlm_request.c::ldlm_cp_timeout" ref="ae602d8aebbc02dff32295d786827e998" args="(struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ldlm_cp_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Completion timeout (covering enqueue, BL AST, data flush, lock cancel, and their replies). </p>
<p>Used for lock completion timeout on the client side.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>lock which is waiting the completion callback</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>in seconds to wait for the server reply </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00142">142</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00373">at_get()</a>, <a class="el" href="lustre__import_8h_source.html#l00379">AT_OFF</a>, <a class="el" href="ldlm__request_8c_source.html#l00070">ldlm_enqueue_min</a>, <a class="el" href="lustre__dlm_8h_source.html#l01018">ldlm_lock_to_ns_at()</a>, <a class="el" href="lnet_2utils_2debug_8c_source.html#l00068">max</a>, <a class="el" href="class__obd_8c_source.html#l00083">obd_timeout</a>, and <a class="el" href="gnilnd__modparams_8c_source.html#l00052">timeout</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00230">ldlm_completion_ast()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f09b221e87cad49483fe400273056f5"></a><!-- doxytag: member="ldlm_request.c::ldlm_format_handles_avail" ref="a6f09b221e87cad49483fe400273056f5" args="(struct obd_import *imp, const struct req_format *fmt, enum req_location loc, int off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_format_handles_avail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structreq__format.html">req_format</a> *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__req__layout.html#ga0c07ccef9ef768eb7bf6cb2946c28261">req_location</a>&nbsp;</td>
          <td class="paramname"> <em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00746">746</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00320">obd_import::imp_msg_magic</a>, <a class="el" href="ldlm__request_8c_source.html#l00724">ldlm_req_handles_avail()</a>, <a class="el" href="layout_8c_source.html#l02296">req_capsule_fmt_size()</a>, and <a class="el" href="cascading__rw_8c_source.html#l00061">size</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01345">ldlm_cli_cancel()</a>, and <a class="el" href="ldlm__request_8c_source.html#l01185">ldlm_cli_cancel_req()</a>.</p>

</div>
</div>
<a class="anchor" id="a1433e55655bdca45846692b2e5448e9d"></a><!-- doxytag: member="ldlm_request.c::ldlm_imp2pl" ref="a1433e55655bdca45846692b2e5448e9d" args="(struct obd_import *imp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structldlm__pool.html">ldlm_pool</a>* ldlm_imp2pl </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01285">1285</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__import_8h_source.html#l00205">obd_import::imp_obd</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__dlm_8h_source.html#l00466">ldlm_namespace::ns_pool</a>, and <a class="el" href="obd_8h_source.html#l00641">obd_device::obd_namespace</a>.</p>

</div>
</div>
<a class="anchor" id="ac94a78ce0358c4deb086e49ee76ca3b6"></a><!-- doxytag: member="ldlm_request.c::ldlm_iter_helper" ref="ac94a78ce0358c4deb086e49ee76ca3b6" args="(struct ldlm_lock *lock, void *closure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_iter_helper </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>closure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l02099">2099</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="ldlm__request_8c_source.html#l02096">iter_helper_data::closure</a>, and <a class="el" href="ldlm__request_8c_source.html#l02095">iter_helper_data::iter</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l02105">ldlm_res_iter_helper()</a>.</p>

</div>
</div>
<a class="anchor" id="aef330e0f68719c540a012ea9dfd2b464"></a><!-- doxytag: member="ldlm_request.c::ldlm_prepare_lru_list" ref="aef330e0f68719c540a012ea9dfd2b464" args="(struct ldlm_namespace *ns, struct list_head *cancels, int count, int max, enum ldlm_lru_flags lru_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_prepare_lru_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>cancels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="ldlm__internal_8h.html#aaccb9c1f7e83484036c499491c4ec0a0">ldlm_lru_flags</a>&nbsp;</td>
          <td class="paramname"> <em>lru_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><ul>
<li>Free space in LRU for <em>count</em> new locks, redundant unused locks are canceled locally;<ul>
<li>also cancel locally unused aged locks;</li>
<li>do not cancel more than <em>max</em> locks;</li>
<li>GET the found locks and add them into the <em>cancels</em> list. </li>
</ul>
</li>
</ul>
</p>
<p>A client lock can be added to the l_bl_ast list only when it is marked LDLM_FL_CANCELING. Otherwise, somebody is already doing CANCEL. There are the following use cases: <a class="el" href="group__ldlm__cli__api.html#ga2fab73fddf169b2202e11527226f7253" title="Find and cancel locally unused locks found on resource, matched to the given policy...">ldlm_cancel_resource_local()</a>, <a class="el" href="ldlm__internal_8h.html#a5046292791619070fb577426506dbb0f">ldlm_cancel_lru_local()</a> and <a class="el" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel.">ldlm_cli_cancel()</a>, which check and set this flag properly. As any attempt to cancel a lock rely on this flag, l_bl_ast list is accessed later without any special locking.</p>
<p>Calling policies for enabled LRU resize: ---------------------------------------- flags &amp; LDLM_LRU_FLAG_LRUR - use LRU resize policy (SLV from server) to cancel not more than <em>count</em> locks;</p>
<p>flags &amp; LDLM_LRU_FLAG_PASSED - cancel <em>count</em> number of old locks (located at the beginning of LRU list);</p>
<p>flags &amp; LDLM_LRU_FLAG_SHRINK - cancel not more than <em>count</em> locks according to memory pressre policy function;</p>
<p>flags &amp; LDLM_LRU_FLAG_AGED - cancel <em>count</em> locks according to "aged policy"</p>
<p>flags &amp; LDLM_LRU_FLAG_NO_WAIT - cancel as many unused locks as possible (typically before replaying locks) w/o sending any RPCs or waiting for any outstanding RPC to complete. </p>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l01669">1669</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="linux-time_8h_source.html#l00152">cfs_time_current()</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="lustre__dlm_8h_source.html#l00865">ldlm_lock::l_bl_ast</a>, <a class="el" href="lustre__dlm_8h_source.html#l00778">ldlm_lock::l_flags</a>, <a class="el" href="lustre__dlm_8h_source.html#l00803">ldlm_lock::l_last_used</a>, <a class="el" href="lustre__dlm_8h_source.html#l00699">ldlm_lock::l_lru</a>, <a class="el" href="lustre__dlm_8h_source.html#l00784">ldlm_lock::l_readers</a>, <a class="el" href="lustre__dlm_8h_source.html#l00885">ldlm_lock::l_reference</a>, <a class="el" href="lustre__dlm_8h_source.html#l00785">ldlm_lock::l_writers</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="ldlm__request_8c_source.html#l01613">ldlm_cancel_lru_policy()</a>, <a class="el" href="ldlm__request_8c.html#a6cce6a0acada8138e2b47454551f40ca">ldlm_cancel_lru_policy_t</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00130">ldlm_clear_cancel_on_block</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00203">LDLM_FL_CANCELING</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00173">LDLM_FL_CBPENDING</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00271">ldlm_is_bl_ast</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00204">ldlm_is_canceling</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00168">ldlm_is_skipped</a>, <a class="el" href="lustre__dlm_8h_source.html#l01344">LDLM_LOCK_GET</a>, <a class="el" href="lustre__dlm_8h_source.html#l01338">LDLM_LOCK_RELEASE</a>, <a class="el" href="ldlm__lock_8c_source.html#l00259">ldlm_lock_remove_from_lru_check()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00233">ldlm_lock_remove_from_lru_nolock()</a>, <a class="el" href="ldlm__internal_8h_source.html#l00110">LDLM_LRU_FLAG_LRUR_NO_WAIT</a>, <a class="el" href="ldlm__internal_8h_source.html#l00108">LDLM_LRU_FLAG_NO_WAIT</a>, <a class="el" href="ldlm__internal_8h_source.html#l00258">LDLM_POLICY_KEEP_LOCK</a>, <a class="el" href="ldlm__internal_8h_source.html#l00259">LDLM_POLICY_SKIP_LOCK</a>, <a class="el" href="list_8h_source.html#l00076">list_add()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="list_8h_source.html#l00484">list_for_each_entry_safe</a>, <a class="el" href="l__lock_8c_source.html#l00051">lock_res_and_lock()</a>, <a class="el" href="lu__ref_8h_source.html#l00204">lu_ref_add()</a>, <a class="el" href="lu__ref_8h_source.html#l00223">lu_ref_del()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00553">ns_connect_lru_resize()</a>, <a class="el" href="lustre__dlm_8h_source.html#l00380">ldlm_namespace::ns_lock</a>, <a class="el" href="lustre__dlm_8h_source.html#l00422">ldlm_namespace::ns_max_unused</a>, <a class="el" href="lustre__dlm_8h_source.html#l00415">ldlm_namespace::ns_nr_unused</a>, <a class="el" href="lustre__dlm_8h_source.html#l00413">ldlm_namespace::ns_unused_list</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, and <a class="el" href="l__lock_8c_source.html#l00067">unlock_res_and_lock()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01831">ldlm_cancel_lru()</a>, and <a class="el" href="ldlm__request_8c_source.html#l01809">ldlm_cancel_lru_local()</a>.</p>

</div>
</div>
<a class="anchor" id="acd777667e24902002df1ab9dad165a56"></a><!-- doxytag: member="ldlm_request.c::ldlm_req_handles_avail" ref="acd777667e24902002df1ab9dad165a56" args="(int req_size, int off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_req_handles_avail </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>req_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate number of lock handles that would fit into request of given size. </p>
<p>PAGE_SIZE-512 is to allow TCP/IP and LNET headers to fit into a single page on the send/receive side. XXX: 512 should be changed to more adequate value. </p>

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00724">724</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="lustre__idl_8h_source.html#l02903">LDLM_LOCKREQ_HANDLES</a>, <a class="el" href="lustre__net_8h_source.html#l00266">LDLM_MAXREQSIZE</a>, <a class="el" href="libcfs__private_8h_source.html#l00309">likely</a>, and <a class="el" href="osc__internal_8h_source.html#l00177">min_t</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00738">ldlm_capsule_handles_avail()</a>, and <a class="el" href="ldlm__request_8c_source.html#l00746">ldlm_format_handles_avail()</a>.</p>

</div>
</div>
<a class="anchor" id="aa74dce326e4e433329d8d04caaefd0e3"></a><!-- doxytag: member="ldlm_request.c::ldlm_res_iter_helper" ref="aa74dce326e4e433329d8d04caaefd0e3" args="(struct cfs_hash *hs, struct cfs_hash_bd *bd, struct hlist_node *hnode, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ldlm_res_iter_helper </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcfs__hash.html">cfs_hash</a> *&nbsp;</td>
          <td class="paramname"> <em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcfs__hash__bd.html">cfs_hash_bd</a> *&nbsp;</td>
          <td class="paramname"> <em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhlist__node.html">hlist_node</a> *&nbsp;</td>
          <td class="paramname"> <em>hnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l02105">2105</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="libcfs__hash_8h_source.html#l00482">cfs_hash_object()</a>, <a class="el" href="ldlm__request_8c_source.html#l02099">ldlm_iter_helper()</a>, <a class="el" href="lustre__dlm_8h_source.html#l01181">LDLM_ITER_STOP</a>, and <a class="el" href="ldlm__request_8c_source.html#l02056">ldlm_resource_foreach()</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l02115">ldlm_namespace_foreach()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e8af84d65fd36480c7f90978edea82e"></a><!-- doxytag: member="ldlm_request.c::module_param" ref="a3e8af84d65fd36480c7f90978edea82e" args="(ldlm_enqueue_min, uint, 0644)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">module_param </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ldlm__request_8c.html#a203c443910cb010024d2111b0126d31d">ldlm_enqueue_min</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0644&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a17197d5cc3101fe7444894dbbda07150"></a><!-- doxytag: member="ldlm_request.c::MODULE_PARM_DESC" ref="a17197d5cc3101fe7444894dbbda07150" args="(ldlm_enqueue_min,&quot;lock enqueue timeout minimum&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MODULE_PARM_DESC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ldlm__request_8c.html#a203c443910cb010024d2111b0126d31d">ldlm_enqueue_min</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;lock enqueue <a class="el" href="o2iblnd__modparams_8c.html#a493b57f443cc38b3d3df9c1e584d9d82">timeout</a> minimum&quot;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a54be6501cb9ee04fbec2d2e4f065e58b"></a><!-- doxytag: member="ldlm_request.c::replay_lock_interpret" ref="a54be6501cb9ee04fbec2d2e4f065e58b" args="(const struct lu_env *env, struct ptlrpc_request *req, struct ldlm_async_args *aa, int rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int replay_lock_interpret </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlu__env.html">lu_env</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__async__args.html">ldlm_async_args</a> *&nbsp;</td>
          <td class="paramname"> <em>aa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l02175">2175</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="hash_8c_source.html#l02004">cfs_hash_rehash_key()</a>, <a class="el" href="lustre__idl_8h_source.html#l01017">lustre_handle::cookie</a>, <a class="el" href="lustre__dlm_8h_source.html#l00074">ELDLM_OK</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="lustre__export_8h_source.html#l00193">obd_export::exp_client_uuid</a>, <a class="el" href="lustre__export_8h_source.html#l00221">obd_export::exp_lock_hash</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="lustre__import_8h_source.html#l00224">obd_import::imp_replay_inflight</a>, <a class="el" href="lustre__dlm_8h_source.html#l00714">ldlm_lock::l_exp_hash</a>, <a class="el" href="lustre__dlm_8h_source.html#l00766">ldlm_lock::l_remote_handle</a>, <a class="el" href="lustre__dlm_8h_source.html#l01168">LDLM_DEBUG</a>, <a class="el" href="lustre__dlm_8h_source.html#l01273">ldlm_handle2lock()</a>, <a class="el" href="lustre__dlm_8h_source.html#l01327">LDLM_LOCK_PUT</a>, <a class="el" href="lnet_2lnet_2nidstrings_8c_source.html#l01236">libcfs_id2str()</a>, <a class="el" href="lustre__idl_8h_source.html#l02928">ldlm_reply::lock_handle</a>, <a class="el" href="ldlm__request_8c_source.html#l00087">ldlm_async_args::lock_handle</a>, <a class="el" href="libcfs_2include_2libcfs_2types_8h_source.html#l00047">LPX64</a>, <a class="el" href="import_8c_source.html#l00648">ptlrpc_connect_import()</a>, <a class="el" href="import_8c_source.html#l01449">ptlrpc_import_recovery_state_machine()</a>, <a class="el" href="layout_8c_source.html#l02158">req_capsule_server_get()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="layout_8c_source.html#l01039">RMF_DLM_REP</a>, <a class="el" href="lustre__net_8h_source.html#l01102">ptlrpc_request::rq_export</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01108">ptlrpc_request::rq_peer</a>, <a class="el" href="lustre__net_8h_source.html#l01121">ptlrpc_request::rq_pill</a>, and <a class="el" href="lustre__user_8h_source.html#l00492">obd_uuid::uuid</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l02226">replay_one_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ad8564a094e2aa5a713852b452afe28"></a><!-- doxytag: member="ldlm_request.c::replay_one_lock" ref="a6ad8564a094e2aa5a713852b452afe28" args="(struct obd_import *imp, struct ldlm_lock *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int replay_one_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structobd__import.html">obd_import</a> *&nbsp;</td>
          <td class="paramname"> <em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l02226">2226</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>References <a class="el" href="osd__iam_8h_source.html#l00054">CLASSERT</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="lustre__import_8h_source.html#l00224">obd_import::imp_replay_inflight</a>, <a class="el" href="lustre__dlm_8h_source.html#l00728">ldlm_lock::l_granted_mode</a>, <a class="el" href="lustre__dlm_8h_source.html#l00818">ldlm_lock::l_lvb_len</a>, <a class="el" href="lustre__dlm_8h_source.html#l00724">ldlm_lock::l_req_mode</a>, <a class="el" href="lustre__dlm_8h_source.html#l00705">ldlm_lock::l_res_link</a>, <a class="el" href="lustre__dlm_8h_source.html#l01168">LDLM_DEBUG</a>, <a class="el" href="packet-lustre_8c_source.html#l00284">LDLM_ENQUEUE</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00048">LDLM_FL_BLOCK_CONV</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00040">LDLM_FL_BLOCK_GRANTED</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00056">LDLM_FL_BLOCK_WAIT</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00070">LDLM_FL_REPLAY</a>, <a class="el" href="lustre__idl_8h_source.html#l02933">ldlm_flags_to_wire</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00128">ldlm_is_cancel_on_block</a>, <a class="el" href="lustre__dlm__flags_8h_source.html#l00204">ldlm_is_canceling</a>, <a class="el" href="ldlm__lock_8c_source.html#l00646">ldlm_lock2desc()</a>, <a class="el" href="ldlm__lock_8c_source.html#l00582">ldlm_lock2handle()</a>, <a class="el" href="ldlm__lock_8c_source.html#l02249">ldlm_lock_cancel()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="lustre__idl_8h_source.html#l02909">ldlm_request::lock_desc</a>, <a class="el" href="lustre__idl_8h_source.html#l02907">ldlm_request::lock_flags</a>, <a class="el" href="ldlm__request_8c_source.html#l00087">ldlm_async_args::lock_handle</a>, <a class="el" href="lustre__idl_8h_source.html#l02910">ldlm_request::lock_handle</a>, <a class="el" href="packet-lustre_8c_source.html#l00079">LUSTRE_DLM_VERSION</a>, <a class="el" href="lustre__import_8h_source.html#l00103">LUSTRE_IMP_REPLAY_LOCKS</a>, <a class="el" href="pack__generic_8c_source.html#l00863">lustre_msg_set_flags()</a>, <a class="el" href="lustre__idl_8h_source.html#l01161">MSG_REQ_REPLAY_DONE</a>, <a class="el" href="lustre__net_8h_source.html#l00505">ptlrpc_req_async_args</a>, <a class="el" href="client_8c_source.html#l00891">ptlrpc_request_alloc_pack()</a>, <a class="el" href="pack__generic_8c_source.html#l01551">ptlrpc_request_set_replen()</a>, <a class="el" href="ptlrpcd_8c_source.html#l00268">ptlrpcd_add_req()</a>, <a class="el" href="lustre__req__layout_8h_source.html#l00059">RCL_SERVER</a>, <a class="el" href="ldlm__request_8c_source.html#l02175">replay_lock_interpret()</a>, <a class="el" href="layout_8c_source.html#l02117">req_capsule_client_get()</a>, <a class="el" href="layout_8c_source.html#l02339">req_capsule_extend()</a>, <a class="el" href="layout_8c_source.html#l02226">req_capsule_set_size()</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="layout_8c_source.html#l01049">RMF_DLM_LVB</a>, <a class="el" href="layout_8c_source.html#l01033">RMF_DLM_REQ</a>, <a class="el" href="lustre__net_8h_source.html#l01104">ptlrpc_request::rq_import</a>, <a class="el" href="lustre__net_8h_source.html#l01121">ptlrpc_request::rq_pill</a>, <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>, <a class="el" href="layout_8c_source.html#l01441">RQF_LDLM_ENQUEUE</a>, and <a class="el" href="layout_8c_source.html#l01446">RQF_LDLM_ENQUEUE_LVB</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l02338">ldlm_replay_locks()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a6cce6a0acada8138e2b47454551f40ca"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_lru_policy_t" ref="a6cce6a0acada8138e2b47454551f40ca" args=")(struct ldlm_namespace *ns, struct ldlm_lock *lock, int unused, int added, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ldlm__internal_8h.html#a889e25f73ecdf5619e0ee61c03c9d2a7">ldlm_policy_res</a>(* <a class="el" href="ldlm__request_8c.html#a6cce6a0acada8138e2b47454551f40ca">ldlm_cancel_lru_policy_t</a>)(struct <a class="el" href="structldlm__namespace.html">ldlm_namespace</a> *ns, struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *lock, int unused, int added, int count)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l01669">ldlm_prepare_lru_list()</a>.</p>

</div>
</div>
<a class="anchor" id="a27b7071107b0390cd461fa9679d8d67a"></a><!-- doxytag: member="ldlm_request.c::ldlm_cancel_unused_locks_before_replay" ref="a27b7071107b0390cd461fa9679d8d67a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="ldlm__request_8c.html#a27b7071107b0390cd461fa9679d8d67a">ldlm_cancel_unused_locks_before_replay</a> = 1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00075">75</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l02338">ldlm_replay_locks()</a>.</p>

</div>
</div>
<a class="anchor" id="a203c443910cb010024d2111b0126d31d"></a><!-- doxytag: member="ldlm_request.c::ldlm_enqueue_min" ref="a203c443910cb010024d2111b0126d31d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="ldlm__request_8c.html#a203c443910cb010024d2111b0126d31d">ldlm_enqueue_min</a> = OBD_TIMEOUT_DEFAULT</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ldlm__request_8c_source.html#l00070">70</a> of file <a class="el" href="ldlm__request_8c_source.html">ldlm_request.c</a>.</p>

<p>Referenced by <a class="el" href="ldlm__request_8c_source.html#l00142">ldlm_cp_timeout()</a>, and <a class="el" href="ldlm__resource_8c_source.html#l00661">ldlm_namespace_new()</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:47 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
