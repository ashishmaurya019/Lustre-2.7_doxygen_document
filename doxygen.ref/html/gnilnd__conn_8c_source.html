<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lnet/klnds/gnilnd/gnilnd_conn.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lnet/klnds/gnilnd/gnilnd_conn.c</h1><a href="gnilnd__conn_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (C) 2012 Cray, Inc.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (c) 2014, Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *   Author: Nic Henke &lt;nic@cray.com&gt;</span>
<a name="l00007"></a>00007 <span class="comment"> *   Author: James Shimek &lt;jshimek@cray.com&gt;</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *   This file is part of Lustre, http://www.lustre.org.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> *   Lustre is free software; you can redistribute it and/or</span>
<a name="l00012"></a>00012 <span class="comment"> *   modify it under the terms of version 2 of the GNU General Public</span>
<a name="l00013"></a>00013 <span class="comment"> *   License as published by the Free Software Foundation.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> *   Lustre is distributed in the hope that it will be useful,</span>
<a name="l00016"></a>00016 <span class="comment"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00017"></a>00017 <span class="comment"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00018"></a>00018 <span class="comment"> *   GNU General Public License for more details.</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> *   You should have received a copy of the GNU General Public License</span>
<a name="l00021"></a>00021 <span class="comment"> *   along with Lustre; if not, write to the Free Software</span>
<a name="l00022"></a>00022 <span class="comment"> *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> */</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="gnilnd_8h.html">gnilnd.h</a>&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="keywordtype">void</span>
<a name="l00029"></a><a class="code" href="gnilnd__conn_8c.html#ad061b2e50cb63b7451493fe03f8194f6">00029</a> <a class="code" href="gnilnd__conn_8c.html#ad061b2e50cb63b7451493fe03f8194f6">kgnilnd_setup_smsg_attr</a>(<a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a> *smsg_attr)
<a name="l00030"></a>00030 {
<a name="l00031"></a>00031         smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#a886a3dbdabf3b1c984410eb4023d346f">mbox_maxcredit</a> = *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#aaada2458ab6f6be7992cca495951adb3">kgn_mbox_credits</a>;
<a name="l00032"></a>00032         smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ad2856348d4b3b2f5287537ffa97503fc">msg_maxsize</a> = <a class="code" href="gnilnd_8h.html#a84dc655f9e1334a031e2ec2fcdc840c4">GNILND_MAX_MSG_SIZE</a>;
<a name="l00033"></a>00033         smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#a3b26680b65203d00681c08a9abfef14a">msg_type</a> = <a class="code" href="gni__pub_8h.html#ab613af3bb116af372b9788fa0c7ea730ae2f6b388167ffec7ccee42df34fc766d">GNI_SMSG_TYPE_MBOX_AUTO_RETRANSMIT</a>;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keywordtype">int</span>
<a name="l00037"></a><a class="code" href="gnilnd__conn_8c.html#ae1cb1d8c4f08c31ddaac9acd13a97dff">00037</a> <a class="code" href="gnilnd__conn_8c.html#ae1cb1d8c4f08c31ddaac9acd13a97dff">kgnilnd_map_fmablk</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device, <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a> *fma_blk)
<a name="l00038"></a>00038 {
<a name="l00039"></a>00039         <a class="code" href="gni__pub_8h.html#a4a1de8d517eef402419200b53132f9a0">gni_return_t</a>            rrc;
<a name="l00040"></a>00040         __u32                   flags = <a class="code" href="gni__pub_8h.html#a6e6c614a3437b000bd1a25563eb9bd17">GNI_MEM_READWRITE</a>;
<a name="l00041"></a>00041         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>    reg_to;
<a name="l00042"></a>00042         <span class="keywordtype">int</span>                     rfto = *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#aa40136954f6aa247e5cde59c86c578e1">kgn_reg_fail_timeout</a>;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> == <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>) {
<a name="l00045"></a>00045                 flags |= <a class="code" href="gni__pub_8h.html#afa8b155195ebeabb9b3fe4fe4611b723">GNI_MEM_PHYS_CONT</a>;
<a name="l00046"></a>00046         }
<a name="l00047"></a>00047 
<a name="l00048"></a>00048         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a887e7562a9972a1759c2bd091e817c8a">gnm_hold_timeout</a> = 0;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050         <span class="comment">/* make sure we are mapping a clean block */</span>
<a name="l00051"></a>00051         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#ab879a822d025628dfa78c0671a64ecf8">qword1</a> == 0UL, <span class="stringliteral">&quot;fma_blk %p dirty\n&quot;</span>, fma_blk);
<a name="l00052"></a>00052 
<a name="l00053"></a>00053         rrc = <a class="code" href="gnilnd__api__wrap_8h.html#a2dd5905f76f0edec4bcf37fd7730bb0c">kgnilnd_mem_register</a>(device-&gt;<a class="code" href="structkgn__device.html#adef69bb2d51b71d659d4404ea419e18e">gnd_handle</a>, (<a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>)fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a>,
<a name="l00054"></a>00054                                    fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>, device-&gt;<a class="code" href="structkgn__device.html#a3c6917235269d06e3c44a66d18be65f4">gnd_rcv_fma_cqh</a>,
<a name="l00055"></a>00055                                    flags, &amp;fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>);
<a name="l00056"></a>00056         <span class="keywordflow">if</span> (rrc != <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>) {
<a name="l00057"></a>00057                 <span class="keywordflow">if</span> (rfto != <a class="code" href="gnilnd_8h.html#aabe23a38dccb02dc4cb0304e97097dba">GNILND_REGFAILTO_DISABLE</a>) {
<a name="l00058"></a>00058                         <span class="keywordflow">if</span> (reg_to == 0) {
<a name="l00059"></a>00059                                 reg_to = jiffies + <a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(rfto);
<a name="l00060"></a>00060                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (time_after(jiffies, reg_to)) {
<a name="l00061"></a>00061                                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;FATAL:fmablk registration has failed &quot;</span>
<a name="l00062"></a>00062                                        <span class="stringliteral">&quot;for %ld seconds.\n&quot;</span>,
<a name="l00063"></a>00063                                        <a class="code" href="linux-time_8h.html#ad893b50498565ea641263d4771bd69bc">cfs_duration_sec</a>(jiffies - reg_to) +
<a name="l00064"></a>00064                                                 rfto);
<a name="l00065"></a>00065                                 <a class="code" href="libcfs__private_8h.html#a08eceadb65d1adcf8c198cff27081d5f">LBUG</a>();
<a name="l00066"></a>00066                         }
<a name="l00067"></a>00067                 }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069                 <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;register fmablk failed 0x%p mbox_size %d flags %u\n&quot;</span>,
<a name="l00070"></a>00070                         fma_blk, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>, flags);
<a name="l00071"></a>00071                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-ENOMEM);
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         reg_to = 0;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <span class="comment">/* PHYS_CONT memory isn&apos;t really mapped, at least not in GART -</span>
<a name="l00077"></a>00077 <span class="comment">         *  but all mappings chew up a MDD</span>
<a name="l00078"></a>00078 <span class="comment">         */</span>
<a name="l00079"></a>00079         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> != <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>) {
<a name="l00080"></a>00080                 atomic64_add(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>, &amp;device-&gt;<a class="code" href="structkgn__device.html#a292559c55248658c29bcc821160a20e1">gnd_nbytes_map</a>);
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         atomic_inc(&amp;device-&gt;<a class="code" href="structkgn__device.html#a6ea63598d69da2c028365e8c041cce37">gnd_n_mdd</a>);
<a name="l00084"></a>00084         <span class="comment">/* nfmablk is live (mapped) blocks */</span>
<a name="l00085"></a>00085         atomic_inc(&amp;device-&gt;<a class="code" href="structkgn__device.html#a9b60268478e8dc949207f034d97db73d">gnd_nfmablk</a>);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00088"></a>00088 }
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="keywordtype">int</span>
<a name="l00091"></a><a class="code" href="gnilnd__conn_8c.html#a68821496fbf0cd4bebcbe9cbfbf09413">00091</a> <a class="code" href="gnilnd__conn_8c.html#a68821496fbf0cd4bebcbe9cbfbf09413">kgnilnd_alloc_fmablk</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device, <span class="keywordtype">int</span> use_phys)
<a name="l00092"></a>00092 {
<a name="l00093"></a>00093         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00094"></a>00094         <span class="keywordtype">int</span>                     num_mbox;
<a name="l00095"></a>00095         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>     *fma_blk;
<a name="l00096"></a>00096         <a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a>         smsg_attr;
<a name="l00097"></a>00097         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>           fmablk_vers;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="preprocessor">#if defined(CONFIG_CRAY_XT) &amp;&amp; !defined(CONFIG_CRAY_COMPUTE)</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>        <span class="comment">/* We allocate large blocks of memory here potentially leading</span>
<a name="l00101"></a>00101 <span class="comment">         * to memory exhaustion during massive reconnects during a network</span>
<a name="l00102"></a>00102 <span class="comment">         * outage. Limit the amount of fma blocks to use by always keeping</span>
<a name="l00103"></a>00103 <span class="comment">         * a percent of pages free initially set to 25% of total memory. */</span>
<a name="l00104"></a>00104         <span class="keywordflow">if</span> (global_page_state(NR_FREE_PAGES) &lt; <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0620d46bb7dfbbf65e0d99e0e3658845">free_pages_limit</a>) {
<a name="l00105"></a>00105                 <a class="code" href="libcfs__debug_8h.html#a43240b2ab1235407f143ed4582ea1f75">LCONSOLE_INFO</a>(<span class="stringliteral">&quot;Exceeding free page limit of %ld. &quot;</span>
<a name="l00106"></a>00106                               <span class="stringliteral">&quot;Free pages available %ld\n&quot;</span>,
<a name="l00107"></a>00107                               <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0620d46bb7dfbbf65e0d99e0e3658845">free_pages_limit</a>,
<a name="l00108"></a>00108                               global_page_state(NR_FREE_PAGES));
<a name="l00109"></a>00109                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111 <span class="preprocessor">#endif</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>        <span class="comment">/* we&apos;ll use fmablk_vers and the gnd_fmablk_mutex to gate access</span>
<a name="l00113"></a>00113 <span class="comment">         * to this allocation code. Everyone will sample the version</span>
<a name="l00114"></a>00114 <span class="comment">         * before and after getting the mutex. If it has changed,</span>
<a name="l00115"></a>00115 <span class="comment">         * we&apos;ll bail out to check the lists again - this indicates that</span>
<a name="l00116"></a>00116 <span class="comment">         * some sort of change was made to the lists and it is possible</span>
<a name="l00117"></a>00117 <span class="comment">         * that there is a mailbox for us to find now. This should prevent</span>
<a name="l00118"></a>00118 <span class="comment">         * a ton of spinning in the case where there are lots of threads</span>
<a name="l00119"></a>00119 <span class="comment">         * that need a yet-to-be-allocated mailbox for a connection. */</span>
<a name="l00120"></a>00120 
<a name="l00121"></a>00121         fmablk_vers = atomic_read(&amp;device-&gt;<a class="code" href="structkgn__device.html#a102b3ef6f66caff6c374de0eb5c62f24">gnd_fmablk_vers</a>);
<a name="l00122"></a>00122         mutex_lock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         <span class="keywordflow">if</span> (fmablk_vers != atomic_read(&amp;device-&gt;<a class="code" href="structkgn__device.html#a102b3ef6f66caff6c374de0eb5c62f24">gnd_fmablk_vers</a>)) {
<a name="l00125"></a>00125                 <span class="comment">/* version changed while we were waiting for semaphore,</span>
<a name="l00126"></a>00126 <span class="comment">                 * we&apos;ll recheck the lists assuming something nice happened */</span>
<a name="l00127"></a>00127                 mutex_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00128"></a>00128                 <span class="keywordflow">return</span> 0;
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <a class="code" href="libcfs__private_8h.html#a87a8b94124ee7f73a969859a2fd83294">LIBCFS_ALLOC</a>(fma_blk, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>));
<a name="l00132"></a>00132         <span class="keywordflow">if</span> (fma_blk == NULL) {
<a name="l00133"></a>00133                 <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;could not allocate fma block descriptor\n&quot;</span>);
<a name="l00134"></a>00134                 rc = -ENOMEM;
<a name="l00135"></a>00135                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a1fb88c525253b178e5d3cbe8ee00b98e">gnm_bufflist</a>);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         <a class="code" href="gnilnd__conn_8c.html#ad061b2e50cb63b7451493fe03f8194f6">kgnilnd_setup_smsg_attr</a>(&amp;smsg_attr);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142         gni_smsg_buff_size_needed(&amp;smsg_attr, &amp;fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>, <span class="stringliteral">&quot;mbox size %d\n&quot;</span>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         <span class="comment">/* gni_smsg_buff_size_needed calculates the base mailbox size and since</span>
<a name="l00147"></a>00147 <span class="comment">         * we want to hold kgn_peer_credits worth of messages in both directions,</span>
<a name="l00148"></a>00148 <span class="comment">         * we add PAYLOAD to grow the mailbox size</span>
<a name="l00149"></a>00149 <span class="comment">         */</span>
<a name="l00150"></a>00150 
<a name="l00151"></a>00151         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a> += <a class="code" href="gnilnd_8h.html#aab471b111d7335252749baf434b64fb8">GNILND_MBOX_PAYLOAD</a>;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153         <span class="comment">/* we&apos;ll only use physical during preallocate at startup -- this keeps it nice and</span>
<a name="l00154"></a>00154 <span class="comment">         * clean for runtime decisions. We&apos;ll keep the PHYS ones around until shutdown</span>
<a name="l00155"></a>00155 <span class="comment">         * as reallocating them is tough if there is memory fragmentation */</span>
<a name="l00156"></a>00156 
<a name="l00157"></a>00157         <span class="keywordflow">if</span> (use_phys) {
<a name="l00158"></a>00158                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a> = kmem_cache_alloc(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a70b14daf19f25d72b39733b8dd28c71a">kgn_mbox_cache</a>, GFP_ATOMIC);
<a name="l00159"></a>00159                 <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a> == NULL) {
<a name="l00160"></a>00160                         <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;could not allocate physical SMSG mailbox memory\n&quot;</span>);
<a name="l00161"></a>00161                         rc = -ENOMEM;
<a name="l00162"></a>00162                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(free_desc, rc);
<a name="l00163"></a>00163                 }
<a name="l00164"></a>00164                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a> = KMALLOC_MAX_SIZE;
<a name="l00165"></a>00165                 num_mbox = fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a> / fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(num_mbox &gt;= 1,
<a name="l00168"></a>00168                          <span class="stringliteral">&quot;num_mbox %d blk_size %u mbox_size %d\n&quot;</span>,
<a name="l00169"></a>00169                           num_mbox, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> = <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         } <span class="keywordflow">else</span> {
<a name="l00174"></a>00174                 num_mbox = *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#a9ee75448f755ee69a9be568f70eb26c3">kgn_mbox_per_block</a>;
<a name="l00175"></a>00175                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a> = num_mbox * fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(num_mbox &gt;= 1 &amp;&amp; num_mbox &gt;= *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#a9ee75448f755ee69a9be568f70eb26c3">kgn_mbox_per_block</a>,
<a name="l00178"></a>00178                          <span class="stringliteral">&quot;num_mbox %d blk_size %u mbox_size %d tunable %d\n&quot;</span>,
<a name="l00179"></a>00179                          num_mbox, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>,
<a name="l00180"></a>00180                          *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#a9ee75448f755ee69a9be568f70eb26c3">kgn_mbox_per_block</a>);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a> = <a class="code" href="gnilnd_8h.html#a02f68a201db8ff28fd06b10065c9feae">kgnilnd_vzalloc</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>);
<a name="l00183"></a>00183                 <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a> == NULL) {
<a name="l00184"></a>00184                         <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;could not allocate virtual SMSG mailbox memory, %d bytes\n&quot;</span>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>);
<a name="l00185"></a>00185                         rc = -ENOMEM;
<a name="l00186"></a>00186                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(free_desc, rc);
<a name="l00187"></a>00187                 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> = <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0fea1ccd4e5861d4867649a79b03f8e2138c">GNILND_FMABLK_VIRT</a>;
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         <span class="comment">/* allocate just enough space for the bits to track the mailboxes */</span>
<a name="l00193"></a>00193         <a class="code" href="libcfs__private_8h.html#a87a8b94124ee7f73a969859a2fd83294">LIBCFS_ALLOC</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a79ec5a38cffb295070f70fc48f725c27">gnm_bit_array</a>, BITS_TO_LONGS(num_mbox) * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>));
<a name="l00194"></a>00194         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a79ec5a38cffb295070f70fc48f725c27">gnm_bit_array</a> == NULL) {
<a name="l00195"></a>00195                 <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;could not allocate mailbox bitmask, %lu bytes for %d mbox\n&quot;</span>,
<a name="l00196"></a>00196                        <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) * BITS_TO_LONGS(num_mbox), num_mbox);
<a name="l00197"></a>00197                 rc = -ENOMEM;
<a name="l00198"></a>00198                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(free_blk, rc);
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200         bitmap_zero(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a79ec5a38cffb295070f70fc48f725c27">gnm_bit_array</a>, num_mbox);
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="comment">/* now that the num_mbox is set based on allocation type, get debug info setup */</span>
<a name="l00203"></a>00203         <a class="code" href="libcfs__private_8h.html#a87a8b94124ee7f73a969859a2fd83294">LIBCFS_ALLOC</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a4a4b79d2d90189d3d56b9e449644322f">gnm_mbox_info</a>, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>) * num_mbox);
<a name="l00204"></a>00204         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a4a4b79d2d90189d3d56b9e449644322f">gnm_mbox_info</a> == NULL) {
<a name="l00205"></a>00205                 <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;could not allocate mailbox debug, %lu bytes for %d mbox\n&quot;</span>,
<a name="l00206"></a>00206                        <span class="keyword">sizeof</span>(<a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>) * num_mbox, num_mbox);
<a name="l00207"></a>00207                 rc = -ENOMEM;
<a name="l00208"></a>00208                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(free_bit, rc);
<a name="l00209"></a>00209         }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         rc = <a class="code" href="gnilnd__conn_8c.html#ae1cb1d8c4f08c31ddaac9acd13a97dff">kgnilnd_map_fmablk</a>(device, fma_blk);
<a name="l00212"></a>00212         <span class="keywordflow">if</span> (rc) {
<a name="l00213"></a>00213                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(free_info, rc);
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#ad0fb3006dd21142155a2fa4abbc10cb8">gnm_next_avail_mbox</a> = 0;
<a name="l00217"></a>00217         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a> = fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a> = num_mbox;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a278f60b5ab8e7110e93fbaf0cd4b5c82">D_MALLOC</a>, <span class="stringliteral">&quot;alloc fmablk 0x%p num %d msg_maxsize %d credits %d &quot;</span>
<a name="l00220"></a>00220                 <span class="stringliteral">&quot;mbox_size %d MDD &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;.&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00221"></a>00221                 fma_blk, num_mbox, smsg_attr.<a class="code" href="structgni__smsg__attr.html#ad2856348d4b3b2f5287537ffa97503fc">msg_maxsize</a>, smsg_attr.<a class="code" href="structgni__smsg__attr.html#a886a3dbdabf3b1c984410eb4023d346f">mbox_maxcredit</a>,
<a name="l00222"></a>00222                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#ab879a822d025628dfa78c0671a64ecf8">qword1</a>,
<a name="l00223"></a>00223                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#a51b2b57c5461fac275e60df0fe6b917a">qword2</a>);
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         <span class="comment">/* lock Is protecting data structures, not semaphore */</span>
<a name="l00226"></a>00226 
<a name="l00227"></a>00227         spin_lock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00228"></a>00228         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a1fb88c525253b178e5d3cbe8ee00b98e">gnm_bufflist</a>, &amp;device-&gt;<a class="code" href="structkgn__device.html#a7788b6db1547646b3bc81f8ee2b5670d">gnd_fma_buffs</a>);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230         <span class="comment">/* toggle under the lock so once they change the list is also</span>
<a name="l00231"></a>00231 <span class="comment">         * ready for others to traverse */</span>
<a name="l00232"></a>00232         atomic_inc(&amp;device-&gt;<a class="code" href="structkgn__device.html#a102b3ef6f66caff6c374de0eb5c62f24">gnd_fmablk_vers</a>);
<a name="l00233"></a>00233 
<a name="l00234"></a>00234         spin_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         mutex_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         <span class="keywordflow">return</span> 0;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 free_info:
<a name="l00241"></a>00241         <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a4a4b79d2d90189d3d56b9e449644322f">gnm_mbox_info</a>, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>)*num_mbox);
<a name="l00242"></a>00242 free_bit:
<a name="l00243"></a>00243         <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a79ec5a38cffb295070f70fc48f725c27">gnm_bit_array</a>, BITS_TO_LONGS(num_mbox) * <span class="keyword">sizeof</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>));
<a name="l00244"></a>00244 free_blk:
<a name="l00245"></a>00245         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> == <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0fea1ccd4e5861d4867649a79b03f8e2138c">GNILND_FMABLK_VIRT</a>) {
<a name="l00246"></a>00246                 <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>);
<a name="l00247"></a>00247         } <span class="keywordflow">else</span> {
<a name="l00248"></a>00248                 kmem_cache_free(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a70b14daf19f25d72b39733b8dd28c71a">kgn_mbox_cache</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a>);
<a name="l00249"></a>00249         }
<a name="l00250"></a>00250 free_desc:
<a name="l00251"></a>00251         <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(fma_blk, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>));
<a name="l00252"></a>00252 out:
<a name="l00253"></a>00253         mutex_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00254"></a>00254         <span class="keywordflow">return</span> rc;
<a name="l00255"></a>00255 }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keywordtype">void</span>
<a name="l00258"></a><a class="code" href="gnilnd__conn_8c.html#abc08557ff8c365cc1bde6bb0e283a44c">00258</a> <a class="code" href="gnilnd__conn_8c.html#abc08557ff8c365cc1bde6bb0e283a44c">kgnilnd_unmap_fmablk</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a> *fma_blk)
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260         <a class="code" href="gni__pub_8h.html#a4a1de8d517eef402419200b53132f9a0">gni_return_t</a>            rrc;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         <span class="comment">/* if some held, set hold_timeout from conn timeouts used in this block</span>
<a name="l00263"></a>00263 <span class="comment">         * but not during shutdown, then just nuke and pave</span>
<a name="l00264"></a>00264 <span class="comment">         * During a stack reset, we need to deregister with a hold timeout</span>
<a name="l00265"></a>00265 <span class="comment">         * set so we don&apos;t use the same mdd after reset is complete */</span>
<a name="l00266"></a>00266         <span class="keywordflow">if</span> ((fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9c1dd155b9beaae810d5c012235c3e4e">gnm_held_mboxs</a> &amp;&amp; !<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#ab2514d2a3fe52303f185e3f4c7260eea">kgn_shutdown</a>) ||
<a name="l00267"></a>00267             <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0cd73387ab25e56d411e774a9b613447">kgn_in_reset</a>) {
<a name="l00268"></a>00268                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a887e7562a9972a1759c2bd091e817c8a">gnm_hold_timeout</a> = <a class="code" href="gnilnd_8h.html#a59819d72bb2c1d56d952b4e208c81b0e">GNILND_TIMEOUT2DEADMAN</a>;
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271         <span class="comment">/* we are changing the state of a block, tickle version to tell</span>
<a name="l00272"></a>00272 <span class="comment">         * proc code list is stale now */</span>
<a name="l00273"></a>00273         atomic_inc(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a102b3ef6f66caff6c374de0eb5c62f24">gnd_fmablk_vers</a>);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         rrc = <a class="code" href="gnilnd__api__wrap_8h.html#ab0a24cc8fbc6f9008b6d43aaacaffebc">kgnilnd_mem_deregister</a>(dev-&gt;<a class="code" href="structkgn__device.html#adef69bb2d51b71d659d4404ea419e18e">gnd_handle</a>, &amp;fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a887e7562a9972a1759c2bd091e817c8a">gnm_hold_timeout</a>);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(rrc == <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a> ? <a class="code" href="libcfs__debug_8h.html#a278f60b5ab8e7110e93fbaf0cd4b5c82">D_MALLOC</a> : <a class="code" href="libcfs__debug_8h.html#a318a550b352f722c270e9c8ea962ae28">D_CONSOLE</a>|<a class="code" href="libcfs__debug_8h.html#a2e9936ae6b69f5e744aacbae3b33c749">D_NETERROR</a>,
<a name="l00278"></a>00278                <span class="stringliteral">&quot;unmap fmablk 0x%p@%s sz %u total %d avail %d held %d mbox_size %d &quot;</span>
<a name="l00279"></a>00279                 <span class="stringliteral">&quot;hold_timeout %d\n&quot;</span>,
<a name="l00280"></a>00280                fma_blk, <a class="code" href="gnilnd_8h.html#ae63679d499465f18c88e248421293d9a">kgnilnd_fmablk_state2str</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a>),
<a name="l00281"></a>00281                fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>,
<a name="l00282"></a>00282                fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9c1dd155b9beaae810d5c012235c3e4e">gnm_held_mboxs</a>,
<a name="l00283"></a>00283                fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a887e7562a9972a1759c2bd091e817c8a">gnm_hold_timeout</a>);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(rrc == <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>,
<a name="l00286"></a>00286                 <span class="stringliteral">&quot;tried to double unmap or something bad, fma_blk %p (rrc %d)\n&quot;</span>,
<a name="l00287"></a>00287                 fma_blk, rrc);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a887e7562a9972a1759c2bd091e817c8a">gnm_hold_timeout</a> &amp;&amp;
<a name="l00290"></a>00290             !(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0cd73387ab25e56d411e774a9b613447">kgn_in_reset</a> &amp;&amp;
<a name="l00291"></a>00291               fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> == <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>)) {
<a name="l00292"></a>00292                 atomic_inc(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a9182b880f57ab8df2151ce2d15c8554a">gnd_n_mdd_held</a>);
<a name="l00293"></a>00293         } <span class="keywordflow">else</span> {
<a name="l00294"></a>00294                 atomic_dec(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a6ea63598d69da2c028365e8c041cce37">gnd_n_mdd</a>);
<a name="l00295"></a>00295         }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297         <span class="comment">/* PHYS blocks don&apos;t get mapped */</span>
<a name="l00298"></a>00298         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> != <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>) {
<a name="l00299"></a>00299                 atomic64_sub(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>, &amp;dev-&gt;<a class="code" href="structkgn__device.html#a292559c55248658c29bcc821160a20e1">gnd_nbytes_map</a>);
<a name="l00300"></a>00300                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> = <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0fead20fc3a310984100fe707210c936f305">GNILND_FMABLK_IDLE</a>;
<a name="l00301"></a>00301         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0cd73387ab25e56d411e774a9b613447">kgn_in_reset</a>) {
<a name="l00302"></a>00302                 <span class="comment">/* in stack reset, clear MDD handle for PHYS blocks, as we&apos;ll</span>
<a name="l00303"></a>00303 <span class="comment">                 * re-use the fma_blk after reset so we don&apos;t have to drop/allocate</span>
<a name="l00304"></a>00304 <span class="comment">                 * all of those physical blocks */</span>
<a name="l00305"></a>00305                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#ab879a822d025628dfa78c0671a64ecf8">qword1</a> = fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#a51b2b57c5461fac275e60df0fe6b917a">qword2</a> = 0UL;
<a name="l00306"></a>00306         }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308         <span class="comment">/* Decrement here as this is the # of mapped blocks */</span>
<a name="l00309"></a>00309         atomic_dec(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a9b60268478e8dc949207f034d97db73d">gnd_nfmablk</a>);
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="comment">/* needs lock on gnd_fmablk_lock to cover gnd_fma_buffs */</span>
<a name="l00314"></a>00314 <span class="keywordtype">void</span>
<a name="l00315"></a><a class="code" href="gnilnd__conn_8c.html#af26a6bc416a851ddadab8556f14143c7">00315</a> <a class="code" href="gnilnd__conn_8c.html#af26a6bc416a851ddadab8556f14143c7">kgnilnd_free_fmablk_locked</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a> *fma_blk)
<a name="l00316"></a>00316 {
<a name="l00317"></a>00317         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a> == fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>,
<a name="l00318"></a>00318                  <span class="stringliteral">&quot;fma_blk %p@%d free in bad state (%d): blk total %d avail %d held %d\n&quot;</span>,
<a name="l00319"></a>00319                  fma_blk, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a887e7562a9972a1759c2bd091e817c8a">gnm_hold_timeout</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>,
<a name="l00320"></a>00320                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9c1dd155b9beaae810d5c012235c3e4e">gnm_held_mboxs</a>);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322         atomic_inc(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a102b3ef6f66caff6c374de0eb5c62f24">gnd_fmablk_vers</a>);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a887e7562a9972a1759c2bd091e817c8a">gnm_hold_timeout</a>) {
<a name="l00325"></a>00325                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a278f60b5ab8e7110e93fbaf0cd4b5c82">D_MALLOC</a>, <span class="stringliteral">&quot;mdd release fmablk 0x%p sz %u avail %d held %d &quot;</span>
<a name="l00326"></a>00326                         <span class="stringliteral">&quot;mbox_size %d\n&quot;</span>,
<a name="l00327"></a>00327                         fma_blk, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a>,
<a name="l00328"></a>00328                         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9c1dd155b9beaae810d5c012235c3e4e">gnm_held_mboxs</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330                 <span class="comment">/* We leave MDD dangling over stack reset */</span>
<a name="l00331"></a>00331                 <span class="keywordflow">if</span> (!<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0cd73387ab25e56d411e774a9b613447">kgn_in_reset</a>) {
<a name="l00332"></a>00332                         <a class="code" href="gnilnd__api__wrap_8h.html#a076e05350895cc25fdeccdaf87cf154a">kgnilnd_mem_mdd_release</a>(dev-&gt;<a class="code" href="structkgn__device.html#adef69bb2d51b71d659d4404ea419e18e">gnd_handle</a>, &amp;fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>);
<a name="l00333"></a>00333                 }
<a name="l00334"></a>00334                 <span class="comment">/* ignoring the return code - if kgni/ghal can&apos;t find it</span>
<a name="l00335"></a>00335 <span class="comment">                 * it must be released already */</span>
<a name="l00336"></a>00336                 atomic_dec(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a9182b880f57ab8df2151ce2d15c8554a">gnd_n_mdd_held</a>);
<a name="l00337"></a>00337                 atomic_dec(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a6ea63598d69da2c028365e8c041cce37">gnd_n_mdd</a>);
<a name="l00338"></a>00338         }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         <span class="comment">/* we cant&apos; free the gnm_block until all the conns have released their</span>
<a name="l00341"></a>00341 <span class="comment">         * purgatory holds. While we have purgatory holds, we might check the conn</span>
<a name="l00342"></a>00342 <span class="comment">         * RX mailbox during the CLOSING process. It is possible that kgni might</span>
<a name="l00343"></a>00343 <span class="comment">         * try to look into the RX side for credits when sending the CLOSE msg too */</span>
<a name="l00344"></a>00344         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a278f60b5ab8e7110e93fbaf0cd4b5c82">D_MALLOC</a>, <span class="stringliteral">&quot;fmablk %p free buffer %p mbox_size %d\n&quot;</span>,
<a name="l00345"></a>00345                 fma_blk, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> == <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>) {
<a name="l00348"></a>00348                 kmem_cache_free(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a70b14daf19f25d72b39733b8dd28c71a">kgn_mbox_cache</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a>);
<a name="l00349"></a>00349         } <span class="keywordflow">else</span> {
<a name="l00350"></a>00350                 <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9363f15234016f79f9750fb0cd266d06">gnm_blk_size</a>);
<a name="l00351"></a>00351         }
<a name="l00352"></a>00352         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> = <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0fea74f6c27283107427cfae273924e51c22">GNILND_FMABLK_FREED</a>;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354         <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a1fb88c525253b178e5d3cbe8ee00b98e">gnm_bufflist</a>);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a4a4b79d2d90189d3d56b9e449644322f">gnm_mbox_info</a>, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>)*fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>);
<a name="l00357"></a>00357         <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a79ec5a38cffb295070f70fc48f725c27">gnm_bit_array</a>, BITS_TO_LONGS(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>) * sizeof (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>));
<a name="l00358"></a>00358         <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(fma_blk, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>));
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 <span class="keywordtype">void</span>
<a name="l00362"></a><a class="code" href="gnilnd__conn_8c.html#a02dd3ffb7a7f96e44a1dd0f00a8306ed">00362</a> <a class="code" href="gnilnd__conn_8c.html#a02dd3ffb7a7f96e44a1dd0f00a8306ed">kgnilnd_find_free_mbox</a>(<a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn)
<a name="l00363"></a>00363 {
<a name="l00364"></a>00364         <a class="code" href="structkgn__device.html">kgn_device_t</a>            *dev = conn-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>;
<a name="l00365"></a>00365         <a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a>         *smsg_attr = &amp;conn-&gt;<a class="code" href="structkgn__conn.html#a11d994c672cf491d3935a13e04448879">gnpr_smsg_attr</a>;
<a name="l00366"></a>00366         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>      *fma_blk;
<a name="l00367"></a>00367         <a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>         *mbox = NULL;
<a name="l00368"></a>00368         <span class="keywordtype">int</span>                     id;
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(fma_blk, &amp;conn-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>-&gt;<a class="code" href="structkgn__device.html#a7788b6db1547646b3bc81f8ee2b5670d">gnd_fma_buffs</a>,
<a name="l00373"></a>00373                             gnm_bufflist) {
<a name="l00374"></a>00374                 <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a> &lt;= 0 ||
<a name="l00375"></a>00375                     fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> &lt;= <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0fead20fc3a310984100fe707210c936f305">GNILND_FMABLK_IDLE</a>) {
<a name="l00376"></a>00376                         <span class="keywordflow">continue</span>;
<a name="l00377"></a>00377                 }
<a name="l00378"></a>00378                 <span class="comment">/* look in bitarray for available mailbox */</span>
<a name="l00379"></a>00379                 <span class="keywordflow">do</span> {
<a name="l00380"></a>00380                         <span class="keywordtype">id</span> = find_next_zero_bit(
<a name="l00381"></a>00381                                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a79ec5a38cffb295070f70fc48f725c27">gnm_bit_array</a>,
<a name="l00382"></a>00382                                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>,
<a name="l00383"></a>00383                                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#ad0fb3006dd21142155a2fa4abbc10cb8">gnm_next_avail_mbox</a>);
<a name="l00384"></a>00384                       <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a> &amp;&amp;
<a name="l00385"></a>00385                           fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#ad0fb3006dd21142155a2fa4abbc10cb8">gnm_next_avail_mbox</a> != 0) {
<a name="l00386"></a>00386                                 <span class="comment">/* wrap around */</span>
<a name="l00387"></a>00387                                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#ad0fb3006dd21142155a2fa4abbc10cb8">gnm_next_avail_mbox</a> = 0;
<a name="l00388"></a>00388                         } <span class="keywordflow">else</span> {
<a name="l00389"></a>00389                                 <span class="keywordflow">break</span>;
<a name="l00390"></a>00390                         }
<a name="l00391"></a>00391                 } <span class="keywordflow">while</span> (1);
<a name="l00392"></a>00392 
<a name="l00393"></a>00393                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(id &lt; fma_blk-&gt;gnm_num_mboxs, <span class="stringliteral">&quot;id %d max %d\n&quot;</span>,
<a name="l00394"></a>00394                          <span class="keywordtype">id</span>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>);
<a name="l00395"></a>00395                 set_bit(<span class="keywordtype">id</span>, (<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a79ec5a38cffb295070f70fc48f725c27">gnm_bit_array</a>);
<a name="l00396"></a>00396                 conn-&gt;<a class="code" href="structkgn__conn.html#a6170b6853d316b0f0c41a29eee87f10f">gnc_mbox_id</a> = id;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#ad0fb3006dd21142155a2fa4abbc10cb8">gnm_next_avail_mbox</a> =
<a name="l00399"></a>00399                         (<span class="keywordtype">id</span> == (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a> - 1)) ? 0 : (<span class="keywordtype">id</span> + 1);
<a name="l00400"></a>00400                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a>--;
<a name="l00401"></a>00401                 conn-&gt;<a class="code" href="structkgn__conn.html#a44d0c57f674b15422b998eae0227b57a">gnc_fma_blk</a> = fma_blk;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403                 <a class="code" href="gnilnd__conn_8c.html#ad061b2e50cb63b7451493fe03f8194f6">kgnilnd_setup_smsg_attr</a>(smsg_attr);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405                 smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ac65a0d3442a8c737b3464601bfcd6ae8">msg_buffer</a> = fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a7ae72e0428ae5ccfaf1b95740b222e87">gnm_block</a>;
<a name="l00406"></a>00406                 smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#abcf96d2ff15b60290a01b9999a8dd3d2">mbox_offset</a> = fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a> * id;
<a name="l00407"></a>00407                 smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#a52ae43371c31882b123c96b88768aec2">mem_hndl</a> = fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>;
<a name="l00408"></a>00408                 smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ae96753b559daa38acf61cba776c51399">buff_size</a> = fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a10c29e7513392b5c54e1f50a1ee400df">gnm_mbox_size</a>;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410                 <span class="comment">/* We&apos;ll set the hndl to zero for PHYS blocks unmapped during stack</span>
<a name="l00411"></a>00411 <span class="comment">                 * reset and re-use the same fma_blk after stack reset. This ensures we&apos;ve</span>
<a name="l00412"></a>00412 <span class="comment">                 * properly mapped it before we use it */</span>
<a name="l00413"></a>00413                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#ab879a822d025628dfa78c0671a64ecf8">qword1</a> != 0UL, <span class="stringliteral">&quot;unmapped fma_blk %p, state %d\n&quot;</span>,
<a name="l00414"></a>00414                          fma_blk, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a>);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;conn %p smsg %p fmablk %p &quot;</span>
<a name="l00417"></a>00417                         <span class="stringliteral">&quot;allocating SMSG mbox %d buf %p &quot;</span>
<a name="l00418"></a>00418                         <span class="stringliteral">&quot;offset %u hndl &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;.&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00419"></a>00419                         conn, smsg_attr, fma_blk, <span class="keywordtype">id</span>,
<a name="l00420"></a>00420                         smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ac65a0d3442a8c737b3464601bfcd6ae8">msg_buffer</a>, smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#abcf96d2ff15b60290a01b9999a8dd3d2">mbox_offset</a>,
<a name="l00421"></a>00421                         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#ab879a822d025628dfa78c0671a64ecf8">qword1</a>,
<a name="l00422"></a>00422                         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#a51b2b57c5461fac275e60df0fe6b917a">qword2</a>);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424                 mbox = &amp;fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a4a4b79d2d90189d3d56b9e449644322f">gnm_mbox_info</a>[id];
<a name="l00425"></a>00425                 mbox-&gt;<a class="code" href="structkgn__mbox__info.html#abda9d2e0369ea4d78431ccb0718f4da5">mbx_create_conn_memset</a> = jiffies;
<a name="l00426"></a>00426                 mbox-&gt;<a class="code" href="structkgn__mbox__info.html#ac0dca24fe50fb866ae77512afeb4359e">mbx_nallocs</a>++;
<a name="l00427"></a>00427                 mbox-&gt;<a class="code" href="structkgn__mbox__info.html#ae7760d56b6ebbe72e4fbe511b4c0ab7b">mbx_nallocs_total</a>++;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429                 <span class="comment">/* zero mbox to remove any old data from our last use.</span>
<a name="l00430"></a>00430 <span class="comment">                 * this better be safe, if not our purgatory timers</span>
<a name="l00431"></a>00431 <span class="comment">                 * are too short or a peer really is misbehaving */</span>
<a name="l00432"></a>00432                 memset(smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ac65a0d3442a8c737b3464601bfcd6ae8">msg_buffer</a> + smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#abcf96d2ff15b60290a01b9999a8dd3d2">mbox_offset</a>,
<a name="l00433"></a>00433                        0, smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ae96753b559daa38acf61cba776c51399">buff_size</a>);
<a name="l00434"></a>00434                 <span class="keywordflow">break</span>;
<a name="l00435"></a>00435         }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00438"></a>00438 }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="keywordtype">int</span>
<a name="l00441"></a><a class="code" href="gnilnd__conn_8c.html#a19028b0b14bd8bae5a70d130a5f51b4d">00441</a> <a class="code" href="gnilnd__conn_8c.html#a19028b0b14bd8bae5a70d130a5f51b4d">kgnilnd_setup_mbox</a>(<a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443         <a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a>         *smsg_attr = &amp;conn-&gt;<a class="code" href="structkgn__conn.html#a11d994c672cf491d3935a13e04448879">gnpr_smsg_attr</a>;
<a name="l00444"></a>00444         <span class="keywordtype">int</span>                      err = 0;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446         smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ac65a0d3442a8c737b3464601bfcd6ae8">msg_buffer</a> = NULL;
<a name="l00447"></a>00447         <span class="comment">/* Look for available mbox */</span>
<a name="l00448"></a>00448         <span class="keywordflow">do</span> {
<a name="l00449"></a>00449                 <a class="code" href="gnilnd__conn_8c.html#a02dd3ffb7a7f96e44a1dd0f00a8306ed">kgnilnd_find_free_mbox</a>(conn);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451                 <span class="comment">/* nothing in the existing buffers, make a new one */</span>
<a name="l00452"></a>00452                 <span class="keywordflow">if</span> (smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ac65a0d3442a8c737b3464601bfcd6ae8">msg_buffer</a> == NULL) {
<a name="l00453"></a>00453                         <span class="comment">/* for runtime allocations, we only want vmalloc */</span>
<a name="l00454"></a>00454                         err = <a class="code" href="gnilnd__conn_8c.html#a68821496fbf0cd4bebcbe9cbfbf09413">kgnilnd_alloc_fmablk</a>(conn-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>, 0);
<a name="l00455"></a>00455                         <span class="keywordflow">if</span> (err) {
<a name="l00456"></a>00456                                 <span class="keywordflow">break</span>;
<a name="l00457"></a>00457                         }
<a name="l00458"></a>00458                 }
<a name="l00459"></a>00459         } <span class="keywordflow">while</span> (smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ac65a0d3442a8c737b3464601bfcd6ae8">msg_buffer</a> == NULL);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (err)
<a name="l00462"></a>00462                 <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;couldn&apos;t allocate SMSG mbox for conn %p Error: %d\n&quot;</span>,
<a name="l00463"></a>00463                         conn, err);
<a name="l00464"></a>00464         <span class="keywordflow">return</span> err;
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keywordtype">void</span>
<a name="l00468"></a><a class="code" href="gnilnd__conn_8c.html#a5fb6b4a60b216aa0d5351d323fa5acb8">00468</a> <a class="code" href="gnilnd_8h.html#a5fb6b4a60b216aa0d5351d323fa5acb8">kgnilnd_release_mbox</a>(<a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn, <span class="keywordtype">int</span> purgatory_hold)
<a name="l00469"></a>00469 {
<a name="l00470"></a>00470         <a class="code" href="structkgn__device.html">kgn_device_t</a>           *dev = conn-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>;
<a name="l00471"></a>00471         <a class="code" href="structgni__smsg__attr.html">gni_smsg_attr_t</a>        *smsg_attr = &amp;conn-&gt;<a class="code" href="structkgn__conn.html#a11d994c672cf491d3935a13e04448879">gnpr_smsg_attr</a>;
<a name="l00472"></a>00472         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>     *fma_blk = NULL;
<a name="l00473"></a>00473         <a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>        *mbox = NULL;
<a name="l00474"></a>00474         <span class="keywordtype">int</span>                     found = 0;
<a name="l00475"></a>00475         <span class="keywordtype">int</span>                     id;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         <span class="comment">/* if we failed to setup mbox and now destroying conn */</span>
<a name="l00478"></a>00478         <span class="keywordflow">if</span> (smsg_attr-&gt;<a class="code" href="structgni__smsg__attr.html#ac65a0d3442a8c737b3464601bfcd6ae8">msg_buffer</a> == NULL) {
<a name="l00479"></a>00479                 <span class="keywordflow">return</span>;
<a name="l00480"></a>00480         }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482         <span class="keywordtype">id</span> = conn-&gt;<a class="code" href="structkgn__conn.html#a6170b6853d316b0f0c41a29eee87f10f">gnc_mbox_id</a>;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00485"></a>00485         <span class="comment">/* make sure our conn points at a valid fma_blk</span>
<a name="l00486"></a>00486 <span class="comment">         * We use this instead of a mem block search out of smsg_attr</span>
<a name="l00487"></a>00487 <span class="comment">         * because we could have freed a block for fma_blk #1 but the fma_blk</span>
<a name="l00488"></a>00488 <span class="comment">         * is still in the list for a purgatory hold. This would induce a false</span>
<a name="l00489"></a>00489 <span class="comment">         * match if that same block gets reallocated to fma_blk #2 */</span>
<a name="l00490"></a>00490         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(fma_blk, &amp;dev-&gt;<a class="code" href="structkgn__device.html#a7788b6db1547646b3bc81f8ee2b5670d">gnd_fma_buffs</a>, gnm_bufflist) {
<a name="l00491"></a>00491                 <span class="keywordflow">if</span> (fma_blk == conn-&gt;<a class="code" href="structkgn__conn.html#a44d0c57f674b15422b998eae0227b57a">gnc_fma_blk</a>) {
<a name="l00492"></a>00492                         found = 1;
<a name="l00493"></a>00493                         <span class="keywordflow">break</span>;
<a name="l00494"></a>00494                 }
<a name="l00495"></a>00495         }
<a name="l00496"></a>00496         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(found, <span class="stringliteral">&quot;unable to find conn 0x%p with gnc_fma_blk %p &quot;</span>
<a name="l00497"></a>00497                  <span class="stringliteral">&quot;anywhere in the world\n&quot;</span>, conn, conn-&gt;<a class="code" href="structkgn__conn.html#a44d0c57f674b15422b998eae0227b57a">gnc_fma_blk</a>);
<a name="l00498"></a>00498 
<a name="l00499"></a>00499         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(id &lt; fma_blk-&gt;gnm_num_mboxs,
<a name="l00500"></a>00500                 <span class="stringliteral">&quot;bad id %d max %d\n&quot;</span>,
<a name="l00501"></a>00501                 <span class="keywordtype">id</span>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503         <span class="comment">/* &lt; 0 - was held, now free it</span>
<a name="l00504"></a>00504 <span class="comment">         * == 0 - just free it</span>
<a name="l00505"></a>00505 <span class="comment">         * &gt; 0 - hold it for now */</span>
<a name="l00506"></a>00506         <span class="keywordflow">if</span> (purgatory_hold == 0) {
<a name="l00507"></a>00507                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;conn %p smsg %p fmablk %p freeing SMSG mbox %d &quot;</span>
<a name="l00508"></a>00508                         <span class="stringliteral">&quot;hndl &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;.&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00509"></a>00509                         conn, smsg_attr, fma_blk, <span class="keywordtype">id</span>,
<a name="l00510"></a>00510                         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#ab879a822d025628dfa78c0671a64ecf8">qword1</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#a51b2b57c5461fac275e60df0fe6b917a">qword2</a>);
<a name="l00511"></a>00511                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a>++;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (purgatory_hold &gt; 0) {
<a name="l00514"></a>00514                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;conn %p smsg %p fmablk %p holding SMSG mbox %d &quot;</span>
<a name="l00515"></a>00515                         <span class="stringliteral">&quot;hndl &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;.&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00516"></a>00516                         conn, smsg_attr, fma_blk, <span class="keywordtype">id</span>,
<a name="l00517"></a>00517                         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#ab879a822d025628dfa78c0671a64ecf8">qword1</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#a51b2b57c5461fac275e60df0fe6b917a">qword2</a>);
<a name="l00518"></a>00518 
<a name="l00519"></a>00519                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9c1dd155b9beaae810d5c012235c3e4e">gnm_held_mboxs</a>++;
<a name="l00520"></a>00520                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#ab7d550d2036aa71dc6fc495d2973ca8d">gnm_max_timeout</a> = <a class="code" href="libcfs__private_8h.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#ab7d550d2036aa71dc6fc495d2973ca8d">gnm_max_timeout</a>,
<a name="l00521"></a>00521                                                 conn-&gt;<a class="code" href="structkgn__conn.html#a6f6f71a37891a4697ad9737eed11105e">gnc_timeout</a>);
<a name="l00522"></a>00522         } <span class="keywordflow">else</span> {
<a name="l00523"></a>00523                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;conn %p smsg %p fmablk %p release SMSG mbox %d &quot;</span>
<a name="l00524"></a>00524                         <span class="stringliteral">&quot;hndl &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;.&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00525"></a>00525                         conn, smsg_attr, fma_blk, <span class="keywordtype">id</span>,
<a name="l00526"></a>00526                         fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#ab879a822d025628dfa78c0671a64ecf8">qword1</a>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a09822fd3ada28d5b93898186a9fb7213">gnm_hndl</a>.<a class="code" href="structgni__mem__handle.html#a51b2b57c5461fac275e60df0fe6b917a">qword2</a>);
<a name="l00527"></a>00527 
<a name="l00528"></a>00528                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9c1dd155b9beaae810d5c012235c3e4e">gnm_held_mboxs</a>--;
<a name="l00529"></a>00529                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a>++;
<a name="l00530"></a>00530         }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         <span class="keywordflow">if</span> (purgatory_hold &lt;= 0) {
<a name="l00533"></a>00533                 <span class="comment">/* if kgni is retransmitting, freeing the smsg block before the EP</span>
<a name="l00534"></a>00534 <span class="comment">                 * is destroyed gets messy. Bug 768295. */</span>
<a name="l00535"></a>00535                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(conn-&gt;<a class="code" href="structkgn__conn.html#aed3554ed5385235fb822b8263c7a95b6">gnc_ephandle</a> == NULL,
<a name="l00536"></a>00536                          <span class="stringliteral">&quot;can&apos;t release mbox before EP is nuked. conn 0x%p\n&quot;</span>, conn);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538                 mbox = &amp;fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a4a4b79d2d90189d3d56b9e449644322f">gnm_mbox_info</a>[id];
<a name="l00539"></a>00539                 mbox-&gt;<a class="code" href="structkgn__mbox__info.html#a8518efb274aa4506128906b139a03b09">mbx_release_from_purgatory</a> = jiffies;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541                 <span class="comment">/* clear conn gnc_fmablk if it is gone - this allows us to</span>
<a name="l00542"></a>00542 <span class="comment">                 * not worry about state so much in kgnilnd_destroy_conn</span>
<a name="l00543"></a>00543 <span class="comment">                 * and makes the guaranteed cleanup of the resources easier */</span>
<a name="l00544"></a>00544                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(test_and_clear_bit(<span class="keywordtype">id</span>, fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a79ec5a38cffb295070f70fc48f725c27">gnm_bit_array</a>),
<a name="l00545"></a>00545                         <span class="stringliteral">&quot;conn %p bit %d already cleared in fma_blk %p\n&quot;</span>,
<a name="l00546"></a>00546                          conn, <span class="keywordtype">id</span>, fma_blk);
<a name="l00547"></a>00547                 conn-&gt;<a class="code" href="structkgn__conn.html#a44d0c57f674b15422b998eae0227b57a">gnc_fma_blk</a> = NULL;
<a name="l00548"></a>00548                 mbox-&gt;<a class="code" href="structkgn__mbox__info.html#ac0dca24fe50fb866ae77512afeb4359e">mbx_nallocs</a>--;
<a name="l00549"></a>00549         }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#ac41376151b63f46cd18d0e04777022fd">CFS_FAIL_GNI_FMABLK_AVAIL</a>)) {
<a name="l00552"></a>00552                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;LBUGs in your future: forcibly marking fma_blk %p &quot;</span>
<a name="l00553"></a>00553                        <span class="stringliteral">&quot;as mapped\n&quot;</span>, fma_blk);
<a name="l00554"></a>00554                 fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> = <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0fea1ccd4e5861d4867649a79b03f8e2138c">GNILND_FMABLK_VIRT</a>;
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         <span class="comment">/* we don&apos;t release or unmap PHYS blocks as part of the normal cycle --</span>
<a name="l00558"></a>00558 <span class="comment">         * those are controlled manually from startup/shutdown */</span>
<a name="l00559"></a>00559         <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> != <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>) {
<a name="l00560"></a>00560                 <span class="comment">/* we can unmap once all are unused (held or avail)</span>
<a name="l00561"></a>00561 <span class="comment">                 * but check hold_timeout to make sure we are not trying to double</span>
<a name="l00562"></a>00562 <span class="comment">                 * unmap this buffer. If there was no hold_timeout set due to</span>
<a name="l00563"></a>00563 <span class="comment">                 * held_mboxs, we&apos;ll free the mobx here shortly and won&apos;t have to</span>
<a name="l00564"></a>00564 <span class="comment">                 * worry about catching a double free for a &apos;clean&apos; fma_blk */</span>
<a name="l00565"></a>00565                 <span class="keywordflow">if</span> (((fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a> + fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9c1dd155b9beaae810d5c012235c3e4e">gnm_held_mboxs</a>) == fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>) &amp;&amp;
<a name="l00566"></a>00566                     (!fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a887e7562a9972a1759c2bd091e817c8a">gnm_hold_timeout</a>)) {
<a name="l00567"></a>00567                         <a class="code" href="gnilnd__conn_8c.html#abc08557ff8c365cc1bde6bb0e283a44c">kgnilnd_unmap_fmablk</a>(dev, fma_blk);
<a name="l00568"></a>00568                 }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570                 <span class="comment">/* But we can only free once they are all avail */</span>
<a name="l00571"></a>00571                 <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#aa4864ee1cee075485c209ed202b177ac">gnm_avail_mboxs</a> == fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a> &amp;&amp;
<a name="l00572"></a>00572                     fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a9c1dd155b9beaae810d5c012235c3e4e">gnm_held_mboxs</a> == 0) {
<a name="l00573"></a>00573                         <span class="comment">/* all mailboxes are released, free fma_blk */</span>
<a name="l00574"></a>00574                         <a class="code" href="gnilnd__conn_8c.html#af26a6bc416a851ddadab8556f14143c7">kgnilnd_free_fmablk_locked</a>(dev, fma_blk);
<a name="l00575"></a>00575                 }
<a name="l00576"></a>00576         }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00579"></a>00579 }
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="keywordtype">int</span>
<a name="l00582"></a><a class="code" href="gnilnd__conn_8c.html#a8a4e2b4d12c6e97356887791f596795d">00582</a> <a class="code" href="gnilnd__conn_8c.html#a8a4e2b4d12c6e97356887791f596795d">kgnilnd_count_phys_mbox</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00583"></a>00583 {
<a name="l00584"></a>00584         <span class="keywordtype">int</span>                     i = 0;
<a name="l00585"></a>00585         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>     *fma_blk;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587         spin_lock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(fma_blk, &amp;device-&gt;<a class="code" href="structkgn__device.html#a7788b6db1547646b3bc81f8ee2b5670d">gnd_fma_buffs</a>, gnm_bufflist) {
<a name="l00590"></a>00590                 <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> == <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>)
<a name="l00591"></a>00591                         i += fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a446914981e6f7893babbe183a8882220">gnm_num_mboxs</a>;
<a name="l00592"></a>00592         }
<a name="l00593"></a>00593         spin_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(i);
<a name="l00596"></a>00596 }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="keywordtype">int</span>
<a name="l00599"></a><a class="code" href="gnilnd__conn_8c.html#ab7bdf5deae46f8af78130a4297b6b03b">00599</a> <a class="code" href="gnilnd_8h.html#ab7bdf5deae46f8af78130a4297b6b03b">kgnilnd_allocate_phys_fmablk</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601         <span class="keywordtype">int</span>     rc;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603         <span class="keywordflow">while</span> (<a class="code" href="gnilnd__conn_8c.html#a8a4e2b4d12c6e97356887791f596795d">kgnilnd_count_phys_mbox</a>(device) &lt; *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#aa845e81ea7b75f2a8748d96761a274cf">kgn_nphys_mbox</a>) {
<a name="l00604"></a>00604 
<a name="l00605"></a>00605                 rc = <a class="code" href="gnilnd__conn_8c.html#a68821496fbf0cd4bebcbe9cbfbf09413">kgnilnd_alloc_fmablk</a>(device, 1);
<a name="l00606"></a>00606                 <span class="keywordflow">if</span> (rc) {
<a name="l00607"></a>00607                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed phys mbox allocation, stopping at %d, rc %d\n&quot;</span>,
<a name="l00608"></a>00608                                 <a class="code" href="gnilnd__conn_8c.html#a8a4e2b4d12c6e97356887791f596795d">kgnilnd_count_phys_mbox</a>(device), rc);
<a name="l00609"></a>00609                         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00610"></a>00610                 }
<a name="l00611"></a>00611         }
<a name="l00612"></a>00612         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00613"></a>00613 }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="keywordtype">int</span>
<a name="l00616"></a><a class="code" href="gnilnd__conn_8c.html#ac9720b771159e503a066d32d87914e0e">00616</a> <a class="code" href="gnilnd_8h.html#ac9720b771159e503a066d32d87914e0e">kgnilnd_map_phys_fmablk</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00617"></a>00617 {
<a name="l00618"></a>00618 
<a name="l00619"></a>00619         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00620"></a>00620         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>     *fma_blk;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622         <span class="comment">/* use mutex to gate access to single thread, just in case */</span>
<a name="l00623"></a>00623         mutex_lock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00624"></a>00624 
<a name="l00625"></a>00625         spin_lock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00626"></a>00626 
<a name="l00627"></a>00627         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(fma_blk, &amp;device-&gt;<a class="code" href="structkgn__device.html#a7788b6db1547646b3bc81f8ee2b5670d">gnd_fma_buffs</a>, gnm_bufflist) {
<a name="l00628"></a>00628                 <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> == <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>) {
<a name="l00629"></a>00629                         rc = <a class="code" href="gnilnd__conn_8c.html#ae1cb1d8c4f08c31ddaac9acd13a97dff">kgnilnd_map_fmablk</a>(device, fma_blk);
<a name="l00630"></a>00630                         <span class="keywordflow">if</span> (rc)
<a name="l00631"></a>00631                                 <span class="keywordflow">break</span>;
<a name="l00632"></a>00632                 }
<a name="l00633"></a>00633         }
<a name="l00634"></a>00634         spin_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         mutex_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00639"></a>00639 }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 <span class="keywordtype">void</span>
<a name="l00642"></a><a class="code" href="gnilnd__conn_8c.html#a093daa4c438c7886400c0fd14c8b86e9">00642</a> <a class="code" href="gnilnd_8h.html#a093daa4c438c7886400c0fd14c8b86e9">kgnilnd_unmap_fma_blocks</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00643"></a>00643 {
<a name="l00644"></a>00644 
<a name="l00645"></a>00645         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>      *fma_blk;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647         <span class="comment">/* use mutex to gate access to single thread, just in case */</span>
<a name="l00648"></a>00648         mutex_lock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         spin_lock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00651"></a>00651 
<a name="l00652"></a>00652         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(fma_blk, &amp;device-&gt;<a class="code" href="structkgn__device.html#a7788b6db1547646b3bc81f8ee2b5670d">gnd_fma_buffs</a>, gnm_bufflist) {
<a name="l00653"></a>00653                 <a class="code" href="gnilnd__conn_8c.html#abc08557ff8c365cc1bde6bb0e283a44c">kgnilnd_unmap_fmablk</a>(device, fma_blk);
<a name="l00654"></a>00654         }
<a name="l00655"></a>00655         spin_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         mutex_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00658"></a>00658 }
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="keywordtype">void</span>
<a name="l00661"></a><a class="code" href="gnilnd__conn_8c.html#ad9648ed7367761195557c1a0ffe67008">00661</a> <a class="code" href="gnilnd_8h.html#ad9648ed7367761195557c1a0ffe67008">kgnilnd_free_phys_fmablk</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *device)
<a name="l00662"></a>00662 {
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         <a class="code" href="structkgn__fma__memblock.html">kgn_fma_memblock_t</a>      *fma_blk, *fma_blkN;
<a name="l00665"></a>00665 
<a name="l00666"></a>00666         <span class="comment">/* use mutex to gate access to single thread, just in case */</span>
<a name="l00667"></a>00667         mutex_lock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669         spin_lock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671         <a class="code" href="list_8h.html#ac3f72d6bd5144c7970824813810d2da1" title="Iterate over a list of given type safe against removal of list entry.">list_for_each_entry_safe</a>(fma_blk, fma_blkN, &amp;device-&gt;<a class="code" href="structkgn__device.html#a7788b6db1547646b3bc81f8ee2b5670d">gnd_fma_buffs</a>, gnm_bufflist) {
<a name="l00672"></a>00672                 <span class="keywordflow">if</span> (fma_blk-&gt;<a class="code" href="structkgn__fma__memblock.html#a27d31da05d1397e7b6d476001771d1e6">gnm_state</a> == <a class="code" href="gnilnd_8h.html#a6cbe51af58c314ee8bf57c742f0fa0feae54ea6b5582446ab5dc58dd336f88473">GNILND_FMABLK_PHYS</a>)
<a name="l00673"></a>00673                         <a class="code" href="gnilnd__conn_8c.html#af26a6bc416a851ddadab8556f14143c7">kgnilnd_free_fmablk_locked</a>(device, fma_blk);
<a name="l00674"></a>00674         }
<a name="l00675"></a>00675         spin_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#af33dc1d2c1cc543c27a3d9b57d1210e4">gnd_fmablk_lock</a>);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677         mutex_unlock(&amp;device-&gt;<a class="code" href="structkgn__device.html#a0b19dc0f01341e16cf1e9c2f2e6ac4c4">gnd_fmablk_mutex</a>);
<a name="l00678"></a>00678 }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 <span class="comment">/* kgnilnd dgram nid-&gt;struct managment */</span>
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *
<a name="l00683"></a><a class="code" href="gnilnd__conn_8c.html#a40261f1a59add37cd0dd1bcc783cbc2a">00683</a> <a class="code" href="gnilnd__conn_8c.html#a40261f1a59add37cd0dd1bcc783cbc2a">kgnilnd_nid2dgramlist</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid)
<a name="l00684"></a>00684 {
<a name="l00685"></a>00685         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = ((<span class="keywordtype">unsigned</span> int)nid) % *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#acc193b5b5171465a5a45ec26665c4c63">kgn_peer_hash_size</a>;
<a name="l00686"></a>00686 
<a name="l00687"></a>00687         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad0a7f62b9d3c4fb47b0e8994aebe3757">gnd_dgrams</a>[hash]);
<a name="l00688"></a>00688 }
<a name="l00689"></a>00689 
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="comment">/* needs dev-&gt;gnd_dgram_lock held */</span>
<a name="l00692"></a>00692 <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *
<a name="l00693"></a><a class="code" href="gnilnd__conn_8c.html#a32639710499349b942de623184d7e84d">00693</a> <a class="code" href="gnilnd__conn_8c.html#a32639710499349b942de623184d7e84d">kgnilnd_find_dgram_locked</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dst_nid)
<a name="l00694"></a>00694 {
<a name="l00695"></a>00695         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *dgram_list = <a class="code" href="gnilnd__conn_8c.html#a40261f1a59add37cd0dd1bcc783cbc2a">kgnilnd_nid2dgramlist</a>(dev, dst_nid);
<a name="l00696"></a>00696         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>      *dgram;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(dgram, dgram_list, gndg_list) {
<a name="l00699"></a>00699 
<a name="l00700"></a>00700                 <span class="comment">/* if state &gt; POSTED, we are already handling cancel/completion */</span>
<a name="l00701"></a>00701                 <span class="keywordflow">if</span> ((dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a> != dst_nid) ||
<a name="l00702"></a>00702                      dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> &gt; <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a16f6b012f4ea48a0a117372ddebbae18">GNILND_DGRAM_POSTED</a>)
<a name="l00703"></a>00703                         <span class="keywordflow">continue</span>;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;got dgram [%p] -&gt; %s\n&quot;</span>,
<a name="l00706"></a>00706                        dgram, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dst_nid));
<a name="l00707"></a>00707                 <span class="keywordflow">return</span> dgram;
<a name="l00708"></a>00708         }
<a name="l00709"></a>00709         <span class="keywordflow">return</span> NULL;
<a name="l00710"></a>00710 }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <span class="keywordtype">int</span>
<a name="l00713"></a><a class="code" href="gnilnd__conn_8c.html#a77d59ddd3a555acd5a63439fc7ebe121">00713</a> <a class="code" href="gnilnd_8h.html#a77d59ddd3a555acd5a63439fc7ebe121">kgnilnd_find_and_cancel_dgram</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dst_nid)
<a name="l00714"></a>00714 {
<a name="l00715"></a>00715         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>     *dgram;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l00718"></a>00718         dgram = <a class="code" href="gnilnd__conn_8c.html#a32639710499349b942de623184d7e84d">kgnilnd_find_dgram_locked</a>(dev, dst_nid);
<a name="l00719"></a>00719 
<a name="l00720"></a>00720         <span class="keywordflow">if</span> (dgram) {
<a name="l00721"></a>00721                 <a class="code" href="gnilnd_8h.html#af0bc27af31ab08277023dded0673771f">kgnilnd_cancel_dgram_locked</a>(dgram);
<a name="l00722"></a>00722         }
<a name="l00723"></a>00723         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(!!(dgram == NULL));
<a name="l00726"></a>00726 }
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 <span class="keywordtype">int</span>
<a name="l00729"></a><a class="code" href="gnilnd__conn_8c.html#ab5b00b1c52fa1a460ac6930708f8e23b">00729</a> <a class="code" href="gnilnd__conn_8c.html#ab5b00b1c52fa1a460ac6930708f8e23b">kgnilnd_pack_connreq</a>(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a> *connreq, <a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn,
<a name="l00730"></a>00730                      <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> srcnid, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dstnid,
<a name="l00731"></a>00731                      <a class="code" href="gnilnd_8h.html#ad9e9bf7209c754ba088533226ac5ab78">kgn_connreq_type_t</a> type)
<a name="l00732"></a>00732 {
<a name="l00733"></a>00733         <span class="keywordtype">int</span> err = 0;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         <span class="comment">/* ensure we haven&apos;t violated max datagram size */</span>
<a name="l00736"></a>00736         <a class="code" href="osd__iam_8h.html#accba6d34cf012c360c3ad61f87373778">CLASSERT</a>(<span class="keyword">sizeof</span>(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>) &lt;= <a class="code" href="gni__pub_8h.html#a643f499ba78fb747d41bd4833c89a615">GNI_DATAGRAM_MAXSIZE</a>);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         <span class="comment">/* no need to zero out, we do that when allocating dgram */</span>
<a name="l00739"></a>00739         connreq-&gt;<a class="code" href="structkgn__connreq.html#a339aeb3890e335d460f3cd27e893b270">gncr_magic</a>     = <a class="code" href="gnilnd_8h.html#a81aeaea3994bb532cf7a1a5a9c9c5670">GNILND_MSG_MAGIC</a>;
<a name="l00740"></a>00740 
<a name="l00741"></a>00741         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a94dfd37c8d7bbb24b5d51324e4008306">CFS_FAIL_GNI_PACK_SRCNID</a>)) {
<a name="l00742"></a>00742                 srcnid = 0xABADBABE;
<a name="l00743"></a>00743         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a44fc0ae02b6df1b0e0a878e357eeff16">CFS_FAIL_GNI_PACK_DSTNID</a>)) {
<a name="l00744"></a>00744                 dstnid = 0xDEFEC8ED;
<a name="l00745"></a>00745         }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>    = srcnid;
<a name="l00748"></a>00748         connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>    = dstnid;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a9e5d664f917201f761101097124f8e14">CFS_FAIL_GNI_CONNREQ_PROTO</a>)) {
<a name="l00751"></a>00751                 connreq-&gt;<a class="code" href="structkgn__connreq.html#ad381c498d8c33fc45f227228d8513968">gncr_version</a> = 99;
<a name="l00752"></a>00752         } <span class="keywordflow">else</span> {
<a name="l00753"></a>00753                 connreq-&gt;<a class="code" href="structkgn__connreq.html#ad381c498d8c33fc45f227228d8513968">gncr_version</a>   = <a class="code" href="gnilnd_8h.html#abd9e13d97334b10c2b2026dfd4c75e94">GNILND_CONNREQ_VERSION</a>;
<a name="l00754"></a>00754         }
<a name="l00755"></a>00755         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a9e5d664f917201f761101097124f8e14">CFS_FAIL_GNI_CONNREQ_PROTO</a>)) {
<a name="l00756"></a>00756                 connreq-&gt;<a class="code" href="structkgn__connreq.html#a3f5e7b13bcf2d9713f74a9a1b9826ee6">gncr_type</a> = 99;
<a name="l00757"></a>00757         } <span class="keywordflow">else</span> {
<a name="l00758"></a>00758                 connreq-&gt;<a class="code" href="structkgn__connreq.html#a3f5e7b13bcf2d9713f74a9a1b9826ee6">gncr_type</a>      = type;
<a name="l00759"></a>00759         }
<a name="l00760"></a>00760         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a9e5d664f917201f761101097124f8e14">CFS_FAIL_GNI_CONNREQ_PROTO</a>)) {
<a name="l00761"></a>00761                 connreq-&gt;<a class="code" href="structkgn__connreq.html#a3376a452a7080b8be6d9d358dd846d55">gncr_peerstamp</a> = 0;
<a name="l00762"></a>00762         } <span class="keywordflow">else</span> {
<a name="l00763"></a>00763                 connreq-&gt;<a class="code" href="structkgn__connreq.html#a3376a452a7080b8be6d9d358dd846d55">gncr_peerstamp</a> = <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a7b7f4499ed006d7bf1025e8e3898a859">kgn_peerstamp</a>;
<a name="l00764"></a>00764         }
<a name="l00765"></a>00765         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a9e5d664f917201f761101097124f8e14">CFS_FAIL_GNI_CONNREQ_PROTO</a>)) {
<a name="l00766"></a>00766                 connreq-&gt;<a class="code" href="structkgn__connreq.html#a68e94324894ead083cc6f2a2492475dd">gncr_connstamp</a> = 0;
<a name="l00767"></a>00767         } <span class="keywordflow">else</span> {
<a name="l00768"></a>00768                 connreq-&gt;<a class="code" href="structkgn__connreq.html#a68e94324894ead083cc6f2a2492475dd">gncr_connstamp</a> = conn-&gt;<a class="code" href="structkgn__conn.html#a462ce2a0b3fc489c4822a43245dc27c2">gnc_my_connstamp</a>;
<a name="l00769"></a>00769         }
<a name="l00770"></a>00770         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a9e5d664f917201f761101097124f8e14">CFS_FAIL_GNI_CONNREQ_PROTO</a>)) {
<a name="l00771"></a>00771                 connreq-&gt;<a class="code" href="structkgn__connreq.html#ada7e02ee44699928ab4b98350cf1dac1">gncr_timeout</a> = 0;
<a name="l00772"></a>00772         } <span class="keywordflow">else</span> {
<a name="l00773"></a>00773                 connreq-&gt;<a class="code" href="structkgn__connreq.html#ada7e02ee44699928ab4b98350cf1dac1">gncr_timeout</a>   = conn-&gt;<a class="code" href="structkgn__conn.html#a6f6f71a37891a4697ad9737eed11105e">gnc_timeout</a>;
<a name="l00774"></a>00774         }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         <span class="comment">/* the rest pack the data into the payload in other places */</span>
<a name="l00777"></a>00777         <span class="keywordflow">if</span> (type == <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a48dd218ba2da7bccf230d76dad5a5b41">GNILND_CONNREQ_REQ</a>) {
<a name="l00778"></a>00778                 <a class="code" href="structkgn__gniparams.html">kgn_gniparams_t</a>       *req_params = &amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>;
<a name="l00779"></a>00779                 req_params-&gt;<a class="code" href="structkgn__gniparams.html#a0ee580d49e912f8a2c954093a8bf0522">gnpr_host_id</a> = conn-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>-&gt;<a class="code" href="structkgn__device.html#a1166a48e70b8f64c768135dc8cab3593">gnd_host_id</a>;
<a name="l00780"></a>00780                 req_params-&gt;<a class="code" href="structkgn__gniparams.html#a91eb2e51396913ea524606af7640fd40">gnpr_cqid</a> = conn-&gt;<a class="code" href="structkgn__conn.html#a5ffc6d67b964fa813a576abcd3a7138f">gnc_cqid</a>;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782                 <span class="comment">/* allocate mailbox for this connection */</span>
<a name="l00783"></a>00783                 err = <a class="code" href="gnilnd__conn_8c.html#a19028b0b14bd8bae5a70d130a5f51b4d">kgnilnd_setup_mbox</a>(conn);
<a name="l00784"></a>00784                 <span class="keywordflow">if</span> (err != 0) {
<a name="l00785"></a>00785                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Failed to setup FMA mailbox (%d)\n&quot;</span>, err);
<a name="l00786"></a>00786                 }
<a name="l00787"></a>00787                 req_params-&gt;<a class="code" href="structkgn__gniparams.html#ac546a52c7366da4fdbb9de98394c46b9">gnpr_smsg_attr</a> = conn-&gt;<a class="code" href="structkgn__conn.html#a11d994c672cf491d3935a13e04448879">gnpr_smsg_attr</a>;
<a name="l00788"></a>00788         }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790         <span class="comment">/* XXX Nic: TBD - checksum computation */</span>
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         <span class="keywordflow">return</span> err;
<a name="l00793"></a>00793 }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795 <span class="keywordtype">int</span>
<a name="l00796"></a><a class="code" href="gnilnd__conn_8c.html#a536fe0e2808756e2a3e7ee066409012a">00796</a> <a class="code" href="gnilnd__conn_8c.html#a536fe0e2808756e2a3e7ee066409012a">kgnilnd_unpack_connreq</a>(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l00797"></a>00797 {
<a name="l00798"></a>00798         <a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>           *connreq = &amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>;
<a name="l00799"></a>00799         <span class="keywordtype">int</span>                      swab, rc = 0;
<a name="l00800"></a>00800         <a class="code" href="structkgn__net.html">kgn_net_t</a>               *net;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802         <span class="comment">/* the following fields must be handled in a backwards compatible</span>
<a name="l00803"></a>00803 <span class="comment">         * manner to ensure we can always send and interpret NAKs */</span>
<a name="l00804"></a>00804 
<a name="l00805"></a>00805         <span class="keywordflow">if</span> (connreq-&gt;<a class="code" href="structkgn__connreq.html#a339aeb3890e335d460f3cd27e893b270">gncr_magic</a> != <a class="code" href="gnilnd_8h.html#a81aeaea3994bb532cf7a1a5a9c9c5670">GNILND_MSG_MAGIC</a> &amp;&amp;
<a name="l00806"></a>00806             connreq-&gt;<a class="code" href="structkgn__connreq.html#a339aeb3890e335d460f3cd27e893b270">gncr_magic</a> != <a class="code" href="byteorder_8h.html#a1807284a5e70b16ca7045ee03bcc879d">__swab32</a>(<a class="code" href="gnilnd_8h.html#a81aeaea3994bb532cf7a1a5a9c9c5670">GNILND_MSG_MAGIC</a>)) {
<a name="l00807"></a>00807                 <span class="comment">/* Unexpected magic! */</span>
<a name="l00808"></a>00808                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Unexpected magic %08x\n&quot;</span>,
<a name="l00809"></a>00809                        connreq-&gt;<a class="code" href="structkgn__connreq.html#a339aeb3890e335d460f3cd27e893b270">gncr_magic</a>);
<a name="l00810"></a>00810                 <span class="keywordflow">return</span> -EBADF;
<a name="l00811"></a>00811         }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813         swab = (connreq-&gt;<a class="code" href="structkgn__connreq.html#a339aeb3890e335d460f3cd27e893b270">gncr_magic</a> == <a class="code" href="byteorder_8h.html#a1807284a5e70b16ca7045ee03bcc879d">__swab32</a>(<a class="code" href="gnilnd_8h.html#a81aeaea3994bb532cf7a1a5a9c9c5670">GNILND_MSG_MAGIC</a>));
<a name="l00814"></a>00814         <span class="keywordflow">if</span> (swab) {
<a name="l00815"></a>00815                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#a339aeb3890e335d460f3cd27e893b270">gncr_magic</a>);
<a name="l00816"></a>00816                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#a83097cb9d5827df7bfd7ea897a26ce56">gncr_cksum</a>);
<a name="l00817"></a>00817                 <a class="code" href="byteorder_8h.html#a921c43a174aafeb42ce2b474dc1bf797">__swab16s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#a3f5e7b13bcf2d9713f74a9a1b9826ee6">gncr_type</a>);
<a name="l00818"></a>00818                 <a class="code" href="byteorder_8h.html#a921c43a174aafeb42ce2b474dc1bf797">__swab16s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ad381c498d8c33fc45f227228d8513968">gncr_version</a>);
<a name="l00819"></a>00819                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ada7e02ee44699928ab4b98350cf1dac1">gncr_timeout</a>);
<a name="l00820"></a>00820                 <a class="code" href="byteorder_8h.html#a8eb48d492d4a496c21c628372e40902a">__swab64s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>);
<a name="l00821"></a>00821                 <a class="code" href="byteorder_8h.html#a8eb48d492d4a496c21c628372e40902a">__swab64s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>);
<a name="l00822"></a>00822                 <a class="code" href="byteorder_8h.html#a8eb48d492d4a496c21c628372e40902a">__swab64s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#a3376a452a7080b8be6d9d358dd846d55">gncr_peerstamp</a>);
<a name="l00823"></a>00823                 <a class="code" href="byteorder_8h.html#a8eb48d492d4a496c21c628372e40902a">__swab64s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#a68e94324894ead083cc6f2a2492475dd">gncr_connstamp</a>);
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826         <span class="comment">/* Do NOT return anything but -EBADF before we munge</span>
<a name="l00827"></a>00827 <span class="comment">         * connreq-&gt;gncr_srcnid - we need that to send the nak */</span>
<a name="l00828"></a>00828 
<a name="l00829"></a>00829         <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a> != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l00830"></a>00830                 <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>      incoming = connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832                 <span class="comment">/* even if the incoming packet is hosed, we know who we sent</span>
<a name="l00833"></a>00833 <span class="comment">                 * the original and can set the srcnid so that we can properly</span>
<a name="l00834"></a>00834 <span class="comment">                 * look up our peer to close the loop on this connreq. We still use</span>
<a name="l00835"></a>00835 <span class="comment">                 * -EBADF to prevent a NAK - just in case there are issues with</span>
<a name="l00836"></a>00836 <span class="comment">                 * the payload coming from a random spot, etc. */</span>
<a name="l00837"></a>00837                 connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a> = dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>;
<a name="l00838"></a>00838 
<a name="l00839"></a>00839                 <span class="keywordflow">if</span> (<a class="code" href="group__lnet__addr.html#ga692b6a866269a35490f2e2803cc2e5d6" title="extract the address part of an lnet_nid_t">LNET_NIDADDR</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>) !=
<a name="l00840"></a>00840                                 <a class="code" href="group__lnet__addr.html#ga692b6a866269a35490f2e2803cc2e5d6" title="extract the address part of an lnet_nid_t">LNET_NIDADDR</a>(incoming)) {
<a name="l00841"></a>00841                         <span class="comment">/* we got a datagram match for the wrong nid... */</span>
<a name="l00842"></a>00842                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;matched datagram 0x%p with srcnid %s &quot;</span>
<a name="l00843"></a>00843                                 <span class="stringliteral">&quot;(%x), expecting %s (%x)\n&quot;</span>,
<a name="l00844"></a>00844                                 dgram,
<a name="l00845"></a>00845                                 <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(incoming),
<a name="l00846"></a>00846                                 <a class="code" href="group__lnet__addr.html#ga692b6a866269a35490f2e2803cc2e5d6" title="extract the address part of an lnet_nid_t">LNET_NIDADDR</a>(incoming),
<a name="l00847"></a>00847                                 <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>),
<a name="l00848"></a>00848                                 <a class="code" href="group__lnet__addr.html#ga692b6a866269a35490f2e2803cc2e5d6" title="extract the address part of an lnet_nid_t">LNET_NIDADDR</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>));
<a name="l00849"></a>00849                         <span class="keywordflow">return</span> -EBADF;
<a name="l00850"></a>00850                 }
<a name="l00851"></a>00851         } <span class="keywordflow">else</span> {
<a name="l00852"></a>00852                 <span class="comment">/* if we have a wildcard datagram it should match an</span>
<a name="l00853"></a>00853 <span class="comment">                 * incoming &quot;active&quot; datagram that should have a fully formed</span>
<a name="l00854"></a>00854 <span class="comment">                 * srcnid and dstnid. If we couldn&apos;t unpack it, we drop as</span>
<a name="l00855"></a>00855 <span class="comment">                 * corrupted packet, otherwise we&apos;ll just verify that the dstnid</span>
<a name="l00856"></a>00856 <span class="comment">                 * matches the NID for the NET that the dgram was posted */</span>
<a name="l00857"></a>00857 
<a name="l00858"></a>00858                 <span class="comment">/* make sure their wildcard didn&apos;t match ours, that is unpossible */</span>
<a name="l00859"></a>00859                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a> != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>,
<a name="l00860"></a>00860                          <span class="stringliteral">&quot;dgram 0x%p from %s, connreq 0x%p; &quot;</span>
<a name="l00861"></a>00861                          <span class="stringliteral">&quot;wildcard matched wildcard \n&quot;</span>, dgram,
<a name="l00862"></a>00862                          <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>), connreq);
<a name="l00863"></a>00863 
<a name="l00864"></a>00864                 rc = <a class="code" href="gnilnd_8h.html#aa82f2f433c0c2b89229eda2e94c9aeb6">kgnilnd_find_net</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>, &amp;net);
<a name="l00865"></a>00865 
<a name="l00866"></a>00866                 <span class="keywordflow">if</span> (rc == -ESHUTDOWN) {
<a name="l00867"></a>00867                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Looking up network: device is in shutdown&quot;</span>);
<a name="l00868"></a>00868                         <span class="keywordflow">return</span> rc;
<a name="l00869"></a>00869                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == -ENONET) {
<a name="l00870"></a>00870                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Connection data from %s: she sent &quot;</span>
<a name="l00871"></a>00871                         <span class="stringliteral">&quot;dst_nid %s, but net lookup failed on &quot;</span>
<a name="l00872"></a>00872                         <span class="stringliteral">&quot;dgram 0x%p@%s\n&quot;</span>,
<a name="l00873"></a>00873                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>),
<a name="l00874"></a>00874                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>),
<a name="l00875"></a>00875                         dgram, <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram));
<a name="l00876"></a>00876                         <span class="keywordflow">return</span> rc;
<a name="l00877"></a>00877                 }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879                 <span class="keywordflow">if</span> (net-&gt;<a class="code" href="structkgn__net.html#ae1eebd7c97c508cd6215923dc828585b">gnn_ni</a>-&gt;<a class="code" href="structlnet__ni.html#a3220978c27f9626e971d2537a167795d">ni_nid</a> != connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>) {
<a name="l00880"></a>00880                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Bad connection data from %s: she sent &quot;</span>
<a name="l00881"></a>00881                                <span class="stringliteral">&quot;dst_nid %s, but I am %s with dgram 0x%p@%s\n&quot;</span>,
<a name="l00882"></a>00882                                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>),
<a name="l00883"></a>00883                                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>),
<a name="l00884"></a>00884                                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(net-&gt;<a class="code" href="structkgn__net.html#ae1eebd7c97c508cd6215923dc828585b">gnn_ni</a>-&gt;<a class="code" href="structlnet__ni.html#a3220978c27f9626e971d2537a167795d">ni_nid</a>),
<a name="l00885"></a>00885                                dgram, <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram));
<a name="l00886"></a>00886                         <a class="code" href="gnilnd_8h.html#ac2fa4e6785ec2b30de4dc241a23ca24f">kgnilnd_net_decref</a>(net);
<a name="l00887"></a>00887                         <span class="keywordflow">return</span> -EBADSLT;
<a name="l00888"></a>00888                 }
<a name="l00889"></a>00889 
<a name="l00890"></a>00890                 <span class="comment">/* kgnilnd_find_net takes a ref on the net it finds, You need to decref it when not needed. */</span>
<a name="l00891"></a>00891                 <a class="code" href="gnilnd_8h.html#ac2fa4e6785ec2b30de4dc241a23ca24f">kgnilnd_net_decref</a>(net);
<a name="l00892"></a>00892         }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         <span class="keywordflow">if</span> (connreq-&gt;<a class="code" href="structkgn__connreq.html#ad381c498d8c33fc45f227228d8513968">gncr_version</a> != <a class="code" href="gnilnd_8h.html#abd9e13d97334b10c2b2026dfd4c75e94">GNILND_CONNREQ_VERSION</a>) {
<a name="l00895"></a>00895                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Unexpected version %d\n&quot;</span>, connreq-&gt;<a class="code" href="structkgn__connreq.html#ad381c498d8c33fc45f227228d8513968">gncr_version</a>);
<a name="l00896"></a>00896                 <span class="keywordflow">return</span> -EPROTO;
<a name="l00897"></a>00897         }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899         <span class="comment">/* XXX Nic: TBD - checksum validation */</span>
<a name="l00900"></a>00900         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a9db9f365af1560d782e6180a6265c0fc">CFS_FAIL_GNI_CONNREQ_DROP</a>)) {
<a name="l00901"></a>00901                 <span class="keywordflow">return</span> -EBADF;
<a name="l00902"></a>00902         }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904         <span class="keywordflow">if</span> (swab &amp;&amp; connreq-&gt;<a class="code" href="structkgn__connreq.html#a3f5e7b13bcf2d9713f74a9a1b9826ee6">gncr_type</a> == <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a48dd218ba2da7bccf230d76dad5a5b41">GNILND_CONNREQ_REQ</a>) {
<a name="l00905"></a>00905                 <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> msg_addr = (<a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>) connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#ac546a52c7366da4fdbb9de98394c46b9">gnpr_smsg_attr</a>.<a class="code" href="structgni__smsg__attr.html#ac65a0d3442a8c737b3464601bfcd6ae8">msg_buffer</a>;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#a0ee580d49e912f8a2c954093a8bf0522">gnpr_host_id</a>);
<a name="l00908"></a>00908                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#a91eb2e51396913ea524606af7640fd40">gnpr_cqid</a>);
<a name="l00909"></a>00909                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#ac546a52c7366da4fdbb9de98394c46b9">gnpr_smsg_attr</a>.<a class="code" href="structgni__smsg__attr.html#ae96753b559daa38acf61cba776c51399">buff_size</a>);
<a name="l00910"></a>00910                 <a class="code" href="byteorder_8h.html#a921c43a174aafeb42ce2b474dc1bf797">__swab16s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#ac546a52c7366da4fdbb9de98394c46b9">gnpr_smsg_attr</a>.<a class="code" href="structgni__smsg__attr.html#a886a3dbdabf3b1c984410eb4023d346f">mbox_maxcredit</a>);
<a name="l00911"></a>00911                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#ac546a52c7366da4fdbb9de98394c46b9">gnpr_smsg_attr</a>.<a class="code" href="structgni__smsg__attr.html#abcf96d2ff15b60290a01b9999a8dd3d2">mbox_offset</a>);
<a name="l00912"></a>00912                 <a class="code" href="byteorder_8h.html#a8eb48d492d4a496c21c628372e40902a">__swab64s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#ac546a52c7366da4fdbb9de98394c46b9">gnpr_smsg_attr</a>.<a class="code" href="structgni__smsg__attr.html#a52ae43371c31882b123c96b88768aec2">mem_hndl</a>.<a class="code" href="structgni__mem__handle.html#ab879a822d025628dfa78c0671a64ecf8">qword1</a>);
<a name="l00913"></a>00913                 <a class="code" href="byteorder_8h.html#a8eb48d492d4a496c21c628372e40902a">__swab64s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#ac546a52c7366da4fdbb9de98394c46b9">gnpr_smsg_attr</a>.<a class="code" href="structgni__smsg__attr.html#a52ae43371c31882b123c96b88768aec2">mem_hndl</a>.<a class="code" href="structgni__mem__handle.html#a51b2b57c5461fac275e60df0fe6b917a">qword2</a>);
<a name="l00914"></a>00914                 <a class="code" href="byteorder_8h.html#a8eb48d492d4a496c21c628372e40902a">__swab64s</a>(&amp;msg_addr);
<a name="l00915"></a>00915                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#ac546a52c7366da4fdbb9de98394c46b9">gnpr_smsg_attr</a>.<a class="code" href="structgni__smsg__attr.html#ad2856348d4b3b2f5287537ffa97503fc">msg_maxsize</a>);
<a name="l00916"></a>00916                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#ae293e6a38adb3452f04d3312eb3c1fc4">gncr_gnparams</a>.<a class="code" href="structkgn__gniparams.html#ac546a52c7366da4fdbb9de98394c46b9">gnpr_smsg_attr</a>.<a class="code" href="structgni__smsg__attr.html#a3b26680b65203d00681c08a9abfef14a">msg_type</a>);
<a name="l00917"></a>00917         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (swab &amp;&amp; connreq-&gt;<a class="code" href="structkgn__connreq.html#a3f5e7b13bcf2d9713f74a9a1b9826ee6">gncr_type</a> == <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a94d5a8f2d421f134365d87243edfed68">GNILND_CONNREQ_NAK</a>) {
<a name="l00918"></a>00918                 <a class="code" href="byteorder_8h.html#ab9cd632aa0194b301cae9e8dbc210718">__swab32s</a>(&amp;connreq-&gt;<a class="code" href="structkgn__connreq.html#a60aca351f9aeb0506874026d3986e1e6">gncr_nakdata</a>.<a class="code" href="structkgn__nak__data.html#ab642014e904809eb127f35c63b981c70">gnnd_errno</a>);
<a name="l00919"></a>00919         }
<a name="l00920"></a>00920 
<a name="l00921"></a>00921         <span class="comment">/* since we use a unique instance ID for each network, the driver</span>
<a name="l00922"></a>00922 <span class="comment">         * will take care of dropping datagrams if we don&apos;t have that network.</span>
<a name="l00923"></a>00923 <span class="comment">         */</span>
<a name="l00924"></a>00924 
<a name="l00925"></a>00925         <span class="comment">/* few more idiot software or configuration checks */</span>
<a name="l00926"></a>00926 
<a name="l00927"></a>00927         <span class="keywordflow">switch</span> (connreq-&gt;<a class="code" href="structkgn__connreq.html#a3f5e7b13bcf2d9713f74a9a1b9826ee6">gncr_type</a>) {
<a name="l00928"></a>00928         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a48dd218ba2da7bccf230d76dad5a5b41">GNILND_CONNREQ_REQ</a>:
<a name="l00929"></a>00929                 <span class="comment">/* wire up EP and SMSG block - this will check the incoming data</span>
<a name="l00930"></a>00930 <span class="comment">                 * and barf a NAK back if need to */</span>
<a name="l00931"></a>00931                 rc = <a class="code" href="gnilnd_8c.html#a414904ece5fc5f35c276b7d775e1ee54">kgnilnd_set_conn_params</a>(dgram);
<a name="l00932"></a>00932                 <span class="keywordflow">if</span> (rc)
<a name="l00933"></a>00933                         <span class="keywordflow">return</span> rc;
<a name="l00934"></a>00934                 <span class="keywordflow">break</span>;
<a name="l00935"></a>00935         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a94d5a8f2d421f134365d87243edfed68">GNILND_CONNREQ_NAK</a>:
<a name="l00936"></a>00936         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777adaa4234e3db40364268a026b60d5dc52">GNILND_CONNREQ_CLOSE</a>:
<a name="l00937"></a>00937                 <span class="keywordflow">break</span>;
<a name="l00938"></a>00938         <span class="keywordflow">default</span>:
<a name="l00939"></a>00939                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;unknown connreq packet type %d\n&quot;</span>, connreq-&gt;<a class="code" href="structkgn__connreq.html#a3f5e7b13bcf2d9713f74a9a1b9826ee6">gncr_type</a>);
<a name="l00940"></a>00940                 <span class="keywordflow">return</span> -EPROTO;
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <span class="keywordflow">if</span> (connreq-&gt;<a class="code" href="structkgn__connreq.html#a3376a452a7080b8be6d9d358dd846d55">gncr_peerstamp</a> == 0 || connreq-&gt;<a class="code" href="structkgn__connreq.html#a68e94324894ead083cc6f2a2492475dd">gncr_connstamp</a> == 0) {
<a name="l00944"></a>00944                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Recived bad timestamps peer &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot; conn &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00945"></a>00945                 connreq-&gt;<a class="code" href="structkgn__connreq.html#a3376a452a7080b8be6d9d358dd846d55">gncr_peerstamp</a>, connreq-&gt;<a class="code" href="structkgn__connreq.html#a68e94324894ead083cc6f2a2492475dd">gncr_connstamp</a>);
<a name="l00946"></a>00946                 <span class="keywordflow">return</span> -EPROTO;
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         <span class="keywordflow">if</span> (connreq-&gt;<a class="code" href="structkgn__connreq.html#ada7e02ee44699928ab4b98350cf1dac1">gncr_timeout</a> &lt; <a class="code" href="gnilnd_8h.html#ac10eadd0112c7364e467985f9986ff4c">GNILND_MIN_TIMEOUT</a>) {
<a name="l00950"></a>00950                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Received timeout %d &lt; MIN %d\n&quot;</span>,
<a name="l00951"></a>00951                        connreq-&gt;<a class="code" href="structkgn__connreq.html#ada7e02ee44699928ab4b98350cf1dac1">gncr_timeout</a>, <a class="code" href="gnilnd_8h.html#ac10eadd0112c7364e467985f9986ff4c">GNILND_MIN_TIMEOUT</a>);
<a name="l00952"></a>00952                 <span class="keywordflow">return</span> -EPROTO;
<a name="l00953"></a>00953         }
<a name="l00954"></a>00954 
<a name="l00955"></a>00955         <span class="keywordflow">return</span> 0;
<a name="l00956"></a>00956 }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="keywordtype">int</span>
<a name="l00959"></a><a class="code" href="gnilnd__conn_8c.html#a5df2bc2ac5fc29b8156de803d5c7c44d">00959</a> <a class="code" href="gnilnd__conn_8c.html#a5df2bc2ac5fc29b8156de803d5c7c44d">kgnilnd_alloc_dgram</a>(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> **dgramp, <a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="gnilnd_8h.html#af8b8123cb6d7bda204f2f338f545833a">kgn_dgram_type_t</a> type)
<a name="l00960"></a>00960 {
<a name="l00961"></a>00961         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>         *dgram;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963         dgram = kmem_cache_alloc(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a2beaf3264a518539776fbe5b154c4b02">kgn_dgram_cache</a>, GFP_ATOMIC);
<a name="l00964"></a>00964         <span class="keywordflow">if</span> (dgram == NULL)
<a name="l00965"></a>00965                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00966"></a>00966 
<a name="l00967"></a>00967         <span class="comment">/* cache alloc&apos;d memory is not zeroed */</span>
<a name="l00968"></a>00968         memset((<span class="keywordtype">void</span> *)dgram, 0, <span class="keyword">sizeof</span>(*dgram)) ;
<a name="l00969"></a>00969 
<a name="l00970"></a>00970         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;dgram-&gt;gndg_list);
<a name="l00971"></a>00971         dgram-&gt;gndg_state = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a954d2d6a8ab6239c849b6e26bcfe0643">GNILND_DGRAM_USED</a>;
<a name="l00972"></a>00972         dgram-&gt;gndg_type = type;
<a name="l00973"></a>00973         dgram-&gt;gndg_magic = <a class="code" href="gnilnd_8h.html#af0349821a59c57b1664d802146449eba">GNILND_DGRAM_MAGIC</a>;
<a name="l00974"></a>00974 
<a name="l00975"></a>00975         atomic_inc(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a51b814d02d69b4750eb35c78575bd03b">gnd_ndgrams</a>);
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a278f60b5ab8e7110e93fbaf0cd4b5c82">D_MALLOC</a>|<a class="code" href="libcfs__debug_8h.html#aeeeea1864fc878a5feed7940fd096adc">D_NETTRACE</a>, <span class="stringliteral">&quot;slab-alloced &apos;dgram&apos;: %lu at %p %s ndgrams&quot;</span>
<a name="l00978"></a>00978                 <span class="stringliteral">&quot; %d\n&quot;</span>,
<a name="l00979"></a>00979                 <span class="keyword">sizeof</span>(*dgram), dgram, <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram),
<a name="l00980"></a>00980                 atomic_read(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a51b814d02d69b4750eb35c78575bd03b">gnd_ndgrams</a>));
<a name="l00981"></a>00981 
<a name="l00982"></a>00982         *dgramp = dgram;
<a name="l00983"></a>00983         <span class="keywordflow">return</span> 0;
<a name="l00984"></a>00984 }
<a name="l00985"></a>00985 
<a name="l00986"></a>00986 <span class="comment">/* call this on a dgram that came back from kgnilnd_ep_postdata_test_by_id</span>
<a name="l00987"></a>00987 <span class="comment"> * returns &lt; 0 on dgram to be cleaned up</span>
<a name="l00988"></a>00988 <span class="comment"> * &gt; 0 on dgram that isn&apos;t done yet</span>
<a name="l00989"></a>00989 <span class="comment"> * == 0 on dgram that is ok and needs connreq processing */</span>
<a name="l00990"></a>00990 <span class="keywordtype">int</span>
<a name="l00991"></a><a class="code" href="gnilnd__conn_8c.html#af93f5b84747adbb5e58c7429167c90d1">00991</a> <a class="code" href="gnilnd__conn_8c.html#af93f5b84747adbb5e58c7429167c90d1">kgnilnd_process_dgram</a>(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram, <a class="code" href="gni__pub_8h.html#ad39107ebe0e99271fb788d7d56fc6493">gni_post_state_t</a> post_state)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993         <span class="keywordtype">int</span> rc = 0;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995         <span class="keywordflow">switch</span> (post_state) {
<a name="l00996"></a>00996         <span class="keywordflow">case</span> <a class="code" href="gni__pub_8h.html#a541df895833b4380df4cc83f5aa3e07faa22c361ec6d7a1b87356d5a33d3db4dd">GNI_POST_COMPLETED</a>:
<a name="l00997"></a>00997                 <span class="comment">/* normal state for dgrams that need actual processing */</span>
<a name="l00998"></a>00998                 <span class="comment">/* GOTO to avoid processing dgram as canceled/done */</span>
<a name="l00999"></a>00999                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(process_out, rc);
<a name="l01000"></a>01000 
<a name="l01001"></a>01001         <span class="keywordflow">case</span> <a class="code" href="gni__pub_8h.html#a541df895833b4380df4cc83f5aa3e07fa7e0efdb7c99bc3ca58de668631f85501">GNI_POST_PENDING</a>:
<a name="l01002"></a>01002                 <span class="comment">/* we should only see this if we are testing a WC dgram after a</span>
<a name="l01003"></a>01003 <span class="comment">                 * cancel - it means that it needs a full cycle of waiting</span>
<a name="l01004"></a>01004 <span class="comment">                 * for kgni_sm_task to finish moving it to TERMINATED */</span>
<a name="l01005"></a>01005                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>((dgram-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a> == <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a>) &amp;&amp;
<a name="l01006"></a>01006                           (dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a671b81e5dd1707df3626ecd10d7ee68c">GNILND_DGRAM_CANCELED</a>),
<a name="l01007"></a>01007                          <span class="stringliteral">&quot;POST_PENDING dgram 0x%p with bad type %d(%s) or state %d(%s)\n&quot;</span>,
<a name="l01008"></a>01008                          dgram, dgram-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a>, <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram),
<a name="l01009"></a>01009                          dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a>, <a class="code" href="gnilnd_8h.html#acc0ed17e2d524b0f29db5479f1dcda93">kgnilnd_dgram_state2str</a>(dgram));
<a name="l01010"></a>01010 
<a name="l01011"></a>01011                 <span class="comment">/* positive RC as this dgram isn&apos;t done yet */</span>
<a name="l01012"></a>01012                 rc = EINPROGRESS;
<a name="l01013"></a>01013 
<a name="l01014"></a>01014                 <span class="comment">/* GOTO as this isn&apos;t done yet */</span>
<a name="l01015"></a>01015                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(process_out, rc);
<a name="l01016"></a>01016                 <span class="keywordflow">break</span>;
<a name="l01017"></a>01017 
<a name="l01018"></a>01018         <span class="keywordflow">case</span> <a class="code" href="gni__pub_8h.html#a541df895833b4380df4cc83f5aa3e07fa83fa9c5525266ed033a818cd3bec043d">GNI_POST_TERMINATED</a>:
<a name="l01019"></a>01019                 <span class="comment">/* we&apos;ve called cancel and it is done or remote guy called cancel and</span>
<a name="l01020"></a>01020 <span class="comment">                 * we&apos;ve receved it on a WC dgram */</span>
<a name="l01021"></a>01021 <span class="preprocessor">#if 0</span>
<a name="l01022"></a>01022 <span class="preprocessor"></span>                <span class="comment">/* we are seeing weird terminations on non WC dgrams when we have not</span>
<a name="l01023"></a>01023 <span class="comment">                 * canceled them */</span>
<a name="l01024"></a>01024 
<a name="l01025"></a>01025                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a671b81e5dd1707df3626ecd10d7ee68c">GNILND_DGRAM_CANCELED</a> ||
<a name="l01026"></a>01026                          dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a> == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>,
<a name="l01027"></a>01027                         <span class="stringliteral">&quot;dgram 0x%p with bad state %d(%s) or dst nid %s\n&quot;</span>,
<a name="l01028"></a>01028                         dgram, dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a>, <a class="code" href="gnilnd_8h.html#acc0ed17e2d524b0f29db5479f1dcda93">kgnilnd_dgram_state2str</a>(dgram),
<a name="l01029"></a>01029                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>));
<a name="l01030"></a>01030 <span class="preprocessor">#endif</span>
<a name="l01031"></a>01031 <span class="preprocessor"></span>
<a name="l01032"></a>01032                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aeeeea1864fc878a5feed7940fd096adc">D_NETTRACE</a>, <span class="stringliteral">&quot;dgram 0x%p saw %s, cleaning it up\n&quot;</span>, dgram,
<a name="l01033"></a>01033                        dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a671b81e5dd1707df3626ecd10d7ee68c">GNILND_DGRAM_CANCELED</a> ?  <span class="stringliteral">&quot;canceled&quot;</span> : <span class="stringliteral">&quot;terminated&quot;</span>);
<a name="l01034"></a>01034 
<a name="l01035"></a>01035                 rc =  -ECANCELED;
<a name="l01036"></a>01036                 <span class="keywordflow">break</span>;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038         <span class="keywordflow">case</span> <a class="code" href="gni__pub_8h.html#a541df895833b4380df4cc83f5aa3e07fa5c102048bc1219f1c5c51f2c38547052">GNI_POST_TIMEOUT</a>:
<a name="l01039"></a>01039                 <span class="comment">/* we could have a timeout on a wildcard dgram too - if</span>
<a name="l01040"></a>01040 <span class="comment">                 * we got the incoming request but the remote node beefed</span>
<a name="l01041"></a>01041 <span class="comment">                 * before kgni could send the match data back. We&apos;ll just error</span>
<a name="l01042"></a>01042 <span class="comment">                 * on the active case and bail out gracefully */</span>
<a name="l01043"></a>01043                 <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a> != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01044"></a>01044                         <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;hardware timeout for connect to &quot;</span>
<a name="l01045"></a>01045                                <span class="stringliteral">&quot;%s after %lu seconds. Is node dead?\n&quot;</span>,
<a name="l01046"></a>01046                                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>),
<a name="l01047"></a>01047                                <a class="code" href="linux-time_8h.html#ad893b50498565ea641263d4771bd69bc">cfs_duration_sec</a>(jiffies - dgram-&gt;<a class="code" href="structkgn__dgram.html#a03e30c7c8e63140d708e72dbcc4e729c">gndg_post_time</a>));
<a name="l01048"></a>01048                 }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050                 rc = -ETIMEDOUT;
<a name="l01051"></a>01051                 <span class="keywordflow">break</span>;
<a name="l01052"></a>01052 
<a name="l01053"></a>01053         <span class="keywordflow">default</span>:
<a name="l01054"></a>01054                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;dgram 0x%p with bad post_state %d\n&quot;</span>, dgram, post_state);
<a name="l01055"></a>01055                 <a class="code" href="libcfs__private_8h.html#a08eceadb65d1adcf8c198cff27081d5f">LBUG</a>();
<a name="l01056"></a>01056         }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058         <span class="comment">/* now finish cleaning up a dgram that is canceled/terminated and needs to</span>
<a name="l01059"></a>01059 <span class="comment">         * go away */</span>
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         <span class="comment">/* If this was actively canceled, drop the count now that we are processing */</span>
<a name="l01062"></a>01062         <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a671b81e5dd1707df3626ecd10d7ee68c">GNILND_DGRAM_CANCELED</a>) {
<a name="l01063"></a>01063                 atomic_dec(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>-&gt;<a class="code" href="structkgn__device.html#a8db21b5be388935ce9343d9579b01868">gnd_canceled_dgrams</a>);
<a name="l01064"></a>01064                 <span class="comment">/* caller responsible for gndg_list removal */</span>
<a name="l01065"></a>01065         }
<a name="l01066"></a>01066 
<a name="l01067"></a>01067 process_out:
<a name="l01068"></a>01068 
<a name="l01069"></a>01069         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01070"></a>01070 }
<a name="l01071"></a>01071 
<a name="l01072"></a>01072 <span class="comment">/* needs dev-&gt;gnd_dgram_lock held */</span>
<a name="l01073"></a>01073 <span class="keywordtype">void</span>
<a name="l01074"></a><a class="code" href="gnilnd__conn_8c.html#af0bc27af31ab08277023dded0673771f">01074</a> <a class="code" href="gnilnd_8h.html#af0bc27af31ab08277023dded0673771f">kgnilnd_cancel_dgram_locked</a>(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01075"></a>01075 {
<a name="l01076"></a>01076         <a class="code" href="gni__pub_8h.html#a4a1de8d517eef402419200b53132f9a0">gni_return_t</a>            grc;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078         <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> != <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a16f6b012f4ea48a0a117372ddebbae18">GNILND_DGRAM_POSTED</a>) {
<a name="l01079"></a>01079                 <span class="keywordflow">return</span>;
<a name="l01080"></a>01080         }
<a name="l01081"></a>01081 
<a name="l01082"></a>01082         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a> != NULL,
<a name="l01083"></a>01083                  <span class="stringliteral">&quot;dgram 0x%p with NULL conn\n&quot;</span>, dgram);
<a name="l01084"></a>01084 
<a name="l01085"></a>01085         <span class="comment">/* C.E - WC dgrams could be canceled immediately but</span>
<a name="l01086"></a>01086 <span class="comment">         * if there was some match pending, we need to call</span>
<a name="l01087"></a>01087 <span class="comment">         * test_by_id to clear it out. If that test returns</span>
<a name="l01088"></a>01088 <span class="comment">         * POST_PENDING, it is half done and needs to go along</span>
<a name="l01089"></a>01089 <span class="comment">         * with the rest of dgrams and go through a kgni_sm_task cycle</span>
<a name="l01090"></a>01090 <span class="comment">         * and deliver a GNI_POST_TERMINATED event before they</span>
<a name="l01091"></a>01091 <span class="comment">         * are actually canceled */</span>
<a name="l01092"></a>01092 
<a name="l01093"></a>01093         dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a671b81e5dd1707df3626ecd10d7ee68c">GNILND_DGRAM_CANCELED</a>;
<a name="l01094"></a>01094 
<a name="l01095"></a>01095         <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#a2399b04e7ded56efe4ae3ba8a431e60a">gnc_state</a> &gt;= <a class="code" href="gnilnd_8h.html#a32505d3fed0776333ac6c392b9138840af38207cc4ea93ca58295feab9e5b06b1">GNILND_CONN_ESTABLISHED</a>) {
<a name="l01096"></a>01096                 <span class="comment">/* we don&apos;t need to cancel_by_id if the datagram was good */</span>
<a name="l01097"></a>01097                 <span class="keywordflow">return</span>;
<a name="l01098"></a>01098         }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100         <span class="comment">/* let folks know there are outstanding cancels */</span>
<a name="l01101"></a>01101         atomic_inc(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>-&gt;<a class="code" href="structkgn__device.html#a8db21b5be388935ce9343d9579b01868">gnd_canceled_dgrams</a>);
<a name="l01102"></a>01102         <span class="comment">/* leave on nid list until cancel is done for debugging fun */</span>
<a name="l01103"></a>01103         grc = <a class="code" href="gnilnd__api__wrap_8h.html#a0f959dab09ef0a7441d1cb732eac6e5d">kgnilnd_ep_postdata_cancel_by_id</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#aed3554ed5385235fb822b8263c7a95b6">gnc_ephandle</a>, (<a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>) dgram);
<a name="l01104"></a>01104 
<a name="l01105"></a>01105         <span class="comment">/* if we don&apos;t get success here, we have hosed up the dgram tracking</span>
<a name="l01106"></a>01106 <span class="comment">         * code and need to bail out */</span>
<a name="l01107"></a>01107         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(grc == <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>,
<a name="l01108"></a>01108                  <span class="stringliteral">&quot;postdata_cancel returned %d for conn 0x%p to %s\n&quot;</span>,
<a name="l01109"></a>01109                  grc, dgram-&gt;gndg_conn,
<a name="l01110"></a>01110                  dgram-&gt;gndg_conn-&gt;gnc_peer ?
<a name="l01111"></a>01111                   <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dgram-&gt;gndg_conn-&gt;gnc_peer-&gt;gnp_nid)
<a name="l01112"></a>01112                   : <span class="stringliteral">&quot;&lt;?&gt;&quot;</span>);
<a name="l01113"></a>01113 
<a name="l01114"></a>01114         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aeeeea1864fc878a5feed7940fd096adc">D_NETTRACE</a>,
<a name="l01115"></a>01115                 <span class="stringliteral">&quot;canceled dgram 0x%p conn 0x%p ephandle 0x%p\n&quot;</span>,
<a name="l01116"></a>01116                 dgram, dgram-&gt;gndg_conn,
<a name="l01117"></a>01117                 dgram-&gt;gndg_conn-&gt;gnc_ephandle);
<a name="l01118"></a>01118 
<a name="l01119"></a>01119         <span class="keywordflow">if</span> (dgram-&gt;gndg_type == <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a>) {
<a name="l01120"></a>01120                 <a class="code" href="gni__pub_8h.html#ad39107ebe0e99271fb788d7d56fc6493">gni_post_state_t</a>         post_state;
<a name="l01121"></a>01121                 <span class="keywordtype">int</span>                      rc = 0;
<a name="l01122"></a>01122                 __u32                    remote_addr = 0, remote_id = 0;
<a name="l01123"></a>01123 
<a name="l01124"></a>01124                 grc = <a class="code" href="gnilnd__api__wrap_8h.html#a3f2bd0bad77692f8fc9301dcd75fca32">kgnilnd_ep_postdata_test_by_id</a>(dgram-&gt;gndg_conn-&gt;gnc_ephandle,
<a name="l01125"></a>01125                                                      (<a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>)dgram, &amp;post_state,
<a name="l01126"></a>01126                                                      &amp;remote_addr, &amp;remote_id);
<a name="l01127"></a>01127 
<a name="l01128"></a>01128                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(grc == <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a4ea8b407a80548cf131ed4795332d533">GNI_RC_NO_MATCH</a> || grc == <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>,
<a name="l01129"></a>01129                          <span class="stringliteral">&quot;bad grc %d from test_by_id on dgram 0x%p\n&quot;</span>,
<a name="l01130"></a>01130                         grc, dgram);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132                 <span class="comment">/* if WC was canceled immediately, we get NO_MATCH, if needs to go</span>
<a name="l01133"></a>01133 <span class="comment">                 * through full cycle, we get SUCCESS and need to parse post_state */</span>
<a name="l01134"></a>01134 
<a name="l01135"></a>01135                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;grc %d dgram 0x%p type %s post_state %d &quot;</span>
<a name="l01136"></a>01136                         <span class="stringliteral">&quot;remote_addr %u remote_id %u\n&quot;</span>, grc, dgram,
<a name="l01137"></a>01137                         <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram),
<a name="l01138"></a>01138                         post_state, remote_addr, remote_id);
<a name="l01139"></a>01139 
<a name="l01140"></a>01140                 <span class="keywordflow">if</span> (grc == <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a4ea8b407a80548cf131ed4795332d533">GNI_RC_NO_MATCH</a>) {
<a name="l01141"></a>01141                         <span class="comment">/* she&apos;s gone, reduce count and move along */</span>
<a name="l01142"></a>01142                         dgram-&gt;gndg_state = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ab7d8300a4cbfd5b331e8018b4822f6f9">GNILND_DGRAM_DONE</a>;
<a name="l01143"></a>01143                         atomic_dec(&amp;dgram-&gt;gndg_conn-&gt;gnc_device-&gt;gnd_canceled_dgrams);
<a name="l01144"></a>01144                         <a class="code" href="libcfs__debug_8h.html#add49da686844faee56b8f16f9c784085">RETURN_EXIT</a>;
<a name="l01145"></a>01145                 }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147                 rc = <a class="code" href="gnilnd__conn_8c.html#af93f5b84747adbb5e58c7429167c90d1">kgnilnd_process_dgram</a>(dgram, post_state);
<a name="l01148"></a>01148 
<a name="l01149"></a>01149                 <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l01150"></a>01150                         <span class="comment">/* if for some weird reason we get a valid dgram back, just mark as done</span>
<a name="l01151"></a>01151 <span class="comment">                         * so we can drop it and move along.</span>
<a name="l01152"></a>01152 <span class="comment">                         * C.E - if it was completed, we&apos;ll just release the conn/mbox</span>
<a name="l01153"></a>01153 <span class="comment">                         * back into the pool and it&apos;ll get reused. That said, we should only</span>
<a name="l01154"></a>01154 <span class="comment">                         * be canceling a WC dgram on stack rest or shutdown, so that is moot */</span>
<a name="l01155"></a>01155                         dgram-&gt;gndg_state = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ab7d8300a4cbfd5b331e8018b4822f6f9">GNILND_DGRAM_DONE</a>;
<a name="l01156"></a>01156                         atomic_dec(&amp;dgram-&gt;gndg_conn-&gt;gnc_device-&gt;gnd_canceled_dgrams);
<a name="l01157"></a>01157 
<a name="l01158"></a>01158                         <span class="comment">/* caller context responsible for calling kgnilnd_release_dgram() */</span>
<a name="l01159"></a>01159                 } <span class="keywordflow">else</span> {
<a name="l01160"></a>01160                         <span class="comment">/* still pending, let it simmer until golden brown and delicious */</span>
<a name="l01161"></a>01161                 }
<a name="l01162"></a>01162         }
<a name="l01163"></a>01163 
<a name="l01164"></a>01164         <span class="comment">/* for non WC dgrams, they are still on the nid list but marked canceled waiting</span>
<a name="l01165"></a>01165 <span class="comment">         * for kgni to return their ID to us via probe - that is when we&apos;ll complete their</span>
<a name="l01166"></a>01166 <span class="comment">         * cancel processing */</span>
<a name="l01167"></a>01167 }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169 <span class="keywordtype">void</span>
<a name="l01170"></a><a class="code" href="gnilnd__conn_8c.html#adf4c92e2b58a6a72147b04e980f94fd1">01170</a> <a class="code" href="gnilnd__conn_8c.html#adf4c92e2b58a6a72147b04e980f94fd1">kgnilnd_cleanup_dgram</a>(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01171"></a>01171 {
<a name="l01172"></a>01172         <span class="comment">/* release the dgram ref on conn */</span>
<a name="l01173"></a>01173         <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>) {
<a name="l01174"></a>01174                 <a class="code" href="gnilnd_8h.html#a8660e9cbb0dc158d5d7a36f7dc86e184">kgnilnd_conn_decref</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>);
<a name="l01175"></a>01175                 dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a> = NULL;
<a name="l01176"></a>01176         }
<a name="l01177"></a>01177 }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179 <span class="keywordtype">void</span>
<a name="l01180"></a><a class="code" href="gnilnd__conn_8c.html#a533185ea570fd06eb08afa867f0aad84">01180</a> <a class="code" href="gnilnd__conn_8c.html#a533185ea570fd06eb08afa867f0aad84">kgnilnd_free_dgram</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01181"></a>01181 {
<a name="l01182"></a>01182         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a954d2d6a8ab6239c849b6e26bcfe0643">GNILND_DGRAM_USED</a> ||
<a name="l01183"></a>01183                  dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ab7d8300a4cbfd5b331e8018b4822f6f9">GNILND_DGRAM_DONE</a>,
<a name="l01184"></a>01184                  <span class="stringliteral">&quot;dgram 0x%p with bad state %s\n&quot;</span>,
<a name="l01185"></a>01185                  dgram, <a class="code" href="gnilnd_8h.html#acc0ed17e2d524b0f29db5479f1dcda93">kgnilnd_dgram_state2str</a>(dgram));
<a name="l01186"></a>01186 
<a name="l01187"></a>01187         <span class="comment">/* bit of poisoning to help detect bad driver data */</span>
<a name="l01188"></a>01188         dgram-&gt;<a class="code" href="structkgn__dgram.html#a923188981616f589919e893a153913a8">gndg_magic</a> = 0x6f5a6b5f;
<a name="l01189"></a>01189         atomic_dec(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a51b814d02d69b4750eb35c78575bd03b">gnd_ndgrams</a>);
<a name="l01190"></a>01190 
<a name="l01191"></a>01191         kmem_cache_free(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a2beaf3264a518539776fbe5b154c4b02">kgn_dgram_cache</a>, dgram);
<a name="l01192"></a>01192         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a278f60b5ab8e7110e93fbaf0cd4b5c82">D_MALLOC</a>|<a class="code" href="libcfs__debug_8h.html#aeeeea1864fc878a5feed7940fd096adc">D_NETTRACE</a>, <span class="stringliteral">&quot;slab-freed &apos;dgram&apos;: %lu at %p %s&quot;</span>
<a name="l01193"></a>01193                <span class="stringliteral">&quot; ndgrams %d\n&quot;</span>,
<a name="l01194"></a>01194                <span class="keyword">sizeof</span>(*dgram), dgram, <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram),
<a name="l01195"></a>01195                atomic_read(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a51b814d02d69b4750eb35c78575bd03b">gnd_ndgrams</a>));
<a name="l01196"></a>01196 }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198 <span class="keywordtype">int</span>
<a name="l01199"></a><a class="code" href="gnilnd__conn_8c.html#aa8afeb18eea207c710d60a0927c91c8d">01199</a> <a class="code" href="gnilnd__conn_8c.html#aa8afeb18eea207c710d60a0927c91c8d">kgnilnd_post_dgram</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dstnid, <a class="code" href="gnilnd_8h.html#ad9e9bf7209c754ba088533226ac5ab78">kgn_connreq_type_t</a> type,
<a name="l01200"></a>01200                    <span class="keywordtype">int</span> data_rc)
<a name="l01201"></a>01201 {
<a name="l01202"></a>01202         <span class="keywordtype">int</span>              rc = 0;
<a name="l01203"></a>01203         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>     *dgram = NULL;
<a name="l01204"></a>01204         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>     *tmpdgram;
<a name="l01205"></a>01205         <a class="code" href="gnilnd_8h.html#af8b8123cb6d7bda204f2f338f545833a">kgn_dgram_type_t</a> dgtype;
<a name="l01206"></a>01206         <a class="code" href="gni__pub_8h.html#a4a1de8d517eef402419200b53132f9a0">gni_return_t</a>     grc;
<a name="l01207"></a>01207         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>            srcnid;
<a name="l01208"></a>01208         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01209"></a>01209 
<a name="l01210"></a>01210         <span class="keywordflow">switch</span> (type) {
<a name="l01211"></a>01211         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a48dd218ba2da7bccf230d76dad5a5b41">GNILND_CONNREQ_REQ</a>:
<a name="l01212"></a>01212                 <span class="keywordflow">if</span> (dstnid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>)
<a name="l01213"></a>01213                         dgtype = <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a>;
<a name="l01214"></a>01214                 <span class="keywordflow">else</span>
<a name="l01215"></a>01215                         dgtype = <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26a4a4f3521baf43868818329dad6d38e60">GNILND_DGRAM_REQ</a>;
<a name="l01216"></a>01216                 <span class="keywordflow">break</span>;
<a name="l01217"></a>01217         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a94d5a8f2d421f134365d87243edfed68">GNILND_CONNREQ_NAK</a>:
<a name="l01218"></a>01218                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, <span class="stringliteral">&quot;can&apos;t NAK to LNET_NID_ANY\n&quot;</span>);
<a name="l01219"></a>01219                 dgtype = <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26a8f76fc062376a06723fcaacc88d7b4e2">GNILND_DGRAM_NAK</a>;
<a name="l01220"></a>01220                 <span class="keywordflow">break</span>;
<a name="l01221"></a>01221         <span class="keywordflow">default</span>:
<a name="l01222"></a>01222                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;unknown connreq type %d\n&quot;</span>, type);
<a name="l01223"></a>01223                 <a class="code" href="libcfs__private_8h.html#a08eceadb65d1adcf8c198cff27081d5f">LBUG</a>();
<a name="l01224"></a>01224         }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226         rc = <a class="code" href="gnilnd__conn_8c.html#a5df2bc2ac5fc29b8156de803d5c7c44d">kgnilnd_alloc_dgram</a>(&amp;dgram, dev, dgtype);
<a name="l01227"></a>01227         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01228"></a>01228                 rc = -ENOMEM;
<a name="l01229"></a>01229                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(post_failed, rc);
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         rc = <a class="code" href="gnilnd_8c.html#a16427dc1b73966ab084540120a97a5d7">kgnilnd_create_conn</a>(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>, dev);
<a name="l01233"></a>01233         <span class="keywordflow">if</span> (rc) {
<a name="l01234"></a>01234                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(post_failed, rc);
<a name="l01235"></a>01235         }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237         <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a> == <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a>) {
<a name="l01238"></a>01238                 <span class="comment">/* clear buffer for sanity on reuse of wildcard */</span>
<a name="l01239"></a>01239                 memset(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>));
<a name="l01240"></a>01240         }
<a name="l01241"></a>01241 
<a name="l01242"></a>01242         <span class="keywordflow">if</span> (dstnid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01243"></a>01243                 <span class="comment">/* set here to reset any dgram re-use */</span>
<a name="l01244"></a>01244                 dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#a2399b04e7ded56efe4ae3ba8a431e60a">gnc_state</a> = <a class="code" href="gnilnd_8h.html#a32505d3fed0776333ac6c392b9138840ac4ac654d4d5d3662eec243dc2bfbad79">GNILND_CONN_LISTEN</a>;
<a name="l01245"></a>01245         } <span class="keywordflow">else</span> {
<a name="l01246"></a>01246                 __u32            host_id;
<a name="l01247"></a>01247 
<a name="l01248"></a>01248                 rc = <a class="code" href="gnilnd__aries_8h.html#af2667278e32c4e1274f4d8814d9b9e30">kgnilnd_nid_to_nicaddrs</a>(<a class="code" href="group__lnet__addr.html#ga692b6a866269a35490f2e2803cc2e5d6" title="extract the address part of an lnet_nid_t">LNET_NIDADDR</a>(dstnid), 1, &amp;host_id);
<a name="l01249"></a>01249                 <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l01250"></a>01250                         rc = -ESRCH;
<a name="l01251"></a>01251                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(post_failed, rc);
<a name="l01252"></a>01252                 }
<a name="l01253"></a>01253 
<a name="l01254"></a>01254                 dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#a2399b04e7ded56efe4ae3ba8a431e60a">gnc_state</a> = <a class="code" href="gnilnd_8h.html#a32505d3fed0776333ac6c392b9138840acd29011708f4d20d63b00a2e3434dbbf">GNILND_CONN_CONNECTING</a>;
<a name="l01255"></a>01255 
<a name="l01256"></a>01256                 <span class="comment">/* don&apos;t need to serialize, there are no CQs for the dgram</span>
<a name="l01257"></a>01257 <span class="comment">                 * EP on the kgn_net_t */</span>
<a name="l01258"></a>01258                 grc = <a class="code" href="gnilnd__api__wrap_8h.html#a79e0d9610f4f640c3357086015abeb17">kgnilnd_ep_bind</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#aed3554ed5385235fb822b8263c7a95b6">gnc_ephandle</a>, host_id, dev-&gt;<a class="code" href="structkgn__device.html#a121a69ed91d615c6eec65ca3605545eb">gnd_id</a>);
<a name="l01259"></a>01259 
<a name="l01260"></a>01260                 <span class="keywordflow">if</span> (grc != <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>) {
<a name="l01261"></a>01261                         rc = -ECONNABORTED;
<a name="l01262"></a>01262                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(post_failed, rc);
<a name="l01263"></a>01263                 }
<a name="l01264"></a>01264 
<a name="l01265"></a>01265         }
<a name="l01266"></a>01266 
<a name="l01267"></a>01267         <span class="comment">/* If we are posting wildcards post using a net of 0, otherwise we&apos;ll use the</span>
<a name="l01268"></a>01268 <span class="comment">         * net of the destination node.</span>
<a name="l01269"></a>01269 <span class="comment">         */</span>
<a name="l01270"></a>01270 
<a name="l01271"></a>01271         <span class="keywordflow">if</span> (dstnid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01272"></a>01272                 srcnid = <a class="code" href="group__lnet__addr.html#gacab9a4d9fd8480776bef52653af50be3">LNET_MKNID</a>(<a class="code" href="group__lnet__addr.html#ga664629710c7e7bf96661b4a3d4300e96">LNET_MKNET</a>(<a class="code" href="nidstr_8h.html#afb9b21dcb0b6eb4e9e0c9cb090e774bea849384fc332c2aa0e096404067976d77">GNILND</a>, 0), dev-&gt;<a class="code" href="structkgn__device.html#aa56a56f537d0714709413694effbfab7">gnd_nid</a>);
<a name="l01273"></a>01273         } <span class="keywordflow">else</span> {
<a name="l01274"></a>01274                 srcnid = <a class="code" href="group__lnet__addr.html#gacab9a4d9fd8480776bef52653af50be3">LNET_MKNID</a>(<a class="code" href="group__lnet__addr.html#gabf536c21b8f5226eadf3a124a265ee3b">LNET_NIDNET</a>(dstnid), dev-&gt;<a class="code" href="structkgn__device.html#aa56a56f537d0714709413694effbfab7">gnd_nid</a>);
<a name="l01275"></a>01275         }
<a name="l01276"></a>01276 
<a name="l01277"></a>01277         rc = <a class="code" href="gnilnd__conn_8c.html#ab5b00b1c52fa1a460ac6930708f8e23b">kgnilnd_pack_connreq</a>(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>, dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>,
<a name="l01278"></a>01278                                   srcnid, dstnid, type);
<a name="l01279"></a>01279         <span class="keywordflow">if</span> (rc) {
<a name="l01280"></a>01280                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(post_failed, rc);
<a name="l01281"></a>01281         }
<a name="l01282"></a>01282 
<a name="l01283"></a>01283         <span class="keywordflow">if</span> (type == <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a94d5a8f2d421f134365d87243edfed68">GNILND_CONNREQ_NAK</a>)
<a name="l01284"></a>01284                 dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a60aca351f9aeb0506874026d3986e1e6">gncr_nakdata</a>.<a class="code" href="structkgn__nak__data.html#ab642014e904809eb127f35c63b981c70">gnnd_errno</a> = data_rc;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286         dgram-&gt;<a class="code" href="structkgn__dgram.html#a03e30c7c8e63140d708e72dbcc4e729c">gndg_post_time</a> = jiffies;
<a name="l01287"></a>01287 
<a name="l01288"></a>01288         <span class="comment">/* XXX Nic: here is where we&apos;d add in logical network multiplexing */</span>
<a name="l01289"></a>01289 
<a name="l01290"></a>01290         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aeeeea1864fc878a5feed7940fd096adc">D_NETTRACE</a>, <span class="stringliteral">&quot;dgram 0x%p type %s %s-&gt;%s cdm %d\n&quot;</span>,
<a name="l01291"></a>01291                dgram, <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram),
<a name="l01292"></a>01292                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(srcnid),
<a name="l01293"></a>01293                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dstnid), dev-&gt;<a class="code" href="structkgn__device.html#a121a69ed91d615c6eec65ca3605545eb">gnd_id</a>);
<a name="l01294"></a>01294 
<a name="l01295"></a>01295         <span class="comment">/* this allocates memory, can&apos;t hold locks across */</span>
<a name="l01296"></a>01296         grc = <a class="code" href="gnilnd__api__wrap_8h.html#a2a7c9e142deb74f9dd80298842018149">kgnilnd_ep_postdata_w_id</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#aed3554ed5385235fb822b8263c7a95b6">gnc_ephandle</a>,
<a name="l01297"></a>01297                                    &amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>),
<a name="l01298"></a>01298                                    &amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>, <span class="keyword">sizeof</span>(<a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>),
<a name="l01299"></a>01299                                    (<a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>)dgram);
<a name="l01300"></a>01300 
<a name="l01301"></a>01301         <span class="keywordflow">if</span> (grc != <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>) {
<a name="l01302"></a>01302                 <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;dropping failed dgram post id 0x%p type %s&quot;</span>
<a name="l01303"></a>01303                         <span class="stringliteral">&quot; reqtype %s to %s: rc %d\n&quot;</span>,
<a name="l01304"></a>01304                         dgram, <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram),
<a name="l01305"></a>01305                         <a class="code" href="gnilnd_8h.html#ab194f631fecd0ca00918602b420409ca">kgnilnd_connreq_type2str</a>(&amp;dgram-&gt;gndg_conn_out),
<a name="l01306"></a>01306                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dstnid), grc);
<a name="l01307"></a>01307                 rc = (grc == <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a5ba902bba73cfdbf0027559b88b8fc63">GNI_RC_ERROR_NOMEM</a>) ? -ENOMEM : -EBADR;
<a name="l01308"></a>01308                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(post_failed, rc);
<a name="l01309"></a>01309         }
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         <span class="comment">/* we don&apos;t need to add earlier - if someone does del_peer during post,</span>
<a name="l01312"></a>01312 <span class="comment">         * that peer will get marked as unlinked and the callers wil take care of it.</span>
<a name="l01313"></a>01313 <span class="comment">         * The dgram code is largely kgn_peer_t ignorant, so at worst, we&apos;ll just drop</span>
<a name="l01314"></a>01314 <span class="comment">         * the completed dgram later when we cant find a peer to stuff it into */</span>
<a name="l01315"></a>01315 
<a name="l01316"></a>01316         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01317"></a>01317 
<a name="l01318"></a>01318         <span class="comment">/* make sure we are not double posting targeted dgrams</span>
<a name="l01319"></a>01319 <span class="comment">         * - we can multiple post WC dgrams to help with processing speed */</span>
<a name="l01320"></a>01320         <span class="keywordflow">if</span> (dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01321"></a>01321                 tmpdgram = <a class="code" href="gnilnd__conn_8c.html#a32639710499349b942de623184d7e84d">kgnilnd_find_dgram_locked</a>(dev, dstnid);
<a name="l01322"></a>01322 
<a name="l01323"></a>01323                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(tmpdgram == NULL,
<a name="l01324"></a>01324                         <span class="stringliteral">&quot;dgram 0x%p-&gt;%s already posted\n&quot;</span>,
<a name="l01325"></a>01325                          dgram, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dstnid));
<a name="l01326"></a>01326         }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328         <span class="comment">/* unmunge dstnid to help processing code cope... */</span>
<a name="l01329"></a>01329         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a44fc0ae02b6df1b0e0a878e357eeff16">CFS_FAIL_GNI_PACK_DSTNID</a>)) {
<a name="l01330"></a>01330                 dgram-&gt;gndg_conn_out.gncr_dstnid = dstnid;
<a name="l01331"></a>01331         }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;dgram-&gt;gndg_list, <a class="code" href="gnilnd__conn_8c.html#a40261f1a59add37cd0dd1bcc783cbc2a">kgnilnd_nid2dgramlist</a>(dev, dstnid));
<a name="l01334"></a>01334         dgram-&gt;gndg_state = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a16f6b012f4ea48a0a117372ddebbae18">GNILND_DGRAM_POSTED</a>;
<a name="l01335"></a>01335         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337 post_failed:
<a name="l01338"></a>01338         <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; dgram != NULL) {
<a name="l01339"></a>01339                 <a class="code" href="gnilnd__conn_8c.html#adf4c92e2b58a6a72147b04e980f94fd1">kgnilnd_cleanup_dgram</a>(dgram);
<a name="l01340"></a>01340                 <a class="code" href="gnilnd__conn_8c.html#a533185ea570fd06eb08afa867f0aad84">kgnilnd_free_dgram</a>(dev, dgram);
<a name="l01341"></a>01341         }
<a name="l01342"></a>01342 
<a name="l01343"></a>01343         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01344"></a>01344 }
<a name="l01345"></a>01345 
<a name="l01346"></a>01346 <span class="comment">/* The shutdown flag is set from the shutdown and stack reset threads. */</span>
<a name="l01347"></a>01347 <span class="keywordtype">void</span>
<a name="l01348"></a><a class="code" href="gnilnd__conn_8c.html#a7a7b634c7c8164ec658dac434ddcb7fb">01348</a> <a class="code" href="gnilnd_8h.html#a7a7b634c7c8164ec658dac434ddcb7fb">kgnilnd_release_dgram</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram, <span class="keywordtype">int</span> shutdown)
<a name="l01349"></a>01349 {
<a name="l01350"></a>01350         <span class="comment">/* The conns of canceled active dgrams need to be put in purgatory so</span>
<a name="l01351"></a>01351 <span class="comment">         * we don&apos;t reuse the mailbox */</span>
<a name="l01352"></a>01352         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a671b81e5dd1707df3626ecd10d7ee68c">GNILND_DGRAM_CANCELED</a>)) {
<a name="l01353"></a>01353                 <a class="code" href="structkgn__peer.html">kgn_peer_t</a> *peer;
<a name="l01354"></a>01354                 <a class="code" href="structkgn__conn.html">kgn_conn_t</a> *conn = dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>;
<a name="l01355"></a>01355                 <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid = dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>;
<a name="l01356"></a>01356 
<a name="l01357"></a>01357                 dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ab7d8300a4cbfd5b331e8018b4822f6f9">GNILND_DGRAM_DONE</a>;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359                 <span class="comment">/* During shutdown we&apos;ve already removed the peer so we don&apos;t</span>
<a name="l01360"></a>01360 <span class="comment">                 * need to add a peer. During stack reset we don&apos;t care about</span>
<a name="l01361"></a>01361 <span class="comment">                 * MDDs since they are all released. */</span>
<a name="l01362"></a>01362                 <span class="keywordflow">if</span> (!shutdown) {
<a name="l01363"></a>01363                         write_lock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01364"></a>01364                         peer = <a class="code" href="gnilnd_8c.html#ae3f81dd4cc7e7702064be92557b3aa62">kgnilnd_find_peer_locked</a>(nid);
<a name="l01365"></a>01365 
<a name="l01366"></a>01366                         <span class="keywordflow">if</span> (peer != NULL) {
<a name="l01367"></a>01367                                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;adding peer&apos;s conn with nid %s &quot;</span>
<a name="l01368"></a>01368                                         <span class="stringliteral">&quot;to purgatory\n&quot;</span>, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(nid));
<a name="l01369"></a>01369                                 <a class="code" href="gnilnd_8h.html#a645ce9ec3f2e5a37df940b2e5f9ef25d">kgnilnd_conn_addref</a>(conn);
<a name="l01370"></a>01370                                 conn-&gt;<a class="code" href="structkgn__conn.html#a73c5fd56c57297902f4203db1086cd87">gnc_peer</a> = peer;
<a name="l01371"></a>01371                                 <a class="code" href="gnilnd_8h.html#ae39f61b875250339ce83d38a9067c201">kgnilnd_peer_addref</a>(peer);
<a name="l01372"></a>01372                                 <a class="code" href="gnilnd_8h.html#a1b04527de6ab8a99d2a6934c1c379f95">kgnilnd_admin_addref</a>(conn-&gt;<a class="code" href="structkgn__conn.html#a73c5fd56c57297902f4203db1086cd87">gnc_peer</a>-&gt;<a class="code" href="structkgn__peer.html#a62ee1ed1c8044c72b7c100af5aa0f6cb">gnp_dirty_eps</a>);
<a name="l01373"></a>01373                                 conn-&gt;<a class="code" href="structkgn__conn.html#a2399b04e7ded56efe4ae3ba8a431e60a">gnc_state</a> = <a class="code" href="gnilnd_8h.html#a32505d3fed0776333ac6c392b9138840ae368bc5dd559c5dd2b6deaa1b740e956">GNILND_CONN_CLOSED</a>;
<a name="l01374"></a>01374                                 <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;conn-&gt;<a class="code" href="structkgn__conn.html#afa12a1f7e60ddf21d1bb24fbab3bd976">gnc_list</a>,
<a name="l01375"></a>01375                                               &amp;peer-&gt;<a class="code" href="structkgn__peer.html#a75552d1bdc03d75d8daa6248fe289189">gnp_conns</a>);
<a name="l01376"></a>01376                                 <a class="code" href="gnilnd_8c.html#a4d36d0d19accb84ebc1427954f0caed5">kgnilnd_add_purgatory_locked</a>(conn,
<a name="l01377"></a>01377                                                              conn-&gt;<a class="code" href="structkgn__conn.html#a73c5fd56c57297902f4203db1086cd87">gnc_peer</a>);
<a name="l01378"></a>01378                                 <a class="code" href="gnilnd_8h.html#a98071e0aa9dd72ea5209ae9ed060904a">kgnilnd_schedule_conn</a>(conn);
<a name="l01379"></a>01379                         }
<a name="l01380"></a>01380                         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01381"></a>01381                 }
<a name="l01382"></a>01382         }
<a name="l01383"></a>01383 
<a name="l01384"></a>01384         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01385"></a>01385         <a class="code" href="gnilnd_8h.html#af0bc27af31ab08277023dded0673771f">kgnilnd_cancel_dgram_locked</a>(dgram);
<a name="l01386"></a>01386         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01387"></a>01387 
<a name="l01388"></a>01388         <a class="code" href="gnilnd__conn_8c.html#adf4c92e2b58a6a72147b04e980f94fd1">kgnilnd_cleanup_dgram</a>(dgram);
<a name="l01389"></a>01389 
<a name="l01390"></a>01390         <span class="comment">/* if the dgram is &apos;canceled&apos; it needs to be wait until the event</span>
<a name="l01391"></a>01391 <span class="comment">         * comes up from kgni that tells us it is safe to release */</span>
<a name="l01392"></a>01392         <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> != <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a671b81e5dd1707df3626ecd10d7ee68c">GNILND_DGRAM_CANCELED</a>) {
<a name="l01393"></a>01393                 dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ab7d8300a4cbfd5b331e8018b4822f6f9">GNILND_DGRAM_DONE</a>;
<a name="l01394"></a>01394 
<a name="l01395"></a>01395                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#a088df57c9c535f57230c8362f2b562de">gndg_list</a>), <span class="stringliteral">&quot;dgram 0x%p on list\n&quot;</span>, dgram);
<a name="l01396"></a>01396 
<a name="l01397"></a>01397                 <span class="comment">/* if it is a wildcard and we are in an appropriate state, repost</span>
<a name="l01398"></a>01398 <span class="comment">                 * the wildcard */</span>
<a name="l01399"></a>01399 
<a name="l01400"></a>01400                 <span class="keywordflow">if</span> ((dgram-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a> == <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a>) &amp;&amp;
<a name="l01401"></a>01401                     (!<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a938fd18f7c3c46fd90971f983573871b">kgn_wc_kill</a> &amp;&amp; !<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0cd73387ab25e56d411e774a9b613447">kgn_in_reset</a>)) {
<a name="l01402"></a>01402                         <span class="keywordtype">int</span>     rerc;
<a name="l01403"></a>01403 
<a name="l01404"></a>01404                         rerc = <a class="code" href="gnilnd__conn_8c.html#aa8afeb18eea207c710d60a0927c91c8d">kgnilnd_post_dgram</a>(dev, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a48dd218ba2da7bccf230d76dad5a5b41">GNILND_CONNREQ_REQ</a>, 0);
<a name="l01405"></a>01405                         <span class="keywordflow">if</span> (rerc != 0) {
<a name="l01406"></a>01406                                 <span class="comment">/* We failed to repost the WC dgram for some reason</span>
<a name="l01407"></a>01407 <span class="comment">                                 * mark it so the repost system attempts to repost */</span>
<a name="l01408"></a>01408                                 <a class="code" href="gnilnd_8h.html#a1b04527de6ab8a99d2a6934c1c379f95">kgnilnd_admin_addref</a>(dev-&gt;<a class="code" href="structkgn__device.html#a5660a310af80697abfbb9a2b33a8b6ff">gnd_nwcdgrams</a>);
<a name="l01409"></a>01409                         }
<a name="l01410"></a>01410                 }
<a name="l01411"></a>01411 
<a name="l01412"></a>01412                 <span class="comment">/* always free the old dgram */</span>
<a name="l01413"></a>01413                 <a class="code" href="gnilnd__conn_8c.html#a533185ea570fd06eb08afa867f0aad84">kgnilnd_free_dgram</a>(dev, dgram);
<a name="l01414"></a>01414         }
<a name="l01415"></a>01415 }
<a name="l01416"></a>01416 
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 <span class="keywordtype">int</span>
<a name="l01419"></a><a class="code" href="gnilnd__conn_8c.html#ad2689ebc9a3f361b4133a42b491cf11c">01419</a> <a class="code" href="gnilnd__conn_8c.html#ad2689ebc9a3f361b4133a42b491cf11c">kgnilnd_probe_for_dgram</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> **dgramp)
<a name="l01420"></a>01420 {
<a name="l01421"></a>01421         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>             *dgram = NULL;
<a name="l01422"></a>01422         <a class="code" href="gni__pub_8h.html#ad39107ebe0e99271fb788d7d56fc6493">gni_post_state_t</a>         post_state;
<a name="l01423"></a>01423         <a class="code" href="gni__pub_8h.html#a4a1de8d517eef402419200b53132f9a0">gni_return_t</a>             grc;
<a name="l01424"></a>01424         <span class="keywordtype">int</span>                      rc = 0;
<a name="l01425"></a>01425         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                    readyid;
<a name="l01426"></a>01426         __u32                    remote_addr = 0, remote_id = 0;
<a name="l01427"></a>01427         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01428"></a>01428 
<a name="l01429"></a>01429         <span class="comment">/* Probe with the lock held. That way if we get a dgram we dont have it canceled</span>
<a name="l01430"></a>01430 <span class="comment">         * between finding the ready dgram and grabbing the lock to remove it from the</span>
<a name="l01431"></a>01431 <span class="comment">         * list. Otherwise we could be left in an inconsistent state. We own the dgram</span>
<a name="l01432"></a>01432 <span class="comment">         * once its off the list so we don&apos;t need to worry about others changing it at</span>
<a name="l01433"></a>01433 <span class="comment">         * that point. */</span>
<a name="l01434"></a>01434         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01435"></a>01435         grc = <a class="code" href="gnilnd__api__wrap_8h.html#a72c04a6c3293383c1e7b9501258307d7">kgnilnd_postdata_probe_by_id</a>(dev-&gt;<a class="code" href="structkgn__device.html#adef69bb2d51b71d659d4404ea419e18e">gnd_handle</a>, &amp;readyid);
<a name="l01436"></a>01436         <span class="keywordflow">if</span> (grc != <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>) {
<a name="l01437"></a>01437                 spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01438"></a>01438                 <span class="comment">/* return 0 to indicate nothing happened */</span>
<a name="l01439"></a>01439                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01440"></a>01440         }
<a name="l01441"></a>01441 
<a name="l01442"></a>01442         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;ready &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot; on device 0x%p\n&quot;</span>,
<a name="l01443"></a>01443                 readyid, dev);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445         dgram = (<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *)readyid;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a923188981616f589919e893a153913a8">gndg_magic</a> == <a class="code" href="gnilnd_8h.html#af0349821a59c57b1664d802146449eba">GNILND_DGRAM_MAGIC</a>,
<a name="l01448"></a>01448                  <span class="stringliteral">&quot;dgram 0x%p from id &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot; with bad magic %x\n&quot;</span>,
<a name="l01449"></a>01449                  dgram, readyid, dgram-&gt;<a class="code" href="structkgn__dgram.html#a923188981616f589919e893a153913a8">gndg_magic</a>);
<a name="l01450"></a>01450 
<a name="l01451"></a>01451         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a16f6b012f4ea48a0a117372ddebbae18">GNILND_DGRAM_POSTED</a> ||
<a name="l01452"></a>01452                  dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a671b81e5dd1707df3626ecd10d7ee68c">GNILND_DGRAM_CANCELED</a>,
<a name="l01453"></a>01453                  <span class="stringliteral">&quot;dgram 0x%p with bad state %s\n&quot;</span>,
<a name="l01454"></a>01454                  dgram, <a class="code" href="gnilnd_8h.html#acc0ed17e2d524b0f29db5479f1dcda93">kgnilnd_dgram_state2str</a>(dgram));
<a name="l01455"></a>01455 
<a name="l01456"></a>01456         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#a088df57c9c535f57230c8362f2b562de">gndg_list</a>),
<a name="l01457"></a>01457                  <span class="stringliteral">&quot;dgram 0x%p with bad list state %s type %s\n&quot;</span>,
<a name="l01458"></a>01458                  dgram, <a class="code" href="gnilnd_8h.html#acc0ed17e2d524b0f29db5479f1dcda93">kgnilnd_dgram_state2str</a>(dgram),
<a name="l01459"></a>01459                  <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram));
<a name="l01460"></a>01460 
<a name="l01461"></a>01461         <span class="comment">/* now we know that the datagram structure is ok, so pull off list */</span>
<a name="l01462"></a>01462         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#a088df57c9c535f57230c8362f2b562de">gndg_list</a>);
<a name="l01463"></a>01463 
<a name="l01464"></a>01464         <span class="comment">/* while we have the gnn_dgram_lock and BEFORE we call test_by_id</span>
<a name="l01465"></a>01465 <span class="comment">         * change the state from POSTED to PROCESSING to ensure that</span>
<a name="l01466"></a>01466 <span class="comment">         * nobody cancels it after we&apos;ve pulled it from the wire */</span>
<a name="l01467"></a>01467         <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a16f6b012f4ea48a0a117372ddebbae18">GNILND_DGRAM_POSTED</a>) {
<a name="l01468"></a>01468                 dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ad27651948750cad41bba3e4ad706a740">GNILND_DGRAM_PROCESSING</a>;
<a name="l01469"></a>01469         }
<a name="l01470"></a>01470 
<a name="l01471"></a>01471         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a> != NULL,
<a name="l01472"></a>01472                 <span class="stringliteral">&quot;dgram 0x%p with NULL conn\n&quot;</span>, dgram);
<a name="l01473"></a>01473 
<a name="l01474"></a>01474         grc = <a class="code" href="gnilnd__api__wrap_8h.html#a3f2bd0bad77692f8fc9301dcd75fca32">kgnilnd_ep_postdata_test_by_id</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#aed3554ed5385235fb822b8263c7a95b6">gnc_ephandle</a>,
<a name="l01475"></a>01475                                              (<a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>)dgram, &amp;post_state,
<a name="l01476"></a>01476                                              &amp;remote_addr, &amp;remote_id);
<a name="l01477"></a>01477 
<a name="l01478"></a>01478         <span class="comment">/* we now &quot;own&quot; this datagram */</span>
<a name="l01479"></a>01479         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01480"></a>01480 
<a name="l01481"></a>01481         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(grc != <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a4ea8b407a80548cf131ed4795332d533">GNI_RC_NO_MATCH</a>, <span class="stringliteral">&quot;kgni lied! probe_by_id told us that&quot;</span>
<a name="l01482"></a>01482                  <span class="stringliteral">&quot; id &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot; was ready\n&quot;</span>, readyid);
<a name="l01483"></a>01483 
<a name="l01484"></a>01484         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;grc %d dgram 0x%p type %s post_state %d &quot;</span>
<a name="l01485"></a>01485                 <span class="stringliteral">&quot;remote_addr %u remote_id %u\n&quot;</span>, grc, dgram,
<a name="l01486"></a>01486                 <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram),
<a name="l01487"></a>01487                 post_state, remote_addr, remote_id);
<a name="l01488"></a>01488 
<a name="l01489"></a>01489         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(grc != <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>)) {
<a name="l01490"></a>01490                 <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;getting data for dgram 0x%p-&gt;%s failed rc %d. Dropping it\n&quot;</span>,
<a name="l01491"></a>01491                         dgram, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dgram-&gt;gndg_conn_out.gncr_dstnid),
<a name="l01492"></a>01492                         grc);
<a name="l01493"></a>01493                 rc = -EINVAL;
<a name="l01494"></a>01494                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(probe_for_out, rc);
<a name="l01495"></a>01495         }
<a name="l01496"></a>01496 
<a name="l01497"></a>01497         rc = <a class="code" href="gnilnd__conn_8c.html#af93f5b84747adbb5e58c7429167c90d1">kgnilnd_process_dgram</a>(dgram, post_state);
<a name="l01498"></a>01498 
<a name="l01499"></a>01499         <span class="comment">/* we should never get probe finding a dgram for us and then it</span>
<a name="l01500"></a>01500 <span class="comment">         * being a WC dgram that is still in the middle of processing */</span>
<a name="l01501"></a>01501         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(rc &lt;= 0, <span class="stringliteral">&quot;bad rc %d from process_dgram 0x%p state %d\n&quot;</span>,
<a name="l01502"></a>01502                  rc, dgram, post_state);
<a name="l01503"></a>01503 
<a name="l01504"></a>01504         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01505"></a>01505                 <span class="comment">/* dgram is good enough for the data to be used */</span>
<a name="l01506"></a>01506                 dgram-&gt;gndg_state = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ad27651948750cad41bba3e4ad706a740">GNILND_DGRAM_PROCESSING</a>;
<a name="l01507"></a>01507                 <span class="comment">/* fake rc to mark that we&apos;ve done something */</span>
<a name="l01508"></a>01508                 rc = 1;
<a name="l01509"></a>01509         } <span class="keywordflow">else</span> {
<a name="l01510"></a>01510                 <span class="comment">/* let kgnilnd_release_dgram take care of canceled dgrams */</span>
<a name="l01511"></a>01511                 <span class="keywordflow">if</span> (dgram-&gt;gndg_state != <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a671b81e5dd1707df3626ecd10d7ee68c">GNILND_DGRAM_CANCELED</a>) {
<a name="l01512"></a>01512                         dgram-&gt;gndg_state = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ab7d8300a4cbfd5b331e8018b4822f6f9">GNILND_DGRAM_DONE</a>;
<a name="l01513"></a>01513                 }
<a name="l01514"></a>01514         }
<a name="l01515"></a>01515 
<a name="l01516"></a>01516         *dgramp = dgram;
<a name="l01517"></a>01517         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01518"></a>01518 
<a name="l01519"></a>01519 probe_for_out:
<a name="l01520"></a>01520 
<a name="l01521"></a>01521         <a class="code" href="gnilnd_8h.html#a7a7b634c7c8164ec658dac434ddcb7fb">kgnilnd_release_dgram</a>(dev, dgram, 0);
<a name="l01522"></a>01522         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01523"></a>01523 }
<a name="l01524"></a>01524 
<a name="l01525"></a>01525 <span class="keywordtype">int</span>
<a name="l01526"></a><a class="code" href="gnilnd__conn_8c.html#adb51499e02fb3635d50acf91d94ecbf1">01526</a> <a class="code" href="gnilnd_8h.html#adb51499e02fb3635d50acf91d94ecbf1">kgnilnd_setup_wildcard_dgram</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l01527"></a>01527 {
<a name="l01528"></a>01528         <span class="comment">/* if kgn_wildcard is zero, return error */</span>
<a name="l01529"></a>01529         <span class="keywordtype">int</span>     rc = -ENOENT, i;
<a name="l01530"></a>01530         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01531"></a>01531 
<a name="l01532"></a>01532         <span class="keywordflow">for</span> (i = 0; i &lt; *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#af80a385f48c278fb1d4d269dbe9650db">kgn_nwildcard</a>; i++) {
<a name="l01533"></a>01533                 rc = <a class="code" href="gnilnd__conn_8c.html#aa8afeb18eea207c710d60a0927c91c8d">kgnilnd_post_dgram</a>(dev, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a48dd218ba2da7bccf230d76dad5a5b41">GNILND_CONNREQ_REQ</a>, 0);
<a name="l01534"></a>01534                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01535"></a>01535                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;error %d: could not post wildcard datagram # %d\n&quot;</span>,
<a name="l01536"></a>01536                                 rc, i);
<a name="l01537"></a>01537                         rc = -EINVAL;
<a name="l01538"></a>01538                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(failed, rc);
<a name="l01539"></a>01539                 }
<a name="l01540"></a>01540         }
<a name="l01541"></a>01541 
<a name="l01542"></a>01542 failed:
<a name="l01543"></a>01543         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01544"></a>01544 }
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 <span class="keywordtype">int</span>
<a name="l01547"></a><a class="code" href="gnilnd__conn_8c.html#a4e5db7f9ad90a055e0232f801596e252">01547</a> <a class="code" href="gnilnd_8h.html#a4e5db7f9ad90a055e0232f801596e252">kgnilnd_cancel_net_dgrams</a>(<a class="code" href="structkgn__net.html">kgn_net_t</a> *net)
<a name="l01548"></a>01548 {
<a name="l01549"></a>01549         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>            *dg, *dgN;
<a name="l01550"></a>01550         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        zombies;
<a name="l01551"></a>01551         <span class="keywordtype">int</span>                     i;
<a name="l01552"></a>01552         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01553"></a>01553 
<a name="l01554"></a>01554         <span class="comment">/* we want to cancel any outstanding dgrams - we don&apos;t want to rely</span>
<a name="l01555"></a>01555 <span class="comment">         * on del_peer_or_conn catching all of them. This helps protect us in cases</span>
<a name="l01556"></a>01556 <span class="comment">         * where we don&apos;t quite keep the peer-&gt;dgram mapping in sync due to some</span>
<a name="l01557"></a>01557 <span class="comment">         * race conditions */</span>
<a name="l01558"></a>01558 
<a name="l01559"></a>01559         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(net-&gt;<a class="code" href="structkgn__net.html#a5338935d53737311f4f6037d6241f274">gnn_shutdown</a> || <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0cd73387ab25e56d411e774a9b613447">kgn_in_reset</a>,
<a name="l01560"></a>01560                  <span class="stringliteral">&quot;called with LND invalid state: net shutdown %d &quot;</span>
<a name="l01561"></a>01561                  <span class="stringliteral">&quot;in reset %d\n&quot;</span>, net-&gt;<a class="code" href="structkgn__net.html#a5338935d53737311f4f6037d6241f274">gnn_shutdown</a>,
<a name="l01562"></a>01562                  <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0cd73387ab25e56d411e774a9b613447">kgn_in_reset</a>);
<a name="l01563"></a>01563 
<a name="l01564"></a>01564         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;zombies);
<a name="l01565"></a>01565 
<a name="l01566"></a>01566         spin_lock(&amp;net-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01567"></a>01567 
<a name="l01568"></a>01568         <span class="keywordflow">for</span> (i = 0; i &lt; *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#acc193b5b5171465a5a45ec26665c4c63">kgn_peer_hash_size</a>; i++) {
<a name="l01569"></a>01569                 <a class="code" href="list_8h.html#ac3f72d6bd5144c7970824813810d2da1" title="Iterate over a list of given type safe against removal of list entry.">list_for_each_entry_safe</a>(dg, dgN, &amp;net-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>-&gt;<a class="code" href="structkgn__device.html#ad0a7f62b9d3c4fb47b0e8994aebe3757">gnd_dgrams</a>[i], gndg_list) {
<a name="l01570"></a>01570 
<a name="l01571"></a>01571                         <span class="comment">/* skip nids not on our net or are wildcards */</span>
<a name="l01572"></a>01572 
<a name="l01573"></a>01573 
<a name="l01574"></a>01574                         <span class="keywordflow">if</span> (dg-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a> == <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a> ||
<a name="l01575"></a>01575                                 net-&gt;<a class="code" href="structkgn__net.html#a82c70a308b49e7574ce1dbc1ff48809a">gnn_netnum</a> != <a class="code" href="group__lnet__addr.html#gaa5b1f70b0f73fff4e4d2ceb7b95965b1">LNET_NETNUM</a>(<a class="code" href="group__lnet__addr.html#gabf536c21b8f5226eadf3a124a265ee3b">LNET_NIDNET</a>(dg-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>)))
<a name="l01576"></a>01576                                 <span class="keywordflow">continue</span>;
<a name="l01577"></a>01577 
<a name="l01578"></a>01578                         <a class="code" href="gnilnd_8h.html#af0bc27af31ab08277023dded0673771f">kgnilnd_cancel_dgram_locked</a>(dg);
<a name="l01579"></a>01579                 }
<a name="l01580"></a>01580         }
<a name="l01581"></a>01581 
<a name="l01582"></a>01582         spin_unlock(&amp;net-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01583"></a>01583 
<a name="l01584"></a>01584         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01585"></a>01585 }
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 <span class="keywordtype">int</span>
<a name="l01588"></a><a class="code" href="gnilnd__conn_8c.html#afc13255d05063a1f24efe5c43019146f">01588</a> <a class="code" href="gnilnd_8h.html#afc13255d05063a1f24efe5c43019146f">kgnilnd_cancel_wc_dgrams</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l01589"></a>01589 {
<a name="l01590"></a>01590         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dg, *dgN;
<a name="l01591"></a>01591         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> zombies;
<a name="l01592"></a>01592         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01593"></a>01593 
<a name="l01594"></a>01594         <span class="comment">/* Time to kill the outstanding WC&apos;s</span>
<a name="l01595"></a>01595 <span class="comment">         * WC&apos;s exist on net 0 only but match on any net...</span>
<a name="l01596"></a>01596 <span class="comment">         */</span>
<a name="l01597"></a>01597 
<a name="l01598"></a>01598         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0cd73387ab25e56d411e774a9b613447">kgn_in_reset</a> || <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a938fd18f7c3c46fd90971f983573871b">kgn_wc_kill</a>,
<a name="l01599"></a>01599                 <span class="stringliteral">&quot;called with LND invalid state: WC shutdown %d &quot;</span>
<a name="l01600"></a>01600                 <span class="stringliteral">&quot;in reset %d\n&quot;</span>, <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a938fd18f7c3c46fd90971f983573871b">kgn_wc_kill</a>,
<a name="l01601"></a>01601                 <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a0cd73387ab25e56d411e774a9b613447">kgn_in_reset</a>);
<a name="l01602"></a>01602 
<a name="l01603"></a>01603         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;zombies);
<a name="l01604"></a>01604         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01605"></a>01605 
<a name="l01606"></a>01606         <span class="keywordflow">do</span> {
<a name="l01607"></a>01607                 dg = <a class="code" href="gnilnd__conn_8c.html#a32639710499349b942de623184d7e84d">kgnilnd_find_dgram_locked</a>(dev, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>);
<a name="l01608"></a>01608                 <span class="keywordflow">if</span> (dg != NULL) {
<a name="l01609"></a>01609                         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dg-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a> == <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a>,
<a name="l01610"></a>01610                                  <span class="stringliteral">&quot;dgram 0x%p-&gt;%s with bad type %d (%s)\n&quot;</span>,
<a name="l01611"></a>01611                                 dg, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dg-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>),
<a name="l01612"></a>01612                                 dg-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a>, <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dg));
<a name="l01613"></a>01613 
<a name="l01614"></a>01614                         <a class="code" href="gnilnd_8h.html#af0bc27af31ab08277023dded0673771f">kgnilnd_cancel_dgram_locked</a>(dg);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616                         <span class="comment">/* WC could be DONE already, check and if so add to list to be released */</span>
<a name="l01617"></a>01617                         <span class="keywordflow">if</span> (dg-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> == <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ab7d8300a4cbfd5b331e8018b4822f6f9">GNILND_DGRAM_DONE</a>) {
<a name="l01618"></a>01618                                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;dg-&gt;<a class="code" href="structkgn__dgram.html#a088df57c9c535f57230c8362f2b562de">gndg_list</a>);
<a name="l01619"></a>01619                                 <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;dg-&gt;<a class="code" href="structkgn__dgram.html#a088df57c9c535f57230c8362f2b562de">gndg_list</a>, &amp;zombies);
<a name="l01620"></a>01620                         }
<a name="l01621"></a>01621                 }
<a name="l01622"></a>01622         } <span class="keywordflow">while</span> (dg != NULL);
<a name="l01623"></a>01623 
<a name="l01624"></a>01624         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01625"></a>01625 
<a name="l01626"></a>01626         <a class="code" href="list_8h.html#ac3f72d6bd5144c7970824813810d2da1" title="Iterate over a list of given type safe against removal of list entry.">list_for_each_entry_safe</a>(dg, dgN, &amp;zombies, gndg_list) {
<a name="l01627"></a>01627                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;dg-&gt;<a class="code" href="structkgn__dgram.html#a088df57c9c535f57230c8362f2b562de">gndg_list</a>);
<a name="l01628"></a>01628                 <a class="code" href="gnilnd_8h.html#a7a7b634c7c8164ec658dac434ddcb7fb">kgnilnd_release_dgram</a>(dev, dg, 1);
<a name="l01629"></a>01629         }
<a name="l01630"></a>01630         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01631"></a>01631 
<a name="l01632"></a>01632 }
<a name="l01633"></a>01633 
<a name="l01634"></a>01634 <span class="keywordtype">int</span>
<a name="l01635"></a><a class="code" href="gnilnd__conn_8c.html#a79091bd9ae8e1203959ee7a1e99060a3">01635</a> <a class="code" href="gnilnd_8h.html#a79091bd9ae8e1203959ee7a1e99060a3">kgnilnd_cancel_dgrams</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l01636"></a>01636 {
<a name="l01637"></a>01637         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dg, *dgN;
<a name="l01638"></a>01638         <span class="keywordtype">int</span> i;
<a name="l01639"></a>01639         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01640"></a>01640 
<a name="l01641"></a>01641         <span class="comment">/* Cancel any outstanding non wildcard datagrams regardless</span>
<a name="l01642"></a>01642 <span class="comment">         * of which net they are on as we are in base shutdown and</span>
<a name="l01643"></a>01643 <span class="comment">         * dont care about connecting anymore.</span>
<a name="l01644"></a>01644 <span class="comment">         */</span>
<a name="l01645"></a>01645 
<a name="l01646"></a>01646         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a938fd18f7c3c46fd90971f983573871b">kgn_wc_kill</a> == 1,<span class="stringliteral">&quot;We didnt get called from base shutdown\n&quot;</span>);
<a name="l01647"></a>01647 
<a name="l01648"></a>01648         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01649"></a>01649 
<a name="l01650"></a>01650         <span class="keywordflow">for</span> (i = 0; i &lt; (*<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#acc193b5b5171465a5a45ec26665c4c63">kgn_peer_hash_size</a> -1); i++) {
<a name="l01651"></a>01651                 <a class="code" href="list_8h.html#ac3f72d6bd5144c7970824813810d2da1" title="Iterate over a list of given type safe against removal of list entry.">list_for_each_entry_safe</a>(dg, dgN, &amp;dev-&gt;<a class="code" href="structkgn__device.html#ad0a7f62b9d3c4fb47b0e8994aebe3757">gnd_dgrams</a>[i], gndg_list) {
<a name="l01652"></a>01652                         <span class="keywordflow">if</span> (dg-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a> != <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a>)
<a name="l01653"></a>01653                                 <a class="code" href="gnilnd_8h.html#af0bc27af31ab08277023dded0673771f">kgnilnd_cancel_dgram_locked</a>(dg);
<a name="l01654"></a>01654                 }
<a name="l01655"></a>01655         }
<a name="l01656"></a>01656 
<a name="l01657"></a>01657         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l01658"></a>01658 
<a name="l01659"></a>01659         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01660"></a>01660 }
<a name="l01661"></a>01661 
<a name="l01662"></a>01662 
<a name="l01663"></a>01663 <span class="keywordtype">void</span>
<a name="l01664"></a><a class="code" href="gnilnd__conn_8c.html#a2eda8cca5a4beaa5b316c9817fc2bcd6">01664</a> <a class="code" href="gnilnd_8h.html#a2eda8cca5a4beaa5b316c9817fc2bcd6">kgnilnd_wait_for_canceled_dgrams</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l01665"></a>01665 {
<a name="l01666"></a>01666         <span class="keywordtype">int</span>             i = 4;
<a name="l01667"></a>01667         <span class="keywordtype">int</span>             rc;
<a name="l01668"></a>01668         <a class="code" href="gni__pub_8h.html#a4a1de8d517eef402419200b53132f9a0">gni_return_t</a>    grc;
<a name="l01669"></a>01669         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>           readyid;
<a name="l01670"></a>01670         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>    *dgram;
<a name="l01671"></a>01671 
<a name="l01672"></a>01672         <span class="comment">/* use do while to get at least one check run to allow</span>
<a name="l01673"></a>01673 <span class="comment">         * regression test for 762072 to hit bug if there */</span>
<a name="l01674"></a>01674 
<a name="l01675"></a>01675         <span class="comment">/* This function races with the dgram mover during shutdown so it is possible for</span>
<a name="l01676"></a>01676 <span class="comment">         * a dgram to be seen in kgnilnd_postdata_probe_wait_by_id but be handled in the</span>
<a name="l01677"></a>01677 <span class="comment">         * dgram mover thread instead of inside of this function.</span>
<a name="l01678"></a>01678 <span class="comment">         */</span>
<a name="l01679"></a>01679 
<a name="l01680"></a>01680         <span class="comment">/* This should only be called from within shutdown, baseshutdown, or stack reset.</span>
<a name="l01681"></a>01681 <span class="comment">         * there are no assertions here to verify since base_shutdown has nothing in it we can check</span>
<a name="l01682"></a>01682 <span class="comment">         * the net is gone by then.</span>
<a name="l01683"></a>01683 <span class="comment">         */</span>
<a name="l01684"></a>01684 
<a name="l01685"></a>01685         <span class="keywordflow">do</span> {
<a name="l01686"></a>01686                 i++;
<a name="l01687"></a>01687                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(((i &amp; (-i)) == i) ? <a class="code" href="libcfs__debug_8h.html#acca9c9cff9837f6f3d2759b02a61ff1d">D_WARNING</a> : <a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>,
<a name="l01688"></a>01688                         <span class="stringliteral">&quot;Waiting for %d canceled datagrams to clear on device %d\n&quot;</span>,
<a name="l01689"></a>01689                         atomic_read(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a8db21b5be388935ce9343d9579b01868">gnd_canceled_dgrams</a>), dev-&gt;<a class="code" href="structkgn__device.html#a121a69ed91d615c6eec65ca3605545eb">gnd_id</a>);
<a name="l01690"></a>01690 
<a name="l01691"></a>01691                 <span class="comment">/* check once a second */</span>
<a name="l01692"></a>01692                 grc = <a class="code" href="gnilnd__api__wrap_8h.html#aef60a68583abd2e338f2958f9cdb9106">kgnilnd_postdata_probe_wait_by_id</a>(dev-&gt;<a class="code" href="structkgn__device.html#adef69bb2d51b71d659d4404ea419e18e">gnd_handle</a>,
<a name="l01693"></a>01693                        250, &amp;readyid);
<a name="l01694"></a>01694 
<a name="l01695"></a>01695                 <span class="keywordflow">if</span> (grc != <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>)
<a name="l01696"></a>01696                         <span class="keywordflow">continue</span>;
<a name="l01697"></a>01697 
<a name="l01698"></a>01698                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(D_NET, <span class="stringliteral">&quot;ready &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot; on device %d-&gt;0x%p\n&quot;</span>,
<a name="l01699"></a>01699                         readyid, dev-&gt;<a class="code" href="structkgn__device.html#a121a69ed91d615c6eec65ca3605545eb">gnd_id</a>, dev);
<a name="l01700"></a>01700 
<a name="l01701"></a>01701                 rc = <a class="code" href="gnilnd__conn_8c.html#ad2689ebc9a3f361b4133a42b491cf11c">kgnilnd_probe_for_dgram</a>(dev, &amp;dgram);
<a name="l01702"></a>01702                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01703"></a>01703                         <span class="comment">/* if we got a valid dgram or one that is now done, clean up */</span>
<a name="l01704"></a>01704                         <a class="code" href="gnilnd_8h.html#a7a7b634c7c8164ec658dac434ddcb7fb">kgnilnd_release_dgram</a>(dev, dgram, 1);
<a name="l01705"></a>01705                 }
<a name="l01706"></a>01706         } <span class="keywordflow">while</span> (atomic_read(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a8db21b5be388935ce9343d9579b01868">gnd_canceled_dgrams</a>));
<a name="l01707"></a>01707 }
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 <span class="keywordtype">int</span>
<a name="l01710"></a><a class="code" href="gnilnd__conn_8c.html#a9f7ca42d3f863f9d3c08f7a57140c872">01710</a> <a class="code" href="gnilnd__conn_8c.html#a9f7ca42d3f863f9d3c08f7a57140c872">kgnilnd_start_connect</a>(<a class="code" href="structkgn__peer.html">kgn_peer_t</a> *peer)
<a name="l01711"></a>01711 {
<a name="l01712"></a>01712         <span class="keywordtype">int</span>              rc = 0;
<a name="l01713"></a>01713         <span class="comment">/* sync point for kgnilnd_del_peer_locked - do an early check to</span>
<a name="l01714"></a>01714 <span class="comment">         * catch the most common hits where del_peer is done by the</span>
<a name="l01715"></a>01715 <span class="comment">         * time we get here */</span>
<a name="l01716"></a>01716         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a3057096e9782194a931fd9f43cc1d610">CFS_FAIL_GNI_GNP_CONNECTING1</a>)) {
<a name="l01717"></a>01717                 <span class="keywordflow">while</span> (<a class="code" href="libcfs__fail_8h.html#ad8a7f229bd17fa3ffeaed1fc21d5f6fb">CFS_FAIL_TIMEOUT</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a3057096e9782194a931fd9f43cc1d610">CFS_FAIL_GNI_GNP_CONNECTING1</a>, 1)) {};
<a name="l01718"></a>01718         }
<a name="l01719"></a>01719 
<a name="l01720"></a>01720         write_lock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01721"></a>01721         <span class="keywordflow">if</span> (!<a class="code" href="gnilnd_8h.html#a71952850ccab3e2c426edf4eda0eaf6d">kgnilnd_peer_active</a>(peer) || peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> != <a class="code" href="gnilnd_8h.html#a08aa73ed62411a3ea5c771b0d1e8401f">GNILND_PEER_CONNECT</a>) {
<a name="l01722"></a>01722                 <span class="comment">/* raced with peer getting unlinked */</span>
<a name="l01723"></a>01723                 write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01724"></a>01724                 rc = ESTALE;
<a name="l01725"></a>01725                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l01726"></a>01726         }
<a name="l01727"></a>01727         peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> = <a class="code" href="gnilnd_8h.html#a4ab40a42aa7c7c222eef57a76fa83488">GNILND_PEER_POSTING</a>;
<a name="l01728"></a>01728         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01729"></a>01729 
<a name="l01730"></a>01730         set_mb(peer-&gt;<a class="code" href="structkgn__peer.html#a34c954a249b92768db34dd8da301bc64">gnp_last_dgram_time</a>, jiffies);
<a name="l01731"></a>01731         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#aa2d87c6ccdc9722e76264b71a111a82d">CFS_FAIL_GNI_GNP_CONNECTING2</a>)) {
<a name="l01732"></a>01732                 <span class="keywordflow">while</span> (<a class="code" href="libcfs__fail_8h.html#ad8a7f229bd17fa3ffeaed1fc21d5f6fb">CFS_FAIL_TIMEOUT</a>(<a class="code" href="gnilnd__api__wrap_8h.html#aa2d87c6ccdc9722e76264b71a111a82d">CFS_FAIL_GNI_GNP_CONNECTING2</a>, 1)) {};
<a name="l01733"></a>01733         }
<a name="l01734"></a>01734 
<a name="l01735"></a>01735         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a8770674a95f541c7f1184dd2c9281224">CFS_FAIL_GNI_GNP_CONNECTING3</a>)) {
<a name="l01736"></a>01736                 <span class="keywordflow">while</span> (<a class="code" href="libcfs__fail_8h.html#ad8a7f229bd17fa3ffeaed1fc21d5f6fb">CFS_FAIL_TIMEOUT</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a8770674a95f541c7f1184dd2c9281224">CFS_FAIL_GNI_GNP_CONNECTING3</a>, 1)) {};
<a name="l01737"></a>01737                 rc = <a class="code" href="libcfs__fail_8h.html#a2ef1cb02c9a3c9f5a23b1f818d3b99ba">cfs_fail_val</a> ? <a class="code" href="libcfs__fail_8h.html#a2ef1cb02c9a3c9f5a23b1f818d3b99ba">cfs_fail_val</a> : -ENOMEM;
<a name="l01738"></a>01738         } <span class="keywordflow">else</span> {
<a name="l01739"></a>01739                 rc = <a class="code" href="gnilnd__conn_8c.html#aa8afeb18eea207c710d60a0927c91c8d">kgnilnd_post_dgram</a>(peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>,
<a name="l01740"></a>01740                                         peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>, <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a48dd218ba2da7bccf230d76dad5a5b41">GNILND_CONNREQ_REQ</a>, 0);
<a name="l01741"></a>01741         }
<a name="l01742"></a>01742         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01743"></a>01743                 set_mb(peer-&gt;<a class="code" href="structkgn__peer.html#a8f7fe56c0cb630e7264b19bb87cd9363">gnp_last_dgram_errno</a>, rc);
<a name="l01744"></a>01744                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(failed, rc);
<a name="l01745"></a>01745         }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747         <span class="comment">/* while we&apos;re posting someone could have decided this peer/dgram needed to</span>
<a name="l01748"></a>01748 <span class="comment">         * die a quick death, so we check for state change and process accordingly */</span>
<a name="l01749"></a>01749 
<a name="l01750"></a>01750         write_lock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01751"></a>01751         <span class="keywordflow">if</span> (!<a class="code" href="gnilnd_8h.html#a71952850ccab3e2c426edf4eda0eaf6d">kgnilnd_peer_active</a>(peer) || peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> == <a class="code" href="gnilnd_8h.html#aed14cc5d3a6e153f6bf209d3783d617f">GNILND_PEER_NEEDS_DEATH</a>) {
<a name="l01752"></a>01752                 <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> == <a class="code" href="gnilnd_8h.html#aed14cc5d3a6e153f6bf209d3783d617f">GNILND_PEER_NEEDS_DEATH</a>) {
<a name="l01753"></a>01753                         peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> = <a class="code" href="gnilnd_8h.html#ab9d39ae93d56f49b06b2232f41a42cb5">GNILND_PEER_KILL</a>;
<a name="l01754"></a>01754                 }
<a name="l01755"></a>01755                 write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01756"></a>01756                 <span class="comment">/* positive RC to avoid dgram cleanup - we&apos;ll have to</span>
<a name="l01757"></a>01757 <span class="comment">                 * wait for the kgni GNI_POST_TERMINATED event to</span>
<a name="l01758"></a>01758 <span class="comment">                 * finish cleaning up */</span>
<a name="l01759"></a>01759                 rc = ESTALE;
<a name="l01760"></a>01760                 <a class="code" href="gnilnd_8h.html#a77d59ddd3a555acd5a63439fc7ebe121">kgnilnd_find_and_cancel_dgram</a>(peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>, peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>);
<a name="l01761"></a>01761                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l01762"></a>01762         }
<a name="l01763"></a>01763         peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> = <a class="code" href="gnilnd_8h.html#a747709150d65c21f6405d9be5e6bf313">GNILND_PEER_POSTED</a>;
<a name="l01764"></a>01764         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01765"></a>01765         <span class="comment">/* reaper thread will take care of any timeouts */</span>
<a name="l01766"></a>01766         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;waiting for connect to finish to %s rc %d\n&quot;</span>,
<a name="l01767"></a>01767                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>), rc);
<a name="l01768"></a>01768 
<a name="l01769"></a>01769         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01770"></a>01770 
<a name="l01771"></a>01771 failed:
<a name="l01772"></a>01772         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;connect to %s failed: rc %d \n&quot;</span>,
<a name="l01773"></a>01773                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>), rc);
<a name="l01774"></a>01774 out:
<a name="l01775"></a>01775         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01776"></a>01776 }
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 <span class="keywordtype">int</span>
<a name="l01779"></a><a class="code" href="gnilnd__conn_8c.html#ae38902809d0fdfab0506a61cb0e6aff5">01779</a> <a class="code" href="gnilnd__conn_8c.html#ae38902809d0fdfab0506a61cb0e6aff5">kgnilnd_finish_connect</a>(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01780"></a>01780 {
<a name="l01781"></a>01781         <a class="code" href="structkgn__conn.html">kgn_conn_t</a>        *conn = dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>;
<a name="l01782"></a>01782         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>         her_nid = dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>.<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>;
<a name="l01783"></a>01783         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>        *new_peer, *peer = NULL;
<a name="l01784"></a>01784         <a class="code" href="structkgn__tx.html">kgn_tx_t</a>          *tx;
<a name="l01785"></a>01785         <a class="code" href="structkgn__tx.html">kgn_tx_t</a>          *txn;
<a name="l01786"></a>01786         <a class="code" href="structkgn__mbox__info.html">kgn_mbox_info_t</a>   *mbox;
<a name="l01787"></a>01787         <span class="keywordtype">int</span>                rc;
<a name="l01788"></a>01788         <span class="keywordtype">int</span>                nstale;
<a name="l01789"></a>01789 
<a name="l01790"></a>01790         <span class="comment">/* try to find a peer that matches the nid we got in the connreq</span>
<a name="l01791"></a>01791 <span class="comment">         * kgnilnd_unpack_connreq makes sure that conn_in.gncr_srcnid is</span>
<a name="l01792"></a>01792 <span class="comment">         * HER and conn_out.gncr_srcnid is ME for both active and WC dgrams */</span>
<a name="l01793"></a>01793 
<a name="l01794"></a>01794         <span class="comment">/* assume this is a new peer  - it makes locking cleaner when it isn&apos;t */</span>
<a name="l01795"></a>01795         <span class="comment">/* no holding kgn_net_rw_sem - already are at the kgnilnd_dgram_mover level */</span>
<a name="l01796"></a>01796 
<a name="l01797"></a>01797         rc = <a class="code" href="gnilnd_8c.html#a5288902f8447984c991c5c8158655ccf">kgnilnd_create_peer_safe</a>(&amp;new_peer, her_nid, NULL, <a class="code" href="gnilnd_8h.html#a6f3060f398784542eb56f4e9813ab5ee">GNILND_RCA_NODE_UP</a>);
<a name="l01798"></a>01798         <span class="keywordflow">if</span> (rc != 0) {
<a name="l01799"></a>01799                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Can&apos;t create peer for %s\n&quot;</span>, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(her_nid));
<a name="l01800"></a>01800                 <span class="keywordflow">return</span> rc;
<a name="l01801"></a>01801         }
<a name="l01802"></a>01802 
<a name="l01803"></a>01803         write_lock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01804"></a>01804 
<a name="l01805"></a>01805         <span class="comment">/* this transfers ref from create_peer to the kgn_peer table */</span>
<a name="l01806"></a>01806         <a class="code" href="gnilnd_8c.html#af4db478154428769ee73bef14abf6697">kgnilnd_add_peer_locked</a>(her_nid, new_peer, &amp;peer);
<a name="l01807"></a>01807 
<a name="l01808"></a>01808         <span class="comment">/* if we found an existing peer, is it really ready for a new conn ? */</span>
<a name="l01809"></a>01809         <span class="keywordflow">if</span> (peer != new_peer) {
<a name="l01810"></a>01810                 <span class="comment">/* if this was an active connect attempt but we can&apos;t find a peer waiting for it</span>
<a name="l01811"></a>01811 <span class="comment">                 * we will dump in the trash */</span>
<a name="l01812"></a>01812 
<a name="l01813"></a>01813                 <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> == <a class="code" href="gnilnd_8h.html#a62fa3c755f2429f118559bd89c8d84d5">GNILND_PEER_IDLE</a> &amp;&amp; dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a> != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01814"></a>01814                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;dropping completed connreq for %s peer 0x%p-&gt;%s\n&quot;</span>,
<a name="l01815"></a>01815                                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(her_nid), peer, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>));
<a name="l01816"></a>01816                         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01817"></a>01817                         rc = ECANCELED;
<a name="l01818"></a>01818                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l01819"></a>01819                 }
<a name="l01820"></a>01820 
<a name="l01821"></a>01821                 <span class="comment">/* check to see if we can catch a connecting peer before it is</span>
<a name="l01822"></a>01822 <span class="comment">                 * removed from the connd_peers list - if not, we need to</span>
<a name="l01823"></a>01823 <span class="comment">                 * let the connreqs race and be handled by kgnilnd_conn_isdup_locked() */</span>
<a name="l01824"></a>01824                 <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> != <a class="code" href="gnilnd_8h.html#a62fa3c755f2429f118559bd89c8d84d5">GNILND_PEER_IDLE</a>) {
<a name="l01825"></a>01825                         spin_lock(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l01826"></a>01826                         <span class="keywordflow">if</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#a48a5b4723170789c6b4b5ce13a045401">gnp_connd_list</a>)) {
<a name="l01827"></a>01827                                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#a48a5b4723170789c6b4b5ce13a045401">gnp_connd_list</a>);
<a name="l01828"></a>01828                                 <span class="comment">/* drop connd ref */</span>
<a name="l01829"></a>01829                                 <a class="code" href="gnilnd_8h.html#a808a7a2d5c4b4612643d06cee039117b">kgnilnd_peer_decref</a>(peer);
<a name="l01830"></a>01830                         }
<a name="l01831"></a>01831                         spin_unlock(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l01832"></a>01832                         <span class="comment">/* clear rc to make sure we don&apos;t have fake error */</span>
<a name="l01833"></a>01833                         rc = 0;
<a name="l01834"></a>01834                 }
<a name="l01835"></a>01835 
<a name="l01836"></a>01836                 <span class="comment">/* no matter what, we are no longer waiting to connect this peer now */</span>
<a name="l01837"></a>01837                 peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> = <a class="code" href="gnilnd_8h.html#a62fa3c755f2429f118559bd89c8d84d5">GNILND_PEER_IDLE</a>;
<a name="l01838"></a>01838 
<a name="l01839"></a>01839                 <span class="comment">/* Refuse to duplicate an existing connection (both sides might try to</span>
<a name="l01840"></a>01840 <span class="comment">                 * connect at once).  NB we return success!  We _are_ connected so we</span>
<a name="l01841"></a>01841 <span class="comment">                 * _don&apos;t_ have any blocked txs to complete with failure. */</span>
<a name="l01842"></a>01842                 rc = <a class="code" href="gnilnd_8c.html#a3d953771b6f029ea638fb6e01b4805aa">kgnilnd_conn_isdup_locked</a>(peer, conn);
<a name="l01843"></a>01843                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01844"></a>01844                         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01845"></a>01845                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;Not creating duplicate connection to %s: %d\n&quot;</span>,
<a name="l01846"></a>01846                               <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(her_nid), rc);
<a name="l01847"></a>01847                         rc = EALREADY;
<a name="l01848"></a>01848                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc);
<a name="l01849"></a>01849                 }
<a name="l01850"></a>01850         }
<a name="l01851"></a>01851 
<a name="l01852"></a>01852         <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="structkgn__peer.html#abc2766b07b95aa11882dc98a4d9ffc7c">gnp_down</a> == <a class="code" href="gnilnd_8h.html#a2c1d5b265c4e274dfed0281e084e7880">GNILND_RCA_NODE_DOWN</a>) {
<a name="l01853"></a>01853                 <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;Received connection request from down nid %s\n&quot;</span>,
<a name="l01854"></a>01854                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(her_nid));
<a name="l01855"></a>01855                 peer-&gt;<a class="code" href="structkgn__peer.html#abc2766b07b95aa11882dc98a4d9ffc7c">gnp_down</a> = <a class="code" href="gnilnd_8h.html#a6f3060f398784542eb56f4e9813ab5ee">GNILND_RCA_NODE_UP</a>;
<a name="l01856"></a>01856         }
<a name="l01857"></a>01857 
<a name="l01858"></a>01858         nstale = <a class="code" href="gnilnd_8c.html#aaf924160cbe58b9a8a8173a2b28ce15d">kgnilnd_close_stale_conns_locked</a>(peer, conn);
<a name="l01859"></a>01859 
<a name="l01860"></a>01860         <span class="comment">/* either way with peer (new or existing), we are ok with ref counts here as the</span>
<a name="l01861"></a>01861 <span class="comment">         * kgnilnd_add_peer_locked will use our ref on new_peer (from create_peer_safe) as the</span>
<a name="l01862"></a>01862 <span class="comment">         * ref for the peer table. */</span>
<a name="l01863"></a>01863 
<a name="l01864"></a>01864         <span class="comment">/* at this point, the connection request is a winner */</span>
<a name="l01865"></a>01865 
<a name="l01866"></a>01866         <span class="comment">/* mark &apos;DONE&apos; to avoid cancel being called from release */</span>
<a name="l01867"></a>01867         dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> = <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950ab7d8300a4cbfd5b331e8018b4822f6f9">GNILND_DGRAM_DONE</a>;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869         <span class="comment">/* initialise timestamps before reaper looks at them */</span>
<a name="l01870"></a>01870         conn-&gt;<a class="code" href="structkgn__conn.html#aff3fc60b91fc8d1b8fee46d4e48476d0">gnc_last_rx</a> = conn-&gt;<a class="code" href="structkgn__conn.html#aae38163050ac7cb3e63b041a10ca27b7">gnc_last_rx_cq</a> = jiffies;
<a name="l01871"></a>01871 
<a name="l01872"></a>01872         <span class="comment">/* last_tx is initialized to jiffies - (keepalive*2) so that if the NOOP fails it will</span>
<a name="l01873"></a>01873 <span class="comment">         * immediatly send a NOOP in the reaper thread during the call to</span>
<a name="l01874"></a>01874 <span class="comment">         * kgnilnd_check_conn_timeouts_locked</span>
<a name="l01875"></a>01875 <span class="comment">         */</span>
<a name="l01876"></a>01876         conn-&gt;<a class="code" href="structkgn__conn.html#aa67e80660a876b283142eaed037524a3">gnc_last_tx</a> = jiffies - (<a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(<a class="code" href="gnilnd_8h.html#a6670bdbac27e1fc3c440c7c5b2d1cca0">GNILND_TO2KA</a>(conn-&gt;<a class="code" href="structkgn__conn.html#a6f6f71a37891a4697ad9737eed11105e">gnc_timeout</a>)) * 2);
<a name="l01877"></a>01877         conn-&gt;<a class="code" href="structkgn__conn.html#a2399b04e7ded56efe4ae3ba8a431e60a">gnc_state</a> = <a class="code" href="gnilnd_8h.html#a32505d3fed0776333ac6c392b9138840af38207cc4ea93ca58295feab9e5b06b1">GNILND_CONN_ESTABLISHED</a>;
<a name="l01878"></a>01878 
<a name="l01879"></a>01879         <span class="comment">/* save the dgram type used to establish this connection */</span>
<a name="l01880"></a>01880         conn-&gt;<a class="code" href="structkgn__conn.html#a9272f5179eadb5ba1e2910958f2f376f">gnc_dgram_type</a> = dgram-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a>;
<a name="l01881"></a>01881 
<a name="l01882"></a>01882         <span class="comment">/* refs are not transferred from dgram to tables, so increment to</span>
<a name="l01883"></a>01883 <span class="comment">         * take ownership */</span>
<a name="l01884"></a>01884         <a class="code" href="gnilnd_8h.html#a645ce9ec3f2e5a37df940b2e5f9ef25d">kgnilnd_conn_addref</a>(conn);
<a name="l01885"></a>01885         <a class="code" href="gnilnd_8h.html#ae39f61b875250339ce83d38a9067c201">kgnilnd_peer_addref</a>(peer);
<a name="l01886"></a>01886         conn-&gt;<a class="code" href="structkgn__conn.html#a73c5fd56c57297902f4203db1086cd87">gnc_peer</a> = peer;
<a name="l01887"></a>01887         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;conn-&gt;<a class="code" href="structkgn__conn.html#afa12a1f7e60ddf21d1bb24fbab3bd976">gnc_list</a>, &amp;peer-&gt;<a class="code" href="structkgn__peer.html#a75552d1bdc03d75d8daa6248fe289189">gnp_conns</a>);
<a name="l01888"></a>01888 
<a name="l01889"></a>01889         <a class="code" href="gnilnd_8h.html#a645ce9ec3f2e5a37df940b2e5f9ef25d">kgnilnd_conn_addref</a>(conn);               <span class="comment">/* +1 ref for conn table */</span>
<a name="l01890"></a>01890         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;conn-&gt;<a class="code" href="structkgn__conn.html#ae888fe73719c8307cadebc91e8e04325">gnc_hashlist</a>,
<a name="l01891"></a>01891                       <a class="code" href="gnilnd_8h.html#a57f7e674e39f232d908b58be61b04d1f">kgnilnd_cqid2connlist</a>(conn-&gt;<a class="code" href="structkgn__conn.html#a5ffc6d67b964fa813a576abcd3a7138f">gnc_cqid</a>));
<a name="l01892"></a>01892         <a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a4bc3ee6990c9f0654c1a2fef5afa02ca">kgn_conn_version</a>++;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894         <span class="comment">/* Dont send NOOP if fail_loc is set</span>
<a name="l01895"></a>01895 <span class="comment">         */</span>
<a name="l01896"></a>01896         <span class="keywordflow">if</span> (!<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#af3be81280a94adc1020d4b4a62e6fa4c">CFS_FAIL_GNI_ONLY_NOOP</a>)) {
<a name="l01897"></a>01897                 tx = <a class="code" href="gnilnd_8h.html#ae93b3c94aa7475bfc5569e626e3547bd">kgnilnd_new_tx_msg</a>(<a class="code" href="gnilnd_8h.html#a5722734fada0cbc8096711745ea8795b">GNILND_MSG_NOOP</a>, peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#ae1eebd7c97c508cd6215923dc828585b">gnn_ni</a>-&gt;<a class="code" href="structlnet__ni.html#a3220978c27f9626e971d2537a167795d">ni_nid</a>);
<a name="l01898"></a>01898                 <span class="keywordflow">if</span> (tx == NULL) {
<a name="l01899"></a>01899                         <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;can&apos;t get TX to initiate NOOP to %s\n&quot;</span>,
<a name="l01900"></a>01900                                 <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>));
<a name="l01901"></a>01901                 } <span class="keywordflow">else</span> {
<a name="l01902"></a>01902                         <a class="code" href="gnilnd_8h.html#ad640a1d09cb6b09e21f2a593cb1bbe33">kgnilnd_queue_tx</a>(conn, tx);
<a name="l01903"></a>01903                 }
<a name="l01904"></a>01904         }
<a name="l01905"></a>01905 
<a name="l01906"></a>01906         <span class="comment">/* Schedule all packets blocking for a connection */</span>
<a name="l01907"></a>01907         <a class="code" href="list_8h.html#ac3f72d6bd5144c7970824813810d2da1" title="Iterate over a list of given type safe against removal of list entry.">list_for_each_entry_safe</a>(tx, txn, &amp;peer-&gt;<a class="code" href="structkgn__peer.html#a1f5c32f5e78499df976c91b72725a72d">gnp_tx_queue</a>, tx_list) {
<a name="l01908"></a>01908                 <span class="comment">/* lock held here is the peer_conn lock */</span>
<a name="l01909"></a>01909                 <a class="code" href="gnilnd_8h.html#aef4c03cda84c85ea98c1ffcf8266a331">kgnilnd_tx_del_state_locked</a>(tx, peer, NULL, <a class="code" href="gnilnd_8h.html#ac9f81a13a3450db4fdb51dd5da9038f3ad4955dee9ea31427eea5247997e9823f">GNILND_TX_ALLOCD</a>);
<a name="l01910"></a>01910                 <a class="code" href="gnilnd_8h.html#ad640a1d09cb6b09e21f2a593cb1bbe33">kgnilnd_queue_tx</a>(conn, tx);
<a name="l01911"></a>01911         }
<a name="l01912"></a>01912 
<a name="l01913"></a>01913         <span class="comment">/* If this is an active connection lets mark its timestamp on the MBoX */</span>
<a name="l01914"></a>01914         <span class="keywordflow">if</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a> != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01915"></a>01915                 mbox = &amp;conn-&gt;<a class="code" href="structkgn__conn.html#a44d0c57f674b15422b998eae0227b57a">gnc_fma_blk</a>-&gt;<a class="code" href="structkgn__fma__memblock.html#a4a4b79d2d90189d3d56b9e449644322f">gnm_mbox_info</a>[conn-&gt;<a class="code" href="structkgn__conn.html#a6170b6853d316b0f0c41a29eee87f10f">gnc_mbox_id</a>];
<a name="l01916"></a>01916                 <span class="comment">/* conn-&gt;gnc_last_rx is jiffies it better exist as it was just set */</span>
<a name="l01917"></a>01917                 mbox-&gt;<a class="code" href="structkgn__mbox__info.html#a309801504cecba859b4cb5bcc3b58ed7">mbx_release_purg_active_dgram</a> = conn-&gt;<a class="code" href="structkgn__conn.html#aff3fc60b91fc8d1b8fee46d4e48476d0">gnc_last_rx</a>;
<a name="l01918"></a>01918         }
<a name="l01919"></a>01919 
<a name="l01920"></a>01920         <span class="comment">/* Bug 765042: wake up scheduler for a race with finish_connect and</span>
<a name="l01921"></a>01921 <span class="comment">         * complete_conn_closed with a conn in purgatory</span>
<a name="l01922"></a>01922 <span class="comment">         * since we can&apos;t use CFS_RACE due to mutex_holds in kgnilnd_process_conns,</span>
<a name="l01923"></a>01923 <span class="comment">         * we just check for set and then clear */</span>
<a name="l01924"></a>01924         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#ac5f7db2d949d95dfa6d0747a0bb658a6">CFS_FAIL_GNI_FINISH_PURG</a>)) {
<a name="l01925"></a>01925                 <a class="code" href="libcfs__fail_8h.html#abfc2659bba684b2bc5d828ef96079efd">cfs_fail_loc</a> = 0x0;
<a name="l01926"></a>01926                 <span class="comment">/* get scheduler thread moving again */</span>
<a name="l01927"></a>01927                 <a class="code" href="gnilnd_8h.html#abf4ddc3a20f7e84393ef51bd7a78902e">kgnilnd_schedule_device</a>(conn-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>);
<a name="l01928"></a>01928         }
<a name="l01929"></a>01929 
<a name="l01930"></a>01930         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;New conn 0x%p-&gt;%s dev %d\n&quot;</span>,
<a name="l01931"></a>01931                conn, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(her_nid), conn-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>-&gt;<a class="code" href="structkgn__device.html#a121a69ed91d615c6eec65ca3605545eb">gnd_id</a>);
<a name="l01932"></a>01932 
<a name="l01933"></a>01933         <span class="comment">/* make sure we reset peer reconnect interval now that we have a good conn */</span>
<a name="l01934"></a>01934         <a class="code" href="gnilnd_8c.html#a9d259d3b924feedc8538d96bfbebf96b">kgnilnd_peer_alive</a>(peer);
<a name="l01935"></a>01935         peer-&gt;<a class="code" href="structkgn__peer.html#a49b120572b756d5c7a1aa6c23b7576a5">gnp_reconnect_interval</a> = 0;
<a name="l01936"></a>01936 
<a name="l01937"></a>01937         <span class="comment">/* clear the unlink attribute if we dont clear it kgnilnd_del_conn_or_peer will wait</span>
<a name="l01938"></a>01938 <span class="comment">         * on the atomic forever</span>
<a name="l01939"></a>01939 <span class="comment">         */</span>
<a name="l01940"></a>01940         <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="structkgn__peer.html#a893f92edc7c2b630c57773d0648b9936">gnp_pending_unlink</a>) {
<a name="l01941"></a>01941                 peer-&gt;<a class="code" href="structkgn__peer.html#a893f92edc7c2b630c57773d0648b9936">gnp_pending_unlink</a> = 0;
<a name="l01942"></a>01942                 <a class="code" href="gnilnd_8h.html#a16c74fde7b75f50db70c46ff5357d714">kgnilnd_admin_decref</a>(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#aca931f2a78c5ed49ab236139c19a701b">kgn_npending_unlink</a>);
<a name="l01943"></a>01943                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;Clearing peer unlink %p\n&quot;</span>,peer);
<a name="l01944"></a>01944         }
<a name="l01945"></a>01945 
<a name="l01946"></a>01946         <span class="comment">/* add ref to make it hang around until after we drop the lock */</span>
<a name="l01947"></a>01947         <a class="code" href="gnilnd_8h.html#a645ce9ec3f2e5a37df940b2e5f9ef25d">kgnilnd_conn_addref</a>(conn);
<a name="l01948"></a>01948 
<a name="l01949"></a>01949         <span class="comment">/* Once the peer_conn lock is dropped, the conn could actually move into</span>
<a name="l01950"></a>01950 <span class="comment">         * CLOSING-&gt;CLOSED-&gt;DONE in the scheduler thread, so hold the</span>
<a name="l01951"></a>01951 <span class="comment">         * lock until we are really done */</span>
<a name="l01952"></a>01952         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01953"></a>01953 
<a name="l01954"></a>01954         <span class="comment">/* Notify LNET that we now have a working connection to this peer.</span>
<a name="l01955"></a>01955 <span class="comment">         * This is a Cray extension to the &quot;standard&quot; LND behavior. */</span>
<a name="l01956"></a>01956         <a class="code" href="lib-lnet_8h.html#aabeaf1606b15ff28ecf3508955d64253">lnet_notify</a>(peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#ae1eebd7c97c508cd6215923dc828585b">gnn_ni</a>, peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>,
<a name="l01957"></a>01957                      1, <a class="code" href="linux-time_8h.html#adc63a7977338536b551ccc795e5a9148">cfs_time_current</a>());
<a name="l01958"></a>01958 
<a name="l01959"></a>01959         <span class="comment">/* drop our &apos;hold&apos; ref */</span>
<a name="l01960"></a>01960         <a class="code" href="gnilnd_8h.html#a8660e9cbb0dc158d5d7a36f7dc86e184">kgnilnd_conn_decref</a>(conn);
<a name="l01961"></a>01961 
<a name="l01962"></a>01962 out:
<a name="l01963"></a>01963         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01964"></a>01964 }
<a name="l01965"></a>01965 
<a name="l01966"></a>01966 <span class="keywordtype">void</span>
<a name="l01967"></a><a class="code" href="gnilnd__conn_8c.html#a86e22aacd3cdd74975cce94e4a895aef">01967</a> <a class="code" href="gnilnd__conn_8c.html#a86e22aacd3cdd74975cce94e4a895aef">kgnilnd_send_nak</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> dst_nid, <span class="keywordtype">int</span> <a class="code" href="it__test_8c.html#ae70cde843eddd6d7c493335f157da127">error</a>)
<a name="l01968"></a>01968 {
<a name="l01969"></a>01969         <span class="keywordtype">int</span>              rc = 0;
<a name="l01970"></a>01970         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01971"></a>01971 
<a name="l01972"></a>01972         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dst_nid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, <span class="stringliteral">&quot;bad dst_nid %s\n&quot;</span>, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dst_nid));
<a name="l01973"></a>01973 
<a name="l01974"></a>01974         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;NAK to %s errno %d\n&quot;</span>, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dst_nid), error);
<a name="l01975"></a>01975 
<a name="l01976"></a>01976         rc = <a class="code" href="gnilnd__conn_8c.html#aa8afeb18eea207c710d60a0927c91c8d">kgnilnd_post_dgram</a>(dev, dst_nid, <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a94d5a8f2d421f134365d87243edfed68">GNILND_CONNREQ_NAK</a>, error);
<a name="l01977"></a>01977 
<a name="l01978"></a>01978         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01979"></a>01979                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;NAK to %s failed: rc %d \n&quot;</span>, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dst_nid), rc);
<a name="l01980"></a>01980         }
<a name="l01981"></a>01981         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l01982"></a>01982 }
<a name="l01983"></a>01983 
<a name="l01984"></a>01984 <span class="keywordtype">int</span>
<a name="l01985"></a><a class="code" href="gnilnd__conn_8c.html#ae37e1285efdb926687ed59dda02f9957">01985</a> <a class="code" href="gnilnd__conn_8c.html#ae37e1285efdb926687ed59dda02f9957">kgnilnd_process_nak</a>(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram)
<a name="l01986"></a>01986 {
<a name="l01987"></a>01987         <a class="code" href="structkgn__connreq.html">kgn_connreq_t</a>     *connreq = &amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>;
<a name="l01988"></a>01988         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>         src_nid = connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>;
<a name="l01989"></a>01989         <span class="keywordtype">int</span>                errno = connreq-&gt;<a class="code" href="structkgn__connreq.html#a60aca351f9aeb0506874026d3986e1e6">gncr_nakdata</a>.<a class="code" href="structkgn__nak__data.html#ab642014e904809eb127f35c63b981c70">gnnd_errno</a>;
<a name="l01990"></a>01990         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>        *peer;
<a name="l01991"></a>01991         <span class="keywordtype">int</span>                rc = 0;
<a name="l01992"></a>01992 
<a name="l01993"></a>01993         write_lock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l01994"></a>01994 
<a name="l01995"></a>01995         peer = <a class="code" href="gnilnd_8c.html#ae3f81dd4cc7e7702064be92557b3aa62">kgnilnd_find_peer_locked</a>(src_nid);
<a name="l01996"></a>01996         <span class="keywordflow">if</span> (peer == NULL) {
<a name="l01997"></a>01997                 <span class="comment">/* we likely dropped him from bad data when we processed</span>
<a name="l01998"></a>01998 <span class="comment">                 * the original REQ */</span>
<a name="l01999"></a>01999                 write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l02000"></a>02000                 <span class="keywordflow">return</span> -EBADSLT;
<a name="l02001"></a>02001         }
<a name="l02002"></a>02002 
<a name="l02003"></a>02003         <span class="comment">/* need to check peerstamp/connstamp against the ones we find</span>
<a name="l02004"></a>02004 <span class="comment">         * to make sure we don&apos;t close new (and good?) conns that we</span>
<a name="l02005"></a>02005 <span class="comment">         * formed after this connreq failed */</span>
<a name="l02006"></a>02006         <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> == <a class="code" href="gnilnd_8h.html#a62fa3c755f2429f118559bd89c8d84d5">GNILND_PEER_IDLE</a>) {
<a name="l02007"></a>02007                 <a class="code" href="structkgn__conn.html">kgn_conn_t</a>        conn;
<a name="l02008"></a>02008 
<a name="l02009"></a>02009                 <span class="keywordflow">if</span> (<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#a75552d1bdc03d75d8daa6248fe289189">gnp_conns</a>)) {
<a name="l02010"></a>02010                         <span class="comment">/* assume already procced datagram and it barfed up</span>
<a name="l02011"></a>02011 <span class="comment">                         * on this side too */</span>
<a name="l02012"></a>02012                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;dropping NAK from %s; &quot;</span>
<a name="l02013"></a>02013                                <span class="stringliteral">&quot;peer %s is already not connected\n&quot;</span>,
<a name="l02014"></a>02014                                 <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>),
<a name="l02015"></a>02015                                 <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>));
<a name="l02016"></a>02016                         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l02017"></a>02017                         <span class="keywordflow">return</span> 0;
<a name="l02018"></a>02018                 }
<a name="l02019"></a>02019 
<a name="l02020"></a>02020                 <span class="comment">/* stub up a connection with the connreq XXX_stamps to allow</span>
<a name="l02021"></a>02021 <span class="comment">                 * use to use close_stale_conns_locked */</span>
<a name="l02022"></a>02022                 conn.<a class="code" href="structkgn__conn.html#a04cf09f9875d5dd418f235adbe2a108a">gnc_peerstamp</a> = connreq-&gt;<a class="code" href="structkgn__connreq.html#a3376a452a7080b8be6d9d358dd846d55">gncr_peerstamp</a>;
<a name="l02023"></a>02023                 conn.<a class="code" href="structkgn__conn.html#a462ce2a0b3fc489c4822a43245dc27c2">gnc_my_connstamp</a> = connreq-&gt;<a class="code" href="structkgn__connreq.html#a68e94324894ead083cc6f2a2492475dd">gncr_connstamp</a>;
<a name="l02024"></a>02024                 conn.<a class="code" href="structkgn__conn.html#acd111c5bef285f78421eac8121b25f7a">gnc_peer_connstamp</a> = connreq-&gt;<a class="code" href="structkgn__connreq.html#a68e94324894ead083cc6f2a2492475dd">gncr_connstamp</a>;
<a name="l02025"></a>02025                 conn.<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a> = peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>;
<a name="l02026"></a>02026 
<a name="l02027"></a>02027                 rc = <a class="code" href="gnilnd_8c.html#aaf924160cbe58b9a8a8173a2b28ce15d">kgnilnd_close_stale_conns_locked</a>(peer, &amp;conn);
<a name="l02028"></a>02028 
<a name="l02029"></a>02029                 <a class="code" href="libcfs__debug_8h.html#a43240b2ab1235407f143ed4582ea1f75">LCONSOLE_INFO</a>(<span class="stringliteral">&quot;Received NAK from %s for %s errno %d; &quot;</span>
<a name="l02030"></a>02030                         <span class="stringliteral">&quot;closed %d connections\n&quot;</span>,
<a name="l02031"></a>02031                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>),
<a name="l02032"></a>02032                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>), errno, rc);
<a name="l02033"></a>02033         } <span class="keywordflow">else</span> {
<a name="l02034"></a>02034                 spin_lock(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02035"></a>02035 
<a name="l02036"></a>02036                 <span class="keywordflow">if</span> (<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#a48a5b4723170789c6b4b5ce13a045401">gnp_connd_list</a>)) {
<a name="l02037"></a>02037                         <span class="comment">/* if peer isn&apos;t on waiting list, try to find one to nuke */</span>
<a name="l02038"></a>02038                         rc = <a class="code" href="gnilnd_8h.html#a77d59ddd3a555acd5a63439fc7ebe121">kgnilnd_find_and_cancel_dgram</a>(peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>,
<a name="l02039"></a>02039                                                            peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>);
<a name="l02040"></a>02040 
<a name="l02041"></a>02041                         <span class="keywordflow">if</span> (rc) {
<a name="l02042"></a>02042                                 <a class="code" href="libcfs__debug_8h.html#a43240b2ab1235407f143ed4582ea1f75">LCONSOLE_INFO</a>(<span class="stringliteral">&quot;Received NAK from %s for %s errno %d; &quot;</span>
<a name="l02043"></a>02043                                         <span class="stringliteral">&quot;canceled pending connect request\n&quot;</span>,
<a name="l02044"></a>02044                                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>),
<a name="l02045"></a>02045                                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(connreq-&gt;<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>), errno);
<a name="l02046"></a>02046                         }
<a name="l02047"></a>02047 
<a name="l02048"></a>02048                         <span class="comment">/* if we can&apos;t find a waiting dgram, we just drop the nak - the conn</span>
<a name="l02049"></a>02049 <span class="comment">                         * connect must have failed (didn&apos;t find conn above and clear connecting</span>
<a name="l02050"></a>02050 <span class="comment">                         * -- so nothing to do besides drop */</span>
<a name="l02051"></a>02051                 } <span class="keywordflow">else</span> {
<a name="l02052"></a>02052                         <span class="comment">/* peer is on list, meaning it is a new connect attempt from the one</span>
<a name="l02053"></a>02053 <span class="comment">                         * we started that generated the NAK - so just drop NAK */</span>
<a name="l02054"></a>02054 
<a name="l02055"></a>02055                         <span class="comment">/* use negative to prevent error message */</span>
<a name="l02056"></a>02056                         rc = -EAGAIN;
<a name="l02057"></a>02057                 }
<a name="l02058"></a>02058                 spin_unlock(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>-&gt;<a class="code" href="structkgn__conn.html#a66e68f130a38c6d57141b6d40a638942">gnc_device</a>-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02059"></a>02059         }
<a name="l02060"></a>02060 
<a name="l02061"></a>02061         <span class="comment">/* success! we found a peer and at least marked pending_nak */</span>
<a name="l02062"></a>02062         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l02063"></a>02063 
<a name="l02064"></a>02064         <span class="keywordflow">return</span> rc;
<a name="l02065"></a>02065 }
<a name="l02066"></a>02066 
<a name="l02067"></a>02067 <span class="keywordtype">int</span>
<a name="l02068"></a><a class="code" href="gnilnd__conn_8c.html#aac4c421e03c141b9b60550d13a1cf115">02068</a> <a class="code" href="gnilnd__conn_8c.html#aac4c421e03c141b9b60550d13a1cf115">kgnilnd_process_connreq</a>(<a class="code" href="structkgn__dgram.html">kgn_dgram_t</a> *dgram, <span class="keywordtype">int</span> *needs_nak)
<a name="l02069"></a>02069 {
<a name="l02070"></a>02070         <span class="keywordtype">int</span>                      rc;
<a name="l02071"></a>02071 
<a name="l02072"></a>02072         rc = <a class="code" href="gnilnd__conn_8c.html#a536fe0e2808756e2a3e7ee066409012a">kgnilnd_unpack_connreq</a>(dgram);
<a name="l02073"></a>02073         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02074"></a>02074                 <span class="keywordflow">if</span> (rc != -EBADF) {
<a name="l02075"></a>02075                         <span class="comment">/* only NAK if we have good srcnid to use */</span>
<a name="l02076"></a>02076                         *needs_nak = 1;
<a name="l02077"></a>02077                 }
<a name="l02078"></a>02078                 <span class="keywordflow">goto</span> connreq_out;
<a name="l02079"></a>02079         }
<a name="l02080"></a>02080 
<a name="l02081"></a>02081         <span class="keywordflow">switch</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>.<a class="code" href="structkgn__connreq.html#a3f5e7b13bcf2d9713f74a9a1b9826ee6">gncr_type</a>) {
<a name="l02082"></a>02082         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a48dd218ba2da7bccf230d76dad5a5b41">GNILND_CONNREQ_REQ</a>:
<a name="l02083"></a>02083                 <span class="comment">/* wire up peer &amp; conn, send queued TX */</span>
<a name="l02084"></a>02084                 rc = <a class="code" href="gnilnd__conn_8c.html#ae38902809d0fdfab0506a61cb0e6aff5">kgnilnd_finish_connect</a>(dgram);
<a name="l02085"></a>02085 
<a name="l02086"></a>02086                 <span class="comment">/* don&apos;t nak when the nid is hosed */</span>
<a name="l02087"></a>02087                 <span class="keywordflow">if</span> ((rc &lt; 0)) {
<a name="l02088"></a>02088                         *needs_nak = 1;
<a name="l02089"></a>02089                 }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091                 <span class="keywordflow">break</span>;
<a name="l02092"></a>02092         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a94d5a8f2d421f134365d87243edfed68">GNILND_CONNREQ_NAK</a>:
<a name="l02093"></a>02093                 rc = <a class="code" href="gnilnd__conn_8c.html#ae37e1285efdb926687ed59dda02f9957">kgnilnd_process_nak</a>(dgram);
<a name="l02094"></a>02094                 <span class="comment">/* return early to prevent reconnect bump */</span>
<a name="l02095"></a>02095                 <span class="keywordflow">return</span> rc;
<a name="l02096"></a>02096         <span class="keywordflow">default</span>:
<a name="l02097"></a>02097                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;unexpected connreq type %s (%d) from %s\n&quot;</span>,
<a name="l02098"></a>02098                         <a class="code" href="gnilnd_8h.html#ab194f631fecd0ca00918602b420409ca">kgnilnd_connreq_type2str</a>(&amp;dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>),
<a name="l02099"></a>02099                         dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>.<a class="code" href="structkgn__connreq.html#a3f5e7b13bcf2d9713f74a9a1b9826ee6">gncr_type</a>,
<a name="l02100"></a>02100                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>.<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>));
<a name="l02101"></a>02101                 rc = -EINVAL;
<a name="l02102"></a>02102                 *needs_nak = 1;
<a name="l02103"></a>02103                 <span class="keywordflow">break</span>;
<a name="l02104"></a>02104         }
<a name="l02105"></a>02105 
<a name="l02106"></a>02106 connreq_out:
<a name="l02107"></a>02107         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l02108"></a>02108 }
<a name="l02109"></a>02109 
<a name="l02110"></a>02110 <span class="keywordtype">int</span>
<a name="l02111"></a><a class="code" href="gnilnd__conn_8c.html#a3f70068d7579cec1a1c9e9d45af27ef9">02111</a> <a class="code" href="gnilnd__conn_8c.html#a3f70068d7579cec1a1c9e9d45af27ef9">kgnilnd_probe_and_process_dgram</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l02112"></a>02112 {
<a name="l02113"></a>02113         <span class="keywordtype">int</span>                      rc;
<a name="l02114"></a>02114         <span class="keywordtype">int</span>                      needs_nak = 0;
<a name="l02115"></a>02115         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>               nak_dstnid = <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>;
<a name="l02116"></a>02116         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>               orig_dstnid;
<a name="l02117"></a>02117         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>             *dgram = NULL;
<a name="l02118"></a>02118         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>              *peer;
<a name="l02119"></a>02119         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02120"></a>02120 
<a name="l02121"></a>02121         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a5313a608557cceb66011718ef700cb07">CFS_FAIL_GNI_PAUSE_DGRAM_COMP</a>)) {
<a name="l02122"></a>02122                 rc = 0;
<a name="l02123"></a>02123         } <span class="keywordflow">else</span> {
<a name="l02124"></a>02124                 rc = <a class="code" href="gnilnd__conn_8c.html#ad2689ebc9a3f361b4133a42b491cf11c">kgnilnd_probe_for_dgram</a>(dev, &amp;dgram);
<a name="l02125"></a>02125         }
<a name="l02126"></a>02126 
<a name="l02127"></a>02127         <span class="keywordflow">if</span> (rc == 0) {
<a name="l02128"></a>02128                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l02129"></a>02129         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02130"></a>02130                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(inform_peer, rc);
<a name="l02131"></a>02131         } <span class="keywordflow">else</span> {
<a name="l02132"></a>02132                 <span class="comment">/* rc &gt; 1 means it did something, reset for this func  */</span>
<a name="l02133"></a>02133                 rc = 0;
<a name="l02134"></a>02134         }
<a name="l02135"></a>02135 
<a name="l02136"></a>02136         <span class="keywordflow">switch</span> (dgram-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a>) {
<a name="l02137"></a>02137         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a>:
<a name="l02138"></a>02138         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26a4a4f3521baf43868818329dad6d38e60">GNILND_DGRAM_REQ</a>:
<a name="l02139"></a>02139                 rc = <a class="code" href="gnilnd__conn_8c.html#aac4c421e03c141b9b60550d13a1cf115">kgnilnd_process_connreq</a>(dgram, &amp;needs_nak);
<a name="l02140"></a>02140                 <span class="keywordflow">break</span>;
<a name="l02141"></a>02141         <span class="keywordflow">case</span> <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26a8f76fc062376a06723fcaacc88d7b4e2">GNILND_DGRAM_NAK</a>:
<a name="l02142"></a>02142                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aeeeea1864fc878a5feed7940fd096adc">D_NETTRACE</a>, <span class="stringliteral">&quot;NAK to %s done\n&quot;</span>,
<a name="l02143"></a>02143                         <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>));
<a name="l02144"></a>02144                 <span class="keywordflow">break</span>;
<a name="l02145"></a>02145         <span class="keywordflow">default</span>:
<a name="l02146"></a>02146                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;unknown datagram type %s (%d)\n&quot;</span>,
<a name="l02147"></a>02147                        <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram), dgram-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a>);
<a name="l02148"></a>02148                 <span class="keywordflow">break</span>;
<a name="l02149"></a>02149         }
<a name="l02150"></a>02150 
<a name="l02151"></a>02151         <span class="comment">/* stash data to use after releasing current datagram */</span>
<a name="l02152"></a>02152         <span class="comment">/* don&apos;t stash net - we are operating on a net already,</span>
<a name="l02153"></a>02153 <span class="comment">         * so the lock on rw_net_lock is sufficient */</span>
<a name="l02154"></a>02154 
<a name="l02155"></a>02155         nak_dstnid = dgram-&gt;<a class="code" href="structkgn__dgram.html#aa6bb912988e701441979a9812545abe5">gndg_conn_in</a>.<a class="code" href="structkgn__connreq.html#adf22cc545a3496c33adf782dfedcb844">gncr_srcnid</a>;
<a name="l02156"></a>02156 
<a name="l02157"></a>02157 inform_peer:
<a name="l02158"></a>02158         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(dgram != NULL, <span class="stringliteral">&quot;dgram 0x%p rc %d needs_nak %d\n&quot;</span>, dgram, rc, needs_nak);
<a name="l02159"></a>02159 
<a name="l02160"></a>02160         orig_dstnid = dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>;
<a name="l02161"></a>02161 
<a name="l02162"></a>02162         <a class="code" href="gnilnd_8h.html#a7a7b634c7c8164ec658dac434ddcb7fb">kgnilnd_release_dgram</a>(dev, dgram, 0);
<a name="l02163"></a>02163 
<a name="l02164"></a>02164         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;cleaning up dgram to %s, rc %d\n&quot;</span>,
<a name="l02165"></a>02165                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(orig_dstnid), rc);
<a name="l02166"></a>02166 
<a name="l02167"></a>02167         <span class="comment">/* if this was a WC_REQ that matched an existing peer, it&apos;ll get marked done</span>
<a name="l02168"></a>02168 <span class="comment">         * in kgnilnd_finish_connect - if errors are from before we get to there,</span>
<a name="l02169"></a>02169 <span class="comment">         * we just drop as it is a WC_REQ - the peer CAN&apos;T be waiting for it */</span>
<a name="l02170"></a>02170         <span class="keywordflow">if</span> ((orig_dstnid != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) &amp;&amp; (rc &lt; 0)) {
<a name="l02171"></a>02171                 <span class="comment">/* if we have a negative rc, we want to find a peer to inform about</span>
<a name="l02172"></a>02172 <span class="comment">                 * the bad connection attempt. Sorry buddy, better luck next time! */</span>
<a name="l02173"></a>02173 
<a name="l02174"></a>02174                 write_lock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l02175"></a>02175                 peer = <a class="code" href="gnilnd_8c.html#ae3f81dd4cc7e7702064be92557b3aa62">kgnilnd_find_peer_locked</a>(orig_dstnid);
<a name="l02176"></a>02176 
<a name="l02177"></a>02177                 <span class="keywordflow">if</span> (peer != NULL) {
<a name="l02178"></a>02178                         <span class="comment">/* add ref to make sure he stays around past the possible unlink</span>
<a name="l02179"></a>02179 <span class="comment">                         * so we can tell LNet about him */</span>
<a name="l02180"></a>02180                         <a class="code" href="gnilnd_8h.html#ae39f61b875250339ce83d38a9067c201">kgnilnd_peer_addref</a>(peer);
<a name="l02181"></a>02181 
<a name="l02182"></a>02182                         <span class="comment">/* if he still cares about the outstanding connect */</span>
<a name="l02183"></a>02183                         <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> &gt;= <a class="code" href="gnilnd_8h.html#a08aa73ed62411a3ea5c771b0d1e8401f">GNILND_PEER_CONNECT</a>) {
<a name="l02184"></a>02184                                 <span class="comment">/* check if he is on the connd list and remove.. */</span>
<a name="l02185"></a>02185                                 spin_lock(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02186"></a>02186                                 <span class="keywordflow">if</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#a48a5b4723170789c6b4b5ce13a045401">gnp_connd_list</a>)) {
<a name="l02187"></a>02187                                         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#a48a5b4723170789c6b4b5ce13a045401">gnp_connd_list</a>);
<a name="l02188"></a>02188                                         <span class="comment">/* drop connd ref */</span>
<a name="l02189"></a>02189                                         <a class="code" href="gnilnd_8h.html#a808a7a2d5c4b4612643d06cee039117b">kgnilnd_peer_decref</a>(peer);
<a name="l02190"></a>02190                                 }
<a name="l02191"></a>02191                                 spin_unlock(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#ad2b6b6968e8e1712e1a4e328a8190a30">gnp_net</a>-&gt;<a class="code" href="structkgn__net.html#a00bbcf50be777caee6eae29af7131a56">gnn_dev</a>-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02192"></a>02192 
<a name="l02193"></a>02193                                 <span class="comment">/* clear gnp_connecting so we don&apos;t have a non-connecting peer</span>
<a name="l02194"></a>02194 <span class="comment">                                 * on gnd_connd_list */</span>
<a name="l02195"></a>02195                                 peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> = <a class="code" href="gnilnd_8h.html#a62fa3c755f2429f118559bd89c8d84d5">GNILND_PEER_IDLE</a>;
<a name="l02196"></a>02196 
<a name="l02197"></a>02197                                 set_mb(peer-&gt;<a class="code" href="structkgn__peer.html#a8f7fe56c0cb630e7264b19bb87cd9363">gnp_last_dgram_errno</a>, rc);
<a name="l02198"></a>02198 
<a name="l02199"></a>02199                                 <a class="code" href="gnilnd_8c.html#ab4ac8ae1e5171241dc45b64017af6921">kgnilnd_peer_increase_reconnect_locked</a>(peer);
<a name="l02200"></a>02200                         }
<a name="l02201"></a>02201                 }
<a name="l02202"></a>02202                 write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l02203"></a>02203 
<a name="l02204"></a>02204                 <span class="comment">/* now that we are outside the lock, tell Mommy */</span>
<a name="l02205"></a>02205                 <span class="keywordflow">if</span> (peer != NULL) {
<a name="l02206"></a>02206                         <a class="code" href="gnilnd_8c.html#a4c259e822949bb03bc9c48dc2ed1f055">kgnilnd_peer_notify</a>(peer, rc, 0);
<a name="l02207"></a>02207                         <a class="code" href="gnilnd_8h.html#a808a7a2d5c4b4612643d06cee039117b">kgnilnd_peer_decref</a>(peer);
<a name="l02208"></a>02208                 }
<a name="l02209"></a>02209         }
<a name="l02210"></a>02210 
<a name="l02211"></a>02211         <span class="keywordflow">if</span> (needs_nak) {
<a name="l02212"></a>02212                 <a class="code" href="gnilnd__conn_8c.html#a86e22aacd3cdd74975cce94e4a895aef">kgnilnd_send_nak</a>(dev, nak_dstnid, rc);
<a name="l02213"></a>02213         }
<a name="l02214"></a>02214 
<a name="l02215"></a>02215         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(1);
<a name="l02216"></a>02216 }
<a name="l02217"></a>02217 
<a name="l02218"></a>02218 <span class="keywordtype">void</span>
<a name="l02219"></a><a class="code" href="gnilnd__conn_8c.html#a46918fd725742a2127db5e1179765909">02219</a> <a class="code" href="gnilnd__conn_8c.html#a46918fd725742a2127db5e1179765909">kgnilnd_reaper_dgram_check</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l02220"></a>02220 {
<a name="l02221"></a>02221         <a class="code" href="structkgn__dgram.html">kgn_dgram_t</a>    *dgram, *tmp;
<a name="l02222"></a>02222         <span class="keywordtype">int</span>             i;
<a name="l02223"></a>02223 
<a name="l02224"></a>02224         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l02225"></a>02225 
<a name="l02226"></a>02226         <span class="keywordflow">for</span> (i = 0; i &lt; (*<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#acc193b5b5171465a5a45ec26665c4c63">kgn_peer_hash_size</a> - 1); i++) {
<a name="l02227"></a>02227                 <a class="code" href="list_8h.html#ac3f72d6bd5144c7970824813810d2da1" title="Iterate over a list of given type safe against removal of list entry.">list_for_each_entry_safe</a>(dgram, tmp, &amp;dev-&gt;<a class="code" href="structkgn__device.html#ad0a7f62b9d3c4fb47b0e8994aebe3757">gnd_dgrams</a>[i], gndg_list) {
<a name="l02228"></a>02228                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            <a class="code" href="createmany_8c.html#a5602e9c6b2da7a1db11ed8a76d19fde3">now</a> = jiffies;
<a name="l02229"></a>02229                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            <a class="code" href="gnilnd__modparams_8c.html#a493b57f443cc38b3d3df9c1e584d9d82">timeout</a>;
<a name="l02230"></a>02230 
<a name="l02231"></a>02231                         <span class="comment">/* don&apos;t timeout stuff if the network is mucked or shutting down */</span>
<a name="l02232"></a>02232                         <span class="keywordflow">if</span> (<a class="code" href="gnilnd_8h.html#a72094302ab878b73587cd15b16b5569b">kgnilnd_check_hw_quiesce</a>()) {
<a name="l02233"></a>02233                                 <span class="keywordflow">break</span>;
<a name="l02234"></a>02234                         }
<a name="l02235"></a>02235 
<a name="l02236"></a>02236                         <span class="keywordflow">if</span> ((dgram-&gt;<a class="code" href="structkgn__dgram.html#a8b0ce0b83a279a3190ab756895b9db0f">gndg_state</a> != <a class="code" href="gnilnd_8h.html#ae1d78d2b5773655ce426324d420bb950a16f6b012f4ea48a0a117372ddebbae18">GNILND_DGRAM_POSTED</a>) ||
<a name="l02237"></a>02237                             (dgram-&gt;<a class="code" href="structkgn__dgram.html#a9fbb47038f88c0f2a2b4063511c12d18">gndg_type</a> == <a class="code" href="gnilnd_8h.html#aa8e915c6b7a2bb3f50b6c32283be2e26ac7a6edaf2f13914a807a7a72518e4358">GNILND_DGRAM_WC_REQ</a>)) {
<a name="l02238"></a>02238                                 <span class="keywordflow">continue</span>;
<a name="l02239"></a>02239                         }
<a name="l02240"></a>02240                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aeeeea1864fc878a5feed7940fd096adc">D_NETTRACE</a>, <span class="stringliteral">&quot;checking dgram 0x%p type %s &quot;</span>
<a name="l02241"></a>02241                                 <span class="stringliteral">&quot;state %s conn 0x%p to %s age %lus\n&quot;</span>,
<a name="l02242"></a>02242                                 dgram, <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram),
<a name="l02243"></a>02243                                 <a class="code" href="gnilnd_8h.html#acc0ed17e2d524b0f29db5479f1dcda93">kgnilnd_dgram_state2str</a>(dgram), dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>,
<a name="l02244"></a>02244                                 <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>),
<a name="l02245"></a>02245                                 <a class="code" href="linux-time_8h.html#ad893b50498565ea641263d4771bd69bc">cfs_duration_sec</a>(now - dgram-&gt;<a class="code" href="structkgn__dgram.html#a03e30c7c8e63140d708e72dbcc4e729c">gndg_post_time</a>));
<a name="l02246"></a>02246 
<a name="l02247"></a>02247                         timeout = <a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(*<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#a12c0064e233846566b84d3a2c7578972">kgn_timeout</a>);
<a name="l02248"></a>02248 
<a name="l02249"></a>02249                         <span class="keywordflow">if</span> (time_before(now, (dgram-&gt;<a class="code" href="structkgn__dgram.html#a03e30c7c8e63140d708e72dbcc4e729c">gndg_post_time</a> + timeout)))
<a name="l02250"></a>02250                                 <span class="keywordflow">continue</span>;
<a name="l02251"></a>02251 
<a name="l02252"></a>02252                         <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;%s datagram to %s timed out @ %lus dgram &quot;</span>
<a name="l02253"></a>02253                                 <span class="stringliteral">&quot;0x%p state %s conn 0x%p\n&quot;</span>,
<a name="l02254"></a>02254                                 <a class="code" href="gnilnd_8h.html#a58b8a57bd15297dc6fd25a5677d3fd8c">kgnilnd_dgram_type2str</a>(dgram),
<a name="l02255"></a>02255                                 <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(dgram-&gt;<a class="code" href="structkgn__dgram.html#aed6294ccecc533f26beb119d0b7e5e05">gndg_conn_out</a>.<a class="code" href="structkgn__connreq.html#a18c2271a703b87ecf18c69f080fd838e">gncr_dstnid</a>),
<a name="l02256"></a>02256                                 <a class="code" href="linux-time_8h.html#ad893b50498565ea641263d4771bd69bc">cfs_duration_sec</a>(now - dgram-&gt;<a class="code" href="structkgn__dgram.html#a03e30c7c8e63140d708e72dbcc4e729c">gndg_post_time</a>),
<a name="l02257"></a>02257                                 dgram, <a class="code" href="gnilnd_8h.html#acc0ed17e2d524b0f29db5479f1dcda93">kgnilnd_dgram_state2str</a>(dgram),
<a name="l02258"></a>02258                                 dgram-&gt;<a class="code" href="structkgn__dgram.html#a68e98b8e2c9d359f78c2d9f72958983d">gndg_conn</a>);
<a name="l02259"></a>02259 
<a name="l02260"></a>02260                         <a class="code" href="gnilnd_8h.html#af0bc27af31ab08277023dded0673771f">kgnilnd_cancel_dgram_locked</a>(dgram);
<a name="l02261"></a>02261                 }
<a name="l02262"></a>02262         }
<a name="l02263"></a>02263         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#ad320f09f5ee808eb87c3a9e4cdba7199">gnd_dgram_lock</a>);
<a name="l02264"></a>02264 }
<a name="l02265"></a>02265 
<a name="l02266"></a>02266 
<a name="l02267"></a>02267 <span class="comment">/* use a thread for the possibly long-blocking wait_by_id to prevent</span>
<a name="l02268"></a>02268 <span class="comment"> * stalling the global workqueues */</span>
<a name="l02269"></a>02269 <span class="keywordtype">int</span>
<a name="l02270"></a><a class="code" href="gnilnd__conn_8c.html#a1296043c6477ca3f825856f772a45e38">02270</a> <a class="code" href="gnilnd_8h.html#a1296043c6477ca3f825856f772a45e38">kgnilnd_dgram_waitq</a>(<span class="keywordtype">void</span> *arg)
<a name="l02271"></a>02271 {
<a name="l02272"></a>02272         <a class="code" href="structkgn__device.html">kgn_device_t</a>     *dev = (<a class="code" href="structkgn__device.html">kgn_device_t</a> *) arg;
<a name="l02273"></a>02273         <span class="keywordtype">char</span>              <a class="code" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>[16];
<a name="l02274"></a>02274         <a class="code" href="gni__pub_8h.html#a4a1de8d517eef402419200b53132f9a0">gni_return_t</a>      grc;
<a name="l02275"></a>02275         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>             readyid;
<a name="l02276"></a>02276         DEFINE_WAIT(mover_done);
<a name="l02277"></a>02277 
<a name="l02278"></a>02278         snprintf(name, <span class="keyword">sizeof</span>(name), <span class="stringliteral">&quot;kgnilnd_dgn_%02d&quot;</span>, dev-&gt;<a class="code" href="structkgn__device.html#a121a69ed91d615c6eec65ca3605545eb">gnd_id</a>);
<a name="l02279"></a>02279         <a class="code" href="linux-prim_8c.html#a207bca0abc341166fa478872e93104f2">cfs_block_allsigs</a>();
<a name="l02280"></a>02280 
<a name="l02281"></a>02281         <span class="comment">/* all gnilnd threads need to run fairly urgently */</span>
<a name="l02282"></a>02282         set_user_nice(current, *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#acf385a6eb103311f2e130153dc256285">kgn_nice</a>);
<a name="l02283"></a>02283 
<a name="l02284"></a>02284         <span class="comment">/* we dont shut down until the device shuts down ... */</span>
<a name="l02285"></a>02285         <span class="keywordflow">while</span> (!<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#ab2514d2a3fe52303f185e3f4c7260eea">kgn_shutdown</a>) {
<a name="l02286"></a>02286                 <span class="comment">/* to quiesce or to not quiesce, that is the question */</span>
<a name="l02287"></a>02287                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a9ad4269edf56049c1363d137e31a56c0">kgn_quiesce_trigger</a>)) {
<a name="l02288"></a>02288                         <a class="code" href="gnilnd_8h.html#a5b810659a3cb6549fa91d9e67c8fd2e9">KGNILND_SPIN_QUIESCE</a>;
<a name="l02289"></a>02289                 }
<a name="l02290"></a>02290 
<a name="l02291"></a>02291                 <span class="keywordflow">while</span> (<a class="code" href="libcfs__fail_8h.html#ad8a7f229bd17fa3ffeaed1fc21d5f6fb">CFS_FAIL_TIMEOUT</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a5313a608557cceb66011718ef700cb07">CFS_FAIL_GNI_PAUSE_DGRAM_COMP</a>, 1)) {}
<a name="l02292"></a>02292 
<a name="l02293"></a>02293                 <span class="comment">/* check once a second */</span>
<a name="l02294"></a>02294                 grc = <a class="code" href="gnilnd__api__wrap_8h.html#aef60a68583abd2e338f2958f9cdb9106">kgnilnd_postdata_probe_wait_by_id</a>(dev-&gt;<a class="code" href="structkgn__device.html#adef69bb2d51b71d659d4404ea419e18e">gnd_handle</a>,
<a name="l02295"></a>02295                                                        1000, &amp;readyid);
<a name="l02296"></a>02296 
<a name="l02297"></a>02297                 <span class="keywordflow">if</span> (grc == <a class="code" href="gni__pub_8h.html#a2c9a07cb0218bb8ca5ce890af7519fb6a37bb09297c7b0ac56534ed8c75be61f5">GNI_RC_SUCCESS</a>) {
<a name="l02298"></a>02298                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;waking up dgram mover thread\n&quot;</span>);
<a name="l02299"></a>02299                         <a class="code" href="gnilnd_8h.html#a8817bfea0f760de156b4cb92a6fbe237">kgnilnd_schedule_dgram</a>(dev);
<a name="l02300"></a>02300 
<a name="l02301"></a>02301                         <span class="comment">/* wait for dgram thread to ping us before spinning again */</span>
<a name="l02302"></a>02302                         prepare_to_wait(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a70a586e0f36291301a07ac83792ed99a">gnd_dgping_waitq</a>, &amp;mover_done,
<a name="l02303"></a>02303                                         TASK_INTERRUPTIBLE);
<a name="l02304"></a>02304 
<a name="l02305"></a>02305                         <span class="comment">/* don&apos;t sleep if we need to quiesce */</span>
<a name="l02306"></a>02306                         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(!<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a9ad4269edf56049c1363d137e31a56c0">kgn_quiesce_trigger</a>)) {
<a name="l02307"></a>02307                                 schedule();
<a name="l02308"></a>02308                         }
<a name="l02309"></a>02309                         finish_wait(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a70a586e0f36291301a07ac83792ed99a">gnd_dgping_waitq</a>, &amp;mover_done);
<a name="l02310"></a>02310                 }
<a name="l02311"></a>02311         }
<a name="l02312"></a>02312 
<a name="l02313"></a>02313         <a class="code" href="gnilnd_8h.html#a32eb11fd0c34dc5d5d0ec8c6dbee146a">kgnilnd_thread_fini</a>();
<a name="l02314"></a>02314         <span class="keywordflow">return</span> 0;
<a name="l02315"></a>02315 }
<a name="l02316"></a>02316 
<a name="l02317"></a>02317 <span class="keywordtype">int</span>
<a name="l02318"></a><a class="code" href="gnilnd__conn_8c.html#af679ed2b26e09859b183b36ff9a3f3fc">02318</a> <a class="code" href="gnilnd__conn_8c.html#af679ed2b26e09859b183b36ff9a3f3fc">kgnilnd_start_outbound_dgrams</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> deadline)
<a name="l02319"></a>02319 {
<a name="l02320"></a>02320         <span class="keywordtype">int</span>                      did_something = 0, rc;
<a name="l02321"></a>02321         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>              *peer = NULL;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323         spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02324"></a>02324 
<a name="l02325"></a>02325         <span class="comment">/* Active connect - we added this in kgnilnd_launch_tx */</span>
<a name="l02326"></a>02326         <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a854522e01cd31936d7e4234eb8e2334b">gnd_connd_peers</a>) &amp;&amp; time_before(jiffies, deadline)) {
<a name="l02327"></a>02327                 peer = list_first_entry(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a854522e01cd31936d7e4234eb8e2334b">gnd_connd_peers</a>,
<a name="l02328"></a>02328                                         <a class="code" href="structkgn__peer.html">kgn_peer_t</a>, gnp_connd_list);
<a name="l02329"></a>02329 
<a name="l02330"></a>02330                 <span class="comment">/* ref for connd removed in if/else below */</span>
<a name="l02331"></a>02331                <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#a48a5b4723170789c6b4b5ce13a045401">gnp_connd_list</a>);
<a name="l02332"></a>02332 
<a name="l02333"></a>02333                 <span class="comment">/* gnp_connecting and membership on gnd_connd_peers should be</span>
<a name="l02334"></a>02334 <span class="comment">                 * done coherently to avoid double adding, etc */</span>
<a name="l02335"></a>02335                 <span class="comment">/* don&apos;t need kgnilnd_data.kgn_peer_conn_lock here as that is only needed</span>
<a name="l02336"></a>02336 <span class="comment">                 * to get the peer to gnp_connecting in the first place. We just need to</span>
<a name="l02337"></a>02337 <span class="comment">                 * rely on gnd_connd_lock to serialize someone pulling him from the list</span>
<a name="l02338"></a>02338 <span class="comment">                 * BEFORE clearing gnp_connecting */</span>
<a name="l02339"></a>02339                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> != <a class="code" href="gnilnd_8h.html#a62fa3c755f2429f118559bd89c8d84d5">GNILND_PEER_IDLE</a>, <span class="stringliteral">&quot;peer 0x%p-&gt;%s not connecting\n&quot;</span>,
<a name="l02340"></a>02340                          peer, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>));
<a name="l02341"></a>02341 
<a name="l02342"></a>02342                 spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02343"></a>02343 
<a name="l02344"></a>02344                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;processing connect to %s\n&quot;</span>,
<a name="l02345"></a>02345                        <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>));
<a name="l02346"></a>02346 
<a name="l02347"></a>02347                 did_something += 1;
<a name="l02348"></a>02348                 rc = <a class="code" href="gnilnd__conn_8c.html#a9f7ca42d3f863f9d3c08f7a57140c872">kgnilnd_start_connect</a>(peer);
<a name="l02349"></a>02349 
<a name="l02350"></a>02350                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(rc &gt;= 0)) {
<a name="l02351"></a>02351                         <span class="comment">/* 0 on success, positive on &apos;just drop peer&apos; errors */</span>
<a name="l02352"></a>02352                         <a class="code" href="gnilnd_8h.html#a808a7a2d5c4b4612643d06cee039117b">kgnilnd_peer_decref</a>(peer);
<a name="l02353"></a>02353                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == -ENOMEM) {
<a name="l02354"></a>02354                         <span class="comment">/* if we are out of wildcards, add back to</span>
<a name="l02355"></a>02355 <span class="comment">                         * connd_list - then break out and we&apos;ll try later</span>
<a name="l02356"></a>02356 <span class="comment">                         * if other errors, we&apos;ll bail &amp; cancel pending tx */</span>
<a name="l02357"></a>02357                         write_lock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l02358"></a>02358                         <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> == <a class="code" href="gnilnd_8h.html#a4ab40a42aa7c7c222eef57a76fa83488">GNILND_PEER_POSTING</a>) {
<a name="l02359"></a>02359                                 peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> = <a class="code" href="gnilnd_8h.html#a08aa73ed62411a3ea5c771b0d1e8401f">GNILND_PEER_CONNECT</a>;
<a name="l02360"></a>02360                                 spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02361"></a>02361                                 <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;peer-&gt;<a class="code" href="structkgn__peer.html#a48a5b4723170789c6b4b5ce13a045401">gnp_connd_list</a>,
<a name="l02362"></a>02362                                               &amp;dev-&gt;<a class="code" href="structkgn__device.html#a854522e01cd31936d7e4234eb8e2334b">gnd_connd_peers</a>);
<a name="l02363"></a>02363                         } <span class="keywordflow">else</span> {
<a name="l02364"></a>02364                                 <span class="comment">/* connecting changed while we were posting */</span>
<a name="l02365"></a>02365 
<a name="l02366"></a>02366                                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> == <a class="code" href="gnilnd_8h.html#aed14cc5d3a6e153f6bf209d3783d617f">GNILND_PEER_NEEDS_DEATH</a>, <span class="stringliteral">&quot;Peer is in invalid&quot;</span>
<a name="l02367"></a>02367                                         <span class="stringliteral">&quot; state 0x%p-&gt;%s, connecting %d\n&quot;</span>,
<a name="l02368"></a>02368                                         peer, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>), peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a>);
<a name="l02369"></a>02369                                 peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> = <a class="code" href="gnilnd_8h.html#ab9d39ae93d56f49b06b2232f41a42cb5">GNILND_PEER_KILL</a>;
<a name="l02370"></a>02370                                 spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02371"></a>02371                                 <span class="comment">/* remove the peer ref frrom the cond list */</span>
<a name="l02372"></a>02372                                 <a class="code" href="gnilnd_8h.html#a808a7a2d5c4b4612643d06cee039117b">kgnilnd_peer_decref</a>(peer);
<a name="l02373"></a>02373                                 <span class="comment">/* let the system handle itself */</span>
<a name="l02374"></a>02374                         }
<a name="l02375"></a>02375                         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l02376"></a>02376                         <span class="comment">/* the datagrams are a global pool,</span>
<a name="l02377"></a>02377 <span class="comment">                         * so break out of trying and hope some free</span>
<a name="l02378"></a>02378 <span class="comment">                         * up soon */</span>
<a name="l02379"></a>02379                         did_something -= 1;
<a name="l02380"></a>02380                         <span class="keywordflow">break</span>;
<a name="l02381"></a>02381                 } <span class="keywordflow">else</span> {
<a name="l02382"></a>02382                         <span class="comment">/* something bad happened, you lose */</span>
<a name="l02383"></a>02383                         <a class="code" href="libcfs__debug_8h.html#a27bee86c1bde3433be1c0d3939ea8c62">CNETERR</a>(<span class="stringliteral">&quot;could not start connecting to %s &quot;</span>
<a name="l02384"></a>02384                                 <span class="stringliteral">&quot;rc %d: Will retry until TX timeout\n&quot;</span>,
<a name="l02385"></a>02385                                <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>), rc);
<a name="l02386"></a>02386                         <span class="comment">/* It didnt post so just set connecting back to zero now.</span>
<a name="l02387"></a>02387 <span class="comment">                         * The reaper will reattempt the connection if it needs too.</span>
<a name="l02388"></a>02388 <span class="comment">                         * If the peer needs death set it so the reaper will cleanup.</span>
<a name="l02389"></a>02389 <span class="comment">                         */</span>
<a name="l02390"></a>02390                         write_lock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l02391"></a>02391                         <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> == <a class="code" href="gnilnd_8h.html#a4ab40a42aa7c7c222eef57a76fa83488">GNILND_PEER_POSTING</a>) {
<a name="l02392"></a>02392                                 peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> = <a class="code" href="gnilnd_8h.html#a62fa3c755f2429f118559bd89c8d84d5">GNILND_PEER_IDLE</a>;
<a name="l02393"></a>02393                                 <a class="code" href="gnilnd_8c.html#ab4ac8ae1e5171241dc45b64017af6921">kgnilnd_peer_increase_reconnect_locked</a>(peer);
<a name="l02394"></a>02394                         } <span class="keywordflow">else</span> {
<a name="l02395"></a>02395                                 <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> == <a class="code" href="gnilnd_8h.html#aed14cc5d3a6e153f6bf209d3783d617f">GNILND_PEER_NEEDS_DEATH</a>, <span class="stringliteral">&quot;Peer is in invalid&quot;</span>
<a name="l02396"></a>02396                                         <span class="stringliteral">&quot; state 0x%p-&gt;%s, connecting %d\n&quot;</span>,
<a name="l02397"></a>02397                                         peer, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(peer-&gt;<a class="code" href="structkgn__peer.html#acd500c6e672c04b82c765ea12c4e647e">gnp_nid</a>), peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a>);
<a name="l02398"></a>02398                                 peer-&gt;<a class="code" href="structkgn__peer.html#a392b83d4cbd981048932925448977659">gnp_connecting</a> = <a class="code" href="gnilnd_8h.html#ab9d39ae93d56f49b06b2232f41a42cb5">GNILND_PEER_KILL</a>;
<a name="l02399"></a>02399                         }
<a name="l02400"></a>02400                         write_unlock(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a8d148ea02cd62ecb9ebf62ffe7bd4e0e">kgn_peer_conn_lock</a>);
<a name="l02401"></a>02401 
<a name="l02402"></a>02402                         <span class="comment">/* hold onto ref until we are really done - if it was</span>
<a name="l02403"></a>02403 <span class="comment">                         * unlinked this could result in a destroy */</span>
<a name="l02404"></a>02404                         <a class="code" href="gnilnd_8h.html#a808a7a2d5c4b4612643d06cee039117b">kgnilnd_peer_decref</a>(peer);
<a name="l02405"></a>02405                 }
<a name="l02406"></a>02406                 spin_lock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02407"></a>02407         }
<a name="l02408"></a>02408 
<a name="l02409"></a>02409         spin_unlock(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a3e71e6d50510eb599aad31f3716db365">gnd_connd_lock</a>);
<a name="l02410"></a>02410         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(did_something);
<a name="l02411"></a>02411 }
<a name="l02412"></a>02412 
<a name="l02413"></a>02413 <span class="keywordtype">int</span>
<a name="l02414"></a><a class="code" href="gnilnd__conn_8c.html#a47c3461b6c96d5124fa21f84bc6f8423">02414</a> <a class="code" href="gnilnd__conn_8c.html#a47c3461b6c96d5124fa21f84bc6f8423">kgnilnd_repost_wc_dgrams</a>(<a class="code" href="structkgn__device.html">kgn_device_t</a> *dev)
<a name="l02415"></a>02415 {
<a name="l02416"></a>02416         <span class="keywordtype">int</span> did_something = 0, to_repost, i;
<a name="l02417"></a>02417         to_repost = atomic_read(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a5660a310af80697abfbb9a2b33a8b6ff">gnd_nwcdgrams</a>);
<a name="l02418"></a>02418         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02419"></a>02419 
<a name="l02420"></a>02420         <span class="keywordflow">for</span> (i = 0; i &lt; to_repost; ++i) {
<a name="l02421"></a>02421                 <span class="keywordtype">int</span>     rerc;
<a name="l02422"></a>02422                 rerc = <a class="code" href="gnilnd__conn_8c.html#aa8afeb18eea207c710d60a0927c91c8d">kgnilnd_post_dgram</a>(dev, <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>, <a class="code" href="gnilnd_8h.html#a6c9695fbb09051832186b293ea4fe777a48dd218ba2da7bccf230d76dad5a5b41">GNILND_CONNREQ_REQ</a>, 0);
<a name="l02423"></a>02423                 <span class="keywordflow">if</span> (rerc == 0) {
<a name="l02424"></a>02424                         <a class="code" href="gnilnd_8h.html#a16c74fde7b75f50db70c46ff5357d714">kgnilnd_admin_decref</a>(dev-&gt;<a class="code" href="structkgn__device.html#a5660a310af80697abfbb9a2b33a8b6ff">gnd_nwcdgrams</a>);
<a name="l02425"></a>02425                         did_something += 1;
<a name="l02426"></a>02426                 } <span class="keywordflow">else</span> {
<a name="l02427"></a>02427                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a2e9936ae6b69f5e744aacbae3b33c749">D_NETERROR</a>, <span class="stringliteral">&quot;error %d: dev %d could not post wildcard datagram\n&quot;</span>,
<a name="l02428"></a>02428                                 rerc, dev-&gt;<a class="code" href="structkgn__device.html#a121a69ed91d615c6eec65ca3605545eb">gnd_id</a>);
<a name="l02429"></a>02429                         <span class="keywordflow">break</span>;
<a name="l02430"></a>02430                 }
<a name="l02431"></a>02431         }
<a name="l02432"></a>02432 
<a name="l02433"></a>02433         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(did_something);
<a name="l02434"></a>02434 }
<a name="l02435"></a>02435 
<a name="l02436"></a>02436 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02437"></a><a class="code" href="gnilnd__conn_8c.html#a7f71b1188ed6e23c91a5597984e83663">02437</a> <a class="code" href="gnilnd__conn_8c.html#a7f71b1188ed6e23c91a5597984e83663">kgnilnd_dgram_poke_with_stick</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
<a name="l02438"></a>02438 {
<a name="l02439"></a>02439         <span class="keywordtype">int</span>             dev_id = arg;
<a name="l02440"></a>02440         <a class="code" href="structkgn__device.html">kgn_device_t</a>    *dev = &amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#ac3fc1a4aec213d797477dd3383256159">kgn_devices</a>[dev_id];
<a name="l02441"></a>02441 
<a name="l02442"></a>02442         wake_up(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a99e37e9ed35a0ebca7c2502eec1c6af6">gnd_dgram_waitq</a>);
<a name="l02443"></a>02443 }
<a name="l02444"></a>02444 
<a name="l02445"></a>02445 <span class="comment">/* use single thread for dgrams - should be sufficient for performance */</span>
<a name="l02446"></a>02446 <span class="keywordtype">int</span>
<a name="l02447"></a><a class="code" href="gnilnd__conn_8c.html#aa5f856d935bb33bc3fbe528da6e72f45">02447</a> <a class="code" href="gnilnd_8h.html#aa5f856d935bb33bc3fbe528da6e72f45">kgnilnd_dgram_mover</a>(<span class="keywordtype">void</span> *arg)
<a name="l02448"></a>02448 {
<a name="l02449"></a>02449         <a class="code" href="structkgn__device.html">kgn_device_t</a>            *dev = (<a class="code" href="structkgn__device.html">kgn_device_t</a> *)arg;
<a name="l02450"></a>02450         <span class="keywordtype">char</span>                     <a class="code" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>[16];
<a name="l02451"></a>02451         <span class="keywordtype">int</span>                      rc, did_something;
<a name="l02452"></a>02452         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            next_purge_check = jiffies - 1;
<a name="l02453"></a>02453         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            <a class="code" href="gnilnd__modparams_8c.html#a493b57f443cc38b3d3df9c1e584d9d82">timeout</a>;
<a name="l02454"></a>02454         <span class="keyword">struct </span>timer_list        timer;
<a name="l02455"></a>02455         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            deadline = 0;
<a name="l02456"></a>02456         DEFINE_WAIT(wait);
<a name="l02457"></a>02457 
<a name="l02458"></a>02458         snprintf(name, <span class="keyword">sizeof</span>(name), <span class="stringliteral">&quot;kgnilnd_dg_%02d&quot;</span>, dev-&gt;<a class="code" href="structkgn__device.html#a121a69ed91d615c6eec65ca3605545eb">gnd_id</a>);
<a name="l02459"></a>02459         <a class="code" href="linux-prim_8c.html#a207bca0abc341166fa478872e93104f2">cfs_block_allsigs</a>();
<a name="l02460"></a>02460         <span class="comment">/* all gnilnd threads need to run fairly urgently */</span>
<a name="l02461"></a>02461         set_user_nice(current, *<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#acf385a6eb103311f2e130153dc256285">kgn_nice</a>);
<a name="l02462"></a>02462 
<a name="l02463"></a>02463         <span class="comment">/* we are ok not locking for these variables as the dgram waitq threads</span>
<a name="l02464"></a>02464 <span class="comment">         * will block both due to tying up net (kgn_shutdown) and the completion</span>
<a name="l02465"></a>02465 <span class="comment">         * event for the dgram_waitq (kgn_quiesce_trigger) */</span>
<a name="l02466"></a>02466         deadline = jiffies + <a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(*<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#afdaa36d1f176adc05479a26974ed8be1">kgn_dgram_timeout</a>);
<a name="l02467"></a>02467         <span class="keywordflow">while</span> (!<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#ab2514d2a3fe52303f185e3f4c7260eea">kgn_shutdown</a>) {
<a name="l02468"></a>02468                 <span class="comment">/* Safe: kgn_shutdown only set when quiescent */</span>
<a name="l02469"></a>02469 
<a name="l02470"></a>02470                 <span class="comment">/* race with stack reset - we want to hold off seeing any new incoming dgrams</span>
<a name="l02471"></a>02471 <span class="comment">                 * so we can force a dirty WC dgram for Bug 762072 - put right before</span>
<a name="l02472"></a>02472 <span class="comment">                 * quiesce check so that it&apos;ll go right into that and not do any</span>
<a name="l02473"></a>02473 <span class="comment">                 * dgram mucking */</span>
<a name="l02474"></a>02474                 <a class="code" href="libcfs__fail_8h.html#aa9efa4433e79a88cfb3d5e645fcdb622">CFS_RACE</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a353bee8de3fe785d05535ac7e694bbdc">CFS_FAIL_GNI_WC_DGRAM_FREE</a>);
<a name="l02475"></a>02475 
<a name="l02476"></a>02476                 <span class="comment">/* to quiesce or to not quiesce, that is the question */</span>
<a name="l02477"></a>02477                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a9ad4269edf56049c1363d137e31a56c0">kgn_quiesce_trigger</a>)) {
<a name="l02478"></a>02478                         <a class="code" href="gnilnd_8h.html#a5b810659a3cb6549fa91d9e67c8fd2e9">KGNILND_SPIN_QUIESCE</a>;
<a name="l02479"></a>02479                 }
<a name="l02480"></a>02480                 did_something = 0;
<a name="l02481"></a>02481 
<a name="l02482"></a>02482                 <a class="code" href="libcfs__fail_8h.html#aa9efa4433e79a88cfb3d5e645fcdb622">CFS_RACE</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a4f282f20c59212c3907cc67571177279">CFS_FAIL_GNI_QUIESCE_RACE</a>);
<a name="l02483"></a>02483 
<a name="l02484"></a>02484                 <span class="comment">/* process any newly completed dgrams */</span>
<a name="l02485"></a>02485                 down_read(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#aefbf08af493c7d1a10f58b08aa960e5e">kgn_net_rw_sem</a>);
<a name="l02486"></a>02486 
<a name="l02487"></a>02487                 rc = <a class="code" href="gnilnd__conn_8c.html#a3f70068d7579cec1a1c9e9d45af27ef9">kgnilnd_probe_and_process_dgram</a>(dev);
<a name="l02488"></a>02488                 <span class="keywordflow">if</span> (rc &gt; 0) {
<a name="l02489"></a>02489                         did_something += rc;
<a name="l02490"></a>02490                 }
<a name="l02491"></a>02491 
<a name="l02492"></a>02492                 up_read(&amp;<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#aefbf08af493c7d1a10f58b08aa960e5e">kgn_net_rw_sem</a>);
<a name="l02493"></a>02493 
<a name="l02494"></a>02494                 <a class="code" href="libcfs__fail_8h.html#ad8a7f229bd17fa3ffeaed1fc21d5f6fb">CFS_FAIL_TIMEOUT</a>(<a class="code" href="gnilnd__api__wrap_8h.html#a73680e4927757393898bd20589828166">CFS_FAIL_GNI_DGRAM_DEADLINE</a>,
<a name="l02495"></a>02495                         (*<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#afdaa36d1f176adc05479a26974ed8be1">kgn_dgram_timeout</a> + 1));
<a name="l02496"></a>02496                 <span class="comment">/* start new outbound dgrams */</span>
<a name="l02497"></a>02497                 did_something += <a class="code" href="gnilnd__conn_8c.html#af679ed2b26e09859b183b36ff9a3f3fc">kgnilnd_start_outbound_dgrams</a>(dev, deadline);
<a name="l02498"></a>02498 
<a name="l02499"></a>02499                 <span class="comment">/* find dead dgrams */</span>
<a name="l02500"></a>02500                 <span class="keywordflow">if</span> (time_after_eq(jiffies, next_purge_check)) {
<a name="l02501"></a>02501                         <span class="comment">/* these don&apos;t need to be checked that often */</span>
<a name="l02502"></a>02502                         <a class="code" href="gnilnd__conn_8c.html#a46918fd725742a2127db5e1179765909">kgnilnd_reaper_dgram_check</a>(dev);
<a name="l02503"></a>02503 
<a name="l02504"></a>02504                         next_purge_check = (long) jiffies +
<a name="l02505"></a>02505                                       <a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a3156eb8b372cc5dbee2264554305a609">kgn_new_min_timeout</a> / 4);
<a name="l02506"></a>02506                 }
<a name="l02507"></a>02507 
<a name="l02508"></a>02508                 did_something += <a class="code" href="gnilnd__conn_8c.html#a47c3461b6c96d5124fa21f84bc6f8423">kgnilnd_repost_wc_dgrams</a>(dev);
<a name="l02509"></a>02509 
<a name="l02510"></a>02510                 <span class="comment">/* careful with the jiffy wrap... */</span>
<a name="l02511"></a>02511                 timeout = (long)(next_purge_check - jiffies);
<a name="l02512"></a>02512 
<a name="l02513"></a>02513                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;did %d timeout %lu next %lu jiffies %lu\n&quot;</span>,
<a name="l02514"></a>02514                        did_something, timeout, next_purge_check, jiffies);
<a name="l02515"></a>02515 
<a name="l02516"></a>02516                 <span class="keywordflow">if</span> ((did_something || timeout &lt;= 0) &amp;&amp; time_before(jiffies, deadline)) {
<a name="l02517"></a>02517                         did_something = 0;
<a name="l02518"></a>02518                         <span class="keywordflow">continue</span>;
<a name="l02519"></a>02519                 }
<a name="l02520"></a>02520 
<a name="l02521"></a>02521                 prepare_to_wait(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a99e37e9ed35a0ebca7c2502eec1c6af6">gnd_dgram_waitq</a>, &amp;wait, TASK_INTERRUPTIBLE);
<a name="l02522"></a>02522 
<a name="l02523"></a>02523                 setup_timer(&amp;timer, <a class="code" href="gnilnd__conn_8c.html#a7f71b1188ed6e23c91a5597984e83663">kgnilnd_dgram_poke_with_stick</a>, dev-&gt;<a class="code" href="structkgn__device.html#a121a69ed91d615c6eec65ca3605545eb">gnd_id</a>);
<a name="l02524"></a>02524                 mod_timer(&amp;timer, (<span class="keywordtype">long</span>) jiffies + timeout);
<a name="l02525"></a>02525 
<a name="l02526"></a>02526                 <span class="comment">/* last second chance for others to poke us */</span>
<a name="l02527"></a>02527                 did_something += xchg(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a2895476de1d6f2031ba8875219522b26">gnd_dgram_ready</a>, <a class="code" href="gnilnd_8h.html#ad582c74339d5372135e69536f8a5f592">GNILND_DGRAM_IDLE</a>);
<a name="l02528"></a>02528 
<a name="l02529"></a>02529                 <span class="comment">/* check flag variables before committing even if we</span>
<a name="l02530"></a>02530 <span class="comment">                 * did something; if we are after the deadline call</span>
<a name="l02531"></a>02531 <span class="comment">                 * schedule */</span>
<a name="l02532"></a>02532                 <span class="keywordflow">if</span> ((!did_something || time_after(jiffies, deadline)) &amp;&amp;
<a name="l02533"></a>02533                     !<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#ab2514d2a3fe52303f185e3f4c7260eea">kgn_shutdown</a> &amp;&amp;
<a name="l02534"></a>02534                     !<a class="code" href="gnilnd_8c.html#a31cd8f62818415359226aef3a488282b">kgnilnd_data</a>.<a class="code" href="structkgn__data.html#a9ad4269edf56049c1363d137e31a56c0">kgn_quiesce_trigger</a>) {
<a name="l02535"></a>02535                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;schedule timeout %ld (%lu sec)\n&quot;</span>,
<a name="l02536"></a>02536                                timeout, <a class="code" href="linux-time_8h.html#ad893b50498565ea641263d4771bd69bc">cfs_duration_sec</a>(timeout));
<a name="l02537"></a>02537                         wake_up_all(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a70a586e0f36291301a07ac83792ed99a">gnd_dgping_waitq</a>);
<a name="l02538"></a>02538                         schedule();
<a name="l02539"></a>02539                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;awake after schedule\n&quot;</span>);
<a name="l02540"></a>02540                         deadline = jiffies + <a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(*<a class="code" href="gnilnd_8h.html#ab5530c1749f29302e919ef38ec1e66a0">kgnilnd_tunables</a>.<a class="code" href="structkgn__tunables.html#afdaa36d1f176adc05479a26974ed8be1">kgn_dgram_timeout</a>);
<a name="l02541"></a>02541                 }
<a name="l02542"></a>02542 
<a name="l02543"></a>02543                 del_singleshot_timer_sync(&amp;timer);
<a name="l02544"></a>02544                 finish_wait(&amp;dev-&gt;<a class="code" href="structkgn__device.html#a99e37e9ed35a0ebca7c2502eec1c6af6">gnd_dgram_waitq</a>, &amp;wait);
<a name="l02545"></a>02545         }
<a name="l02546"></a>02546 
<a name="l02547"></a>02547         <a class="code" href="gnilnd_8h.html#a32eb11fd0c34dc5d5d0ec8c6dbee146a">kgnilnd_thread_fini</a>();
<a name="l02548"></a>02548         <span class="keywordflow">return</span> 0;
<a name="l02549"></a>02549 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:33 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
