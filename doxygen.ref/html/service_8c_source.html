<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ptlrpc/service.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/ptlrpc/service.c</h1><a href="service_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2010, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> */</span>
<a name="l00036"></a>00036 
<a name="l00037"></a><a class="code" href="service_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">00037</a> <span class="preprocessor">#define DEBUG_SUBSYSTEM S_RPC</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/kthread.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="obd__support_8h.html">obd_support.h</a>&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;<a class="code" href="obd__class_8h.html">obd_class.h</a>&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;<a class="code" href="lustre__net_8h.html">lustre_net.h</a>&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;<a class="code" href="lu__object_8h.html">lu_object.h</a>&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;<a class="code" href="lnet_2include_2lnet_2types_8h.html">lnet/types.h</a>&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="ptlrpc__internal_8h.html">ptlrpc_internal.h</a>&quot;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">/* The following are visible and mutable through /sys/module/ptlrpc */</span>
<a name="l00047"></a><a class="code" href="service_8c.html#a840cfd893cfd1ea1f4ac7b04382ed44d">00047</a> <span class="keywordtype">int</span> <a class="code" href="ptlrpc__internal_8h.html#a840cfd893cfd1ea1f4ac7b04382ed44d">test_req_buffer_pressure</a> = 0;
<a name="l00048"></a>00048 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="ptlrpc__internal_8h.html#a840cfd893cfd1ea1f4ac7b04382ed44d">test_req_buffer_pressure</a>, <span class="keywordtype">int</span>, 0444);
<a name="l00049"></a>00049 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="ptlrpc__internal_8h.html#a840cfd893cfd1ea1f4ac7b04382ed44d">test_req_buffer_pressure</a>, <span class="stringliteral">&quot;set non-zero to put pressure on request buffer pools&quot;</span>);
<a name="l00050"></a>00050 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="group__export.html#gac018b3cde737ca787e95380e27734ffd">at_min</a>, <span class="keywordtype">int</span>, 0644);
<a name="l00051"></a>00051 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="group__export.html#gac018b3cde737ca787e95380e27734ffd">at_min</a>, <span class="stringliteral">&quot;Adaptive timeout minimum (sec)&quot;</span>);
<a name="l00052"></a>00052 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="group__export.html#gad437939efbc33a157b6f386ac4a92ecb">at_max</a>, <span class="keywordtype">int</span>, 0644);
<a name="l00053"></a>00053 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="group__export.html#gad437939efbc33a157b6f386ac4a92ecb">at_max</a>, <span class="stringliteral">&quot;Adaptive timeout maximum (sec)&quot;</span>);
<a name="l00054"></a>00054 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="obd__support_8h.html#a4113eb4f3c62d84a17df957bc9d6c1b9">at_history</a>, <span class="keywordtype">int</span>, 0644);
<a name="l00055"></a>00055 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="obd__support_8h.html#a4113eb4f3c62d84a17df957bc9d6c1b9">at_history</a>,
<a name="l00056"></a>00056                  <span class="stringliteral">&quot;Adaptive timeouts remember the slowest event that took place within this period (sec)&quot;</span>);
<a name="l00057"></a>00057 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="obd__support_8h.html#a47a70ddef4976d21923b761d4b637514">at_early_margin</a>, <span class="keywordtype">int</span>, 0644);
<a name="l00058"></a>00058 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="obd__support_8h.html#a47a70ddef4976d21923b761d4b637514">at_early_margin</a>, <span class="stringliteral">&quot;How soon before an RPC deadline to send an early reply&quot;</span>);
<a name="l00059"></a>00059 <a class="code" href="ldlm__lockd_8c.html#a3115a1fd4692ea881ff962c0d7bf7a83">module_param</a>(<a class="code" href="obd__support_8h.html#a30b9fa4cca5a373d84fb01422c5e239d">at_extra</a>, <span class="keywordtype">int</span>, 0644);
<a name="l00060"></a>00060 <a class="code" href="ldlm__lockd_8c.html#a9c22a8e5be87360fbad7b7571cf488f0">MODULE_PARM_DESC</a>(<a class="code" href="obd__support_8h.html#a30b9fa4cca5a373d84fb01422c5e239d">at_extra</a>, <span class="stringliteral">&quot;How much extra time to give with each early reply&quot;</span>);
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">/* forward ref */</span>
<a name="l00063"></a>00063 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#aa3c644131d0f98fd22ad9ba28d49974c">ptlrpc_server_post_idle_rqbds</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt);
<a name="l00064"></a>00064 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#aaa197378ce94c91c9a218f7b3f3faa8c" title="Remove the request from the export list.">ptlrpc_server_hpreq_fini</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00065"></a>00065 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#a7a53df8d8b8dad6cc5e77af7524794eb">ptlrpc_at_remove_timed</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req);
<a name="l00066"></a>00066 
<a name="l00068"></a><a class="code" href="service_8c.html#a9bbbe993837b9f20a26325525bc76bfb">00068</a> <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> <a class="code" href="ptlrpc__internal_8h.html#a9bbbe993837b9f20a26325525bc76bfb" title="Holds a list of all PTLRPC services.">ptlrpc_all_services</a>;
<a name="l00070"></a><a class="code" href="service_8c.html#a9e88c117c1eccb6da9707b1f9430d4f3">00070</a> <span class="keyword">struct </span>mutex <a class="code" href="ptlrpc__internal_8h.html#a9e88c117c1eccb6da9707b1f9430d4f3" title="Used to protect the ptlrpc_all_services list.">ptlrpc_all_services_mutex</a>;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *
<a name="l00073"></a><a class="code" href="service_8c.html#aed50b6950afc4c4f1b9a2bac3a9e2e8b">00073</a> <a class="code" href="service_8c.html#aed50b6950afc4c4f1b9a2bac3a9e2e8b">ptlrpc_alloc_rqbd</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l00074"></a>00074 {
<a name="l00075"></a>00075         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>             *svc = svcpt-&gt;scp_service;
<a name="l00076"></a>00076         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *rqbd;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         <a class="code" href="obd__support_8h.html#a3edaf39d38f2af2b6fbb08a9a3224ffe">OBD_CPT_ALLOC_PTR</a>(rqbd, svc-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a>);
<a name="l00079"></a>00079         <span class="keywordflow">if</span> (rqbd == NULL)
<a name="l00080"></a>00080                 <span class="keywordflow">return</span> NULL;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082         rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a1e7bb4edc15fbecb9ef0800039fe255e" title="Back pointer to service for which this buffer is registered.">rqbd_svcpt</a> = svcpt;
<a name="l00083"></a>00083         rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a00c44a4551ca8b0ccf4955d94f641c6b">rqbd_refcount</a> = 0;
<a name="l00084"></a>00084         rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#af91387c9f97914c97a96469f6e92a849">rqbd_cbid</a>.<a class="code" href="structptlrpc__cb__id.html#a58f3b9cf321abbbda3162af4e35c310e">cbid_fn</a> = <a class="code" href="group__net.html#gabc74b903a7097918d144a762599c02cb">request_in_callback</a>;
<a name="l00085"></a>00085         rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#af91387c9f97914c97a96469f6e92a849">rqbd_cbid</a>.<a class="code" href="structptlrpc__cb__id.html#a599f9ca488ebfefef38c3e0e7052f300">cbid_arg</a> = rqbd;
<a name="l00086"></a>00086         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>);
<a name="l00087"></a>00087         <a class="code" href="obd__support_8h.html#a8e64d7671181dcaf9872ca717a6b1d87">OBD_CPT_ALLOC_LARGE</a>(rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#ad4b53ddbaa302876b0e01ecf24287ce4" title="The buffer itself.">rqbd_buffer</a>, svc-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>,
<a name="l00088"></a>00088                             svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a>, svc-&gt;<a class="code" href="structptlrpc__service.html#ad777e605aff6b7a216384cec5917575b" title="size of individual buffers">srv_buf_size</a>);
<a name="l00089"></a>00089         <span class="keywordflow">if</span> (rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#ad4b53ddbaa302876b0e01ecf24287ce4" title="The buffer itself.">rqbd_buffer</a> == NULL) {
<a name="l00090"></a>00090                 <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(rqbd);
<a name="l00091"></a>00091                 <span class="keywordflow">return</span> NULL;
<a name="l00092"></a>00092         }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00095"></a>00095         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>);
<a name="l00096"></a>00096         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a44b088268ad85c097e75785018da059f" title="total # req buffer descs allocated">scp_nrqbds_total</a>++;
<a name="l00097"></a>00097         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         <span class="keywordflow">return</span> rqbd;
<a name="l00100"></a>00100 }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00103"></a><a class="code" href="service_8c.html#ab4c8313b60651ab857fe795c83b71b64">00103</a> <a class="code" href="service_8c.html#ab4c8313b60651ab857fe795c83b71b64">ptlrpc_free_rqbd</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *rqbd)
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt = rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a1e7bb4edc15fbecb9ef0800039fe255e" title="Back pointer to service for which this buffer is registered.">rqbd_svcpt</a>;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a00c44a4551ca8b0ccf4955d94f641c6b">rqbd_refcount</a> == 0);
<a name="l00108"></a>00108         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>));
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00111"></a>00111         <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>);
<a name="l00112"></a>00112         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a44b088268ad85c097e75785018da059f" title="total # req buffer descs allocated">scp_nrqbds_total</a>--;
<a name="l00113"></a>00113         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <a class="code" href="obd__support_8h.html#a23d443ea219d6893da5645c760e0c28a">OBD_FREE_LARGE</a>(rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#ad4b53ddbaa302876b0e01ecf24287ce4" title="The buffer itself.">rqbd_buffer</a>, svcpt-&gt;scp_service-&gt;srv_buf_size);
<a name="l00116"></a>00116         <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(rqbd);
<a name="l00117"></a>00117 }
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00120"></a><a class="code" href="service_8c.html#a30a2276abeb17ab744d168f4e53c2ee8">00120</a> <a class="code" href="service_8c.html#a30a2276abeb17ab744d168f4e53c2ee8">ptlrpc_grow_req_bufs</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt, <span class="keywordtype">int</span> post)
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>             *svc = svcpt-&gt;scp_service;
<a name="l00123"></a>00123         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *rqbd;
<a name="l00124"></a>00124         <span class="keywordtype">int</span>                                rc = 0;
<a name="l00125"></a>00125         <span class="keywordtype">int</span>                                i;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ad128b103863a3a90a2a0fffeaa9b0198" title="in progress of allocating rqbd">scp_rqbd_allocating</a>)
<a name="l00128"></a>00128                 <span class="keywordflow">goto</span> try_post;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00131"></a>00131         <span class="comment">/* check again with lock */</span>
<a name="l00132"></a>00132         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ad128b103863a3a90a2a0fffeaa9b0198" title="in progress of allocating rqbd">scp_rqbd_allocating</a>) {
<a name="l00133"></a>00133                 <span class="comment">/* NB: we might allow more than one thread in the future */</span>
<a name="l00134"></a>00134                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ad128b103863a3a90a2a0fffeaa9b0198" title="in progress of allocating rqbd">scp_rqbd_allocating</a> == 1);
<a name="l00135"></a>00135                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00136"></a>00136                 <span class="keywordflow">goto</span> try_post;
<a name="l00137"></a>00137         }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ad128b103863a3a90a2a0fffeaa9b0198" title="in progress of allocating rqbd">scp_rqbd_allocating</a>++;
<a name="l00140"></a>00140         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 
<a name="l00143"></a>00143         <span class="keywordflow">for</span> (i = 0; i &lt; svc-&gt;<a class="code" href="structptlrpc__service.html#a54dfbef346d31cd165d5815410fe7b25" title="# buffers to allocate in 1 group">srv_nbuf_per_group</a>; i++) {
<a name="l00144"></a>00144                 <span class="comment">/* NB: another thread might have recycled enough rqbds, we</span>
<a name="l00145"></a>00145 <span class="comment">                 * need to make sure it wouldn&apos;t over-allocate, see LU-1212. */</span>
<a name="l00146"></a>00146                 <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a" title="# posted request buffers for receiving">scp_nrqbds_posted</a> &gt;= svc-&gt;<a class="code" href="structptlrpc__service.html#a54dfbef346d31cd165d5815410fe7b25" title="# buffers to allocate in 1 group">srv_nbuf_per_group</a>)
<a name="l00147"></a>00147                         <span class="keywordflow">break</span>;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149                 rqbd = <a class="code" href="service_8c.html#aed50b6950afc4c4f1b9a2bac3a9e2e8b">ptlrpc_alloc_rqbd</a>(svcpt);
<a name="l00150"></a>00150 
<a name="l00151"></a>00151                 <span class="keywordflow">if</span> (rqbd == NULL) {
<a name="l00152"></a>00152                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;%s: Can&apos;t allocate request buffer\n&quot;</span>,
<a name="l00153"></a>00153                                svc-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>);
<a name="l00154"></a>00154                         rc = -ENOMEM;
<a name="l00155"></a>00155                         <span class="keywordflow">break</span>;
<a name="l00156"></a>00156                 }
<a name="l00157"></a>00157         }
<a name="l00158"></a>00158 
<a name="l00159"></a>00159         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ad128b103863a3a90a2a0fffeaa9b0198" title="in progress of allocating rqbd">scp_rqbd_allocating</a> == 1);
<a name="l00162"></a>00162         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ad128b103863a3a90a2a0fffeaa9b0198" title="in progress of allocating rqbd">scp_rqbd_allocating</a>--;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>,
<a name="l00167"></a>00167                <span class="stringliteral">&quot;%s: allocate %d new %d-byte reqbufs (%d/%d left), rc = %d\n&quot;</span>,
<a name="l00168"></a>00168                svc-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, i, svc-&gt;<a class="code" href="structptlrpc__service.html#ad777e605aff6b7a216384cec5917575b" title="size of individual buffers">srv_buf_size</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a" title="# posted request buffers for receiving">scp_nrqbds_posted</a>,
<a name="l00169"></a>00169                svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a44b088268ad85c097e75785018da059f" title="total # req buffer descs allocated">scp_nrqbds_total</a>, rc);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171  try_post:
<a name="l00172"></a>00172         <span class="keywordflow">if</span> (post &amp;&amp; rc == 0)
<a name="l00173"></a>00173                 rc = <a class="code" href="service_8c.html#aa3c644131d0f98fd22ad9ba28d49974c">ptlrpc_server_post_idle_rqbds</a>(svcpt);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175         <span class="keywordflow">return</span> rc;
<a name="l00176"></a>00176 }
<a name="l00177"></a>00177 
<a name="l00182"></a>00182 <span class="keywordtype">void</span>
<a name="l00183"></a><a class="code" href="group__net.html#ga686ce1d3f4b5ce9b59e59136cb6b265c">00183</a> <a class="code" href="group__net.html#ga686ce1d3f4b5ce9b59e59136cb6b265c" title="Server-side services API.">ptlrpc_save_lock</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00184"></a>00184                  <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lock, <span class="keywordtype">int</span> <a class="code" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, <span class="keywordtype">int</span> no_ack)
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs = req-&gt;rq_reply_state;
<a name="l00187"></a>00187         <span class="keywordtype">int</span>                        idx;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rs != NULL);
<a name="l00190"></a>00190         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a971c2d968f9044adfbb3361f6d938e51" title="Number of locks awaiting client ACK.">rs_nlocks</a> &lt; <a class="code" href="group__net.html#ga2d55f86d607f2386cec08e37daa7ce67" title="Maximum number of locks to fit into reply state.">RS_MAX_LOCKS</a>);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a6dced674d19d58ce0868336c044e1587">exp_disconnected</a>) {
<a name="l00193"></a>00193                 <a class="code" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref</a>(lock, mode);
<a name="l00194"></a>00194         } <span class="keywordflow">else</span> {
<a name="l00195"></a>00195                 idx = rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a971c2d968f9044adfbb3361f6d938e51" title="Number of locks awaiting client ACK.">rs_nlocks</a>++;
<a name="l00196"></a>00196                 rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a610b2cfcd3f4e63424d0d21e3faadb63" title="Handles of locks awaiting client reply ACK.">rs_locks</a>[idx] = *lock;
<a name="l00197"></a>00197                 rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ad8efd2c38ee66e40822759cd3d7255fe" title="Lock modes of locks in rs_locks.">rs_modes</a>[idx] = mode;
<a name="l00198"></a>00198                 rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a053119600f608d97cd028b4e145772f2" title="Reply state flags.">rs_difficult</a> = 1;
<a name="l00199"></a>00199                 rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a6a0ce650ec5a4ace7666db5c4808e52c">rs_no_ack</a> = !!no_ack;
<a name="l00200"></a>00200         }
<a name="l00201"></a>00201 }
<a name="l00202"></a>00202 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga686ce1d3f4b5ce9b59e59136cb6b265c" title="Server-side services API.">ptlrpc_save_lock</a>);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a>;
<a name="l00206"></a>00206 
<a name="l00207"></a><a class="code" href="structptlrpc__hr__thread.html">00207</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a> {
<a name="l00208"></a><a class="code" href="structptlrpc__hr__thread.html#a6e6c22649739a4ce26ccc8c949d4a44f">00208</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__hr__thread.html#a6e6c22649739a4ce26ccc8c949d4a44f">hrt_id</a>;         <span class="comment">/* thread ID */</span>
<a name="l00209"></a><a class="code" href="structptlrpc__hr__thread.html#a5ef8fc11622cd55e87511784bfb57399">00209</a>         spinlock_t                      <a class="code" href="structptlrpc__hr__thread.html#a5ef8fc11622cd55e87511784bfb57399">hrt_lock</a>;
<a name="l00210"></a><a class="code" href="structptlrpc__hr__thread.html#a6730eb323b734b3bf6c7edb5e628a1d0">00210</a>         wait_queue_head_t               <a class="code" href="structptlrpc__hr__thread.html#a6730eb323b734b3bf6c7edb5e628a1d0">hrt_waitq</a>;
<a name="l00211"></a><a class="code" href="structptlrpc__hr__thread.html#ab609ff12f3d8519d89938f225f785bd6">00211</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                        <a class="code" href="structptlrpc__hr__thread.html#ab609ff12f3d8519d89938f225f785bd6">hrt_queue</a>;      <span class="comment">/* RS queue */</span>
<a name="l00212"></a><a class="code" href="structptlrpc__hr__thread.html#aa0d61ec5b7897cd4e306e70c7ee4ca15">00212</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a>      *<a class="code" href="structptlrpc__hr__thread.html#aa0d61ec5b7897cd4e306e70c7ee4ca15">hrt_partition</a>;
<a name="l00213"></a>00213 };
<a name="l00214"></a>00214 
<a name="l00215"></a><a class="code" href="structptlrpc__hr__partition.html">00215</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a> {
<a name="l00216"></a>00216         <span class="comment">/* # of started threads */</span>
<a name="l00217"></a><a class="code" href="structptlrpc__hr__partition.html#abed863bf03fdd63df278d6507b7877d7">00217</a>         atomic_t                        <a class="code" href="structptlrpc__hr__partition.html#abed863bf03fdd63df278d6507b7877d7">hrp_nstarted</a>;
<a name="l00218"></a>00218         <span class="comment">/* # of stopped threads */</span>
<a name="l00219"></a><a class="code" href="structptlrpc__hr__partition.html#a8bd5e537e7a47254e03d1a6de0ac7dff">00219</a>         atomic_t                        <a class="code" href="structptlrpc__hr__partition.html#a8bd5e537e7a47254e03d1a6de0ac7dff">hrp_nstopped</a>;
<a name="l00220"></a>00220         <span class="comment">/* cpu partition id */</span>
<a name="l00221"></a><a class="code" href="structptlrpc__hr__partition.html#a5efa12e87b543d269df0adad94dfd674">00221</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__hr__partition.html#a5efa12e87b543d269df0adad94dfd674">hrp_cpt</a>;
<a name="l00222"></a>00222         <span class="comment">/* round-robin rotor for choosing thread */</span>
<a name="l00223"></a><a class="code" href="structptlrpc__hr__partition.html#a35b50cbc00de1a8e9913b209d8d4a734">00223</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__hr__partition.html#a35b50cbc00de1a8e9913b209d8d4a734">hrp_rotor</a>;
<a name="l00224"></a>00224         <span class="comment">/* total number of threads on this partition */</span>
<a name="l00225"></a><a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">00225</a>         <span class="keywordtype">int</span>                             <a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a>;
<a name="l00226"></a>00226         <span class="comment">/* threads table */</span>
<a name="l00227"></a><a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">00227</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a>         *<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a>;
<a name="l00228"></a>00228 };
<a name="l00229"></a>00229 
<a name="l00230"></a><a class="code" href="service_8c.html#a74f50884015f0b41cda5a936cf25dc1f">00230</a> <span class="preprocessor">#define HRT_RUNNING 0</span>
<a name="l00231"></a><a class="code" href="service_8c.html#afa47a1bdedf2b8af1cfb64ae2cccd6d8">00231</a> <span class="preprocessor"></span><span class="preprocessor">#define HRT_STOPPING 1</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span>
<a name="l00233"></a><a class="code" href="structptlrpc__hr__service.html">00233</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__service.html">ptlrpc_hr_service</a> {
<a name="l00234"></a>00234         <span class="comment">/* CPU partition table, it&apos;s just cfs_cpt_table for now */</span>
<a name="l00235"></a><a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">00235</a>         <span class="keyword">struct </span><a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>            *<a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">hr_cpt_table</a>;
<a name="l00237"></a><a class="code" href="structptlrpc__hr__service.html#a3a547a8ea02708f7ac764ce8a5170b43">00237</a>         wait_queue_head_t               <a class="code" href="structptlrpc__hr__service.html#a3a547a8ea02708f7ac764ce8a5170b43" title="controller sleep waitq">hr_waitq</a>;
<a name="l00238"></a><a class="code" href="structptlrpc__hr__service.html#afc4858378d71dde6bd6ed2414c174dc8">00238</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="structptlrpc__hr__service.html#afc4858378d71dde6bd6ed2414c174dc8">hr_stopping</a>;
<a name="l00240"></a><a class="code" href="structptlrpc__hr__service.html#a01895501b2ada24144a52321e3ed6e11">00240</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="structptlrpc__hr__service.html#a01895501b2ada24144a52321e3ed6e11" title="roundrobin rotor for non-affinity service">hr_rotor</a>;
<a name="l00241"></a>00241         <span class="comment">/* partition data */</span>
<a name="l00242"></a><a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">00242</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a>      **<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a>;
<a name="l00243"></a>00243 };
<a name="l00244"></a>00244 
<a name="l00245"></a><a class="code" href="structrs__batch.html">00245</a> <span class="keyword">struct </span><a class="code" href="structrs__batch.html">rs_batch</a> {
<a name="l00246"></a><a class="code" href="structrs__batch.html#a160470926c33ccda37385c064cb8a1de">00246</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                        <a class="code" href="structrs__batch.html#a160470926c33ccda37385c064cb8a1de">rsb_replies</a>;
<a name="l00247"></a><a class="code" href="structrs__batch.html#aaee3ff35732247166a682b97f9da69b9">00247</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    <a class="code" href="structrs__batch.html#aaee3ff35732247166a682b97f9da69b9">rsb_n_replies</a>;
<a name="l00248"></a><a class="code" href="structrs__batch.html#a0dd1b6e594f807b80f6d76256b330efd">00248</a>         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *<a class="code" href="structrs__batch.html#a0dd1b6e594f807b80f6d76256b330efd">rsb_svcpt</a>;
<a name="l00249"></a>00249 };
<a name="l00250"></a>00250 
<a name="l00252"></a><a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072">00252</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__service.html">ptlrpc_hr_service</a>         <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>;
<a name="l00253"></a>00253 
<a name="l00257"></a><a class="code" href="service_8c.html#a0e7952bed1f9084bd75d14b91da45ba1">00257</a> <span class="preprocessor">#define MAX_SCHEDULED 256</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span>
<a name="l00264"></a><a class="code" href="service_8c.html#a411747971396d61bbbaf5b5644fff526">00264</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#a411747971396d61bbbaf5b5644fff526" title="Initialize a reply batch.">rs_batch_init</a>(<span class="keyword">struct</span> <a class="code" href="structrs__batch.html">rs_batch</a> *b)
<a name="l00265"></a>00265 {
<a name="l00266"></a>00266         memset(b, 0, <span class="keyword">sizeof</span> *b);
<a name="l00267"></a>00267         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;b-&gt;<a class="code" href="structrs__batch.html#a160470926c33ccda37385c064cb8a1de">rsb_replies</a>);
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00273"></a>00273 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a> *
<a name="l00274"></a><a class="code" href="service_8c.html#a9f6d78a36a493da0ddbcdb98eb6c1b70">00274</a> <a class="code" href="service_8c.html#a9f6d78a36a493da0ddbcdb98eb6c1b70" title="Choose an hr thread to dispatch requests to.">ptlrpc_hr_select</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l00275"></a>00275 {
<a name="l00276"></a>00276         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a>      *hrp;
<a name="l00277"></a>00277         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    rotor;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a> &gt;= 0 &amp;&amp;
<a name="l00280"></a>00280             svcpt-&gt;scp_service-&gt;srv_cptable == <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">hr_cpt_table</a>) {
<a name="l00281"></a>00281                 <span class="comment">/* directly match partition */</span>
<a name="l00282"></a>00282                 hrp = <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a>[svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a>];
<a name="l00283"></a>00283 
<a name="l00284"></a>00284         } <span class="keywordflow">else</span> {
<a name="l00285"></a>00285                 rotor = <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a01895501b2ada24144a52321e3ed6e11" title="roundrobin rotor for non-affinity service">hr_rotor</a>++;
<a name="l00286"></a>00286                 rotor %= <a class="code" href="libcfs__cpu_8h.html#a9f06db96214d81272568b87e30e26d3e" title="return total number of CPU partitions in cptab ">cfs_cpt_number</a>(<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">hr_cpt_table</a>);
<a name="l00287"></a>00287 
<a name="l00288"></a>00288                 hrp = <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a>[rotor];
<a name="l00289"></a>00289         }
<a name="l00290"></a>00290 
<a name="l00291"></a>00291         rotor = hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a35b50cbc00de1a8e9913b209d8d4a734">hrp_rotor</a>++;
<a name="l00292"></a>00292         <span class="keywordflow">return</span> &amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a>[rotor % hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a>];
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00301"></a><a class="code" href="service_8c.html#a8508e7a2ae29df691ccbce2c99d12da3">00301</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#a8508e7a2ae29df691ccbce2c99d12da3" title="Dispatch all replies accumulated in the batch to one from dedicated reply handling...">rs_batch_dispatch</a>(<span class="keyword">struct</span> <a class="code" href="structrs__batch.html">rs_batch</a> *b)
<a name="l00302"></a>00302 {
<a name="l00303"></a>00303         <span class="keywordflow">if</span> (b-&gt;<a class="code" href="structrs__batch.html#aaee3ff35732247166a682b97f9da69b9">rsb_n_replies</a> != 0) {
<a name="l00304"></a>00304                 <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a> *hrt;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306                 hrt = <a class="code" href="service_8c.html#a9f6d78a36a493da0ddbcdb98eb6c1b70" title="Choose an hr thread to dispatch requests to.">ptlrpc_hr_select</a>(b-&gt;<a class="code" href="structrs__batch.html#a0dd1b6e594f807b80f6d76256b330efd">rsb_svcpt</a>);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308                 spin_lock(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a5ef8fc11622cd55e87511784bfb57399">hrt_lock</a>);
<a name="l00309"></a>00309                 <a class="code" href="list_8h.html#a948b15519bb72e3d42f3e56975580d30" title="Join two lists and reinitialise the emptied list.">list_splice_init</a>(&amp;b-&gt;<a class="code" href="structrs__batch.html#a160470926c33ccda37385c064cb8a1de">rsb_replies</a>, &amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#ab609ff12f3d8519d89938f225f785bd6">hrt_queue</a>);
<a name="l00310"></a>00310                 spin_unlock(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a5ef8fc11622cd55e87511784bfb57399">hrt_lock</a>);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312                 wake_up(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a6730eb323b734b3bf6c7edb5e628a1d0">hrt_waitq</a>);
<a name="l00313"></a>00313                 b-&gt;<a class="code" href="structrs__batch.html#aaee3ff35732247166a682b97f9da69b9">rsb_n_replies</a> = 0;
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315 }
<a name="l00316"></a>00316 
<a name="l00324"></a><a class="code" href="service_8c.html#ac0db37205b6dec202322fd1fcfe8cfbe">00324</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#ac0db37205b6dec202322fd1fcfe8cfbe" title="Add a reply to a batch.">rs_batch_add</a>(<span class="keyword">struct</span> <a class="code" href="structrs__batch.html">rs_batch</a> *b, <span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt = rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aca1f0b4b5dc96eb0b9c8c7012cfa4ba4">rs_svcpt</a>;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328         <span class="keywordflow">if</span> (svcpt != b-&gt;<a class="code" href="structrs__batch.html#a0dd1b6e594f807b80f6d76256b330efd">rsb_svcpt</a> || b-&gt;<a class="code" href="structrs__batch.html#aaee3ff35732247166a682b97f9da69b9">rsb_n_replies</a> &gt;= <a class="code" href="service_8c.html#a0e7952bed1f9084bd75d14b91da45ba1" title="maximum mumber of replies scheduled in one batch">MAX_SCHEDULED</a>) {
<a name="l00329"></a>00329                 <span class="keywordflow">if</span> (b-&gt;<a class="code" href="structrs__batch.html#a0dd1b6e594f807b80f6d76256b330efd">rsb_svcpt</a> != NULL) {
<a name="l00330"></a>00330                         <a class="code" href="service_8c.html#a8508e7a2ae29df691ccbce2c99d12da3" title="Dispatch all replies accumulated in the batch to one from dedicated reply handling...">rs_batch_dispatch</a>(b);
<a name="l00331"></a>00331                         spin_unlock(&amp;b-&gt;<a class="code" href="structrs__batch.html#a0dd1b6e594f807b80f6d76256b330efd">rsb_svcpt</a>-&gt;scp_rep_lock);
<a name="l00332"></a>00332                 }
<a name="l00333"></a>00333                 spin_lock(&amp;svcpt-&gt;scp_rep_lock);
<a name="l00334"></a>00334                 b-&gt;<a class="code" href="structrs__batch.html#a0dd1b6e594f807b80f6d76256b330efd">rsb_svcpt</a> = svcpt;
<a name="l00335"></a>00335         }
<a name="l00336"></a>00336         spin_lock(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l00337"></a>00337         rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a102a08c16b7884c2aa388d64774c5a9a">rs_scheduled_ever</a> = 1;
<a name="l00338"></a>00338         <span class="keywordflow">if</span> (rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a5ecfa6736210f6c83ec1c15fea5cd3ac">rs_scheduled</a> == 0) {
<a name="l00339"></a>00339                 <a class="code" href="list_8h.html#aee8df43e41969c2272acfd6ed6e75d4c" title="Remove an entry from the list it is currently in and insert it at the start of another...">list_move</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>, &amp;b-&gt;<a class="code" href="structrs__batch.html#a160470926c33ccda37385c064cb8a1de">rsb_replies</a>);
<a name="l00340"></a>00340                 rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a5ecfa6736210f6c83ec1c15fea5cd3ac">rs_scheduled</a> = 1;
<a name="l00341"></a>00341                 b-&gt;<a class="code" href="structrs__batch.html#aaee3ff35732247166a682b97f9da69b9">rsb_n_replies</a>++;
<a name="l00342"></a>00342         }
<a name="l00343"></a>00343         rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ac1225eab1d99d4f8db8d5ac02ef71557">rs_committed</a> = 1;
<a name="l00344"></a>00344         spin_unlock(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l00345"></a>00345 }
<a name="l00346"></a>00346 
<a name="l00354"></a><a class="code" href="service_8c.html#a779db3012eec07c43c3d57dc0fb2bff4">00354</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#a779db3012eec07c43c3d57dc0fb2bff4" title="Reply batch finalization.">rs_batch_fini</a>(<span class="keyword">struct</span> <a class="code" href="structrs__batch.html">rs_batch</a> *b)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356         <span class="keywordflow">if</span> (b-&gt;<a class="code" href="structrs__batch.html#a0dd1b6e594f807b80f6d76256b330efd">rsb_svcpt</a> != NULL) {
<a name="l00357"></a>00357                 <a class="code" href="service_8c.html#a8508e7a2ae29df691ccbce2c99d12da3" title="Dispatch all replies accumulated in the batch to one from dedicated reply handling...">rs_batch_dispatch</a>(b);
<a name="l00358"></a>00358                 spin_unlock(&amp;b-&gt;<a class="code" href="structrs__batch.html#a0dd1b6e594f807b80f6d76256b330efd">rsb_svcpt</a>-&gt;scp_rep_lock);
<a name="l00359"></a>00359         }
<a name="l00360"></a>00360 }
<a name="l00361"></a>00361 
<a name="l00362"></a><a class="code" href="service_8c.html#ae1ce5b998befbc6511c12bd072d274ad">00362</a> <span class="preprocessor">#define DECLARE_RS_BATCH(b)     struct rs_batch b</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span>
<a name="l00364"></a>00364 
<a name="l00369"></a><a class="code" href="group__net.html#gac133162c229195f6e9479dd79aac6473">00369</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gac133162c229195f6e9479dd79aac6473" title="Put reply state into a queue for processing because we received ACK from the client...">ptlrpc_dispatch_difficult_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs)
<a name="l00370"></a>00370 {
<a name="l00371"></a>00371         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a> *hrt;
<a name="l00372"></a>00372         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>));
<a name="l00375"></a>00375 
<a name="l00376"></a>00376         hrt = <a class="code" href="service_8c.html#a9f6d78a36a493da0ddbcdb98eb6c1b70" title="Choose an hr thread to dispatch requests to.">ptlrpc_hr_select</a>(rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aca1f0b4b5dc96eb0b9c8c7012cfa4ba4">rs_svcpt</a>);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378         spin_lock(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a5ef8fc11622cd55e87511784bfb57399">hrt_lock</a>);
<a name="l00379"></a>00379         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>, &amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#ab609ff12f3d8519d89938f225f785bd6">hrt_queue</a>);
<a name="l00380"></a>00380         spin_unlock(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a5ef8fc11622cd55e87511784bfb57399">hrt_lock</a>);
<a name="l00381"></a>00381 
<a name="l00382"></a>00382         wake_up(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a6730eb323b734b3bf6c7edb5e628a1d0">hrt_waitq</a>);
<a name="l00383"></a>00383         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00384"></a>00384 }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 <span class="keywordtype">void</span>
<a name="l00387"></a><a class="code" href="group__net.html#ga9ab523a4b395599275d00e72079b51f9">00387</a> <a class="code" href="group__net.html#ga9ab523a4b395599275d00e72079b51f9">ptlrpc_schedule_difficult_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs)
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00390"></a>00390 
<a name="l00391"></a>00391         assert_spin_locked(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aca1f0b4b5dc96eb0b9c8c7012cfa4ba4">rs_svcpt</a>-&gt;scp_rep_lock);
<a name="l00392"></a>00392         assert_spin_locked(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l00393"></a>00393         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a> (rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a053119600f608d97cd028b4e145772f2" title="Reply state flags.">rs_difficult</a>);
<a name="l00394"></a>00394         rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a102a08c16b7884c2aa388d64774c5a9a">rs_scheduled_ever</a> = 1;  <span class="comment">/* flag any notification attempt */</span>
<a name="l00395"></a>00395 
<a name="l00396"></a>00396         <span class="keywordflow">if</span> (rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a5ecfa6736210f6c83ec1c15fea5cd3ac">rs_scheduled</a>) {     <span class="comment">/* being set up or already notified */</span>
<a name="l00397"></a>00397                 <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00398"></a>00398                 <span class="keywordflow">return</span>;
<a name="l00399"></a>00399         }
<a name="l00400"></a>00400 
<a name="l00401"></a>00401         rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a5ecfa6736210f6c83ec1c15fea5cd3ac">rs_scheduled</a> = 1;
<a name="l00402"></a>00402         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>);
<a name="l00403"></a>00403         <a class="code" href="group__net.html#gac133162c229195f6e9479dd79aac6473" title="Put reply state into a queue for processing because we received ACK from the client...">ptlrpc_dispatch_difficult_reply</a>(rs);
<a name="l00404"></a>00404         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00405"></a>00405 }
<a name="l00406"></a>00406 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga9ab523a4b395599275d00e72079b51f9">ptlrpc_schedule_difficult_reply</a>);
<a name="l00407"></a>00407 
<a name="l00408"></a><a class="code" href="group__net.html#ga1c4d3548ace7c49c820adf3d6610f7a8">00408</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga1c4d3548ace7c49c820adf3d6610f7a8">ptlrpc_commit_replies</a>(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp)
<a name="l00409"></a>00409 {
<a name="l00410"></a>00410         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs, *nxt;
<a name="l00411"></a>00411         <a class="code" href="service_8c.html#ae1ce5b998befbc6511c12bd072d274ad">DECLARE_RS_BATCH</a>(batch);
<a name="l00412"></a>00412         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00413"></a>00413 
<a name="l00414"></a>00414         <a class="code" href="service_8c.html#a411747971396d61bbbaf5b5644fff526" title="Initialize a reply batch.">rs_batch_init</a>(&amp;batch);
<a name="l00415"></a>00415         <span class="comment">/* Find any replies that have been committed and get their service</span>
<a name="l00416"></a>00416 <span class="comment">         * to attend to complete them. */</span>
<a name="l00417"></a>00417 
<a name="l00418"></a>00418         <span class="comment">/* CAVEAT EMPTOR: spinlock ordering!!! */</span>
<a name="l00419"></a>00419         spin_lock(&amp;exp-&gt;<a class="code" href="structobd__export.html#acaaf11d4ac6705216d4297126839f5b4">exp_uncommitted_replies_lock</a>);
<a name="l00420"></a>00420         <a class="code" href="list_8h.html#ac3f72d6bd5144c7970824813810d2da1" title="Iterate over a list of given type safe against removal of list entry.">list_for_each_entry_safe</a>(rs, nxt, &amp;exp-&gt;<a class="code" href="structobd__export.html#a1d21051d9490506557d4f90c4c04699c">exp_uncommitted_replies</a>,
<a name="l00421"></a>00421                                      <a class="code" href="structptlrpc__reply__state.html#a123f596acacfe1cc660bf4ea5407c032" title="Linkage for list of all reply states for same obd.">rs_obd_list</a>) {
<a name="l00422"></a>00422                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a> (rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a053119600f608d97cd028b4e145772f2" title="Reply state flags.">rs_difficult</a>);
<a name="l00423"></a>00423                 <span class="comment">/* VBR: per-export last_committed */</span>
<a name="l00424"></a>00424                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rs-&gt;<a class="code" href="structptlrpc__reply__state.html#af0e79312da8f31e77da05b03ed266430">rs_export</a>);
<a name="l00425"></a>00425                 <span class="keywordflow">if</span> (rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aaa25f70935ff08384bd1f64ee0fb3ac0" title="Transaction number.">rs_transno</a> &lt;= exp-&gt;<a class="code" href="structobd__export.html#a99fd078f0cb65f312e4d80dd685cd2f5" title="Last committed transno for this export.">exp_last_committed</a>) {
<a name="l00426"></a>00426                         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a123f596acacfe1cc660bf4ea5407c032" title="Linkage for list of all reply states for same obd.">rs_obd_list</a>);
<a name="l00427"></a>00427                         <a class="code" href="service_8c.html#ac0db37205b6dec202322fd1fcfe8cfbe" title="Add a reply to a batch.">rs_batch_add</a>(&amp;batch, rs);
<a name="l00428"></a>00428                 }
<a name="l00429"></a>00429         }
<a name="l00430"></a>00430         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#acaaf11d4ac6705216d4297126839f5b4">exp_uncommitted_replies_lock</a>);
<a name="l00431"></a>00431         <a class="code" href="service_8c.html#a779db3012eec07c43c3d57dc0fb2bff4" title="Reply batch finalization.">rs_batch_fini</a>(&amp;batch);
<a name="l00432"></a>00432         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00433"></a>00433 }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00436"></a><a class="code" href="service_8c.html#aa3c644131d0f98fd22ad9ba28d49974c">00436</a> <a class="code" href="service_8c.html#aa3c644131d0f98fd22ad9ba28d49974c">ptlrpc_server_post_idle_rqbds</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l00437"></a>00437 {
<a name="l00438"></a>00438         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *rqbd;
<a name="l00439"></a>00439         <span class="keywordtype">int</span>                               rc;
<a name="l00440"></a>00440         <span class="keywordtype">int</span>                               posted = 0;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442         <span class="keywordflow">for</span> (;;) {
<a name="l00443"></a>00443                 spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445                 <span class="keywordflow">if</span> (<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>)) {
<a name="l00446"></a>00446                         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00447"></a>00447                         <span class="keywordflow">return</span> posted;
<a name="l00448"></a>00448                 }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450                 rqbd = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l00451"></a>00451                                       <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a>,
<a name="l00452"></a>00452                                       <a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>);
<a name="l00453"></a>00453                 <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455                 <span class="comment">/* assume we will post successfully */</span>
<a name="l00456"></a>00456                 svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a" title="# posted request buffers for receiving">scp_nrqbds_posted</a>++;
<a name="l00457"></a>00457                 <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#acd3cb2ad8f3ef3e78751f83373c0e688" title="req buffers receiving">scp_rqbd_posted</a>);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461                 rc = <a class="code" href="group__net.html#gaf7557fc8aa34bbf889ee11612ece2315" title="Register request buffer descriptor for request receiving.">ptlrpc_register_rqbd</a>(rqbd);
<a name="l00462"></a>00462                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00463"></a>00463                         <span class="keywordflow">break</span>;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465                 posted = 1;
<a name="l00466"></a>00466         }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a" title="# posted request buffers for receiving">scp_nrqbds_posted</a>--;
<a name="l00471"></a>00471         <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>);
<a name="l00472"></a>00472         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>);
<a name="l00473"></a>00473 
<a name="l00474"></a>00474         <span class="comment">/* Don&apos;t complain if no request buffers are posted right now; LNET</span>
<a name="l00475"></a>00475 <span class="comment">         * won&apos;t drop requests because we set the portal lazy! */</span>
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00478"></a>00478 
<a name="l00479"></a>00479         <span class="keywordflow">return</span> -1;
<a name="l00480"></a>00480 }
<a name="l00481"></a>00481 
<a name="l00482"></a><a class="code" href="service_8c.html#af921ffb9ea5bd5fa5e842e754bb41f29">00482</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#af921ffb9ea5bd5fa5e842e754bb41f29">ptlrpc_at_timer</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> castmeharder)
<a name="l00483"></a>00483 {
<a name="l00484"></a>00484         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt;
<a name="l00485"></a>00485 
<a name="l00486"></a>00486         svcpt = (<span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *)castmeharder;
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af1d7d89389261e865e0333f652c77b22" title="check early replies">scp_at_check</a> = 1;
<a name="l00489"></a>00489         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aa705fe1ad3fe28ba1b44a3ea327e185f" title="debug">scp_at_checktime</a> = <a class="code" href="linux-time_8h.html#adc63a7977338536b551ccc795e5a9148">cfs_time_current</a>();
<a name="l00490"></a>00490         wake_up(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aea613ac08a7dc84e671b4a260eed2765" title="all threads sleep on this.">scp_waitq</a>);
<a name="l00491"></a>00491 }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00494"></a><a class="code" href="service_8c.html#ac741a2591e6035bc09f137d7a799e811">00494</a> <a class="code" href="service_8c.html#ac741a2591e6035bc09f137d7a799e811">ptlrpc_server_nthreads_check</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc,
<a name="l00495"></a>00495                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__service__conf.html">ptlrpc_service_conf</a> *conf)
<a name="l00496"></a>00496 {
<a name="l00497"></a>00497         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__thr__conf.html">ptlrpc_service_thr_conf</a>  *tc = &amp;conf-&gt;<a class="code" href="structptlrpc__service__conf.html#af4a3a5d65129f9c83b22e3f89d4ec03b">psc_thr</a>;
<a name="l00498"></a>00498         <span class="keywordtype">unsigned</span>                        init;
<a name="l00499"></a>00499         <span class="keywordtype">unsigned</span>                        total;
<a name="l00500"></a>00500         <span class="keywordtype">unsigned</span>                        nthrs;
<a name="l00501"></a>00501         <span class="keywordtype">int</span>                             weight;
<a name="l00502"></a>00502 
<a name="l00503"></a>00503         <span class="comment">/*</span>
<a name="l00504"></a>00504 <span class="comment">         * Common code for estimating &amp; validating threads number.</span>
<a name="l00505"></a>00505 <span class="comment">         * CPT affinity service could have percpt thread-pool instead</span>
<a name="l00506"></a>00506 <span class="comment">         * of a global thread-pool, which means user might not always</span>
<a name="l00507"></a>00507 <span class="comment">         * get the threads number they give it in conf::tc_nthrs_user</span>
<a name="l00508"></a>00508 <span class="comment">         * even they did set. It&apos;s because we need to validate threads</span>
<a name="l00509"></a>00509 <span class="comment">         * number for each CPT to guarantee each pool will have enough</span>
<a name="l00510"></a>00510 <span class="comment">         * threads to keep the service healthy.</span>
<a name="l00511"></a>00511 <span class="comment">         */</span>
<a name="l00512"></a>00512         init = <a class="code" href="group__net.html#gafe956408171741e4f2fa929087b87a26">PTLRPC_NTHRS_INIT</a> + (svc-&gt;<a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90" title="service operations table">srv_ops</a>.<a class="code" href="structptlrpc__service__ops.html#a3b99111ca745490f2cd0cfd183482174" title="function to determine priority of the request, it&amp;#39;s called on every new request...">so_hpreq_handler</a> != NULL);
<a name="l00513"></a>00513         init = max_t(<span class="keywordtype">int</span>, init, tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#a9811887e7de9dab5dc4dcf99d7aeb2dd">tc_nthrs_init</a>);
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <span class="comment">/* NB: please see comments in lustre_lnet.h for definition</span>
<a name="l00516"></a>00516 <span class="comment">         * details of these members */</span>
<a name="l00517"></a>00517         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#ad465d01f0ec00aef63a06a4d1f62a412">tc_nthrs_max</a> != 0);
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         <span class="keywordflow">if</span> (tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#a5163137c6050e108c07df2f0d84aa38a">tc_nthrs_user</a> != 0) {
<a name="l00520"></a>00520                 <span class="comment">/* In case there is a reason to test a service with many</span>
<a name="l00521"></a>00521 <span class="comment">                 * threads, we give a less strict check here, it can</span>
<a name="l00522"></a>00522 <span class="comment">                 * be up to 8 * nthrs_max */</span>
<a name="l00523"></a>00523                 total = min(tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#ad465d01f0ec00aef63a06a4d1f62a412">tc_nthrs_max</a> * 8, tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#a5163137c6050e108c07df2f0d84aa38a">tc_nthrs_user</a>);
<a name="l00524"></a>00524                 nthrs = total / svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>;
<a name="l00525"></a>00525                 init  = <a class="code" href="lnet_2utils_2debug_8c.html#ae1e1dde676c120fa6d10f3bb2c14059e">max</a>(init, nthrs);
<a name="l00526"></a>00526                 <span class="keywordflow">goto</span> out;
<a name="l00527"></a>00527         }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529         total = tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#ad465d01f0ec00aef63a06a4d1f62a412">tc_nthrs_max</a>;
<a name="l00530"></a>00530         <span class="keywordflow">if</span> (tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#a3e348c438e9fbf3c4bf243d6bf51b6b4">tc_nthrs_base</a> == 0) {
<a name="l00531"></a>00531                 <span class="comment">/* don&apos;t care about base threads number per partition,</span>
<a name="l00532"></a>00532 <span class="comment">                 * this is most for non-affinity service */</span>
<a name="l00533"></a>00533                 nthrs = total / svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>;
<a name="l00534"></a>00534                 <span class="keywordflow">goto</span> out;
<a name="l00535"></a>00535         }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537         nthrs = tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#a3e348c438e9fbf3c4bf243d6bf51b6b4">tc_nthrs_base</a>;
<a name="l00538"></a>00538         <span class="keywordflow">if</span> (svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a> == 1) {
<a name="l00539"></a>00539                 <span class="keywordtype">int</span>     i;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541                 <span class="comment">/* NB: Increase the base number if it&apos;s single partition</span>
<a name="l00542"></a>00542 <span class="comment">                 * and total number of cores/HTs is larger or equal to 4.</span>
<a name="l00543"></a>00543 <span class="comment">                 * result will always &lt; 2 * nthrs_base */</span>
<a name="l00544"></a>00544                 weight = <a class="code" href="libcfs__cpu_8h.html#a490feb884ea09b464c88c79377cb22ee" title="return number of HW cores or hypter-threadings in a CPU partition cpt ">cfs_cpt_weight</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>, <a class="code" href="libcfs__cpu_8h.html#a0628df10a6276d56b4dd55643cf7ccbe">CFS_CPT_ANY</a>);
<a name="l00545"></a>00545                 <span class="keywordflow">for</span> (i = 1; (weight &gt;&gt; (i + 1)) != 0 &amp;&amp; <span class="comment">/* &gt;= 4 cores/HTs */</span>
<a name="l00546"></a>00546                             (tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#a3e348c438e9fbf3c4bf243d6bf51b6b4">tc_nthrs_base</a> &gt;&gt; i) != 0; i++)
<a name="l00547"></a>00547                         nthrs += tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#a3e348c438e9fbf3c4bf243d6bf51b6b4">tc_nthrs_base</a> &gt;&gt; i;
<a name="l00548"></a>00548         }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#acbf19dbd7b91406e75fee694f00cb99c">tc_thr_factor</a> != 0) {
<a name="l00551"></a>00551                 <span class="keywordtype">int</span>       factor = tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#acbf19dbd7b91406e75fee694f00cb99c">tc_thr_factor</a>;
<a name="l00552"></a>00552                 <span class="keyword">const</span> <span class="keywordtype">int</span> fade = 4;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554                 <span class="comment">/*</span>
<a name="l00555"></a>00555 <span class="comment">                 * User wants to increase number of threads with for</span>
<a name="l00556"></a>00556 <span class="comment">                 * each CPU core/HT, most likely the factor is larger than</span>
<a name="l00557"></a>00557 <span class="comment">                 * one thread/core because service threads are supposed to</span>
<a name="l00558"></a>00558 <span class="comment">                 * be blocked by lock or wait for IO.</span>
<a name="l00559"></a>00559 <span class="comment">                 */</span>
<a name="l00560"></a>00560                 <span class="comment">/*</span>
<a name="l00561"></a>00561 <span class="comment">                 * Amdahl&apos;s law says that adding processors wouldn&apos;t give</span>
<a name="l00562"></a>00562 <span class="comment">                 * a linear increasing of parallelism, so it&apos;s nonsense to</span>
<a name="l00563"></a>00563 <span class="comment">                 * have too many threads no matter how many cores/HTs</span>
<a name="l00564"></a>00564 <span class="comment">                 * there are.</span>
<a name="l00565"></a>00565 <span class="comment">                 */</span>
<a name="l00566"></a>00566                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__cpu_8h.html#a2896836dbe1aa4f858ce28320b682bc8" title="return number of HTs in the same core of cpu ">cfs_cpu_ht_nsiblings</a>(0) &gt; 1) { <span class="comment">/* weight is # of HTs */</span>
<a name="l00567"></a>00567                         <span class="comment">/* depress thread factor for hyper-thread */</span>
<a name="l00568"></a>00568                         factor = factor - (factor &gt;&gt; 1) + (factor &gt;&gt; 3);
<a name="l00569"></a>00569                 }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571                 weight = <a class="code" href="libcfs__cpu_8h.html#a490feb884ea09b464c88c79377cb22ee" title="return number of HW cores or hypter-threadings in a CPU partition cpt ">cfs_cpt_weight</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>, 0);
<a name="l00572"></a>00572                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(weight &gt; 0);
<a name="l00573"></a>00573 
<a name="l00574"></a>00574                 <span class="keywordflow">for</span> (; factor &gt; 0 &amp;&amp; weight &gt; 0; factor--, weight -= fade)
<a name="l00575"></a>00575                         nthrs += min(weight, fade) * factor;
<a name="l00576"></a>00576         }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         <span class="keywordflow">if</span> (nthrs * svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a> &gt; tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#ad465d01f0ec00aef63a06a4d1f62a412">tc_nthrs_max</a>) {
<a name="l00579"></a>00579                 nthrs = <a class="code" href="lnet_2utils_2debug_8c.html#ae1e1dde676c120fa6d10f3bb2c14059e">max</a>(tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#a3e348c438e9fbf3c4bf243d6bf51b6b4">tc_nthrs_base</a>,
<a name="l00580"></a>00580                             tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#ad465d01f0ec00aef63a06a4d1f62a412">tc_nthrs_max</a> / svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>);
<a name="l00581"></a>00581         }
<a name="l00582"></a>00582  out:
<a name="l00583"></a>00583         nthrs = <a class="code" href="lnet_2utils_2debug_8c.html#ae1e1dde676c120fa6d10f3bb2c14059e">max</a>(nthrs, tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#a9811887e7de9dab5dc4dcf99d7aeb2dd">tc_nthrs_init</a>);
<a name="l00584"></a>00584         svc-&gt;<a class="code" href="structptlrpc__service.html#ab1eb42fd85f14f4a6bccd9025ed5e101" title="limit of threads number for each partition">srv_nthrs_cpt_limit</a> = nthrs;
<a name="l00585"></a>00585         svc-&gt;<a class="code" href="structptlrpc__service.html#adcfb71b3b7e40714db19751ebf3889ad" title="threads # should be created for each partition on initializing">srv_nthrs_cpt_init</a> = init;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587         <span class="keywordflow">if</span> (nthrs * svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a> &gt; tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#ad465d01f0ec00aef63a06a4d1f62a412">tc_nthrs_max</a>) {
<a name="l00588"></a>00588                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#ab317254094d62cdd1f3b99bf74c98edc">D_OTHER</a>, <span class="stringliteral">&quot;%s: This service may have more threads (%d) &quot;</span>
<a name="l00589"></a>00589                        <span class="stringliteral">&quot;than the given soft limit (%d)\n&quot;</span>,
<a name="l00590"></a>00590                        svc-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, nthrs * svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>,
<a name="l00591"></a>00591                        tc-&gt;<a class="code" href="structptlrpc__service__thr__conf.html#ad465d01f0ec00aef63a06a4d1f62a412">tc_nthrs_max</a>);
<a name="l00592"></a>00592         }
<a name="l00593"></a>00593 }
<a name="l00594"></a>00594 
<a name="l00598"></a>00598 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00599"></a><a class="code" href="service_8c.html#ae8ee0d436d5d29f2484f26aec0bbc224">00599</a> <a class="code" href="service_8c.html#ae8ee0d436d5d29f2484f26aec0bbc224" title="Initialize percpt data for a service.">ptlrpc_service_part_init</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc,
<a name="l00600"></a>00600                          <span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt, <span class="keywordtype">int</span> cpt)
<a name="l00601"></a>00601 {
<a name="l00602"></a>00602         <span class="keyword">struct </span><a class="code" href="structptlrpc__at__array.html">ptlrpc_at_array</a>  *array;
<a name="l00603"></a>00603         <span class="keywordtype">int</span>                     <a class="code" href="lp__utils_8h.html#a439227feff9d7f55384e8780cfc2eb82">size</a>;
<a name="l00604"></a>00604         <span class="keywordtype">int</span>                     index;
<a name="l00605"></a>00605         <span class="keywordtype">int</span>                     rc;
<a name="l00606"></a>00606 
<a name="l00607"></a>00607         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a> = cpt;
<a name="l00608"></a>00608         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a658b2ed23da83f38e3acbe91191412e0" title="service threads list">scp_threads</a>);
<a name="l00609"></a>00609 
<a name="l00610"></a>00610         <span class="comment">/* rqbd and incoming request queue */</span>
<a name="l00611"></a>00611         spin_lock_init(&amp;svcpt-&gt;scp_lock);
<a name="l00612"></a>00612         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>);
<a name="l00613"></a>00613         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#acd3cb2ad8f3ef3e78751f83373c0e688" title="req buffers receiving">scp_rqbd_posted</a>);
<a name="l00614"></a>00614         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a54fb502a4f6c138aaa49eb9afea6e39c" title="incoming reqs">scp_req_incoming</a>);
<a name="l00615"></a>00615         init_waitqueue_head(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aea613ac08a7dc84e671b4a260eed2765" title="all threads sleep on this.">scp_waitq</a>);
<a name="l00616"></a>00616         <span class="comment">/* history request &amp; rqbd list */</span>
<a name="l00617"></a>00617         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a73331d554c2adc1cd1b47d6949cee7b4" title="request history">scp_hist_reqs</a>);
<a name="l00618"></a>00618         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aa72950e08d334ab8f1964a2640971efd" title="request buffer history">scp_hist_rqbds</a>);
<a name="l00619"></a>00619 
<a name="l00620"></a>00620         <span class="comment">/* acitve requests and hp requests */</span>
<a name="l00621"></a>00621         spin_lock_init(&amp;svcpt-&gt;scp_req_lock);
<a name="l00622"></a>00622 
<a name="l00623"></a>00623         <span class="comment">/* reply states */</span>
<a name="l00624"></a>00624         spin_lock_init(&amp;svcpt-&gt;scp_rep_lock);
<a name="l00625"></a>00625         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a38155a97f15fe794ff8720e2f8bcf249" title="all the active replies">scp_rep_active</a>);
<a name="l00626"></a>00626         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a1ba1dd17ce94daf0c4b82611d2203b77" title="List of free reply_states.">scp_rep_idle</a>);
<a name="l00627"></a>00627         init_waitqueue_head(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a2053b8073689ec3cedd16a7095656a13" title="waitq to run, when adding stuff to srv_free_rs_list">scp_rep_waitq</a>);
<a name="l00628"></a>00628         atomic_set(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a53b120d0b76021b70f62730a7fb490fe" title="# &amp;#39;difficult&amp;#39; replies">scp_nreps_difficult</a>, 0);
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         <span class="comment">/* adaptive timeout */</span>
<a name="l00631"></a>00631         spin_lock_init(&amp;svcpt-&gt;scp_at_lock);
<a name="l00632"></a>00632         array = &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aba4a06d005f80a1ffb87884f00b68698" title="reqs waiting for replies">scp_at_array</a>;
<a name="l00633"></a>00633 
<a name="l00634"></a>00634         size = <a class="code" href="group__export.html#ga723a170503743e83aa680bc5a421049a">at_est2timeout</a>(<a class="code" href="group__export.html#gad437939efbc33a157b6f386ac4a92ecb">at_max</a>);
<a name="l00635"></a>00635         array-&gt;<a class="code" href="structptlrpc__at__array.html#a4dd5aef596a563237a418ca153585cb4" title="array to hold requests">paa_size</a>     = size;
<a name="l00636"></a>00636         array-&gt;<a class="code" href="structptlrpc__at__array.html#aa2bee8a89fa940c5c5e62575c22eac19" title="the size of array">paa_count</a>    = 0;
<a name="l00637"></a>00637         array-&gt;<a class="code" href="structptlrpc__at__array.html#ad19d85164de63497bcd5fb2c6b1cec7e" title="the total count of reqs">paa_deadline</a> = -1;
<a name="l00638"></a>00638 
<a name="l00639"></a>00639         <span class="comment">/* allocate memory for scp_at_array (ptlrpc_at_array) */</span>
<a name="l00640"></a>00640         <a class="code" href="obd__support_8h.html#ad8b4f0ae380c3011bdfb663dbb37d01d">OBD_CPT_ALLOC</a>(array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a>,
<a name="l00641"></a>00641                       svc-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>, cpt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a>) * size);
<a name="l00642"></a>00642         <span class="keywordflow">if</span> (array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a> == NULL)
<a name="l00643"></a>00643                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00644"></a>00644 
<a name="l00645"></a>00645         <span class="keywordflow">for</span> (index = 0; index &lt; size; index++)
<a name="l00646"></a>00646                 <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a>[index]);
<a name="l00647"></a>00647 
<a name="l00648"></a>00648         <a class="code" href="obd__support_8h.html#ad8b4f0ae380c3011bdfb663dbb37d01d">OBD_CPT_ALLOC</a>(array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a>,
<a name="l00649"></a>00649                       svc-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>, cpt, <span class="keyword">sizeof</span>(__u32) * size);
<a name="l00650"></a>00650         <span class="keywordflow">if</span> (array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a> == NULL)
<a name="l00651"></a>00651                 <span class="keywordflow">goto</span> failed;
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         <a class="code" href="libcfs__prim_8h.html#a895a72c47b5f0f89fbb2e6cd3142e5ce">cfs_timer_init</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ac1e4c68a5aa6d83f2e5441ea05fe9d52" title="early reply timer">scp_at_timer</a>, <a class="code" href="service_8c.html#af921ffb9ea5bd5fa5e842e754bb41f29">ptlrpc_at_timer</a>, svcpt);
<a name="l00654"></a>00654         <span class="comment">/* At SOW, service time should be quick; 10s seems generous. If client</span>
<a name="l00655"></a>00655 <span class="comment">         * timeout is less than this, we&apos;ll be sending an early reply. */</span>
<a name="l00656"></a>00656         <a class="code" href="group__export.html#gad2eda377953eaceda983719642cfc885">at_init</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754" title="estimated rpc service time">scp_at_estimate</a>, 10, 0);
<a name="l00657"></a>00657 
<a name="l00658"></a>00658         <span class="comment">/* assign this before call ptlrpc_grow_req_bufs */</span>
<a name="l00659"></a>00659         svcpt-&gt;scp_service = svc;
<a name="l00660"></a>00660         <span class="comment">/* Now allocate the request buffers, but don&apos;t post them now */</span>
<a name="l00661"></a>00661         rc = <a class="code" href="service_8c.html#a30a2276abeb17ab744d168f4e53c2ee8">ptlrpc_grow_req_bufs</a>(svcpt, 0);
<a name="l00662"></a>00662         <span class="comment">/* We shouldn&apos;t be under memory pressure at startup, so</span>
<a name="l00663"></a>00663 <span class="comment">         * fail if we can&apos;t allocate all our buffers at this time. */</span>
<a name="l00664"></a>00664         <span class="keywordflow">if</span> (rc != 0)
<a name="l00665"></a>00665                 <span class="keywordflow">goto</span> failed;
<a name="l00666"></a>00666 
<a name="l00667"></a>00667         <span class="keywordflow">return</span> 0;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669  failed:
<a name="l00670"></a>00670         <span class="keywordflow">if</span> (array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a> != NULL) {
<a name="l00671"></a>00671                 <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a>, <span class="keyword">sizeof</span>(__u32) * size);
<a name="l00672"></a>00672                 array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a> = NULL;
<a name="l00673"></a>00673         }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675         <span class="keywordflow">if</span> (array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a> != NULL) {
<a name="l00676"></a>00676                 <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a>,
<a name="l00677"></a>00677                          <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a>) * array-&gt;<a class="code" href="structptlrpc__at__array.html#a4dd5aef596a563237a418ca153585cb4" title="array to hold requests">paa_size</a>);
<a name="l00678"></a>00678                 array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a> = NULL;
<a name="l00679"></a>00679         }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00682"></a>00682 }
<a name="l00683"></a>00683 
<a name="l00689"></a>00689 <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *
<a name="l00690"></a><a class="code" href="group__net.html#ga13835bf69545de9744051ff7ef02a4c3">00690</a> <a class="code" href="group__net.html#ga13835bf69545de9744051ff7ef02a4c3" title="Initialize service on a given portal.">ptlrpc_register_service</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__conf.html">ptlrpc_service_conf</a> *conf,
<a name="l00691"></a>00691                         <span class="keyword">struct</span> proc_dir_entry *proc_entry)
<a name="l00692"></a>00692 {
<a name="l00693"></a>00693         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__cpt__conf.html">ptlrpc_service_cpt_conf</a>  *cconf = &amp;conf-&gt;<a class="code" href="structptlrpc__service__conf.html#aae9801714220973ca2045994713ee29f">psc_cpt</a>;
<a name="l00694"></a>00694         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>           *<a class="code" href="o2iblnd__modparams_8c.html#a00f09e31c707a86ebc6b0cf74e934633">service</a>;
<a name="l00695"></a>00695         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *svcpt;
<a name="l00696"></a>00696         <span class="keyword">struct </span><a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>            *cptable;
<a name="l00697"></a>00697         __u32                           *cpts = NULL;
<a name="l00698"></a>00698         <span class="keywordtype">int</span>                             ncpts;
<a name="l00699"></a>00699         <span class="keywordtype">int</span>                             cpt;
<a name="l00700"></a>00700         <span class="keywordtype">int</span>                             rc;
<a name="l00701"></a>00701         <span class="keywordtype">int</span>                             i;
<a name="l00702"></a>00702         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a92db4a4b17c0b9d1a2de413682e920c5">psc_buf</a>.<a class="code" href="structptlrpc__service__buf__conf.html#a5425f22eea4efab36fe10eea49568621">bc_nbufs</a> &gt; 0);
<a name="l00705"></a>00705         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a92db4a4b17c0b9d1a2de413682e920c5">psc_buf</a>.<a class="code" href="structptlrpc__service__buf__conf.html#a111fde124aba74ef9926d047698f3bbd">bc_buf_size</a> &gt;=
<a name="l00706"></a>00706                 conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a92db4a4b17c0b9d1a2de413682e920c5">psc_buf</a>.<a class="code" href="structptlrpc__service__buf__conf.html#a6481bdbd63add844d8f19fe4edc0b274">bc_req_max_size</a> + <a class="code" href="group__sptlrpc.html#ga3958409bc75b758e9e09796d7ca3925e">SPTLRPC_MAX_PAYLOAD</a>);
<a name="l00707"></a>00707         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(conf-&gt;<a class="code" href="structptlrpc__service__conf.html#af4a3a5d65129f9c83b22e3f89d4ec03b">psc_thr</a>.<a class="code" href="structptlrpc__service__thr__conf.html#ad363cb8ec93914089247156213df4f4c">tc_ctx_tags</a> != 0);
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         cptable = cconf-&gt;<a class="code" href="structptlrpc__service__cpt__conf.html#a3ae6aeb10d67a26b16014ac3fbd4e554">cc_cptable</a>;
<a name="l00710"></a>00710         <span class="keywordflow">if</span> (cptable == NULL)
<a name="l00711"></a>00711                 cptable = <a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713         <span class="keywordflow">if</span> (!conf-&gt;<a class="code" href="structptlrpc__service__conf.html#af4a3a5d65129f9c83b22e3f89d4ec03b">psc_thr</a>.<a class="code" href="structptlrpc__service__thr__conf.html#a3813d0bb44f9b67a8d8a9bb72ab6d773">tc_cpu_affinity</a>) {
<a name="l00714"></a>00714                 ncpts = 1;
<a name="l00715"></a>00715         } <span class="keywordflow">else</span> {
<a name="l00716"></a>00716                 ncpts = <a class="code" href="libcfs__cpu_8h.html#a9f06db96214d81272568b87e30e26d3e" title="return total number of CPU partitions in cptab ">cfs_cpt_number</a>(cptable);
<a name="l00717"></a>00717                 <span class="keywordflow">if</span> (cconf-&gt;<a class="code" href="structptlrpc__service__cpt__conf.html#a11e9f954b98a8edcbcbc6f798fcb0398">cc_pattern</a> != NULL) {
<a name="l00718"></a>00718                         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a>    *el;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720                         rc = <a class="code" href="libcfs__string_8h.html#a9fceedd2da112e9e1d8c5515f7ed3404" title="Parses &amp;lt;cfs_expr_list&amp;gt; token of the syntax.">cfs_expr_list_parse</a>(cconf-&gt;<a class="code" href="structptlrpc__service__cpt__conf.html#a11e9f954b98a8edcbcbc6f798fcb0398">cc_pattern</a>,
<a name="l00721"></a>00721                                                  strlen(cconf-&gt;<a class="code" href="structptlrpc__service__cpt__conf.html#a11e9f954b98a8edcbcbc6f798fcb0398">cc_pattern</a>),
<a name="l00722"></a>00722                                                  0, ncpts - 1, &amp;el);
<a name="l00723"></a>00723                         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00724"></a>00724                                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;%s: invalid CPT pattern string: %s&quot;</span>,
<a name="l00725"></a>00725                                        conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a0226a541a4ad6a5f1d35e60fe433b9cd">psc_name</a>, cconf-&gt;<a class="code" href="structptlrpc__service__cpt__conf.html#a11e9f954b98a8edcbcbc6f798fcb0398">cc_pattern</a>);
<a name="l00726"></a>00726                                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(ERR_PTR(-EINVAL));
<a name="l00727"></a>00727                         }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729                         rc = <a class="code" href="libcfs__string_8h.html#a0d15cbaaa8cff42763c7cc3ae4192d69" title="Convert express list (expr_list) to an array of all matched values.">cfs_expr_list_values</a>(el, ncpts, &amp;cpts);
<a name="l00730"></a>00730                         <a class="code" href="libcfs__string_8h.html#a6c6e093e43e446f2c506e10b31ae5f1f" title="Frees cfs_range_expr structures of expr_list.">cfs_expr_list_free</a>(el);
<a name="l00731"></a>00731                         <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l00732"></a>00732                                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;%s: failed to parse CPT array %s: %d\n&quot;</span>,
<a name="l00733"></a>00733                                        conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a0226a541a4ad6a5f1d35e60fe433b9cd">psc_name</a>, cconf-&gt;<a class="code" href="structptlrpc__service__cpt__conf.html#a11e9f954b98a8edcbcbc6f798fcb0398">cc_pattern</a>, rc);
<a name="l00734"></a>00734                                 <span class="keywordflow">if</span> (cpts != NULL)
<a name="l00735"></a>00735                                         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(cpts, <span class="keyword">sizeof</span>(*cpts) * ncpts);
<a name="l00736"></a>00736                                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(ERR_PTR(rc &lt; 0 ? rc : -EINVAL));
<a name="l00737"></a>00737                         }
<a name="l00738"></a>00738                         ncpts = rc;
<a name="l00739"></a>00739                 }
<a name="l00740"></a>00740         }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         <a class="code" href="obd__support_8h.html#a884069f9eb0bef22c424688b5f3fafba">OBD_ALLOC</a>(service, <a class="code" href="group__lustreuser.html#gad4a7496cd704df3829c87864e7dbd703">offsetof</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>, srv_parts[ncpts]));
<a name="l00743"></a>00743         <span class="keywordflow">if</span> (service == NULL) {
<a name="l00744"></a>00744                 <span class="keywordflow">if</span> (cpts != NULL)
<a name="l00745"></a>00745                         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(cpts, <span class="keyword">sizeof</span>(*cpts) * ncpts);
<a name="l00746"></a>00746                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(ERR_PTR(-ENOMEM));
<a name="l00747"></a>00747         }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749         service-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>            = cptable;
<a name="l00750"></a>00750         service-&gt;<a class="code" href="structptlrpc__service.html#a2c32ba2dab0f289ff0ebbd2f093fe7ba" title="CPTs array this service bound on.">srv_cpts</a>               = cpts;
<a name="l00751"></a>00751         service-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>              = ncpts;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753         service-&gt;<a class="code" href="structptlrpc__service.html#a073426a7d8cdc28ce5ebe9849cc49695" title="2^srv_cptab_bits &amp;gt;= cfs_cpt_numbert(srv_cptable)">srv_cpt_bits</a> = 0; <span class="comment">/* it&apos;s zero already, easy to read... */</span>
<a name="l00754"></a>00754         <span class="keywordflow">while</span> ((1 &lt;&lt; service-&gt;<a class="code" href="structptlrpc__service.html#a073426a7d8cdc28ce5ebe9849cc49695" title="2^srv_cptab_bits &amp;gt;= cfs_cpt_numbert(srv_cptable)">srv_cpt_bits</a>) &lt; <a class="code" href="libcfs__cpu_8h.html#a9f06db96214d81272568b87e30e26d3e" title="return total number of CPU partitions in cptab ">cfs_cpt_number</a>(cptable))
<a name="l00755"></a>00755                 service-&gt;<a class="code" href="structptlrpc__service.html#a073426a7d8cdc28ce5ebe9849cc49695" title="2^srv_cptab_bits &amp;gt;= cfs_cpt_numbert(srv_cptable)">srv_cpt_bits</a>++;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         <span class="comment">/* public members */</span>
<a name="l00758"></a>00758         spin_lock_init(&amp;service-&gt;<a class="code" href="structptlrpc__service.html#a2a1688cbca333e023932a1d01da3adf2" title="serialize /proc operations">srv_lock</a>);
<a name="l00759"></a>00759         service-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>               = conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a0226a541a4ad6a5f1d35e60fe433b9cd">psc_name</a>;
<a name="l00760"></a>00760         service-&gt;<a class="code" href="structptlrpc__service.html#a1117d58e40a577dce38f8985a491c895" title="soft watchdog timeout multiplier">srv_watchdog_factor</a>    = conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a35c8446adc65e3bfd5be5cc7c2e7ff67">psc_watchdog_factor</a>;
<a name="l00761"></a>00761         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;service-&gt;<a class="code" href="structptlrpc__service.html#a7b76c93b05ae8b75256861ab53f5db59" title="most often accessed fields">srv_list</a>); <span class="comment">/* for safty of cleanup */</span>
<a name="l00762"></a>00762 
<a name="l00763"></a>00763         <span class="comment">/* buffer configuration */</span>
<a name="l00764"></a>00764         service-&gt;<a class="code" href="structptlrpc__service.html#a54dfbef346d31cd165d5815410fe7b25" title="# buffers to allocate in 1 group">srv_nbuf_per_group</a>     = <a class="code" href="ptlrpc__internal_8h.html#a840cfd893cfd1ea1f4ac7b04382ed44d">test_req_buffer_pressure</a> ?
<a name="l00765"></a>00765                                           1 : conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a92db4a4b17c0b9d1a2de413682e920c5">psc_buf</a>.<a class="code" href="structptlrpc__service__buf__conf.html#a5425f22eea4efab36fe10eea49568621">bc_nbufs</a>;
<a name="l00766"></a>00766         service-&gt;<a class="code" href="structptlrpc__service.html#a4e6fb169a6bd2375b8f724ec9c5c57bc" title="biggest request to receive">srv_max_req_size</a>       = conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a92db4a4b17c0b9d1a2de413682e920c5">psc_buf</a>.<a class="code" href="structptlrpc__service__buf__conf.html#a6481bdbd63add844d8f19fe4edc0b274">bc_req_max_size</a> +
<a name="l00767"></a>00767                                           <a class="code" href="group__sptlrpc.html#ga3958409bc75b758e9e09796d7ca3925e">SPTLRPC_MAX_PAYLOAD</a>;
<a name="l00768"></a>00768         service-&gt;<a class="code" href="structptlrpc__service.html#ad777e605aff6b7a216384cec5917575b" title="size of individual buffers">srv_buf_size</a>           = conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a92db4a4b17c0b9d1a2de413682e920c5">psc_buf</a>.<a class="code" href="structptlrpc__service__buf__conf.html#a111fde124aba74ef9926d047698f3bbd">bc_buf_size</a>;
<a name="l00769"></a>00769         service-&gt;<a class="code" href="structptlrpc__service.html#a80ea8b17769802197d27c45a7a485958" title="Portal on the client to send replies to.">srv_rep_portal</a>         = conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a92db4a4b17c0b9d1a2de413682e920c5">psc_buf</a>.<a class="code" href="structptlrpc__service__buf__conf.html#a071e03edf78bbb49ba217147de07c420">bc_rep_portal</a>;
<a name="l00770"></a>00770         service-&gt;<a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>         = conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a92db4a4b17c0b9d1a2de413682e920c5">psc_buf</a>.<a class="code" href="structptlrpc__service__buf__conf.html#a75992b630829661b0cefb296ac479c95">bc_req_portal</a>;
<a name="l00771"></a>00771 
<a name="l00772"></a>00772         <span class="comment">/* Increase max reply size to next power of two */</span>
<a name="l00773"></a>00773         service-&gt;<a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51" title="biggest reply to send">srv_max_reply_size</a> = 1;
<a name="l00774"></a>00774         <span class="keywordflow">while</span> (service-&gt;<a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51" title="biggest reply to send">srv_max_reply_size</a> &lt;
<a name="l00775"></a>00775                conf-&gt;<a class="code" href="structptlrpc__service__conf.html#a92db4a4b17c0b9d1a2de413682e920c5">psc_buf</a>.<a class="code" href="structptlrpc__service__buf__conf.html#a865a1965ba3ed2cc9cd7e1f05327feef">bc_rep_max_size</a> + <a class="code" href="group__sptlrpc.html#ga3958409bc75b758e9e09796d7ca3925e">SPTLRPC_MAX_PAYLOAD</a>)
<a name="l00776"></a>00776                 service-&gt;<a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51" title="biggest reply to send">srv_max_reply_size</a> &lt;&lt;= 1;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778         service-&gt;<a class="code" href="structptlrpc__service.html#a3618e53f527140ea9c7861f64565b321" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_thread_name</a>        = conf-&gt;<a class="code" href="structptlrpc__service__conf.html#af4a3a5d65129f9c83b22e3f89d4ec03b">psc_thr</a>.<a class="code" href="structptlrpc__service__thr__conf.html#a1449a4a4997a363d82233a9d7ab83178">tc_thr_name</a>;
<a name="l00779"></a>00779         service-&gt;<a class="code" href="structptlrpc__service.html#af76e91c99923a872836d738214efad63" title="Tags for lu_context associated with this thread, see struct lu_context.">srv_ctx_tags</a>           = conf-&gt;<a class="code" href="structptlrpc__service__conf.html#af4a3a5d65129f9c83b22e3f89d4ec03b">psc_thr</a>.<a class="code" href="structptlrpc__service__thr__conf.html#ad363cb8ec93914089247156213df4f4c">tc_ctx_tags</a>;
<a name="l00780"></a>00780         service-&gt;<a class="code" href="structptlrpc__service.html#a73de1e37738df30184d39314262bebbb" title="# hp per lp reqs to handle">srv_hpreq_ratio</a>        = <a class="code" href="group__net.html#ga4f4d7f4b592db13b248e9f0973608f71" title="How many high priority requests to serve before serving one normal priority request...">PTLRPC_SVC_HP_RATIO</a>;
<a name="l00781"></a>00781         service-&gt;<a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90" title="service operations table">srv_ops</a>                = conf-&gt;<a class="code" href="structptlrpc__service__conf.html#ab6bb2e644761768757a65f274c9965ec">psc_ops</a>;
<a name="l00782"></a>00782 
<a name="l00783"></a>00783         <span class="keywordflow">for</span> (i = 0; i &lt; ncpts; i++) {
<a name="l00784"></a>00784                 <span class="keywordflow">if</span> (!conf-&gt;<a class="code" href="structptlrpc__service__conf.html#af4a3a5d65129f9c83b22e3f89d4ec03b">psc_thr</a>.<a class="code" href="structptlrpc__service__thr__conf.html#a3813d0bb44f9b67a8d8a9bb72ab6d773">tc_cpu_affinity</a>)
<a name="l00785"></a>00785                         cpt = <a class="code" href="libcfs__cpu_8h.html#a0628df10a6276d56b4dd55643cf7ccbe">CFS_CPT_ANY</a>;
<a name="l00786"></a>00786                 <span class="keywordflow">else</span>
<a name="l00787"></a>00787                         cpt = cpts != NULL ? cpts[i] : i;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789                 <a class="code" href="obd__support_8h.html#ad8b4f0ae380c3011bdfb663dbb37d01d">OBD_CPT_ALLOC</a>(svcpt, cptable, cpt, <span class="keyword">sizeof</span>(*svcpt));
<a name="l00790"></a>00790                 <span class="keywordflow">if</span> (svcpt == NULL)
<a name="l00791"></a>00791                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(failed, rc = -ENOMEM);
<a name="l00792"></a>00792 
<a name="l00793"></a>00793                 service-&gt;<a class="code" href="structptlrpc__service.html#a7e35faf6ba1087f8f57b57fd8ef98bb8" title="partition data for ptlrpc service">srv_parts</a>[i] = svcpt;
<a name="l00794"></a>00794                 rc = <a class="code" href="service_8c.html#ae8ee0d436d5d29f2484f26aec0bbc224" title="Initialize percpt data for a service.">ptlrpc_service_part_init</a>(service, svcpt, cpt);
<a name="l00795"></a>00795                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00796"></a>00796                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(failed, rc);
<a name="l00797"></a>00797         }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799         <a class="code" href="service_8c.html#ac741a2591e6035bc09f137d7a799e811">ptlrpc_server_nthreads_check</a>(service, conf);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         rc = <a class="code" href="group__lnet__misc.html#ga1986737ae4fa6d8756708df641f024e3" title="Turn on the lazy portal attribute.">LNetSetLazyPortal</a>(service-&gt;<a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>);
<a name="l00802"></a>00802         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rc == 0);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         mutex_lock(&amp;<a class="code" href="ptlrpc__internal_8h.html#a9e88c117c1eccb6da9707b1f9430d4f3" title="Used to protect the ptlrpc_all_services list.">ptlrpc_all_services_mutex</a>);
<a name="l00805"></a>00805         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;service-&gt;<a class="code" href="structptlrpc__service.html#a7b76c93b05ae8b75256861ab53f5db59" title="most often accessed fields">srv_list</a>, &amp;<a class="code" href="ptlrpc__internal_8h.html#a9bbbe993837b9f20a26325525bc76bfb" title="Holds a list of all PTLRPC services.">ptlrpc_all_services</a>);
<a name="l00806"></a>00806         mutex_unlock(&amp;<a class="code" href="ptlrpc__internal_8h.html#a9e88c117c1eccb6da9707b1f9430d4f3" title="Used to protect the ptlrpc_all_services list.">ptlrpc_all_services_mutex</a>);
<a name="l00807"></a>00807 
<a name="l00808"></a>00808         <span class="keywordflow">if</span> (proc_entry != NULL)
<a name="l00809"></a>00809                 <a class="code" href="ptlrpc__internal_8h.html#aab8f753dcc744d942854530a5586924b">ptlrpc_lprocfs_register_service</a>(proc_entry, service);
<a name="l00810"></a>00810 
<a name="l00811"></a>00811         rc = <a class="code" href="nrs_8c.html#a107d0adae381864f5c53de6cc805a59f" title="Setup NRS heads on all service partitions of service svc, and register all compatible...">ptlrpc_service_nrs_setup</a>(service);
<a name="l00812"></a>00812         <span class="keywordflow">if</span> (rc != 0)
<a name="l00813"></a>00813                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(failed, rc);
<a name="l00814"></a>00814 
<a name="l00815"></a>00815         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;%s: Started, listening on portal %d\n&quot;</span>,
<a name="l00816"></a>00816                service-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, service-&gt;<a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>);
<a name="l00817"></a>00817 
<a name="l00818"></a>00818         rc = <a class="code" href="group__net.html#gae98dcdbb3ab34d8e067f6caf336c9d31">ptlrpc_start_threads</a>(service);
<a name="l00819"></a>00819         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00820"></a>00820                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Failed to start threads for service %s: %d\n&quot;</span>,
<a name="l00821"></a>00821                        service-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, rc);
<a name="l00822"></a>00822                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(failed, rc);
<a name="l00823"></a>00823         }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(service);
<a name="l00826"></a>00826 failed:
<a name="l00827"></a>00827         <a class="code" href="group__net.html#ga2f7edc9d9d00fa395262051c0f9fc855">ptlrpc_unregister_service</a>(service);
<a name="l00828"></a>00828         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(ERR_PTR(rc));
<a name="l00829"></a>00829 }
<a name="l00830"></a>00830 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga13835bf69545de9744051ff7ef02a4c3" title="Initialize service on a given portal.">ptlrpc_register_service</a>);
<a name="l00831"></a>00831 
<a name="l00836"></a><a class="code" href="service_8c.html#a2489791165b9da8139f7e6c88c50f26f">00836</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#a2489791165b9da8139f7e6c88c50f26f" title="to actually free the request, must be called without holding svc_lock.">ptlrpc_server_free_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00837"></a>00837 {
<a name="l00838"></a>00838         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>) == 0);
<a name="l00839"></a>00839         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;req-&gt;rq_timed_list));
<a name="l00840"></a>00840 
<a name="l00841"></a>00841         <span class="comment">/* DEBUG_REQ() assumes the reply state of a request with a valid</span>
<a name="l00842"></a>00842 <span class="comment">         * ref will not be destroyed until that reference is dropped. */</span>
<a name="l00843"></a>00843         <a class="code" href="group__net.html#gaaaac1ad8119782fe41d9f0a5cccec394">ptlrpc_req_drop_rs</a>(req);
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         <a class="code" href="group__sptlrpc.html#gabb77528ba2594382bae01ea165279b33">sptlrpc_svc_ctx_decref</a>(req);
<a name="l00846"></a>00846 
<a name="l00847"></a>00847         <span class="keywordflow">if</span> (req != &amp;req-&gt;rq_rqbd-&gt;rqbd_req) {
<a name="l00848"></a>00848                 <span class="comment">/* NB request buffers use an embedded</span>
<a name="l00849"></a>00849 <span class="comment">                 * req if the incoming req unlinked the</span>
<a name="l00850"></a>00850 <span class="comment">                 * MD; this isn&apos;t one of them! */</span>
<a name="l00851"></a>00851                 <a class="code" href="client_8c.html#a62d5a40d5504554ad53443f0ccae0cb2">ptlrpc_request_cache_free</a>(req);
<a name="l00852"></a>00852         }
<a name="l00853"></a>00853 }
<a name="l00854"></a>00854 
<a name="l00859"></a><a class="code" href="group__net.html#ga45bbc99a8cb3940b830d5ac581cd2f10">00859</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga45bbc99a8cb3940b830d5ac581cd2f10" title="drop a reference count of the request.">ptlrpc_server_drop_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l00860"></a>00860 {
<a name="l00861"></a>00861         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *rqbd = req-&gt;rq_rqbd;
<a name="l00862"></a>00862         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>        *svcpt = rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a1e7bb4edc15fbecb9ef0800039fe255e" title="Back pointer to service for which this buffer is registered.">rqbd_svcpt</a>;
<a name="l00863"></a>00863         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>             *svc = svcpt-&gt;scp_service;
<a name="l00864"></a>00864         <span class="keywordtype">int</span>                                refcount;
<a name="l00865"></a>00865         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                          *tmp;
<a name="l00866"></a>00866         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                          *nxt;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868         <span class="keywordflow">if</span> (!atomic_dec_and_test(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>))
<a name="l00869"></a>00869                 <span class="keywordflow">return</span>;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871         <span class="keywordflow">if</span> (req-&gt;rq_session.lc_state == <a class="code" href="group__lu.html#ggac56fa70640d169266a36bd75a951f182ad72ee6b200fc4b3b87a530efd851383f">LCS_ENTERED</a>) {
<a name="l00872"></a>00872                 <a class="code" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit</a>(&amp;req-&gt;rq_session);
<a name="l00873"></a>00873                 <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(&amp;req-&gt;rq_session);
<a name="l00874"></a>00874         }
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a9e26278917dfc99ef8c03ce46770d9bf" title="link into service&amp;#39;s srv_at_array">rq_at_linked</a>) {
<a name="l00877"></a>00877                 spin_lock(&amp;svcpt-&gt;scp_at_lock);
<a name="l00878"></a>00878                 <span class="comment">/* recheck with lock, in case it&apos;s unlinked by</span>
<a name="l00879"></a>00879 <span class="comment">                 * ptlrpc_at_check_timed() */</span>
<a name="l00880"></a>00880                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a9e26278917dfc99ef8c03ce46770d9bf" title="link into service&amp;#39;s srv_at_array">rq_at_linked</a>))
<a name="l00881"></a>00881                         <a class="code" href="service_8c.html#a7a53df8d8b8dad6cc5e77af7524794eb">ptlrpc_at_remove_timed</a>(req);
<a name="l00882"></a>00882                 spin_unlock(&amp;svcpt-&gt;scp_at_lock);
<a name="l00883"></a>00883         }
<a name="l00884"></a>00884 
<a name="l00885"></a>00885         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;req-&gt;rq_timed_list));
<a name="l00886"></a>00886 
<a name="l00887"></a>00887         <span class="comment">/* finalize request */</span>
<a name="l00888"></a>00888         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>) {
<a name="l00889"></a>00889                 <a class="code" href="obd__class_8h.html#a60de37a3a43d309602be633a0f1125f9">class_export_put</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l00890"></a>00890                 req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> = NULL;
<a name="l00891"></a>00891         }
<a name="l00892"></a>00892 
<a name="l00893"></a>00893         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>, &amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>);
<a name="l00896"></a>00896 
<a name="l00897"></a>00897         refcount = --(rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a00c44a4551ca8b0ccf4955d94f641c6b">rqbd_refcount</a>);
<a name="l00898"></a>00898         <span class="keywordflow">if</span> (refcount == 0) {
<a name="l00899"></a>00899                 <span class="comment">/* request buffer is now idle: add to history */</span>
<a name="l00900"></a>00900                 <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>);
<a name="l00901"></a>00901 
<a name="l00902"></a>00902                 <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aa72950e08d334ab8f1964a2640971efd" title="request buffer history">scp_hist_rqbds</a>);
<a name="l00903"></a>00903                 svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a46f749b9c04d8a939db8e29cbadadb0f" title="# request buffers in history">scp_hist_nrqbds</a>++;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905                 <span class="comment">/* cull some history?</span>
<a name="l00906"></a>00906 <span class="comment">                 * I expect only about 1 or 2 rqbds need to be recycled here */</span>
<a name="l00907"></a>00907                 <span class="keywordflow">while</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a46f749b9c04d8a939db8e29cbadadb0f" title="# request buffers in history">scp_hist_nrqbds</a> &gt; svc-&gt;<a class="code" href="structptlrpc__service.html#ab8c2b2b1eaca9032c565e830244fdfdb" title="max # request buffers in history per partition">srv_hist_nrqbds_cpt_max</a>) {
<a name="l00908"></a>00908                         rqbd = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aa72950e08d334ab8f1964a2640971efd" title="request buffer history">scp_hist_rqbds</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l00909"></a>00909                                           <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a>,
<a name="l00910"></a>00910                                           rqbd_list);
<a name="l00911"></a>00911 
<a name="l00912"></a>00912                         <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>);
<a name="l00913"></a>00913                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a46f749b9c04d8a939db8e29cbadadb0f" title="# request buffers in history">scp_hist_nrqbds</a>--;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915                         <span class="comment">/* remove rqbd&apos;s reqs from svc&apos;s req history while</span>
<a name="l00916"></a>00916 <span class="comment">                         * I&apos;ve got the service lock */</span>
<a name="l00917"></a>00917                         <a class="code" href="list_8h.html#ab8b24e6660ab3760c923e4b4db3fa502" title="Iterate over a list.">list_for_each</a>(tmp, &amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>) {
<a name="l00918"></a>00918                                 req = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(tmp, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00919"></a>00919                                                  rq_list);
<a name="l00920"></a>00920                                 <span class="comment">/* Track the highest culled req seq */</span>
<a name="l00921"></a>00921                                 <span class="keywordflow">if</span> (req-&gt;rq_history_seq &gt;
<a name="l00922"></a>00922                                     svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a" title="highest seq culled from history">scp_hist_seq_culled</a>) {
<a name="l00923"></a>00923                                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a" title="highest seq culled from history">scp_hist_seq_culled</a> =
<a name="l00924"></a>00924                                                 req-&gt;rq_history_seq;
<a name="l00925"></a>00925                                 }
<a name="l00926"></a>00926                                 <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;req-&gt;rq_history_list);
<a name="l00927"></a>00927                         }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929                         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00930"></a>00930 
<a name="l00931"></a>00931                         <a class="code" href="list_8h.html#a9e4b9328744994b9d3878f5dad75c09f" title="Iterate over a list safely.">list_for_each_safe</a>(tmp, nxt, &amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>) {
<a name="l00932"></a>00932                                 req = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#abbbf5edb64da4c85cf3e801f656cf02f" title="History of requests for this buffer.">rqbd_reqs</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l00933"></a>00933                                                  <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l00934"></a>00934                                                  rq_list);
<a name="l00935"></a>00935                                 <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l00936"></a>00936                                 <a class="code" href="service_8c.html#a2489791165b9da8139f7e6c88c50f26f" title="to actually free the request, must be called without holding svc_lock.">ptlrpc_server_free_request</a>(req);
<a name="l00937"></a>00937                         }
<a name="l00938"></a>00938 
<a name="l00939"></a>00939                         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l00940"></a>00940                         <span class="comment">/*</span>
<a name="l00941"></a>00941 <span class="comment">                         * now all reqs including the embedded req has been</span>
<a name="l00942"></a>00942 <span class="comment">                         * disposed, schedule request buffer for re-use.</span>
<a name="l00943"></a>00943 <span class="comment">                         */</span>
<a name="l00944"></a>00944                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a039d2591d32389c3b0e9c739c33cf263" title="This &amp;quot;embedded&amp;quot; request structure is only used for the last request to...">rqbd_req</a>.<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>) == 0);
<a name="l00945"></a>00945                         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a481f3ad3411929e1ac22fa12851b3107" title="Link item for rqbds on a service.">rqbd_list</a>, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>);
<a name="l00946"></a>00946                 }
<a name="l00947"></a>00947 
<a name="l00948"></a>00948                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00949"></a>00949         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;rq_reply_state &amp;&amp; req-&gt;rq_reply_state-&gt;rs_prealloc) {
<a name="l00950"></a>00950                 <span class="comment">/* If we are low on memory, we are not interested in history */</span>
<a name="l00951"></a>00951                 <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l00952"></a>00952                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;req-&gt;rq_history_list);
<a name="l00953"></a>00953 
<a name="l00954"></a>00954                 <span class="comment">/* Track the highest culled req seq */</span>
<a name="l00955"></a>00955                 <span class="keywordflow">if</span> (req-&gt;rq_history_seq &gt; svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a" title="highest seq culled from history">scp_hist_seq_culled</a>)
<a name="l00956"></a>00956                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aac3eedd439a5c744ab1cd7885152c68a" title="highest seq culled from history">scp_hist_seq_culled</a> = req-&gt;rq_history_seq;
<a name="l00957"></a>00957 
<a name="l00958"></a>00958                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960                 <a class="code" href="service_8c.html#a2489791165b9da8139f7e6c88c50f26f" title="to actually free the request, must be called without holding svc_lock.">ptlrpc_server_free_request</a>(req);
<a name="l00961"></a>00961         } <span class="keywordflow">else</span> {
<a name="l00962"></a>00962                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l00963"></a>00963         }
<a name="l00964"></a>00964 }
<a name="l00965"></a>00965 
<a name="l00967"></a><a class="code" href="group__net.html#gaedae07eef44eef7ce7d1b0cfe437804f">00967</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#gaedae07eef44eef7ce7d1b0cfe437804f" title="Change request export and move hp request from old export to new.">ptlrpc_request_change_export</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req,
<a name="l00968"></a>00968                                   <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *export)
<a name="l00969"></a>00969 {
<a name="l00970"></a>00970         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> != NULL) {
<a name="l00971"></a>00971                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;req-&gt;rq_exp_list));
<a name="l00972"></a>00972                 <span class="comment">/* remove rq_exp_list from last export */</span>
<a name="l00973"></a>00973                 spin_lock_bh(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">exp_rpc_lock</a>);
<a name="l00974"></a>00974                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;req-&gt;rq_exp_list);
<a name="l00975"></a>00975                 spin_unlock_bh(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">exp_rpc_lock</a>);
<a name="l00976"></a>00976                 <span class="comment">/* export has one reference already, so it`s safe to</span>
<a name="l00977"></a>00977 <span class="comment">                 * add req to export queue here and get another</span>
<a name="l00978"></a>00978 <span class="comment">                 * reference for request later */</span>
<a name="l00979"></a>00979                 spin_lock_bh(&amp;export-&gt;<a class="code" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">exp_rpc_lock</a>);
<a name="l00980"></a>00980                 <span class="keywordflow">if</span> (req-&gt;rq_ops != NULL) <span class="comment">/* hp request */</span>
<a name="l00981"></a>00981                         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;req-&gt;rq_exp_list, &amp;export-&gt;<a class="code" href="structobd__export.html#a23fbf73ffa8f3422b2a9f8ce038b8187">exp_hp_rpcs</a>);
<a name="l00982"></a>00982                 <span class="keywordflow">else</span>
<a name="l00983"></a>00983                         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;req-&gt;rq_exp_list, &amp;export-&gt;<a class="code" href="structobd__export.html#aa2b2950faa85653e564caefd91e240e5">exp_reg_rpcs</a>);
<a name="l00984"></a>00984                 spin_unlock_bh(&amp;export-&gt;<a class="code" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">exp_rpc_lock</a>);
<a name="l00985"></a>00985 
<a name="l00986"></a>00986                 <a class="code" href="obd__class_8h.html#a4852bdbebee2a70d6ea023a49ec915a1">class_export_rpc_dec</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l00987"></a>00987                 <a class="code" href="obd__class_8h.html#a60de37a3a43d309602be633a0f1125f9">class_export_put</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l00988"></a>00988         }
<a name="l00989"></a>00989 
<a name="l00990"></a>00990         <span class="comment">/* request takes one export refcount */</span>
<a name="l00991"></a>00991         req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> = <a class="code" href="obd__class_8h.html#a6e46dd899223d141967fabba76d36bd8">class_export_get</a>(export);
<a name="l00992"></a>00992         <a class="code" href="obd__class_8h.html#a0b998d2750c48d182576ee3f2463dde7">class_export_rpc_inc</a>(export);
<a name="l00993"></a>00993 
<a name="l00994"></a>00994         <span class="keywordflow">return</span>;
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l01001"></a><a class="code" href="service_8c.html#a2d71c5442a9a62c66bd99bc984d2c8d1">01001</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#a2d71c5442a9a62c66bd99bc984d2c8d1" title="to finish a request: stop sending more early replies, and release the request.">ptlrpc_server_finish_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l01002"></a>01002                                          <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01003"></a>01003 {
<a name="l01004"></a>01004         <a class="code" href="service_8c.html#aaa197378ce94c91c9a218f7b3f3faa8c" title="Remove the request from the export list.">ptlrpc_server_hpreq_fini</a>(req);
<a name="l01005"></a>01005 
<a name="l01006"></a>01006         <a class="code" href="group__net.html#ga45bbc99a8cb3940b830d5ac581cd2f10" title="drop a reference count of the request.">ptlrpc_server_drop_request</a>(req);
<a name="l01007"></a>01007 }
<a name="l01008"></a>01008 
<a name="l01013"></a><a class="code" href="service_8c.html#a82747d1c580374cfd9087a99f1c67750">01013</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#a82747d1c580374cfd9087a99f1c67750" title="to finish an active request: stop sending more early replies, and release the request...">ptlrpc_server_finish_active_request</a>(
<a name="l01014"></a>01014                                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l01015"></a>01015                                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01016"></a>01016 {
<a name="l01017"></a>01017         spin_lock(&amp;svcpt-&gt;scp_req_lock);
<a name="l01018"></a>01018         <a class="code" href="nrs_8c.html#a41d6af6b26aebda69530fe3537266dfd">ptlrpc_nrs_req_stop_nolock</a>(req);
<a name="l01019"></a>01019         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a>--;
<a name="l01020"></a>01020         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a97e5341e8ef49e047ef82b2cfa138ec8" title="server-side flags">rq_hp</a>)
<a name="l01021"></a>01021                 svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a5cb3e1be6fad443994888bc086aa5283" title="# HPreqs being served">scp_nhreqs_active</a>--;
<a name="l01022"></a>01022         spin_unlock(&amp;svcpt-&gt;scp_req_lock);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         <a class="code" href="nrs_8c.html#aa35053963b23dd9e0dc17f6b214da481" title="Releases resources for a request; is called after the request has been handled.">ptlrpc_nrs_req_finalize</a>(req);
<a name="l01025"></a>01025 
<a name="l01026"></a>01026         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> != NULL)
<a name="l01027"></a>01027                 <a class="code" href="obd__class_8h.html#a4852bdbebee2a70d6ea023a49ec915a1">class_export_rpc_dec</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l01028"></a>01028 
<a name="l01029"></a>01029         <a class="code" href="service_8c.html#a2d71c5442a9a62c66bd99bc984d2c8d1" title="to finish a request: stop sending more early replies, and release the request.">ptlrpc_server_finish_request</a>(svcpt, req);
<a name="l01030"></a>01030 }
<a name="l01031"></a>01031 
<a name="l01037"></a><a class="code" href="group__net.html#ga3b962a1b6e534a49a4848336555d1d89">01037</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga3b962a1b6e534a49a4848336555d1d89" title="This function makes sure dead exports are evicted in a timely manner.">ptlrpc_update_export_timer</a>(<span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp, <span class="keywordtype">long</span> extra_delay)
<a name="l01038"></a>01038 {
<a name="l01039"></a>01039         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *oldest_exp;
<a name="l01040"></a>01040         time_t oldest_time, new_time;
<a name="l01041"></a>01041 
<a name="l01042"></a>01042         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(exp);
<a name="l01045"></a>01045 
<a name="l01046"></a>01046         <span class="comment">/* Compensate for slow machines, etc, by faking our request time</span>
<a name="l01047"></a>01047 <span class="comment">           into the future.  Although this can break the strict time-ordering</span>
<a name="l01048"></a>01048 <span class="comment">           of the list, we can be really lazy here - we don&apos;t have to evict</span>
<a name="l01049"></a>01049 <span class="comment">           at the exact right moment.  Eventually, all silent exports</span>
<a name="l01050"></a>01050 <span class="comment">           will make it to the top of the list. */</span>
<a name="l01051"></a>01051 
<a name="l01052"></a>01052         <span class="comment">/* Do not pay attention on 1sec or smaller renewals. */</span>
<a name="l01053"></a>01053         new_time = <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() + extra_delay;
<a name="l01054"></a>01054         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structobd__export.html#a84db689e39028117188c5177e0b21dd0" title="When was last request received.">exp_last_request_time</a> + 1 <span class="comment">/*second */</span> &gt;= new_time)
<a name="l01055"></a>01055                 <a class="code" href="libcfs__debug_8h.html#add49da686844faee56b8f16f9c784085">RETURN_EXIT</a>;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057         exp-&gt;<a class="code" href="structobd__export.html#a84db689e39028117188c5177e0b21dd0" title="When was last request received.">exp_last_request_time</a> = new_time;
<a name="l01058"></a>01058 
<a name="l01059"></a>01059         <span class="comment">/* exports may get disconnected from the chain even though the</span>
<a name="l01060"></a>01060 <span class="comment">           export has references, so we must keep the spin lock while</span>
<a name="l01061"></a>01061 <span class="comment">           manipulating the lists */</span>
<a name="l01062"></a>01062         spin_lock(&amp;exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a318ff629a967bb291952c902b3357474">obd_dev_lock</a>);
<a name="l01063"></a>01063 
<a name="l01064"></a>01064         <span class="keywordflow">if</span> (<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;exp-&gt;<a class="code" href="structobd__export.html#a6bb9ba26dcffde196c0e80178558ced2" title="last_rcvd clt gen hash">exp_obd_chain_timed</a>)) {
<a name="l01065"></a>01065                 <span class="comment">/* this one is not timed */</span>
<a name="l01066"></a>01066                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a318ff629a967bb291952c902b3357474">obd_dev_lock</a>);
<a name="l01067"></a>01067                 <a class="code" href="libcfs__debug_8h.html#add49da686844faee56b8f16f9c784085">RETURN_EXIT</a>;
<a name="l01068"></a>01068         }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070         <a class="code" href="list_8h.html#a1c5ac6a6b04a03f5782e818daacf96e9" title="Remove an entry from the list it is currently in and insert it at the end of another...">list_move_tail</a>(&amp;exp-&gt;<a class="code" href="structobd__export.html#a6bb9ba26dcffde196c0e80178558ced2" title="last_rcvd clt gen hash">exp_obd_chain_timed</a>,
<a name="l01071"></a>01071                        &amp;exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a9836dbea2756fbca1b72a81434acc558">obd_exports_timed</a>);
<a name="l01072"></a>01072 
<a name="l01073"></a>01073         oldest_exp = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a9836dbea2756fbca1b72a81434acc558">obd_exports_timed</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l01074"></a>01074                                 <span class="keyword">struct</span> <a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>, <a class="code" href="structobd__export.html#a6bb9ba26dcffde196c0e80178558ced2" title="last_rcvd clt gen hash">exp_obd_chain_timed</a>);
<a name="l01075"></a>01075         oldest_time = oldest_exp-&gt;<a class="code" href="structobd__export.html#a84db689e39028117188c5177e0b21dd0" title="When was last request received.">exp_last_request_time</a>;
<a name="l01076"></a>01076         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a318ff629a967bb291952c902b3357474">obd_dev_lock</a>);
<a name="l01077"></a>01077 
<a name="l01078"></a>01078         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#aaaab64ca2afe41b1eba34a6ea4c97344">obd_recovering</a>) {
<a name="l01079"></a>01079                 <span class="comment">/* be nice to everyone during recovery */</span>
<a name="l01080"></a>01080                 <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l01081"></a>01081                 <span class="keywordflow">return</span>;
<a name="l01082"></a>01082         }
<a name="l01083"></a>01083 
<a name="l01084"></a>01084         <span class="comment">/* Note - racing to start/reset the obd_eviction timer is safe */</span>
<a name="l01085"></a>01085         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a23fb097a99f9b7361d915b59fc34f30b">obd_eviction_timer</a> == 0) {
<a name="l01086"></a>01086                 <span class="comment">/* Check if the oldest entry is expired. */</span>
<a name="l01087"></a>01087                 <span class="keywordflow">if</span> (<a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() &gt; (oldest_time + <a class="code" href="obd__support_8h.html#a9588506e55758d29f057f92948548196">PING_EVICT_TIMEOUT</a> +
<a name="l01088"></a>01088                                               extra_delay)) {
<a name="l01089"></a>01089                         <span class="comment">/* We need a second timer, in case the net was down and</span>
<a name="l01090"></a>01090 <span class="comment">                         * it just came back. Since the pinger may skip every</span>
<a name="l01091"></a>01091 <span class="comment">                         * other PING_INTERVAL (see note in ptlrpc_pinger_main),</span>
<a name="l01092"></a>01092 <span class="comment">                         * we better wait for 3. */</span>
<a name="l01093"></a>01093                         exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a23fb097a99f9b7361d915b59fc34f30b">obd_eviction_timer</a> =
<a name="l01094"></a>01094                                 <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() + 3 * <a class="code" href="obd__support_8h.html#ae138d10c7cd4199e5e96377ff1f8e317">PING_INTERVAL</a>;
<a name="l01095"></a>01095                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a125b66aada63eaccd986e27e8dac1ab2">D_HA</a>, <span class="stringliteral">&quot;%s: Think about evicting %s from &quot;</span><a class="code" href="linux-time_8h.html#aa7b76e99c79db328bd5ca8f4e5f32d95">CFS_TIME_T</a><span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01096"></a>01096                                exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a47f3a5a4e3b9ce7d39282c2aa1058985">obd_name</a>,
<a name="l01097"></a>01097                                <a class="code" href="obd__class_8h.html#a67d51620b7031eb947626281c6948d42">obd_export_nid2str</a>(oldest_exp), oldest_time);
<a name="l01098"></a>01098                 }
<a name="l01099"></a>01099         } <span class="keywordflow">else</span> {
<a name="l01100"></a>01100                 <span class="keywordflow">if</span> (<a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() &gt;
<a name="l01101"></a>01101                     (exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a23fb097a99f9b7361d915b59fc34f30b">obd_eviction_timer</a> + extra_delay)) {
<a name="l01102"></a>01102                         <span class="comment">/* The evictor won&apos;t evict anyone who we&apos;ve heard from</span>
<a name="l01103"></a>01103 <span class="comment">                         * recently, so we don&apos;t have to check before we start</span>
<a name="l01104"></a>01104 <span class="comment">                         * it. */</span>
<a name="l01105"></a>01105                         <span class="keywordflow">if</span> (!<a class="code" href="pinger_8c.html#ae27ab38649b956801ef131bc5661361a">ping_evictor_wake</a>(exp))
<a name="l01106"></a>01106                                 exp-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a23fb097a99f9b7361d915b59fc34f30b">obd_eviction_timer</a> = 0;
<a name="l01107"></a>01107                 }
<a name="l01108"></a>01108         }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l01111"></a>01111 }
<a name="l01112"></a>01112 
<a name="l01117"></a><a class="code" href="service_8c.html#a80f18cb077b5d857391b16687f9dcb0e">01117</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#a80f18cb077b5d857391b16687f9dcb0e" title="Sanity check request req.">ptlrpc_check_req</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01118"></a>01118 {
<a name="l01119"></a>01119         <span class="keyword">struct </span><a class="code" href="structobd__device.html">obd_device</a> *obd = req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>;
<a name="l01120"></a>01120         <span class="keywordtype">int</span> rc = 0;
<a name="l01121"></a>01121 
<a name="l01122"></a>01122         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(<a class="code" href="group__net.html#ga8a5b544ffbfafa4fb89c592e719ac9e5">lustre_msg_get_conn_cnt</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &lt;
<a name="l01123"></a>01123                      req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a339173861bb8b8eb01eaf33e6e24d119" title="Connection count value from last successful reconnect rpc.">exp_conn_cnt</a>)) {
<a name="l01124"></a>01124                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, req,
<a name="l01125"></a>01125                           <span class="stringliteral">&quot;DROPPING req from old connection %d &lt; %d&quot;</span>,
<a name="l01126"></a>01126                           <a class="code" href="group__net.html#ga8a5b544ffbfafa4fb89c592e719ac9e5">lustre_msg_get_conn_cnt</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>),
<a name="l01127"></a>01127                           req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a339173861bb8b8eb01eaf33e6e24d119" title="Connection count value from last successful reconnect rpc.">exp_conn_cnt</a>);
<a name="l01128"></a>01128                 <span class="keywordflow">return</span> -EEXIST;
<a name="l01129"></a>01129         }
<a name="l01130"></a>01130         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(obd == NULL || obd-&gt;<a class="code" href="structobd__device.html#a32c7ae5a6d0fe19f36cd1986b7808990">obd_fail</a>)) {
<a name="l01131"></a>01131                 <span class="comment">/* Failing over, don&apos;t handle any more reqs,</span>
<a name="l01132"></a>01132 <span class="comment">                 * send error response instead. */</span>
<a name="l01133"></a>01133                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, <span class="stringliteral">&quot;Dropping req %p for failed obd %s\n&quot;</span>,
<a name="l01134"></a>01134                         req, (obd != NULL) ? obd-&gt;<a class="code" href="structobd__device.html#a47f3a5a4e3b9ce7d39282c2aa1058985">obd_name</a> : <span class="stringliteral">&quot;unknown&quot;</span>);
<a name="l01135"></a>01135                 rc = -ENODEV;
<a name="l01136"></a>01136         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__net.html#ga7039633508af55679f204cff967f1879">lustre_msg_get_flags</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp;
<a name="l01137"></a>01137                    (<a class="code" href="group__lustreidl.html#gab6581834223318f6050e245588723c96">MSG_REPLAY</a> | <a class="code" href="group__lustreidl.html#ga58c5a8d05a96b9e39636f2b9e46e540b">MSG_REQ_REPLAY_DONE</a>) &amp;&amp;
<a name="l01138"></a>01138                    !obd-&gt;<a class="code" href="structobd__device.html#aaaab64ca2afe41b1eba34a6ea4c97344">obd_recovering</a>) {
<a name="l01139"></a>01139                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#af25fefaf5c55ce92d41da370dc9399c2">D_ERROR</a>, req,
<a name="l01140"></a>01140                                   <span class="stringliteral">&quot;Invalid replay without recovery&quot;</span>);
<a name="l01141"></a>01141                         <a class="code" href="obd__class_8h.html#ac0722e474e442ec044e953cd28e5188c">class_fail_export</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l01142"></a>01142                         rc = -ENODEV;
<a name="l01143"></a>01143         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__net.html#ga9bedef213e170e969899bfab36bb8fb0">lustre_msg_get_transno</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) != 0 &amp;&amp;
<a name="l01144"></a>01144                    !obd-&gt;<a class="code" href="structobd__device.html#aaaab64ca2afe41b1eba34a6ea4c97344">obd_recovering</a>) {
<a name="l01145"></a>01145                         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#af25fefaf5c55ce92d41da370dc9399c2">D_ERROR</a>, req, <span class="stringliteral">&quot;Invalid req with transno &quot;</span>
<a name="l01146"></a>01146                                   <a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot; without recovery&quot;</span>,
<a name="l01147"></a>01147                                   <a class="code" href="group__net.html#ga9bedef213e170e969899bfab36bb8fb0">lustre_msg_get_transno</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l01148"></a>01148                         <a class="code" href="obd__class_8h.html#ac0722e474e442ec044e953cd28e5188c">class_fail_export</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l01149"></a>01149                         rc = -ENODEV;
<a name="l01150"></a>01150         }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(rc &lt; 0)) {
<a name="l01153"></a>01153                 req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = rc;
<a name="l01154"></a>01154                 <a class="code" href="group__net.html#gab9ee87b413f0ce1ea5589d233011a30c">ptlrpc_error</a>(req);
<a name="l01155"></a>01155         }
<a name="l01156"></a>01156         <span class="keywordflow">return</span> rc;
<a name="l01157"></a>01157 }
<a name="l01158"></a>01158 
<a name="l01159"></a><a class="code" href="service_8c.html#a4757a6d721555e12790af773a0b36145">01159</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#a4757a6d721555e12790af773a0b36145">ptlrpc_at_set_timer</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l01160"></a>01160 {
<a name="l01161"></a>01161         <span class="keyword">struct </span><a class="code" href="structptlrpc__at__array.html">ptlrpc_at_array</a> *array = &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aba4a06d005f80a1ffb87884f00b68698" title="reqs waiting for replies">scp_at_array</a>;
<a name="l01162"></a>01162         __s32 next;
<a name="l01163"></a>01163 
<a name="l01164"></a>01164         <span class="keywordflow">if</span> (array-&gt;<a class="code" href="structptlrpc__at__array.html#aa2bee8a89fa940c5c5e62575c22eac19" title="the size of array">paa_count</a> == 0) {
<a name="l01165"></a>01165                 <a class="code" href="libcfs__prim_8h.html#a73357d243036c731f58cf6cf50d34ad7">cfs_timer_disarm</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ac1e4c68a5aa6d83f2e5441ea05fe9d52" title="early reply timer">scp_at_timer</a>);
<a name="l01166"></a>01166                 <span class="keywordflow">return</span>;
<a name="l01167"></a>01167         }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169         <span class="comment">/* Set timer for closest deadline */</span>
<a name="l01170"></a>01170         next = (__s32)(array-&gt;<a class="code" href="structptlrpc__at__array.html#ad19d85164de63497bcd5fb2c6b1cec7e" title="the total count of reqs">paa_deadline</a> - <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() -
<a name="l01171"></a>01171                        <a class="code" href="obd__support_8h.html#a47a70ddef4976d21923b761d4b637514">at_early_margin</a>);
<a name="l01172"></a>01172         <span class="keywordflow">if</span> (next &lt;= 0) {
<a name="l01173"></a>01173                 <a class="code" href="service_8c.html#af921ffb9ea5bd5fa5e842e754bb41f29">ptlrpc_at_timer</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)svcpt);
<a name="l01174"></a>01174         } <span class="keywordflow">else</span> {
<a name="l01175"></a>01175                 <a class="code" href="libcfs__prim_8h.html#ad993e65d22283a72e167773153cde76c">cfs_timer_arm</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ac1e4c68a5aa6d83f2e5441ea05fe9d52" title="early reply timer">scp_at_timer</a>, <a class="code" href="libcfs__time_8h.html#a7af2831a39c8a28afcb278541ede7193">cfs_time_shift</a>(next));
<a name="l01176"></a>01176                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;armed %s at %+ds\n&quot;</span>,
<a name="l01177"></a>01177                        svcpt-&gt;scp_service-&gt;srv_name, next);
<a name="l01178"></a>01178         }
<a name="l01179"></a>01179 }
<a name="l01180"></a>01180 
<a name="l01181"></a>01181 <span class="comment">/* Add rpc to early reply check list */</span>
<a name="l01182"></a><a class="code" href="service_8c.html#a870c7d7495f1f30e402923ad17a49687">01182</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#a870c7d7495f1f30e402923ad17a49687">ptlrpc_at_add_timed</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01183"></a>01183 {
<a name="l01184"></a>01184         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt = req-&gt;rq_rqbd-&gt;rqbd_svcpt;
<a name="l01185"></a>01185         <span class="keyword">struct </span><a class="code" href="structptlrpc__at__array.html">ptlrpc_at_array</a> *array = &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aba4a06d005f80a1ffb87884f00b68698" title="reqs waiting for replies">scp_at_array</a>;
<a name="l01186"></a>01186         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *rq = NULL;
<a name="l01187"></a>01187         __u32 index;
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         <span class="keywordflow">if</span> (<a class="code" href="group__export.html#ga8a5d48126ef884f74f2de78ef49ea61a">AT_OFF</a>)
<a name="l01190"></a>01190                 <span class="keywordflow">return</span>(0);
<a name="l01191"></a>01191 
<a name="l01192"></a>01192         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a1b90ce1f4dbe19dc586d3c7d5d7bb167">rq_no_reply</a>)
<a name="l01193"></a>01193                 <span class="keywordflow">return</span> 0;
<a name="l01194"></a>01194 
<a name="l01195"></a>01195         <span class="keywordflow">if</span> ((<a class="code" href="group__net.html#gafa52f54de41c43cabe289cdaa7fedc1b">lustre_msghdr_get_flags</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; <a class="code" href="group__lustreidl.html#ga3f2d351b95a850943970bf309b7dc61f">MSGHDR_AT_SUPPORT</a>) == 0)
<a name="l01196"></a>01196                 <span class="keywordflow">return</span>(-ENOSYS);
<a name="l01197"></a>01197 
<a name="l01198"></a>01198         spin_lock(&amp;svcpt-&gt;scp_at_lock);
<a name="l01199"></a>01199         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;req-&gt;rq_timed_list));
<a name="l01200"></a>01200 
<a name="l01201"></a>01201         index = (<span class="keywordtype">unsigned</span> long)req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> % array-&gt;<a class="code" href="structptlrpc__at__array.html#a4dd5aef596a563237a418ca153585cb4" title="array to hold requests">paa_size</a>;
<a name="l01202"></a>01202         if (array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a>[index] &gt; 0) {
<a name="l01203"></a>01203                 <span class="comment">/* latest rpcs will have the latest deadlines in the list,</span>
<a name="l01204"></a>01204 <span class="comment">                 * so search backward. */</span>
<a name="l01205"></a>01205                 <a class="code" href="list_8h.html#accc8d8e6c8ffe8ce964c5a1b59732cf3" title="Iterate backwards over a list of given type.">list_for_each_entry_reverse</a>(rq,
<a name="l01206"></a>01206                                                 &amp;array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a>[index],
<a name="l01207"></a>01207                                                 <a class="code" href="group__net.html#gacc0944ef09687a9201caa304a2fd3df7">rq_timed_list</a>) {
<a name="l01208"></a>01208                         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> &gt;= rq-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>) {
<a name="l01209"></a>01209                                 <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;req-&gt;rq_timed_list,
<a name="l01210"></a>01210                                              &amp;rq-&gt;rq_timed_list);
<a name="l01211"></a>01211                                 <span class="keywordflow">break</span>;
<a name="l01212"></a>01212                         }
<a name="l01213"></a>01213                 }
<a name="l01214"></a>01214         }
<a name="l01215"></a>01215 
<a name="l01216"></a>01216         <span class="comment">/* Add the request at the head of the list */</span>
<a name="l01217"></a>01217         <span class="keywordflow">if</span> (<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;req-&gt;rq_timed_list))
<a name="l01218"></a>01218                 <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;req-&gt;rq_timed_list,
<a name="l01219"></a>01219                              &amp;array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a>[index]);
<a name="l01220"></a>01220 
<a name="l01221"></a>01221         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01222"></a>01222         req-&gt;<a class="code" href="structptlrpc__request.html#a9e26278917dfc99ef8c03ce46770d9bf" title="link into service&amp;#39;s srv_at_array">rq_at_linked</a> = 1;
<a name="l01223"></a>01223         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01224"></a>01224         req-&gt;rq_at_index = index;
<a name="l01225"></a>01225         array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a>[index]++;
<a name="l01226"></a>01226         array-&gt;<a class="code" href="structptlrpc__at__array.html#aa2bee8a89fa940c5c5e62575c22eac19" title="the size of array">paa_count</a>++;
<a name="l01227"></a>01227         <span class="keywordflow">if</span> (array-&gt;<a class="code" href="structptlrpc__at__array.html#aa2bee8a89fa940c5c5e62575c22eac19" title="the size of array">paa_count</a> == 1 || array-&gt;<a class="code" href="structptlrpc__at__array.html#ad19d85164de63497bcd5fb2c6b1cec7e" title="the total count of reqs">paa_deadline</a> &gt; req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>) {
<a name="l01228"></a>01228                 array-&gt;<a class="code" href="structptlrpc__at__array.html#ad19d85164de63497bcd5fb2c6b1cec7e" title="the total count of reqs">paa_deadline</a> = req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>;
<a name="l01229"></a>01229                 <a class="code" href="service_8c.html#a4757a6d721555e12790af773a0b36145">ptlrpc_at_set_timer</a>(svcpt);
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231         spin_unlock(&amp;svcpt-&gt;scp_at_lock);
<a name="l01232"></a>01232 
<a name="l01233"></a>01233         <span class="keywordflow">return</span> 0;
<a name="l01234"></a>01234 }
<a name="l01235"></a>01235 
<a name="l01236"></a>01236 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01237"></a><a class="code" href="service_8c.html#a7a53df8d8b8dad6cc5e77af7524794eb">01237</a> <a class="code" href="service_8c.html#a7a53df8d8b8dad6cc5e77af7524794eb">ptlrpc_at_remove_timed</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01238"></a>01238 {
<a name="l01239"></a>01239         <span class="keyword">struct </span><a class="code" href="structptlrpc__at__array.html">ptlrpc_at_array</a> *array;
<a name="l01240"></a>01240 
<a name="l01241"></a>01241         array = &amp;req-&gt;rq_rqbd-&gt;rqbd_svcpt-&gt;scp_at_array;
<a name="l01242"></a>01242 
<a name="l01243"></a>01243         <span class="comment">/* NB: must call with hold svcpt::scp_at_lock */</span>
<a name="l01244"></a>01244         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;req-&gt;rq_timed_list));
<a name="l01245"></a>01245         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;req-&gt;rq_timed_list);
<a name="l01246"></a>01246 
<a name="l01247"></a>01247         spin_lock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01248"></a>01248         req-&gt;<a class="code" href="structptlrpc__request.html#a9e26278917dfc99ef8c03ce46770d9bf" title="link into service&amp;#39;s srv_at_array">rq_at_linked</a> = 0;
<a name="l01249"></a>01249         spin_unlock(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#afb9723e194dc3b27d3721e45e5428d62" title="Lock to protect request flags and some other important bits, like rq_list.">rq_lock</a>);
<a name="l01250"></a>01250 
<a name="l01251"></a>01251         array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a>[req-&gt;rq_at_index]--;
<a name="l01252"></a>01252         array-&gt;<a class="code" href="structptlrpc__at__array.html#aa2bee8a89fa940c5c5e62575c22eac19" title="the size of array">paa_count</a>--;
<a name="l01253"></a>01253 }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255 <span class="comment">/*</span>
<a name="l01256"></a>01256 <span class="comment"> * Attempt to extend the request deadline by sending an early reply to the</span>
<a name="l01257"></a>01257 <span class="comment"> * client.</span>
<a name="l01258"></a>01258 <span class="comment"> */</span>
<a name="l01259"></a><a class="code" href="service_8c.html#aa46d5add9948a153701350bb60d73f40">01259</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#aa46d5add9948a153701350bb60d73f40">ptlrpc_at_send_early_reply</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01260"></a>01260 {
<a name="l01261"></a>01261         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt = req-&gt;rq_rqbd-&gt;rqbd_svcpt;
<a name="l01262"></a>01262         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *reqcopy;
<a name="l01263"></a>01263         <span class="keyword">struct </span><a class="code" href="group__lustreidl.html#ga89e700d146c2a3e6d25089bdf59fb0b9">lustre_msg</a> *reqmsg;
<a name="l01264"></a>01264         <a class="code" href="linux-time_8h.html#af2983229a5c106d92b8a64c1c89e78e0">cfs_duration_t</a> olddl = req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> - <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>();
<a name="l01265"></a>01265         time_t  newdl;
<a name="l01266"></a>01266         <span class="keywordtype">int</span> rc;
<a name="l01267"></a>01267 
<a name="l01268"></a>01268         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01269"></a>01269 
<a name="l01270"></a>01270         <span class="keywordflow">if</span> (<a class="code" href="libcfs__fail_8h.html#a1c9aef9dc12ace2aebb26b88d3922abc">CFS_FAIL_CHECK</a>(<a class="code" href="obd__support_8h.html#ad8dbd69f638d1ce7c464d3c9462494ee">OBD_FAIL_TGT_REPLAY_RECONNECT</a>)) {
<a name="l01271"></a>01271                 <span class="comment">/* don&apos;t send early reply */</span>
<a name="l01272"></a>01272                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(1);
<a name="l01273"></a>01273         }
<a name="l01274"></a>01274 
<a name="l01275"></a>01275         <span class="comment">/* deadline is when the client expects us to reply, margin is the</span>
<a name="l01276"></a>01276 <span class="comment">           difference between clients&apos; and servers&apos; expectations */</span>
<a name="l01277"></a>01277         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a>, req,
<a name="l01278"></a>01278                   <span class="stringliteral">&quot;%ssending early reply (deadline %+lds, margin %+lds) for &quot;</span>
<a name="l01279"></a>01279                   <span class="stringliteral">&quot;%d+%d&quot;</span>, <a class="code" href="group__export.html#ga8a5d48126ef884f74f2de78ef49ea61a">AT_OFF</a> ? <span class="stringliteral">&quot;AT off - not &quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l01280"></a>01280                   olddl, olddl - <a class="code" href="group__export.html#ga68221f24f8416268d266c57882e21fe5">at_get</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754" title="estimated rpc service time">scp_at_estimate</a>),
<a name="l01281"></a>01281                   <a class="code" href="group__export.html#ga68221f24f8416268d266c57882e21fe5">at_get</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754" title="estimated rpc service time">scp_at_estimate</a>), <a class="code" href="obd__support_8h.html#a30b9fa4cca5a373d84fb01422c5e239d">at_extra</a>);
<a name="l01282"></a>01282 
<a name="l01283"></a>01283         <span class="keywordflow">if</span> (<a class="code" href="group__export.html#ga8a5d48126ef884f74f2de78ef49ea61a">AT_OFF</a>)
<a name="l01284"></a>01284                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286         <span class="keywordflow">if</span> (olddl &lt; 0) {
<a name="l01287"></a>01287                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#acca9c9cff9837f6f3d2759b02a61ff1d">D_WARNING</a>, req, <span class="stringliteral">&quot;Already past deadline (%+lds), &quot;</span>
<a name="l01288"></a>01288                           <span class="stringliteral">&quot;not sending early reply. Consider increasing &quot;</span>
<a name="l01289"></a>01289                           <span class="stringliteral">&quot;at_early_margin (%d)?&quot;</span>, olddl, <a class="code" href="obd__support_8h.html#a47a70ddef4976d21923b761d4b637514">at_early_margin</a>);
<a name="l01290"></a>01290 
<a name="l01291"></a>01291                 <span class="comment">/* Return an error so we&apos;re not re-added to the timed list. */</span>
<a name="l01292"></a>01292                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-ETIMEDOUT);
<a name="l01293"></a>01293         }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295         <span class="keywordflow">if</span> ((<a class="code" href="group__net.html#gafa52f54de41c43cabe289cdaa7fedc1b">lustre_msghdr_get_flags</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; <a class="code" href="group__lustreidl.html#ga3f2d351b95a850943970bf309b7dc61f">MSGHDR_AT_SUPPORT</a>) == 0){
<a name="l01296"></a>01296                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, req, <span class="stringliteral">&quot;Wanted to ask client for more time, &quot;</span>
<a name="l01297"></a>01297                           <span class="stringliteral">&quot;but no AT support&quot;</span>);
<a name="l01298"></a>01298                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-ENOSYS);
<a name="l01299"></a>01299         }
<a name="l01300"></a>01300 
<a name="l01301"></a>01301         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> &amp;&amp;
<a name="l01302"></a>01302             <a class="code" href="group__net.html#ga7039633508af55679f204cff967f1879">lustre_msg_get_flags</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp;
<a name="l01303"></a>01303             (<a class="code" href="group__lustreidl.html#gab6581834223318f6050e245588723c96">MSG_REPLAY</a> | <a class="code" href="group__lustreidl.html#ga58c5a8d05a96b9e39636f2b9e46e540b">MSG_REQ_REPLAY_DONE</a> | <a class="code" href="group__lustreidl.html#gae966d47b53fb59afa92ba2d0d9163bfc">MSG_LOCK_REPLAY_DONE</a>)) {
<a name="l01304"></a>01304                 <span class="comment">/* During recovery, we don&apos;t want to send too many early</span>
<a name="l01305"></a>01305 <span class="comment">                 * replies, but on the other hand we want to make sure the</span>
<a name="l01306"></a>01306 <span class="comment">                 * client has enough time to resend if the rpc is lost. So</span>
<a name="l01307"></a>01307 <span class="comment">                 * during the recovery period send at least 4 early replies,</span>
<a name="l01308"></a>01308 <span class="comment">                 * spacing them every at_extra if we can. at_estimate should</span>
<a name="l01309"></a>01309 <span class="comment">                 * always equal this fixed value during recovery. */</span>
<a name="l01310"></a>01310                 <span class="comment">/* Don&apos;t account request processing time into AT history</span>
<a name="l01311"></a>01311 <span class="comment">                 * during recovery, it is not service time we need but</span>
<a name="l01312"></a>01312 <span class="comment">                 * includes also waiting time for recovering clients */</span>
<a name="l01313"></a>01313                 newdl = <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() + min(<a class="code" href="obd__support_8h.html#a30b9fa4cca5a373d84fb01422c5e239d">at_extra</a>,
<a name="l01314"></a>01314                         req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#ac57b711443babae6934247ba9e5e8b9e">obd_recovery_timeout</a> / 4);
<a name="l01315"></a>01315         } <span class="keywordflow">else</span> {
<a name="l01316"></a>01316                 <span class="comment">/* We want to extend the request deadline by at_extra seconds,</span>
<a name="l01317"></a>01317 <span class="comment">                 * so we set our service estimate to reflect how much time has</span>
<a name="l01318"></a>01318 <span class="comment">                 * passed since this request arrived plus an additional</span>
<a name="l01319"></a>01319 <span class="comment">                 * at_extra seconds. The client will calculate the new deadline</span>
<a name="l01320"></a>01320 <span class="comment">                 * based on this service estimate (plus some additional time to</span>
<a name="l01321"></a>01321 <span class="comment">                 * account for network latency). See ptlrpc_at_recv_early_reply</span>
<a name="l01322"></a>01322 <span class="comment">                 */</span>
<a name="l01323"></a>01323                 <a class="code" href="group__export.html#ga7f701ef24e4393b42eb56ffc4777a1d8">at_measured</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754" title="estimated rpc service time">scp_at_estimate</a>, <a class="code" href="obd__support_8h.html#a30b9fa4cca5a373d84fb01422c5e239d">at_extra</a> +
<a name="l01324"></a>01324                             <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() -
<a name="l01325"></a>01325                             req-&gt;rq_arrival_time.tv_sec);
<a name="l01326"></a>01326                 newdl = req-&gt;rq_arrival_time.tv_sec +
<a name="l01327"></a>01327                         <a class="code" href="group__export.html#ga68221f24f8416268d266c57882e21fe5">at_get</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754" title="estimated rpc service time">scp_at_estimate</a>);
<a name="l01328"></a>01328         }
<a name="l01329"></a>01329 
<a name="l01330"></a>01330         <span class="comment">/* Check to see if we&apos;ve actually increased the deadline -</span>
<a name="l01331"></a>01331 <span class="comment">         * we may be past adaptive_max */</span>
<a name="l01332"></a>01332         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> &gt;= newdl) {
<a name="l01333"></a>01333                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#acca9c9cff9837f6f3d2759b02a61ff1d">D_WARNING</a>, req, <span class="stringliteral">&quot;Couldn&apos;t add any time &quot;</span>
<a name="l01334"></a>01334                           <span class="stringliteral">&quot;(%ld/%ld), not sending early reply\n&quot;</span>,
<a name="l01335"></a>01335                           olddl, newdl - <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>());
<a name="l01336"></a>01336                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-ETIMEDOUT);
<a name="l01337"></a>01337         }
<a name="l01338"></a>01338 
<a name="l01339"></a>01339         reqcopy = <a class="code" href="client_8c.html#af6ed95facf669fc40ac53a9ffa67cf1b">ptlrpc_request_cache_alloc</a>(GFP_NOFS);
<a name="l01340"></a>01340         <span class="keywordflow">if</span> (reqcopy == NULL)
<a name="l01341"></a>01341                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-ENOMEM);
<a name="l01342"></a>01342         <a class="code" href="obd__support_8h.html#afa959cd10c660882cd6c5fad07311897">OBD_ALLOC_LARGE</a>(reqmsg, req-&gt;<a class="code" href="structptlrpc__request.html#a9746010150c167d5b6e62786d61f18df" title="Request length.">rq_reqlen</a>);
<a name="l01343"></a>01343         <span class="keywordflow">if</span> (!reqmsg)
<a name="l01344"></a>01344                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out_free, rc = -ENOMEM);
<a name="l01345"></a>01345 
<a name="l01346"></a>01346         *reqcopy = *req;
<a name="l01347"></a>01347         reqcopy-&gt;rq_reply_state = NULL;
<a name="l01348"></a>01348         reqcopy-&gt;<a class="code" href="structptlrpc__request.html#afaf8be69b70dbe6926fb273611fa037b">rq_rep_swab_mask</a> = 0;
<a name="l01349"></a>01349         reqcopy-&gt;<a class="code" href="structptlrpc__request.html#a4af60b591ffbbbd6e3365ef8a5320a45">rq_pack_bulk</a> = 0;
<a name="l01350"></a>01350         reqcopy-&gt;<a class="code" href="structptlrpc__request.html#a462d2c356285145a57a35325d78e0d44">rq_pack_udesc</a> = 0;
<a name="l01351"></a>01351         reqcopy-&gt;<a class="code" href="structptlrpc__request.html#aadfcdd8f9119f3f92f018aae66c6ffce" title="packed final reply">rq_packed_final</a> = 0;
<a name="l01352"></a>01352         <a class="code" href="group__sptlrpc.html#gac66b97b1dc648126eca05d226eb472d4">sptlrpc_svc_ctx_addref</a>(reqcopy);
<a name="l01353"></a>01353         <span class="comment">/* We only need the reqmsg for the magic */</span>
<a name="l01354"></a>01354         reqcopy-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> = reqmsg;
<a name="l01355"></a>01355         memcpy(reqmsg, req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>, req-&gt;<a class="code" href="structptlrpc__request.html#a9746010150c167d5b6e62786d61f18df" title="Request length.">rq_reqlen</a>);
<a name="l01356"></a>01356 
<a name="l01357"></a>01357         <span class="comment">/*</span>
<a name="l01358"></a>01358 <span class="comment">         * tgt_brw_read() and tgt_brw_write() may have decided not to reply.</span>
<a name="l01359"></a>01359 <span class="comment">         * Without this check, we would fail the rq_no_reply assertion in</span>
<a name="l01360"></a>01360 <span class="comment">         * ptlrpc_send_reply().</span>
<a name="l01361"></a>01361 <span class="comment">         */</span>
<a name="l01362"></a>01362         <span class="keywordflow">if</span> (reqcopy-&gt;<a class="code" href="structptlrpc__request.html#a1b90ce1f4dbe19dc586d3c7d5d7bb167">rq_no_reply</a>)
<a name="l01363"></a>01363                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc = -ETIMEDOUT);
<a name="l01364"></a>01364 
<a name="l01365"></a>01365         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>));
<a name="l01367"></a>01367         <span class="keywordflow">if</span> (atomic_read(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>) == 1) {
<a name="l01368"></a>01368                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a>, reqcopy, <span class="stringliteral">&quot;Normal reply already sent out, &quot;</span>
<a name="l01369"></a>01369                           <span class="stringliteral">&quot;abort sending early reply\n&quot;</span>);
<a name="l01370"></a>01370                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc = -EINVAL);
<a name="l01371"></a>01371         }
<a name="l01372"></a>01372 
<a name="l01373"></a>01373         <span class="comment">/* Connection ref */</span>
<a name="l01374"></a>01374         reqcopy-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> = <a class="code" href="group__export.html#ga81cdb4586b1839c76ecdd5abb1eabe49">class_conn2export</a>(
<a name="l01375"></a>01375                                      <a class="code" href="group__net.html#gad75d2dc265242a98676033489842e8c1">lustre_msg_get_handle</a>(reqcopy-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l01376"></a>01376         <span class="keywordflow">if</span> (reqcopy-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> == NULL)
<a name="l01377"></a>01377                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc = -ENODEV);
<a name="l01378"></a>01378 
<a name="l01379"></a>01379         <span class="comment">/* RPC ref */</span>
<a name="l01380"></a>01380         <a class="code" href="obd__class_8h.html#a0b998d2750c48d182576ee3f2463dde7">class_export_rpc_inc</a>(reqcopy-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l01381"></a>01381         <span class="keywordflow">if</span> (reqcopy-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a> &amp;&amp;
<a name="l01382"></a>01382             reqcopy-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#ab0e9778c418ab982cb6befb298b38368" title="Obd device of this export.">exp_obd</a>-&gt;<a class="code" href="structobd__device.html#a32c7ae5a6d0fe19f36cd1986b7808990">obd_fail</a>)
<a name="l01383"></a>01383                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out_put, rc = -ENODEV);
<a name="l01384"></a>01384 
<a name="l01385"></a>01385         rc = <a class="code" href="group__net.html#ga59c89b28811f4f38f28b2b7d339797f6">lustre_pack_reply_flags</a>(reqcopy, 1, NULL, NULL, <a class="code" href="group__net.html#ga199fecbfb969a5e469f5f84fcffa12a4">LPRFL_EARLY_REPLY</a>);
<a name="l01386"></a>01386         <span class="keywordflow">if</span> (rc)
<a name="l01387"></a>01387                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out_put, rc);
<a name="l01388"></a>01388 
<a name="l01389"></a>01389         rc = <a class="code" href="group__net.html#ga563a5d436790759334ba2a51f0dce12e" title="Send request reply from request req reply buffer.">ptlrpc_send_reply</a>(reqcopy, <a class="code" href="group__net.html#ga4223d4b654456d504d272bebd9ebba23">PTLRPC_REPLY_EARLY</a>);
<a name="l01390"></a>01390 
<a name="l01391"></a>01391         <span class="keywordflow">if</span> (!rc) {
<a name="l01392"></a>01392                 <span class="comment">/* Adjust our own deadline to what we told the client */</span>
<a name="l01393"></a>01393                 req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> = newdl;
<a name="l01394"></a>01394                 req-&gt;<a class="code" href="structptlrpc__request.html#a4107706ff91738c79e18c271469afe8d" title="how many early replies (for stats)">rq_early_count</a>++; <span class="comment">/* number sent, server side */</span>
<a name="l01395"></a>01395         } <span class="keywordflow">else</span> {
<a name="l01396"></a>01396                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#af25fefaf5c55ce92d41da370dc9399c2">D_ERROR</a>, req, <span class="stringliteral">&quot;Early reply send failed %d&quot;</span>, rc);
<a name="l01397"></a>01397         }
<a name="l01398"></a>01398 
<a name="l01399"></a>01399         <span class="comment">/* Free the (early) reply state from lustre_pack_reply.</span>
<a name="l01400"></a>01400 <span class="comment">           (ptlrpc_send_reply takes it&apos;s own rs ref, so this is safe here) */</span>
<a name="l01401"></a>01401         <a class="code" href="group__net.html#gaaaac1ad8119782fe41d9f0a5cccec394">ptlrpc_req_drop_rs</a>(reqcopy);
<a name="l01402"></a>01402 
<a name="l01403"></a>01403 out_put:
<a name="l01404"></a>01404         <a class="code" href="obd__class_8h.html#a4852bdbebee2a70d6ea023a49ec915a1">class_export_rpc_dec</a>(reqcopy-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l01405"></a>01405         <a class="code" href="obd__class_8h.html#a60de37a3a43d309602be633a0f1125f9">class_export_put</a>(reqcopy-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l01406"></a>01406 out:
<a name="l01407"></a>01407         <a class="code" href="group__sptlrpc.html#gabb77528ba2594382bae01ea165279b33">sptlrpc_svc_ctx_decref</a>(reqcopy);
<a name="l01408"></a>01408         <a class="code" href="obd__support_8h.html#a23d443ea219d6893da5645c760e0c28a">OBD_FREE_LARGE</a>(reqmsg, req-&gt;<a class="code" href="structptlrpc__request.html#a9746010150c167d5b6e62786d61f18df" title="Request length.">rq_reqlen</a>);
<a name="l01409"></a>01409 out_free:
<a name="l01410"></a>01410         <a class="code" href="client_8c.html#a62d5a40d5504554ad53443f0ccae0cb2">ptlrpc_request_cache_free</a>(reqcopy);
<a name="l01411"></a>01411         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01412"></a>01412 }
<a name="l01413"></a>01413 
<a name="l01414"></a>01414 <span class="comment">/* Send early replies to everybody expiring within at_early_margin</span>
<a name="l01415"></a>01415 <span class="comment">   asking for at_extra time */</span>
<a name="l01416"></a><a class="code" href="service_8c.html#aa7ee569529c9251f8c0abed514c5c8e5">01416</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#aa7ee569529c9251f8c0abed514c5c8e5">ptlrpc_at_check_timed</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l01417"></a>01417 {
<a name="l01418"></a>01418         <span class="keyword">struct </span><a class="code" href="structptlrpc__at__array.html">ptlrpc_at_array</a> *array = &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aba4a06d005f80a1ffb87884f00b68698" title="reqs waiting for replies">scp_at_array</a>;
<a name="l01419"></a>01419         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *rq, *n;
<a name="l01420"></a>01420         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> work_list;
<a name="l01421"></a>01421         __u32  index, count;
<a name="l01422"></a>01422         time_t deadline;
<a name="l01423"></a>01423         time_t <a class="code" href="createmany_8c.html#a5602e9c6b2da7a1db11ed8a76d19fde3">now</a> = <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>();
<a name="l01424"></a>01424         <a class="code" href="linux-time_8h.html#af2983229a5c106d92b8a64c1c89e78e0">cfs_duration_t</a> delay;
<a name="l01425"></a>01425         <span class="keywordtype">int</span> first, counter = 0;
<a name="l01426"></a>01426         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01427"></a>01427 
<a name="l01428"></a>01428         spin_lock(&amp;svcpt-&gt;scp_at_lock);
<a name="l01429"></a>01429         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af1d7d89389261e865e0333f652c77b22" title="check early replies">scp_at_check</a> == 0) {
<a name="l01430"></a>01430                 spin_unlock(&amp;svcpt-&gt;scp_at_lock);
<a name="l01431"></a>01431                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01432"></a>01432         }
<a name="l01433"></a>01433         delay = <a class="code" href="libcfs__time_8h.html#ab328ad5c5c5b57cebf2ba487e73af3e4">cfs_time_sub</a>(<a class="code" href="linux-time_8h.html#adc63a7977338536b551ccc795e5a9148">cfs_time_current</a>(), svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aa705fe1ad3fe28ba1b44a3ea327e185f" title="debug">scp_at_checktime</a>);
<a name="l01434"></a>01434         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af1d7d89389261e865e0333f652c77b22" title="check early replies">scp_at_check</a> = 0;
<a name="l01435"></a>01435 
<a name="l01436"></a>01436         <span class="keywordflow">if</span> (array-&gt;<a class="code" href="structptlrpc__at__array.html#aa2bee8a89fa940c5c5e62575c22eac19" title="the size of array">paa_count</a> == 0) {
<a name="l01437"></a>01437                 spin_unlock(&amp;svcpt-&gt;scp_at_lock);
<a name="l01438"></a>01438                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01439"></a>01439         }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441         <span class="comment">/* The timer went off, but maybe the nearest rpc already completed. */</span>
<a name="l01442"></a>01442         first = array-&gt;<a class="code" href="structptlrpc__at__array.html#ad19d85164de63497bcd5fb2c6b1cec7e" title="the total count of reqs">paa_deadline</a> - now;
<a name="l01443"></a>01443         <span class="keywordflow">if</span> (first &gt; <a class="code" href="obd__support_8h.html#a47a70ddef4976d21923b761d4b637514">at_early_margin</a>) {
<a name="l01444"></a>01444                 <span class="comment">/* We&apos;ve still got plenty of time.  Reset the timer. */</span>
<a name="l01445"></a>01445                 <a class="code" href="service_8c.html#a4757a6d721555e12790af773a0b36145">ptlrpc_at_set_timer</a>(svcpt);
<a name="l01446"></a>01446                 spin_unlock(&amp;svcpt-&gt;scp_at_lock);
<a name="l01447"></a>01447                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01448"></a>01448         }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450         <span class="comment">/* We&apos;re close to a timeout, and we don&apos;t know how much longer the</span>
<a name="l01451"></a>01451 <span class="comment">           server will take. Send early replies to everyone expiring soon. */</span>
<a name="l01452"></a>01452         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;work_list);
<a name="l01453"></a>01453         deadline = -1;
<a name="l01454"></a>01454         index = (<span class="keywordtype">unsigned</span> long)array-&gt;<a class="code" href="structptlrpc__at__array.html#ad19d85164de63497bcd5fb2c6b1cec7e" title="the total count of reqs">paa_deadline</a> % array-&gt;<a class="code" href="structptlrpc__at__array.html#a4dd5aef596a563237a418ca153585cb4" title="array to hold requests">paa_size</a>;
<a name="l01455"></a>01455         count = array-&gt;<a class="code" href="structptlrpc__at__array.html#aa2bee8a89fa940c5c5e62575c22eac19" title="the size of array">paa_count</a>;
<a name="l01456"></a>01456         while (count &gt; 0) {
<a name="l01457"></a>01457                 count -= array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a>[index];
<a name="l01458"></a>01458                 <a class="code" href="list_8h.html#ac3f72d6bd5144c7970824813810d2da1" title="Iterate over a list of given type safe against removal of list entry.">list_for_each_entry_safe</a>(rq, n,
<a name="l01459"></a>01459                                          &amp;array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a>[index],
<a name="l01460"></a>01460                                          <a class="code" href="group__net.html#gacc0944ef09687a9201caa304a2fd3df7">rq_timed_list</a>) {
<a name="l01461"></a>01461                         <span class="keywordflow">if</span> (rq-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> &gt; now + <a class="code" href="obd__support_8h.html#a47a70ddef4976d21923b761d4b637514">at_early_margin</a>) {
<a name="l01462"></a>01462                                 <span class="comment">/* update the earliest deadline */</span>
<a name="l01463"></a>01463                                 <span class="keywordflow">if</span> (deadline == -1 ||
<a name="l01464"></a>01464                                     rq-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> &lt; deadline)
<a name="l01465"></a>01465                                         deadline = rq-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>;
<a name="l01466"></a>01466                                 <span class="keywordflow">break</span>;
<a name="l01467"></a>01467                         }
<a name="l01468"></a>01468 
<a name="l01469"></a>01469                         <a class="code" href="service_8c.html#a7a53df8d8b8dad6cc5e77af7524794eb">ptlrpc_at_remove_timed</a>(rq);
<a name="l01475"></a>01475                         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(atomic_inc_not_zero(&amp;rq-&gt;<a class="code" href="structptlrpc__request.html#a766b89c8d0bab9b1751bd3725ae605df" title="client-side refcount for SENT race, server-side refcounf for multiple replies">rq_refcount</a>)))
<a name="l01476"></a>01476                                 <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;rq-&gt;rq_timed_list, &amp;work_list);
<a name="l01477"></a>01477                         counter++;
<a name="l01478"></a>01478                 }
<a name="l01479"></a>01479 
<a name="l01480"></a>01480                 <span class="keywordflow">if</span> (++index &gt;= array-&gt;<a class="code" href="structptlrpc__at__array.html#a4dd5aef596a563237a418ca153585cb4" title="array to hold requests">paa_size</a>)
<a name="l01481"></a>01481                         index = 0;
<a name="l01482"></a>01482         }
<a name="l01483"></a>01483         array-&gt;<a class="code" href="structptlrpc__at__array.html#ad19d85164de63497bcd5fb2c6b1cec7e" title="the total count of reqs">paa_deadline</a> = deadline;
<a name="l01484"></a>01484         <span class="comment">/* we have a new earliest deadline, restart the timer */</span>
<a name="l01485"></a>01485         <a class="code" href="service_8c.html#a4757a6d721555e12790af773a0b36145">ptlrpc_at_set_timer</a>(svcpt);
<a name="l01486"></a>01486 
<a name="l01487"></a>01487         spin_unlock(&amp;svcpt-&gt;scp_at_lock);
<a name="l01488"></a>01488 
<a name="l01489"></a>01489         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a>, <span class="stringliteral">&quot;timeout in %+ds, asking for %d secs on %d early &quot;</span>
<a name="l01490"></a>01490                <span class="stringliteral">&quot;replies\n&quot;</span>, first, <a class="code" href="obd__support_8h.html#a30b9fa4cca5a373d84fb01422c5e239d">at_extra</a>, counter);
<a name="l01491"></a>01491         <span class="keywordflow">if</span> (first &lt; 0) {
<a name="l01492"></a>01492                 <span class="comment">/* We&apos;re already past request deadlines before we even get a</span>
<a name="l01493"></a>01493 <span class="comment">                   chance to send early replies */</span>
<a name="l01494"></a>01494                 <a class="code" href="libcfs__debug_8h.html#ac961fee8081e28c070b075fd57cd5a81">LCONSOLE_WARN</a>(<span class="stringliteral">&quot;%s: This server is not able to keep up with &quot;</span>
<a name="l01495"></a>01495                               <span class="stringliteral">&quot;request traffic (cpu-bound).\n&quot;</span>,
<a name="l01496"></a>01496                               svcpt-&gt;scp_service-&gt;srv_name);
<a name="l01497"></a>01497                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;earlyQ=%d reqQ=%d recA=%d, svcEst=%d, &quot;</span>
<a name="l01498"></a>01498                       <span class="stringliteral">&quot;delay=&quot;</span><a class="code" href="linux-time_8h.html#a51671c06b4d7ee85b50b3243086e7f6a">CFS_DURATION_T</a><span class="stringliteral">&quot;(jiff)\n&quot;</span>,
<a name="l01499"></a>01499                       counter, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a8283d58f626b885a04d59e22ac5b234a" title="# incoming reqs">scp_nreqs_incoming</a>,
<a name="l01500"></a>01500                       svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a>,
<a name="l01501"></a>01501                       <a class="code" href="group__export.html#ga68221f24f8416268d266c57882e21fe5">at_get</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754" title="estimated rpc service time">scp_at_estimate</a>), delay);
<a name="l01502"></a>01502         }
<a name="l01503"></a>01503 
<a name="l01504"></a>01504         <span class="comment">/* we took additional refcount so entries can&apos;t be deleted from list, no</span>
<a name="l01505"></a>01505 <span class="comment">         * locking is needed */</span>
<a name="l01506"></a>01506         <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;work_list)) {
<a name="l01507"></a>01507                 rq = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(work_list.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>, <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>,
<a name="l01508"></a>01508                                     <a class="code" href="group__net.html#gacc0944ef09687a9201caa304a2fd3df7">rq_timed_list</a>);
<a name="l01509"></a>01509                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;rq-&gt;rq_timed_list);
<a name="l01510"></a>01510 
<a name="l01511"></a>01511                 <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#aa46d5add9948a153701350bb60d73f40">ptlrpc_at_send_early_reply</a>(rq) == 0)
<a name="l01512"></a>01512                         <a class="code" href="service_8c.html#a870c7d7495f1f30e402923ad17a49687">ptlrpc_at_add_timed</a>(rq);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514                 <a class="code" href="group__net.html#ga45bbc99a8cb3940b830d5ac581cd2f10" title="drop a reference count of the request.">ptlrpc_server_drop_request</a>(rq);
<a name="l01515"></a>01515         }
<a name="l01516"></a>01516 
<a name="l01517"></a>01517         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(1); <span class="comment">/* return &quot;did_something&quot; for liblustre */</span>
<a name="l01518"></a>01518 }
<a name="l01519"></a>01519 
<a name="l01520"></a>01520 <span class="comment">/* Check if we are already handling earlier incarnation of this request.</span>
<a name="l01521"></a>01521 <span class="comment"> * Called under &amp;req-&gt;rq_export-&gt;exp_rpc_lock locked */</span>
<a name="l01522"></a><a class="code" href="service_8c.html#a4fe9438acef5ce97dd9c9948c15211d1">01522</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#a4fe9438acef5ce97dd9c9948c15211d1">ptlrpc_server_check_resend_in_progress</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01523"></a>01523 {
<a name="l01524"></a>01524         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *tmp = NULL;
<a name="l01525"></a>01525 
<a name="l01526"></a>01526         <span class="keywordflow">if</span> (!(<a class="code" href="group__net.html#ga7039633508af55679f204cff967f1879">lustre_msg_get_flags</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp; <a class="code" href="group__lustreidl.html#ga7f730b08ce34af6895312a959831a719">MSG_RESENT</a>) ||
<a name="l01527"></a>01527             (atomic_read(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a386f244c121af2d9b7a2e13fd1bb39dc" title="Set of counters below is to track where export references are kept.">exp_rpc_count</a>) == 0))
<a name="l01528"></a>01528                 <span class="keywordflow">return</span> 0;
<a name="l01529"></a>01529 
<a name="l01530"></a>01530         <span class="comment">/* bulk request are aborted upon reconnect, don&apos;t try to</span>
<a name="l01531"></a>01531 <span class="comment">         * find a match */</span>
<a name="l01532"></a>01532         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#abfef4dea80e2a10fb266463e54b0c020">rq_bulk_write</a> || req-&gt;<a class="code" href="structptlrpc__request.html#acec36b5c2e3a9584b2c51a83ada4ec25">rq_bulk_read</a>)
<a name="l01533"></a>01533                 <span class="keywordflow">return</span> 0;
<a name="l01534"></a>01534 
<a name="l01535"></a>01535         <span class="comment">/* This list should not be longer than max_requests in</span>
<a name="l01536"></a>01536 <span class="comment">         * flights on the client, so it is not all that long.</span>
<a name="l01537"></a>01537 <span class="comment">         * Also we only hit this codepath in case of a resent</span>
<a name="l01538"></a>01538 <span class="comment">         * request which makes it even more rarely hit */</span>
<a name="l01539"></a>01539         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(tmp, &amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#aa2b2950faa85653e564caefd91e240e5">exp_reg_rpcs</a>,
<a name="l01540"></a>01540                                 <a class="code" href="group__net.html#ga065abc2354b8e9dbc0b029924d8097d8">rq_exp_list</a>) {
<a name="l01541"></a>01541                 <span class="comment">/* Found duplicate one */</span>
<a name="l01542"></a>01542                 <span class="keywordflow">if</span> (tmp-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> == req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>)
<a name="l01543"></a>01543                         <span class="keywordflow">goto</span> found;
<a name="l01544"></a>01544         }
<a name="l01545"></a>01545         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(tmp, &amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a23fbf73ffa8f3422b2a9f8ce038b8187">exp_hp_rpcs</a>,
<a name="l01546"></a>01546                                 <a class="code" href="group__net.html#ga065abc2354b8e9dbc0b029924d8097d8">rq_exp_list</a>) {
<a name="l01547"></a>01547                 <span class="comment">/* Found duplicate one */</span>
<a name="l01548"></a>01548                 <span class="keywordflow">if</span> (tmp-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a> == req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>)
<a name="l01549"></a>01549                         <span class="keywordflow">goto</span> found;
<a name="l01550"></a>01550         }
<a name="l01551"></a>01551         <span class="keywordflow">return</span> 0;
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 found:
<a name="l01554"></a>01554         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#a125b66aada63eaccd986e27e8dac1ab2">D_HA</a>, req, <span class="stringliteral">&quot;Found duplicate req in processing&quot;</span>);
<a name="l01555"></a>01555         <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#a125b66aada63eaccd986e27e8dac1ab2">D_HA</a>, tmp, <span class="stringliteral">&quot;Request being processed&quot;</span>);
<a name="l01556"></a>01556         <span class="keywordflow">return</span> -EBUSY;
<a name="l01557"></a>01557 }
<a name="l01558"></a>01558 
<a name="l01566"></a><a class="code" href="service_8c.html#a2f4b65688f54e1839964c171450ad4e2">01566</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#a2f4b65688f54e1839964c171450ad4e2" title="Check if a request should be assigned with a high priority.">ptlrpc_server_hpreq_init</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l01567"></a>01567                                     <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01568"></a>01568 {
<a name="l01569"></a>01569         <span class="keywordtype">int</span> rc = 0;
<a name="l01570"></a>01570         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01571"></a>01571 
<a name="l01572"></a>01572         <span class="keywordflow">if</span> (svcpt-&gt;scp_service-&gt;srv_ops.so_hpreq_handler != NULL) {
<a name="l01573"></a>01573                 rc = svcpt-&gt;scp_service-&gt;srv_ops.so_hpreq_handler(req);
<a name="l01574"></a>01574                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01575"></a>01575                         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rc == 0);
<a name="l01578"></a>01578         }
<a name="l01579"></a>01579 
<a name="l01580"></a>01580         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> != NULL &amp;&amp; req-&gt;rq_ops != NULL) {
<a name="l01581"></a>01581                 <span class="comment">/* Perform request specific check. We should do this</span>
<a name="l01582"></a>01582 <span class="comment">                 * check before the request is added into exp_hp_rpcs</span>
<a name="l01583"></a>01583 <span class="comment">                 * list otherwise it may hit swab race at LU-1044. */</span>
<a name="l01584"></a>01584                 <span class="keywordflow">if</span> (req-&gt;rq_ops-&gt;hpreq_check != NULL) {
<a name="l01585"></a>01585                         rc = req-&gt;rq_ops-&gt;hpreq_check(req);
<a name="l01586"></a>01586                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rc &lt;= 1); <span class="comment">/* can only return error, 0, or 1 */</span>
<a name="l01587"></a>01587                 }
<a name="l01588"></a>01588         }
<a name="l01589"></a>01589 
<a name="l01590"></a>01590         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01591"></a>01591 }
<a name="l01592"></a>01592 
<a name="l01594"></a><a class="code" href="service_8c.html#aaa197378ce94c91c9a218f7b3f3faa8c">01594</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#aaa197378ce94c91c9a218f7b3f3faa8c" title="Remove the request from the export list.">ptlrpc_server_hpreq_fini</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01595"></a>01595 {
<a name="l01596"></a>01596         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01597"></a>01597         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>) {
<a name="l01598"></a>01598                 <span class="comment">/* refresh lock timeout again so that client has more</span>
<a name="l01599"></a>01599 <span class="comment">                 * room to send lock cancel RPC. */</span>
<a name="l01600"></a>01600                 <span class="keywordflow">if</span> (req-&gt;rq_ops &amp;&amp; req-&gt;rq_ops-&gt;hpreq_fini)
<a name="l01601"></a>01601                         req-&gt;rq_ops-&gt;hpreq_fini(req);
<a name="l01602"></a>01602 
<a name="l01603"></a>01603                 spin_lock_bh(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">exp_rpc_lock</a>);
<a name="l01604"></a>01604                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;req-&gt;rq_exp_list);
<a name="l01605"></a>01605                 spin_unlock_bh(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">exp_rpc_lock</a>);
<a name="l01606"></a>01606         }
<a name="l01607"></a>01607         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l01608"></a>01608 }
<a name="l01609"></a>01609 
<a name="l01610"></a><a class="code" href="service_8c.html#a3998b53a9b8e5f5daae67e33d71d9d4b">01610</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#a3998b53a9b8e5f5daae67e33d71d9d4b">ptlrpc_hpreq_check</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01611"></a>01611 {
<a name="l01612"></a>01612         <span class="keywordflow">return</span> 1;
<a name="l01613"></a>01613 }
<a name="l01614"></a>01614 
<a name="l01615"></a><a class="code" href="service_8c.html#affadc36d1336031381dedcf4b2720d6e">01615</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__hpreq__ops.html" title="Basic request prioritization operations structure.">ptlrpc_hpreq_ops</a> <a class="code" href="service_8c.html#affadc36d1336031381dedcf4b2720d6e">ptlrpc_hpreq_common</a> = {
<a name="l01616"></a>01616         .<a class="code" href="structptlrpc__hpreq__ops.html#a654252f8000bcba25e02f3f991aa46cd" title="Check if the request is a high priority one.">hpreq_check</a>       = <a class="code" href="service_8c.html#a3998b53a9b8e5f5daae67e33d71d9d4b">ptlrpc_hpreq_check</a>,
<a name="l01617"></a>01617 };
<a name="l01618"></a>01618 
<a name="l01619"></a>01619 <span class="comment">/* Hi-Priority RPC check by RPC operation code. */</span>
<a name="l01620"></a><a class="code" href="group__net.html#ga6539e422ce487ae5c6cdeb3855ffdc96">01620</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga6539e422ce487ae5c6cdeb3855ffdc96">ptlrpc_hpreq_handler</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01621"></a>01621 {
<a name="l01622"></a>01622         <span class="keywordtype">int</span> opc = <a class="code" href="group__net.html#ga5889b19f527897c102df244998c9de02">lustre_msg_get_opc</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l01623"></a>01623 
<a name="l01624"></a>01624         <span class="comment">/* Check for export to let only reconnects for not yet evicted</span>
<a name="l01625"></a>01625 <span class="comment">         * export to become a HP rpc. */</span>
<a name="l01626"></a>01626         <span class="keywordflow">if</span> ((req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> != NULL) &amp;&amp;
<a name="l01627"></a>01627             (opc == <a class="code" href="packet-lustre_8c.html#a54e5c4528c1781401f73f51e2b705292">OBD_PING</a> || opc == <a class="code" href="group__lustreidl.html#ggafb46b2fd1532fecf64a120ca96d31c25a5d9da37f79414a20c089a76f4e5a53b9">MDS_CONNECT</a> || opc == <a class="code" href="group__lustreidl.html#ggadeda0b7c376c32e2a7c49c7eee01c065a23f1aabf5552c06b8f22165c11332259">OST_CONNECT</a>))
<a name="l01628"></a>01628                 req-&gt;rq_ops = &amp;ptlrpc_hpreq_common;
<a name="l01629"></a>01629 
<a name="l01630"></a>01630         <span class="keywordflow">return</span> 0;
<a name="l01631"></a>01631 }
<a name="l01632"></a>01632 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga6539e422ce487ae5c6cdeb3855ffdc96">ptlrpc_hpreq_handler</a>);
<a name="l01633"></a>01633 
<a name="l01634"></a><a class="code" href="service_8c.html#a22d78c661b2c78da1b7e5c06d50510f5">01634</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#a22d78c661b2c78da1b7e5c06d50510f5">ptlrpc_server_request_add</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l01635"></a>01635                                      <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01636"></a>01636 {
<a name="l01637"></a>01637         <span class="keywordtype">int</span> rc;
<a name="l01638"></a>01638         <span class="keywordtype">bool</span> hp;
<a name="l01639"></a>01639         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01640"></a>01640 
<a name="l01641"></a>01641         rc = <a class="code" href="service_8c.html#a2f4b65688f54e1839964c171450ad4e2" title="Check if a request should be assigned with a high priority.">ptlrpc_server_hpreq_init</a>(svcpt, req);
<a name="l01642"></a>01642         <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l01643"></a>01643                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01644"></a>01644 
<a name="l01645"></a>01645         hp = rc &gt; 0;
<a name="l01646"></a>01646         <a class="code" href="nrs_8c.html#a040685413af9d845199d4866c37316b8" title="Obtains NRS head resources for request req.">ptlrpc_nrs_req_initialize</a>(svcpt, req, hp);
<a name="l01647"></a>01647 
<a name="l01648"></a>01648         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> != NULL) {
<a name="l01649"></a>01649                 <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a> *exp = req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>;
<a name="l01650"></a>01650 
<a name="l01651"></a>01651                 <span class="comment">/* do search for duplicated xid and the adding to the list</span>
<a name="l01652"></a>01652 <span class="comment">                 * atomically */</span>
<a name="l01653"></a>01653                 spin_lock_bh(&amp;exp-&gt;<a class="code" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">exp_rpc_lock</a>);
<a name="l01654"></a>01654                 rc = <a class="code" href="service_8c.html#a4fe9438acef5ce97dd9c9948c15211d1">ptlrpc_server_check_resend_in_progress</a>(req);
<a name="l01655"></a>01655                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l01656"></a>01656                         spin_unlock_bh(&amp;exp-&gt;<a class="code" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">exp_rpc_lock</a>);
<a name="l01657"></a>01657 
<a name="l01658"></a>01658                         <a class="code" href="nrs_8c.html#aa35053963b23dd9e0dc17f6b214da481" title="Releases resources for a request; is called after the request has been handled.">ptlrpc_nrs_req_finalize</a>(req);
<a name="l01659"></a>01659                         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01660"></a>01660                 }
<a name="l01661"></a>01661 
<a name="l01662"></a>01662                 <span class="keywordflow">if</span> (hp || req-&gt;rq_ops != NULL)
<a name="l01663"></a>01663                         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;req-&gt;rq_exp_list, &amp;exp-&gt;<a class="code" href="structobd__export.html#a23fbf73ffa8f3422b2a9f8ce038b8187">exp_hp_rpcs</a>);
<a name="l01664"></a>01664                 <span class="keywordflow">else</span>
<a name="l01665"></a>01665                         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;req-&gt;rq_exp_list, &amp;exp-&gt;<a class="code" href="structobd__export.html#aa2b2950faa85653e564caefd91e240e5">exp_reg_rpcs</a>);
<a name="l01666"></a>01666                 spin_unlock_bh(&amp;exp-&gt;<a class="code" href="structobd__export.html#a2b33d87480eedf3d4c9ab218d84a6e86" title="protects exp_hp_rpcs">exp_rpc_lock</a>);
<a name="l01667"></a>01667         }
<a name="l01668"></a>01668 
<a name="l01669"></a>01669         <span class="comment">/* the current thread is not the processing thread for this request</span>
<a name="l01670"></a>01670 <span class="comment">         * since that, but request is in exp_hp_list and can be find there.</span>
<a name="l01671"></a>01671 <span class="comment">         * Remove all relations between request and old thread. */</span>
<a name="l01672"></a>01672         req-&gt;rq_svc_thread-&gt;t_env-&gt;le_ses = NULL;
<a name="l01673"></a>01673         req-&gt;rq_svc_thread = NULL;
<a name="l01674"></a>01674         req-&gt;rq_session.lc_thread = NULL;
<a name="l01675"></a>01675 
<a name="l01676"></a>01676         <a class="code" href="nrs_8c.html#a376ea8577919ec8eb729d36195bcbf1a" title="Enqueues request req on either the regular or high-priority NRS head of service partition...">ptlrpc_nrs_req_add</a>(svcpt, req, hp);
<a name="l01677"></a>01677 
<a name="l01678"></a>01678         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01679"></a>01679 }
<a name="l01680"></a>01680 
<a name="l01686"></a><a class="code" href="service_8c.html#aad3a54e6eed55c20c2fcb640b152f720">01686</a> <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="service_8c.html#aad3a54e6eed55c20c2fcb640b152f720" title="Allow to handle high priority request User can call it w/o any lock but need to hold...">ptlrpc_server_allow_high</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l01687"></a>01687                                      <span class="keywordtype">bool</span> force)
<a name="l01688"></a>01688 {
<a name="l01689"></a>01689         <span class="keywordtype">int</span> running = svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a>;
<a name="l01690"></a>01690 
<a name="l01691"></a>01691         <span class="keywordflow">if</span> (!<a class="code" href="ptlrpc__internal_8h.html#aaf4ffa9c17fffb706e83c266967827f0">nrs_svcpt_has_hp</a>(svcpt))
<a name="l01692"></a>01692                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01693"></a>01693 
<a name="l01694"></a>01694         <span class="keywordflow">if</span> (force)
<a name="l01695"></a>01695                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01696"></a>01696 
<a name="l01697"></a>01697         <span class="keywordflow">if</span> (<a class="code" href="nrs_8c.html#adca0e099406dbe4e2f80aed92e475774" title="Returns whether NRS policy is throttling reqeust.">ptlrpc_nrs_req_throttling_nolock</a>(svcpt, <span class="keyword">true</span>))
<a name="l01698"></a>01698                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01699"></a>01699 
<a name="l01700"></a>01700         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(svcpt-&gt;scp_service-&gt;srv_req_portal == <a class="code" href="group__lustreidl.html#gae1a831d1e4f8f13199c0cf757f876b56">MDS_REQUEST_PORTAL</a> &amp;&amp;
<a name="l01701"></a>01701                      <a class="code" href="libcfs__fail_8h.html#ab5b1ae34601be2e03737c996a347d7f7">CFS_FAIL_PRECHECK</a>(<a class="code" href="obd__support_8h.html#a7dfe72d0f2572bd71841839692a5e851">OBD_FAIL_PTLRPC_CANCEL_RESEND</a>))) {
<a name="l01702"></a>01702                 <span class="comment">/* leave just 1 thread for normal RPCs */</span>
<a name="l01703"></a>01703                 running = <a class="code" href="group__net.html#gafe956408171741e4f2fa929087b87a26">PTLRPC_NTHRS_INIT</a>;
<a name="l01704"></a>01704                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service-&gt;srv_ops.so_hpreq_handler != NULL)
<a name="l01705"></a>01705                         running += 1;
<a name="l01706"></a>01706         }
<a name="l01707"></a>01707 
<a name="l01708"></a>01708         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a> &gt;= running - 1)
<a name="l01709"></a>01709                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01710"></a>01710 
<a name="l01711"></a>01711         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a5cb3e1be6fad443994888bc086aa5283" title="# HPreqs being served">scp_nhreqs_active</a> == 0)
<a name="l01712"></a>01712                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01713"></a>01713 
<a name="l01714"></a>01714         <span class="keywordflow">return</span> !<a class="code" href="nrs_8c.html#acd9117d134d826c1aaed14e2e8d5f57d" title="Returns whether there are any requests currently enqueued on any of the policies...">ptlrpc_nrs_req_pending_nolock</a>(svcpt, <span class="keyword">false</span>) ||
<a name="l01715"></a>01715                svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af8d242d89a56c88d4522319d5ec82b94" title="# hp requests handled">scp_hreq_count</a> &lt; svcpt-&gt;scp_service-&gt;srv_hpreq_ratio;
<a name="l01716"></a>01716 }
<a name="l01717"></a>01717 
<a name="l01718"></a><a class="code" href="service_8c.html#ac5e70e9ac0846630ba9e4d3e1a50156b">01718</a> <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="service_8c.html#ac5e70e9ac0846630ba9e4d3e1a50156b">ptlrpc_server_high_pending</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l01719"></a>01719                                        <span class="keywordtype">bool</span> force)
<a name="l01720"></a>01720 {
<a name="l01721"></a>01721         <span class="keywordflow">return</span> <a class="code" href="service_8c.html#aad3a54e6eed55c20c2fcb640b152f720" title="Allow to handle high priority request User can call it w/o any lock but need to hold...">ptlrpc_server_allow_high</a>(svcpt, force) &amp;&amp;
<a name="l01722"></a>01722                <a class="code" href="nrs_8c.html#acd9117d134d826c1aaed14e2e8d5f57d" title="Returns whether there are any requests currently enqueued on any of the policies...">ptlrpc_nrs_req_pending_nolock</a>(svcpt, <span class="keyword">true</span>);
<a name="l01723"></a>01723 }
<a name="l01724"></a>01724 
<a name="l01734"></a><a class="code" href="service_8c.html#ac6e38d8c616e2daee51de465d2d7013a">01734</a> <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="service_8c.html#ac6e38d8c616e2daee51de465d2d7013a" title="Only allow normal priority requests on a service that has a high-priority queue if...">ptlrpc_server_allow_normal</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l01735"></a>01735                                        <span class="keywordtype">bool</span> force)
<a name="l01736"></a>01736 {
<a name="l01737"></a>01737         <span class="keywordtype">int</span> running = svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a>;
<a name="l01738"></a>01738         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(svcpt-&gt;scp_service-&gt;srv_req_portal == <a class="code" href="group__lustreidl.html#gae1a831d1e4f8f13199c0cf757f876b56">MDS_REQUEST_PORTAL</a> &amp;&amp;
<a name="l01739"></a>01739                      <a class="code" href="libcfs__fail_8h.html#ab5b1ae34601be2e03737c996a347d7f7">CFS_FAIL_PRECHECK</a>(<a class="code" href="obd__support_8h.html#a7dfe72d0f2572bd71841839692a5e851">OBD_FAIL_PTLRPC_CANCEL_RESEND</a>))) {
<a name="l01740"></a>01740                 <span class="comment">/* leave just 1 thread for normal RPCs */</span>
<a name="l01741"></a>01741                 running = <a class="code" href="group__net.html#gafe956408171741e4f2fa929087b87a26">PTLRPC_NTHRS_INIT</a>;
<a name="l01742"></a>01742                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service-&gt;srv_ops.so_hpreq_handler != NULL)
<a name="l01743"></a>01743                         running += 1;
<a name="l01744"></a>01744         }
<a name="l01745"></a>01745 
<a name="l01746"></a>01746         <span class="keywordflow">if</span> (force)
<a name="l01747"></a>01747                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01748"></a>01748 
<a name="l01749"></a>01749         <span class="keywordflow">if</span> (<a class="code" href="nrs_8c.html#adca0e099406dbe4e2f80aed92e475774" title="Returns whether NRS policy is throttling reqeust.">ptlrpc_nrs_req_throttling_nolock</a>(svcpt, <span class="keyword">false</span>))
<a name="l01750"></a>01750                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01751"></a>01751 
<a name="l01752"></a>01752         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a> &lt; running - 2)
<a name="l01753"></a>01753                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01754"></a>01754 
<a name="l01755"></a>01755         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a> &gt;= running - 1)
<a name="l01756"></a>01756                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01757"></a>01757 
<a name="l01758"></a>01758         <span class="keywordflow">return</span> svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a5cb3e1be6fad443994888bc086aa5283" title="# HPreqs being served">scp_nhreqs_active</a> &gt; 0 || !<a class="code" href="ptlrpc__internal_8h.html#aaf4ffa9c17fffb706e83c266967827f0">nrs_svcpt_has_hp</a>(svcpt);
<a name="l01759"></a>01759 }
<a name="l01760"></a>01760 
<a name="l01761"></a><a class="code" href="service_8c.html#a07185adbcc9ce1e9ca17cb1a13789e00">01761</a> <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="service_8c.html#a07185adbcc9ce1e9ca17cb1a13789e00">ptlrpc_server_normal_pending</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l01762"></a>01762                                          <span class="keywordtype">bool</span> force)
<a name="l01763"></a>01763 {
<a name="l01764"></a>01764         <span class="keywordflow">return</span> <a class="code" href="service_8c.html#ac6e38d8c616e2daee51de465d2d7013a" title="Only allow normal priority requests on a service that has a high-priority queue if...">ptlrpc_server_allow_normal</a>(svcpt, force) &amp;&amp;
<a name="l01765"></a>01765                <a class="code" href="nrs_8c.html#acd9117d134d826c1aaed14e2e8d5f57d" title="Returns whether there are any requests currently enqueued on any of the policies...">ptlrpc_nrs_req_pending_nolock</a>(svcpt, <span class="keyword">false</span>);
<a name="l01766"></a>01766 }
<a name="l01767"></a>01767 
<a name="l01776"></a>01776 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l01777"></a><a class="code" href="service_8c.html#ac05b630214d88cf338cae0215329ffac">01777</a> <a class="code" href="service_8c.html#ac05b630214d88cf338cae0215329ffac" title="Returns true if there are requests available in incoming request queue for processing...">ptlrpc_server_request_pending</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt, <span class="keywordtype">bool</span> force)
<a name="l01778"></a>01778 {
<a name="l01779"></a>01779         <span class="keywordflow">return</span> <a class="code" href="service_8c.html#ac5e70e9ac0846630ba9e4d3e1a50156b">ptlrpc_server_high_pending</a>(svcpt, force) ||
<a name="l01780"></a>01780                <a class="code" href="service_8c.html#a07185adbcc9ce1e9ca17cb1a13789e00">ptlrpc_server_normal_pending</a>(svcpt, force);
<a name="l01781"></a>01781 }
<a name="l01782"></a>01782 
<a name="l01788"></a>01788 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *
<a name="l01789"></a><a class="code" href="service_8c.html#a6974eddc8d099fb5e20dcc08d3863f35">01789</a> <a class="code" href="service_8c.html#a6974eddc8d099fb5e20dcc08d3863f35" title="Fetch a request for processing from queue of unprocessed requests.">ptlrpc_server_request_get</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt, <span class="keywordtype">bool</span> force)
<a name="l01790"></a>01790 {
<a name="l01791"></a>01791         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req = NULL;
<a name="l01792"></a>01792         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01793"></a>01793 
<a name="l01794"></a>01794         spin_lock(&amp;svcpt-&gt;scp_req_lock);
<a name="l01795"></a>01795 
<a name="l01796"></a>01796         <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#ac5e70e9ac0846630ba9e4d3e1a50156b">ptlrpc_server_high_pending</a>(svcpt, force)) {
<a name="l01797"></a>01797                 req = <a class="code" href="ptlrpc__internal_8h.html#ad92335242ec3763ecf8874e00c41efee">ptlrpc_nrs_req_get_nolock</a>(svcpt, <span class="keyword">true</span>, force);
<a name="l01798"></a>01798                 <span class="keywordflow">if</span> (req != NULL) {
<a name="l01799"></a>01799                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af8d242d89a56c88d4522319d5ec82b94" title="# hp requests handled">scp_hreq_count</a>++;
<a name="l01800"></a>01800                         <span class="keywordflow">goto</span> got_request;
<a name="l01801"></a>01801                 }
<a name="l01802"></a>01802         }
<a name="l01803"></a>01803 
<a name="l01804"></a>01804         <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#a07185adbcc9ce1e9ca17cb1a13789e00">ptlrpc_server_normal_pending</a>(svcpt, force)) {
<a name="l01805"></a>01805                 req = <a class="code" href="ptlrpc__internal_8h.html#ad92335242ec3763ecf8874e00c41efee">ptlrpc_nrs_req_get_nolock</a>(svcpt, <span class="keyword">false</span>, force);
<a name="l01806"></a>01806                 <span class="keywordflow">if</span> (req != NULL) {
<a name="l01807"></a>01807                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af8d242d89a56c88d4522319d5ec82b94" title="# hp requests handled">scp_hreq_count</a> = 0;
<a name="l01808"></a>01808                         <span class="keywordflow">goto</span> got_request;
<a name="l01809"></a>01809                 }
<a name="l01810"></a>01810         }
<a name="l01811"></a>01811 
<a name="l01812"></a>01812         spin_unlock(&amp;svcpt-&gt;scp_req_lock);
<a name="l01813"></a>01813         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(NULL);
<a name="l01814"></a>01814 
<a name="l01815"></a>01815 got_request:
<a name="l01816"></a>01816         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a>++;
<a name="l01817"></a>01817         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#a97e5341e8ef49e047ef82b2cfa138ec8" title="server-side flags">rq_hp</a>)
<a name="l01818"></a>01818                 svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a5cb3e1be6fad443994888bc086aa5283" title="# HPreqs being served">scp_nhreqs_active</a>++;
<a name="l01819"></a>01819 
<a name="l01820"></a>01820         spin_unlock(&amp;svcpt-&gt;scp_req_lock);
<a name="l01821"></a>01821 
<a name="l01822"></a>01822         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>))
<a name="l01823"></a>01823                 <a class="code" href="obd__class_8h.html#a0b998d2750c48d182576ee3f2463dde7">class_export_rpc_inc</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>);
<a name="l01824"></a>01824 
<a name="l01825"></a>01825         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(req);
<a name="l01826"></a>01826 }
<a name="l01827"></a>01827 
<a name="l01834"></a>01834 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01835"></a><a class="code" href="service_8c.html#af551f3c6043b58390a944685f0010c4e">01835</a> <a class="code" href="service_8c.html#af551f3c6043b58390a944685f0010c4e" title="Handle freshly incoming reqs, add to timed early reply list, pass on to regular request...">ptlrpc_server_handle_req_in</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l01836"></a>01836                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *<a class="code" href="obd_8c.html#a20057145635eb007e0621c11bc2d7176">thread</a>)
<a name="l01837"></a>01837 {
<a name="l01838"></a>01838         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>   *svc = svcpt-&gt;scp_service;
<a name="l01839"></a>01839         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *req;
<a name="l01840"></a>01840         __u32                   deadline;
<a name="l01841"></a>01841         <span class="keywordtype">int</span>                     rc;
<a name="l01842"></a>01842         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01843"></a>01843 
<a name="l01844"></a>01844         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l01845"></a>01845         <span class="keywordflow">if</span> (<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a54fb502a4f6c138aaa49eb9afea6e39c" title="incoming reqs">scp_req_incoming</a>)) {
<a name="l01846"></a>01846                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l01847"></a>01847                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01848"></a>01848         }
<a name="l01849"></a>01849 
<a name="l01850"></a>01850         req = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a54fb502a4f6c138aaa49eb9afea6e39c" title="incoming reqs">scp_req_incoming</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l01851"></a>01851                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, <a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l01852"></a>01852         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l01853"></a>01853         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a8283d58f626b885a04d59e22ac5b234a" title="# incoming reqs">scp_nreqs_incoming</a>--;
<a name="l01854"></a>01854         <span class="comment">/* Consider this still a &quot;queued&quot; request as far as stats are</span>
<a name="l01855"></a>01855 <span class="comment">         * concerned */</span>
<a name="l01856"></a>01856         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l01857"></a>01857 
<a name="l01858"></a>01858         <span class="comment">/* go through security check/transform */</span>
<a name="l01859"></a>01859         rc = <a class="code" href="group__sptlrpc.html#ga6fdd12db4bcfd925fed91da8a4ecf857" title="Used by ptlrpc server, to perform transformation upon request message of incoming...">sptlrpc_svc_unwrap_request</a>(req);
<a name="l01860"></a>01860         <span class="keywordflow">switch</span> (rc) {
<a name="l01861"></a>01861         <span class="keywordflow">case</span> <a class="code" href="group__sptlrpc.html#ggaac622aab8a11283ec2afdc77b7c7da3ca0072a05e125df3fd1fde56e4ece016fc">SECSVC_OK</a>:
<a name="l01862"></a>01862                 <span class="keywordflow">break</span>;
<a name="l01863"></a>01863         <span class="keywordflow">case</span> <a class="code" href="group__sptlrpc.html#ggaac622aab8a11283ec2afdc77b7c7da3cad3f52a353338eaf99f2fa3da2e5d8d77">SECSVC_COMPLETE</a>:
<a name="l01864"></a>01864                 <a class="code" href="group__lib.html#ga85f5aad1f6441ed3a0d44b17c6b99c7b">target_send_reply</a>(req, 0, <a class="code" href="obd__support_8h.html#ae6eb01b5685c90e5467369398657b9c9">OBD_FAIL_MDS_ALL_REPLY_NET</a>);
<a name="l01865"></a>01865                 <span class="keywordflow">goto</span> err_req;
<a name="l01866"></a>01866         <span class="keywordflow">case</span> <a class="code" href="group__sptlrpc.html#ggaac622aab8a11283ec2afdc77b7c7da3ca54216bb6bef0d175b7cc9903fbde5fa2">SECSVC_DROP</a>:
<a name="l01867"></a>01867                 <span class="keywordflow">goto</span> err_req;
<a name="l01868"></a>01868         <span class="keywordflow">default</span>:
<a name="l01869"></a>01869                 <a class="code" href="libcfs__private_8h.html#a08eceadb65d1adcf8c198cff27081d5f">LBUG</a>();
<a name="l01870"></a>01870         }
<a name="l01871"></a>01871 
<a name="l01872"></a>01872         <span class="comment">/*</span>
<a name="l01873"></a>01873 <span class="comment">         * for null-flavored rpc, msg has been unpacked by sptlrpc, although</span>
<a name="l01874"></a>01874 <span class="comment">         * redo it wouldn&apos;t be harmful.</span>
<a name="l01875"></a>01875 <span class="comment">         */</span>
<a name="l01876"></a>01876         <span class="keywordflow">if</span> (<a class="code" href="group__flavor.html#ga8955bc258d554af31543213d9fc687e6">SPTLRPC_FLVR_POLICY</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac3e5a642d385eedc857fbf06031047c6" title="security and encryption data">rq_flvr</a>.<a class="code" href="structsptlrpc__flavor.html#a0af9caf1a25eb7e9fa776aac0e33e0e7" title="wire flavor, should be renamed to sf_wire.">sf_rpc</a>) != <a class="code" href="group__flavor.html#gga37942381334c943a7e6967f08864cfb4a99315fa5cb53b3a984fdfba2f0c793b8">SPTLRPC_POLICY_NULL</a>) {
<a name="l01877"></a>01877                 rc = <a class="code" href="group__net.html#ga880aa3ea008857e45135398b11077193">ptlrpc_unpack_req_msg</a>(req, req-&gt;<a class="code" href="structptlrpc__request.html#a9746010150c167d5b6e62786d61f18df" title="Request length.">rq_reqlen</a>);
<a name="l01878"></a>01878                 <span class="keywordflow">if</span> (rc != 0) {
<a name="l01879"></a>01879                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;error unpacking request: ptl %d from %s &quot;</span>
<a name="l01880"></a>01880                                <span class="stringliteral">&quot;x&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;\n&quot;</span>, svc-&gt;<a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>,
<a name="l01881"></a>01881                                <a class="code" href="nidstr_8h.html#ab0b294c710b89667647c7636e7e4d519">libcfs_id2str</a>(req-&gt;<a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>), req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l01882"></a>01882                         <span class="keywordflow">goto</span> err_req;
<a name="l01883"></a>01883                 }
<a name="l01884"></a>01884         }
<a name="l01885"></a>01885 
<a name="l01886"></a>01886         rc = <a class="code" href="pack__generic_8c.html#a75e70c906ed859881dddce7a938c5e9d">lustre_unpack_req_ptlrpc_body</a>(req, <a class="code" href="group__lustreidl.html#gad7ddfc6368a84f8cf442c0d4aabcbdc8">MSG_PTLRPC_BODY_OFF</a>);
<a name="l01887"></a>01887         <span class="keywordflow">if</span> (rc) {
<a name="l01888"></a>01888                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a> (<span class="stringliteral">&quot;error unpacking ptlrpc body: ptl %d from %s x&quot;</span>
<a name="l01889"></a>01889                         <a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;\n&quot;</span>, svc-&gt;<a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>,
<a name="l01890"></a>01890                         <a class="code" href="nidstr_8h.html#ab0b294c710b89667647c7636e7e4d519">libcfs_id2str</a>(req-&gt;<a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>), req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l01891"></a>01891                 <span class="keywordflow">goto</span> err_req;
<a name="l01892"></a>01892         }
<a name="l01893"></a>01893 
<a name="l01894"></a>01894         <span class="keywordflow">if</span> (<a class="code" href="obd__support_8h.html#a1a625df67e59932bc7ef6f87a8548cda">OBD_FAIL_CHECK</a>(<a class="code" href="obd__support_8h.html#a641ea148510513286aa49f8b44c5afe4">OBD_FAIL_PTLRPC_DROP_REQ_OPC</a>) &amp;&amp;
<a name="l01895"></a>01895             <a class="code" href="group__net.html#ga5889b19f527897c102df244998c9de02">lustre_msg_get_opc</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) == <a class="code" href="libcfs__fail_8h.html#a2ef1cb02c9a3c9f5a23b1f818d3b99ba">cfs_fail_val</a>) {
<a name="l01896"></a>01896                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;drop incoming rpc opc %u, x&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01897"></a>01897                        <a class="code" href="libcfs__fail_8h.html#a2ef1cb02c9a3c9f5a23b1f818d3b99ba">cfs_fail_val</a>, req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l01898"></a>01898                 <span class="keywordflow">goto</span> err_req;
<a name="l01899"></a>01899         }
<a name="l01900"></a>01900 
<a name="l01901"></a>01901         rc = -EINVAL;
<a name="l01902"></a>01902         <span class="keywordflow">if</span> (<a class="code" href="group__net.html#ga01d33f66f8a27c313cd4db66ea0bdbc6">lustre_msg_get_type</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) != <a class="code" href="packet-lustre_8c.html#a4965948d628638ee970ac34ce3dec462">PTL_RPC_MSG_REQUEST</a>) {
<a name="l01903"></a>01903                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;wrong packet type received (type=%u) from %s\n&quot;</span>,
<a name="l01904"></a>01904                        <a class="code" href="group__net.html#ga01d33f66f8a27c313cd4db66ea0bdbc6">lustre_msg_get_type</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>),
<a name="l01905"></a>01905                        <a class="code" href="nidstr_8h.html#ab0b294c710b89667647c7636e7e4d519">libcfs_id2str</a>(req-&gt;<a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>));
<a name="l01906"></a>01906                 <span class="keywordflow">goto</span> err_req;
<a name="l01907"></a>01907         }
<a name="l01908"></a>01908 
<a name="l01909"></a>01909         <span class="keywordflow">switch</span> (<a class="code" href="group__net.html#ga5889b19f527897c102df244998c9de02">lustre_msg_get_opc</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>)) {
<a name="l01910"></a>01910         <span class="keywordflow">case</span> <a class="code" href="group__lustreidl.html#ggafb46b2fd1532fecf64a120ca96d31c25a27418318585cef91aa49f39d8ae006f8">MDS_WRITEPAGE</a>:
<a name="l01911"></a>01911         <span class="keywordflow">case</span> <a class="code" href="group__lustreidl.html#ggadeda0b7c376c32e2a7c49c7eee01c065a703556bbce21846e103b1953a31c8bbd">OST_WRITE</a>:
<a name="l01912"></a>01912         <span class="keywordflow">case</span> <a class="code" href="group__lustreidl.html#gga6950301f8a5a3745922e1e67f00fdecfa33a3469616644da74db154c9c58eea45">OUT_UPDATE</a>:
<a name="l01913"></a>01913                 req-&gt;<a class="code" href="structptlrpc__request.html#abfef4dea80e2a10fb266463e54b0c020">rq_bulk_write</a> = 1;
<a name="l01914"></a>01914                 <span class="keywordflow">break</span>;
<a name="l01915"></a>01915         <span class="keywordflow">case</span> <a class="code" href="group__lustreidl.html#ggafb46b2fd1532fecf64a120ca96d31c25a723527bf5f088c416ff35d13c7ba4ca4">MDS_READPAGE</a>:
<a name="l01916"></a>01916         <span class="keywordflow">case</span> <a class="code" href="group__lustreidl.html#ggadeda0b7c376c32e2a7c49c7eee01c065a7589e2943348fad089d6db86ac47456a">OST_READ</a>:
<a name="l01917"></a>01917         <span class="keywordflow">case</span> <a class="code" href="group__lustreidl.html#gga4a3cabbbc37d10b05e826a5027c76c37abceaef2da3be2dfa69bba30204bf40fe">MGS_CONFIG_READ</a>:
<a name="l01918"></a>01918                 req-&gt;<a class="code" href="structptlrpc__request.html#acec36b5c2e3a9584b2c51a83ada4ec25">rq_bulk_read</a> = 1;
<a name="l01919"></a>01919                 <span class="keywordflow">break</span>;
<a name="l01920"></a>01920         }
<a name="l01921"></a>01921 
<a name="l01922"></a>01922         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, <span class="stringliteral">&quot;got req x&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;\n&quot;</span>, req-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l01923"></a>01923 
<a name="l01924"></a>01924         req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> = <a class="code" href="group__export.html#ga81cdb4586b1839c76ecdd5abb1eabe49">class_conn2export</a>(
<a name="l01925"></a>01925                 <a class="code" href="group__net.html#gad75d2dc265242a98676033489842e8c1">lustre_msg_get_handle</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l01926"></a>01926         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>) {
<a name="l01927"></a>01927                 rc = <a class="code" href="service_8c.html#a80f18cb077b5d857391b16687f9dcb0e" title="Sanity check request req.">ptlrpc_check_req</a>(req);
<a name="l01928"></a>01928                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l01929"></a>01929                         rc = <a class="code" href="group__sptlrpc.html#gaf12efdd6553013c0e886d356541dd86b" title="Given an export exp, check whether the flavor of incoming req is allowed by the export...">sptlrpc_target_export_check</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>, req);
<a name="l01930"></a>01930                         <span class="keywordflow">if</span> (rc)
<a name="l01931"></a>01931                                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#af25fefaf5c55ce92d41da370dc9399c2">D_ERROR</a>, req, <span class="stringliteral">&quot;DROPPING req with &quot;</span>
<a name="l01932"></a>01932                                           <span class="stringliteral">&quot;illegal security flavor,&quot;</span>);
<a name="l01933"></a>01933                 }
<a name="l01934"></a>01934 
<a name="l01935"></a>01935                 <span class="keywordflow">if</span> (rc)
<a name="l01936"></a>01936                         <span class="keywordflow">goto</span> err_req;
<a name="l01937"></a>01937                 <a class="code" href="group__net.html#ga3b962a1b6e534a49a4848336555d1d89" title="This function makes sure dead exports are evicted in a timely manner.">ptlrpc_update_export_timer</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>, 0);
<a name="l01938"></a>01938         }
<a name="l01939"></a>01939 
<a name="l01940"></a>01940         <span class="comment">/* req_in handling should/must be fast */</span>
<a name="l01941"></a>01941         <span class="keywordflow">if</span> (<a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() - req-&gt;rq_arrival_time.tv_sec &gt; 5)
<a name="l01942"></a>01942                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#acca9c9cff9837f6f3d2759b02a61ff1d">D_WARNING</a>, req, <span class="stringliteral">&quot;Slow req_in handling &quot;</span><a class="code" href="linux-time_8h.html#a51671c06b4d7ee85b50b3243086e7f6a">CFS_DURATION_T</a><span class="stringliteral">&quot;s&quot;</span>,
<a name="l01943"></a>01943                           <a class="code" href="libcfs__time_8h.html#ab328ad5c5c5b57cebf2ba487e73af3e4">cfs_time_sub</a>(<a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>(),
<a name="l01944"></a>01944                                        req-&gt;rq_arrival_time.tv_sec));
<a name="l01945"></a>01945 
<a name="l01946"></a>01946         <span class="comment">/* Set rpc server deadline and add it to the timed list */</span>
<a name="l01947"></a>01947         deadline = (<a class="code" href="group__net.html#gafa52f54de41c43cabe289cdaa7fedc1b">lustre_msghdr_get_flags</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) &amp;
<a name="l01948"></a>01948                     <a class="code" href="group__lustreidl.html#ga3f2d351b95a850943970bf309b7dc61f">MSGHDR_AT_SUPPORT</a>) ?
<a name="l01949"></a>01949                    <span class="comment">/* The max time the client expects us to take */</span>
<a name="l01950"></a>01950                    <a class="code" href="group__net.html#gac8ece5ff148e7b332a8408646971193c">lustre_msg_get_timeout</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) : <a class="code" href="obd__support_8h.html#aa0f9a3f30233340b9fe0b3a3eb300735">obd_timeout</a>;
<a name="l01951"></a>01951 
<a name="l01952"></a>01952         req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> = req-&gt;rq_arrival_time.tv_sec + deadline;
<a name="l01953"></a>01953         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(deadline == 0)) {
<a name="l01954"></a>01954                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#af25fefaf5c55ce92d41da370dc9399c2">D_ERROR</a>, req, <span class="stringliteral">&quot;Dropping request with 0 timeout&quot;</span>);
<a name="l01955"></a>01955                 <span class="keywordflow">goto</span> err_req;
<a name="l01956"></a>01956         }
<a name="l01957"></a>01957 
<a name="l01958"></a>01958         <span class="comment">/* Skip early reply */</span>
<a name="l01959"></a>01959         <span class="keywordflow">if</span> (<a class="code" href="obd__support_8h.html#a2894b095c98960b30c09449ce0b2cd4b">OBD_FAIL_PRECHECK</a>(<a class="code" href="obd__support_8h.html#a9942e9121eb591bddeac756293878cfc">OBD_FAIL_MDS_RESEND</a>))
<a name="l01960"></a>01960                 req-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a> += <a class="code" href="obd__support_8h.html#aa0f9a3f30233340b9fe0b3a3eb300735">obd_timeout</a>;
<a name="l01961"></a>01961 
<a name="l01962"></a>01962         req-&gt;rq_svc_thread = thread;
<a name="l01963"></a>01963         <span class="keywordflow">if</span> (thread != NULL) {
<a name="l01964"></a>01964                 <span class="comment">/* initialize request session, it is needed for request</span>
<a name="l01965"></a>01965 <span class="comment">                 * processing by target */</span>
<a name="l01966"></a>01966                 rc = <a class="code" href="group__lu.html#ga952ae50ec5c4d109d2afecbb90c59a5c" title="Initialize context data-structure.">lu_context_init</a>(&amp;req-&gt;rq_session, <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aabaed253be3089b461b48756c519b654a" title="session for server thread">LCT_SERVER_SESSION</a> |
<a name="l01967"></a>01967                                                        <a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084" title="Don&amp;#39;t add references for modules creating key values in that context.">LCT_NOREF</a>);
<a name="l01968"></a>01968                 <span class="keywordflow">if</span> (rc) {
<a name="l01969"></a>01969                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;%s: failure to initialize session: rc = %d\n&quot;</span>,
<a name="l01970"></a>01970                                thread-&gt;<a class="code" href="structptlrpc__thread.html#adf5b750656843ad30ddbef591081dbc8">t_name</a>, rc);
<a name="l01971"></a>01971                         <span class="keywordflow">goto</span> err_req;
<a name="l01972"></a>01972                 }
<a name="l01973"></a>01973                 req-&gt;rq_session.lc_thread = thread;
<a name="l01974"></a>01974                 <a class="code" href="group__lu.html#gaf86fb0a5bf6a1dadec88844694e2ad31" title="Called before entering context.">lu_context_enter</a>(&amp;req-&gt;rq_session);
<a name="l01975"></a>01975                 thread-&gt;<a class="code" href="structptlrpc__thread.html#af6cc81f0f51f2a2a3c62f80416b75ba8">t_env</a>-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a> = &amp;req-&gt;rq_session;
<a name="l01976"></a>01976         }
<a name="l01977"></a>01977 
<a name="l01978"></a>01978         <a class="code" href="service_8c.html#a870c7d7495f1f30e402923ad17a49687">ptlrpc_at_add_timed</a>(req);
<a name="l01979"></a>01979 
<a name="l01980"></a>01980         <span class="comment">/* Move it over to the request processing queue */</span>
<a name="l01981"></a>01981         rc = <a class="code" href="service_8c.html#a22d78c661b2c78da1b7e5c06d50510f5">ptlrpc_server_request_add</a>(svcpt, req);
<a name="l01982"></a>01982         <span class="keywordflow">if</span> (rc)
<a name="l01983"></a>01983                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(err_req, rc);
<a name="l01984"></a>01984 
<a name="l01985"></a>01985         wake_up(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aea613ac08a7dc84e671b4a260eed2765" title="all threads sleep on this.">scp_waitq</a>);
<a name="l01986"></a>01986         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(1);
<a name="l01987"></a>01987 
<a name="l01988"></a>01988 err_req:
<a name="l01989"></a>01989         <a class="code" href="service_8c.html#a2d71c5442a9a62c66bd99bc984d2c8d1" title="to finish a request: stop sending more early replies, and release the request.">ptlrpc_server_finish_request</a>(svcpt, req);
<a name="l01990"></a>01990 
<a name="l01991"></a>01991         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(1);
<a name="l01992"></a>01992 }
<a name="l01993"></a>01993 
<a name="l01998"></a>01998 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01999"></a><a class="code" href="service_8c.html#a9380f0d64f1bd15f62f971bccdc810b7">01999</a> <a class="code" href="service_8c.html#a9380f0d64f1bd15f62f971bccdc810b7" title="Main incoming request handling logic.">ptlrpc_server_handle_request</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l02000"></a>02000                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *<a class="code" href="obd_8c.html#a20057145635eb007e0621c11bc2d7176">thread</a>)
<a name="l02001"></a>02001 {
<a name="l02002"></a>02002         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>   *svc = svcpt-&gt;scp_service;
<a name="l02003"></a>02003         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *request;
<a name="l02004"></a>02004         <span class="keyword">struct </span>timeval           work_start;
<a name="l02005"></a>02005         <span class="keyword">struct </span>timeval           work_end;
<a name="l02006"></a>02006         <span class="keywordtype">long</span>                     timediff;
<a name="l02007"></a>02007         <span class="keywordtype">int</span>                      fail_opc = 0;
<a name="l02008"></a>02008 
<a name="l02009"></a>02009         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02010"></a>02010 
<a name="l02011"></a>02011         request = <a class="code" href="service_8c.html#a6974eddc8d099fb5e20dcc08d3863f35" title="Fetch a request for processing from queue of unprocessed requests.">ptlrpc_server_request_get</a>(svcpt, <span class="keyword">false</span>);
<a name="l02012"></a>02012         <span class="keywordflow">if</span> (request == NULL)
<a name="l02013"></a>02013                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l02014"></a>02014 
<a name="l02015"></a>02015         <span class="keywordflow">if</span> (<a class="code" href="obd__support_8h.html#a1a625df67e59932bc7ef6f87a8548cda">OBD_FAIL_CHECK</a>(<a class="code" href="obd__support_8h.html#adfba151539355bd641e09112365f1a90">OBD_FAIL_PTLRPC_HPREQ_NOTIMEOUT</a>))
<a name="l02016"></a>02016                 fail_opc = <a class="code" href="obd__support_8h.html#adfba151539355bd641e09112365f1a90">OBD_FAIL_PTLRPC_HPREQ_NOTIMEOUT</a>;
<a name="l02017"></a>02017         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="obd__support_8h.html#a1a625df67e59932bc7ef6f87a8548cda">OBD_FAIL_CHECK</a>(<a class="code" href="obd__support_8h.html#adb6ecf1cdcfc4f483fd8448b971506a8">OBD_FAIL_PTLRPC_HPREQ_TIMEOUT</a>))
<a name="l02018"></a>02018                 fail_opc = <a class="code" href="obd__support_8h.html#adb6ecf1cdcfc4f483fd8448b971506a8">OBD_FAIL_PTLRPC_HPREQ_TIMEOUT</a>;
<a name="l02019"></a>02019 
<a name="l02020"></a>02020         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(fail_opc)) {
<a name="l02021"></a>02021                 <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> &amp;&amp; request-&gt;rq_ops)
<a name="l02022"></a>02022                         <a class="code" href="obd__support_8h.html#afeaff6f88a7a02b18ff70e2825e3ddc8">OBD_FAIL_TIMEOUT</a>(fail_opc, 4);
<a name="l02023"></a>02023         }
<a name="l02024"></a>02024 
<a name="l02025"></a>02025         <a class="code" href="group__net.html#gacfc7db95b5c34170599725b0f098bc5c" title="Change request phase of req to new_phase.">ptlrpc_rqphase_move</a>(request, <a class="code" href="group__net.html#gga0e456f0c28b52cad4b543eec9efa656aa9f48f591c9f9032215c26eb2da589c87">RQ_PHASE_INTERPRET</a>);
<a name="l02026"></a>02026 
<a name="l02027"></a>02027         <span class="keywordflow">if</span>(<a class="code" href="obd__support_8h.html#a1a625df67e59932bc7ef6f87a8548cda">OBD_FAIL_CHECK</a>(<a class="code" href="obd__support_8h.html#abd2dd9c945e6eed21b6b2af590e942f5">OBD_FAIL_PTLRPC_DUMP_LOG</a>))
<a name="l02028"></a>02028                 <a class="code" href="libcfs__private_8h.html#a85d1d89abbc273e1797c0e98299719eb">libcfs_debug_dumplog</a>();
<a name="l02029"></a>02029 
<a name="l02030"></a>02030         do_gettimeofday(&amp;work_start);
<a name="l02031"></a>02031         timediff = <a class="code" href="libcfs__time_8h.html#af9b4a1317e77625716e3f7c01d3f4c01">cfs_timeval_sub</a>(&amp;work_start, &amp;request-&gt;rq_arrival_time,NULL);
<a name="l02032"></a>02032         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a47394cf36a95669f10d8ccaaa21e3e82" title="Pointer to statistic data for this service.">srv_stats</a> != NULL)) {
<a name="l02033"></a>02033                 <a class="code" href="lprocfs__status_8h.html#a5757deead2e3930997728dc4d173c24b">lprocfs_counter_add</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a47394cf36a95669f10d8ccaaa21e3e82" title="Pointer to statistic data for this service.">srv_stats</a>, <a class="code" href="lprocfs__status_8h.html#af9bdc3014f3d54c426b6d2df10de4960aad5d8e98da076b066a93d3baf2667ec7">PTLRPC_REQWAIT_CNTR</a>,
<a name="l02034"></a>02034                                     timediff);
<a name="l02035"></a>02035                 <a class="code" href="lprocfs__status_8h.html#a5757deead2e3930997728dc4d173c24b">lprocfs_counter_add</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a47394cf36a95669f10d8ccaaa21e3e82" title="Pointer to statistic data for this service.">srv_stats</a>, <a class="code" href="lprocfs__status_8h.html#af9bdc3014f3d54c426b6d2df10de4960afaae8d6d503e339b226c14af351838aa">PTLRPC_REQQDEPTH_CNTR</a>,
<a name="l02036"></a>02036                                     svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a8283d58f626b885a04d59e22ac5b234a" title="# incoming reqs">scp_nreqs_incoming</a>);
<a name="l02037"></a>02037                 <a class="code" href="lprocfs__status_8h.html#a5757deead2e3930997728dc4d173c24b">lprocfs_counter_add</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a47394cf36a95669f10d8ccaaa21e3e82" title="Pointer to statistic data for this service.">srv_stats</a>, <a class="code" href="lprocfs__status_8h.html#af9bdc3014f3d54c426b6d2df10de4960a526a138a6295e6476b7172b944790e5f">PTLRPC_REQACTIVE_CNTR</a>,
<a name="l02038"></a>02038                                     svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a>);
<a name="l02039"></a>02039                 <a class="code" href="lprocfs__status_8h.html#a5757deead2e3930997728dc4d173c24b">lprocfs_counter_add</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a47394cf36a95669f10d8ccaaa21e3e82" title="Pointer to statistic data for this service.">srv_stats</a>, <a class="code" href="lprocfs__status_8h.html#af9bdc3014f3d54c426b6d2df10de4960a3e3dc4a981bb2c3e62bded0abf320077">PTLRPC_TIMEOUT</a>,
<a name="l02040"></a>02040                                     <a class="code" href="group__export.html#ga68221f24f8416268d266c57882e21fe5">at_get</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afdd717e7ea139bdf2e2914ac425c8754" title="estimated rpc service time">scp_at_estimate</a>));
<a name="l02041"></a>02041         }
<a name="l02042"></a>02042 
<a name="l02043"></a>02043         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>)) {
<a name="l02044"></a>02044                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(<a class="code" href="service_8c.html#a80f18cb077b5d857391b16687f9dcb0e" title="Sanity check request req.">ptlrpc_check_req</a>(request)))
<a name="l02045"></a>02045                         <span class="keywordflow">goto</span> put_conn;
<a name="l02046"></a>02046                 <a class="code" href="group__net.html#ga3b962a1b6e534a49a4848336555d1d89" title="This function makes sure dead exports are evicted in a timely manner.">ptlrpc_update_export_timer</a>(request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>, timediff &gt;&gt; 19);
<a name="l02047"></a>02047         }
<a name="l02048"></a>02048 
<a name="l02049"></a>02049         <span class="comment">/* Discard requests queued for longer than the deadline.</span>
<a name="l02050"></a>02050 <span class="comment">           The deadline is increased if we send an early reply. */</span>
<a name="l02051"></a>02051         <span class="keywordflow">if</span> (<a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() &gt; request-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>) {
<a name="l02052"></a>02052                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#af25fefaf5c55ce92d41da370dc9399c2">D_ERROR</a>, request, <span class="stringliteral">&quot;Dropping timed-out request from %s&quot;</span>
<a name="l02053"></a>02053                           <span class="stringliteral">&quot;: deadline &quot;</span><a class="code" href="linux-time_8h.html#a51671c06b4d7ee85b50b3243086e7f6a">CFS_DURATION_T</a><span class="stringliteral">&quot;:&quot;</span><a class="code" href="linux-time_8h.html#a51671c06b4d7ee85b50b3243086e7f6a">CFS_DURATION_T</a><span class="stringliteral">&quot;s ago\n&quot;</span>,
<a name="l02054"></a>02054                           <a class="code" href="nidstr_8h.html#ab0b294c710b89667647c7636e7e4d519">libcfs_id2str</a>(request-&gt;<a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>),
<a name="l02055"></a>02055                           <a class="code" href="libcfs__time_8h.html#ab328ad5c5c5b57cebf2ba487e73af3e4">cfs_time_sub</a>(request-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>,
<a name="l02056"></a>02056                           request-&gt;rq_arrival_time.tv_sec),
<a name="l02057"></a>02057                           <a class="code" href="libcfs__time_8h.html#ab328ad5c5c5b57cebf2ba487e73af3e4">cfs_time_sub</a>(<a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>(),
<a name="l02058"></a>02058                           request-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>));
<a name="l02059"></a>02059                 <span class="keywordflow">goto</span> put_conn;
<a name="l02060"></a>02060         }
<a name="l02061"></a>02061 
<a name="l02062"></a>02062         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, <span class="stringliteral">&quot;Handling RPC pname:cluuid+ref:pid:xid:nid:opc &quot;</span>
<a name="l02063"></a>02063                <span class="stringliteral">&quot;%s:%s+%d:%d:x&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;:%s:%d\n&quot;</span>, <a class="code" href="linux_2libcfs_8h.html#abf3c2c07ba6bba1be0b48e2d9c5c10ea">current_comm</a>(),
<a name="l02064"></a>02064                (request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> ?
<a name="l02065"></a>02065                 (<span class="keywordtype">char</span> *)request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#add66633855471a2f937a811ce353b5ca" title="Lock references.">exp_client_uuid</a>.<a class="code" href="structobd__uuid.html#aa6cced3e76a3656e5152bb9ed249e7a1">uuid</a> : <span class="stringliteral">&quot;0&quot;</span>),
<a name="l02066"></a>02066                (request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> ?
<a name="l02067"></a>02067                 atomic_read(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a0d045bc9d5806c434b1ceb547e15b2df">exp_refcount</a>) : -99),
<a name="l02068"></a>02068                <a class="code" href="group__net.html#gaaa6ef42a52d75cf87cb0b7834606093b">lustre_msg_get_status</a>(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>), request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>,
<a name="l02069"></a>02069                <a class="code" href="nidstr_8h.html#ab0b294c710b89667647c7636e7e4d519">libcfs_id2str</a>(request-&gt;<a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>),
<a name="l02070"></a>02070                <a class="code" href="group__net.html#ga5889b19f527897c102df244998c9de02">lustre_msg_get_opc</a>(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>));
<a name="l02071"></a>02071 
<a name="l02072"></a>02072         <span class="keywordflow">if</span> (<a class="code" href="group__net.html#ga5889b19f527897c102df244998c9de02">lustre_msg_get_opc</a>(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) != <a class="code" href="packet-lustre_8c.html#a54e5c4528c1781401f73f51e2b705292">OBD_PING</a>)
<a name="l02073"></a>02073                 <a class="code" href="libcfs__fail_8h.html#a15a0b3b084f1b4183fc1af9a89029ab7">CFS_FAIL_TIMEOUT_MS</a>(<a class="code" href="obd__support_8h.html#a0e269f362b184beea883ffe699459dbe">OBD_FAIL_PTLRPC_PAUSE_REQ</a>, <a class="code" href="libcfs__fail_8h.html#a2ef1cb02c9a3c9f5a23b1f818d3b99ba">cfs_fail_val</a>);
<a name="l02074"></a>02074 
<a name="l02075"></a>02075         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;got req &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;\n&quot;</span>, request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>);
<a name="l02076"></a>02076 
<a name="l02077"></a>02077         <span class="comment">/* re-assign request and sesson thread to the current one */</span>
<a name="l02078"></a>02078         request-&gt;rq_svc_thread = thread;
<a name="l02079"></a>02079         <span class="keywordflow">if</span> (thread != NULL) {
<a name="l02080"></a>02080                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(request-&gt;rq_session.lc_thread == NULL);
<a name="l02081"></a>02081                 request-&gt;rq_session.lc_thread = thread;
<a name="l02082"></a>02082                 thread-&gt;<a class="code" href="structptlrpc__thread.html#af6cc81f0f51f2a2a3c62f80416b75ba8">t_env</a>-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a> = &amp;request-&gt;rq_session;
<a name="l02083"></a>02083         }
<a name="l02084"></a>02084         svc-&gt;<a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90" title="service operations table">srv_ops</a>.<a class="code" href="structptlrpc__service__ops.html#ace0bd2960a564f7e405763b10879d854" title="Handler function for incoming requests for this service.">so_req_handler</a>(request);
<a name="l02085"></a>02085 
<a name="l02086"></a>02086         <a class="code" href="group__net.html#gacfc7db95b5c34170599725b0f098bc5c" title="Change request phase of req to new_phase.">ptlrpc_rqphase_move</a>(request, <a class="code" href="group__net.html#gga0e456f0c28b52cad4b543eec9efa656aade4cc4a5d9abae94a06fca77e02ac001">RQ_PHASE_COMPLETE</a>);
<a name="l02087"></a>02087 
<a name="l02088"></a>02088 put_conn:
<a name="l02089"></a>02089         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(<a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() &gt; request-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>)) {
<a name="l02090"></a>02090                      <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="libcfs__debug_8h.html#acca9c9cff9837f6f3d2759b02a61ff1d">D_WARNING</a>, request, <span class="stringliteral">&quot;Request took longer &quot;</span>
<a name="l02091"></a>02091                                <span class="stringliteral">&quot;than estimated (&quot;</span><a class="code" href="linux-time_8h.html#a51671c06b4d7ee85b50b3243086e7f6a">CFS_DURATION_T</a><span class="stringliteral">&quot;:&quot;</span><a class="code" href="linux-time_8h.html#a51671c06b4d7ee85b50b3243086e7f6a">CFS_DURATION_T</a><span class="stringliteral">&quot;s);&quot;</span>
<a name="l02092"></a>02092                                <span class="stringliteral">&quot; client may timeout.&quot;</span>,
<a name="l02093"></a>02093                                <a class="code" href="libcfs__time_8h.html#ab328ad5c5c5b57cebf2ba487e73af3e4">cfs_time_sub</a>(request-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>,
<a name="l02094"></a>02094                                             request-&gt;rq_arrival_time.tv_sec),
<a name="l02095"></a>02095                                <a class="code" href="libcfs__time_8h.html#ab328ad5c5c5b57cebf2ba487e73af3e4">cfs_time_sub</a>(<a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>(),
<a name="l02096"></a>02096                                             request-&gt;<a class="code" href="structptlrpc__request.html#ab29afa9e8660c959a61d6f4b86777844" title="when request must finish.">rq_deadline</a>));
<a name="l02097"></a>02097         }
<a name="l02098"></a>02098 
<a name="l02099"></a>02099         do_gettimeofday(&amp;work_end);
<a name="l02100"></a>02100         timediff = <a class="code" href="libcfs__time_8h.html#af9b4a1317e77625716e3f7c01d3f4c01">cfs_timeval_sub</a>(&amp;work_end, &amp;work_start, NULL);
<a name="l02101"></a>02101         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, <span class="stringliteral">&quot;Handled RPC pname:cluuid+ref:pid:xid:nid:opc &quot;</span>
<a name="l02102"></a>02102                <span class="stringliteral">&quot;%s:%s+%d:%d:x&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;:%s:%d Request procesed in &quot;</span>
<a name="l02103"></a>02103                <span class="stringliteral">&quot;%ldus (%ldus total) trans &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot; rc %d/%d\n&quot;</span>,
<a name="l02104"></a>02104                 <a class="code" href="linux_2libcfs_8h.html#abf3c2c07ba6bba1be0b48e2d9c5c10ea">current_comm</a>(),
<a name="l02105"></a>02105                 (request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> ?
<a name="l02106"></a>02106                  (<span class="keywordtype">char</span> *)request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#add66633855471a2f937a811ce353b5ca" title="Lock references.">exp_client_uuid</a>.<a class="code" href="structobd__uuid.html#aa6cced3e76a3656e5152bb9ed249e7a1">uuid</a> : <span class="stringliteral">&quot;0&quot;</span>),
<a name="l02107"></a>02107                 (request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a> ?
<a name="l02108"></a>02108                  atomic_read(&amp;request-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>-&gt;<a class="code" href="structobd__export.html#a0d045bc9d5806c434b1ceb547e15b2df">exp_refcount</a>) : -99),
<a name="l02109"></a>02109                 <a class="code" href="group__net.html#gaaa6ef42a52d75cf87cb0b7834606093b">lustre_msg_get_status</a>(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>),
<a name="l02110"></a>02110                 request-&gt;<a class="code" href="structptlrpc__request.html#ab88b3c4dc962d237d5642e0808d323b2" title="xid">rq_xid</a>,
<a name="l02111"></a>02111                 <a class="code" href="nidstr_8h.html#ab0b294c710b89667647c7636e7e4d519">libcfs_id2str</a>(request-&gt;<a class="code" href="structptlrpc__request.html#afcb4b4a3d2b10a89c7bd4be4a02d0c4e" title="Peer description (the other side).">rq_peer</a>),
<a name="l02112"></a>02112                 <a class="code" href="group__net.html#ga5889b19f527897c102df244998c9de02">lustre_msg_get_opc</a>(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>),
<a name="l02113"></a>02113                 timediff,
<a name="l02114"></a>02114                 <a class="code" href="libcfs__time_8h.html#af9b4a1317e77625716e3f7c01d3f4c01">cfs_timeval_sub</a>(&amp;work_end, &amp;request-&gt;rq_arrival_time, NULL),
<a name="l02115"></a>02115                 (request-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> ?
<a name="l02116"></a>02116                  <a class="code" href="group__net.html#ga9bedef213e170e969899bfab36bb8fb0">lustre_msg_get_transno</a>(request-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) :
<a name="l02117"></a>02117                  request-&gt;<a class="code" href="structptlrpc__request.html#ab4228f142360486f518cebde2614dafd" title="Transaction number.">rq_transno</a>),
<a name="l02118"></a>02118                 request-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a>,
<a name="l02119"></a>02119                 (request-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a> ?
<a name="l02120"></a>02120                  <a class="code" href="group__net.html#gaaa6ef42a52d75cf87cb0b7834606093b">lustre_msg_get_status</a>(request-&gt;<a class="code" href="structptlrpc__request.html#a0c10a934ec07154a75ee696126876f3e" title="Reply message - server response.">rq_repmsg</a>) : -999));
<a name="l02121"></a>02121         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a47394cf36a95669f10d8ccaaa21e3e82" title="Pointer to statistic data for this service.">srv_stats</a> != NULL &amp;&amp; request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a> != NULL)) {
<a name="l02122"></a>02122                 __u32 <a class="code" href="iam__ut_8c.html#a99a30df0f2488360cdd46b4b88e5f5f0">op</a> = <a class="code" href="group__net.html#ga5889b19f527897c102df244998c9de02">lustre_msg_get_opc</a>(request-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>);
<a name="l02123"></a>02123                 <span class="keywordtype">int</span> opc = <a class="code" href="lprocfs__status_8h.html#a904e52a00f9fe88e7f5085893ce5a560">opcode_offset</a>(op);
<a name="l02124"></a>02124                 <span class="keywordflow">if</span> (opc &gt; 0 &amp;&amp; !(op == <a class="code" href="packet-lustre_8c.html#a8321f1254097562570d86daf2af860e8">LDLM_ENQUEUE</a> || op == <a class="code" href="group__lustreidl.html#ggafb46b2fd1532fecf64a120ca96d31c25a943b3833166c1d5bbfdd82db81553065">MDS_REINT</a>)) {
<a name="l02125"></a>02125                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(opc &lt; <a class="code" href="lprocfs__status_8h.html#a561d65a042b0fc805cc98795448c27ae">LUSTRE_MAX_OPCODES</a>);
<a name="l02126"></a>02126                         <a class="code" href="lprocfs__status_8h.html#a5757deead2e3930997728dc4d173c24b">lprocfs_counter_add</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a47394cf36a95669f10d8ccaaa21e3e82" title="Pointer to statistic data for this service.">srv_stats</a>,
<a name="l02127"></a>02127                                             opc + <a class="code" href="lprocfs__status_8h.html#a4abf2f876f25b8f4e8f296b3c2c111e1">EXTRA_MAX_OPCODES</a>,
<a name="l02128"></a>02128                                             timediff);
<a name="l02129"></a>02129                 }
<a name="l02130"></a>02130         }
<a name="l02131"></a>02131         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(request-&gt;<a class="code" href="structptlrpc__request.html#a4107706ff91738c79e18c271469afe8d" title="how many early replies (for stats)">rq_early_count</a>)) {
<a name="l02132"></a>02132                 <a class="code" href="group__net.html#ga2d5d1c7075b9387118d9356833e9abdf" title="This is the debug print function you need to use to print request sturucture content...">DEBUG_REQ</a>(<a class="code" href="group__export.html#ga1e9af31f1c737a82f0c1fb7dac29a322" title="Adaptive Timeout stuff.">D_ADAPTTO</a>, request,
<a name="l02133"></a>02133                           <span class="stringliteral">&quot;sent %d early replies before finishing in &quot;</span>
<a name="l02134"></a>02134                           <a class="code" href="linux-time_8h.html#a51671c06b4d7ee85b50b3243086e7f6a">CFS_DURATION_T</a><span class="stringliteral">&quot;s&quot;</span>,
<a name="l02135"></a>02135                           request-&gt;<a class="code" href="structptlrpc__request.html#a4107706ff91738c79e18c271469afe8d" title="how many early replies (for stats)">rq_early_count</a>,
<a name="l02136"></a>02136                           <a class="code" href="libcfs__time_8h.html#ab328ad5c5c5b57cebf2ba487e73af3e4">cfs_time_sub</a>(work_end.tv_sec,
<a name="l02137"></a>02137                           request-&gt;rq_arrival_time.tv_sec));
<a name="l02138"></a>02138         }
<a name="l02139"></a>02139 
<a name="l02140"></a>02140         <a class="code" href="service_8c.html#a82747d1c580374cfd9087a99f1c67750" title="to finish an active request: stop sending more early replies, and release the request...">ptlrpc_server_finish_active_request</a>(svcpt, request);
<a name="l02141"></a>02141 
<a name="l02142"></a>02142         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(1);
<a name="l02143"></a>02143 }
<a name="l02144"></a>02144 
<a name="l02148"></a>02148 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02149"></a><a class="code" href="service_8c.html#a028888de363f84cfcc617068e00c9f78">02149</a> <a class="code" href="service_8c.html#a028888de363f84cfcc617068e00c9f78" title="An internal function to process a single reply state object.">ptlrpc_handle_rs</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs)
<a name="l02150"></a>02150 {
<a name="l02151"></a>02151         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt = rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aca1f0b4b5dc96eb0b9c8c7012cfa4ba4">rs_svcpt</a>;
<a name="l02152"></a>02152         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>     *svc = svcpt-&gt;scp_service;
<a name="l02153"></a>02153         <span class="keyword">struct </span><a class="code" href="structobd__export.html" title="Export structure.">obd_export</a>         *exp;
<a name="l02154"></a>02154         <span class="keywordtype">int</span>                        nlocks;
<a name="l02155"></a>02155         <span class="keywordtype">int</span>                        been_handled;
<a name="l02156"></a>02156         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02157"></a>02157 
<a name="l02158"></a>02158         exp = rs-&gt;<a class="code" href="structptlrpc__reply__state.html#af0e79312da8f31e77da05b03ed266430">rs_export</a>;
<a name="l02159"></a>02159 
<a name="l02160"></a>02160         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a053119600f608d97cd028b4e145772f2" title="Reply state flags.">rs_difficult</a>);
<a name="l02161"></a>02161         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a5ecfa6736210f6c83ec1c15fea5cd3ac">rs_scheduled</a>);
<a name="l02162"></a>02162         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>));
<a name="l02163"></a>02163 
<a name="l02164"></a>02164         spin_lock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l02165"></a>02165         <span class="comment">/* Noop if removed already */</span>
<a name="l02166"></a>02166         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aa51185c7e39693f894ddb9e9733edf20" title="Linkage for list of all reply states on same export.">rs_exp_list</a>);
<a name="l02167"></a>02167         spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#a3d3174a4ec7f564a2aea27b749b472e5" title="protects exp_flags, exp_outstanding_replies and the change of exp_imp_reverse">exp_lock</a>);
<a name="l02168"></a>02168 
<a name="l02169"></a>02169         <span class="comment">/* The disk commit callback holds exp_uncommitted_replies_lock while it</span>
<a name="l02170"></a>02170 <span class="comment">         * iterates over newly committed replies, removing them from</span>
<a name="l02171"></a>02171 <span class="comment">         * exp_uncommitted_replies.  It then drops this lock and schedules the</span>
<a name="l02172"></a>02172 <span class="comment">         * replies it found for handling here.</span>
<a name="l02173"></a>02173 <span class="comment">         *</span>
<a name="l02174"></a>02174 <span class="comment">         * We can avoid contention for exp_uncommitted_replies_lock between the</span>
<a name="l02175"></a>02175 <span class="comment">         * HRT threads and further commit callbacks by checking rs_committed</span>
<a name="l02176"></a>02176 <span class="comment">         * which is set in the commit callback while it holds both</span>
<a name="l02177"></a>02177 <span class="comment">         * rs_lock and exp_uncommitted_reples.</span>
<a name="l02178"></a>02178 <span class="comment">         *</span>
<a name="l02179"></a>02179 <span class="comment">         * If we see rs_committed clear, the commit callback _may_ not have</span>
<a name="l02180"></a>02180 <span class="comment">         * handled this reply yet and we race with it to grab</span>
<a name="l02181"></a>02181 <span class="comment">         * exp_uncommitted_replies_lock before removing the reply from</span>
<a name="l02182"></a>02182 <span class="comment">         * exp_uncommitted_replies.  Note that if we lose the race and the</span>
<a name="l02183"></a>02183 <span class="comment">         * reply has already been removed, list_del_init() is a noop.</span>
<a name="l02184"></a>02184 <span class="comment">         *</span>
<a name="l02185"></a>02185 <span class="comment">         * If we see rs_committed set, we know the commit callback is handling,</span>
<a name="l02186"></a>02186 <span class="comment">         * or has handled this reply since store reordering might allow us to</span>
<a name="l02187"></a>02187 <span class="comment">         * see rs_committed set out of sequence.  But since this is done</span>
<a name="l02188"></a>02188 <span class="comment">         * holding rs_lock, we can be sure it has all completed once we hold</span>
<a name="l02189"></a>02189 <span class="comment">         * rs_lock, which we do right next.</span>
<a name="l02190"></a>02190 <span class="comment">         */</span>
<a name="l02191"></a>02191         <span class="keywordflow">if</span> (!rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ac1225eab1d99d4f8db8d5ac02ef71557">rs_committed</a>) {
<a name="l02192"></a>02192                 spin_lock(&amp;exp-&gt;<a class="code" href="structobd__export.html#acaaf11d4ac6705216d4297126839f5b4">exp_uncommitted_replies_lock</a>);
<a name="l02193"></a>02193                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a123f596acacfe1cc660bf4ea5407c032" title="Linkage for list of all reply states for same obd.">rs_obd_list</a>);
<a name="l02194"></a>02194                 spin_unlock(&amp;exp-&gt;<a class="code" href="structobd__export.html#acaaf11d4ac6705216d4297126839f5b4">exp_uncommitted_replies_lock</a>);
<a name="l02195"></a>02195         }
<a name="l02196"></a>02196 
<a name="l02197"></a>02197         spin_lock(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l02198"></a>02198 
<a name="l02199"></a>02199         been_handled = rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a373792d6f110ada420c4dee13c5ba870">rs_handled</a>;
<a name="l02200"></a>02200         rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a373792d6f110ada420c4dee13c5ba870">rs_handled</a> = 1;
<a name="l02201"></a>02201 
<a name="l02202"></a>02202         nlocks = rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a971c2d968f9044adfbb3361f6d938e51" title="Number of locks awaiting client ACK.">rs_nlocks</a>;                 <span class="comment">/* atomic &quot;steal&quot;, but */</span>
<a name="l02203"></a>02203         rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a971c2d968f9044adfbb3361f6d938e51" title="Number of locks awaiting client ACK.">rs_nlocks</a> = 0;                      <span class="comment">/* locks still on rs_locks! */</span>
<a name="l02204"></a>02204 
<a name="l02205"></a>02205         <span class="keywordflow">if</span> (nlocks == 0 &amp;&amp; !been_handled) {
<a name="l02206"></a>02206                 <span class="comment">/* If we see this, we should already have seen the warning</span>
<a name="l02207"></a>02207 <span class="comment">                 * in mds_steal_ack_locks()  */</span>
<a name="l02208"></a>02208                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a125b66aada63eaccd986e27e8dac1ab2">D_HA</a>, <span class="stringliteral">&quot;All locks stolen from rs %p x&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a414a71ca04d1db8d7875631cf51d45bf">LPD64</a><span class="stringliteral">&quot;.t&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a414a71ca04d1db8d7875631cf51d45bf">LPD64</a>
<a name="l02209"></a>02209                        <span class="stringliteral">&quot; o%d NID %s\n&quot;</span>,
<a name="l02210"></a>02210                        rs,
<a name="l02211"></a>02211                        rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a73136f25efd9632142e418146775c1a3" title="xid">rs_xid</a>, rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aaa25f70935ff08384bd1f64ee0fb3ac0" title="Transaction number.">rs_transno</a>, rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a159f1f865036a3bafd3bba949d63ff8e" title="opcode">rs_opc</a>,
<a name="l02212"></a>02212                        <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(exp-&gt;<a class="code" href="structobd__export.html#ae0ed47ab09f5904f1b740d33bd2f27ef" title="Active connetion.">exp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>));
<a name="l02213"></a>02213         }
<a name="l02214"></a>02214 
<a name="l02215"></a>02215         <span class="keywordflow">if</span> ((!been_handled &amp;&amp; rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aa0a0ce60c4f057f43da410140eca3598">rs_on_net</a>) || nlocks &gt; 0) {
<a name="l02216"></a>02216                 spin_unlock(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l02217"></a>02217 
<a name="l02218"></a>02218                 <span class="keywordflow">if</span> (!been_handled &amp;&amp; rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aa0a0ce60c4f057f43da410140eca3598">rs_on_net</a>) {
<a name="l02219"></a>02219                         <a class="code" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink</a>(rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a48dd3dc9a45264d8875c1508d61a25e8" title="Lnet metadata handle for the reply.">rs_md_h</a>);
<a name="l02220"></a>02220                         <span class="comment">/* Ignore return code; we&apos;re racing with completion */</span>
<a name="l02221"></a>02221                 }
<a name="l02222"></a>02222 
<a name="l02223"></a>02223                 <span class="keywordflow">while</span> (nlocks-- &gt; 0)
<a name="l02224"></a>02224                         <a class="code" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a610b2cfcd3f4e63424d0d21e3faadb63" title="Handles of locks awaiting client reply ACK.">rs_locks</a>[nlocks],
<a name="l02225"></a>02225                                          rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ad8efd2c38ee66e40822759cd3d7255fe" title="Lock modes of locks in rs_locks.">rs_modes</a>[nlocks]);
<a name="l02226"></a>02226 
<a name="l02227"></a>02227                 spin_lock(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l02228"></a>02228         }
<a name="l02229"></a>02229 
<a name="l02230"></a>02230         rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a5ecfa6736210f6c83ec1c15fea5cd3ac">rs_scheduled</a> = 0;
<a name="l02231"></a>02231 
<a name="l02232"></a>02232         <span class="keywordflow">if</span> (!rs-&gt;<a class="code" href="structptlrpc__reply__state.html#aa0a0ce60c4f057f43da410140eca3598">rs_on_net</a>) {
<a name="l02233"></a>02233                 <span class="comment">/* Off the net */</span>
<a name="l02234"></a>02234                 spin_unlock(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l02235"></a>02235 
<a name="l02236"></a>02236                 <a class="code" href="obd__class_8h.html#a60de37a3a43d309602be633a0f1125f9">class_export_put</a> (exp);
<a name="l02237"></a>02237                 rs-&gt;<a class="code" href="structptlrpc__reply__state.html#af0e79312da8f31e77da05b03ed266430">rs_export</a> = NULL;
<a name="l02238"></a>02238                 <a class="code" href="group__net.html#gab1e93aadb37e3874a19d1ac7c582eacf">ptlrpc_rs_decref</a>(rs);
<a name="l02239"></a>02239                 <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a53b120d0b76021b70f62730a7fb490fe" title="# &amp;#39;difficult&amp;#39; replies">scp_nreps_difficult</a>) &amp;&amp;
<a name="l02240"></a>02240                     svc-&gt;<a class="code" href="structptlrpc__service.html#a356fa84033571129333ab81646a283df" title="under unregister_service">srv_is_stopping</a>)
<a name="l02241"></a>02241                         wake_up_all(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aea613ac08a7dc84e671b4a260eed2765" title="all threads sleep on this.">scp_waitq</a>);
<a name="l02242"></a>02242                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(1);
<a name="l02243"></a>02243         }
<a name="l02244"></a>02244 
<a name="l02245"></a>02245         <span class="comment">/* still on the net; callback will schedule */</span>
<a name="l02246"></a>02246         spin_unlock(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l02247"></a>02247         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(1);
<a name="l02248"></a>02248 }
<a name="l02249"></a>02249 
<a name="l02250"></a>02250 
<a name="l02251"></a>02251 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02252"></a><a class="code" href="service_8c.html#ae95b1f7839d3ace23bfa28a6be4fd70c">02252</a> <a class="code" href="service_8c.html#ae95b1f7839d3ace23bfa28a6be4fd70c">ptlrpc_check_rqbd_pool</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02253"></a>02253 {
<a name="l02254"></a>02254         <span class="keywordtype">int</span> avail = svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a" title="# posted request buffers for receiving">scp_nrqbds_posted</a>;
<a name="l02255"></a>02255         <span class="keywordtype">int</span> low_water = <a class="code" href="ptlrpc__internal_8h.html#a840cfd893cfd1ea1f4ac7b04382ed44d">test_req_buffer_pressure</a> ? 0 :
<a name="l02256"></a>02256                         svcpt-&gt;scp_service-&gt;srv_nbuf_per_group / 2;
<a name="l02257"></a>02257 
<a name="l02258"></a>02258         <span class="comment">/* NB I&apos;m not locking; just looking. */</span>
<a name="l02259"></a>02259 
<a name="l02260"></a>02260         <span class="comment">/* CAVEAT EMPTOR: We might be allocating buffers here because we&apos;ve</span>
<a name="l02261"></a>02261 <span class="comment">         * allowed the request history to grow out of control.  We could put a</span>
<a name="l02262"></a>02262 <span class="comment">         * sanity check on that here and cull some history if we need the</span>
<a name="l02263"></a>02263 <span class="comment">         * space. */</span>
<a name="l02264"></a>02264 
<a name="l02265"></a>02265         <span class="keywordflow">if</span> (avail &lt;= low_water)
<a name="l02266"></a>02266                 <a class="code" href="service_8c.html#a30a2276abeb17ab744d168f4e53c2ee8">ptlrpc_grow_req_bufs</a>(svcpt, 1);
<a name="l02267"></a>02267 
<a name="l02268"></a>02268         <span class="keywordflow">if</span> (svcpt-&gt;scp_service-&gt;srv_stats) {
<a name="l02269"></a>02269                 <a class="code" href="lprocfs__status_8h.html#a5757deead2e3930997728dc4d173c24b">lprocfs_counter_add</a>(svcpt-&gt;scp_service-&gt;srv_stats,
<a name="l02270"></a>02270                                     <a class="code" href="lprocfs__status_8h.html#af9bdc3014f3d54c426b6d2df10de4960a9ba3085b0f13829314303f58b198b116">PTLRPC_REQBUF_AVAIL_CNTR</a>, avail);
<a name="l02271"></a>02271         }
<a name="l02272"></a>02272 }
<a name="l02273"></a>02273 
<a name="l02274"></a>02274 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02275"></a><a class="code" href="service_8c.html#a909aa12fe9994a55430ff3e660c01f4c">02275</a> <a class="code" href="service_8c.html#a909aa12fe9994a55430ff3e660c01f4c">ptlrpc_retry_rqbds</a>(<span class="keywordtype">void</span> *arg)
<a name="l02276"></a>02276 {
<a name="l02277"></a>02277         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt = (<span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *)arg;
<a name="l02278"></a>02278 
<a name="l02279"></a>02279         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a22eb45de0fb6b349d79bb092fb83c00a" title="timeout before re-posting reqs, in tick">scp_rqbd_timeout</a> = 0;
<a name="l02280"></a>02280         <span class="keywordflow">return</span> -ETIMEDOUT;
<a name="l02281"></a>02281 }
<a name="l02282"></a>02282 
<a name="l02283"></a>02283 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02284"></a><a class="code" href="service_8c.html#a3cfdf38f0d5acd7850dd17575a69560e">02284</a> <a class="code" href="service_8c.html#a3cfdf38f0d5acd7850dd17575a69560e">ptlrpc_threads_enough</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02285"></a>02285 {
<a name="l02286"></a>02286         <span class="keywordflow">return</span> svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a> &lt;
<a name="l02287"></a>02287                svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a> - 1 -
<a name="l02288"></a>02288                (svcpt-&gt;scp_service-&gt;srv_ops.so_hpreq_handler != NULL);
<a name="l02289"></a>02289 }
<a name="l02290"></a>02290 
<a name="l02296"></a>02296 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02297"></a><a class="code" href="service_8c.html#a4430e2147c91e0e0a9d599b81203221e">02297</a> <a class="code" href="service_8c.html#a4430e2147c91e0e0a9d599b81203221e" title="allowed to create more threads user can call it w/o any lock but need to hold ptlrpc_service_part::s...">ptlrpc_threads_increasable</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02298"></a>02298 {
<a name="l02299"></a>02299         <span class="keywordflow">return</span> svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a> +
<a name="l02300"></a>02300                svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a" title="# of starting threads">scp_nthrs_starting</a> &lt;
<a name="l02301"></a>02301                svcpt-&gt;scp_service-&gt;srv_nthrs_cpt_limit;
<a name="l02302"></a>02302 }
<a name="l02303"></a>02303 
<a name="l02307"></a>02307 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02308"></a><a class="code" href="service_8c.html#a2506ff0b950b2484e9d414ac8fcda9d8">02308</a> <a class="code" href="service_8c.html#a2506ff0b950b2484e9d414ac8fcda9d8" title="too many requests and allowed to create more threads">ptlrpc_threads_need_create</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02309"></a>02309 {
<a name="l02310"></a>02310         <span class="keywordflow">return</span> !<a class="code" href="service_8c.html#a3cfdf38f0d5acd7850dd17575a69560e">ptlrpc_threads_enough</a>(svcpt) &amp;&amp;
<a name="l02311"></a>02311                 <a class="code" href="service_8c.html#a4430e2147c91e0e0a9d599b81203221e" title="allowed to create more threads user can call it w/o any lock but need to hold ptlrpc_service_part::s...">ptlrpc_threads_increasable</a>(svcpt);
<a name="l02312"></a>02312 }
<a name="l02313"></a>02313 
<a name="l02314"></a>02314 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02315"></a><a class="code" href="service_8c.html#a83a141ecdccbc4b49ab3c20b9c02de30">02315</a> <a class="code" href="service_8c.html#a83a141ecdccbc4b49ab3c20b9c02de30">ptlrpc_thread_stopping</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *<a class="code" href="obd_8c.html#a20057145635eb007e0621c11bc2d7176">thread</a>)
<a name="l02316"></a>02316 {
<a name="l02317"></a>02317         <span class="keywordflow">return</span> <a class="code" href="group__net.html#gab9dc73a42ff1dc50fe192daad32492bf">thread_is_stopping</a>(thread) ||
<a name="l02318"></a>02318                thread-&gt;<a class="code" href="structptlrpc__thread.html#af71d131dfdec9144aa2eac252e1e49e4" title="the svc this thread belonged to b=18582">t_svcpt</a>-&gt;scp_service-&gt;srv_is_stopping;
<a name="l02319"></a>02319 }
<a name="l02320"></a>02320 
<a name="l02321"></a>02321 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02322"></a><a class="code" href="service_8c.html#af8041c3cf09a9ac2e2f56d44e9d71d7a">02322</a> <a class="code" href="service_8c.html#af8041c3cf09a9ac2e2f56d44e9d71d7a">ptlrpc_rqbd_pending</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02323"></a>02323 {
<a name="l02324"></a>02324         <span class="keywordflow">return</span> !<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>) &amp;&amp;
<a name="l02325"></a>02325                svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a22eb45de0fb6b349d79bb092fb83c00a" title="timeout before re-posting reqs, in tick">scp_rqbd_timeout</a> == 0;
<a name="l02326"></a>02326 }
<a name="l02327"></a>02327 
<a name="l02328"></a>02328 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02329"></a><a class="code" href="service_8c.html#a636d42759b82b23e7c74c1023c6e5862">02329</a> <a class="code" href="service_8c.html#a636d42759b82b23e7c74c1023c6e5862">ptlrpc_at_check</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02330"></a>02330 {
<a name="l02331"></a>02331         <span class="keywordflow">return</span> svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af1d7d89389261e865e0333f652c77b22" title="check early replies">scp_at_check</a>;
<a name="l02332"></a>02332 }
<a name="l02333"></a>02333 
<a name="l02339"></a>02339 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l02340"></a><a class="code" href="service_8c.html#a0322266f64e271acfbab011e51926e55">02340</a> <a class="code" href="service_8c.html#a0322266f64e271acfbab011e51926e55" title="requests wait on preprocessing user can call it w/o any lock but need to hold ptlrpc_service_part::s...">ptlrpc_server_request_incoming</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02341"></a>02341 {
<a name="l02342"></a>02342         <span class="keywordflow">return</span> !<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a54fb502a4f6c138aaa49eb9afea6e39c" title="incoming reqs">scp_req_incoming</a>);
<a name="l02343"></a>02343 }
<a name="l02344"></a>02344 
<a name="l02345"></a><a class="code" href="service_8c.html#a1775ae7f2480ffa206fe948279e60e45">02345</a> <span class="keyword">static</span> <a class="code" href="fid_8mod_8c.html#a804f230e6220e338767d15b94fc5801d">__attribute__</a>((__noinline__)) int
<a name="l02346"></a>02346 ptlrpc_wait_event(struct <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt,
<a name="l02347"></a>02347                   struct <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *<a class="code" href="obd_8c.html#a20057145635eb007e0621c11bc2d7176">thread</a>)
<a name="l02348"></a>02348 {
<a name="l02349"></a>02349         <span class="comment">/* Don&apos;t exit while there are replies to be handled */</span>
<a name="l02350"></a>02350         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi = <a class="code" href="group__lib.html#ga2c8a9c91f1f21e7ff21abedc365140f9">LWI_TIMEOUT</a>(svcpt-&gt;scp_rqbd_timeout,
<a name="l02351"></a>02351                                              <a class="code" href="service_8c.html#a909aa12fe9994a55430ff3e660c01f4c">ptlrpc_retry_rqbds</a>, svcpt);
<a name="l02352"></a>02352 
<a name="l02353"></a>02353         <a class="code" href="watchdog_8c.html#a5cbdd2f87b8a70886600f5c8cc11eb6d">lc_watchdog_disable</a>(thread-&gt;t_watchdog);
<a name="l02354"></a>02354 
<a name="l02355"></a>02355         cond_resched();
<a name="l02356"></a>02356 
<a name="l02357"></a>02357         <a class="code" href="group__lib.html#ga44238bd6042bb29adc0735ba6efc808f">l_wait_event_exclusive_head</a>(svcpt-&gt;scp_waitq,
<a name="l02358"></a>02358                                 <a class="code" href="service_8c.html#a83a141ecdccbc4b49ab3c20b9c02de30">ptlrpc_thread_stopping</a>(thread) ||
<a name="l02359"></a>02359                                 <a class="code" href="service_8c.html#a0322266f64e271acfbab011e51926e55" title="requests wait on preprocessing user can call it w/o any lock but need to hold ptlrpc_service_part::s...">ptlrpc_server_request_incoming</a>(svcpt) ||
<a name="l02360"></a>02360                                 <a class="code" href="service_8c.html#ac05b630214d88cf338cae0215329ffac" title="Returns true if there are requests available in incoming request queue for processing...">ptlrpc_server_request_pending</a>(svcpt, <span class="keyword">false</span>) ||
<a name="l02361"></a>02361                                 <a class="code" href="service_8c.html#af8041c3cf09a9ac2e2f56d44e9d71d7a">ptlrpc_rqbd_pending</a>(svcpt) ||
<a name="l02362"></a>02362                                 <a class="code" href="service_8c.html#a636d42759b82b23e7c74c1023c6e5862">ptlrpc_at_check</a>(svcpt), &amp;lwi);
<a name="l02363"></a>02363 
<a name="l02364"></a>02364         <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#a83a141ecdccbc4b49ab3c20b9c02de30">ptlrpc_thread_stopping</a>(thread))
<a name="l02365"></a>02365                 <span class="keywordflow">return</span> -EINTR;
<a name="l02366"></a>02366 
<a name="l02367"></a>02367         <a class="code" href="watchdog_8c.html#a4dd2b3cd387b387da57709b2225b762b">lc_watchdog_touch</a>(thread-&gt;t_watchdog,
<a name="l02368"></a>02368                           <a class="code" href="group__net.html#ga6a27be8ed69a65dcb3c872cf7ee4f4f9">ptlrpc_server_get_timeout</a>(svcpt));
<a name="l02369"></a>02369         <span class="keywordflow">return</span> 0;
<a name="l02370"></a>02370 }
<a name="l02371"></a>02371 
<a name="l02378"></a><a class="code" href="service_8c.html#aac3d1f47bc27111a611b1c116255f53c">02378</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#aac3d1f47bc27111a611b1c116255f53c" title="Main thread body for service threads.">ptlrpc_main</a>(<span class="keywordtype">void</span> *arg)
<a name="l02379"></a>02379 {
<a name="l02380"></a>02380         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>            *<a class="code" href="obd_8c.html#a20057145635eb007e0621c11bc2d7176">thread</a> = (<span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a> *)arg;
<a name="l02381"></a>02381         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *svcpt = thread-&gt;<a class="code" href="structptlrpc__thread.html#af71d131dfdec9144aa2eac252e1e49e4" title="the svc this thread belonged to b=18582">t_svcpt</a>;
<a name="l02382"></a>02382         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>           *svc = svcpt-&gt;scp_service;
<a name="l02383"></a>02383         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>       *rs;
<a name="l02384"></a>02384         <span class="keyword">struct </span>group_info *ginfo = NULL;
<a name="l02385"></a>02385         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env;
<a name="l02386"></a>02386         <span class="keywordtype">int</span> counter = 0, rc = 0;
<a name="l02387"></a>02387         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02388"></a>02388 
<a name="l02389"></a>02389         thread-&gt;<a class="code" href="structptlrpc__thread.html#aa8c67cb27a88779527ca37106a52e095" title="service thread pid">t_pid</a> = <a class="code" href="linux_2libcfs_8h.html#a9fce95151f16556044079367a03239bb">current_pid</a>();
<a name="l02390"></a>02390         unshare_fs_struct();
<a name="l02391"></a>02391 
<a name="l02392"></a>02392         <span class="comment">/* NB: we will call cfs_cpt_bind() for all threads, because we</span>
<a name="l02393"></a>02393 <span class="comment">         * might want to run lustre server only on a subset of system CPUs,</span>
<a name="l02394"></a>02394 <span class="comment">         * in that case -&gt;scp_cpt is CFS_CPT_ANY */</span>
<a name="l02395"></a>02395         rc = <a class="code" href="libcfs__cpu_8h.html#a5640d52431f8a9f49f0ca6c93c6e4d10" title="bind current thread on a CPU-partition cpt of cptab ">cfs_cpt_bind</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a>);
<a name="l02396"></a>02396         <span class="keywordflow">if</span> (rc != 0) {
<a name="l02397"></a>02397                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;%s: failed to bind %s on CPT %d\n&quot;</span>,
<a name="l02398"></a>02398                       svc-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, thread-&gt;<a class="code" href="structptlrpc__thread.html#adf5b750656843ad30ddbef591081dbc8">t_name</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a>);
<a name="l02399"></a>02399         }
<a name="l02400"></a>02400 
<a name="l02401"></a>02401         ginfo = groups_alloc(0);
<a name="l02402"></a>02402         <span class="keywordflow">if</span> (!ginfo) {
<a name="l02403"></a>02403                 rc = -ENOMEM;
<a name="l02404"></a>02404                 <span class="keywordflow">goto</span> out;
<a name="l02405"></a>02405         }
<a name="l02406"></a>02406 
<a name="l02407"></a>02407         set_current_groups(ginfo);
<a name="l02408"></a>02408         put_group_info(ginfo);
<a name="l02409"></a>02409 
<a name="l02410"></a>02410         <span class="keywordflow">if</span> (svc-&gt;<a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90" title="service operations table">srv_ops</a>.<a class="code" href="structptlrpc__service__ops.html#a46b48cb79fc9aa8a65bb59b204ef6f29" title="if non-NULL called during thread creation (ptlrpc_start_thread()) to initialize service...">so_thr_init</a> != NULL) {
<a name="l02411"></a>02411                 rc = svc-&gt;<a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90" title="service operations table">srv_ops</a>.<a class="code" href="structptlrpc__service__ops.html#a46b48cb79fc9aa8a65bb59b204ef6f29" title="if non-NULL called during thread creation (ptlrpc_start_thread()) to initialize service...">so_thr_init</a>(thread);
<a name="l02412"></a>02412                 <span class="keywordflow">if</span> (rc)
<a name="l02413"></a>02413                         <span class="keywordflow">goto</span> out;
<a name="l02414"></a>02414         }
<a name="l02415"></a>02415 
<a name="l02416"></a>02416         <a class="code" href="obd__support_8h.html#ab5ccc29ab0a6625457a863652381c45c">OBD_ALLOC_PTR</a>(env);
<a name="l02417"></a>02417         <span class="keywordflow">if</span> (env == NULL) {
<a name="l02418"></a>02418                 rc = -ENOMEM;
<a name="l02419"></a>02419                 <span class="keywordflow">goto</span> out_srv_fini;
<a name="l02420"></a>02420         }
<a name="l02421"></a>02421 
<a name="l02422"></a>02422         rc = <a class="code" href="group__lu.html#ga952ae50ec5c4d109d2afecbb90c59a5c" title="Initialize context data-structure.">lu_context_init</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>,
<a name="l02423"></a>02423                              svc-&gt;<a class="code" href="structptlrpc__service.html#af76e91c99923a872836d738214efad63" title="Tags for lu_context associated with this thread, see struct lu_context.">srv_ctx_tags</a>|<a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aaa4613f38f1b6e834d8e6953c1b962e4e" title="Context should be remembered.">LCT_REMEMBER</a>|<a class="code" href="group__lu.html#ggad7e2d14b1b91480b0b25656f63169a0aa780c89ea39b1a7701917dd3d154dd084" title="Don&amp;#39;t add references for modules creating key values in that context.">LCT_NOREF</a>);
<a name="l02424"></a>02424         <span class="keywordflow">if</span> (rc)
<a name="l02425"></a>02425                 <span class="keywordflow">goto</span> out_srv_fini;
<a name="l02426"></a>02426 
<a name="l02427"></a>02427         thread-&gt;<a class="code" href="structptlrpc__thread.html#af6cc81f0f51f2a2a3c62f80416b75ba8">t_env</a> = env;
<a name="l02428"></a>02428         env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>.<a class="code" href="structlu__context.html#a10d0f65e355fcfbe968bf33efef644fa" title="Pointer to the home service thread.">lc_thread</a> = thread;
<a name="l02429"></a>02429         env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>.<a class="code" href="structlu__context.html#ac3d3d48fead955bf7e0d5fe0b2207421" title="Debugging cookie.">lc_cookie</a> = 0x6;
<a name="l02430"></a>02430 
<a name="l02431"></a>02431         <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>)) {
<a name="l02432"></a>02432                 rc = <a class="code" href="service_8c.html#aa3c644131d0f98fd22ad9ba28d49974c">ptlrpc_server_post_idle_rqbds</a>(svcpt);
<a name="l02433"></a>02433                 <span class="keywordflow">if</span> (rc &gt;= 0)
<a name="l02434"></a>02434                         <span class="keywordflow">continue</span>;
<a name="l02435"></a>02435 
<a name="l02436"></a>02436                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Failed to post rqbd for %s on CPT %d: %d\n&quot;</span>,
<a name="l02437"></a>02437                         svc-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a>, rc);
<a name="l02438"></a>02438                 <span class="keywordflow">goto</span> out_srv_fini;
<a name="l02439"></a>02439         }
<a name="l02440"></a>02440 
<a name="l02441"></a>02441         <span class="comment">/* Alloc reply state structure for this one */</span>
<a name="l02442"></a>02442         <a class="code" href="obd__support_8h.html#afa959cd10c660882cd6c5fad07311897">OBD_ALLOC_LARGE</a>(rs, svc-&gt;<a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51" title="biggest reply to send">srv_max_reply_size</a>);
<a name="l02443"></a>02443         <span class="keywordflow">if</span> (!rs) {
<a name="l02444"></a>02444                 rc = -ENOMEM;
<a name="l02445"></a>02445                 <span class="keywordflow">goto</span> out_srv_fini;
<a name="l02446"></a>02446         }
<a name="l02447"></a>02447 
<a name="l02448"></a>02448         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l02449"></a>02449 
<a name="l02450"></a>02450         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="group__net.html#ga31c68adf3489642e7bf76bb5b4abfbdd">thread_is_starting</a>(thread));
<a name="l02451"></a>02451         <a class="code" href="group__net.html#ga17ef66e44dcebdbce9887a789d7d49a5">thread_clear_flags</a>(thread, <a class="code" href="group__net.html#gga9334a5b9057f32da96db9b5c6a045d67acc1c5776026581be68cdaa44692575c8">SVC_STARTING</a>);
<a name="l02452"></a>02452 
<a name="l02453"></a>02453         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a" title="# of starting threads">scp_nthrs_starting</a> == 1);
<a name="l02454"></a>02454         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a" title="# of starting threads">scp_nthrs_starting</a>--;
<a name="l02455"></a>02455 
<a name="l02456"></a>02456         <span class="comment">/* SVC_STOPPING may already be set here if someone else is trying</span>
<a name="l02457"></a>02457 <span class="comment">         * to stop the service while this new thread has been dynamically</span>
<a name="l02458"></a>02458 <span class="comment">         * forked. We still set SVC_RUNNING to let our creator know that</span>
<a name="l02459"></a>02459 <span class="comment">         * we are now running, however we will exit as soon as possible */</span>
<a name="l02460"></a>02460         <a class="code" href="group__net.html#ga8a23b28e06b7f07c966d3e1b3eb321ba">thread_add_flags</a>(thread, <a class="code" href="group__net.html#gga9334a5b9057f32da96db9b5c6a045d67aa18622e2516bc2d9afa7677b9abcf5d8">SVC_RUNNING</a>);
<a name="l02461"></a>02461         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a>++;
<a name="l02462"></a>02462         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l02463"></a>02463 
<a name="l02464"></a>02464         <span class="comment">/* wake up our creator in case he&apos;s still waiting. */</span>
<a name="l02465"></a>02465         wake_up(&amp;thread-&gt;<a class="code" href="structptlrpc__thread.html#a2659c95a8d4b9867958aec477d1f2d6b">t_ctl_waitq</a>);
<a name="l02466"></a>02466 
<a name="l02467"></a>02467         thread-&gt;<a class="code" href="structptlrpc__thread.html#a03dcaad73307322e1dfe8430c7aa2049" title="put watchdog in the structure per thread b=14840">t_watchdog</a> = <a class="code" href="watchdog_8c.html#a261a5d310d4eecff8955ed8776d5d024">lc_watchdog_add</a>(<a class="code" href="group__net.html#ga6a27be8ed69a65dcb3c872cf7ee4f4f9">ptlrpc_server_get_timeout</a>(svcpt),
<a name="l02468"></a>02468                                              NULL, NULL);
<a name="l02469"></a>02469 
<a name="l02470"></a>02470         spin_lock(&amp;svcpt-&gt;scp_rep_lock);
<a name="l02471"></a>02471         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a1ba1dd17ce94daf0c4b82611d2203b77" title="List of free reply_states.">scp_rep_idle</a>);
<a name="l02472"></a>02472         wake_up(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a2053b8073689ec3cedd16a7095656a13" title="waitq to run, when adding stuff to srv_free_rs_list">scp_rep_waitq</a>);
<a name="l02473"></a>02473         spin_unlock(&amp;svcpt-&gt;scp_rep_lock);
<a name="l02474"></a>02474 
<a name="l02475"></a>02475         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;service thread %d (#%d) started\n&quot;</span>, thread-&gt;<a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a>,
<a name="l02476"></a>02476                svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a>);
<a name="l02477"></a>02477 
<a name="l02478"></a>02478         <span class="comment">/* XXX maintain a list of all managed devices: insert here */</span>
<a name="l02479"></a>02479         <span class="keywordflow">while</span> (!<a class="code" href="service_8c.html#a83a141ecdccbc4b49ab3c20b9c02de30">ptlrpc_thread_stopping</a>(thread)) {
<a name="l02480"></a>02480                 <span class="keywordflow">if</span> (ptlrpc_wait_event(svcpt, thread))
<a name="l02481"></a>02481                         <span class="keywordflow">break</span>;
<a name="l02482"></a>02482 
<a name="l02483"></a>02483                 <a class="code" href="service_8c.html#ae95b1f7839d3ace23bfa28a6be4fd70c">ptlrpc_check_rqbd_pool</a>(svcpt);
<a name="l02484"></a>02484 
<a name="l02485"></a>02485                 <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#a2506ff0b950b2484e9d414ac8fcda9d8" title="too many requests and allowed to create more threads">ptlrpc_threads_need_create</a>(svcpt)) {
<a name="l02486"></a>02486                         <span class="comment">/* Ignore return code - we tried... */</span>
<a name="l02487"></a>02487                         <a class="code" href="ptlrpc__internal_8h.html#ae010a629f5f836492d7726dcf2692a0e">ptlrpc_start_thread</a>(svcpt, 0);
<a name="l02488"></a>02488                 }
<a name="l02489"></a>02489 
<a name="l02490"></a>02490                 <span class="comment">/* reset le_ses to initial state */</span>
<a name="l02491"></a>02491                 env-&gt;<a class="code" href="structlu__env.html#a1428adbfa83ae8a08464e22392aa272c" title="&amp;quot;Session&amp;quot; context for per-request data.">le_ses</a> = NULL;
<a name="l02492"></a>02492                 <span class="comment">/* Process all incoming reqs before handling any */</span>
<a name="l02493"></a>02493                 <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#a0322266f64e271acfbab011e51926e55" title="requests wait on preprocessing user can call it w/o any lock but need to hold ptlrpc_service_part::s...">ptlrpc_server_request_incoming</a>(svcpt)) {
<a name="l02494"></a>02494                         <a class="code" href="group__lu.html#gaf86fb0a5bf6a1dadec88844694e2ad31" title="Called before entering context.">lu_context_enter</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l02495"></a>02495                         <a class="code" href="service_8c.html#af551f3c6043b58390a944685f0010c4e" title="Handle freshly incoming reqs, add to timed early reply list, pass on to regular request...">ptlrpc_server_handle_req_in</a>(svcpt, thread);
<a name="l02496"></a>02496                         <a class="code" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l02497"></a>02497 
<a name="l02498"></a>02498                         <span class="comment">/* but limit ourselves in case of flood */</span>
<a name="l02499"></a>02499                         <span class="keywordflow">if</span> (counter++ &lt; 100)
<a name="l02500"></a>02500                                 <span class="keywordflow">continue</span>;
<a name="l02501"></a>02501                         counter = 0;
<a name="l02502"></a>02502                 }
<a name="l02503"></a>02503 
<a name="l02504"></a>02504                 <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#a636d42759b82b23e7c74c1023c6e5862">ptlrpc_at_check</a>(svcpt))
<a name="l02505"></a>02505                         <a class="code" href="service_8c.html#aa7ee569529c9251f8c0abed514c5c8e5">ptlrpc_at_check_timed</a>(svcpt);
<a name="l02506"></a>02506 
<a name="l02507"></a>02507                 <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#ac05b630214d88cf338cae0215329ffac" title="Returns true if there are requests available in incoming request queue for processing...">ptlrpc_server_request_pending</a>(svcpt, <span class="keyword">false</span>)) {
<a name="l02508"></a>02508                         <a class="code" href="group__lu.html#gaf86fb0a5bf6a1dadec88844694e2ad31" title="Called before entering context.">lu_context_enter</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l02509"></a>02509                         <a class="code" href="service_8c.html#a9380f0d64f1bd15f62f971bccdc810b7" title="Main incoming request handling logic.">ptlrpc_server_handle_request</a>(svcpt, thread);
<a name="l02510"></a>02510                         <a class="code" href="group__lu.html#ga85625901fefb6948280ff1e0d4778f61" title="Called after exiting from ctx.">lu_context_exit</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l02511"></a>02511                 }
<a name="l02512"></a>02512 
<a name="l02513"></a>02513                 <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#af8041c3cf09a9ac2e2f56d44e9d71d7a">ptlrpc_rqbd_pending</a>(svcpt) &amp;&amp;
<a name="l02514"></a>02514                     <a class="code" href="service_8c.html#aa3c644131d0f98fd22ad9ba28d49974c">ptlrpc_server_post_idle_rqbds</a>(svcpt) &lt; 0) {
<a name="l02515"></a>02515                         <span class="comment">/* I just failed to repost request buffers.</span>
<a name="l02516"></a>02516 <span class="comment">                         * Wait for a timeout (unless something else</span>
<a name="l02517"></a>02517 <span class="comment">                         * happens) before I try again */</span>
<a name="l02518"></a>02518                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a22eb45de0fb6b349d79bb092fb83c00a" title="timeout before re-posting reqs, in tick">scp_rqbd_timeout</a> = <a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(1) / 10;
<a name="l02519"></a>02519                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, <span class="stringliteral">&quot;Posted buffers: %d\n&quot;</span>,
<a name="l02520"></a>02520                                svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a" title="# posted request buffers for receiving">scp_nrqbds_posted</a>);
<a name="l02521"></a>02521                 }
<a name="l02522"></a>02522         }
<a name="l02523"></a>02523 
<a name="l02524"></a>02524         <a class="code" href="watchdog_8c.html#af3ddfd032179994cf0fc7a566205d884">lc_watchdog_delete</a>(thread-&gt;<a class="code" href="structptlrpc__thread.html#a03dcaad73307322e1dfe8430c7aa2049" title="put watchdog in the structure per thread b=14840">t_watchdog</a>);
<a name="l02525"></a>02525         thread-&gt;<a class="code" href="structptlrpc__thread.html#a03dcaad73307322e1dfe8430c7aa2049" title="put watchdog in the structure per thread b=14840">t_watchdog</a> = NULL;
<a name="l02526"></a>02526 
<a name="l02527"></a>02527 out_srv_fini:
<a name="l02528"></a>02528         <span class="comment">/*</span>
<a name="l02529"></a>02529 <span class="comment">         * deconstruct service specific state created by ptlrpc_start_thread()</span>
<a name="l02530"></a>02530 <span class="comment">         */</span>
<a name="l02531"></a>02531         <span class="keywordflow">if</span> (svc-&gt;<a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90" title="service operations table">srv_ops</a>.<a class="code" href="structptlrpc__service__ops.html#ae5aa4ea05c5025d162fbef6e3cd11b20" title="if non-NULL called during thread shutdown (ptlrpc_main()) to destruct state created...">so_thr_done</a> != NULL)
<a name="l02532"></a>02532                 svc-&gt;<a class="code" href="structptlrpc__service.html#ad3d4c07597667f25183cd7bc832b9f90" title="service operations table">srv_ops</a>.<a class="code" href="structptlrpc__service__ops.html#ae5aa4ea05c5025d162fbef6e3cd11b20" title="if non-NULL called during thread shutdown (ptlrpc_main()) to destruct state created...">so_thr_done</a>(thread);
<a name="l02533"></a>02533 
<a name="l02534"></a>02534         <span class="keywordflow">if</span> (env != NULL) {
<a name="l02535"></a>02535                 <a class="code" href="group__lu.html#ga1d2df80dc90294622ca45338757e2693" title="Finalize context data-structure.">lu_context_fini</a>(&amp;env-&gt;<a class="code" href="structlu__env.html#a8c3e54a599d9514dce7868eab34e411d" title="&amp;quot;Local&amp;quot; context, used to store data instead of stack.">le_ctx</a>);
<a name="l02536"></a>02536                 <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(env);
<a name="l02537"></a>02537         }
<a name="l02538"></a>02538 out:
<a name="l02539"></a>02539         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, <span class="stringliteral">&quot;service thread [ %p : %u ] %d exiting: rc %d\n&quot;</span>,
<a name="l02540"></a>02540                thread, thread-&gt;<a class="code" href="structptlrpc__thread.html#aa8c67cb27a88779527ca37106a52e095" title="service thread pid">t_pid</a>, thread-&gt;<a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a>, rc);
<a name="l02541"></a>02541 
<a name="l02542"></a>02542         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l02543"></a>02543         <span class="keywordflow">if</span> (<a class="code" href="group__net.html#ga6680441202a3c1ee5af2af17249953ca">thread_test_and_clear_flags</a>(thread, <a class="code" href="group__net.html#gga9334a5b9057f32da96db9b5c6a045d67acc1c5776026581be68cdaa44692575c8">SVC_STARTING</a>))
<a name="l02544"></a>02544                 svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a" title="# of starting threads">scp_nthrs_starting</a>--;
<a name="l02545"></a>02545 
<a name="l02546"></a>02546         <span class="keywordflow">if</span> (<a class="code" href="group__net.html#ga6680441202a3c1ee5af2af17249953ca">thread_test_and_clear_flags</a>(thread, <a class="code" href="group__net.html#gga9334a5b9057f32da96db9b5c6a045d67aa18622e2516bc2d9afa7677b9abcf5d8">SVC_RUNNING</a>)) {
<a name="l02547"></a>02547                 <span class="comment">/* must know immediately */</span>
<a name="l02548"></a>02548                 svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a>--;
<a name="l02549"></a>02549         }
<a name="l02550"></a>02550 
<a name="l02551"></a>02551         thread-&gt;<a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a> = rc;
<a name="l02552"></a>02552         <a class="code" href="group__net.html#ga8a23b28e06b7f07c966d3e1b3eb321ba">thread_add_flags</a>(thread, <a class="code" href="group__net.html#gga9334a5b9057f32da96db9b5c6a045d67a93371c0e0bea3e5fad2bce495e27208c">SVC_STOPPED</a>);
<a name="l02553"></a>02553 
<a name="l02554"></a>02554         wake_up(&amp;thread-&gt;<a class="code" href="structptlrpc__thread.html#a2659c95a8d4b9867958aec477d1f2d6b">t_ctl_waitq</a>);
<a name="l02555"></a>02555         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l02556"></a>02556 
<a name="l02557"></a>02557         <span class="keywordflow">return</span> rc;
<a name="l02558"></a>02558 }
<a name="l02559"></a>02559 
<a name="l02560"></a><a class="code" href="service_8c.html#a2f5691160ea879ec21a77c501e649740">02560</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#a2f5691160ea879ec21a77c501e649740">hrt_dont_sleep</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a> *hrt,
<a name="l02561"></a>02561                           <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *replies)
<a name="l02562"></a>02562 {
<a name="l02563"></a>02563         <span class="keywordtype">int</span> result;
<a name="l02564"></a>02564 
<a name="l02565"></a>02565         spin_lock(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a5ef8fc11622cd55e87511784bfb57399">hrt_lock</a>);
<a name="l02566"></a>02566 
<a name="l02567"></a>02567         <a class="code" href="list_8h.html#a948b15519bb72e3d42f3e56975580d30" title="Join two lists and reinitialise the emptied list.">list_splice_init</a>(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#ab609ff12f3d8519d89938f225f785bd6">hrt_queue</a>, replies);
<a name="l02568"></a>02568         result = <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#afc4858378d71dde6bd6ed2414c174dc8">hr_stopping</a> || !<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(replies);
<a name="l02569"></a>02569 
<a name="l02570"></a>02570         spin_unlock(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a5ef8fc11622cd55e87511784bfb57399">hrt_lock</a>);
<a name="l02571"></a>02571         <span class="keywordflow">return</span> result;
<a name="l02572"></a>02572 }
<a name="l02573"></a>02573 
<a name="l02578"></a><a class="code" href="service_8c.html#ae480dac18fde296385661bf5d397128d">02578</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#ae480dac18fde296385661bf5d397128d" title="Main body of &amp;quot;handle reply&amp;quot; function.">ptlrpc_hr_main</a>(<span class="keywordtype">void</span> *arg)
<a name="l02579"></a>02579 {
<a name="l02580"></a>02580         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a>         *hrt = (<span class="keyword">struct </span><a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a> *)arg;
<a name="l02581"></a>02581         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a>      *hrp = hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#aa0d61ec5b7897cd4e306e70c7ee4ca15">hrt_partition</a>;
<a name="l02582"></a>02582         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                replies;
<a name="l02583"></a>02583         <span class="keywordtype">char</span>                            threadname[20];
<a name="l02584"></a>02584         <span class="keywordtype">int</span>                             rc;
<a name="l02585"></a>02585 
<a name="l02586"></a>02586         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;replies);
<a name="l02587"></a>02587         snprintf(threadname, <span class="keyword">sizeof</span>(threadname), <span class="stringliteral">&quot;ptlrpc_hr%02d_%03d&quot;</span>,
<a name="l02588"></a>02588                  hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a5efa12e87b543d269df0adad94dfd674">hrp_cpt</a>, hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a6e6c22649739a4ce26ccc8c949d4a44f">hrt_id</a>);
<a name="l02589"></a>02589         unshare_fs_struct();
<a name="l02590"></a>02590 
<a name="l02591"></a>02591         rc = <a class="code" href="libcfs__cpu_8h.html#a5640d52431f8a9f49f0ca6c93c6e4d10" title="bind current thread on a CPU-partition cpt of cptab ">cfs_cpt_bind</a>(<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">hr_cpt_table</a>, hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a5efa12e87b543d269df0adad94dfd674">hrp_cpt</a>);
<a name="l02592"></a>02592         <span class="keywordflow">if</span> (rc != 0) {
<a name="l02593"></a>02593                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;Failed to bind %s on CPT %d of CPT table %p: rc = %d\n&quot;</span>,
<a name="l02594"></a>02594                       threadname, hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a5efa12e87b543d269df0adad94dfd674">hrp_cpt</a>, <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">hr_cpt_table</a>, rc);
<a name="l02595"></a>02595         }
<a name="l02596"></a>02596 
<a name="l02597"></a>02597         atomic_inc(&amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#abed863bf03fdd63df278d6507b7877d7">hrp_nstarted</a>);
<a name="l02598"></a>02598         wake_up(&amp;<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a3a547a8ea02708f7ac764ce8a5170b43" title="controller sleep waitq">hr_waitq</a>);
<a name="l02599"></a>02599 
<a name="l02600"></a>02600         <span class="keywordflow">while</span> (!<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#afc4858378d71dde6bd6ed2414c174dc8">hr_stopping</a>) {
<a name="l02601"></a>02601                 <a class="code" href="group__lib.html#ga6070101353394203e1505e9bb2e32413">l_wait_condition</a>(hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a6730eb323b734b3bf6c7edb5e628a1d0">hrt_waitq</a>, <a class="code" href="service_8c.html#a2f5691160ea879ec21a77c501e649740">hrt_dont_sleep</a>(hrt, &amp;replies));
<a name="l02602"></a>02602 
<a name="l02603"></a>02603                 <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;replies)) {
<a name="l02604"></a>02604                         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a> *rs;
<a name="l02605"></a>02605 
<a name="l02606"></a>02606                         rs = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(replies.<a class="code" href="structlist__head.html#aaa0eabda8877e1d6de73a33f223ad004">prev</a>,
<a name="l02607"></a>02607                                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>,
<a name="l02608"></a>02608                                         <a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>);
<a name="l02609"></a>02609                         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>);
<a name="l02610"></a>02610                         <a class="code" href="service_8c.html#a028888de363f84cfcc617068e00c9f78" title="An internal function to process a single reply state object.">ptlrpc_handle_rs</a>(rs);
<a name="l02611"></a>02611                 }
<a name="l02612"></a>02612         }
<a name="l02613"></a>02613 
<a name="l02614"></a>02614         atomic_inc(&amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a8bd5e537e7a47254e03d1a6de0ac7dff">hrp_nstopped</a>);
<a name="l02615"></a>02615         wake_up(&amp;<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a3a547a8ea02708f7ac764ce8a5170b43" title="controller sleep waitq">hr_waitq</a>);
<a name="l02616"></a>02616 
<a name="l02617"></a>02617         <span class="keywordflow">return</span> 0;
<a name="l02618"></a>02618 }
<a name="l02619"></a>02619 
<a name="l02620"></a><a class="code" href="service_8c.html#aaeadc494869c167148325113344afdeb">02620</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#aaeadc494869c167148325113344afdeb">ptlrpc_stop_hr_threads</a>(<span class="keywordtype">void</span>)
<a name="l02621"></a>02621 {
<a name="l02622"></a>02622         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a>      *hrp;
<a name="l02623"></a>02623         <span class="keywordtype">int</span>                             i;
<a name="l02624"></a>02624         <span class="keywordtype">int</span>                             j;
<a name="l02625"></a>02625 
<a name="l02626"></a>02626         <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#afc4858378d71dde6bd6ed2414c174dc8">hr_stopping</a> = 1;
<a name="l02627"></a>02627 
<a name="l02628"></a>02628         <a class="code" href="libcfs__cpu_8h.html#a4de64b9464c23beadb6c47fbceb63929">cfs_percpt_for_each</a>(hrp, i, <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a>) {
<a name="l02629"></a>02629                 <span class="keywordflow">if</span> (hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a> == NULL)
<a name="l02630"></a>02630                         <span class="keywordflow">continue</span>; <span class="comment">/* uninitialized */</span>
<a name="l02631"></a>02631                 <span class="keywordflow">for</span> (j = 0; j &lt; hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a>; j++)
<a name="l02632"></a>02632                         wake_up_all(&amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a>[j].<a class="code" href="structptlrpc__hr__thread.html#a6730eb323b734b3bf6c7edb5e628a1d0">hrt_waitq</a>);
<a name="l02633"></a>02633         }
<a name="l02634"></a>02634 
<a name="l02635"></a>02635         <a class="code" href="libcfs__cpu_8h.html#a4de64b9464c23beadb6c47fbceb63929">cfs_percpt_for_each</a>(hrp, i, <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a>) {
<a name="l02636"></a>02636                 <span class="keywordflow">if</span> (hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a> == NULL)
<a name="l02637"></a>02637                         <span class="keywordflow">continue</span>; <span class="comment">/* uninitialized */</span>
<a name="l02638"></a>02638                 wait_event(<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a3a547a8ea02708f7ac764ce8a5170b43" title="controller sleep waitq">hr_waitq</a>,
<a name="l02639"></a>02639                                atomic_read(&amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a8bd5e537e7a47254e03d1a6de0ac7dff">hrp_nstopped</a>) ==
<a name="l02640"></a>02640                                atomic_read(&amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#abed863bf03fdd63df278d6507b7877d7">hrp_nstarted</a>));
<a name="l02641"></a>02641         }
<a name="l02642"></a>02642 }
<a name="l02643"></a>02643 
<a name="l02644"></a><a class="code" href="service_8c.html#a3605ffc33362009878bd0b077a1f577d">02644</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#a3605ffc33362009878bd0b077a1f577d">ptlrpc_start_hr_threads</a>(<span class="keywordtype">void</span>)
<a name="l02645"></a>02645 {
<a name="l02646"></a>02646         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a>      *hrp;
<a name="l02647"></a>02647         <span class="keywordtype">int</span>                             i;
<a name="l02648"></a>02648         <span class="keywordtype">int</span>                             j;
<a name="l02649"></a>02649         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02650"></a>02650 
<a name="l02651"></a>02651         <a class="code" href="libcfs__cpu_8h.html#a4de64b9464c23beadb6c47fbceb63929">cfs_percpt_for_each</a>(hrp, i, <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a>) {
<a name="l02652"></a>02652                 <span class="keywordtype">int</span>     rc = 0;
<a name="l02653"></a>02653 
<a name="l02654"></a>02654                 <span class="keywordflow">for</span> (j = 0; j &lt; hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a>; j++) {
<a name="l02655"></a>02655                         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a> *hrt = &amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a>[j];
<a name="l02656"></a>02656                         <span class="keyword">struct </span>task_struct *task;
<a name="l02657"></a>02657 
<a name="l02658"></a>02658                         task = kthread_run(<a class="code" href="service_8c.html#ae480dac18fde296385661bf5d397128d" title="Main body of &amp;quot;handle reply&amp;quot; function.">ptlrpc_hr_main</a>,
<a name="l02659"></a>02659                                            &amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a>[j],
<a name="l02660"></a>02660                                            <span class="stringliteral">&quot;ptlrpc_hr%02d_%03d&quot;</span>,
<a name="l02661"></a>02661                                            hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a5efa12e87b543d269df0adad94dfd674">hrp_cpt</a>,
<a name="l02662"></a>02662                                            hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a6e6c22649739a4ce26ccc8c949d4a44f">hrt_id</a>);
<a name="l02663"></a>02663                         <span class="keywordflow">if</span> (IS_ERR(task)) {
<a name="l02664"></a>02664                                 rc = PTR_ERR(task);
<a name="l02665"></a>02665                                 <span class="keywordflow">break</span>;
<a name="l02666"></a>02666                         }
<a name="l02667"></a>02667                 }
<a name="l02668"></a>02668 
<a name="l02669"></a>02669                 wait_event(<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a3a547a8ea02708f7ac764ce8a5170b43" title="controller sleep waitq">hr_waitq</a>,
<a name="l02670"></a>02670                            atomic_read(&amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#abed863bf03fdd63df278d6507b7877d7">hrp_nstarted</a>) == j);
<a name="l02671"></a>02671 
<a name="l02672"></a>02672                 <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l02673"></a>02673                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;cannot start reply handler thread %d:%d: &quot;</span>
<a name="l02674"></a>02674                                <span class="stringliteral">&quot;rc = %d\n&quot;</span>, i, j, rc);
<a name="l02675"></a>02675                         <a class="code" href="service_8c.html#aaeadc494869c167148325113344afdeb">ptlrpc_stop_hr_threads</a>();
<a name="l02676"></a>02676                         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l02677"></a>02677                 }
<a name="l02678"></a>02678         }
<a name="l02679"></a>02679 
<a name="l02680"></a>02680         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l02681"></a>02681 }
<a name="l02682"></a>02682 
<a name="l02683"></a><a class="code" href="service_8c.html#a62db31ec83e712c6dfd032092407be6b">02683</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#a62db31ec83e712c6dfd032092407be6b">ptlrpc_svcpt_stop_threads</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02684"></a>02684 {
<a name="l02685"></a>02685         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>      lwi = { 0 };
<a name="l02686"></a>02686         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>    *<a class="code" href="obd_8c.html#a20057145635eb007e0621c11bc2d7176">thread</a>;
<a name="l02687"></a>02687         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        zombie;
<a name="l02688"></a>02688 
<a name="l02689"></a>02689         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02690"></a>02690 
<a name="l02691"></a>02691         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;Stopping threads for service %s\n&quot;</span>,
<a name="l02692"></a>02692                svcpt-&gt;scp_service-&gt;srv_name);
<a name="l02693"></a>02693 
<a name="l02694"></a>02694         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;zombie);
<a name="l02695"></a>02695         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l02696"></a>02696         <span class="comment">/* let the thread know that we would like it to stop asap */</span>
<a name="l02697"></a>02697         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(thread, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a658b2ed23da83f38e3acbe91191412e0" title="service threads list">scp_threads</a>, t_link) {
<a name="l02698"></a>02698                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;Stopping thread %s #%u\n&quot;</span>,
<a name="l02699"></a>02699                        svcpt-&gt;scp_service-&gt;srv_thread_name, thread-&gt;<a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a>);
<a name="l02700"></a>02700                 <a class="code" href="group__net.html#ga8a23b28e06b7f07c966d3e1b3eb321ba">thread_add_flags</a>(thread, <a class="code" href="group__net.html#gga9334a5b9057f32da96db9b5c6a045d67a5ebda0e5982da48001134dbe2af8380c">SVC_STOPPING</a>);
<a name="l02701"></a>02701         }
<a name="l02702"></a>02702 
<a name="l02703"></a>02703         wake_up_all(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aea613ac08a7dc84e671b4a260eed2765" title="all threads sleep on this.">scp_waitq</a>);
<a name="l02704"></a>02704 
<a name="l02705"></a>02705         <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a658b2ed23da83f38e3acbe91191412e0" title="service threads list">scp_threads</a>)) {
<a name="l02706"></a>02706                 thread = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a658b2ed23da83f38e3acbe91191412e0" title="service threads list">scp_threads</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l02707"></a>02707                                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>, t_link);
<a name="l02708"></a>02708                 <span class="keywordflow">if</span> (<a class="code" href="group__net.html#gac107250eb869d663ca69b6d55e82f88a">thread_is_stopped</a>(thread)) {
<a name="l02709"></a>02709                         <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;thread-&gt;<a class="code" href="structptlrpc__thread.html#aae3239900e0e33d2fc4bd21382712c25" title="List of active threads in svc-&amp;gt;srv_threads.">t_link</a>);
<a name="l02710"></a>02710                         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;thread-&gt;<a class="code" href="structptlrpc__thread.html#aae3239900e0e33d2fc4bd21382712c25" title="List of active threads in svc-&amp;gt;srv_threads.">t_link</a>, &amp;zombie);
<a name="l02711"></a>02711                         <span class="keywordflow">continue</span>;
<a name="l02712"></a>02712                 }
<a name="l02713"></a>02713                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l02714"></a>02714 
<a name="l02715"></a>02715                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;waiting for stopping-thread %s #%u\n&quot;</span>,
<a name="l02716"></a>02716                        svcpt-&gt;scp_service-&gt;srv_thread_name, thread-&gt;<a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a>);
<a name="l02717"></a>02717                 <a class="code" href="group__lib.html#ga277da3a4d12da2eb0be28a20ba56d900">l_wait_event</a>(thread-&gt;<a class="code" href="structptlrpc__thread.html#a2659c95a8d4b9867958aec477d1f2d6b">t_ctl_waitq</a>,
<a name="l02718"></a>02718                              <a class="code" href="group__net.html#gac107250eb869d663ca69b6d55e82f88a">thread_is_stopped</a>(thread), &amp;lwi);
<a name="l02719"></a>02719 
<a name="l02720"></a>02720                 spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l02721"></a>02721         }
<a name="l02722"></a>02722 
<a name="l02723"></a>02723         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l02724"></a>02724 
<a name="l02725"></a>02725         <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;zombie)) {
<a name="l02726"></a>02726                 thread = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(zombie.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l02727"></a>02727                                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>, t_link);
<a name="l02728"></a>02728                 <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;thread-&gt;<a class="code" href="structptlrpc__thread.html#aae3239900e0e33d2fc4bd21382712c25" title="List of active threads in svc-&amp;gt;srv_threads.">t_link</a>);
<a name="l02729"></a>02729                 <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(thread);
<a name="l02730"></a>02730         }
<a name="l02731"></a>02731         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l02732"></a>02732 }
<a name="l02733"></a>02733 
<a name="l02737"></a><a class="code" href="group__net.html#ga59db7fb30a02fd79e28791330f99fb3c">02737</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga59db7fb30a02fd79e28791330f99fb3c" title="Stops all threads of a particular service svc.">ptlrpc_stop_all_threads</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l02738"></a>02738 {
<a name="l02739"></a>02739         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt;
<a name="l02740"></a>02740         <span class="keywordtype">int</span>                        i;
<a name="l02741"></a>02741         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02742"></a>02742 
<a name="l02743"></a>02743         <a class="code" href="group__net.html#gadfc88ea5f31c558c5e23cd0a999bd36d">ptlrpc_service_for_each_part</a>(svcpt, i, svc) {
<a name="l02744"></a>02744                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service != NULL)
<a name="l02745"></a>02745                         <a class="code" href="service_8c.html#a62db31ec83e712c6dfd032092407be6b">ptlrpc_svcpt_stop_threads</a>(svcpt);
<a name="l02746"></a>02746         }
<a name="l02747"></a>02747 
<a name="l02748"></a>02748         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l02749"></a>02749 }
<a name="l02750"></a>02750 
<a name="l02751"></a><a class="code" href="group__net.html#gae98dcdbb3ab34d8e067f6caf336c9d31">02751</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#gae98dcdbb3ab34d8e067f6caf336c9d31">ptlrpc_start_threads</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l02752"></a>02752 {
<a name="l02753"></a>02753         <span class="keywordtype">int</span>     rc = 0;
<a name="l02754"></a>02754         <span class="keywordtype">int</span>     i;
<a name="l02755"></a>02755         <span class="keywordtype">int</span>     j;
<a name="l02756"></a>02756         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02757"></a>02757 
<a name="l02758"></a>02758         <span class="comment">/* We require 2 threads min, see note in ptlrpc_server_handle_request */</span>
<a name="l02759"></a>02759         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#adcfb71b3b7e40714db19751ebf3889ad" title="threads # should be created for each partition on initializing">srv_nthrs_cpt_init</a> &gt;= <a class="code" href="group__net.html#gafe956408171741e4f2fa929087b87a26">PTLRPC_NTHRS_INIT</a>);
<a name="l02760"></a>02760 
<a name="l02761"></a>02761         <span class="keywordflow">for</span> (i = 0; i &lt; svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>; i++) {
<a name="l02762"></a>02762                 <span class="keywordflow">for</span> (j = 0; j &lt; svc-&gt;<a class="code" href="structptlrpc__service.html#adcfb71b3b7e40714db19751ebf3889ad" title="threads # should be created for each partition on initializing">srv_nthrs_cpt_init</a>; j++) {
<a name="l02763"></a>02763                         rc = <a class="code" href="ptlrpc__internal_8h.html#ae010a629f5f836492d7726dcf2692a0e">ptlrpc_start_thread</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a7e35faf6ba1087f8f57b57fd8ef98bb8" title="partition data for ptlrpc service">srv_parts</a>[i], 1);
<a name="l02764"></a>02764                         <span class="keywordflow">if</span> (rc == 0)
<a name="l02765"></a>02765                                 <span class="keywordflow">continue</span>;
<a name="l02766"></a>02766 
<a name="l02767"></a>02767                         <span class="keywordflow">if</span> (rc != -EMFILE)
<a name="l02768"></a>02768                                 <span class="keywordflow">goto</span> failed;
<a name="l02769"></a>02769                         <span class="comment">/* We have enough threads, don&apos;t start more. b=15759 */</span>
<a name="l02770"></a>02770                         <span class="keywordflow">break</span>;
<a name="l02771"></a>02771                 }
<a name="l02772"></a>02772         }
<a name="l02773"></a>02773 
<a name="l02774"></a>02774         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l02775"></a>02775  failed:
<a name="l02776"></a>02776         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;cannot start %s thread #%d_%d: rc %d\n&quot;</span>,
<a name="l02777"></a>02777                svc-&gt;<a class="code" href="structptlrpc__service.html#a3618e53f527140ea9c7861f64565b321" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_thread_name</a>, i, j, rc);
<a name="l02778"></a>02778         <a class="code" href="group__net.html#ga59db7fb30a02fd79e28791330f99fb3c" title="Stops all threads of a particular service svc.">ptlrpc_stop_all_threads</a>(svc);
<a name="l02779"></a>02779         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l02780"></a>02780 }
<a name="l02781"></a>02781 
<a name="l02782"></a><a class="code" href="service_8c.html#ae010a629f5f836492d7726dcf2692a0e">02782</a> <span class="keywordtype">int</span> <a class="code" href="ptlrpc__internal_8h.html#ae010a629f5f836492d7726dcf2692a0e">ptlrpc_start_thread</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt, <span class="keywordtype">int</span> wait)
<a name="l02783"></a>02783 {
<a name="l02784"></a>02784         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>      lwi = { 0 };
<a name="l02785"></a>02785         <span class="keyword">struct </span><a class="code" href="structptlrpc__thread.html" title="Definition of server service thread structure.">ptlrpc_thread</a>    *<a class="code" href="obd_8c.html#a20057145635eb007e0621c11bc2d7176">thread</a>;
<a name="l02786"></a>02786         <span class="keyword">struct </span><a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>   *svc;
<a name="l02787"></a>02787         <span class="keyword">struct </span>task_struct      *task;
<a name="l02788"></a>02788         <span class="keywordtype">int</span>                     rc;
<a name="l02789"></a>02789         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02790"></a>02790 
<a name="l02791"></a>02791         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svcpt != NULL);
<a name="l02792"></a>02792 
<a name="l02793"></a>02793         svc = svcpt-&gt;scp_service;
<a name="l02794"></a>02794 
<a name="l02795"></a>02795         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, <span class="stringliteral">&quot;%s[%d] started %d min %d max %d\n&quot;</span>,
<a name="l02796"></a>02796                svc-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a>,
<a name="l02797"></a>02797                svc-&gt;<a class="code" href="structptlrpc__service.html#adcfb71b3b7e40714db19751ebf3889ad" title="threads # should be created for each partition on initializing">srv_nthrs_cpt_init</a>, svc-&gt;<a class="code" href="structptlrpc__service.html#ab1eb42fd85f14f4a6bccd9025ed5e101" title="limit of threads number for each partition">srv_nthrs_cpt_limit</a>);
<a name="l02798"></a>02798 
<a name="l02799"></a>02799  again:
<a name="l02800"></a>02800         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a356fa84033571129333ab81646a283df" title="under unregister_service">srv_is_stopping</a>))
<a name="l02801"></a>02801                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-ESRCH);
<a name="l02802"></a>02802 
<a name="l02803"></a>02803         <span class="keywordflow">if</span> (!<a class="code" href="service_8c.html#a4430e2147c91e0e0a9d599b81203221e" title="allowed to create more threads user can call it w/o any lock but need to hold ptlrpc_service_part::s...">ptlrpc_threads_increasable</a>(svcpt) ||
<a name="l02804"></a>02804             (<a class="code" href="obd__support_8h.html#a1a625df67e59932bc7ef6f87a8548cda">OBD_FAIL_CHECK</a>(<a class="code" href="obd__support_8h.html#a332d96b7133dc6e81e5713f764f299e4">OBD_FAIL_TGT_TOOMANY_THREADS</a>) &amp;&amp;
<a name="l02805"></a>02805              svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a281b166ae15b1ba09ae338866750ba77" title="# running threads">scp_nthrs_running</a> == svc-&gt;<a class="code" href="structptlrpc__service.html#adcfb71b3b7e40714db19751ebf3889ad" title="threads # should be created for each partition on initializing">srv_nthrs_cpt_init</a> - 1))
<a name="l02806"></a>02806                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-EMFILE);
<a name="l02807"></a>02807 
<a name="l02808"></a>02808         <a class="code" href="obd__support_8h.html#a3edaf39d38f2af2b6fbb08a9a3224ffe">OBD_CPT_ALLOC_PTR</a>(thread, svc-&gt;<a class="code" href="structptlrpc__service.html#ab2ba13aa9c2726a4fdc7b8c9f313d189" title="CPT table this service is running over.">srv_cptable</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a>);
<a name="l02809"></a>02809         <span class="keywordflow">if</span> (thread == NULL)
<a name="l02810"></a>02810                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-ENOMEM);
<a name="l02811"></a>02811         init_waitqueue_head(&amp;thread-&gt;<a class="code" href="structptlrpc__thread.html#a2659c95a8d4b9867958aec477d1f2d6b">t_ctl_waitq</a>);
<a name="l02812"></a>02812 
<a name="l02813"></a>02813         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l02814"></a>02814         <span class="keywordflow">if</span> (!<a class="code" href="service_8c.html#a4430e2147c91e0e0a9d599b81203221e" title="allowed to create more threads user can call it w/o any lock but need to hold ptlrpc_service_part::s...">ptlrpc_threads_increasable</a>(svcpt)) {
<a name="l02815"></a>02815                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l02816"></a>02816                 <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(thread);
<a name="l02817"></a>02817                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-EMFILE);
<a name="l02818"></a>02818         }
<a name="l02819"></a>02819 
<a name="l02820"></a>02820         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a" title="# of starting threads">scp_nthrs_starting</a> != 0) {
<a name="l02821"></a>02821                 <span class="comment">/* serialize starting because some modules (obdfilter)</span>
<a name="l02822"></a>02822 <span class="comment">                 * might require unique and contiguous t_id */</span>
<a name="l02823"></a>02823                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a" title="# of starting threads">scp_nthrs_starting</a> == 1);
<a name="l02824"></a>02824                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l02825"></a>02825                 <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(thread);
<a name="l02826"></a>02826                 <span class="keywordflow">if</span> (wait) {
<a name="l02827"></a>02827                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;Waiting for creating thread %s #%d\n&quot;</span>,
<a name="l02828"></a>02828                                svc-&gt;<a class="code" href="structptlrpc__service.html#a3618e53f527140ea9c7861f64565b321" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_thread_name</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af6581a250bb165eb31291b5daf4a422e" title="always increasing number">scp_thr_nextid</a>);
<a name="l02829"></a>02829                         schedule();
<a name="l02830"></a>02830                         <span class="keywordflow">goto</span> again;
<a name="l02831"></a>02831                 }
<a name="l02832"></a>02832 
<a name="l02833"></a>02833                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a61818a4c2cf85e96d77e6e46ca4ea853">D_INFO</a>, <span class="stringliteral">&quot;Creating thread %s #%d race, retry later\n&quot;</span>,
<a name="l02834"></a>02834                        svc-&gt;<a class="code" href="structptlrpc__service.html#a3618e53f527140ea9c7861f64565b321" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_thread_name</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af6581a250bb165eb31291b5daf4a422e" title="always increasing number">scp_thr_nextid</a>);
<a name="l02835"></a>02835                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-EAGAIN);
<a name="l02836"></a>02836         }
<a name="l02837"></a>02837 
<a name="l02838"></a>02838         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a" title="# of starting threads">scp_nthrs_starting</a>++;
<a name="l02839"></a>02839         thread-&gt;<a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a> = svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#af6581a250bb165eb31291b5daf4a422e" title="always increasing number">scp_thr_nextid</a>++;
<a name="l02840"></a>02840         <a class="code" href="group__net.html#ga8a23b28e06b7f07c966d3e1b3eb321ba">thread_add_flags</a>(thread, <a class="code" href="group__net.html#gga9334a5b9057f32da96db9b5c6a045d67acc1c5776026581be68cdaa44692575c8">SVC_STARTING</a>);
<a name="l02841"></a>02841         thread-&gt;<a class="code" href="structptlrpc__thread.html#af71d131dfdec9144aa2eac252e1e49e4" title="the svc this thread belonged to b=18582">t_svcpt</a> = svcpt;
<a name="l02842"></a>02842 
<a name="l02843"></a>02843         <a class="code" href="list_8h.html#a0373c4b3c8ce51a451a569ad978b32e1" title="Insert an entry at the start of a list.">list_add</a>(&amp;thread-&gt;<a class="code" href="structptlrpc__thread.html#aae3239900e0e33d2fc4bd21382712c25" title="List of active threads in svc-&amp;gt;srv_threads.">t_link</a>, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a658b2ed23da83f38e3acbe91191412e0" title="service threads list">scp_threads</a>);
<a name="l02844"></a>02844         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l02845"></a>02845 
<a name="l02846"></a>02846         <span class="keywordflow">if</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a> &gt;= 0) {
<a name="l02847"></a>02847                 snprintf(thread-&gt;<a class="code" href="structptlrpc__thread.html#adf5b750656843ad30ddbef591081dbc8">t_name</a>, <a class="code" href="group__net.html#gacc35cc21ab702063983586056094d6c3">PTLRPC_THR_NAME_LEN</a>, <span class="stringliteral">&quot;%s%02d_%03d&quot;</span>,
<a name="l02848"></a>02848                          svc-&gt;<a class="code" href="structptlrpc__service.html#a3618e53f527140ea9c7861f64565b321" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_thread_name</a>, svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a616b2db3286d5fe98329a0322b348faf">scp_cpt</a>, thread-&gt;<a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a>);
<a name="l02849"></a>02849         } <span class="keywordflow">else</span> {
<a name="l02850"></a>02850                 snprintf(thread-&gt;<a class="code" href="structptlrpc__thread.html#adf5b750656843ad30ddbef591081dbc8">t_name</a>, <a class="code" href="group__net.html#gacc35cc21ab702063983586056094d6c3">PTLRPC_THR_NAME_LEN</a>, <span class="stringliteral">&quot;%s_%04d&quot;</span>,
<a name="l02851"></a>02851                          svc-&gt;<a class="code" href="structptlrpc__service.html#a3618e53f527140ea9c7861f64565b321" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_thread_name</a>, thread-&gt;<a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a>);
<a name="l02852"></a>02852         }
<a name="l02853"></a>02853 
<a name="l02854"></a>02854         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#aed4daa7096c3237824e93375e1473af7">D_RPCTRACE</a>, <span class="stringliteral">&quot;starting thread &apos;%s&apos;\n&quot;</span>, thread-&gt;<a class="code" href="structptlrpc__thread.html#adf5b750656843ad30ddbef591081dbc8">t_name</a>);
<a name="l02855"></a>02855         task = kthread_run(<a class="code" href="service_8c.html#aac3d1f47bc27111a611b1c116255f53c" title="Main thread body for service threads.">ptlrpc_main</a>, thread, <span class="stringliteral">&quot;%s&quot;</span>, thread-&gt;<a class="code" href="structptlrpc__thread.html#adf5b750656843ad30ddbef591081dbc8">t_name</a>);
<a name="l02856"></a>02856         <span class="keywordflow">if</span> (IS_ERR(task)) {
<a name="l02857"></a>02857                 rc = PTR_ERR(task);
<a name="l02858"></a>02858                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;cannot start thread &apos;%s&apos;: rc = %d\n&quot;</span>,
<a name="l02859"></a>02859                        thread-&gt;<a class="code" href="structptlrpc__thread.html#adf5b750656843ad30ddbef591081dbc8">t_name</a>, rc);
<a name="l02860"></a>02860                 spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l02861"></a>02861                 --svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a0eb7001f059ddeb079a5b5cc633c837a" title="# of starting threads">scp_nthrs_starting</a>;
<a name="l02862"></a>02862                 <span class="keywordflow">if</span> (<a class="code" href="group__net.html#gab9dc73a42ff1dc50fe192daad32492bf">thread_is_stopping</a>(thread)) {
<a name="l02863"></a>02863                         <span class="comment">/* this ptlrpc_thread is being hanled</span>
<a name="l02864"></a>02864 <span class="comment">                         * by ptlrpc_svcpt_stop_threads now</span>
<a name="l02865"></a>02865 <span class="comment">                         */</span>
<a name="l02866"></a>02866                         <a class="code" href="group__net.html#ga8a23b28e06b7f07c966d3e1b3eb321ba">thread_add_flags</a>(thread, <a class="code" href="group__net.html#gga9334a5b9057f32da96db9b5c6a045d67a93371c0e0bea3e5fad2bce495e27208c">SVC_STOPPED</a>);
<a name="l02867"></a>02867                         wake_up(&amp;thread-&gt;<a class="code" href="structptlrpc__thread.html#a2659c95a8d4b9867958aec477d1f2d6b">t_ctl_waitq</a>);
<a name="l02868"></a>02868                         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l02869"></a>02869                 } <span class="keywordflow">else</span> {
<a name="l02870"></a>02870                         <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;thread-&gt;<a class="code" href="structptlrpc__thread.html#aae3239900e0e33d2fc4bd21382712c25" title="List of active threads in svc-&amp;gt;srv_threads.">t_link</a>);
<a name="l02871"></a>02871                         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l02872"></a>02872                         <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(thread);
<a name="l02873"></a>02873                 }
<a name="l02874"></a>02874                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l02875"></a>02875         }
<a name="l02876"></a>02876 
<a name="l02877"></a>02877         <span class="keywordflow">if</span> (!wait)
<a name="l02878"></a>02878                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l02879"></a>02879 
<a name="l02880"></a>02880         <a class="code" href="group__lib.html#ga277da3a4d12da2eb0be28a20ba56d900">l_wait_event</a>(thread-&gt;<a class="code" href="structptlrpc__thread.html#a2659c95a8d4b9867958aec477d1f2d6b">t_ctl_waitq</a>,
<a name="l02881"></a>02881                      <a class="code" href="group__net.html#gaffc015271d06f10519beec5a816506dc">thread_is_running</a>(thread) || <a class="code" href="group__net.html#gac107250eb869d663ca69b6d55e82f88a">thread_is_stopped</a>(thread),
<a name="l02882"></a>02882                      &amp;lwi);
<a name="l02883"></a>02883 
<a name="l02884"></a>02884         rc = <a class="code" href="group__net.html#gac107250eb869d663ca69b6d55e82f88a">thread_is_stopped</a>(thread) ? thread-&gt;<a class="code" href="structptlrpc__thread.html#a6717ba27915fe4b8d7a2595c0883d894" title="service thread index, from ptlrpc_start_threads">t_id</a> : 0;
<a name="l02885"></a>02885         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l02886"></a>02886 }
<a name="l02887"></a>02887 
<a name="l02888"></a><a class="code" href="group__net.html#ga47eab7558ff3a05ad0bd51901e737849">02888</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga47eab7558ff3a05ad0bd51901e737849">ptlrpc_hr_init</a>(<span class="keywordtype">void</span>)
<a name="l02889"></a>02889 {
<a name="l02890"></a>02890         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a>      *hrp;
<a name="l02891"></a>02891         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__thread.html">ptlrpc_hr_thread</a>         *hrt;
<a name="l02892"></a>02892         <span class="keywordtype">int</span>                             rc;
<a name="l02893"></a>02893         <span class="keywordtype">int</span>                             i;
<a name="l02894"></a>02894         <span class="keywordtype">int</span>                             j;
<a name="l02895"></a>02895         <span class="keywordtype">int</span>                             weight;
<a name="l02896"></a>02896         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l02897"></a>02897 
<a name="l02898"></a>02898         memset(&amp;<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>));
<a name="l02899"></a>02899         <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">hr_cpt_table</a> = <a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>;
<a name="l02900"></a>02900 
<a name="l02901"></a>02901         <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a> = <a class="code" href="libcfs__cpu_8h.html#a45c7a434b06b018cff3260e33463dbd2">cfs_percpt_alloc</a>(<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">hr_cpt_table</a>,
<a name="l02902"></a>02902                                                    <span class="keyword">sizeof</span>(*hrp));
<a name="l02903"></a>02903         <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a> == NULL)
<a name="l02904"></a>02904                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-ENOMEM);
<a name="l02905"></a>02905 
<a name="l02906"></a>02906         init_waitqueue_head(&amp;<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a3a547a8ea02708f7ac764ce8a5170b43" title="controller sleep waitq">hr_waitq</a>);
<a name="l02907"></a>02907 
<a name="l02908"></a>02908         weight = <a class="code" href="libcfs__cpu_8h.html#a2896836dbe1aa4f858ce28320b682bc8" title="return number of HTs in the same core of cpu ">cfs_cpu_ht_nsiblings</a>(0);
<a name="l02909"></a>02909 
<a name="l02910"></a>02910         <a class="code" href="libcfs__cpu_8h.html#a4de64b9464c23beadb6c47fbceb63929">cfs_percpt_for_each</a>(hrp, i, <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a>) {
<a name="l02911"></a>02911                 hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a5efa12e87b543d269df0adad94dfd674">hrp_cpt</a> = i;
<a name="l02912"></a>02912 
<a name="l02913"></a>02913                 atomic_set(&amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#abed863bf03fdd63df278d6507b7877d7">hrp_nstarted</a>, 0);
<a name="l02914"></a>02914                 atomic_set(&amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a8bd5e537e7a47254e03d1a6de0ac7dff">hrp_nstopped</a>, 0);
<a name="l02915"></a>02915 
<a name="l02916"></a>02916                 hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a> = <a class="code" href="libcfs__cpu_8h.html#a490feb884ea09b464c88c79377cb22ee" title="return number of HW cores or hypter-threadings in a CPU partition cpt ">cfs_cpt_weight</a>(<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">hr_cpt_table</a>, i);
<a name="l02917"></a>02917                 hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a> /= weight;
<a name="l02918"></a>02918 
<a name="l02919"></a>02919                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a> &gt; 0);
<a name="l02920"></a>02920                 <a class="code" href="obd__support_8h.html#ad8b4f0ae380c3011bdfb663dbb37d01d">OBD_CPT_ALLOC</a>(hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a>, <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a2bab17a66ebc77139fac5467a07a5785">hr_cpt_table</a>, i,
<a name="l02921"></a>02921                               hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a> * <span class="keyword">sizeof</span>(*hrt));
<a name="l02922"></a>02922                 <span class="keywordflow">if</span> (hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a> == NULL)
<a name="l02923"></a>02923                         <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, rc = -ENOMEM);
<a name="l02924"></a>02924 
<a name="l02925"></a>02925                 <span class="keywordflow">for</span> (j = 0; j &lt; hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a>; j++) {
<a name="l02926"></a>02926                         hrt = &amp;hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a>[j];
<a name="l02927"></a>02927 
<a name="l02928"></a>02928                         hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a6e6c22649739a4ce26ccc8c949d4a44f">hrt_id</a> = j;
<a name="l02929"></a>02929                         hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#aa0d61ec5b7897cd4e306e70c7ee4ca15">hrt_partition</a> = hrp;
<a name="l02930"></a>02930                         init_waitqueue_head(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a6730eb323b734b3bf6c7edb5e628a1d0">hrt_waitq</a>);
<a name="l02931"></a>02931                         spin_lock_init(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#a5ef8fc11622cd55e87511784bfb57399">hrt_lock</a>);
<a name="l02932"></a>02932                         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;hrt-&gt;<a class="code" href="structptlrpc__hr__thread.html#ab609ff12f3d8519d89938f225f785bd6">hrt_queue</a>);
<a name="l02933"></a>02933                 }
<a name="l02934"></a>02934         }
<a name="l02935"></a>02935 
<a name="l02936"></a>02936         rc = <a class="code" href="service_8c.html#a3605ffc33362009878bd0b077a1f577d">ptlrpc_start_hr_threads</a>();
<a name="l02937"></a>02937 out:
<a name="l02938"></a>02938         <span class="keywordflow">if</span> (rc != 0)
<a name="l02939"></a>02939                 <a class="code" href="group__net.html#ga48bcd41298dc75aed55d30b850d28c26">ptlrpc_hr_fini</a>();
<a name="l02940"></a>02940         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l02941"></a>02941 }
<a name="l02942"></a>02942 
<a name="l02943"></a><a class="code" href="group__net.html#ga48bcd41298dc75aed55d30b850d28c26">02943</a> <span class="keywordtype">void</span> <a class="code" href="group__net.html#ga48bcd41298dc75aed55d30b850d28c26">ptlrpc_hr_fini</a>(<span class="keywordtype">void</span>)
<a name="l02944"></a>02944 {
<a name="l02945"></a>02945         <span class="keyword">struct </span><a class="code" href="structptlrpc__hr__partition.html">ptlrpc_hr_partition</a>      *hrp;
<a name="l02946"></a>02946         <span class="keywordtype">int</span>                             i;
<a name="l02947"></a>02947 
<a name="l02948"></a>02948         <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a> == NULL)
<a name="l02949"></a>02949                 <span class="keywordflow">return</span>;
<a name="l02950"></a>02950 
<a name="l02951"></a>02951         <a class="code" href="service_8c.html#aaeadc494869c167148325113344afdeb">ptlrpc_stop_hr_threads</a>();
<a name="l02952"></a>02952 
<a name="l02953"></a>02953         <a class="code" href="libcfs__cpu_8h.html#a4de64b9464c23beadb6c47fbceb63929">cfs_percpt_for_each</a>(hrp, i, <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a>) {
<a name="l02954"></a>02954                 <span class="keywordflow">if</span> (hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a> != NULL) {
<a name="l02955"></a>02955                         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a>,
<a name="l02956"></a>02956                                  hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a98a321c3117d0a306a45f7fceeeb9cb1">hrp_nthrs</a> * <span class="keyword">sizeof</span>(hrp-&gt;<a class="code" href="structptlrpc__hr__partition.html#a909685aae2f798be65f2d29f0fd6a9db">hrp_thrs</a>[0]));
<a name="l02957"></a>02957                 }
<a name="l02958"></a>02958         }
<a name="l02959"></a>02959 
<a name="l02960"></a>02960         <a class="code" href="libcfs__cpu_8h.html#a37fd5c4dd7552fef5647378faedf8818">cfs_percpt_free</a>(<a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a>);
<a name="l02961"></a>02961         <a class="code" href="service_8c.html#a6750d361795df91f3863e34d25ef5072" title="reply handling service.">ptlrpc_hr</a>.<a class="code" href="structptlrpc__hr__service.html#a861921d4404076b1b8f5a2c81248285f">hr_partitions</a> = NULL;
<a name="l02962"></a>02962 }
<a name="l02963"></a>02963 
<a name="l02964"></a>02964 
<a name="l02968"></a><a class="code" href="service_8c.html#af06fb62ce2b0948a26182475c53245c7">02968</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="service_8c.html#af06fb62ce2b0948a26182475c53245c7" title="Wait until all already scheduled replies are processed.">ptlrpc_wait_replies</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l02969"></a>02969 {
<a name="l02970"></a>02970         <span class="keywordflow">while</span> (1) {
<a name="l02971"></a>02971                 <span class="keywordtype">int</span> rc;
<a name="l02972"></a>02972                 <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a> lwi = <a class="code" href="group__lib.html#ga2c8a9c91f1f21e7ff21abedc365140f9">LWI_TIMEOUT</a>(<a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(10),
<a name="l02973"></a>02973                                                      NULL, NULL);
<a name="l02974"></a>02974 
<a name="l02975"></a>02975                 rc = <a class="code" href="group__lib.html#ga277da3a4d12da2eb0be28a20ba56d900">l_wait_event</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aea613ac08a7dc84e671b4a260eed2765" title="all threads sleep on this.">scp_waitq</a>,
<a name="l02976"></a>02976                      atomic_read(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a53b120d0b76021b70f62730a7fb490fe" title="# &amp;#39;difficult&amp;#39; replies">scp_nreps_difficult</a>) == 0, &amp;lwi);
<a name="l02977"></a>02977                 <span class="keywordflow">if</span> (rc == 0)
<a name="l02978"></a>02978                         <span class="keywordflow">break</span>;
<a name="l02979"></a>02979                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;Unexpectedly long timeout %s %p\n&quot;</span>,
<a name="l02980"></a>02980                       svcpt-&gt;scp_service-&gt;srv_name, svcpt-&gt;scp_service);
<a name="l02981"></a>02981         }
<a name="l02982"></a>02982 }
<a name="l02983"></a>02983 
<a name="l02984"></a>02984 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02985"></a><a class="code" href="service_8c.html#a81a779f138575827c60f3e9e562d1e44">02985</a> <a class="code" href="service_8c.html#a81a779f138575827c60f3e9e562d1e44">ptlrpc_service_del_atimer</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l02986"></a>02986 {
<a name="l02987"></a>02987         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *svcpt;
<a name="l02988"></a>02988         <span class="keywordtype">int</span>                             i;
<a name="l02989"></a>02989 
<a name="l02990"></a>02990         <span class="comment">/* early disarm AT timer... */</span>
<a name="l02991"></a>02991         <a class="code" href="group__net.html#gadfc88ea5f31c558c5e23cd0a999bd36d">ptlrpc_service_for_each_part</a>(svcpt, i, svc) {
<a name="l02992"></a>02992                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service != NULL)
<a name="l02993"></a>02993                         <a class="code" href="libcfs__prim_8h.html#a73357d243036c731f58cf6cf50d34ad7">cfs_timer_disarm</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ac1e4c68a5aa6d83f2e5441ea05fe9d52" title="early reply timer">scp_at_timer</a>);
<a name="l02994"></a>02994         }
<a name="l02995"></a>02995 }
<a name="l02996"></a>02996 
<a name="l02997"></a>02997 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02998"></a><a class="code" href="service_8c.html#a0715e555526b5bb028ef352dc19a58a5">02998</a> <a class="code" href="service_8c.html#a0715e555526b5bb028ef352dc19a58a5">ptlrpc_service_unlink_rqbd</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l02999"></a>02999 {
<a name="l03000"></a>03000         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>        *svcpt;
<a name="l03001"></a>03001         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a> *rqbd;
<a name="l03002"></a>03002         <span class="keyword">struct </span><a class="code" href="structl__wait__info.html">l_wait_info</a>                lwi;
<a name="l03003"></a>03003         <span class="keywordtype">int</span>                               rc;
<a name="l03004"></a>03004         <span class="keywordtype">int</span>                               i;
<a name="l03005"></a>03005 
<a name="l03006"></a>03006         <span class="comment">/* All history will be culled when the next request buffer is</span>
<a name="l03007"></a>03007 <span class="comment">         * freed in ptlrpc_service_purge_all() */</span>
<a name="l03008"></a>03008         svc-&gt;<a class="code" href="structptlrpc__service.html#ab8c2b2b1eaca9032c565e830244fdfdb" title="max # request buffers in history per partition">srv_hist_nrqbds_cpt_max</a> = 0;
<a name="l03009"></a>03009 
<a name="l03010"></a>03010         rc = <a class="code" href="group__lnet__misc.html#ga8dd90e2ffad743128236983380bab6db" title="Turn off the lazy portal attribute.">LNetClearLazyPortal</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a419d843f51ff5820c8a66269be6ee86b" title="Local portal on which to receive requests.">srv_req_portal</a>);
<a name="l03011"></a>03011         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rc == 0);
<a name="l03012"></a>03012 
<a name="l03013"></a>03013         <a class="code" href="group__net.html#gadfc88ea5f31c558c5e23cd0a999bd36d">ptlrpc_service_for_each_part</a>(svcpt, i, svc) {
<a name="l03014"></a>03014                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service == NULL)
<a name="l03015"></a>03015                         <span class="keywordflow">break</span>;
<a name="l03016"></a>03016 
<a name="l03017"></a>03017                 <span class="comment">/* Unlink all the request buffers.  This forces a &apos;final&apos;</span>
<a name="l03018"></a>03018 <span class="comment">                 * event with its &apos;unlink&apos; flag set for each posted rqbd */</span>
<a name="l03019"></a>03019                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(rqbd, &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#acd3cb2ad8f3ef3e78751f83373c0e688" title="req buffers receiving">scp_rqbd_posted</a>,
<a name="l03020"></a>03020                                         rqbd_list) {
<a name="l03021"></a>03021                         rc = <a class="code" href="group__lnet__md.html#ga2a0ce03253bcaae1e35be920f6029ca9" title="Unlink the memory descriptor from any ME it may be linked to and release the internal...">LNetMDUnlink</a>(rqbd-&gt;<a class="code" href="structptlrpc__request__buffer__desc.html#a1dbe83278f677b1c4bfa121131373418" title="LNet descriptor.">rqbd_md_h</a>);
<a name="l03022"></a>03022                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(rc == 0 || rc == -ENOENT);
<a name="l03023"></a>03023                 }
<a name="l03024"></a>03024         }
<a name="l03025"></a>03025 
<a name="l03026"></a>03026         <a class="code" href="group__net.html#gadfc88ea5f31c558c5e23cd0a999bd36d">ptlrpc_service_for_each_part</a>(svcpt, i, svc) {
<a name="l03027"></a>03027                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service == NULL)
<a name="l03028"></a>03028                         <span class="keywordflow">break</span>;
<a name="l03029"></a>03029 
<a name="l03030"></a>03030                 <span class="comment">/* Wait for the network to release any buffers</span>
<a name="l03031"></a>03031 <span class="comment">                 * it&apos;s currently filling */</span>
<a name="l03032"></a>03032                 spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l03033"></a>03033                 <span class="keywordflow">while</span> (svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a" title="# posted request buffers for receiving">scp_nrqbds_posted</a> != 0) {
<a name="l03034"></a>03034                         spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l03035"></a>03035                         <span class="comment">/* Network access will complete in finite time but</span>
<a name="l03036"></a>03036 <span class="comment">                         * the HUGE timeout lets us CWARN for visibility</span>
<a name="l03037"></a>03037 <span class="comment">                         * of sluggish NALs */</span>
<a name="l03038"></a>03038                         lwi = <a class="code" href="group__lib.html#ga551c4c576557c71d5d420704bc9206b0">LWI_TIMEOUT_INTERVAL</a>(
<a name="l03039"></a>03039                                         <a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(<a class="code" href="obd__support_8h.html#ad4d281dec5c7a68249818934ba21a3ec">LONG_UNLINK</a>),
<a name="l03040"></a>03040                                         <a class="code" href="linux-time_8h.html#a025b413736cfecdc30256f4e5d3d2605">cfs_time_seconds</a>(1), NULL, NULL);
<a name="l03041"></a>03041                         rc = <a class="code" href="group__lib.html#ga277da3a4d12da2eb0be28a20ba56d900">l_wait_event</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aea613ac08a7dc84e671b4a260eed2765" title="all threads sleep on this.">scp_waitq</a>,
<a name="l03042"></a>03042                                           svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a498a960c1ab556b2cd15ff122069133a" title="# posted request buffers for receiving">scp_nrqbds_posted</a> == 0, &amp;lwi);
<a name="l03043"></a>03043                         <span class="keywordflow">if</span> (rc == -ETIMEDOUT) {
<a name="l03044"></a>03044                                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;Service %s waiting for &quot;</span>
<a name="l03045"></a>03045                                       <span class="stringliteral">&quot;request buffers\n&quot;</span>,
<a name="l03046"></a>03046                                       svcpt-&gt;scp_service-&gt;srv_name);
<a name="l03047"></a>03047                         }
<a name="l03048"></a>03048                         spin_lock(&amp;svcpt-&gt;scp_lock);
<a name="l03049"></a>03049                 }
<a name="l03050"></a>03050                 spin_unlock(&amp;svcpt-&gt;scp_lock);
<a name="l03051"></a>03051         }
<a name="l03052"></a>03052 }
<a name="l03053"></a>03053 
<a name="l03054"></a>03054 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03055"></a><a class="code" href="service_8c.html#aea01c5861feea88341d2a351ff7574c3">03055</a> <a class="code" href="service_8c.html#aea01c5861feea88341d2a351ff7574c3">ptlrpc_service_purge_all</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l03056"></a>03056 {
<a name="l03057"></a>03057         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>              *svcpt;
<a name="l03058"></a>03058         <span class="keyword">struct </span><a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a>       *rqbd;
<a name="l03059"></a>03059         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>                   *req;
<a name="l03060"></a>03060         <span class="keyword">struct </span><a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>               *rs;
<a name="l03061"></a>03061         <span class="keywordtype">int</span>                                     i;
<a name="l03062"></a>03062 
<a name="l03063"></a>03063         <a class="code" href="group__net.html#gadfc88ea5f31c558c5e23cd0a999bd36d">ptlrpc_service_for_each_part</a>(svcpt, i, svc) {
<a name="l03064"></a>03064                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service == NULL)
<a name="l03065"></a>03065                         <span class="keywordflow">break</span>;
<a name="l03066"></a>03066 
<a name="l03067"></a>03067                 spin_lock(&amp;svcpt-&gt;scp_rep_lock);
<a name="l03068"></a>03068                 <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a38155a97f15fe794ff8720e2f8bcf249" title="all the active replies">scp_rep_active</a>)) {
<a name="l03069"></a>03069                         rs = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a38155a97f15fe794ff8720e2f8bcf249" title="all the active replies">scp_rep_active</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l03070"></a>03070                                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>, <a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>);
<a name="l03071"></a>03071                         spin_lock(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l03072"></a>03072                         <a class="code" href="group__net.html#ga9ab523a4b395599275d00e72079b51f9">ptlrpc_schedule_difficult_reply</a>(rs);
<a name="l03073"></a>03073                         spin_unlock(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#a24c7229b07c8544dcd749c5726595cbe" title="A spinlock to protect the reply state flags.">rs_lock</a>);
<a name="l03074"></a>03074                 }
<a name="l03075"></a>03075                 spin_unlock(&amp;svcpt-&gt;scp_rep_lock);
<a name="l03076"></a>03076 
<a name="l03077"></a>03077                 <span class="comment">/* purge the request queue.  NB No new replies (rqbds</span>
<a name="l03078"></a>03078 <span class="comment">                 * all unlinked) and no service threads, so I&apos;m the only</span>
<a name="l03079"></a>03079 <span class="comment">                 * thread noodling the request queue now */</span>
<a name="l03080"></a>03080                 <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a54fb502a4f6c138aaa49eb9afea6e39c" title="incoming reqs">scp_req_incoming</a>)) {
<a name="l03081"></a>03081                         req = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a54fb502a4f6c138aaa49eb9afea6e39c" title="incoming reqs">scp_req_incoming</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l03082"></a>03082                                              <span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>, rq_list);
<a name="l03083"></a>03083 
<a name="l03084"></a>03084                         <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#aa9b98d9b3a3a53d97d4fdc825910c733" title="Linkage item through which this request is included into sending/delayed lists on...">rq_list</a>);
<a name="l03085"></a>03085                         svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a8283d58f626b885a04d59e22ac5b234a" title="# incoming reqs">scp_nreqs_incoming</a>--;
<a name="l03086"></a>03086                         <a class="code" href="service_8c.html#a2d71c5442a9a62c66bd99bc984d2c8d1" title="to finish a request: stop sending more early replies, and release the request.">ptlrpc_server_finish_request</a>(svcpt, req);
<a name="l03087"></a>03087                 }
<a name="l03088"></a>03088 
<a name="l03089"></a>03089                 <span class="keywordflow">while</span> (<a class="code" href="service_8c.html#ac05b630214d88cf338cae0215329ffac" title="Returns true if there are requests available in incoming request queue for processing...">ptlrpc_server_request_pending</a>(svcpt, <span class="keyword">true</span>)) {
<a name="l03090"></a>03090                         req = <a class="code" href="service_8c.html#a6974eddc8d099fb5e20dcc08d3863f35" title="Fetch a request for processing from queue of unprocessed requests.">ptlrpc_server_request_get</a>(svcpt, <span class="keyword">true</span>);
<a name="l03091"></a>03091                         <a class="code" href="service_8c.html#a82747d1c580374cfd9087a99f1c67750" title="to finish an active request: stop sending more early replies, and release the request...">ptlrpc_server_finish_active_request</a>(svcpt, req);
<a name="l03092"></a>03092                 }
<a name="l03093"></a>03093 
<a name="l03094"></a>03094                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#acd3cb2ad8f3ef3e78751f83373c0e688" title="req buffers receiving">scp_rqbd_posted</a>));
<a name="l03095"></a>03095                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a8283d58f626b885a04d59e22ac5b234a" title="# incoming reqs">scp_nreqs_incoming</a> == 0);
<a name="l03096"></a>03096                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#afa479ca58224b1f1eb30793a2ebd7e65" title="# reqs in either of the NRS heads below">scp_nreqs_active</a> == 0);
<a name="l03097"></a>03097                 <span class="comment">/* history should have been culled by</span>
<a name="l03098"></a>03098 <span class="comment">                 * ptlrpc_server_finish_request */</span>
<a name="l03099"></a>03099                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a46f749b9c04d8a939db8e29cbadadb0f" title="# request buffers in history">scp_hist_nrqbds</a> == 0);
<a name="l03100"></a>03100 
<a name="l03101"></a>03101                 <span class="comment">/* Now free all the request buffers since nothing</span>
<a name="l03102"></a>03102 <span class="comment">                 * references them any more... */</span>
<a name="l03103"></a>03103 
<a name="l03104"></a>03104                 <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>)) {
<a name="l03105"></a>03105                         rqbd = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a4861a69db14903c4e80982c48be76c8b" title="request buffers to be reposted">scp_rqbd_idle</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l03106"></a>03106                                               <span class="keyword">struct</span> <a class="code" href="structptlrpc__request__buffer__desc.html" title="Request buffer descriptor structure.">ptlrpc_request_buffer_desc</a>,
<a name="l03107"></a>03107                                               rqbd_list);
<a name="l03108"></a>03108                         <a class="code" href="service_8c.html#ab4c8313b60651ab857fe795c83b71b64">ptlrpc_free_rqbd</a>(rqbd);
<a name="l03109"></a>03109                 }
<a name="l03110"></a>03110                 <a class="code" href="service_8c.html#af06fb62ce2b0948a26182475c53245c7" title="Wait until all already scheduled replies are processed.">ptlrpc_wait_replies</a>(svcpt);
<a name="l03111"></a>03111 
<a name="l03112"></a>03112                 <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a1ba1dd17ce94daf0c4b82611d2203b77" title="List of free reply_states.">scp_rep_idle</a>)) {
<a name="l03113"></a>03113                         rs = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#a1ba1dd17ce94daf0c4b82611d2203b77" title="List of free reply_states.">scp_rep_idle</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>,
<a name="l03114"></a>03114                                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>,
<a name="l03115"></a>03115                                             <a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>);
<a name="l03116"></a>03116                         <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;rs-&gt;<a class="code" href="structptlrpc__reply__state.html#ae257df3424c4ec7aaf280aaee8a440fd" title="Linkage for list of all reply states in a system.">rs_list</a>);
<a name="l03117"></a>03117                         <a class="code" href="obd__support_8h.html#a23d443ea219d6893da5645c760e0c28a">OBD_FREE_LARGE</a>(rs, svc-&gt;<a class="code" href="structptlrpc__service.html#a6180a248a18a644e05681a35444e7f51" title="biggest reply to send">srv_max_reply_size</a>);
<a name="l03118"></a>03118                 }
<a name="l03119"></a>03119         }
<a name="l03120"></a>03120 }
<a name="l03121"></a>03121 
<a name="l03122"></a>03122 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03123"></a><a class="code" href="service_8c.html#a43254fcf67c7956fe3e38637b11086be">03123</a> <a class="code" href="service_8c.html#a43254fcf67c7956fe3e38637b11086be">ptlrpc_service_free</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l03124"></a>03124 {
<a name="l03125"></a>03125         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *svcpt;
<a name="l03126"></a>03126         <span class="keyword">struct </span><a class="code" href="structptlrpc__at__array.html">ptlrpc_at_array</a>          *array;
<a name="l03127"></a>03127         <span class="keywordtype">int</span>                             i;
<a name="l03128"></a>03128 
<a name="l03129"></a>03129         <a class="code" href="group__net.html#gadfc88ea5f31c558c5e23cd0a999bd36d">ptlrpc_service_for_each_part</a>(svcpt, i, svc) {
<a name="l03130"></a>03130                 <span class="keywordflow">if</span> (svcpt-&gt;scp_service == NULL)
<a name="l03131"></a>03131                         <span class="keywordflow">break</span>;
<a name="l03132"></a>03132 
<a name="l03133"></a>03133                 <span class="comment">/* In case somebody rearmed this in the meantime */</span>
<a name="l03134"></a>03134                 <a class="code" href="libcfs__prim_8h.html#a73357d243036c731f58cf6cf50d34ad7">cfs_timer_disarm</a>(&amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#ac1e4c68a5aa6d83f2e5441ea05fe9d52" title="early reply timer">scp_at_timer</a>);
<a name="l03135"></a>03135                 array = &amp;svcpt-&gt;<a class="code" href="structptlrpc__service__part.html#aba4a06d005f80a1ffb87884f00b68698" title="reqs waiting for replies">scp_at_array</a>;
<a name="l03136"></a>03136 
<a name="l03137"></a>03137                 <span class="keywordflow">if</span> (array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a> != NULL) {
<a name="l03138"></a>03138                         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a>,
<a name="l03139"></a>03139                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a>) * array-&gt;<a class="code" href="structptlrpc__at__array.html#a4dd5aef596a563237a418ca153585cb4" title="array to hold requests">paa_size</a>);
<a name="l03140"></a>03140                         array-&gt;<a class="code" href="structptlrpc__at__array.html#aecd8e77cedd1d76566472ba30ddb54bc">paa_reqs_array</a> = NULL;
<a name="l03141"></a>03141                 }
<a name="l03142"></a>03142 
<a name="l03143"></a>03143                 <span class="keywordflow">if</span> (array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a> != NULL) {
<a name="l03144"></a>03144                         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a>,
<a name="l03145"></a>03145                                  <span class="keyword">sizeof</span>(__u32) * array-&gt;<a class="code" href="structptlrpc__at__array.html#a4dd5aef596a563237a418ca153585cb4" title="array to hold requests">paa_size</a>);
<a name="l03146"></a>03146                         array-&gt;<a class="code" href="structptlrpc__at__array.html#a6ecae0960a0175e315894e5c36e91a59" title="the earliest deadline of reqs">paa_reqs_count</a> = NULL;
<a name="l03147"></a>03147                 }
<a name="l03148"></a>03148         }
<a name="l03149"></a>03149 
<a name="l03150"></a>03150         <a class="code" href="group__net.html#gadfc88ea5f31c558c5e23cd0a999bd36d">ptlrpc_service_for_each_part</a>(svcpt, i, svc)
<a name="l03151"></a>03151                 <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(svcpt);
<a name="l03152"></a>03152 
<a name="l03153"></a>03153         <span class="keywordflow">if</span> (svc-&gt;<a class="code" href="structptlrpc__service.html#a2c32ba2dab0f289ff0ebbd2f093fe7ba" title="CPTs array this service bound on.">srv_cpts</a> != NULL)
<a name="l03154"></a>03154                 <a class="code" href="libcfs__string_8h.html#ac2eeac94f43883683f3c21c629148f7c">cfs_expr_list_values_free</a>(svc-&gt;<a class="code" href="structptlrpc__service.html#a2c32ba2dab0f289ff0ebbd2f093fe7ba" title="CPTs array this service bound on.">srv_cpts</a>, svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>);
<a name="l03155"></a>03155 
<a name="l03156"></a>03156         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(svc, <a class="code" href="group__lustreuser.html#gad4a7496cd704df3829c87864e7dbd703">offsetof</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a>,
<a name="l03157"></a>03157                                srv_parts[svc-&gt;<a class="code" href="structptlrpc__service.html#ab349b914c5987a7e43c67b009e39b64a" title="number of CPTs this service bound on">srv_ncpts</a>]));
<a name="l03158"></a>03158 }
<a name="l03159"></a>03159 
<a name="l03160"></a><a class="code" href="group__net.html#ga2f7edc9d9d00fa395262051c0f9fc855">03160</a> <span class="keywordtype">int</span> <a class="code" href="group__net.html#ga2f7edc9d9d00fa395262051c0f9fc855">ptlrpc_unregister_service</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *<a class="code" href="o2iblnd__modparams_8c.html#a00f09e31c707a86ebc6b0cf74e934633">service</a>)
<a name="l03161"></a>03161 {
<a name="l03162"></a>03162         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l03163"></a>03163 
<a name="l03164"></a>03164         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a645bb72e3ae1cac3c21a4b507d522a92">D_NET</a>, <span class="stringliteral">&quot;%s: tearing down\n&quot;</span>, service-&gt;<a class="code" href="structptlrpc__service.html#aae4c3cd5c6362b9586c16f671076bb55" title="only statically allocated strings here; we don&amp;#39;t clean them">srv_name</a>);
<a name="l03165"></a>03165 
<a name="l03166"></a>03166         service-&gt;<a class="code" href="structptlrpc__service.html#a356fa84033571129333ab81646a283df" title="under unregister_service">srv_is_stopping</a> = 1;
<a name="l03167"></a>03167 
<a name="l03168"></a>03168         mutex_lock(&amp;<a class="code" href="ptlrpc__internal_8h.html#a9e88c117c1eccb6da9707b1f9430d4f3" title="Used to protect the ptlrpc_all_services list.">ptlrpc_all_services_mutex</a>);
<a name="l03169"></a>03169         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;service-&gt;<a class="code" href="structptlrpc__service.html#a7b76c93b05ae8b75256861ab53f5db59" title="most often accessed fields">srv_list</a>);
<a name="l03170"></a>03170         mutex_unlock(&amp;<a class="code" href="ptlrpc__internal_8h.html#a9e88c117c1eccb6da9707b1f9430d4f3" title="Used to protect the ptlrpc_all_services list.">ptlrpc_all_services_mutex</a>);
<a name="l03171"></a>03171 
<a name="l03172"></a>03172         <a class="code" href="service_8c.html#a81a779f138575827c60f3e9e562d1e44">ptlrpc_service_del_atimer</a>(service);
<a name="l03173"></a>03173         <a class="code" href="group__net.html#ga59db7fb30a02fd79e28791330f99fb3c" title="Stops all threads of a particular service svc.">ptlrpc_stop_all_threads</a>(service);
<a name="l03174"></a>03174 
<a name="l03175"></a>03175         <a class="code" href="service_8c.html#a0715e555526b5bb028ef352dc19a58a5">ptlrpc_service_unlink_rqbd</a>(service);
<a name="l03176"></a>03176         <a class="code" href="service_8c.html#aea01c5861feea88341d2a351ff7574c3">ptlrpc_service_purge_all</a>(service);
<a name="l03177"></a>03177         <a class="code" href="nrs_8c.html#addde07332222429e28ec6cb0a78ca460" title="Unregisters all policies on all service partitions of service svc.">ptlrpc_service_nrs_cleanup</a>(service);
<a name="l03178"></a>03178 
<a name="l03179"></a>03179         <a class="code" href="ptlrpc__internal_8h.html#a61b45eea1de14b46fdfb6f7748400879">ptlrpc_lprocfs_unregister_service</a>(service);
<a name="l03180"></a>03180 
<a name="l03181"></a>03181         <a class="code" href="service_8c.html#a43254fcf67c7956fe3e38637b11086be">ptlrpc_service_free</a>(service);
<a name="l03182"></a>03182 
<a name="l03183"></a>03183         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l03184"></a>03184 }
<a name="l03185"></a>03185 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga2f7edc9d9d00fa395262051c0f9fc855">ptlrpc_unregister_service</a>);
<a name="l03186"></a>03186 
<a name="l03193"></a><a class="code" href="service_8c.html#ada6b019d287e10df1411a160eb834584">03193</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="service_8c.html#ada6b019d287e10df1411a160eb834584" title="Returns 0 if the service is healthy.">ptlrpc_svcpt_health_check</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a> *svcpt)
<a name="l03194"></a>03194 {
<a name="l03195"></a>03195         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>           *request = NULL;
<a name="l03196"></a>03196         <span class="keyword">struct </span>timeval                  right_now;
<a name="l03197"></a>03197         <span class="keywordtype">long</span>                            timediff;
<a name="l03198"></a>03198 
<a name="l03199"></a>03199         do_gettimeofday(&amp;right_now);
<a name="l03200"></a>03200 
<a name="l03201"></a>03201         spin_lock(&amp;svcpt-&gt;scp_req_lock);
<a name="l03202"></a>03202         <span class="comment">/* How long has the next entry been waiting? */</span>
<a name="l03203"></a>03203         <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#ac5e70e9ac0846630ba9e4d3e1a50156b">ptlrpc_server_high_pending</a>(svcpt, <span class="keyword">true</span>))
<a name="l03204"></a>03204                 request = <a class="code" href="ptlrpc__internal_8h.html#a2b75bda47bbc05dc96217fa09e392107">ptlrpc_nrs_req_peek_nolock</a>(svcpt, <span class="keyword">true</span>);
<a name="l03205"></a>03205         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="service_8c.html#a07185adbcc9ce1e9ca17cb1a13789e00">ptlrpc_server_normal_pending</a>(svcpt, <span class="keyword">true</span>))
<a name="l03206"></a>03206                 request = <a class="code" href="ptlrpc__internal_8h.html#a2b75bda47bbc05dc96217fa09e392107">ptlrpc_nrs_req_peek_nolock</a>(svcpt, <span class="keyword">false</span>);
<a name="l03207"></a>03207 
<a name="l03208"></a>03208         <span class="keywordflow">if</span> (request == NULL) {
<a name="l03209"></a>03209                 spin_unlock(&amp;svcpt-&gt;scp_req_lock);
<a name="l03210"></a>03210                 <span class="keywordflow">return</span> 0;
<a name="l03211"></a>03211         }
<a name="l03212"></a>03212 
<a name="l03213"></a>03213         timediff = <a class="code" href="libcfs__time_8h.html#af9b4a1317e77625716e3f7c01d3f4c01">cfs_timeval_sub</a>(&amp;right_now, &amp;request-&gt;rq_arrival_time, NULL);
<a name="l03214"></a>03214         spin_unlock(&amp;svcpt-&gt;scp_req_lock);
<a name="l03215"></a>03215 
<a name="l03216"></a>03216         <span class="keywordflow">if</span> ((timediff / <a class="code" href="linux-time_8h.html#a6a146c1b2155b03eb2ffa3f4ba755034">ONE_MILLION</a>) &gt;
<a name="l03217"></a>03217             (<a class="code" href="group__export.html#ga8a5d48126ef884f74f2de78ef49ea61a">AT_OFF</a> ? <a class="code" href="obd__support_8h.html#aa0f9a3f30233340b9fe0b3a3eb300735">obd_timeout</a> * 3 / 2 : <a class="code" href="group__export.html#gad437939efbc33a157b6f386ac4a92ecb">at_max</a>)) {
<a name="l03218"></a>03218                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;%s: unhealthy - request has been waiting %lds\n&quot;</span>,
<a name="l03219"></a>03219                        svcpt-&gt;scp_service-&gt;srv_name, timediff / <a class="code" href="linux-time_8h.html#a6a146c1b2155b03eb2ffa3f4ba755034">ONE_MILLION</a>);
<a name="l03220"></a>03220                 <span class="keywordflow">return</span> -1;
<a name="l03221"></a>03221         }
<a name="l03222"></a>03222 
<a name="l03223"></a>03223         <span class="keywordflow">return</span> 0;
<a name="l03224"></a>03224 }
<a name="l03225"></a>03225 
<a name="l03226"></a>03226 <span class="keywordtype">int</span>
<a name="l03227"></a><a class="code" href="group__net.html#ga7bc966179d16fa5e27e45a95523b0386">03227</a> <a class="code" href="group__net.html#ga7bc966179d16fa5e27e45a95523b0386">ptlrpc_service_health_check</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__service.html" title="Definition of PortalRPC service.">ptlrpc_service</a> *svc)
<a name="l03228"></a>03228 {
<a name="l03229"></a>03229         <span class="keyword">struct </span><a class="code" href="structptlrpc__service__part.html" title="Definition of PortalRPC service partition data.">ptlrpc_service_part</a>      *svcpt;
<a name="l03230"></a>03230         <span class="keywordtype">int</span>                             i;
<a name="l03231"></a>03231 
<a name="l03232"></a>03232         <span class="keywordflow">if</span> (svc == NULL)
<a name="l03233"></a>03233                 <span class="keywordflow">return</span> 0;
<a name="l03234"></a>03234 
<a name="l03235"></a>03235         <a class="code" href="group__net.html#gadfc88ea5f31c558c5e23cd0a999bd36d">ptlrpc_service_for_each_part</a>(svcpt, i, svc) {
<a name="l03236"></a>03236                 <span class="keywordtype">int</span> rc = <a class="code" href="service_8c.html#ada6b019d287e10df1411a160eb834584" title="Returns 0 if the service is healthy.">ptlrpc_svcpt_health_check</a>(svcpt);
<a name="l03237"></a>03237 
<a name="l03238"></a>03238                 <span class="keywordflow">if</span> (rc != 0)
<a name="l03239"></a>03239                         <span class="keywordflow">return</span> rc;
<a name="l03240"></a>03240         }
<a name="l03241"></a>03241         <span class="keywordflow">return</span> 0;
<a name="l03242"></a>03242 }
<a name="l03243"></a>03243 EXPORT_SYMBOL(<a class="code" href="group__net.html#ga7bc966179d16fa5e27e45a95523b0386">ptlrpc_service_health_check</a>);
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:43 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
