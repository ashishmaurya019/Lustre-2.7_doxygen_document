<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ptlrpc/gss/gss_keyring.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/ptlrpc/gss/gss_keyring.c</h1><a href="gss__keyring_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2012, 2014, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lustre/ptlrpc/gss/gss_keyring.c</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Author: Eric Mei &lt;ericm@clusterfs.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> */</span>
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="gss__keyring_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">00041</a> <span class="preprocessor">#define DEBUG_SUBSYSTEM S_SEC</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/init.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;linux/slab.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;linux/dcache.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;linux/fs.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;linux/crypto.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;linux/key.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;linux/keyctl.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;linux/key-type.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;linux/mutex.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;asm/atomic.h&gt;</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;<a class="code" href="obd_8h.html">obd.h</a>&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;<a class="code" href="obd__class_8h.html">obd_class.h</a>&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;<a class="code" href="obd__support_8h.html">obd_support.h</a>&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;<a class="code" href="lustre__idl_8h.html">lustre/lustre_idl.h</a>&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;<a class="code" href="lustre__sec_8h.html">lustre_sec.h</a>&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;<a class="code" href="lustre__net_8h.html">lustre_net.h</a>&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;<a class="code" href="lustre__import_8h.html">lustre_import.h</a>&gt;</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;<a class="code" href="gss__err_8h.html">gss_err.h</a>&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;<a class="code" href="gss__internal_8h.html">gss_internal.h</a>&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;<a class="code" href="gss__api_8h.html">gss_api.h</a>&quot;</span>
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="gss__keyring_8c.html#ad4fceaf252b84c6761b2ba9e14eaf50b">00066</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> <a class="code" href="gss__keyring_8c.html#ad4fceaf252b84c6761b2ba9e14eaf50b">gss_policy_keyring</a>;
<a name="l00067"></a><a class="code" href="gss__keyring_8c.html#abf4771e7b17fb63b063a5fd7b7897efd">00067</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__ctx__ops.html">ptlrpc_ctx_ops</a> <a class="code" href="gss__keyring_8c.html#abf4771e7b17fb63b063a5fd7b7897efd">gss_keyring_ctxops</a>;
<a name="l00068"></a><a class="code" href="gss__keyring_8c.html#aa9180484e95238702168fa8193f9a797">00068</a> <span class="keyword">static</span> <span class="keyword">struct </span>key_type <a class="code" href="gss__keyring_8c.html#aa9180484e95238702168fa8193f9a797">gss_key_type</a>;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a57d118b8febccdc110895ea651efbd75">sec_install_rctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00071"></a>00071                                <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *svc_ctx);
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="comment">/*</span>
<a name="l00074"></a>00074 <span class="comment"> * the timeout is only for the case that upcall child process die abnormally.</span>
<a name="l00075"></a>00075 <span class="comment"> * in any other cases it should finally update kernel key.</span>
<a name="l00076"></a>00076 <span class="comment"> *</span>
<a name="l00077"></a>00077 <span class="comment"> * FIXME we&apos;d better to incorporate the client &amp; server side upcall timeouts</span>
<a name="l00078"></a>00078 <span class="comment"> * into the framework of Adaptive Timeouts, but we need to figure out how to</span>
<a name="l00079"></a>00079 <span class="comment"> * make sure that kernel knows the upcall processes is in-progress or died</span>
<a name="l00080"></a>00080 <span class="comment"> * unexpectedly.</span>
<a name="l00081"></a>00081 <span class="comment"> */</span>
<a name="l00082"></a><a class="code" href="gss__keyring_8c.html#afffe7859f8bdc0060956e7fe5ffb9cc2">00082</a> <span class="preprocessor">#define KEYRING_UPCALL_TIMEOUT  (obd_timeout + obd_timeout)</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00084"></a>00084 <span class="comment">/****************************************</span>
<a name="l00085"></a>00085 <span class="comment"> * internal helpers                     *</span>
<a name="l00086"></a>00086 <span class="comment"> ****************************************/</span>
<a name="l00087"></a>00087 
<a name="l00088"></a><a class="code" href="gss__keyring_8c.html#ac9cd3cfcbaa6add2f24a67c054a940fd">00088</a> <span class="preprocessor">#define DUMP_PROCESS_KEYRINGS(tsk)                                      \</span>
<a name="l00089"></a>00089 <span class="preprocessor">{                                                                       \</span>
<a name="l00090"></a>00090 <span class="preprocessor">        CWARN(&quot;DUMP PK: %s[%u,%u/%u](&lt;-%s[%u,%u/%u]): &quot;                 \</span>
<a name="l00091"></a>00091 <span class="preprocessor">              &quot;a %d, t %d, p %d, s %d, u %d, us %d, df %d\n&quot;,           \</span>
<a name="l00092"></a>00092 <span class="preprocessor">              tsk-&gt;comm, tsk-&gt;pid, tsk-&gt;uid, tsk-&gt;fsuid,                \</span>
<a name="l00093"></a>00093 <span class="preprocessor">              tsk-&gt;parent-&gt;comm, tsk-&gt;parent-&gt;pid,                      \</span>
<a name="l00094"></a>00094 <span class="preprocessor">              tsk-&gt;parent-&gt;uid, tsk-&gt;parent-&gt;fsuid,                     \</span>
<a name="l00095"></a>00095 <span class="preprocessor">              tsk-&gt;request_key_auth ?                                   \</span>
<a name="l00096"></a>00096 <span class="preprocessor">              tsk-&gt;request_key_auth-&gt;serial : 0,                        \</span>
<a name="l00097"></a>00097 <span class="preprocessor">              key_cred(tsk)-&gt;thread_keyring ?                           \</span>
<a name="l00098"></a>00098 <span class="preprocessor">              key_cred(tsk)-&gt;thread_keyring-&gt;serial : 0,                \</span>
<a name="l00099"></a>00099 <span class="preprocessor">              key_tgcred(tsk)-&gt;process_keyring ?                        \</span>
<a name="l00100"></a>00100 <span class="preprocessor">              key_tgcred(tsk)-&gt;process_keyring-&gt;serial : 0,             \</span>
<a name="l00101"></a>00101 <span class="preprocessor">              key_tgcred(tsk)-&gt;session_keyring ?                        \</span>
<a name="l00102"></a>00102 <span class="preprocessor">              key_tgcred(tsk)-&gt;session_keyring-&gt;serial : 0,             \</span>
<a name="l00103"></a>00103 <span class="preprocessor">              key_cred(tsk)-&gt;user-&gt;uid_keyring ?                        \</span>
<a name="l00104"></a>00104 <span class="preprocessor">              key_cred(tsk)-&gt;user-&gt;uid_keyring-&gt;serial : 0,             \</span>
<a name="l00105"></a>00105 <span class="preprocessor">              key_cred(tsk)-&gt;user-&gt;session_keyring ?                    \</span>
<a name="l00106"></a>00106 <span class="preprocessor">              key_cred(tsk)-&gt;user-&gt;session_keyring-&gt;serial : 0,         \</span>
<a name="l00107"></a>00107 <span class="preprocessor">              key_cred(tsk)-&gt;jit_keyring                                \</span>
<a name="l00108"></a>00108 <span class="preprocessor">             );                                                         \</span>
<a name="l00109"></a>00109 <span class="preprocessor">}</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>
<a name="l00111"></a><a class="code" href="gss__keyring_8c.html#aae6aa7f56122439326f48c2ea5dd2a27">00111</a> <span class="preprocessor">#define DUMP_KEY(key)                                                   \</span>
<a name="l00112"></a>00112 <span class="preprocessor">{                                                                       \</span>
<a name="l00113"></a>00113 <span class="preprocessor">        CWARN(&quot;DUMP KEY: %p(%d) ref %d u%u/g%u desc %s\n&quot;,              \</span>
<a name="l00114"></a>00114 <span class="preprocessor">              key, key-&gt;serial, atomic_read(&amp;key-&gt;usage),               \</span>
<a name="l00115"></a>00115 <span class="preprocessor">              key-&gt;uid, key-&gt;gid,                                       \</span>
<a name="l00116"></a>00116 <span class="preprocessor">              key-&gt;description ? key-&gt;description : &quot;n/a&quot;               \</span>
<a name="l00117"></a>00117 <span class="preprocessor">             );                                                         \</span>
<a name="l00118"></a>00118 <span class="preprocessor">}</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>
<a name="l00120"></a><a class="code" href="gss__keyring_8c.html#aca35f9972380c126511c85625daa56bf">00120</a> <span class="preprocessor">#define key_cred(tsk)   ((tsk)-&gt;cred)</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_CRED_TGCRED</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor">#define key_tgcred(tsk) ((tsk)-&gt;cred-&gt;tgcred)</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00124"></a><a class="code" href="gss__keyring_8c.html#a0262ea1aa8b745b7c971ec8fc05f2573">00124</a> <span class="preprocessor"></span><span class="preprocessor">#define key_tgcred(tsk) key_cred(tsk)</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span>
<a name="l00127"></a><a class="code" href="gss__keyring_8c.html#a108f3d829b36c1457d818aff66090816">00127</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a108f3d829b36c1457d818aff66090816">keyring_upcall_lock</a>(<span class="keyword">struct</span> <a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a> *gsec_kr)
<a name="l00128"></a>00128 {
<a name="l00129"></a>00129 <span class="preprocessor">#ifdef HAVE_KEYRING_UPCALL_SERIALIZED</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span>        mutex_lock(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa06507139516c64184a855aaa8a635d7">gsk_uc_lock</a>);
<a name="l00131"></a>00131 <span class="preprocessor">#endif</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>}
<a name="l00133"></a>00133 
<a name="l00134"></a><a class="code" href="gss__keyring_8c.html#a54b97b8256520663da4a2a27abe3cc5a">00134</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a54b97b8256520663da4a2a27abe3cc5a">keyring_upcall_unlock</a>(<span class="keyword">struct</span> <a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a> *gsec_kr)
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136 <span class="preprocessor">#ifdef HAVE_KEYRING_UPCALL_SERIALIZED</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>        mutex_unlock(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa06507139516c64184a855aaa8a635d7">gsk_uc_lock</a>);
<a name="l00138"></a>00138 <span class="preprocessor">#endif</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span>}
<a name="l00140"></a>00140 
<a name="l00141"></a><a class="code" href="gss__keyring_8c.html#afb70392389d6aad5dd5d47b522788620">00141</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#afb70392389d6aad5dd5d47b522788620">key_revoke_locked</a>(<span class="keyword">struct</span> key *key)
<a name="l00142"></a>00142 {
<a name="l00143"></a>00143         set_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags);
<a name="l00144"></a>00144 }
<a name="l00145"></a>00145 
<a name="l00146"></a><a class="code" href="gss__keyring_8c.html#a0ef7e54db10aa6224ec20d16c2fbe137">00146</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a0ef7e54db10aa6224ec20d16c2fbe137">ctx_upcall_timeout_kr</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l00147"></a>00147 {
<a name="l00148"></a>00148         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = (<span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *) data;
<a name="l00149"></a>00149         <span class="keyword">struct </span>key            *key = <a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx)-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a47532bb05ad6399ee9989135a39f4c8b">gck_key</a>;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;ctx %p, key %p\n&quot;</span>, ctx, key);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(key);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155         <a class="code" href="gss__internal_8h.html#a0221581476c9d1e189b27f84ef6227b2">cli_ctx_expire</a>(ctx);
<a name="l00156"></a>00156         <a class="code" href="gss__keyring_8c.html#afb70392389d6aad5dd5d47b522788620">key_revoke_locked</a>(key);
<a name="l00157"></a>00157 }
<a name="l00158"></a>00158 
<a name="l00159"></a><a class="code" href="gss__keyring_8c.html#a3deec10c9d7902fd4d44765fd86418bb">00159</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a3deec10c9d7902fd4d44765fd86418bb">ctx_start_timer_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">long</span> <a class="code" href="gnilnd__modparams_8c.html#a493b57f443cc38b3d3df9c1e584d9d82">timeout</a>)
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161         <span class="keyword">struct </span><a class="code" href="structgss__cli__ctx__keyring.html">gss_cli_ctx_keyring</a> *gctx_kr = <a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx);
<a name="l00162"></a>00162         <span class="keyword">struct </span>timer_list          *timer = gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a4510a4aa955428e028a42ead177989f0">gck_timer</a>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(timer);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;ctx %p: start timer %lds\n&quot;</span>, ctx, timeout);
<a name="l00167"></a>00167         timeout = msecs_to_jiffies(timeout * MSEC_PER_SEC) +
<a name="l00168"></a>00168                   <a class="code" href="linux-time_8h.html#adc63a7977338536b551ccc795e5a9148">cfs_time_current</a>();
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         init_timer(timer);
<a name="l00171"></a>00171         timer-&gt;expires = timeout;
<a name="l00172"></a>00172         timer-&gt;data = (<span class="keywordtype">unsigned</span> long ) ctx;
<a name="l00173"></a>00173         timer-&gt;function = <a class="code" href="gss__keyring_8c.html#a0ef7e54db10aa6224ec20d16c2fbe137">ctx_upcall_timeout_kr</a>;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175         add_timer(timer);
<a name="l00176"></a>00176 }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="comment">/*</span>
<a name="l00179"></a>00179 <span class="comment"> * caller should make sure no race with other threads</span>
<a name="l00180"></a>00180 <span class="comment"> */</span>
<a name="l00181"></a>00181 <span class="keyword">static</span>
<a name="l00182"></a><a class="code" href="gss__keyring_8c.html#a1b6b0a6d4b0a8b856169e1952ad57c45">00182</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a1b6b0a6d4b0a8b856169e1952ad57c45">ctx_clear_timer_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00183"></a>00183 {
<a name="l00184"></a>00184         <span class="keyword">struct </span><a class="code" href="structgss__cli__ctx__keyring.html">gss_cli_ctx_keyring</a> *gctx_kr = <a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx);
<a name="l00185"></a>00185         <span class="keyword">struct </span>timer_list          *timer = gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a4510a4aa955428e028a42ead177989f0">gck_timer</a>;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <span class="keywordflow">if</span> (timer == NULL)
<a name="l00188"></a>00188                 <span class="keywordflow">return</span>;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;ctx %p, key %p\n&quot;</span>, ctx, gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a47532bb05ad6399ee9989135a39f4c8b">gck_key</a>);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a4510a4aa955428e028a42ead177989f0">gck_timer</a> = NULL;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         del_singleshot_timer_sync(timer);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(timer);
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="keyword">static</span>
<a name="l00200"></a><a class="code" href="gss__keyring_8c.html#a618d26f42ae4d0492d02395faedb08dd">00200</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *<a class="code" href="gss__keyring_8c.html#a618d26f42ae4d0492d02395faedb08dd">ctx_create_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00201"></a>00201                                      <span class="keyword">struct</span> <a class="code" href="structvfs__cred.html">vfs_cred</a> *vcred)
<a name="l00202"></a>00202 {
<a name="l00203"></a>00203         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>      *ctx;
<a name="l00204"></a>00204         <span class="keyword">struct </span><a class="code" href="structgss__cli__ctx__keyring.html">gss_cli_ctx_keyring</a> *gctx_kr;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <a class="code" href="obd__support_8h.html#ab5ccc29ab0a6625457a863652381c45c">OBD_ALLOC_PTR</a>(gctx_kr);
<a name="l00207"></a>00207         <span class="keywordflow">if</span> (gctx_kr == NULL)
<a name="l00208"></a>00208                 <span class="keywordflow">return</span> NULL;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <a class="code" href="obd__support_8h.html#ab5ccc29ab0a6625457a863652381c45c">OBD_ALLOC_PTR</a>(gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a4510a4aa955428e028a42ead177989f0">gck_timer</a>);
<a name="l00211"></a>00211         <span class="keywordflow">if</span> (gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a4510a4aa955428e028a42ead177989f0">gck_timer</a> == NULL) {
<a name="l00212"></a>00212                 <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(gctx_kr);
<a name="l00213"></a>00213                 <span class="keywordflow">return</span> NULL;
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215         init_timer(gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a4510a4aa955428e028a42ead177989f0">gck_timer</a>);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         ctx = &amp;gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#ab0fcfcbddfb5f97e5c59686600e2a020">gck_base</a>.<a class="code" href="structgss__cli__ctx.html#a2c2d9cf002b8655a384015e2ba071f57">gc_base</a>;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <span class="keywordflow">if</span> (<a class="code" href="gss__internal_8h.html#a90054c1f8c6dff8cf2eccd382c4f8f79">gss_cli_ctx_init_common</a>(sec, ctx, &amp;<a class="code" href="gss__keyring_8c.html#abf4771e7b17fb63b063a5fd7b7897efd">gss_keyring_ctxops</a>, vcred)) {
<a name="l00220"></a>00220                 <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a4510a4aa955428e028a42ead177989f0">gck_timer</a>);
<a name="l00221"></a>00221                 <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(gctx_kr);
<a name="l00222"></a>00222                 <span class="keywordflow">return</span> NULL;
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a2e29183830176dfb8c6a77839af173ec">cc_expire</a> = <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>() + <a class="code" href="gss__keyring_8c.html#afffe7859f8bdc0060956e7fe5ffb9cc2">KEYRING_UPCALL_TIMEOUT</a>;
<a name="l00226"></a>00226         clear_bit(<a class="code" href="group__sptlrpc.html#ga3102fdbe49a0dfef9ecb47f58d1c5935">PTLRPC_CTX_NEW_BIT</a>, &amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>);
<a name="l00227"></a>00227         atomic_inc(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>); <span class="comment">/* for the caller */</span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         <span class="keywordflow">return</span> ctx;
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a><a class="code" href="gss__keyring_8c.html#a024df1fb15f8c40a8560971a2848057c">00232</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a024df1fb15f8c40a8560971a2848057c">ctx_destroy_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00233"></a>00233 {
<a name="l00234"></a>00234         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>               *sec = ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a9c813cb37af100b37e92ec19db663a18">cc_sec</a>;
<a name="l00235"></a>00235         <span class="keyword">struct </span><a class="code" href="structgss__cli__ctx__keyring.html">gss_cli_ctx_keyring</a>      *gctx_kr = <a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;destroying ctx %p\n&quot;</span>, ctx);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239         <span class="comment">/* at this time the association with key has been broken. */</span>
<a name="l00240"></a>00240         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(sec);
<a name="l00241"></a>00241         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a4f72ce6853cdfb0253f533a31a1ced54">ps_refcount</a>) &gt; 0);
<a name="l00242"></a>00242         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a9e8ab0f2316d16b984a6452a73df5790" title="statistic only">ps_nctx</a>) &gt; 0);
<a name="l00243"></a>00243         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(test_bit(<a class="code" href="group__sptlrpc.html#ga69a211d66569cde070d2b8c9db0eb822">PTLRPC_CTX_CACHED_BIT</a>, &amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>) == 0);
<a name="l00244"></a>00244         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a47532bb05ad6399ee9989135a39f4c8b">gck_key</a> == NULL);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246         <a class="code" href="gss__keyring_8c.html#a1b6b0a6d4b0a8b856169e1952ad57c45">ctx_clear_timer_kr</a>(ctx);
<a name="l00247"></a>00247         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(gctx_kr-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a4510a4aa955428e028a42ead177989f0">gck_timer</a> == NULL);
<a name="l00248"></a>00248 
<a name="l00249"></a>00249         <span class="keywordflow">if</span> (<a class="code" href="gss__internal_8h.html#a47d7dfde849fe699ed11fd7debf3311a">gss_cli_ctx_fini_common</a>(sec, ctx))
<a name="l00250"></a>00250                 <span class="keywordflow">return</span>;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         <a class="code" href="obd__support_8h.html#a56214d823e92375ad47cd06a7daeae7a">OBD_FREE_PTR</a>(gctx_kr);
<a name="l00253"></a>00253 
<a name="l00254"></a>00254         atomic_dec(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a9e8ab0f2316d16b984a6452a73df5790" title="statistic only">ps_nctx</a>);
<a name="l00255"></a>00255         <a class="code" href="group__sptlrpc.html#ga7614fad9d6201ee956c2b8c591b63e27">sptlrpc_sec_put</a>(sec);
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a><a class="code" href="gss__keyring_8c.html#a7ec7f153c41487851981b77e6c0d7d3e">00258</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a7ec7f153c41487851981b77e6c0d7d3e">ctx_release_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">int</span> sync)
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260         <span class="keywordflow">if</span> (sync) {
<a name="l00261"></a>00261                 <a class="code" href="gss__keyring_8c.html#a024df1fb15f8c40a8560971a2848057c">ctx_destroy_kr</a>(ctx);
<a name="l00262"></a>00262         } <span class="keywordflow">else</span> {
<a name="l00263"></a>00263                 atomic_inc(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l00264"></a>00264                 <a class="code" href="group__sptlrpc.html#gad6c2b6adaa51bed62ebd4a5bef32eb8e">sptlrpc_gc_add_ctx</a>(ctx);
<a name="l00265"></a>00265         }
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a><a class="code" href="gss__keyring_8c.html#a79f4bcc956335d06ad6d1a6e6758eca0">00268</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a79f4bcc956335d06ad6d1a6e6758eca0">ctx_put_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">int</span> sync)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 0);
<a name="l00271"></a>00271 
<a name="l00272"></a>00272         <span class="keywordflow">if</span> (atomic_dec_and_test(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>))
<a name="l00273"></a>00273                 <a class="code" href="gss__keyring_8c.html#a7ec7f153c41487851981b77e6c0d7d3e">ctx_release_kr</a>(ctx, sync);
<a name="l00274"></a>00274 }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="comment">/*</span>
<a name="l00277"></a>00277 <span class="comment"> * key &lt;-&gt; ctx association and rules:</span>
<a name="l00278"></a>00278 <span class="comment"> * - ctx might not bind with any key</span>
<a name="l00279"></a>00279 <span class="comment"> * - key/ctx binding is protected by key semaphore (if the key present)</span>
<a name="l00280"></a>00280 <span class="comment"> * - key and ctx each take a reference of the other</span>
<a name="l00281"></a>00281 <span class="comment"> * - ctx enlist/unlist is protected by ctx spinlock</span>
<a name="l00282"></a>00282 <span class="comment"> * - never enlist a ctx after it&apos;s been unlisted</span>
<a name="l00283"></a>00283 <span class="comment"> * - whoever do enlist should also do bind, lock key before enlist:</span>
<a name="l00284"></a>00284 <span class="comment"> *   - lock key -&gt; lock ctx -&gt; enlist -&gt; unlock ctx -&gt; bind -&gt; unlock key</span>
<a name="l00285"></a>00285 <span class="comment"> * - whoever do unlist should also do unbind:</span>
<a name="l00286"></a>00286 <span class="comment"> *   - lock key -&gt; lock ctx -&gt; unlist -&gt; unlock ctx -&gt; unbind -&gt; unlock key</span>
<a name="l00287"></a>00287 <span class="comment"> *   - lock ctx -&gt; unlist -&gt; unlock ctx -&gt; lock key -&gt; unbind -&gt; unlock key</span>
<a name="l00288"></a>00288 <span class="comment"> */</span>
<a name="l00289"></a>00289 
<a name="l00290"></a><a class="code" href="gss__keyring_8c.html#a0277ce9e3d60919cc9aa9ea06e72e538">00290</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a0277ce9e3d60919cc9aa9ea06e72e538">spin_lock_if</a>(spinlock_t *lock, <span class="keywordtype">int</span> condition)
<a name="l00291"></a>00291 {
<a name="l00292"></a>00292         <span class="keywordflow">if</span> (condition)
<a name="l00293"></a>00293                 spin_lock(lock);
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00296"></a><a class="code" href="gss__keyring_8c.html#aa99f2559ad97438f457e7652791f6225">00296</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#aa99f2559ad97438f457e7652791f6225">spin_unlock_if</a>(spinlock_t *lock, <span class="keywordtype">int</span> condition)
<a name="l00297"></a>00297 {
<a name="l00298"></a>00298         <span class="keywordflow">if</span> (condition)
<a name="l00299"></a>00299                 spin_unlock(lock);
<a name="l00300"></a>00300 }
<a name="l00301"></a>00301 
<a name="l00302"></a><a class="code" href="gss__keyring_8c.html#a9724538fe8f4774ad2366c0d428f3702">00302</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a9724538fe8f4774ad2366c0d428f3702">ctx_enlist_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">int</span> is_root, <span class="keywordtype">int</span> locked)
<a name="l00303"></a>00303 {
<a name="l00304"></a>00304         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>       *sec = ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a9c813cb37af100b37e92ec19db663a18">cc_sec</a>;
<a name="l00305"></a>00305         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr = <a class="code" href="gss__internal_8h.html#ac981fa7c72306e0ea05429d2cceab30e">sec2gsec_keyring</a>(sec);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!test_bit(<a class="code" href="group__sptlrpc.html#ga69a211d66569cde070d2b8c9db0eb822">PTLRPC_CTX_CACHED_BIT</a>, &amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>));
<a name="l00308"></a>00308         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 0);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310         <a class="code" href="gss__keyring_8c.html#a0277ce9e3d60919cc9aa9ea06e72e538">spin_lock_if</a>(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>, !locked);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312         atomic_inc(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l00313"></a>00313         set_bit(<a class="code" href="group__sptlrpc.html#ga69a211d66569cde070d2b8c9db0eb822">PTLRPC_CTX_CACHED_BIT</a>, &amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>);
<a name="l00314"></a>00314         <a class="code" href="group__hlist.html#gad7a242949abf03ff2ae417686a4451cd">hlist_add_head</a>(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#ae4d570c219d29e547a09ce4c1ff6eb5b">cc_cache</a>, &amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#ad55cfea8393e100a306a026e8b302ed0">gsk_clist</a>);
<a name="l00315"></a>00315         <span class="keywordflow">if</span> (is_root)
<a name="l00316"></a>00316                 gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aab61545a459962d4d55c8cc9d031617b">gsk_root_ctx</a> = ctx;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318         <a class="code" href="gss__keyring_8c.html#aa99f2559ad97438f457e7652791f6225">spin_unlock_if</a>(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>, !locked);
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="comment">/*</span>
<a name="l00322"></a>00322 <span class="comment"> * Note after this get called, caller should not access ctx again because</span>
<a name="l00323"></a>00323 <span class="comment"> * it might have been freed, unless caller hold at least one refcount of</span>
<a name="l00324"></a>00324 <span class="comment"> * the ctx.</span>
<a name="l00325"></a>00325 <span class="comment"> *</span>
<a name="l00326"></a>00326 <span class="comment"> * return non-zero if we indeed unlist this ctx.</span>
<a name="l00327"></a>00327 <span class="comment"> */</span>
<a name="l00328"></a><a class="code" href="gss__keyring_8c.html#a27b5f34d201bd54a9f667f9b4e127c7d">00328</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a27b5f34d201bd54a9f667f9b4e127c7d">ctx_unlist_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">int</span> locked)
<a name="l00329"></a>00329 {
<a name="l00330"></a>00330         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a>       *sec = ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a9c813cb37af100b37e92ec19db663a18">cc_sec</a>;
<a name="l00331"></a>00331         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr = <a class="code" href="gss__internal_8h.html#ac981fa7c72306e0ea05429d2cceab30e">sec2gsec_keyring</a>(sec);
<a name="l00332"></a>00332 
<a name="l00333"></a>00333         <span class="comment">/* if hashed bit has gone, leave the job to somebody who is doing it */</span>
<a name="l00334"></a>00334         <span class="keywordflow">if</span> (test_and_clear_bit(<a class="code" href="group__sptlrpc.html#ga69a211d66569cde070d2b8c9db0eb822">PTLRPC_CTX_CACHED_BIT</a>, &amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>) == 0)
<a name="l00335"></a>00335                 <span class="keywordflow">return</span> 0;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337         <span class="comment">/* drop ref inside spin lock to prevent race with other operations */</span>
<a name="l00338"></a>00338         <a class="code" href="gss__keyring_8c.html#a0277ce9e3d60919cc9aa9ea06e72e538">spin_lock_if</a>(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>, !locked);
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         <span class="keywordflow">if</span> (gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aab61545a459962d4d55c8cc9d031617b">gsk_root_ctx</a> == ctx)
<a name="l00341"></a>00341                 gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aab61545a459962d4d55c8cc9d031617b">gsk_root_ctx</a> = NULL;
<a name="l00342"></a>00342         <a class="code" href="group__hlist.html#ga2e00d6f98de0c25c46a7645a0b6f4d5f">hlist_del_init</a>(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#ae4d570c219d29e547a09ce4c1ff6eb5b">cc_cache</a>);
<a name="l00343"></a>00343         atomic_dec(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l00344"></a>00344 
<a name="l00345"></a>00345         <a class="code" href="gss__keyring_8c.html#aa99f2559ad97438f457e7652791f6225">spin_unlock_if</a>(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>, !locked);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         <span class="keywordflow">return</span> 1;
<a name="l00348"></a>00348 }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 <span class="comment">/*</span>
<a name="l00351"></a>00351 <span class="comment"> * Get specific payload. Newer kernels support 4 slots.</span>
<a name="l00352"></a>00352 <span class="comment"> */</span>
<a name="l00353"></a>00353 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l00354"></a><a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">00354</a> <a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(<span class="keyword">struct</span> key *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356         <span class="keywordtype">void</span> *key_ptr = NULL;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="preprocessor">#ifdef HAVE_KEY_PAYLOAD_DATA_ARRAY</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span>        key_ptr = key-&gt;payload.data[index];
<a name="l00360"></a>00360 <span class="preprocessor">#else</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!index)
<a name="l00362"></a>00362                 key_ptr = key-&gt;payload.data;
<a name="l00363"></a>00363 <span class="preprocessor">#endif</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span>        <span class="keywordflow">return</span> key_ptr;
<a name="l00365"></a>00365 }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="comment">/*</span>
<a name="l00368"></a>00368 <span class="comment"> * Set specific payload. Newer kernels support 4 slots.</span>
<a name="l00369"></a>00369 <span class="comment"> */</span>
<a name="l00370"></a><a class="code" href="gss__keyring_8c.html#a0251b27284d5d1c5412c610752aaf843">00370</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a0251b27284d5d1c5412c610752aaf843">key_set_payload</a>(<span class="keyword">struct</span> key *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index,
<a name="l00371"></a>00371                            <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00372"></a>00372 {
<a name="l00373"></a>00373         <span class="keywordtype">int</span> rc = -EINVAL;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="preprocessor">#ifdef HAVE_KEY_PAYLOAD_DATA_ARRAY</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (index &lt; 4) {
<a name="l00377"></a>00377                 key-&gt;payload.data[index] = ctx;
<a name="l00378"></a>00378 <span class="preprocessor">#else</span>
<a name="l00379"></a>00379 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!index) {
<a name="l00380"></a>00380                 key-&gt;payload.data = ctx;
<a name="l00381"></a>00381 <span class="preprocessor">#endif</span>
<a name="l00382"></a>00382 <span class="preprocessor"></span>                rc = 0;
<a name="l00383"></a>00383         }
<a name="l00384"></a>00384         <span class="keywordflow">return</span> rc;
<a name="l00385"></a>00385 }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="comment">/*</span>
<a name="l00388"></a>00388 <span class="comment"> * bind a key with a ctx together.</span>
<a name="l00389"></a>00389 <span class="comment"> * caller must hold write lock of the key, as well as ref on key &amp; ctx.</span>
<a name="l00390"></a>00390 <span class="comment"> */</span>
<a name="l00391"></a><a class="code" href="gss__keyring_8c.html#abf8b5969b86eba0b43b721c0260fd316">00391</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#abf8b5969b86eba0b43b721c0260fd316">bind_key_ctx</a>(<span class="keyword">struct</span> key *key, <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00392"></a>00392 {
<a name="l00393"></a>00393         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 0);
<a name="l00394"></a>00394         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;key-&gt;usage) &gt; 0);
<a name="l00395"></a>00395         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx)-&gt;gck_key == NULL);
<a name="l00396"></a>00396         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!<a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0));
<a name="l00397"></a>00397 
<a name="l00398"></a>00398         <span class="comment">/* at this time context may or may not in list. */</span>
<a name="l00399"></a>00399         key_get(key);
<a name="l00400"></a>00400         atomic_inc(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l00401"></a>00401         <a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx)-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a47532bb05ad6399ee9989135a39f4c8b">gck_key</a> = key;
<a name="l00402"></a>00402         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!<a class="code" href="gss__keyring_8c.html#a0251b27284d5d1c5412c610752aaf843">key_set_payload</a>(key, 0, ctx));
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="comment">/*</span>
<a name="l00406"></a>00406 <span class="comment"> * unbind a key and a ctx.</span>
<a name="l00407"></a>00407 <span class="comment"> * caller must hold write lock, as well as a ref of the key.</span>
<a name="l00408"></a>00408 <span class="comment"> */</span>
<a name="l00409"></a><a class="code" href="gss__keyring_8c.html#a56634e8e06967613443269027dd3d2f1">00409</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a56634e8e06967613443269027dd3d2f1">unbind_key_ctx</a>(<span class="keyword">struct</span> key *key, <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00410"></a>00410 {
<a name="l00411"></a>00411         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0) == ctx);
<a name="l00412"></a>00412         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(test_bit(<a class="code" href="group__sptlrpc.html#ga69a211d66569cde070d2b8c9db0eb822">PTLRPC_CTX_CACHED_BIT</a>, &amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>) == 0);
<a name="l00413"></a>00413 
<a name="l00414"></a>00414         <span class="comment">/* must revoke the key, or others may treat it as newly created */</span>
<a name="l00415"></a>00415         <a class="code" href="gss__keyring_8c.html#afb70392389d6aad5dd5d47b522788620">key_revoke_locked</a>(key);
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         <a class="code" href="gss__keyring_8c.html#a0251b27284d5d1c5412c610752aaf843">key_set_payload</a>(key, 0, NULL);
<a name="l00418"></a>00418         <a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx)-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a47532bb05ad6399ee9989135a39f4c8b">gck_key</a> = NULL;
<a name="l00419"></a>00419 
<a name="l00420"></a>00420         <span class="comment">/* once ctx get split from key, the timer is meaningless */</span>
<a name="l00421"></a>00421         <a class="code" href="gss__keyring_8c.html#a1b6b0a6d4b0a8b856169e1952ad57c45">ctx_clear_timer_kr</a>(ctx);
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         <a class="code" href="gss__keyring_8c.html#a79f4bcc956335d06ad6d1a6e6758eca0">ctx_put_kr</a>(ctx, 1);
<a name="l00424"></a>00424         key_put(key);
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="comment">/*</span>
<a name="l00428"></a>00428 <span class="comment"> * given a ctx, unbind with its coupled key, if any.</span>
<a name="l00429"></a>00429 <span class="comment"> * unbind could only be called once, so we don&apos;t worry the key be released</span>
<a name="l00430"></a>00430 <span class="comment"> * by someone else.</span>
<a name="l00431"></a>00431 <span class="comment"> */</span>
<a name="l00432"></a><a class="code" href="gss__keyring_8c.html#a8cb623192d698f0b9eafc52aa22e21a9">00432</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a8cb623192d698f0b9eafc52aa22e21a9">unbind_ctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00433"></a>00433 {
<a name="l00434"></a>00434         <span class="keyword">struct </span>key      *key = <a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx)-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a47532bb05ad6399ee9989135a39f4c8b">gck_key</a>;
<a name="l00435"></a>00435 
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (key) {
<a name="l00437"></a>00437                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0) == ctx);
<a name="l00438"></a>00438 
<a name="l00439"></a>00439                 key_get(key);
<a name="l00440"></a>00440                 down_write(&amp;key-&gt;sem);
<a name="l00441"></a>00441                 <a class="code" href="gss__keyring_8c.html#a56634e8e06967613443269027dd3d2f1">unbind_key_ctx</a>(key, ctx);
<a name="l00442"></a>00442                 up_write(&amp;key-&gt;sem);
<a name="l00443"></a>00443                 key_put(key);
<a name="l00444"></a>00444         }
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="comment">/*</span>
<a name="l00448"></a>00448 <span class="comment"> * given a key, unbind with its coupled ctx, if any.</span>
<a name="l00449"></a>00449 <span class="comment"> * caller must hold write lock, as well as a ref of the key.</span>
<a name="l00450"></a>00450 <span class="comment"> */</span>
<a name="l00451"></a><a class="code" href="gss__keyring_8c.html#a56e455640677831cd2f95da607d217c1">00451</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a56e455640677831cd2f95da607d217c1">unbind_key_locked</a>(<span class="keyword">struct</span> key *key)
<a name="l00452"></a>00452 {
<a name="l00453"></a>00453         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = <a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         <span class="keywordflow">if</span> (ctx)
<a name="l00456"></a>00456                 <a class="code" href="gss__keyring_8c.html#a56634e8e06967613443269027dd3d2f1">unbind_key_ctx</a>(key, ctx);
<a name="l00457"></a>00457 }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="comment">/*</span>
<a name="l00460"></a>00460 <span class="comment"> * unlist a ctx, and unbind from coupled key</span>
<a name="l00461"></a>00461 <span class="comment"> */</span>
<a name="l00462"></a><a class="code" href="gss__keyring_8c.html#abd57eda3f7c92a032a1c5cbac2a29e13">00462</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#abd57eda3f7c92a032a1c5cbac2a29e13">kill_ctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l00463"></a>00463 {
<a name="l00464"></a>00464         <span class="keywordflow">if</span> (<a class="code" href="gss__keyring_8c.html#a27b5f34d201bd54a9f667f9b4e127c7d">ctx_unlist_kr</a>(ctx, 0))
<a name="l00465"></a>00465                 <a class="code" href="gss__keyring_8c.html#a8cb623192d698f0b9eafc52aa22e21a9">unbind_ctx_kr</a>(ctx);
<a name="l00466"></a>00466 }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="comment">/*</span>
<a name="l00469"></a>00469 <span class="comment"> * given a key, unlist and unbind with the coupled ctx (if any).</span>
<a name="l00470"></a>00470 <span class="comment"> * caller must hold write lock, as well as a ref of the key.</span>
<a name="l00471"></a>00471 <span class="comment"> */</span>
<a name="l00472"></a><a class="code" href="gss__keyring_8c.html#a2ede0149fdb88eb781694dd4a97fc39e">00472</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a2ede0149fdb88eb781694dd4a97fc39e">kill_key_locked</a>(<span class="keyword">struct</span> key *key)
<a name="l00473"></a>00473 {
<a name="l00474"></a>00474         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = <a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0);
<a name="l00475"></a>00475 
<a name="l00476"></a>00476         <span class="keywordflow">if</span> (ctx &amp;&amp; <a class="code" href="gss__keyring_8c.html#a27b5f34d201bd54a9f667f9b4e127c7d">ctx_unlist_kr</a>(ctx, 0))
<a name="l00477"></a>00477                 <a class="code" href="gss__keyring_8c.html#a56e455640677831cd2f95da607d217c1">unbind_key_locked</a>(key);
<a name="l00478"></a>00478 }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 <span class="comment">/*</span>
<a name="l00481"></a>00481 <span class="comment"> * caller should hold one ref on contexts in freelist.</span>
<a name="l00482"></a>00482 <span class="comment"> */</span>
<a name="l00483"></a><a class="code" href="gss__keyring_8c.html#a45eff170e415335c118d4fdaae01c9d2">00483</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a45eff170e415335c118d4fdaae01c9d2">dispose_ctx_list_kr</a>(<span class="keyword">struct</span> <a class="code" href="structhlist__head.html">hlist_head</a> *freelist)
<a name="l00484"></a>00484 {
<a name="l00485"></a>00485         <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>       __maybe_unused *pos, *<a class="code" href="structhlist__node.html#a915ba19b2ab3aa3f092edc8d5ed98c27">next</a>;
<a name="l00486"></a>00486         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *ctx;
<a name="l00487"></a>00487         <span class="keyword">struct </span><a class="code" href="structgss__cli__ctx.html">gss_cli_ctx</a>      *gctx;
<a name="l00488"></a>00488 
<a name="l00489"></a>00489         <a class="code" href="list_8h.html#a89bd1c1d04dc01a4e0ba38e8a6a562d2">cfs_hlist_for_each_entry_safe</a>(ctx, pos, next, freelist, cc_cache) {
<a name="l00490"></a>00490                 <a class="code" href="group__hlist.html#ga2e00d6f98de0c25c46a7645a0b6f4d5f">hlist_del_init</a>(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#ae4d570c219d29e547a09ce4c1ff6eb5b">cc_cache</a>);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492                 <span class="comment">/* reverse ctx: update current seq to buddy svcctx if exist.</span>
<a name="l00493"></a>00493 <span class="comment">                 * ideally this should be done at gss_cli_ctx_finalize(), but</span>
<a name="l00494"></a>00494 <span class="comment">                 * the ctx destroy could be delayed by:</span>
<a name="l00495"></a>00495 <span class="comment">                 *  1) ctx still has reference;</span>
<a name="l00496"></a>00496 <span class="comment">                 *  2) ctx destroy is asynchronous;</span>
<a name="l00497"></a>00497 <span class="comment">                 * and reverse import call inval_all_ctx() require this be done</span>
<a name="l00498"></a>00498 <span class="comment">                 * _immediately_ otherwise newly created reverse ctx might copy</span>
<a name="l00499"></a>00499 <span class="comment">                 * the very old sequence number from svcctx. */</span>
<a name="l00500"></a>00500                 gctx = <a class="code" href="gss__internal_8h.html#a05af0b887e35087790790d31ab623e9a">ctx2gctx</a>(ctx);
<a name="l00501"></a>00501                 <span class="keywordflow">if</span> (!<a class="code" href="gss__internal_8h.html#a296b02a2092693da45115e3c18c6735d">rawobj_empty</a>(&amp;gctx-&gt;<a class="code" href="structgss__cli__ctx.html#ac3e25dd72f1a8683cad494af7e22fb52">gc_svc_handle</a>) &amp;&amp;
<a name="l00502"></a>00502                     <a class="code" href="group__sptlrpc.html#ga46f1b8ed0c826e568a23850f7c929f12">sec_is_reverse</a>(gctx-&gt;<a class="code" href="structgss__cli__ctx.html#a2c2d9cf002b8655a384015e2ba071f57">gc_base</a>.<a class="code" href="structptlrpc__cli__ctx.html#a9c813cb37af100b37e92ec19db663a18">cc_sec</a>)) {
<a name="l00503"></a>00503                         <a class="code" href="gss__internal_8h.html#a5516f1a994d34b1f858da2708524daad">gss_svc_upcall_update_sequence</a>(&amp;gctx-&gt;<a class="code" href="structgss__cli__ctx.html#ac3e25dd72f1a8683cad494af7e22fb52">gc_svc_handle</a>,
<a name="l00504"></a>00504                                         (__u32) atomic_read(&amp;gctx-&gt;<a class="code" href="structgss__cli__ctx.html#ab648b65a9748c23ca03427606fffda64">gc_seq</a>));
<a name="l00505"></a>00505                 }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507                 <span class="comment">/* we need to wakeup waiting reqs here. the context might</span>
<a name="l00508"></a>00508 <span class="comment">                 * be forced released before upcall finished, then the</span>
<a name="l00509"></a>00509 <span class="comment">                 * late-arrived downcall can&apos;t find the ctx even. */</span>
<a name="l00510"></a>00510                 <a class="code" href="group__sptlrpc.html#gae8509673f10f3ba05986d960f5b4a20d" title="To wake up the threads who are waiting for this client context.">sptlrpc_cli_ctx_wakeup</a>(ctx);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512                 <a class="code" href="gss__keyring_8c.html#a8cb623192d698f0b9eafc52aa22e21a9">unbind_ctx_kr</a>(ctx);
<a name="l00513"></a>00513                 <a class="code" href="gss__keyring_8c.html#a79f4bcc956335d06ad6d1a6e6758eca0">ctx_put_kr</a>(ctx, 0);
<a name="l00514"></a>00514         }
<a name="l00515"></a>00515 }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="comment">/*</span>
<a name="l00518"></a>00518 <span class="comment"> * lookup a root context directly in a sec, return root ctx with a</span>
<a name="l00519"></a>00519 <span class="comment"> * reference taken or NULL.</span>
<a name="l00520"></a>00520 <span class="comment"> */</span>
<a name="l00521"></a>00521 <span class="keyword">static</span>
<a name="l00522"></a><a class="code" href="gss__keyring_8c.html#ab9397cc0b2f63cd8af15f4b65795da0b">00522</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> * <a class="code" href="gss__keyring_8c.html#ab9397cc0b2f63cd8af15f4b65795da0b">sec_lookup_root_ctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l00523"></a>00523 {
<a name="l00524"></a>00524         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr = <a class="code" href="gss__internal_8h.html#ac981fa7c72306e0ea05429d2cceab30e">sec2gsec_keyring</a>(sec);
<a name="l00525"></a>00525         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *ctx = NULL;
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         spin_lock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l00528"></a>00528 
<a name="l00529"></a>00529         ctx = gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aab61545a459962d4d55c8cc9d031617b">gsk_root_ctx</a>;
<a name="l00530"></a>00530 
<a name="l00531"></a>00531         <span class="keywordflow">if</span> (ctx == NULL &amp;&amp; <a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(<a class="code" href="group__sptlrpc.html#ga46f1b8ed0c826e568a23850f7c929f12">sec_is_reverse</a>(sec))) {
<a name="l00532"></a>00532                 <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>       __maybe_unused *node;
<a name="l00533"></a>00533                 <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *tmp;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535                 <span class="comment">/* reverse ctx, search root ctx in list, choose the one</span>
<a name="l00536"></a>00536 <span class="comment">                 * with shortest expire time, which is most possibly have</span>
<a name="l00537"></a>00537 <span class="comment">                 * an established peer ctx at client side. */</span>
<a name="l00538"></a>00538                 <a class="code" href="list_8h.html#a5c82c166bd340019710358c6c7c22a95">cfs_hlist_for_each_entry</a>(tmp, node, &amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#ad55cfea8393e100a306a026e8b302ed0">gsk_clist</a>,
<a name="l00539"></a>00539                                          <a class="code" href="structptlrpc__cli__ctx.html#ae4d570c219d29e547a09ce4c1ff6eb5b">cc_cache</a>) {
<a name="l00540"></a>00540                         <span class="keywordflow">if</span> (ctx == NULL || ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a2e29183830176dfb8c6a77839af173ec">cc_expire</a> == 0 ||
<a name="l00541"></a>00541                             ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a2e29183830176dfb8c6a77839af173ec">cc_expire</a> &gt; tmp-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a2e29183830176dfb8c6a77839af173ec">cc_expire</a>) {
<a name="l00542"></a>00542                                 ctx = tmp;
<a name="l00543"></a>00543                                 <span class="comment">/* promote to be root_ctx */</span>
<a name="l00544"></a>00544                                 gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aab61545a459962d4d55c8cc9d031617b">gsk_root_ctx</a> = ctx;
<a name="l00545"></a>00545                         }
<a name="l00546"></a>00546                 }
<a name="l00547"></a>00547         }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549         <span class="keywordflow">if</span> (ctx) {
<a name="l00550"></a>00550                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 0);
<a name="l00551"></a>00551                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!<a class="code" href="group__hlist.html#gaf610dde21167bf116937c81c393a229f">hlist_empty</a>(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#ad55cfea8393e100a306a026e8b302ed0">gsk_clist</a>));
<a name="l00552"></a>00552                 atomic_inc(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l00553"></a>00553         }
<a name="l00554"></a>00554 
<a name="l00555"></a>00555         spin_unlock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         <span class="keywordflow">return</span> ctx;
<a name="l00558"></a>00558 }
<a name="l00559"></a>00559 
<a name="l00560"></a><a class="code" href="gss__keyring_8c.html#a362c7302e88f9b56a4c273de61518bec">00560</a> <span class="preprocessor">#define RVS_CTX_EXPIRE_NICE    (10)</span>
<a name="l00561"></a>00561 <span class="preprocessor"></span>
<a name="l00562"></a>00562 <span class="keyword">static</span>
<a name="l00563"></a><a class="code" href="gss__keyring_8c.html#ac94a4d051ef6cb3a5b270633403627e4">00563</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#ac94a4d051ef6cb3a5b270633403627e4">rvs_sec_install_root_ctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00564"></a>00564                                  <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *new_ctx,
<a name="l00565"></a>00565                                  <span class="keyword">struct</span> key *key)
<a name="l00566"></a>00566 {
<a name="l00567"></a>00567         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr = <a class="code" href="gss__internal_8h.html#ac981fa7c72306e0ea05429d2cceab30e">sec2gsec_keyring</a>(sec);
<a name="l00568"></a>00568         <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>       __maybe_unused *hnode;
<a name="l00569"></a>00569         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *ctx;
<a name="l00570"></a>00570         <a class="code" href="linux-time_8h.html#a0e81d053bc8d925f6574c760bbea5ac4">cfs_time_t</a>              <a class="code" href="createmany_8c.html#a5602e9c6b2da7a1db11ed8a76d19fde3">now</a>;
<a name="l00571"></a>00571         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="group__sptlrpc.html#ga46f1b8ed0c826e568a23850f7c929f12">sec_is_reverse</a>(sec));
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         spin_lock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l00576"></a>00576 
<a name="l00577"></a>00577         now = <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>();
<a name="l00578"></a>00578 
<a name="l00579"></a>00579         <span class="comment">/* set all existing ctxs short expiry */</span>
<a name="l00580"></a>00580         <a class="code" href="list_8h.html#a5c82c166bd340019710358c6c7c22a95">cfs_hlist_for_each_entry</a>(ctx, hnode, &amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#ad55cfea8393e100a306a026e8b302ed0">gsk_clist</a>, <a class="code" href="structptlrpc__cli__ctx.html#ae4d570c219d29e547a09ce4c1ff6eb5b">cc_cache</a>) {
<a name="l00581"></a>00581                 <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a2e29183830176dfb8c6a77839af173ec">cc_expire</a> &gt; now + <a class="code" href="gss__keyring_8c.html#a362c7302e88f9b56a4c273de61518bec">RVS_CTX_EXPIRE_NICE</a>) {
<a name="l00582"></a>00582                         ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a6c4ef24b5fcc18b018f49f921d37aa70">cc_early_expire</a> = 1;
<a name="l00583"></a>00583                         ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a2e29183830176dfb8c6a77839af173ec">cc_expire</a> = now + <a class="code" href="gss__keyring_8c.html#a362c7302e88f9b56a4c273de61518bec">RVS_CTX_EXPIRE_NICE</a>;
<a name="l00584"></a>00584                 }
<a name="l00585"></a>00585         }
<a name="l00586"></a>00586 
<a name="l00587"></a>00587         <span class="comment">/* if there&apos;s root_ctx there, instead obsolete the current</span>
<a name="l00588"></a>00588 <span class="comment">         * immediately, we leave it continue operating for a little while.</span>
<a name="l00589"></a>00589 <span class="comment">         * hopefully when the first backward rpc with newest ctx send out,</span>
<a name="l00590"></a>00590 <span class="comment">         * the client side already have the peer ctx well established. */</span>
<a name="l00591"></a>00591         <a class="code" href="gss__keyring_8c.html#a9724538fe8f4774ad2366c0d428f3702">ctx_enlist_kr</a>(new_ctx, gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aab61545a459962d4d55c8cc9d031617b">gsk_root_ctx</a> ? 0 : 1, 1);
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         <span class="keywordflow">if</span> (key)
<a name="l00594"></a>00594                 <a class="code" href="gss__keyring_8c.html#abf8b5969b86eba0b43b721c0260fd316">bind_key_ctx</a>(key, new_ctx);
<a name="l00595"></a>00595 
<a name="l00596"></a>00596         spin_unlock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l00597"></a>00597 }
<a name="l00598"></a>00598 
<a name="l00599"></a><a class="code" href="gss__keyring_8c.html#a5db44e2620d98ba779b1af994694e16e">00599</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a5db44e2620d98ba779b1af994694e16e">construct_key_desc</a>(<span class="keywordtype">void</span> *<a class="code" href="parallel__grouplock_8c.html#a30581aaaef7980b9fc6df8f98406097c">buf</a>, <span class="keywordtype">int</span> <a class="code" href="multiop_8c.html#a199ab88d4ca8eab30e1cb7d35edacca5">bufsize</a>,
<a name="l00600"></a>00600                                <span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec, uid_t uid)
<a name="l00601"></a>00601 {
<a name="l00602"></a>00602         snprintf(buf, bufsize, <span class="stringliteral">&quot;%d@%x&quot;</span>, uid, sec-&gt;<a class="code" href="structptlrpc__sec.html#a68829ae9ed27305779a9d5ad9d1b8283" title="unique identifier">ps_id</a>);
<a name="l00603"></a>00603         ((<span class="keywordtype">char</span> *)buf)[bufsize - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00604"></a>00604 }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="comment">/****************************************</span>
<a name="l00607"></a>00607 <span class="comment"> * sec apis                             *</span>
<a name="l00608"></a>00608 <span class="comment"> ****************************************/</span>
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 <span class="keyword">static</span>
<a name="l00611"></a><a class="code" href="gss__keyring_8c.html#aad20b6d21cebcad1912409a00e644680">00611</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> * <a class="code" href="gss__keyring_8c.html#aad20b6d21cebcad1912409a00e644680">gss_sec_create_kr</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l00612"></a>00612                                       <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *svcctx,
<a name="l00613"></a>00613                                       <span class="keyword">struct</span> <a class="code" href="structsptlrpc__flavor.html" title="Full description of flavors being used on a ptlrpc connection, include both regular...">sptlrpc_flavor</a> *sf)
<a name="l00614"></a>00614 {
<a name="l00615"></a>00615         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr;
<a name="l00616"></a>00616         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618         <a class="code" href="obd__support_8h.html#a884069f9eb0bef22c424688b5f3fafba">OBD_ALLOC</a>(gsec_kr, <span class="keyword">sizeof</span>(*gsec_kr));
<a name="l00619"></a>00619         <span class="keywordflow">if</span> (gsec_kr == NULL)
<a name="l00620"></a>00620                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(NULL);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622         <a class="code" href="group__hlist.html#ga502bdfb9a4a5a0d922363ea1708bf081">INIT_HLIST_HEAD</a>(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#ad55cfea8393e100a306a026e8b302ed0">gsk_clist</a>);
<a name="l00623"></a>00623         gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aab61545a459962d4d55c8cc9d031617b">gsk_root_ctx</a> = NULL;
<a name="l00624"></a>00624         mutex_init(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa9c28b5fd10b8753446a0ec9c125d15f">gsk_root_uc_lock</a>);
<a name="l00625"></a>00625 <span class="preprocessor">#ifdef HAVE_KEYRING_UPCALL_SERIALIZED</span>
<a name="l00626"></a>00626 <span class="preprocessor"></span>        mutex_init(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa06507139516c64184a855aaa8a635d7">gsk_uc_lock</a>);
<a name="l00627"></a>00627 <span class="preprocessor">#endif</span>
<a name="l00628"></a>00628 <span class="preprocessor"></span>
<a name="l00629"></a>00629         <span class="keywordflow">if</span> (<a class="code" href="gss__internal_8h.html#a610b5c8c367cb840887f8b298a7ec92e">gss_sec_create_common</a>(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa767c749c01555e545731877869d4e04">gsk_base</a>, &amp;<a class="code" href="gss__keyring_8c.html#ad4fceaf252b84c6761b2ba9e14eaf50b">gss_policy_keyring</a>,
<a name="l00630"></a>00630                                   imp, svcctx, sf))
<a name="l00631"></a>00631                 <span class="keywordflow">goto</span> err_free;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633         <span class="keywordflow">if</span> (svcctx != NULL &amp;&amp;
<a name="l00634"></a>00634             <a class="code" href="gss__keyring_8c.html#a57d118b8febccdc110895ea651efbd75">sec_install_rctx_kr</a>(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa767c749c01555e545731877869d4e04">gsk_base</a>.<a class="code" href="structgss__sec.html#a53ef335272dd45e92d4ff83341e9ce15">gs_base</a>, svcctx)) {
<a name="l00635"></a>00635                 <a class="code" href="gss__internal_8h.html#a86eceac16ab00ecaca0759414e7aa972">gss_sec_destroy_common</a>(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa767c749c01555e545731877869d4e04">gsk_base</a>);
<a name="l00636"></a>00636                 <span class="keywordflow">goto</span> err_free;
<a name="l00637"></a>00637         }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa767c749c01555e545731877869d4e04">gsk_base</a>.<a class="code" href="structgss__sec.html#a53ef335272dd45e92d4ff83341e9ce15">gs_base</a>);
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 err_free:
<a name="l00642"></a>00642         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(gsec_kr, <span class="keyword">sizeof</span>(*gsec_kr));
<a name="l00643"></a>00643         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(NULL);
<a name="l00644"></a>00644 }
<a name="l00645"></a>00645 
<a name="l00646"></a>00646 <span class="keyword">static</span>
<a name="l00647"></a><a class="code" href="gss__keyring_8c.html#ae5a3328ecbb8e49fb839a6d50bf1f8a5">00647</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#ae5a3328ecbb8e49fb839a6d50bf1f8a5">gss_sec_destroy_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l00648"></a>00648 {
<a name="l00649"></a>00649         <span class="keyword">struct </span><a class="code" href="structgss__sec.html">gss_sec</a>          *gsec = <a class="code" href="gss__internal_8h.html#a85f066ea8b2a7f30edffdadabbebea52">sec2gsec</a>(sec);
<a name="l00650"></a>00650         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr = <a class="code" href="gss__internal_8h.html#ac981fa7c72306e0ea05429d2cceab30e">sec2gsec_keyring</a>(sec);
<a name="l00651"></a>00651 
<a name="l00652"></a>00652         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;destroy %s@%p\n&quot;</span>, sec-&gt;<a class="code" href="structptlrpc__sec.html#a234a026412f54989b733a4da40db4d69">ps_policy</a>-&gt;<a class="code" href="structptlrpc__sec__policy.html#a4eb592d0887f48d2fefda96c09a064d0">sp_name</a>, sec);
<a name="l00653"></a>00653 
<a name="l00654"></a>00654         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="group__hlist.html#gaf610dde21167bf116937c81c393a229f">hlist_empty</a>(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#ad55cfea8393e100a306a026e8b302ed0">gsk_clist</a>));
<a name="l00655"></a>00655         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aab61545a459962d4d55c8cc9d031617b">gsk_root_ctx</a> == NULL);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         <a class="code" href="gss__internal_8h.html#a86eceac16ab00ecaca0759414e7aa972">gss_sec_destroy_common</a>(gsec);
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(gsec_kr, <span class="keyword">sizeof</span>(*gsec_kr));
<a name="l00660"></a>00660 }
<a name="l00661"></a>00661 
<a name="l00662"></a><a class="code" href="gss__keyring_8c.html#a691d89262884007ebed2ef41bb1b7f12">00662</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a691d89262884007ebed2ef41bb1b7f12">user_is_root</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec, <span class="keyword">struct</span> <a class="code" href="structvfs__cred.html">vfs_cred</a> *vcred)
<a name="l00663"></a>00663 {
<a name="l00664"></a>00664         <span class="comment">/* except the ROOTONLY flag, treat it as root user only if real uid</span>
<a name="l00665"></a>00665 <span class="comment">         * is 0, euid/fsuid being 0 are handled as setuid scenarios */</span>
<a name="l00666"></a>00666         <span class="keywordflow">if</span> (<a class="code" href="group__sptlrpc.html#ga7341925609139e420a78172f5974f1ee">sec_is_rootonly</a>(sec) || (vcred-&gt;<a class="code" href="structvfs__cred.html#af7938ab8ff1701fbfea3a3e66c70d66f">vc_uid</a> == 0))
<a name="l00667"></a>00667                 <span class="keywordflow">return</span> 1;
<a name="l00668"></a>00668         <span class="keywordflow">else</span>
<a name="l00669"></a>00669                 <span class="keywordflow">return</span> 0;
<a name="l00670"></a>00670 }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="comment">/*</span>
<a name="l00673"></a>00673 <span class="comment"> * unlink request key from it&apos;s ring, which is linked during request_key().</span>
<a name="l00674"></a>00674 <span class="comment"> * sadly, we have to &apos;guess&apos; which keyring it&apos;s linked to.</span>
<a name="l00675"></a>00675 <span class="comment"> *</span>
<a name="l00676"></a>00676 <span class="comment"> * FIXME this code is fragile, depend on how request_key_link() is implemented.</span>
<a name="l00677"></a>00677 <span class="comment"> */</span>
<a name="l00678"></a><a class="code" href="gss__keyring_8c.html#a18739ff8678825f73625fb44bb07c363">00678</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a18739ff8678825f73625fb44bb07c363">request_key_unlink</a>(<span class="keyword">struct</span> key *key)
<a name="l00679"></a>00679 {
<a name="l00680"></a>00680         <span class="keyword">struct </span>task_struct *tsk = current;
<a name="l00681"></a>00681         <span class="keyword">struct </span>key *ring;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         <span class="keywordflow">switch</span> (<a class="code" href="gss__keyring_8c.html#aca35f9972380c126511c85625daa56bf">key_cred</a>(tsk)-&gt;jit_keyring) {
<a name="l00684"></a>00684         <span class="keywordflow">case</span> KEY_REQKEY_DEFL_DEFAULT:
<a name="l00685"></a>00685         <span class="keywordflow">case</span> KEY_REQKEY_DEFL_THREAD_KEYRING:
<a name="l00686"></a>00686                 ring = key_get(<a class="code" href="gss__keyring_8c.html#aca35f9972380c126511c85625daa56bf">key_cred</a>(tsk)-&gt;thread_keyring);
<a name="l00687"></a>00687                 <span class="keywordflow">if</span> (ring)
<a name="l00688"></a>00688                         <span class="keywordflow">break</span>;
<a name="l00689"></a>00689         <span class="keywordflow">case</span> KEY_REQKEY_DEFL_PROCESS_KEYRING:
<a name="l00690"></a>00690                 ring = key_get(<a class="code" href="gss__keyring_8c.html#a0262ea1aa8b745b7c971ec8fc05f2573">key_tgcred</a>(tsk)-&gt;process_keyring);
<a name="l00691"></a>00691                 <span class="keywordflow">if</span> (ring)
<a name="l00692"></a>00692                         <span class="keywordflow">break</span>;
<a name="l00693"></a>00693         <span class="keywordflow">case</span> KEY_REQKEY_DEFL_SESSION_KEYRING:
<a name="l00694"></a>00694                 rcu_read_lock();
<a name="l00695"></a>00695                 ring = key_get(rcu_dereference(<a class="code" href="gss__keyring_8c.html#a0262ea1aa8b745b7c971ec8fc05f2573">key_tgcred</a>(tsk)
<a name="l00696"></a>00696                                                -&gt;session_keyring));
<a name="l00697"></a>00697                 rcu_read_unlock();
<a name="l00698"></a>00698                 <span class="keywordflow">if</span> (ring)
<a name="l00699"></a>00699                         <span class="keywordflow">break</span>;
<a name="l00700"></a>00700         <span class="keywordflow">case</span> KEY_REQKEY_DEFL_USER_SESSION_KEYRING:
<a name="l00701"></a>00701                 ring = key_get(<a class="code" href="gss__keyring_8c.html#aca35f9972380c126511c85625daa56bf">key_cred</a>(tsk)-&gt;user-&gt;session_keyring);
<a name="l00702"></a>00702                 <span class="keywordflow">break</span>;
<a name="l00703"></a>00703         <span class="keywordflow">case</span> KEY_REQKEY_DEFL_USER_KEYRING:
<a name="l00704"></a>00704                 ring = key_get(<a class="code" href="gss__keyring_8c.html#aca35f9972380c126511c85625daa56bf">key_cred</a>(tsk)-&gt;user-&gt;uid_keyring);
<a name="l00705"></a>00705                 <span class="keywordflow">break</span>;
<a name="l00706"></a>00706         <span class="keywordflow">case</span> KEY_REQKEY_DEFL_GROUP_KEYRING:
<a name="l00707"></a>00707         <span class="keywordflow">default</span>:
<a name="l00708"></a>00708                 <a class="code" href="libcfs__private_8h.html#a08eceadb65d1adcf8c198cff27081d5f">LBUG</a>();
<a name="l00709"></a>00709         }
<a name="l00710"></a>00710 
<a name="l00711"></a>00711         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(ring);
<a name="l00712"></a>00712         key_unlink(ring, key);
<a name="l00713"></a>00713         key_put(ring);
<a name="l00714"></a>00714 }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="keyword">static</span>
<a name="l00717"></a><a class="code" href="gss__keyring_8c.html#a505ff4936cd36347d5bfc58cc0768a52">00717</a> <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> * <a class="code" href="gss__keyring_8c.html#a505ff4936cd36347d5bfc58cc0768a52">gss_sec_lookup_ctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00718"></a>00718                                               <span class="keyword">struct</span> <a class="code" href="structvfs__cred.html">vfs_cred</a> *vcred,
<a name="l00719"></a>00719                                               <span class="keywordtype">int</span> create, <span class="keywordtype">int</span> remove_dead)
<a name="l00720"></a>00720 {
<a name="l00721"></a>00721         <span class="keyword">struct </span><a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a>       *imp = sec-&gt;<a class="code" href="structptlrpc__sec.html#a52e343bfafb7fde35949b51da5125458" title="owning import">ps_import</a>;
<a name="l00722"></a>00722         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr = <a class="code" href="gss__internal_8h.html#ac981fa7c72306e0ea05429d2cceab30e">sec2gsec_keyring</a>(sec);
<a name="l00723"></a>00723         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *ctx = NULL;
<a name="l00724"></a>00724         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>             is_root = 0, create_new = 0;
<a name="l00725"></a>00725         <span class="keyword">struct </span>key              *key;
<a name="l00726"></a>00726         <span class="keywordtype">char</span>                     desc[24];
<a name="l00727"></a>00727         <span class="keywordtype">char</span>                    *coinfo;
<a name="l00728"></a>00728         <span class="keywordtype">int</span>                      coinfo_size;
<a name="l00729"></a>00729         <span class="keywordtype">char</span>                    *co_flags = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00730"></a>00730         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00731"></a>00731 
<a name="l00732"></a>00732         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(imp != NULL);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734         is_root = <a class="code" href="gss__keyring_8c.html#a691d89262884007ebed2ef41bb1b7f12">user_is_root</a>(sec, vcred);
<a name="l00735"></a>00735 
<a name="l00736"></a>00736         <span class="comment">/* a little bit optimization for root context */</span>
<a name="l00737"></a>00737         <span class="keywordflow">if</span> (is_root) {
<a name="l00738"></a>00738                 ctx = <a class="code" href="gss__keyring_8c.html#ab9397cc0b2f63cd8af15f4b65795da0b">sec_lookup_root_ctx_kr</a>(sec);
<a name="l00739"></a>00739                 <span class="comment">/*</span>
<a name="l00740"></a>00740 <span class="comment">                 * Only lookup directly for REVERSE sec, which should</span>
<a name="l00741"></a>00741 <span class="comment">                 * always succeed.</span>
<a name="l00742"></a>00742 <span class="comment">                 */</span>
<a name="l00743"></a>00743                 <span class="keywordflow">if</span> (ctx || <a class="code" href="group__sptlrpc.html#ga46f1b8ed0c826e568a23850f7c929f12">sec_is_reverse</a>(sec))
<a name="l00744"></a>00744                         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(ctx);
<a name="l00745"></a>00745         }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(create != 0);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749         <span class="comment">/* for root context, obtain lock and check again, this time hold</span>
<a name="l00750"></a>00750 <span class="comment">         * the root upcall lock, make sure nobody else populated new root</span>
<a name="l00751"></a>00751 <span class="comment">         * context after last check. */</span>
<a name="l00752"></a>00752         <span class="keywordflow">if</span> (is_root) {
<a name="l00753"></a>00753                 mutex_lock(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa9c28b5fd10b8753446a0ec9c125d15f">gsk_root_uc_lock</a>);
<a name="l00754"></a>00754 
<a name="l00755"></a>00755                 ctx = <a class="code" href="gss__keyring_8c.html#ab9397cc0b2f63cd8af15f4b65795da0b">sec_lookup_root_ctx_kr</a>(sec);
<a name="l00756"></a>00756                 <span class="keywordflow">if</span> (ctx)
<a name="l00757"></a>00757                         <span class="keywordflow">goto</span> out;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759                 <span class="comment">/* update reverse handle for root user */</span>
<a name="l00760"></a>00760                 <a class="code" href="gss__internal_8h.html#a85f066ea8b2a7f30edffdadabbebea52">sec2gsec</a>(sec)-&gt;<a class="code" href="structgss__sec.html#a7e895ffd4c4e9b2ee6e63b8c32752ac1">gs_rvs_hdl</a> = <a class="code" href="gss__internal_8h.html#a0f8e999b492714e5601ad19cfbb0584b">gss_get_next_ctx_index</a>();
<a name="l00761"></a>00761 
<a name="l00762"></a>00762                 <span class="keywordflow">switch</span> (sec-&gt;<a class="code" href="structptlrpc__sec.html#a000fb7123a7686296667a02bdd660393">ps_part</a>) {
<a name="l00763"></a>00763                 <span class="keywordflow">case</span> <a class="code" href="group__sptlrpc.html#ggaceeb8c40afd0179b5b42fc19aa58d177af68497fcb8b6689fe4b17cf2d6596e12">LUSTRE_SP_MDT</a>:
<a name="l00764"></a>00764                         co_flags = <span class="stringliteral">&quot;m&quot;</span>;
<a name="l00765"></a>00765                         <span class="keywordflow">break</span>;
<a name="l00766"></a>00766                 <span class="keywordflow">case</span> <a class="code" href="group__sptlrpc.html#ggaceeb8c40afd0179b5b42fc19aa58d177ae20d2ec76b70b6ab7869fa28fe858e44">LUSTRE_SP_OST</a>:
<a name="l00767"></a>00767                         co_flags = <span class="stringliteral">&quot;o&quot;</span>;
<a name="l00768"></a>00768                         <span class="keywordflow">break</span>;
<a name="l00769"></a>00769                 <span class="keywordflow">case</span> <a class="code" href="group__sptlrpc.html#ggaceeb8c40afd0179b5b42fc19aa58d177a385d69a8f7c6fe4d46363aebea735bf8">LUSTRE_SP_MGC</a>:
<a name="l00770"></a>00770                         co_flags = <span class="stringliteral">&quot;rmo&quot;</span>;
<a name="l00771"></a>00771                         <span class="keywordflow">break</span>;
<a name="l00772"></a>00772                 <span class="keywordflow">case</span> <a class="code" href="group__sptlrpc.html#ggaceeb8c40afd0179b5b42fc19aa58d177ac06a6ccae3176e8855b7f10cdbb4cd5f">LUSTRE_SP_CLI</a>:
<a name="l00773"></a>00773                         co_flags = <span class="stringliteral">&quot;r&quot;</span>;
<a name="l00774"></a>00774                         <span class="keywordflow">break</span>;
<a name="l00775"></a>00775                 <span class="keywordflow">case</span> <a class="code" href="group__sptlrpc.html#ggaceeb8c40afd0179b5b42fc19aa58d177ad580baf746802d4b54738756155e0146">LUSTRE_SP_MGS</a>:
<a name="l00776"></a>00776                 <span class="keywordflow">default</span>:
<a name="l00777"></a>00777                         <a class="code" href="libcfs__private_8h.html#a08eceadb65d1adcf8c198cff27081d5f">LBUG</a>();
<a name="l00778"></a>00778                 }
<a name="l00779"></a>00779         }
<a name="l00780"></a>00780 
<a name="l00781"></a>00781         <span class="comment">/* in case of setuid, key will be constructed as owner of fsuid/fsgid,</span>
<a name="l00782"></a>00782 <span class="comment">         * but we do authentication based on real uid/gid. the key permission</span>
<a name="l00783"></a>00783 <span class="comment">         * bits will be exactly as POS_ALL, so only processes who subscribed</span>
<a name="l00784"></a>00784 <span class="comment">         * this key could have the access, although the quota might be counted</span>
<a name="l00785"></a>00785 <span class="comment">         * on others (fsuid/fsgid).</span>
<a name="l00786"></a>00786 <span class="comment">         *</span>
<a name="l00787"></a>00787 <span class="comment">         * keyring will use fsuid/fsgid as upcall parameters, so we have to</span>
<a name="l00788"></a>00788 <span class="comment">         * encode real uid/gid into callout info.</span>
<a name="l00789"></a>00789 <span class="comment">         */</span>
<a name="l00790"></a>00790 
<a name="l00791"></a>00791         <span class="comment">/* But first we need to make sure the obd type is supported */</span>
<a name="l00792"></a>00792         <span class="keywordflow">if</span> (strcmp(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;<a class="code" href="structobd__device.html#a12f24300000bfbce9cdd752a638c0760">obd_type</a>-&gt;<a class="code" href="structobd__type.html#a43bd9bff60d57948dd0db78df194e7fb">typ_name</a>, <a class="code" href="obd_8h.html#a398c916a3d6d401d2e581d42deaffb45">LUSTRE_MDC_NAME</a>) &amp;&amp;
<a name="l00793"></a>00793             strcmp(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;<a class="code" href="structobd__device.html#a12f24300000bfbce9cdd752a638c0760">obd_type</a>-&gt;<a class="code" href="structobd__type.html#a43bd9bff60d57948dd0db78df194e7fb">typ_name</a>, <a class="code" href="obd_8h.html#a2ae5b0d66c37e995d787f3ed67a050c0">LUSTRE_OSC_NAME</a>) &amp;&amp;
<a name="l00794"></a>00794             strcmp(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;<a class="code" href="structobd__device.html#a12f24300000bfbce9cdd752a638c0760">obd_type</a>-&gt;<a class="code" href="structobd__type.html#a43bd9bff60d57948dd0db78df194e7fb">typ_name</a>, <a class="code" href="obd_8h.html#a9f34bd9dc4c7e1fe45387044d3d67b6a">LUSTRE_MGC_NAME</a>) &amp;&amp;
<a name="l00795"></a>00795             strcmp(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;<a class="code" href="structobd__device.html#a12f24300000bfbce9cdd752a638c0760">obd_type</a>-&gt;<a class="code" href="structobd__type.html#a43bd9bff60d57948dd0db78df194e7fb">typ_name</a>, <a class="code" href="obd_8h.html#a1faaa03c572d6da5becd353da39bf533">LUSTRE_LWP_NAME</a>) &amp;&amp;
<a name="l00796"></a>00796             strcmp(imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;<a class="code" href="structobd__device.html#a12f24300000bfbce9cdd752a638c0760">obd_type</a>-&gt;<a class="code" href="structobd__type.html#a43bd9bff60d57948dd0db78df194e7fb">typ_name</a>, <a class="code" href="obd_8h.html#ac57fca1ca1ef63748cf5c50ad1b7eb45">LUSTRE_OSP_NAME</a>)) {
<a name="l00797"></a>00797                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;obd %s is not a supported device\n&quot;</span>,
<a name="l00798"></a>00798                         imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;<a class="code" href="structobd__device.html#a47f3a5a4e3b9ce7d39282c2aa1058985">obd_name</a>);
<a name="l00799"></a>00799                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, ctx = NULL);
<a name="l00800"></a>00800         }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802         <a class="code" href="gss__keyring_8c.html#a5db44e2620d98ba779b1af994694e16e">construct_key_desc</a>(desc, <span class="keyword">sizeof</span>(desc), sec, vcred-&gt;<a class="code" href="structvfs__cred.html#af7938ab8ff1701fbfea3a3e66c70d66f">vc_uid</a>);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         <span class="comment">/* callout info format:</span>
<a name="l00805"></a>00805 <span class="comment">         * secid:mech:uid:gid:flags:svc_type:peer_nid:target_uuid</span>
<a name="l00806"></a>00806 <span class="comment">         */</span>
<a name="l00807"></a>00807         coinfo_size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structobd__uuid.html">obd_uuid</a>) + MAX_OBD_NAME + 64;
<a name="l00808"></a>00808         <a class="code" href="obd__support_8h.html#a884069f9eb0bef22c424688b5f3fafba">OBD_ALLOC</a>(coinfo, coinfo_size);
<a name="l00809"></a>00809         <span class="keywordflow">if</span> (coinfo == NULL)
<a name="l00810"></a>00810                 <span class="keywordflow">goto</span> out;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812         snprintf(coinfo, coinfo_size, <span class="stringliteral">&quot;%d:%s:%u:%u:%s:%d:&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;:%s:&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a>,
<a name="l00813"></a>00813                  sec-&gt;<a class="code" href="structptlrpc__sec.html#a68829ae9ed27305779a9d5ad9d1b8283" title="unique identifier">ps_id</a>, <a class="code" href="gss__internal_8h.html#a85f066ea8b2a7f30edffdadabbebea52">sec2gsec</a>(sec)-&gt;gs_mech-&gt;gm_name,
<a name="l00814"></a>00814                  vcred-&gt;<a class="code" href="structvfs__cred.html#af7938ab8ff1701fbfea3a3e66c70d66f">vc_uid</a>, vcred-&gt;<a class="code" href="structvfs__cred.html#abeb547265163165b20538636f1adf63b">vc_gid</a>,
<a name="l00815"></a>00815                  co_flags, <a class="code" href="gss__internal_8h.html#a64d61ec1bafb802e279b7c1b2e2b061d">import_to_gss_svc</a>(imp),
<a name="l00816"></a>00816                  imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a71fe23e65708fa8d286db348d2bdf249" title="Remote side nid for this connection.">c_peer</a>.<a class="code" href="structlnet__process__id__t.html#ab0c421c9d4e55b3a45fa62100f20687d" title="node id">nid</a>, imp-&gt;<a class="code" href="structobd__import.html#a8f00f6e006a7f308a71654b3e067a4af" title="obd device for this import">imp_obd</a>-&gt;<a class="code" href="structobd__device.html#a47f3a5a4e3b9ce7d39282c2aa1058985">obd_name</a>,
<a name="l00817"></a>00817                  imp-&gt;<a class="code" href="structobd__import.html#af8d2d08c0e13cf532ff05d8fddccb16e" title="Currently active connection.">imp_connection</a>-&gt;<a class="code" href="structptlrpc__connection.html#a002bdb401d67315c931ff672970178b8" title="Our own lnet nid for this connection.">c_self</a>);
<a name="l00818"></a>00818 
<a name="l00819"></a>00819         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;requesting key for %s\n&quot;</span>, desc);
<a name="l00820"></a>00820 
<a name="l00821"></a>00821         <a class="code" href="gss__keyring_8c.html#a108f3d829b36c1457d818aff66090816">keyring_upcall_lock</a>(gsec_kr);
<a name="l00822"></a>00822         key = request_key(&amp;<a class="code" href="gss__keyring_8c.html#aa9180484e95238702168fa8193f9a797">gss_key_type</a>, desc, coinfo);
<a name="l00823"></a>00823         <a class="code" href="gss__keyring_8c.html#a54b97b8256520663da4a2a27abe3cc5a">keyring_upcall_unlock</a>(gsec_kr);
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         <a class="code" href="obd__support_8h.html#a9bf49373d607ed467488261f133e5e49">OBD_FREE</a>(coinfo, coinfo_size);
<a name="l00826"></a>00826 
<a name="l00827"></a>00827         <span class="keywordflow">if</span> (IS_ERR(key)) {
<a name="l00828"></a>00828                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed request key: %ld\n&quot;</span>, PTR_ERR(key));
<a name="l00829"></a>00829                 <span class="keywordflow">goto</span> out;
<a name="l00830"></a>00830         }
<a name="l00831"></a>00831         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;obtained key %08x for %s\n&quot;</span>, key-&gt;serial, desc);
<a name="l00832"></a>00832 
<a name="l00833"></a>00833         <span class="comment">/* once payload.data was pointed to a ctx, it never changes until</span>
<a name="l00834"></a>00834 <span class="comment">         * we de-associate them; but parallel request_key() may return</span>
<a name="l00835"></a>00835 <span class="comment">         * a key with payload.data == NULL at the same time. so we still</span>
<a name="l00836"></a>00836 <span class="comment">         * need wirtelock of key-&gt;sem to serialize them. */</span>
<a name="l00837"></a>00837         down_write(&amp;key-&gt;sem);
<a name="l00838"></a>00838 
<a name="l00839"></a>00839         ctx = <a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0);
<a name="l00840"></a>00840         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(ctx)) {
<a name="l00841"></a>00841                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt;= 1);
<a name="l00842"></a>00842                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx)-&gt;gck_key == key);
<a name="l00843"></a>00843                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;key-&gt;usage) &gt;= 2);
<a name="l00844"></a>00844 
<a name="l00845"></a>00845                 <span class="comment">/* simply take a ref and return. it&apos;s upper layer&apos;s</span>
<a name="l00846"></a>00846 <span class="comment">                 * responsibility to detect &amp; replace dead ctx. */</span>
<a name="l00847"></a>00847                 atomic_inc(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l00848"></a>00848         } <span class="keywordflow">else</span> {
<a name="l00849"></a>00849                 <span class="comment">/* pre initialization with a cli_ctx. this can&apos;t be done in</span>
<a name="l00850"></a>00850 <span class="comment">                 * key_instantiate() because we&apos;v no enough information</span>
<a name="l00851"></a>00851 <span class="comment">                 * there. */</span>
<a name="l00852"></a>00852                 ctx = <a class="code" href="gss__keyring_8c.html#a618d26f42ae4d0492d02395faedb08dd">ctx_create_kr</a>(sec, vcred);
<a name="l00853"></a>00853                 <span class="keywordflow">if</span> (ctx != NULL) {
<a name="l00854"></a>00854                         <a class="code" href="gss__keyring_8c.html#a9724538fe8f4774ad2366c0d428f3702">ctx_enlist_kr</a>(ctx, is_root, 0);
<a name="l00855"></a>00855                         <a class="code" href="gss__keyring_8c.html#abf8b5969b86eba0b43b721c0260fd316">bind_key_ctx</a>(key, ctx);
<a name="l00856"></a>00856 
<a name="l00857"></a>00857                         <a class="code" href="gss__keyring_8c.html#a3deec10c9d7902fd4d44765fd86418bb">ctx_start_timer_kr</a>(ctx, <a class="code" href="gss__keyring_8c.html#afffe7859f8bdc0060956e7fe5ffb9cc2">KEYRING_UPCALL_TIMEOUT</a>);
<a name="l00858"></a>00858 
<a name="l00859"></a>00859                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;installed key %p &lt;-&gt; ctx %p (sec %p)\n&quot;</span>,
<a name="l00860"></a>00860                                key, ctx, sec);
<a name="l00861"></a>00861                 } <span class="keywordflow">else</span> {
<a name="l00862"></a>00862                         <span class="comment">/* we&apos;d prefer to call key_revoke(), but we more like</span>
<a name="l00863"></a>00863 <span class="comment">                         * to revoke it within this key-&gt;sem locked period. */</span>
<a name="l00864"></a>00864                         <a class="code" href="gss__keyring_8c.html#afb70392389d6aad5dd5d47b522788620">key_revoke_locked</a>(key);
<a name="l00865"></a>00865                 }
<a name="l00866"></a>00866 
<a name="l00867"></a>00867                 create_new = 1;
<a name="l00868"></a>00868         }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         up_write(&amp;key-&gt;sem);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872         <span class="keywordflow">if</span> (is_root &amp;&amp; create_new)
<a name="l00873"></a>00873                 <a class="code" href="gss__keyring_8c.html#a18739ff8678825f73625fb44bb07c363">request_key_unlink</a>(key);
<a name="l00874"></a>00874 
<a name="l00875"></a>00875         key_put(key);
<a name="l00876"></a>00876 out:
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (is_root)
<a name="l00878"></a>00878                 mutex_unlock(&amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#aa9c28b5fd10b8753446a0ec9c125d15f">gsk_root_uc_lock</a>);
<a name="l00879"></a>00879         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(ctx);
<a name="l00880"></a>00880 }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882 <span class="keyword">static</span>
<a name="l00883"></a><a class="code" href="gss__keyring_8c.html#ac6129db720554623b2cc23b0a77f3ec9">00883</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#ac6129db720554623b2cc23b0a77f3ec9">gss_sec_release_ctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00884"></a>00884                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx,
<a name="l00885"></a>00885                             <span class="keywordtype">int</span> sync)
<a name="l00886"></a>00886 {
<a name="l00887"></a>00887         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a4f72ce6853cdfb0253f533a31a1ced54">ps_refcount</a>) &gt; 0);
<a name="l00888"></a>00888         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) == 0);
<a name="l00889"></a>00889         <a class="code" href="gss__keyring_8c.html#a7ec7f153c41487851981b77e6c0d7d3e">ctx_release_kr</a>(ctx, sync);
<a name="l00890"></a>00890 }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892 <span class="comment">/*</span>
<a name="l00893"></a>00893 <span class="comment"> * flush context of normal user, we must resort to keyring itself to find out</span>
<a name="l00894"></a>00894 <span class="comment"> * contexts which belong to me.</span>
<a name="l00895"></a>00895 <span class="comment"> *</span>
<a name="l00896"></a>00896 <span class="comment"> * Note here we suppose only to flush _my_ context, the &quot;uid&quot; will</span>
<a name="l00897"></a>00897 <span class="comment"> * be ignored in the search.</span>
<a name="l00898"></a>00898 <span class="comment"> */</span>
<a name="l00899"></a>00899 <span class="keyword">static</span>
<a name="l00900"></a><a class="code" href="gss__keyring_8c.html#af67e595668a47f10f66694920b40c18b">00900</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#af67e595668a47f10f66694920b40c18b">flush_user_ctx_cache_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00901"></a>00901                              uid_t uid,
<a name="l00902"></a>00902                              <span class="keywordtype">int</span> grace, <span class="keywordtype">int</span> force)
<a name="l00903"></a>00903 {
<a name="l00904"></a>00904         <span class="keyword">struct </span>key              *key;
<a name="l00905"></a>00905         <span class="keywordtype">char</span>                     desc[24];
<a name="l00906"></a>00906 
<a name="l00907"></a>00907         <span class="comment">/* nothing to do for reverse or rootonly sec */</span>
<a name="l00908"></a>00908         <span class="keywordflow">if</span> (<a class="code" href="group__sptlrpc.html#ga46f1b8ed0c826e568a23850f7c929f12">sec_is_reverse</a>(sec) || <a class="code" href="group__sptlrpc.html#ga7341925609139e420a78172f5974f1ee">sec_is_rootonly</a>(sec))
<a name="l00909"></a>00909                 <span class="keywordflow">return</span>;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911         <a class="code" href="gss__keyring_8c.html#a5db44e2620d98ba779b1af994694e16e">construct_key_desc</a>(desc, <span class="keyword">sizeof</span>(desc), sec, uid);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913         <span class="comment">/* there should be only one valid key, but we put it in the</span>
<a name="l00914"></a>00914 <span class="comment">         * loop in case of any weird cases */</span>
<a name="l00915"></a>00915         <span class="keywordflow">for</span> (;;) {
<a name="l00916"></a>00916                 key = request_key(&amp;<a class="code" href="gss__keyring_8c.html#aa9180484e95238702168fa8193f9a797">gss_key_type</a>, desc, NULL);
<a name="l00917"></a>00917                 <span class="keywordflow">if</span> (IS_ERR(key)) {
<a name="l00918"></a>00918                         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;No more key found for current user\n&quot;</span>);
<a name="l00919"></a>00919                         <span class="keywordflow">break</span>;
<a name="l00920"></a>00920                 }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922                 down_write(&amp;key-&gt;sem);
<a name="l00923"></a>00923 
<a name="l00924"></a>00924                 <a class="code" href="gss__keyring_8c.html#a2ede0149fdb88eb781694dd4a97fc39e">kill_key_locked</a>(key);
<a name="l00925"></a>00925 
<a name="l00926"></a>00926                 <span class="comment">/* kill_key_locked() should usually revoke the key, but we</span>
<a name="l00927"></a>00927 <span class="comment">                 * revoke it again to make sure, e.g. some case the key may</span>
<a name="l00928"></a>00928 <span class="comment">                 * not well coupled with a context. */</span>
<a name="l00929"></a>00929                 <a class="code" href="gss__keyring_8c.html#afb70392389d6aad5dd5d47b522788620">key_revoke_locked</a>(key);
<a name="l00930"></a>00930 
<a name="l00931"></a>00931                 up_write(&amp;key-&gt;sem);
<a name="l00932"></a>00932 
<a name="l00933"></a>00933                 <a class="code" href="gss__keyring_8c.html#a18739ff8678825f73625fb44bb07c363">request_key_unlink</a>(key);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935                 key_put(key);
<a name="l00936"></a>00936         }
<a name="l00937"></a>00937 }
<a name="l00938"></a>00938 
<a name="l00939"></a>00939 <span class="comment">/*</span>
<a name="l00940"></a>00940 <span class="comment"> * flush context of root or all, we iterate through the list.</span>
<a name="l00941"></a>00941 <span class="comment"> */</span>
<a name="l00942"></a>00942 <span class="keyword">static</span>
<a name="l00943"></a><a class="code" href="gss__keyring_8c.html#aa2d0300c23fcc08d6f7df59e6c6a17b6">00943</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#aa2d0300c23fcc08d6f7df59e6c6a17b6">flush_spec_ctx_cache_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec, uid_t uid, <span class="keywordtype">int</span> grace,
<a name="l00944"></a>00944                              <span class="keywordtype">int</span> force)
<a name="l00945"></a>00945 {
<a name="l00946"></a>00946         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr;
<a name="l00947"></a>00947         <span class="keyword">struct </span><a class="code" href="structhlist__head.html">hlist_head</a>        freelist = <a class="code" href="group__hlist.html#ga68283f4abad271853d5b25ad697b1b06">HLIST_HEAD_INIT</a>;
<a name="l00948"></a>00948         <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>       __maybe_unused *pos, *<a class="code" href="structhlist__node.html#a915ba19b2ab3aa3f092edc8d5ed98c27">next</a>;
<a name="l00949"></a>00949         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *ctx;
<a name="l00950"></a>00950         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00951"></a>00951 
<a name="l00952"></a>00952         gsec_kr = <a class="code" href="gss__internal_8h.html#ac981fa7c72306e0ea05429d2cceab30e">sec2gsec_keyring</a>(sec);
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         spin_lock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l00955"></a>00955         <a class="code" href="list_8h.html#a89bd1c1d04dc01a4e0ba38e8a6a562d2">cfs_hlist_for_each_entry_safe</a>(ctx, pos, next,
<a name="l00956"></a>00956                                       &amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#ad55cfea8393e100a306a026e8b302ed0">gsk_clist</a>, <a class="code" href="structptlrpc__cli__ctx.html#ae4d570c219d29e547a09ce4c1ff6eb5b">cc_cache</a>) {
<a name="l00957"></a>00957                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 0);
<a name="l00958"></a>00958 
<a name="l00959"></a>00959                 <span class="keywordflow">if</span> (uid != -1 &amp;&amp; uid != ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#ae51eb24729e33c746ad0baa2356d0524">cc_vcred</a>.<a class="code" href="structvfs__cred.html#af7938ab8ff1701fbfea3a3e66c70d66f">vc_uid</a>)
<a name="l00960"></a>00960                         <span class="keywordflow">continue</span>;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962                 <span class="comment">/* at this moment there&apos;s at least 2 base reference:</span>
<a name="l00963"></a>00963 <span class="comment">                 * key association and in-list. */</span>
<a name="l00964"></a>00964                 <span class="keywordflow">if</span> (atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 2) {
<a name="l00965"></a>00965                         <span class="keywordflow">if</span> (!force)
<a name="l00966"></a>00966                                 <span class="keywordflow">continue</span>;
<a name="l00967"></a>00967                         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;flush busy ctx %p(%u-&gt;%s, extra ref %d)\n&quot;</span>,
<a name="l00968"></a>00968                               ctx, ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#ae51eb24729e33c746ad0baa2356d0524">cc_vcred</a>.<a class="code" href="structvfs__cred.html#af7938ab8ff1701fbfea3a3e66c70d66f">vc_uid</a>,
<a name="l00969"></a>00969                               <a class="code" href="group__sptlrpc.html#gafca48f8057fe571c4bfb390c91959ed4">sec2target_str</a>(ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a9c813cb37af100b37e92ec19db663a18">cc_sec</a>),
<a name="l00970"></a>00970                               atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) - 2);
<a name="l00971"></a>00971                 }
<a name="l00972"></a>00972 
<a name="l00973"></a>00973                 set_bit(<a class="code" href="group__sptlrpc.html#gaa3716b7ebd501da999e12c921ceb0acb">PTLRPC_CTX_DEAD_BIT</a>, &amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>);
<a name="l00974"></a>00974                 <span class="keywordflow">if</span> (!grace)
<a name="l00975"></a>00975                         clear_bit(<a class="code" href="group__sptlrpc.html#ga5aae0155a0ccdf50d4b64cb9e8965a47">PTLRPC_CTX_UPTODATE_BIT</a>, &amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>);
<a name="l00976"></a>00976 
<a name="l00977"></a>00977                 atomic_inc(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l00978"></a>00978 
<a name="l00979"></a>00979                 <span class="keywordflow">if</span> (<a class="code" href="gss__keyring_8c.html#a27b5f34d201bd54a9f667f9b4e127c7d">ctx_unlist_kr</a>(ctx, 1)) {
<a name="l00980"></a>00980                         <a class="code" href="group__hlist.html#gad7a242949abf03ff2ae417686a4451cd">hlist_add_head</a>(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#ae4d570c219d29e547a09ce4c1ff6eb5b">cc_cache</a>, &amp;freelist);
<a name="l00981"></a>00981                 } <span class="keywordflow">else</span> {
<a name="l00982"></a>00982                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt;= 2);
<a name="l00983"></a>00983                         atomic_dec(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l00984"></a>00984                 }
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986         spin_unlock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l00987"></a>00987 
<a name="l00988"></a>00988         <a class="code" href="gss__keyring_8c.html#a45eff170e415335c118d4fdaae01c9d2">dispose_ctx_list_kr</a>(&amp;freelist);
<a name="l00989"></a>00989         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00990"></a>00990 }
<a name="l00991"></a>00991 
<a name="l00992"></a>00992 <span class="keyword">static</span>
<a name="l00993"></a><a class="code" href="gss__keyring_8c.html#a17268710fe2fc7c8267e7a054b4d78a6">00993</a> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a17268710fe2fc7c8267e7a054b4d78a6">gss_sec_flush_ctx_cache_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l00994"></a>00994                                uid_t uid, <span class="keywordtype">int</span> grace, <span class="keywordtype">int</span> force)
<a name="l00995"></a>00995 {
<a name="l00996"></a>00996         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;sec %p(%d, nctx %d), uid %d, grace %d, force %d\n&quot;</span>,
<a name="l00999"></a>00999                sec, atomic_read(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a4f72ce6853cdfb0253f533a31a1ced54">ps_refcount</a>),
<a name="l01000"></a>01000                atomic_read(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a9e8ab0f2316d16b984a6452a73df5790" title="statistic only">ps_nctx</a>),
<a name="l01001"></a>01001                uid, grace, force);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003         <span class="keywordflow">if</span> (uid != -1 &amp;&amp; uid != 0)
<a name="l01004"></a>01004                 <a class="code" href="gss__keyring_8c.html#af67e595668a47f10f66694920b40c18b">flush_user_ctx_cache_kr</a>(sec, uid, grace, force);
<a name="l01005"></a>01005         <span class="keywordflow">else</span>
<a name="l01006"></a>01006                 <a class="code" href="gss__keyring_8c.html#aa2d0300c23fcc08d6f7df59e6c6a17b6">flush_spec_ctx_cache_kr</a>(sec, uid, grace, force);
<a name="l01007"></a>01007 
<a name="l01008"></a>01008         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01009"></a>01009 }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 <span class="keyword">static</span>
<a name="l01012"></a><a class="code" href="gss__keyring_8c.html#a4a13ec845f896aee3b14b6687cecb5a5">01012</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a4a13ec845f896aee3b14b6687cecb5a5">gss_sec_gc_ctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec)
<a name="l01013"></a>01013 {
<a name="l01014"></a>01014         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr = <a class="code" href="gss__internal_8h.html#ac981fa7c72306e0ea05429d2cceab30e">sec2gsec_keyring</a>(sec);
<a name="l01015"></a>01015         <span class="keyword">struct </span><a class="code" href="structhlist__head.html">hlist_head</a>       freelist = <a class="code" href="group__hlist.html#ga68283f4abad271853d5b25ad697b1b06">HLIST_HEAD_INIT</a>;
<a name="l01016"></a>01016         <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>       __maybe_unused *pos, *<a class="code" href="structhlist__node.html#a915ba19b2ab3aa3f092edc8d5ed98c27">next</a>;
<a name="l01017"></a>01017         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *ctx;
<a name="l01018"></a>01018         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01019"></a>01019 
<a name="l01020"></a>01020         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;running gc\n&quot;</span>);
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         spin_lock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l01023"></a>01023         <a class="code" href="list_8h.html#a89bd1c1d04dc01a4e0ba38e8a6a562d2">cfs_hlist_for_each_entry_safe</a>(ctx, pos, next,
<a name="l01024"></a>01024                                       &amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#ad55cfea8393e100a306a026e8b302ed0">gsk_clist</a>, <a class="code" href="structptlrpc__cli__ctx.html#ae4d570c219d29e547a09ce4c1ff6eb5b">cc_cache</a>) {
<a name="l01025"></a>01025                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 0);
<a name="l01026"></a>01026 
<a name="l01027"></a>01027                 atomic_inc(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l01028"></a>01028 
<a name="l01029"></a>01029                 <span class="keywordflow">if</span> (<a class="code" href="gss__internal_8h.html#a43452438866819b5296b6d5cf46881aa">cli_ctx_check_death</a>(ctx) &amp;&amp; <a class="code" href="gss__keyring_8c.html#a27b5f34d201bd54a9f667f9b4e127c7d">ctx_unlist_kr</a>(ctx, 1)) {
<a name="l01030"></a>01030                         <a class="code" href="group__hlist.html#gad7a242949abf03ff2ae417686a4451cd">hlist_add_head</a>(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#ae4d570c219d29e547a09ce4c1ff6eb5b">cc_cache</a>, &amp;freelist);
<a name="l01031"></a>01031                         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;unhashed ctx %p\n&quot;</span>, ctx);
<a name="l01032"></a>01032                 } <span class="keywordflow">else</span> {
<a name="l01033"></a>01033                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt;= 2);
<a name="l01034"></a>01034                         atomic_dec(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>);
<a name="l01035"></a>01035                 }
<a name="l01036"></a>01036         }
<a name="l01037"></a>01037         spin_unlock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039         <a class="code" href="gss__keyring_8c.html#a45eff170e415335c118d4fdaae01c9d2">dispose_ctx_list_kr</a>(&amp;freelist);
<a name="l01040"></a>01040         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l01041"></a>01041         <span class="keywordflow">return</span>;
<a name="l01042"></a>01042 }
<a name="l01043"></a>01043 
<a name="l01044"></a>01044 <span class="keyword">static</span>
<a name="l01045"></a><a class="code" href="gss__keyring_8c.html#a2c1310dd9886385dcb9f51d47c0e307b">01045</a> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a2c1310dd9886385dcb9f51d47c0e307b">gss_sec_display_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec, <span class="keyword">struct</span> seq_file *seq)
<a name="l01046"></a>01046 {
<a name="l01047"></a>01047         <span class="keyword">struct </span><a class="code" href="structgss__sec__keyring.html">gss_sec_keyring</a>  *gsec_kr = <a class="code" href="gss__internal_8h.html#ac981fa7c72306e0ea05429d2cceab30e">sec2gsec_keyring</a>(sec);
<a name="l01048"></a>01048         <span class="keyword">struct </span><a class="code" href="structhlist__node.html">hlist_node</a>       __maybe_unused *pos, *<a class="code" href="structhlist__node.html#a915ba19b2ab3aa3f092edc8d5ed98c27">next</a>;
<a name="l01049"></a>01049         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *ctx;
<a name="l01050"></a>01050         <span class="keyword">struct </span><a class="code" href="structgss__cli__ctx.html">gss_cli_ctx</a>      *gctx;
<a name="l01051"></a>01051         time_t                   <a class="code" href="createmany_8c.html#a5602e9c6b2da7a1db11ed8a76d19fde3">now</a> = <a class="code" href="linux-time_8h.html#a4ba86e5720dafea3737a5c9aa6c211c3">cfs_time_current_sec</a>();
<a name="l01052"></a>01052         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01053"></a>01053 
<a name="l01054"></a>01054         spin_lock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l01055"></a>01055         <a class="code" href="list_8h.html#a89bd1c1d04dc01a4e0ba38e8a6a562d2">cfs_hlist_for_each_entry_safe</a>(ctx, pos, next,
<a name="l01056"></a>01056                                       &amp;gsec_kr-&gt;<a class="code" href="structgss__sec__keyring.html#ad55cfea8393e100a306a026e8b302ed0">gsk_clist</a>, cc_cache) {
<a name="l01057"></a>01057                 <span class="keyword">struct </span>key             *key;
<a name="l01058"></a>01058                 <span class="keywordtype">char</span>                    flags_str[40];
<a name="l01059"></a>01059                 <span class="keywordtype">char</span>                    mech[40];
<a name="l01060"></a>01060 
<a name="l01061"></a>01061                 gctx = <a class="code" href="gss__internal_8h.html#a05af0b887e35087790790d31ab623e9a">ctx2gctx</a>(ctx);
<a name="l01062"></a>01062                 key = <a class="code" href="gss__internal_8h.html#a9f0d600a24e06cbd2c7a24d39071d84d">ctx2gctx_keyring</a>(ctx)-&gt;<a class="code" href="structgss__cli__ctx__keyring.html#a47532bb05ad6399ee9989135a39f4c8b">gck_key</a>;
<a name="l01063"></a>01063 
<a name="l01064"></a>01064                 <a class="code" href="gss__internal_8h.html#a86a6d130026d1087c2ba06d898f9a41e">gss_cli_ctx_flags2str</a>(ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>,
<a name="l01065"></a>01065                                       flags_str, <span class="keyword">sizeof</span>(flags_str));
<a name="l01066"></a>01066 
<a name="l01067"></a>01067                 <span class="keywordflow">if</span> (gctx-&gt;<a class="code" href="structgss__cli__ctx.html#acd2614d0b04211586c330aedc1074261">gc_mechctx</a>)
<a name="l01068"></a>01068                         <a class="code" href="gss__api_8h.html#a0afcd2ec18ef71d5be3d3d63e6f2b1b7">lgss_display</a>(gctx-&gt;<a class="code" href="structgss__cli__ctx.html#acd2614d0b04211586c330aedc1074261">gc_mechctx</a>, mech, <span class="keyword">sizeof</span>(mech));
<a name="l01069"></a>01069                 <span class="keywordflow">else</span>
<a name="l01070"></a>01070                         snprintf(mech, <span class="keyword">sizeof</span>(mech), <span class="stringliteral">&quot;N/A&quot;</span>);
<a name="l01071"></a>01071                 mech[<span class="keyword">sizeof</span>(mech) - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01072"></a>01072 
<a name="l01073"></a>01073                 seq_printf(seq, <span class="stringliteral">&quot;%p: uid %u, ref %d, expire %ld(%+ld), fl %s, &quot;</span>
<a name="l01074"></a>01074                            <span class="stringliteral">&quot;seq %d, win %u, key %08x(ref %d), &quot;</span>
<a name="l01075"></a>01075                            <span class="stringliteral">&quot;hdl &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;:&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot;, mech: %s\n&quot;</span>,
<a name="l01076"></a>01076                            ctx, ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#ae51eb24729e33c746ad0baa2356d0524">cc_vcred</a>.<a class="code" href="structvfs__cred.html#af7938ab8ff1701fbfea3a3e66c70d66f">vc_uid</a>,
<a name="l01077"></a>01077                            atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>),
<a name="l01078"></a>01078                            ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a2e29183830176dfb8c6a77839af173ec">cc_expire</a>,
<a name="l01079"></a>01079                            ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a2e29183830176dfb8c6a77839af173ec">cc_expire</a> ?  ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a2e29183830176dfb8c6a77839af173ec">cc_expire</a> - now : 0,
<a name="l01080"></a>01080                            flags_str,
<a name="l01081"></a>01081                            atomic_read(&amp;gctx-&gt;<a class="code" href="structgss__cli__ctx.html#ab648b65a9748c23ca03427606fffda64">gc_seq</a>),
<a name="l01082"></a>01082                            gctx-&gt;<a class="code" href="structgss__cli__ctx.html#a57117068e8bab5673522de1aff43515d">gc_win</a>,
<a name="l01083"></a>01083                            key ? key-&gt;serial : 0,
<a name="l01084"></a>01084                            key ? atomic_read(&amp;key-&gt;usage) : 0,
<a name="l01085"></a>01085                            <a class="code" href="gss__internal_8h.html#a0cf662e3423ecf6383bde8a4a7be62c2">gss_handle_to_u64</a>(&amp;gctx-&gt;<a class="code" href="structgss__cli__ctx.html#ae042fc29dbb9a0c1780843b9fbaa2c64">gc_handle</a>),
<a name="l01086"></a>01086                            <a class="code" href="gss__internal_8h.html#a0cf662e3423ecf6383bde8a4a7be62c2">gss_handle_to_u64</a>(&amp;gctx-&gt;<a class="code" href="structgss__cli__ctx.html#ac3e25dd72f1a8683cad494af7e22fb52">gc_svc_handle</a>),
<a name="l01087"></a>01087                            mech);
<a name="l01088"></a>01088         }
<a name="l01089"></a>01089         spin_unlock(&amp;sec-&gt;<a class="code" href="structptlrpc__sec.html#a569941f0e6e0eb536449fe10c4a9a0cf">ps_lock</a>);
<a name="l01090"></a>01090 
<a name="l01091"></a>01091         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01092"></a>01092 }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 <span class="comment">/****************************************</span>
<a name="l01095"></a>01095 <span class="comment"> * cli_ctx apis                         *</span>
<a name="l01096"></a>01096 <span class="comment"> ****************************************/</span>
<a name="l01097"></a>01097 
<a name="l01098"></a>01098 <span class="keyword">static</span>
<a name="l01099"></a><a class="code" href="gss__keyring_8c.html#a3e586649acc5a369bfe51b9a4441c17a">01099</a> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a3e586649acc5a369bfe51b9a4441c17a">gss_cli_ctx_refresh_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l01100"></a>01100 {
<a name="l01101"></a>01101         <span class="comment">/* upcall is already on the way */</span>
<a name="l01102"></a>01102         <span class="keywordflow">return</span> 0;
<a name="l01103"></a>01103 }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 <span class="keyword">static</span>
<a name="l01106"></a><a class="code" href="gss__keyring_8c.html#a98fe06cb759c09904f0a3993ce1cee92">01106</a> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a98fe06cb759c09904f0a3993ce1cee92">gss_cli_ctx_validate_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx)
<a name="l01107"></a>01107 {
<a name="l01108"></a>01108         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 0);
<a name="l01109"></a>01109         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a9c813cb37af100b37e92ec19db663a18">cc_sec</a>);
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="keywordflow">if</span> (<a class="code" href="gss__internal_8h.html#a43452438866819b5296b6d5cf46881aa">cli_ctx_check_death</a>(ctx)) {
<a name="l01112"></a>01112                 <a class="code" href="gss__keyring_8c.html#abd57eda3f7c92a032a1c5cbac2a29e13">kill_ctx_kr</a>(ctx);
<a name="l01113"></a>01113                 <span class="keywordflow">return</span> 1;
<a name="l01114"></a>01114         }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116         <span class="keywordflow">if</span> (<a class="code" href="group__sptlrpc.html#gaa710a4bc6a37534f426d21b1aa8c4016">cli_ctx_is_ready</a>(ctx))
<a name="l01117"></a>01117                 <span class="keywordflow">return</span> 0;
<a name="l01118"></a>01118         <span class="keywordflow">return</span> 1;
<a name="l01119"></a>01119 }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="keyword">static</span>
<a name="l01122"></a><a class="code" href="gss__keyring_8c.html#ab744636ae5321d67dea2fe66767de106">01122</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#ab744636ae5321d67dea2fe66767de106">gss_cli_ctx_die_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx, <span class="keywordtype">int</span> grace)
<a name="l01123"></a>01123 {
<a name="l01124"></a>01124         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 0);
<a name="l01125"></a>01125         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a9c813cb37af100b37e92ec19db663a18">cc_sec</a>);
<a name="l01126"></a>01126 
<a name="l01127"></a>01127         <a class="code" href="gss__internal_8h.html#a0221581476c9d1e189b27f84ef6227b2">cli_ctx_expire</a>(ctx);
<a name="l01128"></a>01128         <a class="code" href="gss__keyring_8c.html#abd57eda3f7c92a032a1c5cbac2a29e13">kill_ctx_kr</a>(ctx);
<a name="l01129"></a>01129 }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131 <span class="comment">/****************************************</span>
<a name="l01132"></a>01132 <span class="comment"> * (reverse) service                    *</span>
<a name="l01133"></a>01133 <span class="comment"> ****************************************/</span>
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 <span class="comment">/*</span>
<a name="l01136"></a>01136 <span class="comment"> * reverse context could have nothing to do with keyrings. here we still keep</span>
<a name="l01137"></a>01137 <span class="comment"> * the version which bind to a key, for future reference.</span>
<a name="l01138"></a>01138 <span class="comment"> */</span>
<a name="l01139"></a><a class="code" href="gss__keyring_8c.html#abdbd27ad18eaa4b1fd20cbae42b211fb">01139</a> <span class="preprocessor">#define HAVE_REVERSE_CTX_NOKEY</span>
<a name="l01140"></a>01140 <span class="preprocessor"></span>
<a name="l01141"></a>01141 <span class="preprocessor">#ifdef HAVE_REVERSE_CTX_NOKEY</span>
<a name="l01142"></a>01142 <span class="preprocessor"></span>
<a name="l01143"></a>01143 <span class="keyword">static</span>
<a name="l01144"></a><a class="code" href="gss__keyring_8c.html#a57d118b8febccdc110895ea651efbd75">01144</a> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a57d118b8febccdc110895ea651efbd75">sec_install_rctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l01145"></a>01145                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *svc_ctx)
<a name="l01146"></a>01146 {
<a name="l01147"></a>01147         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *cli_ctx;
<a name="l01148"></a>01148         <span class="keyword">struct </span><a class="code" href="structvfs__cred.html">vfs_cred</a>          vcred = { 0, 0 };
<a name="l01149"></a>01149         <span class="keywordtype">int</span>                      rc;
<a name="l01150"></a>01150 
<a name="l01151"></a>01151         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(sec);
<a name="l01152"></a>01152         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svc_ctx);
<a name="l01153"></a>01153 
<a name="l01154"></a>01154         cli_ctx = <a class="code" href="gss__keyring_8c.html#a618d26f42ae4d0492d02395faedb08dd">ctx_create_kr</a>(sec, &amp;vcred);
<a name="l01155"></a>01155         <span class="keywordflow">if</span> (cli_ctx == NULL)
<a name="l01156"></a>01156                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01157"></a>01157 
<a name="l01158"></a>01158         rc = <a class="code" href="gss__internal_8h.html#ae1051f52e0434e77478f3c75778e38ae">gss_copy_rvc_cli_ctx</a>(cli_ctx, svc_ctx);
<a name="l01159"></a>01159         <span class="keywordflow">if</span> (rc) {
<a name="l01160"></a>01160                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed copy reverse cli ctx: %d\n&quot;</span>, rc);
<a name="l01161"></a>01161 
<a name="l01162"></a>01162                 <a class="code" href="gss__keyring_8c.html#a79f4bcc956335d06ad6d1a6e6758eca0">ctx_put_kr</a>(cli_ctx, 1);
<a name="l01163"></a>01163                 <span class="keywordflow">return</span> rc;
<a name="l01164"></a>01164         }
<a name="l01165"></a>01165 
<a name="l01166"></a>01166         <a class="code" href="gss__keyring_8c.html#ac94a4d051ef6cb3a5b270633403627e4">rvs_sec_install_root_ctx_kr</a>(sec, cli_ctx, NULL);
<a name="l01167"></a>01167 
<a name="l01168"></a>01168         <a class="code" href="gss__keyring_8c.html#a79f4bcc956335d06ad6d1a6e6758eca0">ctx_put_kr</a>(cli_ctx, 1);
<a name="l01169"></a>01169 
<a name="l01170"></a>01170         <span class="keywordflow">return</span> 0;
<a name="l01171"></a>01171 }
<a name="l01172"></a>01172 
<a name="l01173"></a>01173 <span class="preprocessor">#else </span><span class="comment">/* ! HAVE_REVERSE_CTX_NOKEY */</span>
<a name="l01174"></a>01174 
<a name="l01175"></a>01175 <span class="keyword">static</span>
<a name="l01176"></a>01176 <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a57d118b8febccdc110895ea651efbd75">sec_install_rctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec,
<a name="l01177"></a>01177                         <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *svc_ctx)
<a name="l01178"></a>01178 {
<a name="l01179"></a>01179         <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a>   *cli_ctx = NULL;
<a name="l01180"></a>01180         <span class="keyword">struct </span>key              *key;
<a name="l01181"></a>01181         <span class="keyword">struct </span><a class="code" href="structvfs__cred.html">vfs_cred</a>          vcred = { 0, 0 };
<a name="l01182"></a>01182         <span class="keywordtype">char</span>                     desc[64];
<a name="l01183"></a>01183         <span class="keywordtype">int</span>                      rc;
<a name="l01184"></a>01184 
<a name="l01185"></a>01185         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(sec);
<a name="l01186"></a>01186         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(svc_ctx);
<a name="l01187"></a>01187         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;called\n&quot;</span>);
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         <a class="code" href="gss__keyring_8c.html#a5db44e2620d98ba779b1af994694e16e">construct_key_desc</a>(desc, <span class="keyword">sizeof</span>(desc), sec, 0);
<a name="l01190"></a>01190 
<a name="l01191"></a>01191         key = key_alloc(&amp;<a class="code" href="gss__keyring_8c.html#aa9180484e95238702168fa8193f9a797">gss_key_type</a>, desc, 0, 0,
<a name="l01192"></a>01192                         KEY_POS_ALL | KEY_USR_ALL, 1);
<a name="l01193"></a>01193         <span class="keywordflow">if</span> (IS_ERR(key)) {
<a name="l01194"></a>01194                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed to alloc key: %ld\n&quot;</span>, PTR_ERR(key));
<a name="l01195"></a>01195                 <span class="keywordflow">return</span> PTR_ERR(key);
<a name="l01196"></a>01196         }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198         rc = key_instantiate_and_link(key, NULL, 0, NULL, NULL);
<a name="l01199"></a>01199         <span class="keywordflow">if</span> (rc) {
<a name="l01200"></a>01200                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed to instantiate key: %d\n&quot;</span>, rc);
<a name="l01201"></a>01201                 <span class="keywordflow">goto</span> err_revoke;
<a name="l01202"></a>01202         }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204         down_write(&amp;key-&gt;sem);
<a name="l01205"></a>01205 
<a name="l01206"></a>01206         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!<a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0));
<a name="l01207"></a>01207 
<a name="l01208"></a>01208         cli_ctx = <a class="code" href="gss__keyring_8c.html#a618d26f42ae4d0492d02395faedb08dd">ctx_create_kr</a>(sec, &amp;vcred);
<a name="l01209"></a>01209         <span class="keywordflow">if</span> (cli_ctx == NULL) {
<a name="l01210"></a>01210                 rc = -ENOMEM;
<a name="l01211"></a>01211                 <span class="keywordflow">goto</span> err_up;
<a name="l01212"></a>01212         }
<a name="l01213"></a>01213 
<a name="l01214"></a>01214         rc = <a class="code" href="gss__internal_8h.html#ae1051f52e0434e77478f3c75778e38ae">gss_copy_rvc_cli_ctx</a>(cli_ctx, svc_ctx);
<a name="l01215"></a>01215         <span class="keywordflow">if</span> (rc) {
<a name="l01216"></a>01216                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed copy reverse cli ctx: %d\n&quot;</span>, rc);
<a name="l01217"></a>01217                 <span class="keywordflow">goto</span> err_put;
<a name="l01218"></a>01218         }
<a name="l01219"></a>01219 
<a name="l01220"></a>01220         <a class="code" href="gss__keyring_8c.html#ac94a4d051ef6cb3a5b270633403627e4">rvs_sec_install_root_ctx_kr</a>(sec, cli_ctx, key);
<a name="l01221"></a>01221 
<a name="l01222"></a>01222         <a class="code" href="gss__keyring_8c.html#a79f4bcc956335d06ad6d1a6e6758eca0">ctx_put_kr</a>(cli_ctx, 1);
<a name="l01223"></a>01223         up_write(&amp;key-&gt;sem);
<a name="l01224"></a>01224 
<a name="l01225"></a>01225         rc = 0;
<a name="l01226"></a>01226         <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;ok!\n&quot;</span>);
<a name="l01227"></a>01227 out:
<a name="l01228"></a>01228         key_put(key);
<a name="l01229"></a>01229         <span class="keywordflow">return</span> rc;
<a name="l01230"></a>01230 
<a name="l01231"></a>01231 err_put:
<a name="l01232"></a>01232         <a class="code" href="gss__keyring_8c.html#a79f4bcc956335d06ad6d1a6e6758eca0">ctx_put_kr</a>(cli_ctx, 1);
<a name="l01233"></a>01233 err_up:
<a name="l01234"></a>01234         up_write(&amp;key-&gt;sem);
<a name="l01235"></a>01235 err_revoke:
<a name="l01236"></a>01236         key_revoke(key);
<a name="l01237"></a>01237         <span class="keywordflow">goto</span> out;
<a name="l01238"></a>01238 }
<a name="l01239"></a>01239 
<a name="l01240"></a>01240 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_REVERSE_CTX_NOKEY */</span>
<a name="l01241"></a>01241 
<a name="l01242"></a>01242 <span class="comment">/****************************************</span>
<a name="l01243"></a>01243 <span class="comment"> * service apis                         *</span>
<a name="l01244"></a>01244 <span class="comment"> ****************************************/</span>
<a name="l01245"></a>01245 
<a name="l01246"></a>01246 <span class="keyword">static</span>
<a name="l01247"></a><a class="code" href="gss__keyring_8c.html#a4e843949cb40706f83c2f8a89f48cac3">01247</a> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a4e843949cb40706f83c2f8a89f48cac3">gss_svc_accept_kr</a>(<span class="keyword">struct</span> <a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a> *req)
<a name="l01248"></a>01248 {
<a name="l01249"></a>01249         <span class="keywordflow">return</span> <a class="code" href="gss__internal_8h.html#af6e1f09236107b4b437cf9df54bec18a">gss_svc_accept</a>(&amp;<a class="code" href="gss__keyring_8c.html#ad4fceaf252b84c6761b2ba9e14eaf50b">gss_policy_keyring</a>, req);
<a name="l01250"></a>01250 }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252 <span class="keyword">static</span>
<a name="l01253"></a><a class="code" href="gss__keyring_8c.html#aebc35641628f2930e1c7c19a8fed89c6">01253</a> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#aebc35641628f2930e1c7c19a8fed89c6">gss_svc_install_rctx_kr</a>(<span class="keyword">struct</span> <a class="code" href="structobd__import.html" title="Defintion of PortalRPC import structure.">obd_import</a> *imp,
<a name="l01254"></a>01254                             <span class="keyword">struct</span> <a class="code" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *svc_ctx)
<a name="l01255"></a>01255 {
<a name="l01256"></a>01256         <span class="keyword">struct </span><a class="code" href="structptlrpc__sec.html" title="The ptlrpc_sec represents the client side ptlrpc security facilities, each obd_import...">ptlrpc_sec</a> *sec;
<a name="l01257"></a>01257         <span class="keywordtype">int</span>                rc;
<a name="l01258"></a>01258 
<a name="l01259"></a>01259         sec = <a class="code" href="group__sptlrpc.html#gaaaacc60ce00e1c012d6a657e285853f6">sptlrpc_import_sec_ref</a>(imp);
<a name="l01260"></a>01260         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(sec);
<a name="l01261"></a>01261 
<a name="l01262"></a>01262         rc = <a class="code" href="gss__keyring_8c.html#a57d118b8febccdc110895ea651efbd75">sec_install_rctx_kr</a>(sec, svc_ctx);
<a name="l01263"></a>01263         <a class="code" href="group__sptlrpc.html#ga7614fad9d6201ee956c2b8c591b63e27">sptlrpc_sec_put</a>(sec);
<a name="l01264"></a>01264 
<a name="l01265"></a>01265         <span class="keywordflow">return</span> rc;
<a name="l01266"></a>01266 }
<a name="l01267"></a>01267 
<a name="l01268"></a>01268 <span class="comment">/****************************************</span>
<a name="l01269"></a>01269 <span class="comment"> * key apis                             *</span>
<a name="l01270"></a>01270 <span class="comment"> ****************************************/</span>
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 <span class="keyword">static</span>
<a name="l01273"></a>01273 <span class="preprocessor">#ifdef HAVE_KEY_TYPE_INSTANTIATE_2ARGS</span>
<a name="l01274"></a>01274 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a4897af60caa950d445177a66b4e02763">gss_kt_instantiate</a>(<span class="keyword">struct</span> key *key, <span class="keyword">struct</span> key_preparsed_payload *prep)
<a name="l01275"></a>01275 {
<a name="l01276"></a>01276         <span class="keyword">const</span> <span class="keywordtype">void</span>     *data = prep-&gt;data;
<a name="l01277"></a>01277         <span class="keywordtype">size_t</span>          datalen = prep-&gt;datalen;
<a name="l01278"></a>01278 <span class="preprocessor">#else</span>
<a name="l01279"></a><a class="code" href="gss__keyring_8c.html#a4897af60caa950d445177a66b4e02763">01279</a> <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a4897af60caa950d445177a66b4e02763">gss_kt_instantiate</a>(<span class="keyword">struct</span> key *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> datalen)
<a name="l01280"></a>01280 {
<a name="l01281"></a>01281 <span class="preprocessor">#endif</span>
<a name="l01282"></a>01282 <span class="preprocessor"></span>        <span class="keywordtype">int</span>             rc;
<a name="l01283"></a>01283         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01284"></a>01284 
<a name="l01285"></a>01285         <span class="keywordflow">if</span> (data != NULL || datalen != 0) {
<a name="l01286"></a>01286                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;invalid: data %p, len %lu\n&quot;</span>, data, (<span class="keywordtype">long</span>)datalen);
<a name="l01287"></a>01287                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-EINVAL);
<a name="l01288"></a>01288         }
<a name="l01289"></a>01289 
<a name="l01290"></a>01290         <span class="keywordflow">if</span> (<a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0)) {
<a name="l01291"></a>01291                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;key already have payload\n&quot;</span>);
<a name="l01292"></a>01292                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-EINVAL);
<a name="l01293"></a>01293         }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295         <span class="comment">/* link the key to session keyring, so following context negotiation</span>
<a name="l01296"></a>01296 <span class="comment">         * rpc fired from user space could find this key. This will be unlinked</span>
<a name="l01297"></a>01297 <span class="comment">         * automatically when upcall processes die.</span>
<a name="l01298"></a>01298 <span class="comment">         *</span>
<a name="l01299"></a>01299 <span class="comment">         * we can&apos;t do this through keyctl from userspace, because the upcall</span>
<a name="l01300"></a>01300 <span class="comment">         * might be neither possessor nor owner of the key (setuid).</span>
<a name="l01301"></a>01301 <span class="comment">         *</span>
<a name="l01302"></a>01302 <span class="comment">         * the session keyring is created upon upcall, and don&apos;t change all</span>
<a name="l01303"></a>01303 <span class="comment">         * the way until upcall finished, so rcu lock is not needed here.</span>
<a name="l01304"></a>01304 <span class="comment">         */</span>
<a name="l01305"></a>01305         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="gss__keyring_8c.html#a0262ea1aa8b745b7c971ec8fc05f2573">key_tgcred</a>(current)-&gt;session_keyring);
<a name="l01306"></a>01306 
<a name="l01307"></a>01307         lockdep_off();
<a name="l01308"></a>01308         rc = key_link(<a class="code" href="gss__keyring_8c.html#a0262ea1aa8b745b7c971ec8fc05f2573">key_tgcred</a>(current)-&gt;session_keyring, key);
<a name="l01309"></a>01309         lockdep_on();
<a name="l01310"></a>01310         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(rc)) {
<a name="l01311"></a>01311                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed to link key %08x to keyring %08x: %d\n&quot;</span>,
<a name="l01312"></a>01312                        key-&gt;serial,
<a name="l01313"></a>01313                        <a class="code" href="gss__keyring_8c.html#a0262ea1aa8b745b7c971ec8fc05f2573">key_tgcred</a>(current)-&gt;session_keyring-&gt;serial, rc);
<a name="l01314"></a>01314                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01315"></a>01315         }
<a name="l01316"></a>01316 
<a name="l01317"></a>01317         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;key %p instantiated, ctx %p\n&quot;</span>, key,
<a name="l01318"></a>01318                <a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0));
<a name="l01319"></a>01319         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01320"></a>01320 }
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 <span class="comment">/*</span>
<a name="l01323"></a>01323 <span class="comment"> * called with key semaphore write locked. it means we can operate</span>
<a name="l01324"></a>01324 <span class="comment"> * on the context without fear of loosing refcount.</span>
<a name="l01325"></a>01325 <span class="comment"> */</span>
<a name="l01326"></a>01326 <span class="keyword">static</span>
<a name="l01327"></a>01327 <span class="preprocessor">#ifdef HAVE_KEY_TYPE_INSTANTIATE_2ARGS</span>
<a name="l01328"></a>01328 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a38f073671dc53a2a9852d1701122ec56">gss_kt_update</a>(<span class="keyword">struct</span> key *key, <span class="keyword">struct</span> key_preparsed_payload *prep)
<a name="l01329"></a>01329 {
<a name="l01330"></a>01330         <span class="keyword">const</span> <span class="keywordtype">void</span>              *data = prep-&gt;data;
<a name="l01331"></a>01331         __u32                    datalen32 = (__u32) prep-&gt;datalen;
<a name="l01332"></a>01332 #<span class="keywordflow">else</span>
<a name="l01333"></a><a class="code" href="gss__keyring_8c.html#a38f073671dc53a2a9852d1701122ec56">01333</a> <span class="keywordtype">int</span> <a class="code" href="gss__keyring_8c.html#a38f073671dc53a2a9852d1701122ec56">gss_kt_update</a>(<span class="keyword">struct</span> key *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> datalen)
<a name="l01334"></a>01334 {
<a name="l01335"></a>01335         __u32                    datalen32 = (__u32) datalen;
<a name="l01336"></a>01336 <span class="preprocessor">#endif</span>
<a name="l01337"></a>01337 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structptlrpc__cli__ctx.html">ptlrpc_cli_ctx</a> *ctx = <a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0);
<a name="l01338"></a>01338         <span class="keyword">struct </span><a class="code" href="structgss__cli__ctx.html">gss_cli_ctx</a>      *gctx;
<a name="l01339"></a>01339         <a class="code" href="structrawobj__s.html">rawobj_t</a>                 tmpobj = <a class="code" href="gss__internal_8h.html#a3ccba81ff05d9ebf33a9555cf662dbbb">RAWOBJ_EMPTY</a>;
<a name="l01340"></a>01340         <span class="keywordtype">int</span>                      rc;
<a name="l01341"></a>01341         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01342"></a>01342 
<a name="l01343"></a>01343         <span class="keywordflow">if</span> (data == NULL || datalen32 == 0) {
<a name="l01344"></a>01344                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;invalid: data %p, len %lu\n&quot;</span>, data, (<span class="keywordtype">long</span>)datalen32);
<a name="l01345"></a>01345                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-EINVAL);
<a name="l01346"></a>01346         }
<a name="l01347"></a>01347 
<a name="l01348"></a>01348         <span class="comment">/* if upcall finished negotiation too fast (mostly likely because</span>
<a name="l01349"></a>01349 <span class="comment">         * of local error happened) and call kt_update(), the ctx</span>
<a name="l01350"></a>01350 <span class="comment">         * might be still NULL. but the key will finally be associate</span>
<a name="l01351"></a>01351 <span class="comment">         * with a context, or be revoked. if key status is fine, return</span>
<a name="l01352"></a>01352 <span class="comment">         * -EAGAIN to allow userspace sleep a while and call again. */</span>
<a name="l01353"></a>01353         <span class="keywordflow">if</span> (ctx == NULL) {
<a name="l01354"></a>01354                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;update too soon: key %p(%x) flags %lx\n&quot;</span>,
<a name="l01355"></a>01355                       key, key-&gt;serial, key-&gt;flags);
<a name="l01356"></a>01356 
<a name="l01357"></a>01357                 rc = key_validate(key);
<a name="l01358"></a>01358                 <span class="keywordflow">if</span> (rc == 0)
<a name="l01359"></a>01359                         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(-EAGAIN);
<a name="l01360"></a>01360                 <span class="keywordflow">else</span>
<a name="l01361"></a>01361                         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l01362"></a>01362         }
<a name="l01363"></a>01363 
<a name="l01364"></a>01364         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(atomic_read(&amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a5261af5e71ac07794a1b23e137d260a1">cc_refcount</a>) &gt; 0);
<a name="l01365"></a>01365         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a9c813cb37af100b37e92ec19db663a18">cc_sec</a>);
<a name="l01366"></a>01366 
<a name="l01367"></a>01367         <a class="code" href="gss__keyring_8c.html#a1b6b0a6d4b0a8b856169e1952ad57c45">ctx_clear_timer_kr</a>(ctx);
<a name="l01368"></a>01368 
<a name="l01369"></a>01369         <span class="comment">/* don&apos;t proceed if already refreshed */</span>
<a name="l01370"></a>01370         <span class="keywordflow">if</span> (<a class="code" href="group__sptlrpc.html#gac7c8b7be9c3bc1a99be63ff25c21d6c0">cli_ctx_is_refreshed</a>(ctx)) {
<a name="l01371"></a>01371                 <a class="code" href="libcfs__debug_8h.html#af03883cada59830b0488595cf5d571a0">CWARN</a>(<span class="stringliteral">&quot;ctx already done refresh\n&quot;</span>);
<a name="l01372"></a>01372                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01373"></a>01373         }
<a name="l01374"></a>01374 
<a name="l01375"></a>01375         <a class="code" href="group__sptlrpc.html#gab9129ba640c50c1a8b7d3e50bfec54f4">sptlrpc_cli_ctx_get</a>(ctx);
<a name="l01376"></a>01376         gctx = <a class="code" href="gss__internal_8h.html#a05af0b887e35087790790d31ab623e9a">ctx2gctx</a>(ctx);
<a name="l01377"></a>01377 
<a name="l01378"></a>01378         rc = <a class="code" href="gss__internal_8h.html#ae49e56d9f16f5ab947b90ada95a1385d">buffer_extract_bytes</a>(&amp;data, &amp;datalen32, &amp;gctx-&gt;<a class="code" href="structgss__cli__ctx.html#a57117068e8bab5673522de1aff43515d">gc_win</a>,
<a name="l01379"></a>01379                                   <span class="keyword">sizeof</span>(gctx-&gt;<a class="code" href="structgss__cli__ctx.html#a57117068e8bab5673522de1aff43515d">gc_win</a>));
<a name="l01380"></a>01380         <span class="keywordflow">if</span> (rc) {
<a name="l01381"></a>01381                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed extract seq_win\n&quot;</span>);
<a name="l01382"></a>01382                 <span class="keywordflow">goto</span> out;
<a name="l01383"></a>01383         }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385         <span class="keywordflow">if</span> (gctx-&gt;<a class="code" href="structgss__cli__ctx.html#a57117068e8bab5673522de1aff43515d">gc_win</a> == 0) {
<a name="l01386"></a>01386                 __u32   nego_rpc_err, nego_gss_err;
<a name="l01387"></a>01387 
<a name="l01388"></a>01388                 rc = <a class="code" href="gss__internal_8h.html#ae49e56d9f16f5ab947b90ada95a1385d">buffer_extract_bytes</a>(&amp;data, &amp;datalen32, &amp;nego_rpc_err,
<a name="l01389"></a>01389                                           <span class="keyword">sizeof</span>(nego_rpc_err));
<a name="l01390"></a>01390                 <span class="keywordflow">if</span> (rc) {
<a name="l01391"></a>01391                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed to extrace rpc rc\n&quot;</span>);
<a name="l01392"></a>01392                         <span class="keywordflow">goto</span> out;
<a name="l01393"></a>01393                 }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395                 rc = <a class="code" href="gss__internal_8h.html#ae49e56d9f16f5ab947b90ada95a1385d">buffer_extract_bytes</a>(&amp;data, &amp;datalen32, &amp;nego_gss_err,
<a name="l01396"></a>01396                                           <span class="keyword">sizeof</span>(nego_gss_err));
<a name="l01397"></a>01397                 <span class="keywordflow">if</span> (rc) {
<a name="l01398"></a>01398                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed to extrace gss rc\n&quot;</span>);
<a name="l01399"></a>01399                         <span class="keywordflow">goto</span> out;
<a name="l01400"></a>01400                 }
<a name="l01401"></a>01401 
<a name="l01402"></a>01402                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;negotiation: rpc err %d, gss err %x\n&quot;</span>,
<a name="l01403"></a>01403                        nego_rpc_err, nego_gss_err);
<a name="l01404"></a>01404 
<a name="l01405"></a>01405                 rc = nego_rpc_err ? nego_rpc_err : -EACCES;
<a name="l01406"></a>01406         } <span class="keywordflow">else</span> {
<a name="l01407"></a>01407                 rc = <a class="code" href="gss__internal_8h.html#ab2b57ef95034cebea5598bf29f3fc447">rawobj_extract_local_alloc</a>(&amp;gctx-&gt;<a class="code" href="structgss__cli__ctx.html#ae042fc29dbb9a0c1780843b9fbaa2c64">gc_handle</a>,
<a name="l01408"></a>01408                                                 (__u32 **) &amp;data, &amp;datalen32);
<a name="l01409"></a>01409                 <span class="keywordflow">if</span> (rc) {
<a name="l01410"></a>01410                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed extract handle\n&quot;</span>);
<a name="l01411"></a>01411                         <span class="keywordflow">goto</span> out;
<a name="l01412"></a>01412                 }
<a name="l01413"></a>01413 
<a name="l01414"></a>01414                 rc = <a class="code" href="gss__internal_8h.html#a819237b1e041873a729c7b85d13c3484">rawobj_extract_local</a>(&amp;tmpobj, (__u32 **) &amp;data,&amp;datalen32);
<a name="l01415"></a>01415                 <span class="keywordflow">if</span> (rc) {
<a name="l01416"></a>01416                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed extract mech\n&quot;</span>);
<a name="l01417"></a>01417                         <span class="keywordflow">goto</span> out;
<a name="l01418"></a>01418                 }
<a name="l01419"></a>01419 
<a name="l01420"></a>01420                 rc = <a class="code" href="gss__api_8h.html#a2c31d4997df726bf273ca0429cacc778">lgss_import_sec_context</a>(&amp;tmpobj,
<a name="l01421"></a>01421                                              <a class="code" href="gss__internal_8h.html#a85f066ea8b2a7f30edffdadabbebea52">sec2gsec</a>(ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#a9c813cb37af100b37e92ec19db663a18">cc_sec</a>)-&gt;<a class="code" href="structgss__sec.html#a4f4ec0b2ecc92a3fa168efcc5195d93b">gs_mech</a>,
<a name="l01422"></a>01422                                              &amp;gctx-&gt;<a class="code" href="structgss__cli__ctx.html#acd2614d0b04211586c330aedc1074261">gc_mechctx</a>);
<a name="l01423"></a>01423                 <span class="keywordflow">if</span> (rc != <a class="code" href="gss__err_8h.html#abee8408a17073f0514e0578a23b93e09">GSS_S_COMPLETE</a>)
<a name="l01424"></a>01424                         <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed import context\n&quot;</span>);
<a name="l01425"></a>01425                 <span class="keywordflow">else</span>
<a name="l01426"></a>01426                         rc = 0;
<a name="l01427"></a>01427         }
<a name="l01428"></a>01428 out:
<a name="l01429"></a>01429         <span class="comment">/* we don&apos;t care what current status of this ctx, even someone else</span>
<a name="l01430"></a>01430 <span class="comment">         * is operating on the ctx at the same time. we just add up our own</span>
<a name="l01431"></a>01431 <span class="comment">         * opinions here. */</span>
<a name="l01432"></a>01432         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01433"></a>01433                 <a class="code" href="gss__internal_8h.html#a76fcb27561cf70c27aa394d4758ccaec">gss_cli_ctx_uptodate</a>(gctx);
<a name="l01434"></a>01434         } <span class="keywordflow">else</span> {
<a name="l01435"></a>01435                 <span class="comment">/* this will also revoke the key. has to be done before</span>
<a name="l01436"></a>01436 <span class="comment">                 * wakeup waiters otherwise they can find the stale key */</span>
<a name="l01437"></a>01437                 <a class="code" href="gss__keyring_8c.html#a2ede0149fdb88eb781694dd4a97fc39e">kill_key_locked</a>(key);
<a name="l01438"></a>01438 
<a name="l01439"></a>01439                 <a class="code" href="gss__internal_8h.html#a0221581476c9d1e189b27f84ef6227b2">cli_ctx_expire</a>(ctx);
<a name="l01440"></a>01440 
<a name="l01441"></a>01441                 <span class="keywordflow">if</span> (rc != -ERESTART)
<a name="l01442"></a>01442                         set_bit(<a class="code" href="group__sptlrpc.html#ga0b7bd0230dc3d10ba50a6e32afc81a8d">PTLRPC_CTX_ERROR_BIT</a>, &amp;ctx-&gt;<a class="code" href="structptlrpc__cli__ctx.html#abf3100fe0833d421407f697e49372021">cc_flags</a>);
<a name="l01443"></a>01443         }
<a name="l01444"></a>01444 
<a name="l01445"></a>01445         <span class="comment">/* let user space think it&apos;s a success */</span>
<a name="l01446"></a>01446         <a class="code" href="group__sptlrpc.html#ga69f6e7f870c1215e81c9e939d790ae3b">sptlrpc_cli_ctx_put</a>(ctx, 1);
<a name="l01447"></a>01447         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l01448"></a>01448 }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 <span class="preprocessor">#ifndef HAVE_KEY_MATCH_DATA</span>
<a name="l01451"></a>01451 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01452"></a><a class="code" href="gss__keyring_8c.html#aed9d6a6b56df58e528597f23b2c3834a">01452</a> <a class="code" href="gss__keyring_8c.html#aed9d6a6b56df58e528597f23b2c3834a">gss_kt_match</a>(<span class="keyword">const</span> <span class="keyword">struct</span> key *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *desc)
<a name="l01453"></a>01453 {
<a name="l01454"></a>01454         <span class="keywordflow">return</span> strcmp(key-&gt;description, (<span class="keyword">const</span> <span class="keywordtype">char</span> *) desc) == 0 &amp;&amp;
<a name="l01455"></a>01455                 !test_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags);
<a name="l01456"></a>01456 }
<a name="l01457"></a>01457 <span class="preprocessor">#else </span><span class="comment">/* ! HAVE_KEY_MATCH_DATA */</span>
<a name="l01458"></a>01458 <span class="keyword">static</span> <span class="keywordtype">bool</span>
<a name="l01459"></a>01459 <a class="code" href="gss__keyring_8c.html#aed9d6a6b56df58e528597f23b2c3834a">gss_kt_match</a>(<span class="keyword">const</span> <span class="keyword">struct</span> key *key, <span class="keyword">const</span> <span class="keyword">struct</span> key_match_data *match_data)
<a name="l01460"></a>01460 {
<a name="l01461"></a>01461         <span class="keyword">const</span> <span class="keywordtype">char</span> *desc = match_data-&gt;raw_data;
<a name="l01462"></a>01462 
<a name="l01463"></a>01463         <span class="keywordflow">return</span> strcmp(key-&gt;description, desc) == 0 &amp;&amp;
<a name="l01464"></a>01464                 !test_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags);
<a name="l01465"></a>01465 }
<a name="l01466"></a>01466 
<a name="l01467"></a>01467 <span class="comment">/*</span>
<a name="l01468"></a>01468 <span class="comment"> * Preparse the match criterion.</span>
<a name="l01469"></a>01469 <span class="comment"> */</span>
<a name="l01470"></a>01470 <span class="keyword">static</span> <span class="keywordtype">int</span> gss_kt_match_preparse(<span class="keyword">struct</span> key_match_data *match_data)
<a name="l01471"></a>01471 {
<a name="l01472"></a>01472         match_data-&gt;lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT;
<a name="l01473"></a>01473         match_data-&gt;cmp = <a class="code" href="gss__keyring_8c.html#aed9d6a6b56df58e528597f23b2c3834a">gss_kt_match</a>;
<a name="l01474"></a>01474         <span class="keywordflow">return</span> 0;
<a name="l01475"></a>01475 }
<a name="l01476"></a>01476 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_KEY_MATCH_DATA */</span>
<a name="l01477"></a>01477 
<a name="l01478"></a>01478 <span class="keyword">static</span>
<a name="l01479"></a><a class="code" href="gss__keyring_8c.html#ae2fa01a6a043685630e39d859f07b8a7">01479</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#ae2fa01a6a043685630e39d859f07b8a7">gss_kt_destroy</a>(<span class="keyword">struct</span> key *key)
<a name="l01480"></a>01480 {
<a name="l01481"></a>01481         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01482"></a>01482         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!<a class="code" href="gss__keyring_8c.html#adb5a33a52512d8e2bd78588120cfc313">key_get_payload</a>(key, 0));
<a name="l01483"></a>01483         <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a782d79a71e858aed966ca4188b6b0e7a">D_SEC</a>, <span class="stringliteral">&quot;destroy key %p\n&quot;</span>, key);
<a name="l01484"></a>01484         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l01485"></a>01485 }
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 <span class="keyword">static</span>
<a name="l01488"></a><a class="code" href="gss__keyring_8c.html#a29cabc3188968b4f7b27d11b5f4eda9b">01488</a> <span class="keywordtype">void</span> <a class="code" href="gss__keyring_8c.html#a29cabc3188968b4f7b27d11b5f4eda9b">gss_kt_describe</a>(<span class="keyword">const</span> <span class="keyword">struct</span> key *key, <span class="keyword">struct</span> seq_file *s)
<a name="l01489"></a>01489 {
<a name="l01490"></a>01490         <span class="keywordflow">if</span> (key-&gt;description == NULL)
<a name="l01491"></a>01491                 seq_puts(s, <span class="stringliteral">&quot;[null]&quot;</span>);
<a name="l01492"></a>01492         <span class="keywordflow">else</span>
<a name="l01493"></a>01493                 seq_puts(s, key-&gt;description);
<a name="l01494"></a>01494 }
<a name="l01495"></a>01495 
<a name="l01496"></a>01496 <span class="keyword">static</span> <span class="keyword">struct </span>key_type <a class="code" href="gss__keyring_8c.html#aa9180484e95238702168fa8193f9a797">gss_key_type</a> =
<a name="l01497"></a>01497 {
<a name="l01498"></a>01498         .name           = <span class="stringliteral">&quot;lgssc&quot;</span>,
<a name="l01499"></a>01499         .def_datalen    = 0,
<a name="l01500"></a>01500         .instantiate    = <a class="code" href="gss__keyring_8c.html#a4897af60caa950d445177a66b4e02763">gss_kt_instantiate</a>,
<a name="l01501"></a>01501         .update         = <a class="code" href="gss__keyring_8c.html#a38f073671dc53a2a9852d1701122ec56">gss_kt_update</a>,
<a name="l01502"></a>01502 <span class="preprocessor">#ifdef HAVE_KEY_MATCH_DATA</span>
<a name="l01503"></a>01503 <span class="preprocessor"></span>        .match_preparse = gss_kt_match_preparse,
<a name="l01504"></a>01504 <span class="preprocessor">#else</span>
<a name="l01505"></a>01505 <span class="preprocessor"></span>        .match          = <a class="code" href="gss__keyring_8c.html#aed9d6a6b56df58e528597f23b2c3834a">gss_kt_match</a>,
<a name="l01506"></a>01506 <span class="preprocessor">#endif</span>
<a name="l01507"></a>01507 <span class="preprocessor"></span>        .destroy        = <a class="code" href="gss__keyring_8c.html#ae2fa01a6a043685630e39d859f07b8a7">gss_kt_destroy</a>,
<a name="l01508"></a>01508         .describe       = <a class="code" href="gss__keyring_8c.html#a29cabc3188968b4f7b27d11b5f4eda9b">gss_kt_describe</a>,
<a name="l01509"></a>01509 };
<a name="l01510"></a>01510 
<a name="l01511"></a>01511 <span class="comment">/****************************************</span>
<a name="l01512"></a>01512 <span class="comment"> * lustre gss keyring policy            *</span>
<a name="l01513"></a>01513 <span class="comment"> ****************************************/</span>
<a name="l01514"></a>01514 
<a name="l01515"></a>01515 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__ctx__ops.html">ptlrpc_ctx_ops</a> <a class="code" href="gss__keyring_8c.html#abf4771e7b17fb63b063a5fd7b7897efd">gss_keyring_ctxops</a> = {
<a name="l01516"></a>01516         .<a class="code" href="structptlrpc__ctx__ops.html#a01fd4f091d29feea575abfe2253cebc9" title="To determine whether it&amp;#39;s suitable to use the ctx for vcred.">match</a>                  = <a class="code" href="gss__internal_8h.html#a7d4c3436a0993e70fd4d85a4720ce3fe">gss_cli_ctx_match</a>,
<a name="l01517"></a>01517         .refresh                = <a class="code" href="gss__keyring_8c.html#a3e586649acc5a369bfe51b9a4441c17a">gss_cli_ctx_refresh_kr</a>,
<a name="l01518"></a>01518         .validate               = <a class="code" href="gss__keyring_8c.html#a98fe06cb759c09904f0a3993ce1cee92">gss_cli_ctx_validate_kr</a>,
<a name="l01519"></a>01519         .die                    = <a class="code" href="gss__keyring_8c.html#ab744636ae5321d67dea2fe66767de106">gss_cli_ctx_die_kr</a>,
<a name="l01520"></a>01520         .sign                   = <a class="code" href="gss__internal_8h.html#a44cabfb5eae388e35bd80f54163e2de2">gss_cli_ctx_sign</a>,
<a name="l01521"></a>01521         .verify                 = <a class="code" href="gss__internal_8h.html#a06963f5c7a48bd076af975b525838a8f">gss_cli_ctx_verify</a>,
<a name="l01522"></a>01522         .seal                   = <a class="code" href="gss__internal_8h.html#a66350a143a4db3b0a7a9c38204f4ea21">gss_cli_ctx_seal</a>,
<a name="l01523"></a>01523         .unseal                 = <a class="code" href="gss__internal_8h.html#a138fabb1ff47eb6f9ee4f8d89ef0a31f">gss_cli_ctx_unseal</a>,
<a name="l01524"></a>01524         .wrap_bulk              = <a class="code" href="gss__bulk_8c.html#abc9fc5cb4a0d66bb0730d948b499362a">gss_cli_ctx_wrap_bulk</a>,
<a name="l01525"></a>01525         .unwrap_bulk            = <a class="code" href="gss__bulk_8c.html#a15815684ab050e5a07506c009d77af44">gss_cli_ctx_unwrap_bulk</a>,
<a name="l01526"></a>01526 };
<a name="l01527"></a>01527 
<a name="l01528"></a><a class="code" href="gss__keyring_8c.html#a2b34ebe91af1d3df8f3920fced88328b">01528</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__cops.html" title="client side policy operation vector.">ptlrpc_sec_cops</a> <a class="code" href="gss__keyring_8c.html#a2b34ebe91af1d3df8f3920fced88328b">gss_sec_keyring_cops</a> = {
<a name="l01529"></a>01529         .<a class="code" href="structptlrpc__sec__cops.html#a8bf54ba0627dde53dbce14fd8ddf1808" title="Given an imp, create and initialize a ptlrpc_sec structure.">create_sec</a>             = <a class="code" href="gss__keyring_8c.html#aad20b6d21cebcad1912409a00e644680">gss_sec_create_kr</a>,
<a name="l01530"></a>01530         .destroy_sec            = <a class="code" href="gss__keyring_8c.html#ae5a3328ecbb8e49fb839a6d50bf1f8a5">gss_sec_destroy_kr</a>,
<a name="l01531"></a>01531         .kill_sec               = <a class="code" href="gss__internal_8h.html#ac32200df78f9c91e30d9a815e4a6766c">gss_sec_kill</a>,
<a name="l01532"></a>01532         .lookup_ctx             = <a class="code" href="gss__keyring_8c.html#a505ff4936cd36347d5bfc58cc0768a52">gss_sec_lookup_ctx_kr</a>,
<a name="l01533"></a>01533         .release_ctx            = <a class="code" href="gss__keyring_8c.html#ac6129db720554623b2cc23b0a77f3ec9">gss_sec_release_ctx_kr</a>,
<a name="l01534"></a>01534         .flush_ctx_cache        = <a class="code" href="gss__keyring_8c.html#a17268710fe2fc7c8267e7a054b4d78a6">gss_sec_flush_ctx_cache_kr</a>,
<a name="l01535"></a>01535         .gc_ctx                 = <a class="code" href="gss__keyring_8c.html#a4a13ec845f896aee3b14b6687cecb5a5">gss_sec_gc_ctx_kr</a>,
<a name="l01536"></a>01536         .install_rctx           = <a class="code" href="gss__internal_8h.html#aa5b20499d0da6a6ad5e2b67fafad10ee">gss_sec_install_rctx</a>,
<a name="l01537"></a>01537         .alloc_reqbuf           = <a class="code" href="gss__internal_8h.html#a790db4923bc126ade067f3a42c85ec37">gss_alloc_reqbuf</a>,
<a name="l01538"></a>01538         .free_reqbuf            = <a class="code" href="gss__internal_8h.html#ae0d2dc87ab5dced59080c99e48412579">gss_free_reqbuf</a>,
<a name="l01539"></a>01539         .alloc_repbuf           = <a class="code" href="gss__internal_8h.html#a2122d6a74dbfbfeaf8e33dde73f5d67d">gss_alloc_repbuf</a>,
<a name="l01540"></a>01540         .free_repbuf            = <a class="code" href="gss__internal_8h.html#a865d6db82f15ac488e72d6f25f29b585">gss_free_repbuf</a>,
<a name="l01541"></a>01541         .enlarge_reqbuf         = <a class="code" href="gss__internal_8h.html#af2276f33c9fca9b062941bd2921a798c">gss_enlarge_reqbuf</a>,
<a name="l01542"></a>01542         .display                = <a class="code" href="gss__keyring_8c.html#a2c1310dd9886385dcb9f51d47c0e307b">gss_sec_display_kr</a>,
<a name="l01543"></a>01543 };
<a name="l01544"></a>01544 
<a name="l01545"></a><a class="code" href="gss__keyring_8c.html#abda4023ad5dba0314adf8b4a234033eb">01545</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__sops.html" title="server side policy operation vector.">ptlrpc_sec_sops</a> <a class="code" href="gss__keyring_8c.html#abda4023ad5dba0314adf8b4a234033eb">gss_sec_keyring_sops</a> = {
<a name="l01546"></a>01546         .<a class="code" href="structptlrpc__sec__sops.html#a2a593984c53aea5425bc29f6ede99144" title="verify an incoming request.">accept</a>                 = <a class="code" href="gss__keyring_8c.html#a4e843949cb40706f83c2f8a89f48cac3">gss_svc_accept_kr</a>,
<a name="l01547"></a>01547         .invalidate_ctx         = <a class="code" href="gss__internal_8h.html#a65a2fcf20b33d6a9bf89b27963ea7852">gss_svc_invalidate_ctx</a>,
<a name="l01548"></a>01548         .alloc_rs               = <a class="code" href="gss__internal_8h.html#abd29c9ffb7d0c9cc19ca1e3b1c4a970c">gss_svc_alloc_rs</a>,
<a name="l01549"></a>01549         .authorize              = <a class="code" href="gss__internal_8h.html#aa659134e6e34ca30e85dc652a408d7fc">gss_svc_authorize</a>,
<a name="l01550"></a>01550         .free_rs                = <a class="code" href="gss__internal_8h.html#a065898e49f883619f2b5cde15af2bd72">gss_svc_free_rs</a>,
<a name="l01551"></a>01551         .free_ctx               = <a class="code" href="gss__internal_8h.html#a6f07334c490938a3644ceaaaeca8c1dc">gss_svc_free_ctx</a>,
<a name="l01552"></a>01552         .prep_bulk              = <a class="code" href="gss__bulk_8c.html#ab28eaefa1ab987d3ab01d040e0babfa3">gss_svc_prep_bulk</a>,
<a name="l01553"></a>01553         .unwrap_bulk            = <a class="code" href="gss__bulk_8c.html#ad5f4894d4323e35fa6f9934bd6141e1e">gss_svc_unwrap_bulk</a>,
<a name="l01554"></a>01554         .wrap_bulk              = <a class="code" href="gss__bulk_8c.html#ad475a21881c6727d0700e6e3d4548fb4">gss_svc_wrap_bulk</a>,
<a name="l01555"></a>01555         .install_rctx           = <a class="code" href="gss__keyring_8c.html#aebc35641628f2930e1c7c19a8fed89c6">gss_svc_install_rctx_kr</a>,
<a name="l01556"></a>01556 };
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structptlrpc__sec__policy.html">ptlrpc_sec_policy</a> <a class="code" href="gss__keyring_8c.html#ad4fceaf252b84c6761b2ba9e14eaf50b">gss_policy_keyring</a> = {
<a name="l01559"></a>01559         .<a class="code" href="structptlrpc__sec__policy.html#a2a88fe8fab20af38bf133e5327810424">sp_owner</a>               = THIS_MODULE,
<a name="l01560"></a>01560         .sp_name                = <span class="stringliteral">&quot;gss.keyring&quot;</span>,
<a name="l01561"></a>01561         .sp_policy              = <a class="code" href="group__flavor.html#gga37942381334c943a7e6967f08864cfb4ac61d097d7d5862d0e28dff56626501b7">SPTLRPC_POLICY_GSS</a>,
<a name="l01562"></a>01562         .sp_cops                = &amp;gss_sec_keyring_cops,
<a name="l01563"></a>01563         .sp_sops                = &amp;gss_sec_keyring_sops,
<a name="l01564"></a>01564 };
<a name="l01565"></a>01565 
<a name="l01566"></a>01566 
<a name="l01567"></a><a class="code" href="gss__keyring_8c.html#afefd9a176e298f878432b480ad2a5c4a">01567</a> <span class="keywordtype">int</span> __init <a class="code" href="gss__keyring_8c.html#afefd9a176e298f878432b480ad2a5c4a">gss_init_keyring</a>(<span class="keywordtype">void</span>)
<a name="l01568"></a>01568 {
<a name="l01569"></a>01569         <span class="keywordtype">int</span> rc;
<a name="l01570"></a>01570 
<a name="l01571"></a>01571         rc = register_key_type(&amp;gss_key_type);
<a name="l01572"></a>01572         <span class="keywordflow">if</span> (rc) {
<a name="l01573"></a>01573                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;failed to register keyring type: %d\n&quot;</span>, rc);
<a name="l01574"></a>01574                 <span class="keywordflow">return</span> rc;
<a name="l01575"></a>01575         }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577         rc = <a class="code" href="group__sptlrpc.html#ga1a05c039cd87056cf638e2051cf3fe83">sptlrpc_register_policy</a>(&amp;gss_policy_keyring);
<a name="l01578"></a>01578         <span class="keywordflow">if</span> (rc) {
<a name="l01579"></a>01579                 unregister_key_type(&amp;gss_key_type);
<a name="l01580"></a>01580                 <span class="keywordflow">return</span> rc;
<a name="l01581"></a>01581         }
<a name="l01582"></a>01582 
<a name="l01583"></a>01583         <span class="keywordflow">return</span> 0;
<a name="l01584"></a>01584 }
<a name="l01585"></a>01585 
<a name="l01586"></a><a class="code" href="gss__keyring_8c.html#ae4acfdd1de6b1f7ecbe6070c4725ceb4">01586</a> <span class="keywordtype">void</span> __exit <a class="code" href="gss__keyring_8c.html#ae4acfdd1de6b1f7ecbe6070c4725ceb4">gss_exit_keyring</a>(<span class="keywordtype">void</span>)
<a name="l01587"></a>01587 {
<a name="l01588"></a>01588         unregister_key_type(&amp;gss_key_type);
<a name="l01589"></a>01589         <a class="code" href="group__sptlrpc.html#gaed742582f21f7873e14c565bbbf25ff2">sptlrpc_unregister_policy</a>(&amp;gss_policy_keyring);
<a name="l01590"></a>01590 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:42 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
