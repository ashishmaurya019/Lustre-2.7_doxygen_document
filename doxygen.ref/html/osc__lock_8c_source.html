<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/osc/osc_lock.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lustre/osc/osc_lock.c</h1><a href="osc__lock_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * Implementation of cl_lock for OSC layer.</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> *   Author: Nikita Danilov &lt;nikita.danilov@sun.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> *   Author: Jinshan Xiong &lt;jinshan.xiong@intel.com&gt;</span>
<a name="l00040"></a>00040 <span class="comment"> */</span>
<a name="l00041"></a>00041 
<a name="l00042"></a><a class="code" href="osc__lock_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">00042</a> <span class="preprocessor">#define DEBUG_SUBSYSTEM S_OSC</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;<a class="code" href="libcfs_8h.html">libcfs/libcfs.h</a>&gt;</span>
<a name="l00045"></a>00045 <span class="comment">/* fid_build_reg_res_name() */</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;<a class="code" href="lustre__fid_8h.html">lustre_fid.h</a>&gt;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="osc__cl__internal_8h.html">osc_cl_internal.h</a>&quot;</span>
<a name="l00049"></a>00049 
<a name="l00054"></a>00054 <span class="comment">/*****************************************************************************</span>
<a name="l00055"></a>00055 <span class="comment"> *</span>
<a name="l00056"></a>00056 <span class="comment"> * Type conversions.</span>
<a name="l00057"></a>00057 <span class="comment"> *</span>
<a name="l00058"></a>00058 <span class="comment"> */</span>
<a name="l00059"></a>00059 
<a name="l00060"></a><a class="code" href="group__osc.html#gaf69bf16bf23d5ce82362b480fcb0a331">00060</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__lock__operations.html">cl_lock_operations</a> <a class="code" href="group__osc.html#gaf69bf16bf23d5ce82362b480fcb0a331">osc_lock_ops</a>;
<a name="l00061"></a><a class="code" href="group__osc.html#gae177dc16a77b0406ec3645ad1725734d">00061</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__lock__operations.html">cl_lock_operations</a> <a class="code" href="group__osc.html#gae177dc16a77b0406ec3645ad1725734d">osc_lock_lockless_ops</a>;
<a name="l00062"></a>00062 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gae950ceda261ffba5e5cfd891375e866d" title="Determine if the lock should be converted into a lockless lock.">osc_lock_to_lockless</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00063"></a>00063                                  <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *ols, <span class="keywordtype">int</span> force);
<a name="l00064"></a>00064 
<a name="l00065"></a><a class="code" href="group__osc.html#gaa565e6849b165c1b13f243a672677c99">00065</a> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gaa565e6849b165c1b13f243a672677c99">osc_lock_is_lockless</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *olck)
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067         <span class="keywordflow">return</span> (olck-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>.<a class="code" href="structcl__lock__slice.html#acf8f055c895f746f50fe19c4189defad">cls_ops</a> == &amp;<a class="code" href="group__osc.html#gae177dc16a77b0406ec3645ad1725734d">osc_lock_lockless_ops</a>);
<a name="l00068"></a>00068 }
<a name="l00069"></a>00069 
<a name="l00075"></a><a class="code" href="group__osc.html#ga95f7cfb7218e8b72b11725001f63b02c">00075</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *<a class="code" href="group__osc.html#ga95f7cfb7218e8b72b11725001f63b02c" title="Returns a weak pointer to the ldlm lock identified by a handle.">osc_handle_ptr</a>(<span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *handle)
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079         lock = <a class="code" href="group__LDLM.html#ga362da0472f4016a927cc50b1163585e4" title="Obtain a lock reference by its handle.">ldlm_handle2lock</a>(handle);
<a name="l00080"></a>00080         <span class="keywordflow">if</span> (lock != NULL)
<a name="l00081"></a>00081                 <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(lock);
<a name="l00082"></a>00082         <span class="keywordflow">return</span> lock;
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00088"></a><a class="code" href="group__osc.html#ga54adc12953bce11081c44d696c8b147e">00088</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga54adc12953bce11081c44d696c8b147e" title="Invariant that has to be true all of the time.">osc_lock_invariant</a>(<span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *ols)
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock        = <a class="code" href="group__osc.html#ga95f7cfb7218e8b72b11725001f63b02c" title="Returns a weak pointer to the ldlm lock identified by a handle.">osc_handle_ptr</a>(&amp;ols-&gt;<a class="code" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">ols_handle</a>);
<a name="l00091"></a>00091         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *olock       = ols-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a>;
<a name="l00092"></a>00092         <span class="keywordtype">int</span>               handle_used = <a class="code" href="group__lustreidl.html#ga1382ead1fe9dd82db2821a82c4d2de11">lustre_handle_is_used</a>(&amp;ols-&gt;<a class="code" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">ols_handle</a>);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094         <span class="keywordflow">if</span> (<a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(<a class="code" href="group__osc.html#gaa565e6849b165c1b13f243a672677c99">osc_lock_is_lockless</a>(ols),
<a name="l00095"></a>00095                  ols-&gt;<a class="code" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed" title="inherit the lockless attribute from top level cl_io.">ols_locklessable</a> &amp;&amp; ols-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a> == NULL))
<a name="l00096"></a>00096                 <span class="keywordflow">return</span> 1;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098         <span class="comment">/*</span>
<a name="l00099"></a>00099 <span class="comment">         * If all the following &quot;ergo&quot;s are true, return 1, otherwise 0</span>
<a name="l00100"></a>00100 <span class="comment">         */</span>
<a name="l00101"></a>00101         <span class="keywordflow">if</span> (! <a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(olock != NULL, handle_used))
<a name="l00102"></a>00102                 <span class="keywordflow">return</span> 0;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104         <span class="keywordflow">if</span> (! <a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(olock != NULL,
<a name="l00105"></a>00105                    olock-&gt;<a class="code" href="structldlm__lock.html#af6bfe0ab210b608d0fa59ee6e95841ec" title="Local lock handle.">l_handle</a>.<a class="code" href="structportals__handle.html#a69a5ee95c5da23f07b14dc3fb6d1440c">h_cookie</a> == ols-&gt;<a class="code" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">ols_handle</a>.<a class="code" href="structlustre__handle.html#a735d65d1a27d9cafdc17245e4574000a">cookie</a>))
<a name="l00106"></a>00106                 <span class="keywordflow">return</span> 0;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108         <span class="keywordflow">if</span> (! <a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(handle_used,
<a name="l00109"></a>00109                    <a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(lock != NULL &amp;&amp; olock != NULL, lock == olock) &amp;&amp;
<a name="l00110"></a>00110                    <a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(lock == NULL, olock == NULL)))
<a name="l00111"></a>00111                 <span class="keywordflow">return</span> 0;
<a name="l00112"></a>00112         <span class="comment">/*</span>
<a name="l00113"></a>00113 <span class="comment">         * Check that -&gt;ols_handle and -&gt;ols_dlmlock are consistent, but</span>
<a name="l00114"></a>00114 <span class="comment">         * take into account that they are set at the different time.</span>
<a name="l00115"></a>00115 <span class="comment">         */</span>
<a name="l00116"></a>00116         <span class="keywordflow">if</span> (! <a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(ols-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> == <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a0be13e08c2f9842b70f8f380a029ad49">OLS_CANCELLED</a>,
<a name="l00117"></a>00117                    olock == NULL &amp;&amp; !handle_used))
<a name="l00118"></a>00118                 <span class="keywordflow">return</span> 0;
<a name="l00119"></a>00119         <span class="comment">/*</span>
<a name="l00120"></a>00120 <span class="comment">         * DLM lock is destroyed only after we have seen cancellation</span>
<a name="l00121"></a>00121 <span class="comment">         * ast.</span>
<a name="l00122"></a>00122 <span class="comment">         */</span>
<a name="l00123"></a>00123         <span class="keywordflow">if</span> (! <a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(olock != NULL &amp;&amp; ols-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> &lt; <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a0be13e08c2f9842b70f8f380a029ad49">OLS_CANCELLED</a>,
<a name="l00124"></a>00124                    !<a class="code" href="group__LDLM.html#gaa42d6481767a1729beb6c8e23dad96ea">ldlm_is_destroyed</a>(olock)))
<a name="l00125"></a>00125                 <span class="keywordflow">return</span> 0;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         <span class="keywordflow">if</span> (! <a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(ols-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> == <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a2d25aac14431d41d5aaa8ae702e40705">OLS_GRANTED</a>,
<a name="l00128"></a>00128                    olock != NULL &amp;&amp;
<a name="l00129"></a>00129                    olock-&gt;<a class="code" href="structldlm__lock.html#a4c3ab4e1a3ec7f022d954251e6eafa67" title="Requested mode.">l_req_mode</a> == olock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a> &amp;&amp;
<a name="l00130"></a>00130                    ols-&gt;<a class="code" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">ols_hold</a>))
<a name="l00131"></a>00131                 <span class="keywordflow">return</span> 0;
<a name="l00132"></a>00132         <span class="keywordflow">return</span> 1;
<a name="l00133"></a>00133 }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="comment">/*****************************************************************************</span>
<a name="l00136"></a>00136 <span class="comment"> *</span>
<a name="l00137"></a>00137 <span class="comment"> * Lock operations.</span>
<a name="l00138"></a>00138 <span class="comment"> *</span>
<a name="l00139"></a>00139 <span class="comment"> */</span>
<a name="l00140"></a>00140 
<a name="l00141"></a><a class="code" href="group__osc.html#gab6bded0dd5d3b8886cb39393501ee7e3">00141</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gab6bded0dd5d3b8886cb39393501ee7e3">osc_lock_fini</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00142"></a>00142                           <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice)
<a name="l00143"></a>00143 {
<a name="l00144"></a>00144         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>  *ols = <a class="code" href="group__osc.html#ga9858e598601602f25f65cd55b4e98c0e">cl2osc_lock</a>(slice);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         <a class="code" href="libcfs__private_8h.html#a85e7b3762b6313387835c7ea0dd29081">LINVRNT</a>(<a class="code" href="group__osc.html#ga54adc12953bce11081c44d696c8b147e" title="Invariant that has to be true all of the time.">osc_lock_invariant</a>(ols));
<a name="l00147"></a>00147         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(ols-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a> == NULL);
<a name="l00148"></a>00148 
<a name="l00149"></a>00149         <a class="code" href="obd__support_8h.html#a8790e4c5dc3134282343de016fff8e2a">OBD_SLAB_FREE_PTR</a>(ols, <a class="code" href="group__osc.html#gab64712a972a010e480fe937ff1382a55">osc_lock_kmem</a>);
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00152"></a><a class="code" href="group__osc.html#gaa5a7b973cac7b99a2bd42990c4d5f368">00152</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gaa5a7b973cac7b99a2bd42990c4d5f368">osc_lock_build_policy</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00153"></a>00153                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock,
<a name="l00154"></a>00154                                   <span class="keyword">union</span> <a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *d = &amp;lock-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158         <a class="code" href="group__osc.html#ga5023e2c6d3427c41c4f8002c8845bcfe">osc_index2policy</a>(policy, d-&gt;<a class="code" href="structcl__lock__descr.html#a4364f7ff8f5675436ccb006540452752" title="Object this lock is granted for.">cld_obj</a>, d-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a>, d-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>);
<a name="l00159"></a>00159         policy-&gt;<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>.<a class="code" href="structldlm__extent.html#a26ed2c10540083850c4075cd178ae1c5">gid</a> = d-&gt;<a class="code" href="structcl__lock__descr.html#a9946758cc4db9583f64f9f98decc2e5c" title="Group ID, for group lock.">cld_gid</a>;
<a name="l00160"></a>00160 }
<a name="l00161"></a>00161 
<a name="l00162"></a><a class="code" href="group__osc.html#ga8dd2b15bab97b5408114762ab5c22c95">00162</a> <span class="keyword">static</span> <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="code" href="group__osc.html#ga8dd2b15bab97b5408114762ab5c22c95">osc_enq2ldlm_flags</a>(__u32 enqflags)
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> result = 0;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>((enqflags &amp; ~<a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a1a094fe2f0162ab8a02816903d804d97" title="mask of enq_flags.">CEF_MASK</a>) == 0);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168         <span class="keywordflow">if</span> (enqflags &amp; <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a1562800e334f5cb2c074f41cc5b0bf1c" title="instruct server to not block, if conflicting lock is found.">CEF_NONBLOCK</a>)
<a name="l00169"></a>00169                 result |= <a class="code" href="group__LDLM.html#ga34a11c94b46a7cd00e464a9063ff3879" title="Server told not to wait if blocked.">LDLM_FL_BLOCK_NOWAIT</a>;
<a name="l00170"></a>00170         <span class="keywordflow">if</span> (enqflags &amp; <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a432de84a3a6c92d385d1455be6b0272b" title="take lock asynchronously (out of order), as it cannot deadlock.">CEF_ASYNC</a>)
<a name="l00171"></a>00171                 result |= <a class="code" href="group__LDLM.html#ga71a692568def3030f14e3a56f51eacc2" title="lock request has intent">LDLM_FL_HAS_INTENT</a>;
<a name="l00172"></a>00172         <span class="keywordflow">if</span> (enqflags &amp; <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a2b96e0457cbff9ba9a8aa854009cf8da" title="tell the server to instruct (though a flag in the blocking ast) an owner of the conflicting...">CEF_DISCARD_DATA</a>)
<a name="l00173"></a>00173                 result |= <a class="code" href="group__LDLM.html#ga28476345c80ee86025d566e9e7c432b9" title="These are flags that are mapped into the flags and ASTs of blocking locks Add FL_DISCARD...">LDLM_FL_AST_DISCARD_DATA</a>;
<a name="l00174"></a>00174         <span class="keywordflow">if</span> (enqflags &amp; <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a469f38a944b34de3f51d2f2964202604" title="enqueue a lock to test DLM lock existence.">CEF_PEEK</a>)
<a name="l00175"></a>00175                 result |= <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>;
<a name="l00176"></a>00176         <span class="keywordflow">if</span> (enqflags &amp; <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a61dce4cb6cb397ffffaf1c6d5d8608db" title="Lock match only.">CEF_LOCK_MATCH</a>)
<a name="l00177"></a>00177                 result |= <a class="code" href="group__LDLM.html#ga6ac6aa7bab27701ec8d953219626df95" title="match lock only">LDLM_FL_MATCH_LOCK</a>;
<a name="l00178"></a>00178         <span class="keywordflow">return</span> result;
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00191"></a><a class="code" href="group__osc.html#ga18aaf7af10329193fd017482344c1fa7">00191</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga18aaf7af10329193fd017482344c1fa7" title="Updates object attributes from a lock value block (lvb) received together with the...">osc_lock_lvb_update</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00192"></a>00192                                 <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *osc,
<a name="l00193"></a>00193                                 <span class="keyword">struct</span> <a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *dlmlock,
<a name="l00194"></a>00194                                 <span class="keyword">struct</span> <a class="code" href="structost__lvb.html">ost_lvb</a> *lvb)
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>  *obj = <a class="code" href="group__osc.html#gabeee966e59f8ff3f8a8c3cba94b63559">osc2cl</a>(osc);
<a name="l00197"></a>00197         <span class="keyword">struct </span><a class="code" href="structlov__oinfo.html">lov_oinfo</a>  *oinfo = osc-&gt;<a class="code" href="structosc__object.html#aa101340a37e6780faa2a9fecc3d3a4a1">oo_oinfo</a>;
<a name="l00198"></a>00198         <span class="keyword">struct </span><a class="code" href="structcl__attr.html" title="&amp;quot;Data attributes&amp;quot; of cl_object.">cl_attr</a>    *attr = &amp;<a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env)-&gt;<a class="code" href="structosc__thread__info.html#a90c70fec97d97c7d66308d6d9f9cc5cf">oti_attr</a>;
<a name="l00199"></a>00199         <span class="keywordtype">unsigned</span>           valid;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         valid = <a class="code" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83a0426f1a497ac52defd19a0f843de76dd">CAT_BLOCKS</a> | <a class="code" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83af1b07764255dd3f79878a040e7cb73b0">CAT_ATIME</a> | <a class="code" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83a3d90d16441447a6904e7932279f13cb3">CAT_CTIME</a> | <a class="code" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83ac7e947d42c260c8df203b6d73da46f4c">CAT_MTIME</a> | <a class="code" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83a8ccb81e3f6a5cba7c8e9bd494874cd38">CAT_SIZE</a>;
<a name="l00204"></a>00204         <span class="keywordflow">if</span> (lvb == NULL) {
<a name="l00205"></a>00205                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(dlmlock != NULL);
<a name="l00206"></a>00206                 lvb = dlmlock-&gt;<a class="code" href="structldlm__lock.html#a58e99cf39e7033e1a504afccc043f318">l_lvb_data</a>;
<a name="l00207"></a>00207         }
<a name="l00208"></a>00208         <a class="code" href="group__clio.html#gad69ffcfdd3d835937721abdc10dd1098" title="Converts struct ost_lvb to struct cl_attr.">cl_lvb2attr</a>(attr, lvb);
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <a class="code" href="group__cl__object.html#ga0ab97a8a879d5a81b4b5d60367e0ff0a" title="Locks data-attributes.">cl_object_attr_lock</a>(obj);
<a name="l00211"></a>00211         <span class="keywordflow">if</span> (dlmlock != NULL) {
<a name="l00212"></a>00212                 <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="code" href="lp__utils_8h.html#a439227feff9d7f55384e8780cfc2eb82">size</a>;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214                 <a class="code" href="group__LDLM.html#gafcd013e3a5397cfa341646d8522d2563" title="Check if resource is already locked, assert if not.">check_res_locked</a>(dlmlock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(lvb == dlmlock-&gt;<a class="code" href="structldlm__lock.html#a58e99cf39e7033e1a504afccc043f318">l_lvb_data</a>);
<a name="l00217"></a>00217                 size = lvb-&gt;<a class="code" href="structost__lvb.html#a6e02b563ed2659d7fa0dfed6865db416">lvb_size</a>;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219                 <span class="comment">/* Extend KMS up to the end of this lock and no further</span>
<a name="l00220"></a>00220 <span class="comment">                 * A lock on [x,y] means a KMS of up to y + 1 bytes! */</span>
<a name="l00221"></a>00221                 <span class="keywordflow">if</span> (size &gt; dlmlock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>.<a class="code" href="structldlm__extent.html#a46a04a5a0a47f6e4b476bb37648c5ffc">end</a>)
<a name="l00222"></a>00222                         size = dlmlock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>.<a class="code" href="structldlm__extent.html#a46a04a5a0a47f6e4b476bb37648c5ffc">end</a> + 1;
<a name="l00223"></a>00223                 <span class="keywordflow">if</span> (size &gt;= oinfo-&gt;<a class="code" href="structlov__oinfo.html#a9ffac609d572e59b297dd51938bc9ab9">loi_kms</a>) {
<a name="l00224"></a>00224                         <a class="code" href="group__LDLM.html#gad8d04218a1ba26d32ea36a1f5aebc505">LDLM_DEBUG</a>(dlmlock, <span class="stringliteral">&quot;lock acquired, setting rss=&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a>
<a name="l00225"></a>00225                                    <span class="stringliteral">&quot;, kms=&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a>, lvb-&gt;<a class="code" href="structost__lvb.html#a6e02b563ed2659d7fa0dfed6865db416">lvb_size</a>, size);
<a name="l00226"></a>00226                         valid |= <a class="code" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83aa410b24e55de9c6bf1fb8da2d36a5c8d">CAT_KMS</a>;
<a name="l00227"></a>00227                         attr-&gt;<a class="code" href="structcl__attr.html#a84e50a30068843ee9789b137b1e00aef" title="Known minimal size, in bytes.">cat_kms</a> = size;
<a name="l00228"></a>00228                 } <span class="keywordflow">else</span> {
<a name="l00229"></a>00229                         <a class="code" href="group__LDLM.html#gad8d04218a1ba26d32ea36a1f5aebc505">LDLM_DEBUG</a>(dlmlock, <span class="stringliteral">&quot;lock acquired, setting rss=&quot;</span>
<a name="l00230"></a>00230                                    <a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;; leaving kms=&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a><span class="stringliteral">&quot;, end=&quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#a5ef11521803262dc2f972061520e41f2">LPU64</a>,
<a name="l00231"></a>00231                                    lvb-&gt;<a class="code" href="structost__lvb.html#a6e02b563ed2659d7fa0dfed6865db416">lvb_size</a>, oinfo-&gt;<a class="code" href="structlov__oinfo.html#a9ffac609d572e59b297dd51938bc9ab9">loi_kms</a>,
<a name="l00232"></a>00232                                    dlmlock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>.<a class="code" href="structldlm__extent.html#a46a04a5a0a47f6e4b476bb37648c5ffc">end</a>);
<a name="l00233"></a>00233                 }
<a name="l00234"></a>00234                 <a class="code" href="group__LDLM.html#gab9c1d858901b9d9a4db13ffbad095fb6" title="Mark lock as &amp;quot;matchable&amp;quot; by OST.">ldlm_lock_allow_match_locked</a>(dlmlock);
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237         <a class="code" href="group__cl__object.html#gaaa4c4e2f092946a662c321e1aa7a4aab" title="Updates data-attributes of an object obj.">cl_object_attr_update</a>(env, obj, attr, valid);
<a name="l00238"></a>00238         <a class="code" href="group__cl__object.html#ga2fc69699a9214cda8ac2e8264b709dac" title="Releases data-attributes lock, acquired by cl_object_attr_lock().">cl_object_attr_unlock</a>(obj);
<a name="l00239"></a>00239 
<a name="l00240"></a>00240         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a><a class="code" href="group__osc.html#ga5bd9e2d847a8448e23dcf09c6b73766f">00243</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga5bd9e2d847a8448e23dcf09c6b73766f">osc_lock_granted</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *oscl,
<a name="l00244"></a>00244                              <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lockh, <span class="keywordtype">bool</span> lvb_update)
<a name="l00245"></a>00245 {
<a name="l00246"></a>00246         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *dlmlock;
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         dlmlock = <a class="code" href="group__LDLM.html#gaee7a1e25a9767f6e3bdbade69a15764f">ldlm_handle2lock_long</a>(lockh, 0);
<a name="l00249"></a>00249         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(dlmlock != NULL);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251         <span class="comment">/* lock reference taken by ldlm_handle2lock_long() is</span>
<a name="l00252"></a>00252 <span class="comment">         * owned by osc_lock and released in osc_lock_detach()</span>
<a name="l00253"></a>00253 <span class="comment">         */</span>
<a name="l00254"></a>00254         <a class="code" href="group__lu__ref.html#gad327cc83dc17317225095651013e1fd6">lu_ref_add</a>(&amp;dlmlock-&gt;<a class="code" href="structldlm__lock.html#a2cc84a3989e5b197caffa7a0fe014f27" title="Reference tracking structure to debug leaked locks.">l_reference</a>, <span class="stringliteral">&quot;osc_lock&quot;</span>, oscl);
<a name="l00255"></a>00255         oscl-&gt;<a class="code" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152" title="this is much like osc_lock::ols_hold, except that this bit is cleared _after_ reference...">ols_has_ref</a> = 1;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oscl-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a> == NULL);
<a name="l00258"></a>00258         oscl-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a> = dlmlock;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260         <span class="comment">/* This may be a matched lock for glimpse request, do not hold</span>
<a name="l00261"></a>00261 <span class="comment">         * lock reference in that case. */</span>
<a name="l00262"></a>00262         <span class="keywordflow">if</span> (!oscl-&gt;<a class="code" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416" title="if set, the osc_lock is a glimpse lock.">ols_glimpse</a>) {
<a name="l00263"></a>00263                 <span class="comment">/* hold a refc for non glimpse lock which will</span>
<a name="l00264"></a>00264 <span class="comment">                 * be released in osc_lock_cancel() */</span>
<a name="l00265"></a>00265                 <a class="code" href="group__lustreidl.html#ga80949fd91d76a5021e11f4ac3c17e682">lustre_handle_copy</a>(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">ols_handle</a>, lockh);
<a name="l00266"></a>00266                 <a class="code" href="group__LDLM.html#ga2d77135057c3b9123a3ae5704752c946" title="Add specified reader/writer reference to LDLM lock with handle lockh.">ldlm_lock_addref</a>(lockh, oscl-&gt;<a class="code" href="structosc__lock.html#a4d1369425e04be04518a52972a05bf89">ols_einfo</a>.<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a>);
<a name="l00267"></a>00267                 oscl-&gt;<a class="code" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">ols_hold</a> = 1;
<a name="l00268"></a>00268         }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         <span class="comment">/* Lock must have been granted. */</span>
<a name="l00271"></a>00271         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(dlmlock);
<a name="l00272"></a>00272         <span class="keywordflow">if</span> (dlmlock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a> == dlmlock-&gt;<a class="code" href="structldlm__lock.html#a4c3ab4e1a3ec7f022d954251e6eafa67" title="Requested mode.">l_req_mode</a>) {
<a name="l00273"></a>00273                 <span class="keyword">struct </span><a class="code" href="structldlm__extent.html">ldlm_extent</a> *ext = &amp;dlmlock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>;
<a name="l00274"></a>00274                 <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *descr = &amp;oscl-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>.<a class="code" href="structcl__lock__slice.html#abd152a13b7a1df918805b47ac43113b3">cls_lock</a>-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276                 <span class="comment">/* extend the lock extent, otherwise it will have problem when</span>
<a name="l00277"></a>00277 <span class="comment">                 * we decide whether to grant a lockless lock. */</span>
<a name="l00278"></a>00278                 descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a>  = <a class="code" href="group__osc.html#gaca9ddc217b81f518afa43dd690ff1108">osc_ldlm2cl_lock</a>(dlmlock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a>);
<a name="l00279"></a>00279                 descr-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a> = <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(descr-&gt;<a class="code" href="structcl__lock__descr.html#a4364f7ff8f5675436ccb006540452752" title="Object this lock is granted for.">cld_obj</a>, ext-&gt;<a class="code" href="structldlm__extent.html#af09bacd52ee801eb10e12807fc6ed5b7">start</a>);
<a name="l00280"></a>00280                 descr-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>   = <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(descr-&gt;<a class="code" href="structcl__lock__descr.html#a4364f7ff8f5675436ccb006540452752" title="Object this lock is granted for.">cld_obj</a>, ext-&gt;<a class="code" href="structldlm__extent.html#a46a04a5a0a47f6e4b476bb37648c5ffc">end</a>);
<a name="l00281"></a>00281                 descr-&gt;<a class="code" href="structcl__lock__descr.html#a9946758cc4db9583f64f9f98decc2e5c" title="Group ID, for group lock.">cld_gid</a>   = ext-&gt;<a class="code" href="structldlm__extent.html#a26ed2c10540083850c4075cd178ae1c5">gid</a>;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283                 <span class="comment">/* no lvb update for matched lock */</span>
<a name="l00284"></a>00284                 <span class="keywordflow">if</span> (lvb_update) {
<a name="l00285"></a>00285                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a> &amp; <a class="code" href="group__LDLM.html#ga3af51d9e1097e0aeaacd1c3cc88fec62" title="XXX FIXME: This is being added to b_size as a low-risk fix to the fact that the LVB...">LDLM_FL_LVB_READY</a>);
<a name="l00286"></a>00286                         <a class="code" href="group__osc.html#ga18aaf7af10329193fd017482344c1fa7" title="Updates object attributes from a lock value block (lvb) received together with the...">osc_lock_lvb_update</a>(env, <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(oscl-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>.<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>),
<a name="l00287"></a>00287                                             dlmlock, NULL);
<a name="l00288"></a>00288                 }
<a name="l00289"></a>00289                 <a class="code" href="libcfs__private_8h.html#a85e7b3762b6313387835c7ea0dd29081">LINVRNT</a>(<a class="code" href="group__osc.html#ga54adc12953bce11081c44d696c8b147e" title="Invariant that has to be true all of the time.">osc_lock_invariant</a>(oscl));
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(dlmlock);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> != <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a2d25aac14431d41d5aaa8ae702e40705">OLS_GRANTED</a>);
<a name="l00294"></a>00294         oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> = <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a2d25aac14431d41d5aaa8ae702e40705">OLS_GRANTED</a>;
<a name="l00295"></a>00295 }
<a name="l00296"></a>00296 
<a name="l00302"></a><a class="code" href="group__osc.html#ga29f791d1abf24609d793f38771cc90b3">00302</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga29f791d1abf24609d793f38771cc90b3" title="Lock upcall function that is executed either when a reply to ENQUEUE rpc is received...">osc_lock_upcall</a>(<span class="keywordtype">void</span> *cookie, <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lockh,
<a name="l00303"></a>00303                            <span class="keywordtype">int</span> errcode)
<a name="l00304"></a>00304 {
<a name="l00305"></a>00305         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>         *oscl  = cookie;
<a name="l00306"></a>00306         <span class="keyword">struct </span><a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a>    *slice = &amp;oscl-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>;
<a name="l00307"></a>00307         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>           *env;
<a name="l00308"></a>00308         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a>      nest;
<a name="l00309"></a>00309         <span class="keywordtype">int</span>                     rc;
<a name="l00310"></a>00310 
<a name="l00311"></a>00311         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313         env = <a class="code" href="group__cl__env.html#ga6ed10b419dd63d9fa101c7e14e75f965">cl_env_nested_get</a>(&amp;nest);
<a name="l00314"></a>00314         <span class="comment">/* should never happen, similar to osc_ldlm_blocking_ast(). */</span>
<a name="l00315"></a>00315         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!IS_ERR(env));
<a name="l00316"></a>00316 
<a name="l00317"></a>00317         rc = <a class="code" href="group__LDLM.html#ga7dac0446d813ef65c24c0831b6d1a519" title="Rather arbitrary mapping from LDLM error codes to errno values.">ldlm_error2errno</a>(errcode);
<a name="l00318"></a>00318         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> == <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a776ca12c4ee51af431b067dea743f901">OLS_ENQUEUED</a>) {
<a name="l00319"></a>00319                 oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> = <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a5816097365b1593a67efc02f67f55037">OLS_UPCALL_RECEIVED</a>;
<a name="l00320"></a>00320         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> == <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a0be13e08c2f9842b70f8f380a029ad49">OLS_CANCELLED</a>) {
<a name="l00321"></a>00321                 rc = -EIO;
<a name="l00322"></a>00322         } <span class="keywordflow">else</span> {
<a name="l00323"></a>00323                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Impossible state: %d\n&quot;</span>, oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a>);
<a name="l00324"></a>00324                 <a class="code" href="libcfs__private_8h.html#a08eceadb65d1adcf8c198cff27081d5f">LBUG</a>();
<a name="l00325"></a>00325         }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327         <span class="keywordflow">if</span> (rc == 0)
<a name="l00328"></a>00328                 <a class="code" href="group__osc.html#ga5bd9e2d847a8448e23dcf09c6b73766f">osc_lock_granted</a>(env, oscl, lockh, errcode == <a class="code" href="group__LDLM.html#ggaa2fbd012972eb2b2d0653c8df02964f7a469cbc24e6549b934f26184a5a78230e">ELDLM_OK</a>);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330         <span class="comment">/* Error handling, some errors are tolerable. */</span>
<a name="l00331"></a>00331         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed" title="inherit the lockless attribute from top level cl_io.">ols_locklessable</a> &amp;&amp; rc == -EUSERS) {
<a name="l00332"></a>00332                 <span class="comment">/* This is a tolerable error, turn this lock into</span>
<a name="l00333"></a>00333 <span class="comment">                 * lockless lock.</span>
<a name="l00334"></a>00334 <span class="comment">                 */</span>
<a name="l00335"></a>00335                 <a class="code" href="group__osc.html#ga898abac02468e34cf3cc62075837b421">osc_object_set_contended</a>(<a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(slice-&gt;<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>));
<a name="l00336"></a>00336                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(slice-&gt;<a class="code" href="structcl__lock__slice.html#acf8f055c895f746f50fe19c4189defad">cls_ops</a> == &amp;<a class="code" href="group__osc.html#gaf69bf16bf23d5ce82362b480fcb0a331">osc_lock_ops</a>);
<a name="l00337"></a>00337 
<a name="l00338"></a>00338                 <span class="comment">/* Change this lock to ldlmlock-less lock. */</span>
<a name="l00339"></a>00339                 <a class="code" href="group__osc.html#gae950ceda261ffba5e5cfd891375e866d" title="Determine if the lock should be converted into a lockless lock.">osc_lock_to_lockless</a>(env, oscl, 1);
<a name="l00340"></a>00340                 oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> = <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a2d25aac14431d41d5aaa8ae702e40705">OLS_GRANTED</a>;
<a name="l00341"></a>00341                 rc = 0;
<a name="l00342"></a>00342         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416" title="if set, the osc_lock is a glimpse lock.">ols_glimpse</a> &amp;&amp; rc == -ENAVAIL) {
<a name="l00343"></a>00343                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a> &amp; <a class="code" href="group__LDLM.html#ga3af51d9e1097e0aeaacd1c3cc88fec62" title="XXX FIXME: This is being added to b_size as a low-risk fix to the fact that the LVB...">LDLM_FL_LVB_READY</a>);
<a name="l00344"></a>00344                 <a class="code" href="group__osc.html#ga18aaf7af10329193fd017482344c1fa7" title="Updates object attributes from a lock value block (lvb) received together with the...">osc_lock_lvb_update</a>(env, <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(slice-&gt;<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>),
<a name="l00345"></a>00345                                     NULL, &amp;oscl-&gt;<a class="code" href="structosc__lock.html#a942265d5ad56c6b1260aa06ae9df6960" title="lock value block">ols_lvb</a>);
<a name="l00346"></a>00346                 <span class="comment">/* Hide the error. */</span>
<a name="l00347"></a>00347                 rc = 0;
<a name="l00348"></a>00348         }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7" title="Owner sleeps on this channel for state change.">ols_owner</a> != NULL)
<a name="l00351"></a>00351                 <a class="code" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9" title="Indicate that transfer of a single page completed.">cl_sync_io_note</a>(env, oscl-&gt;<a class="code" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7" title="Owner sleeps on this channel for state change.">ols_owner</a>, rc);
<a name="l00352"></a>00352         <a class="code" href="group__cl__env.html#gad0152e8236bb22b70e9066509070fded">cl_env_nested_put</a>(&amp;nest, env);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 
<a name="l00357"></a><a class="code" href="group__osc.html#gaf9b0a5fcc4fbfa6437afc998a0b8657d">00357</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gaf9b0a5fcc4fbfa6437afc998a0b8657d">osc_lock_upcall_agl</a>(<span class="keywordtype">void</span> *cookie, <span class="keyword">struct</span> <a class="code" href="structlustre__handle.html">lustre_handle</a> *lockh,
<a name="l00358"></a>00358                                <span class="keywordtype">int</span> errcode)
<a name="l00359"></a>00359 {
<a name="l00360"></a>00360         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a>       *osc = cookie;
<a name="l00361"></a>00361         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a>        *dlmlock;
<a name="l00362"></a>00362         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>           *env;
<a name="l00363"></a>00363         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a>       nest;
<a name="l00364"></a>00364         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         env = <a class="code" href="group__cl__env.html#ga6ed10b419dd63d9fa101c7e14e75f965">cl_env_nested_get</a>(&amp;nest);
<a name="l00367"></a>00367         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!IS_ERR(env));
<a name="l00368"></a>00368 
<a name="l00369"></a>00369         <span class="keywordflow">if</span> (errcode == <a class="code" href="group__LDLM.html#ggaa2fbd012972eb2b2d0653c8df02964f7a6545cc9db51172495cf36a4c88abca7d">ELDLM_LOCK_MATCHED</a>)
<a name="l00370"></a>00370                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, errcode = <a class="code" href="group__LDLM.html#ggaa2fbd012972eb2b2d0653c8df02964f7a469cbc24e6549b934f26184a5a78230e">ELDLM_OK</a>);
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         <span class="keywordflow">if</span> (errcode != <a class="code" href="group__LDLM.html#ggaa2fbd012972eb2b2d0653c8df02964f7a469cbc24e6549b934f26184a5a78230e">ELDLM_OK</a>)
<a name="l00373"></a>00373                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, errcode);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         dlmlock = <a class="code" href="group__LDLM.html#ga362da0472f4016a927cc50b1163585e4" title="Obtain a lock reference by its handle.">ldlm_handle2lock</a>(lockh);
<a name="l00376"></a>00376         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(dlmlock != NULL);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(dlmlock);
<a name="l00379"></a>00379         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(dlmlock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a> == dlmlock-&gt;<a class="code" href="structldlm__lock.html#a4c3ab4e1a3ec7f022d954251e6eafa67" title="Requested mode.">l_req_mode</a>);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381         <span class="comment">/* there is no osc_lock associated with AGL lock */</span>
<a name="l00382"></a>00382         <a class="code" href="group__osc.html#ga18aaf7af10329193fd017482344c1fa7" title="Updates object attributes from a lock value block (lvb) received together with the...">osc_lock_lvb_update</a>(env, osc, dlmlock, NULL);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(dlmlock);
<a name="l00385"></a>00385         <a class="code" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT</a>(dlmlock);
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 out:
<a name="l00388"></a>00388         <a class="code" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put</a>(env, <a class="code" href="group__osc.html#gabeee966e59f8ff3f8a8c3cba94b63559">osc2cl</a>(osc));
<a name="l00389"></a>00389         <a class="code" href="group__cl__env.html#gad0152e8236bb22b70e9066509070fded">cl_env_nested_put</a>(&amp;nest, env);
<a name="l00390"></a>00390         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(<a class="code" href="group__LDLM.html#ga7dac0446d813ef65c24c0831b6d1a519" title="Rather arbitrary mapping from LDLM error codes to errno values.">ldlm_error2errno</a>(errcode));
<a name="l00391"></a>00391 }
<a name="l00392"></a>00392 
<a name="l00393"></a><a class="code" href="group__osc.html#ga3a7f4b12063dd00ce41a418fb3818e39">00393</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga3a7f4b12063dd00ce41a418fb3818e39">osc_lock_flush</a>(<span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj, pgoff_t <a class="code" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, pgoff_t <a class="code" href="mdsrate_8c.html#abce9f5dc9c83f2639b72024fdee5d388">end</a>,
<a name="l00394"></a>00394                           <span class="keyword">enum</span> <a class="code" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1" title="Lock mode.">cl_lock_mode</a> <a class="code" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, <span class="keywordtype">int</span> discard)
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>           *env;
<a name="l00397"></a>00397         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a>      nest;
<a name="l00398"></a>00398         <span class="keywordtype">int</span>                     rc = 0;
<a name="l00399"></a>00399         <span class="keywordtype">int</span>                     rc2 = 0;
<a name="l00400"></a>00400 
<a name="l00401"></a>00401         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403         env = <a class="code" href="group__cl__env.html#ga6ed10b419dd63d9fa101c7e14e75f965">cl_env_nested_get</a>(&amp;nest);
<a name="l00404"></a>00404         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l00405"></a>00405                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(PTR_ERR(env));
<a name="l00406"></a>00406 
<a name="l00407"></a>00407         <span class="keywordflow">if</span> (mode == <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1acf7d9afdb41a33222d042680cd268179">CLM_WRITE</a>) {
<a name="l00408"></a>00408                 rc = <a class="code" href="group__osc.html#ga91e31015ca9c3df0750e008ebd5831cf" title="Called to write out a range of osc object.">osc_cache_writeback_range</a>(env, obj, start, end, 1,
<a name="l00409"></a>00409                                                discard);
<a name="l00410"></a>00410                 <a class="code" href="libcfs__debug_8h.html#a9253e2ada2b31c570a7c99d1bd6a6355">CDEBUG</a>(<a class="code" href="libcfs__debug_8h.html#a82cd19c0939c99444c5bf1bc830df4ee">D_CACHE</a>, <span class="stringliteral">&quot;object %p: [%lu -&gt; %lu] %d pages were %s.\n&quot;</span>,
<a name="l00411"></a>00411                        obj, start, end, rc,
<a name="l00412"></a>00412                        discard ? <span class="stringliteral">&quot;discarded&quot;</span> : <span class="stringliteral">&quot;written back&quot;</span>);
<a name="l00413"></a>00413                 <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l00414"></a>00414                         rc = 0;
<a name="l00415"></a>00415         }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         rc2 = <a class="code" href="group__osc.html#gad86265cc2892261e7634f0d9a2050a6b" title="Discard pages protected by the given lock.">osc_lock_discard_pages</a>(env, obj, start, end, mode);
<a name="l00418"></a>00418         <span class="keywordflow">if</span> (rc == 0 &amp;&amp; rc2 &lt; 0)
<a name="l00419"></a>00419                 rc = rc2;
<a name="l00420"></a>00420 
<a name="l00421"></a>00421         <a class="code" href="group__cl__env.html#gad0152e8236bb22b70e9066509070fded">cl_env_nested_put</a>(&amp;nest, env);
<a name="l00422"></a>00422         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00423"></a>00423 }
<a name="l00424"></a>00424 
<a name="l00429"></a><a class="code" href="group__osc.html#gaa7b3a2727168eb22303066140b94eef4">00429</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gaa7b3a2727168eb22303066140b94eef4" title="Helper for osc_dlm_blocking_ast() handling discrepancies between cl_lock and ldlm_lock...">osc_dlm_blocking_ast0</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00430"></a>00430                                  <span class="keyword">struct</span> <a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *dlmlock,
<a name="l00431"></a>00431                                  <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> flag)
<a name="l00432"></a>00432 {
<a name="l00433"></a>00433         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>        *obj = NULL;
<a name="l00434"></a>00434         <span class="keywordtype">int</span>                     result = 0;
<a name="l00435"></a>00435         <span class="keywordtype">int</span>                     discard;
<a name="l00436"></a>00436         <span class="keyword">enum</span> <a class="code" href="group__cl__lock.html#ga85e741e93c4ba0b8fd87206425e347a1" title="Lock mode.">cl_lock_mode</a>       <a class="code" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a> = <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a>;
<a name="l00437"></a>00437         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(flag == <a class="code" href="group__LDLM.html#ga5d94274920487243f51d4942f163b947">LDLM_CB_CANCELING</a>);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(dlmlock);
<a name="l00442"></a>00442         <span class="keywordflow">if</span> (dlmlock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a> != dlmlock-&gt;<a class="code" href="structldlm__lock.html#a4c3ab4e1a3ec7f022d954251e6eafa67" title="Requested mode.">l_req_mode</a>) {
<a name="l00443"></a>00443                 dlmlock-&gt;<a class="code" href="structldlm__lock.html#acb54919a43db8f99a336c67e0988fdb8" title="Private storage for lock user.">l_ast_data</a> = NULL;
<a name="l00444"></a>00444                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(dlmlock);
<a name="l00445"></a>00445                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         discard = <a class="code" href="group__LDLM.html#ga7fcf88e1d975071d9eebf367aa9c6d5c">ldlm_is_discard_data</a>(dlmlock);
<a name="l00449"></a>00449         <span class="keywordflow">if</span> (dlmlock-&gt;<a class="code" href="structldlm__lock.html#a714ebd7977f069a111bf98aa7b202167" title="Granted mode, also protected by lr_lock.">l_granted_mode</a> &amp; (<a class="code" href="packet-lustre_8c.html#acfddf2f902384575528f1e893c561afc">LCK_PW</a> | <a class="code" href="packet-lustre_8c.html#a37496b5479e3e46be8b0be98137baeb1">LCK_GROUP</a>))
<a name="l00450"></a>00450                 mode = <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1acf7d9afdb41a33222d042680cd268179">CLM_WRITE</a>;
<a name="l00451"></a>00451 
<a name="l00452"></a>00452         <span class="keywordflow">if</span> (dlmlock-&gt;<a class="code" href="structldlm__lock.html#acb54919a43db8f99a336c67e0988fdb8" title="Private storage for lock user.">l_ast_data</a> != NULL) {
<a name="l00453"></a>00453                 obj = <a class="code" href="group__osc.html#gabeee966e59f8ff3f8a8c3cba94b63559">osc2cl</a>(dlmlock-&gt;<a class="code" href="structldlm__lock.html#acb54919a43db8f99a336c67e0988fdb8" title="Private storage for lock user.">l_ast_data</a>);
<a name="l00454"></a>00454                 dlmlock-&gt;<a class="code" href="structldlm__lock.html#acb54919a43db8f99a336c67e0988fdb8" title="Private storage for lock user.">l_ast_data</a> = NULL;
<a name="l00455"></a>00455 
<a name="l00456"></a>00456                 <a class="code" href="group__cl__object.html#gae84de86afc6e9dbf1f9e1a7219bd202b" title="Acquire an additional reference to the object o.">cl_object_get</a>(obj);
<a name="l00457"></a>00457         }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(dlmlock);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461         <span class="comment">/* if l_ast_data is NULL, the dlmlock was enqueued by AGL or</span>
<a name="l00462"></a>00462 <span class="comment">         * the object has been destroyed. */</span>
<a name="l00463"></a>00463         <span class="keywordflow">if</span> (obj != NULL) {
<a name="l00464"></a>00464                 <span class="keyword">struct </span><a class="code" href="structldlm__extent.html">ldlm_extent</a> *extent = &amp;dlmlock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>;
<a name="l00465"></a>00465                 <span class="keyword">struct </span><a class="code" href="structcl__attr.html" title="&amp;quot;Data attributes&amp;quot; of cl_object.">cl_attr</a> *attr = &amp;<a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env)-&gt;<a class="code" href="structosc__thread__info.html#a90c70fec97d97c7d66308d6d9f9cc5cf">oti_attr</a>;
<a name="l00466"></a>00466                 <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> old_kms;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468                 <span class="comment">/* Destroy pages covered by the extent of the DLM lock */</span>
<a name="l00469"></a>00469                 result = <a class="code" href="group__osc.html#ga3a7f4b12063dd00ce41a418fb3818e39">osc_lock_flush</a>(<a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(obj),
<a name="l00470"></a>00470                                         <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(obj, extent-&gt;<a class="code" href="structldlm__extent.html#af09bacd52ee801eb10e12807fc6ed5b7">start</a>),
<a name="l00471"></a>00471                                         <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(obj, extent-&gt;<a class="code" href="structldlm__extent.html#a46a04a5a0a47f6e4b476bb37648c5ffc">end</a>),
<a name="l00472"></a>00472                                         mode, discard);
<a name="l00473"></a>00473 
<a name="l00474"></a>00474                 <span class="comment">/* losing a lock, update kms */</span>
<a name="l00475"></a>00475                 <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(dlmlock);
<a name="l00476"></a>00476                 <a class="code" href="group__cl__object.html#ga0ab97a8a879d5a81b4b5d60367e0ff0a" title="Locks data-attributes.">cl_object_attr_lock</a>(obj);
<a name="l00477"></a>00477                 <span class="comment">/* Must get the value under the lock to avoid race. */</span>
<a name="l00478"></a>00478                 old_kms = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(obj)-&gt;<a class="code" href="structosc__object.html#aa101340a37e6780faa2a9fecc3d3a4a1">oo_oinfo</a>-&gt;<a class="code" href="structlov__oinfo.html#a9ffac609d572e59b297dd51938bc9ab9">loi_kms</a>;
<a name="l00479"></a>00479                 <span class="comment">/* Update the kms. Need to loop all granted locks.</span>
<a name="l00480"></a>00480 <span class="comment">                 * Not a problem for the client */</span>
<a name="l00481"></a>00481                 attr-&gt;<a class="code" href="structcl__attr.html#a84e50a30068843ee9789b137b1e00aef" title="Known minimal size, in bytes.">cat_kms</a> = <a class="code" href="group__LDLM.html#gaa9bd1ddd8fa94d5bb36d9ab2499148f3">ldlm_extent_shift_kms</a>(dlmlock, old_kms);
<a name="l00482"></a>00482 
<a name="l00483"></a>00483                 <a class="code" href="group__cl__object.html#gaaa4c4e2f092946a662c321e1aa7a4aab" title="Updates data-attributes of an object obj.">cl_object_attr_update</a>(env, obj, attr, <a class="code" href="group__cl__object.html#gga48fd4da7a215ef4bcc31582adceb8b83aa410b24e55de9c6bf1fb8da2d36a5c8d">CAT_KMS</a>);
<a name="l00484"></a>00484                 <a class="code" href="group__cl__object.html#ga2fc69699a9214cda8ac2e8264b709dac" title="Releases data-attributes lock, acquired by cl_object_attr_lock().">cl_object_attr_unlock</a>(obj);
<a name="l00485"></a>00485                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(dlmlock);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487                 <a class="code" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put</a>(env, obj);
<a name="l00488"></a>00488         }
<a name="l00489"></a>00489         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(result);
<a name="l00490"></a>00490 }
<a name="l00491"></a>00491 
<a name="l00534"></a><a class="code" href="group__osc.html#ga3d96731374882d1b601e94dab8f92397">00534</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga3d96731374882d1b601e94dab8f92397" title="Blocking ast invoked by ldlm when dlm lock is either blocking progress of some other...">osc_ldlm_blocking_ast</a>(<span class="keyword">struct</span> <a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *dlmlock,
<a name="l00535"></a>00535                                  <span class="keyword">struct</span> <a class="code" href="structldlm__lock__desc.html">ldlm_lock_desc</a> *<span class="keyword">new</span>, <span class="keywordtype">void</span> *data,
<a name="l00536"></a>00536                                  <span class="keywordtype">int</span> flag)
<a name="l00537"></a>00537 {
<a name="l00538"></a>00538         <span class="keywordtype">int</span> result = 0;
<a name="l00539"></a>00539         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         <span class="keywordflow">switch</span> (flag) {
<a name="l00542"></a>00542         <span class="keywordflow">case</span> <a class="code" href="group__LDLM.html#gac91b29eaa6987e07656d85e9e139ca3f" title="The blocking callback is overloaded to perform two functions.">LDLM_CB_BLOCKING</a>: {
<a name="l00543"></a>00543                 <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lockh;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545                 <a class="code" href="group__LDLM.html#ga35362f3605ec8dec52464f153c932c85" title="Fills in handle for LDLM lock lock into supplied lockh Does not take any references...">ldlm_lock2handle</a>(dlmlock, &amp;lockh);
<a name="l00546"></a>00546                 result = <a class="code" href="group__ldlm__cli__api.html#ga0237477d402999ab81f2b2447fceebc9" title="Client side lock cancel.">ldlm_cli_cancel</a>(&amp;lockh, <a class="code" href="group__LDLM.html#gga0b718c2d27bc15f43205e50e4da16ec9a280acd6e88765fc97a4833aa18e30968">LCF_ASYNC</a>);
<a name="l00547"></a>00547                 <span class="keywordflow">if</span> (result == -ENODATA)
<a name="l00548"></a>00548                         result = 0;
<a name="l00549"></a>00549                 <span class="keywordflow">break</span>;
<a name="l00550"></a>00550         }
<a name="l00551"></a>00551         <span class="keywordflow">case</span> <a class="code" href="group__LDLM.html#ga5d94274920487243f51d4942f163b947">LDLM_CB_CANCELING</a>: {
<a name="l00552"></a>00552                 <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>     *env;
<a name="l00553"></a>00553                 <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a> nest;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555                 <span class="comment">/*</span>
<a name="l00556"></a>00556 <span class="comment">                 * This can be called in the context of outer IO, e.g.,</span>
<a name="l00557"></a>00557 <span class="comment">                 *</span>
<a name="l00558"></a>00558 <span class="comment">                 *    osc_enqueue_base()-&gt;...</span>
<a name="l00559"></a>00559 <span class="comment">                 *      -&gt;ldlm_prep_elc_req()-&gt;...</span>
<a name="l00560"></a>00560 <span class="comment">                 *        -&gt;ldlm_cancel_callback()-&gt;...</span>
<a name="l00561"></a>00561 <span class="comment">                 *          -&gt;osc_ldlm_blocking_ast()</span>
<a name="l00562"></a>00562 <span class="comment">                 *</span>
<a name="l00563"></a>00563 <span class="comment">                 * new environment has to be created to not corrupt outer</span>
<a name="l00564"></a>00564 <span class="comment">                 * context.</span>
<a name="l00565"></a>00565 <span class="comment">                 */</span>
<a name="l00566"></a>00566                 env = <a class="code" href="group__cl__env.html#ga6ed10b419dd63d9fa101c7e14e75f965">cl_env_nested_get</a>(&amp;nest);
<a name="l00567"></a>00567                 <span class="keywordflow">if</span> (IS_ERR(env)) {
<a name="l00568"></a>00568                         result = PTR_ERR(env);
<a name="l00569"></a>00569                         <span class="keywordflow">break</span>;
<a name="l00570"></a>00570                 }
<a name="l00571"></a>00571 
<a name="l00572"></a>00572                 result = <a class="code" href="group__osc.html#gaa7b3a2727168eb22303066140b94eef4" title="Helper for osc_dlm_blocking_ast() handling discrepancies between cl_lock and ldlm_lock...">osc_dlm_blocking_ast0</a>(env, dlmlock, data, flag);
<a name="l00573"></a>00573                 <a class="code" href="group__cl__env.html#gad0152e8236bb22b70e9066509070fded">cl_env_nested_put</a>(&amp;nest, env);
<a name="l00574"></a>00574                 <span class="keywordflow">break</span>;
<a name="l00575"></a>00575         }
<a name="l00576"></a>00576         <span class="keywordflow">default</span>:
<a name="l00577"></a>00577                 <a class="code" href="libcfs__private_8h.html#a08eceadb65d1adcf8c198cff27081d5f">LBUG</a>();
<a name="l00578"></a>00578         }
<a name="l00579"></a>00579         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(result);
<a name="l00580"></a>00580 }
<a name="l00581"></a>00581 
<a name="l00582"></a><a class="code" href="group__osc.html#gabeb20790e130bf97ca7999f0832fba5f">00582</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gabeb20790e130bf97ca7999f0832fba5f">osc_ldlm_glimpse_ast</a>(<span class="keyword">struct</span> <a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *dlmlock, <span class="keywordtype">void</span> *data)
<a name="l00583"></a>00583 {
<a name="l00584"></a>00584         <span class="keyword">struct </span><a class="code" href="structptlrpc__request.html" title="Represents remote procedure call.">ptlrpc_request</a>   *req  = data;
<a name="l00585"></a>00585         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a>      nest;
<a name="l00586"></a>00586         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>           *env;
<a name="l00587"></a>00587         <span class="keyword">struct </span><a class="code" href="structost__lvb.html">ost_lvb</a>          *lvb;
<a name="l00588"></a>00588         <span class="keyword">struct </span><a class="code" href="structreq__capsule.html">req_capsule</a>      *cap;
<a name="l00589"></a>00589         <span class="keywordtype">int</span>                     result;
<a name="l00590"></a>00590 
<a name="l00591"></a>00591         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="group__net.html#ga5889b19f527897c102df244998c9de02">lustre_msg_get_opc</a>(req-&gt;<a class="code" href="structptlrpc__request.html#a98c2879f06b955c80000e8c1776373f7" title="Request message - what client sent.">rq_reqmsg</a>) == <a class="code" href="packet-lustre_8c.html#a70035b7ee9554257648ff591d5b088ae">LDLM_GL_CALLBACK</a>);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         env = <a class="code" href="group__cl__env.html#ga6ed10b419dd63d9fa101c7e14e75f965">cl_env_nested_get</a>(&amp;nest);
<a name="l00596"></a>00596         <span class="keywordflow">if</span> (!IS_ERR(env)) {
<a name="l00597"></a>00597                 <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj = NULL;
<a name="l00598"></a>00598 
<a name="l00599"></a>00599                 <a class="code" href="group__LDLM.html#ga7ea7aa073d254d8500c07d2664cbecf9" title="Lock a lock and its resource.">lock_res_and_lock</a>(dlmlock);
<a name="l00600"></a>00600                 <span class="keywordflow">if</span> (dlmlock-&gt;<a class="code" href="structldlm__lock.html#acb54919a43db8f99a336c67e0988fdb8" title="Private storage for lock user.">l_ast_data</a> != NULL) {
<a name="l00601"></a>00601                         obj = <a class="code" href="group__osc.html#gabeee966e59f8ff3f8a8c3cba94b63559">osc2cl</a>(dlmlock-&gt;<a class="code" href="structldlm__lock.html#acb54919a43db8f99a336c67e0988fdb8" title="Private storage for lock user.">l_ast_data</a>);
<a name="l00602"></a>00602                         <a class="code" href="group__cl__object.html#gae84de86afc6e9dbf1f9e1a7219bd202b" title="Acquire an additional reference to the object o.">cl_object_get</a>(obj);
<a name="l00603"></a>00603                 }
<a name="l00604"></a>00604                 <a class="code" href="group__LDLM.html#gaf9b19facd1a8bb3cdfcac5047159f15e" title="Unlock a lock and its resource previously locked with lock_res_and_lock.">unlock_res_and_lock</a>(dlmlock);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606                 <span class="keywordflow">if</span> (obj != NULL) {
<a name="l00607"></a>00607                         <span class="comment">/* Do not grab the mutex of cl_lock for glimpse.</span>
<a name="l00608"></a>00608 <span class="comment">                         * See LU-1274 for details.</span>
<a name="l00609"></a>00609 <span class="comment">                         * BTW, it&apos;s okay for cl_lock to be cancelled during</span>
<a name="l00610"></a>00610 <span class="comment">                         * this period because server can handle this race.</span>
<a name="l00611"></a>00611 <span class="comment">                         * See ldlm_server_glimpse_ast() for details.</span>
<a name="l00612"></a>00612 <span class="comment">                         * cl_lock_mutex_get(env, lock); */</span>
<a name="l00613"></a>00613                         cap = &amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>;
<a name="l00614"></a>00614                         <a class="code" href="group__req__layout.html#gad16c26c15f59593e2e005e4afbeb8034" title="Changes the format of an RPC.">req_capsule_extend</a>(cap, &amp;<a class="code" href="group__req__layout.html#gae141fed8e88604e47bab590ea0634cb6">RQF_LDLM_GL_CALLBACK</a>);
<a name="l00615"></a>00615                         <a class="code" href="group__req__layout.html#ga6d0a3a11367bcd9fe40dc723243e7b0d" title="Set the size of the PTLRPC request/reply (loc) buffer for the given field of the...">req_capsule_set_size</a>(cap, &amp;<a class="code" href="group__req__layout.html#ga56e0b6e5796ef17e49941b918803bd9b">RMF_DLM_LVB</a>, <a class="code" href="group__req__layout.html#gga0c07ccef9ef768eb7bf6cb2946c28261a4dac5db7141584c5bd83eae83a8439c0">RCL_SERVER</a>,
<a name="l00616"></a>00616                                              <span class="keyword">sizeof</span> *lvb);
<a name="l00617"></a>00617                         result = <a class="code" href="group__req__layout.html#ga2d6e601381473d8117410c7c9cd176c9" title="Capsule equivalent of lustre_pack_request() and lustre_pack_reply().">req_capsule_server_pack</a>(cap);
<a name="l00618"></a>00618                         <span class="keywordflow">if</span> (result == 0) {
<a name="l00619"></a>00619                                 lvb = <a class="code" href="group__req__layout.html#ga0d1ad53a1914c35470f3916e4bb4b8fe" title="Trivial wrapper around __req_capsule_get(), that returns the PTLRPC reply buffer...">req_capsule_server_get</a>(cap, &amp;<a class="code" href="group__req__layout.html#ga56e0b6e5796ef17e49941b918803bd9b">RMF_DLM_LVB</a>);
<a name="l00620"></a>00620                                 result = <a class="code" href="group__cl__object.html#gaeed557c8f4926f9d6492df7026fd4b13" title="Notifies layers (bottom-to-top) that glimpse AST was received.">cl_object_glimpse</a>(env, obj, lvb);
<a name="l00621"></a>00621                         }
<a name="l00622"></a>00622                         <span class="keywordflow">if</span> (!<a class="code" href="group__export.html#ga043b8eeb46c34da98ba68d662cb255e6">exp_connect_lvb_type</a>(req-&gt;<a class="code" href="structptlrpc__request.html#ac7af87194ec26c0e6646bdfaa943b17d" title="Server-side, export on which request was received.">rq_export</a>))
<a name="l00623"></a>00623                                 <a class="code" href="group__req__layout.html#gaf42efe506903884592711902e9276e99" title="This function shrinks the size of the _buffer_ of the pill&amp;#39;s PTLRPC request or...">req_capsule_shrink</a>(&amp;req-&gt;<a class="code" href="structptlrpc__request.html#ab7324f88fb8682a894baf36052f78da5" title="request format description">rq_pill</a>,
<a name="l00624"></a>00624                                                    &amp;<a class="code" href="group__req__layout.html#ga56e0b6e5796ef17e49941b918803bd9b">RMF_DLM_LVB</a>,
<a name="l00625"></a>00625                                                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structost__lvb__v1.html">ost_lvb_v1</a>),
<a name="l00626"></a>00626                                                    <a class="code" href="group__req__layout.html#gga0c07ccef9ef768eb7bf6cb2946c28261a4dac5db7141584c5bd83eae83a8439c0">RCL_SERVER</a>);
<a name="l00627"></a>00627                         <a class="code" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put</a>(env, obj);
<a name="l00628"></a>00628                 } <span class="keywordflow">else</span> {
<a name="l00629"></a>00629                         <span class="comment">/*</span>
<a name="l00630"></a>00630 <span class="comment">                         * These errors are normal races, so we don&apos;t want to</span>
<a name="l00631"></a>00631 <span class="comment">                         * fill the console with messages by calling</span>
<a name="l00632"></a>00632 <span class="comment">                         * ptlrpc_error()</span>
<a name="l00633"></a>00633 <span class="comment">                         */</span>
<a name="l00634"></a>00634                         <a class="code" href="group__net.html#ga931e9c4b5f584f4101c94dfcd3462c5f">lustre_pack_reply</a>(req, 1, NULL, NULL);
<a name="l00635"></a>00635                         result = -<a class="code" href="group__LDLM.html#ggaa2fbd012972eb2b2d0653c8df02964f7a1e8fbbeb38571f8585669ab5c6b8b826">ELDLM_NO_LOCK_DATA</a>;
<a name="l00636"></a>00636                 }
<a name="l00637"></a>00637                 <a class="code" href="group__cl__env.html#gad0152e8236bb22b70e9066509070fded">cl_env_nested_put</a>(&amp;nest, env);
<a name="l00638"></a>00638         } <span class="keywordflow">else</span>
<a name="l00639"></a>00639                 result = PTR_ERR(env);
<a name="l00640"></a>00640         req-&gt;<a class="code" href="structptlrpc__request.html#a275fd3eef6c30a8d9d65379aa94b6b2d" title="Result of request processing.">rq_status</a> = result;
<a name="l00641"></a>00641         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(result);
<a name="l00642"></a>00642 }
<a name="l00643"></a>00643 
<a name="l00644"></a><a class="code" href="group__osc.html#ga3b7c17bc704a969f4148b6735fb9d7dc">00644</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga3b7c17bc704a969f4148b6735fb9d7dc">weigh_cb</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l00645"></a>00645                     <span class="keyword">struct</span> <a class="code" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> *ops, <span class="keywordtype">void</span> *cbdata)
<a name="l00646"></a>00646 {
<a name="l00647"></a>00647         <span class="keyword">struct </span><a class="code" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a> *page = ops-&gt;<a class="code" href="structosc__page.html#aca0b5d1b8abc9ac4f139e5ed150cb816">ops_cl</a>.<a class="code" href="structcl__page__slice.html#a1c0b833d3d55ed4aff2470f5ab287506">cpl_page</a>;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         <span class="keywordflow">if</span> (<a class="code" href="group__cl__page.html#gaff21e5139bb0af2f15e2cfb9cfb587f3" title="Returns true, iff pg is VM locked in a suitable sense by the calling thread.">cl_page_is_vmlocked</a>(env, page)
<a name="l00650"></a>00650             || PageDirty(page-&gt;<a class="code" href="structcl__page.html#a9a4e391a7b741652812a451580176c9a" title="vmpage">cp_vmpage</a>) || PageWriteback(page-&gt;<a class="code" href="structcl__page.html#a9a4e391a7b741652812a451580176c9a" title="vmpage">cp_vmpage</a>)
<a name="l00651"></a>00651            )
<a name="l00652"></a>00652                 <span class="keywordflow">return</span> <a class="code" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06cacad5f5792a95672ac7258f707217afa7">CLP_GANG_ABORT</a>;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654         *(pgoff_t *)cbdata = <a class="code" href="group__osc.html#gad78c5a0ff4043426e5c4dd46336e9a07">osc_index</a>(ops) + 1;
<a name="l00655"></a>00655         <span class="keywordflow">return</span> <a class="code" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06ca1a8b155b6d6a78a95318775eb54c08b5">CLP_GANG_OKAY</a>;
<a name="l00656"></a>00656 }
<a name="l00657"></a>00657 
<a name="l00658"></a><a class="code" href="group__osc.html#ga9325a913aeaac8dbe7867ac4a8e86a12">00658</a> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="group__osc.html#ga9325a913aeaac8dbe7867ac4a8e86a12">osc_lock_weight</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00659"></a>00659                                      <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *oscobj,
<a name="l00660"></a>00660                                      <span class="keyword">struct</span> <a class="code" href="structldlm__extent.html">ldlm_extent</a> *extent)
<a name="l00661"></a>00661 {
<a name="l00662"></a>00662         <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>     *io = &amp;<a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env)-&gt;<a class="code" href="structosc__thread__info.html#ae53d5a14892a9fd224f99d4df2ca0aca">oti_io</a>;
<a name="l00663"></a>00663         <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj = <a class="code" href="group__cl__object.html#ga00ef0f7240b9a7d773a49a77c667f03a" title="Returns the top-object for a given o.">cl_object_top</a>(&amp;oscobj-&gt;<a class="code" href="structosc__object.html#a469d3f3450582d3143ada256fe3583bb">oo_cl</a>);
<a name="l00664"></a>00664         pgoff_t          page_index;
<a name="l00665"></a>00665         <span class="keywordtype">int</span>              result;
<a name="l00666"></a>00666         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668         io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a> = obj;
<a name="l00669"></a>00669         io-&gt;<a class="code" href="structcl__io.html#a5d6c1c346a6203b03bf6fb768c6799da" title="to not refresh layout - the IO issuer knows that the layout won&amp;#39;t change(page...">ci_ignore_layout</a> = 1;
<a name="l00670"></a>00670         result = <a class="code" href="group__cl__io.html#ga2a75c8a7a83eb31d6c899da9dc5143b1" title="Initialize io, by calling cl_io_operations::cio_init() top-to-bottom.">cl_io_init</a>(env, io, <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378ab21ff138f79ef4d41a40950879bf1e3c" title="Miscellaneous io.">CIT_MISC</a>, io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a>);
<a name="l00671"></a>00671         <span class="keywordflow">if</span> (result != 0)
<a name="l00672"></a>00672                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(result);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         page_index = <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(obj, extent-&gt;<a class="code" href="structldlm__extent.html#af09bacd52ee801eb10e12807fc6ed5b7">start</a>);
<a name="l00675"></a>00675         <span class="keywordflow">do</span> {
<a name="l00676"></a>00676                 result = <a class="code" href="group__osc.html#ga4ac00d525c8750fbccb312796dfb0542" title="Returns a list of pages by a given [start, end] of obj.">osc_page_gang_lookup</a>(env, io, oscobj,
<a name="l00677"></a>00677                                               page_index,
<a name="l00678"></a>00678                                               <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(obj, extent-&gt;<a class="code" href="structldlm__extent.html#a46a04a5a0a47f6e4b476bb37648c5ffc">end</a>),
<a name="l00679"></a>00679                                               <a class="code" href="group__osc.html#ga3b7c17bc704a969f4148b6735fb9d7dc">weigh_cb</a>, (<span class="keywordtype">void</span> *)&amp;page_index);
<a name="l00680"></a>00680                 <span class="keywordflow">if</span> (result == <a class="code" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06cacad5f5792a95672ac7258f707217afa7">CLP_GANG_ABORT</a>)
<a name="l00681"></a>00681                         <span class="keywordflow">break</span>;
<a name="l00682"></a>00682                 <span class="keywordflow">if</span> (result == <a class="code" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06ca1279507e1987988d99116da1f362faaa">CLP_GANG_RESCHED</a>)
<a name="l00683"></a>00683                         cond_resched();
<a name="l00684"></a>00684         } <span class="keywordflow">while</span> (result != <a class="code" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06ca1a8b155b6d6a78a95318775eb54c08b5">CLP_GANG_OKAY</a>);
<a name="l00685"></a>00685         <a class="code" href="group__cl__io.html#gacde22a6b2da553556081b6f93e8e0f7f" title="Finalize io, by calling cl_io_operations::cio_fini() bottom-to-top.">cl_io_fini</a>(env, io);
<a name="l00686"></a>00686 
<a name="l00687"></a>00687         <span class="keywordflow">return</span> result == <a class="code" href="group__cl__page.html#ggadc29c2ff13d900c2f185ee95427fb06cacad5f5792a95672ac7258f707217afa7">CLP_GANG_ABORT</a> ? 1 : 0;
<a name="l00688"></a>00688 }
<a name="l00689"></a>00689 
<a name="l00693"></a><a class="code" href="group__osc.html#ga35e11197afdf291ad1614fe6217d4108">00693</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="group__osc.html#ga35e11197afdf291ad1614fe6217d4108" title="Get the weight of dlm lock for early cancellation.">osc_ldlm_weigh_ast</a>(<span class="keyword">struct</span> <a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *dlmlock)
<a name="l00694"></a>00694 {
<a name="l00695"></a>00695         <span class="keyword">struct </span><a class="code" href="structcl__env__nest.html">cl_env_nest</a>       nest;
<a name="l00696"></a>00696         <span class="keyword">struct </span><a class="code" href="structlu__env.html" title="Environment.">lu_env</a>           *env;
<a name="l00697"></a>00697         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a>       *obj;
<a name="l00698"></a>00698         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>         *oscl;
<a name="l00699"></a>00699         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>            weight;
<a name="l00700"></a>00700         <span class="keywordtype">bool</span>                    found = <span class="keyword">false</span>;
<a name="l00701"></a>00701         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         might_sleep();
<a name="l00704"></a>00704         <span class="comment">/*</span>
<a name="l00705"></a>00705 <span class="comment">         * osc_ldlm_weigh_ast has a complex context since it might be called</span>
<a name="l00706"></a>00706 <span class="comment">         * because of lock canceling, or from user&apos;s input. We have to make</span>
<a name="l00707"></a>00707 <span class="comment">         * a new environment for it. Probably it is implementation safe to use</span>
<a name="l00708"></a>00708 <span class="comment">         * the upper context because cl_lock_put don&apos;t modify environment</span>
<a name="l00709"></a>00709 <span class="comment">         * variables. But just in case ..</span>
<a name="l00710"></a>00710 <span class="comment">         */</span>
<a name="l00711"></a>00711         env = <a class="code" href="group__cl__env.html#ga6ed10b419dd63d9fa101c7e14e75f965">cl_env_nested_get</a>(&amp;nest);
<a name="l00712"></a>00712         <span class="keywordflow">if</span> (IS_ERR(env))
<a name="l00713"></a>00713                 <span class="comment">/* Mostly because lack of memory, do not eliminate this lock */</span>
<a name="l00714"></a>00714                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(1);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(dlmlock-&gt;<a class="code" href="structldlm__lock.html#a41f4592eb59ed0c94d85e9fa67acfa6f" title="Pointer to actual resource this lock is in.">l_resource</a>-&gt;<a class="code" href="structldlm__resource.html#a49b3d8776d2a7ff57e963c988d1de5cf" title="Type of locks this resource can hold.">lr_type</a> == <a class="code" href="packet-lustre_8c.html#ab92227eb33b3bc79ee12e10421865cad">LDLM_EXTENT</a>);
<a name="l00717"></a>00717         obj = dlmlock-&gt;<a class="code" href="structldlm__lock.html#acb54919a43db8f99a336c67e0988fdb8" title="Private storage for lock user.">l_ast_data</a>;
<a name="l00718"></a>00718         <span class="keywordflow">if</span> (obj == NULL)
<a name="l00719"></a>00719                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, weight = 1);
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         spin_lock(&amp;obj-&gt;<a class="code" href="structosc__object.html#a950a26b39516a8c32370d8cb1fe92c7f">oo_ol_spin</a>);
<a name="l00722"></a>00722         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(oscl, &amp;obj-&gt;<a class="code" href="structosc__object.html#a7f440305c7a797bfcffc48fb36f73eda">oo_ol_list</a>, <a class="code" href="structosc__lock.html#a61ed1b1236e5970e472888bb62c81193" title="list entry for osc_object::oo_ol_list">ols_nextlock_oscobj</a>) {
<a name="l00723"></a>00723                 <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a> != NULL &amp;&amp; oscl-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a> != dlmlock)
<a name="l00724"></a>00724                         <span class="keywordflow">continue</span>;
<a name="l00725"></a>00725                 found = <span class="keyword">true</span>;
<a name="l00726"></a>00726         }
<a name="l00727"></a>00727         spin_unlock(&amp;obj-&gt;<a class="code" href="structosc__object.html#a950a26b39516a8c32370d8cb1fe92c7f">oo_ol_spin</a>);
<a name="l00728"></a>00728         <span class="keywordflow">if</span> (found) {
<a name="l00729"></a>00729                 <span class="comment">/*</span>
<a name="l00730"></a>00730 <span class="comment">                 * If the lock is being used by an IO, definitely not cancel it.</span>
<a name="l00731"></a>00731 <span class="comment">                 */</span>
<a name="l00732"></a>00732                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, weight = 1);
<a name="l00733"></a>00733         }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         weight = <a class="code" href="group__osc.html#ga9325a913aeaac8dbe7867ac4a8e86a12">osc_lock_weight</a>(env, obj, &amp;dlmlock-&gt;<a class="code" href="structldlm__lock.html#a30dc0349b0b525d72e9a3a92ad19ff79" title="Representation of private data specific for a lock type.">l_policy_data</a>.<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>);
<a name="l00736"></a>00736         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 out:
<a name="l00739"></a>00739         <a class="code" href="group__cl__env.html#gad0152e8236bb22b70e9066509070fded">cl_env_nested_put</a>(&amp;nest, env);
<a name="l00740"></a>00740         <span class="keywordflow">return</span> weight;
<a name="l00741"></a>00741 }
<a name="l00742"></a>00742 
<a name="l00743"></a><a class="code" href="group__osc.html#gaf9d3972737301af659fe94269be36549">00743</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gaf9d3972737301af659fe94269be36549">osc_lock_build_einfo</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00744"></a>00744                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock,
<a name="l00745"></a>00745                                  <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *osc,
<a name="l00746"></a>00746                                  <span class="keyword">struct</span> <a class="code" href="structldlm__enqueue__info.html" title="Common ldlm_enqueue parameters.">ldlm_enqueue_info</a> *einfo)
<a name="l00747"></a>00747 {
<a name="l00748"></a>00748         einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#a6b87487abead59973262624bf9f90eb0">ei_type</a>   = <a class="code" href="packet-lustre_8c.html#ab92227eb33b3bc79ee12e10421865cad">LDLM_EXTENT</a>;
<a name="l00749"></a>00749         einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a>   = <a class="code" href="group__osc.html#ga10c33ef023f6e4826b12f531287ecb74">osc_cl_lock2ldlm</a>(lock-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>.<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a>);
<a name="l00750"></a>00750         einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#abf96eb0f7a2c82dc89872dedfe64b223" title="Mode of the lock being enqueued.">ei_cb_bl</a>  = <a class="code" href="group__osc.html#ga3d96731374882d1b601e94dab8f92397" title="Blocking ast invoked by ldlm when dlm lock is either blocking progress of some other...">osc_ldlm_blocking_ast</a>;
<a name="l00751"></a>00751         einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#a08e843216d2e582b026fb5379fac9814" title="blocking local lock callback">ei_cb_cp</a>  = <a class="code" href="group__ldlm__local__ast.html#gaae5738d417a8624f65b5418d57fef359" title="Generic LDLM &amp;quot;completion&amp;quot; AST.">ldlm_completion_ast</a>;
<a name="l00752"></a>00752         einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#a486fcd5061cb4cb937812c7979d568b3" title="lock completion callback">ei_cb_gl</a>  = <a class="code" href="group__osc.html#gabeb20790e130bf97ca7999f0832fba5f">osc_ldlm_glimpse_ast</a>;
<a name="l00753"></a>00753         einfo-&gt;<a class="code" href="structldlm__enqueue__info.html#af0ba62d8b646a2164ec979fb9bca48d4" title="lock glimpse callback">ei_cbdata</a> = osc; <span class="comment">/* value to be put into -&gt;l_ast_data */</span>
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 
<a name="l00768"></a><a class="code" href="group__osc.html#gae950ceda261ffba5e5cfd891375e866d">00768</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gae950ceda261ffba5e5cfd891375e866d" title="Determine if the lock should be converted into a lockless lock.">osc_lock_to_lockless</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00769"></a>00769                                  <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *ols, <span class="keywordtype">int</span> force)
<a name="l00770"></a>00770 {
<a name="l00771"></a>00771         <span class="keyword">struct </span><a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice = &amp;ols-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>;
<a name="l00772"></a>00772 
<a name="l00773"></a>00773         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(ols-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> == <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a23081e5902c9447c703ecc678119d6e9">OLS_NEW</a> ||
<a name="l00774"></a>00774                 ols-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> == <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a5816097365b1593a67efc02f67f55037">OLS_UPCALL_RECEIVED</a>);
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         <span class="keywordflow">if</span> (force) {
<a name="l00777"></a>00777                 ols-&gt;<a class="code" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed" title="inherit the lockless attribute from top level cl_io.">ols_locklessable</a> = 1;
<a name="l00778"></a>00778                 slice-&gt;<a class="code" href="structcl__lock__slice.html#acf8f055c895f746f50fe19c4189defad">cls_ops</a> = &amp;<a class="code" href="group__osc.html#gae177dc16a77b0406ec3645ad1725734d">osc_lock_lockless_ops</a>;
<a name="l00779"></a>00779         } <span class="keywordflow">else</span> {
<a name="l00780"></a>00780                 <span class="keyword">struct </span><a class="code" href="structosc__io.html" title="State maintained by osc layer for each IO context.">osc_io</a> *oio     = <a class="code" href="group__osc.html#ga80a9df989eeced2c8854e2e74214ce40">osc_env_io</a>(env);
<a name="l00781"></a>00781                 <span class="keyword">struct </span><a class="code" href="structcl__io.html" title="State for io.">cl_io</a>  *io      = oio-&gt;<a class="code" href="structosc__io.html#a7ee5ca22311af0cd83adac47b95af6ca" title="super class">oi_cl</a>.<a class="code" href="structcl__io__slice.html#abc3f4df47b63dde53be1d7cdfd6d007c">cis_io</a>;
<a name="l00782"></a>00782                 <span class="keyword">struct </span><a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj  = slice-&gt;<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>;
<a name="l00783"></a>00783                 <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a> *oob = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(obj);
<a name="l00784"></a>00784                 <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structosc__device.html">osc_device</a> *osd = <a class="code" href="group__osc.html#ga4c77a45f48bd470506805b983a8d48c7">lu2osc_dev</a>(obj-&gt;<a class="code" href="structcl__object.html#acff3a09f38d513eda81deb6644332c2d" title="super class">co_lu</a>.<a class="code" href="structlu__object.html#a5b9108a283d9901c95bdf32833f70601" title="Device for this layer.">lo_dev</a>);
<a name="l00785"></a>00785                 <span class="keyword">struct </span><a class="code" href="structobd__connect__data.html">obd_connect_data</a> *ocd;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(io-&gt;<a class="code" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa" title="lock requirements, this is just a help info for sublayers.">ci_lockreq</a> == <a class="code" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824ba4e46f767dce68b1f061c35ec1edc0528" title="Always lock data (e.g., O_APPEND).">CILR_MANDATORY</a> ||
<a name="l00788"></a>00788                         io-&gt;<a class="code" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa" title="lock requirements, this is just a help info for sublayers.">ci_lockreq</a> == <a class="code" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824bafc402749f67a87f7c2508998b1caec47" title="Layers are free to decide between local and global locking.">CILR_MAYBE</a> ||
<a name="l00789"></a>00789                         io-&gt;<a class="code" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa" title="lock requirements, this is just a help info for sublayers.">ci_lockreq</a> == <a class="code" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824bacfd43489ba9d674ad77c4bdd51d3a7bc" title="Never lock: there is no cache (e.g., liblustre).">CILR_NEVER</a>);
<a name="l00790"></a>00790 
<a name="l00791"></a>00791                 ocd = &amp;<a class="code" href="group__export.html#ga2d80493ea727d72caf23f5ef37b4b428">class_exp2cliimp</a>(<a class="code" href="group__osc.html#ga62ec09b84963e0993a0c996837113edc">osc_export</a>(oob))-&gt;<a class="code" href="structobd__import.html#aa811a6418422d3a974c15908153f29ca">imp_connect_data</a>;
<a name="l00792"></a>00792                 ols-&gt;<a class="code" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed" title="inherit the lockless attribute from top level cl_io.">ols_locklessable</a> = (io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a> != <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378a0a7b38271be1f7d7faac2bfc3f8ce3a6" title="truncate, utime system calls">CIT_SETATTR</a>) &amp;&amp;
<a name="l00793"></a>00793                                 (io-&gt;<a class="code" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa" title="lock requirements, this is just a help info for sublayers.">ci_lockreq</a> == <a class="code" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824bafc402749f67a87f7c2508998b1caec47" title="Layers are free to decide between local and global locking.">CILR_MAYBE</a>) &amp;&amp;
<a name="l00794"></a>00794                                 (ocd-&gt;<a class="code" href="structobd__connect__data.html#a056d6aaded7f397e902843b52a36a6a5">ocd_connect_flags</a> &amp; <a class="code" href="group__lustreidl.html#gab4e4305bf5a9861a7eca289a6bf0168e">OBD_CONNECT_SRVLOCK</a>);
<a name="l00795"></a>00795                 <span class="keywordflow">if</span> (io-&gt;<a class="code" href="structcl__io.html#a245a0c27f43614baa43128f2e82867fa" title="lock requirements, this is just a help info for sublayers.">ci_lockreq</a> == <a class="code" href="group__cl__io.html#ggac7ff31ceda4789c9101711379ffe824bacfd43489ba9d674ad77c4bdd51d3a7bc" title="Never lock: there is no cache (e.g., liblustre).">CILR_NEVER</a> ||
<a name="l00796"></a>00796                         <span class="comment">/* lockless IO */</span>
<a name="l00797"></a>00797                     (ols-&gt;<a class="code" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed" title="inherit the lockless attribute from top level cl_io.">ols_locklessable</a> &amp;&amp; <a class="code" href="group__osc.html#gac2bf0d492fc8978c34d62dc408ead87d">osc_object_is_contended</a>(oob)) ||
<a name="l00798"></a>00798                         <span class="comment">/* lockless truncate */</span>
<a name="l00799"></a>00799                     (<a class="code" href="group__cl__io.html#gafc95427f78408eaab2a0857e92d1004a" title="True, iff io is a truncate(2).">cl_io_is_trunc</a>(io) &amp;&amp;
<a name="l00800"></a>00800                      (ocd-&gt;<a class="code" href="structobd__connect__data.html#a056d6aaded7f397e902843b52a36a6a5">ocd_connect_flags</a> &amp; <a class="code" href="group__lustreidl.html#gaccf9e49103b8bd0f9e12ff896d03ed3b">OBD_CONNECT_TRUNCLOCK</a>) &amp;&amp;
<a name="l00801"></a>00801                       osd-&gt;<a class="code" href="structosc__device.html#a45a0d16e8bb5da1cca719a0b36536543">od_lockless_truncate</a>)) {
<a name="l00802"></a>00802                         ols-&gt;<a class="code" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed" title="inherit the lockless attribute from top level cl_io.">ols_locklessable</a> = 1;
<a name="l00803"></a>00803                         slice-&gt;<a class="code" href="structcl__lock__slice.html#acf8f055c895f746f50fe19c4189defad">cls_ops</a> = &amp;<a class="code" href="group__osc.html#gae177dc16a77b0406ec3645ad1725734d">osc_lock_lockless_ops</a>;
<a name="l00804"></a>00804                 }
<a name="l00805"></a>00805         }
<a name="l00806"></a>00806         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(ols-&gt;<a class="code" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416" title="if set, the osc_lock is a glimpse lock.">ols_glimpse</a>, !<a class="code" href="group__osc.html#gaa565e6849b165c1b13f243a672677c99">osc_lock_is_lockless</a>(ols)));
<a name="l00807"></a>00807 }
<a name="l00808"></a>00808 
<a name="l00809"></a><a class="code" href="group__osc.html#gab65f4d86251c42976f7a34615d12d7fb">00809</a> <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="group__osc.html#gab65f4d86251c42976f7a34615d12d7fb">osc_lock_compatible</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *qing,
<a name="l00810"></a>00810                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *qed)
<a name="l00811"></a>00811 {
<a name="l00812"></a>00812         <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *qed_descr = &amp;qed-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>.<a class="code" href="structcl__lock__slice.html#abd152a13b7a1df918805b47ac43113b3">cls_lock</a>-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>;
<a name="l00813"></a>00813         <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *qing_descr = &amp;qing-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>.<a class="code" href="structcl__lock__slice.html#abd152a13b7a1df918805b47ac43113b3">cls_lock</a>-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815         <span class="keywordflow">if</span> (qed-&gt;<a class="code" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416" title="if set, the osc_lock is a glimpse lock.">ols_glimpse</a>)
<a name="l00816"></a>00816                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00817"></a>00817 
<a name="l00818"></a>00818         <span class="keywordflow">if</span> (qing_descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> == <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a> &amp;&amp; qed_descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> == <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a>)
<a name="l00819"></a>00819                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00820"></a>00820 
<a name="l00821"></a>00821         <span class="keywordflow">if</span> (qed-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> &lt; <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a2d25aac14431d41d5aaa8ae702e40705">OLS_GRANTED</a>)
<a name="l00822"></a>00822                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824         <span class="keywordflow">if</span> (qed_descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a>  &gt;= qing_descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> &amp;&amp;
<a name="l00825"></a>00825             qed_descr-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a> &lt;= qing_descr-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a> &amp;&amp;
<a name="l00826"></a>00826             qed_descr-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>   &gt;= qing_descr-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>)
<a name="l00827"></a>00827                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00830"></a>00830 }
<a name="l00831"></a>00831 
<a name="l00832"></a><a class="code" href="group__osc.html#ga023dc78f4efa274e91d49f39aeb869f7">00832</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga023dc78f4efa274e91d49f39aeb869f7">osc_lock_wake_waiters</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00833"></a>00833                                   <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *osc,
<a name="l00834"></a>00834                                   <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *oscl)
<a name="l00835"></a>00835 {
<a name="l00836"></a>00836         spin_lock(&amp;osc-&gt;<a class="code" href="structosc__object.html#a950a26b39516a8c32370d8cb1fe92c7f">oo_ol_spin</a>);
<a name="l00837"></a>00837         <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#a61ed1b1236e5970e472888bb62c81193" title="list entry for osc_object::oo_ol_list">ols_nextlock_oscobj</a>);
<a name="l00838"></a>00838         spin_unlock(&amp;osc-&gt;<a class="code" href="structosc__object.html#a950a26b39516a8c32370d8cb1fe92c7f">oo_ol_spin</a>);
<a name="l00839"></a>00839 
<a name="l00840"></a>00840         spin_lock(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">ols_lock</a>);
<a name="l00841"></a>00841         <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#a59dd81488c9fbd6733740cfaeed61b56" title="waiting list for this lock to be cancelled">ols_waiting_list</a>)) {
<a name="l00842"></a>00842                 <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *scan;
<a name="l00843"></a>00843 
<a name="l00844"></a>00844                 scan = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(oscl-&gt;<a class="code" href="structosc__lock.html#a59dd81488c9fbd6733740cfaeed61b56" title="waiting list for this lock to be cancelled">ols_waiting_list</a>.<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>, <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>,
<a name="l00845"></a>00845                                   <a class="code" href="structosc__lock.html#aaf07ba3202fb5cd4074a6b98bc41f9e3" title="wait entry of ols_waiting_list">ols_wait_entry</a>);
<a name="l00846"></a>00846                 <a class="code" href="list_8h.html#ae1cde0f50b85945cfff23be4fc1586f4" title="Remove an entry from the list it is currently in and reinitialize it.">list_del_init</a>(&amp;scan-&gt;<a class="code" href="structosc__lock.html#aaf07ba3202fb5cd4074a6b98bc41f9e3" title="wait entry of ols_waiting_list">ols_wait_entry</a>);
<a name="l00847"></a>00847 
<a name="l00848"></a>00848                 <a class="code" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9" title="Indicate that transfer of a single page completed.">cl_sync_io_note</a>(env, scan-&gt;<a class="code" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7" title="Owner sleeps on this channel for state change.">ols_owner</a>, 0);
<a name="l00849"></a>00849         }
<a name="l00850"></a>00850         spin_unlock(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">ols_lock</a>);
<a name="l00851"></a>00851 }
<a name="l00852"></a>00852 
<a name="l00853"></a><a class="code" href="group__osc.html#gab799760ac0c7ccb8e4f6b7f109ad619e">00853</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gab799760ac0c7ccb8e4f6b7f109ad619e">osc_lock_enqueue_wait</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00854"></a>00854                 <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *oscl)
<a name="l00855"></a>00855 {
<a name="l00856"></a>00856         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>         *tmp_oscl;
<a name="l00857"></a>00857         <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a>    *need = &amp;oscl-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>.<a class="code" href="structcl__lock__slice.html#abd152a13b7a1df918805b47ac43113b3">cls_lock</a>-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>;
<a name="l00858"></a>00858         <span class="keyword">struct </span><a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a>       *waiter = &amp;<a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env)-&gt;<a class="code" href="structosc__thread__info.html#aacabfd9f46cc51921b09d5053ac497f4">oti_anchor</a>;
<a name="l00859"></a>00859         <span class="keywordtype">int</span> rc = 0;
<a name="l00860"></a>00860         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00861"></a>00861 
<a name="l00862"></a>00862         spin_lock(&amp;obj-&gt;<a class="code" href="structosc__object.html#a950a26b39516a8c32370d8cb1fe92c7f">oo_ol_spin</a>);
<a name="l00863"></a>00863         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#a61ed1b1236e5970e472888bb62c81193" title="list entry for osc_object::oo_ol_list">ols_nextlock_oscobj</a>, &amp;obj-&gt;<a class="code" href="structosc__object.html#a7f440305c7a797bfcffc48fb36f73eda">oo_ol_list</a>);
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 restart:
<a name="l00866"></a>00866         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(tmp_oscl, &amp;obj-&gt;<a class="code" href="structosc__object.html#a7f440305c7a797bfcffc48fb36f73eda">oo_ol_list</a>,
<a name="l00867"></a>00867                             ols_nextlock_oscobj) {
<a name="l00868"></a>00868                 <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *descr;
<a name="l00869"></a>00869 
<a name="l00870"></a>00870                 <span class="keywordflow">if</span> (tmp_oscl == oscl)
<a name="l00871"></a>00871                         <span class="keywordflow">break</span>;
<a name="l00872"></a>00872 
<a name="l00873"></a>00873                 descr = &amp;tmp_oscl-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>.<a class="code" href="structcl__lock__slice.html#abd152a13b7a1df918805b47ac43113b3">cls_lock</a>-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>;
<a name="l00874"></a>00874                 <span class="keywordflow">if</span> (descr-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a> &gt; need-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a> ||
<a name="l00875"></a>00875                     descr-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>   &lt; need-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a>)
<a name="l00876"></a>00876                         <span class="keywordflow">continue</span>;
<a name="l00877"></a>00877 
<a name="l00878"></a>00878                 <span class="comment">/* We&apos;re not supposed to give up group lock */</span>
<a name="l00879"></a>00879                 <span class="keywordflow">if</span> (descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> == <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1a9216706e47555f5dcf27d23513323e52">CLM_GROUP</a>)
<a name="l00880"></a>00880                         <span class="keywordflow">break</span>;
<a name="l00881"></a>00881 
<a name="l00882"></a>00882                 <span class="keywordflow">if</span> (!<a class="code" href="group__osc.html#gaa565e6849b165c1b13f243a672677c99">osc_lock_is_lockless</a>(oscl) &amp;&amp;
<a name="l00883"></a>00883                     <a class="code" href="group__osc.html#gab65f4d86251c42976f7a34615d12d7fb">osc_lock_compatible</a>(oscl, tmp_oscl))
<a name="l00884"></a>00884                         <span class="keywordflow">continue</span>;
<a name="l00885"></a>00885 
<a name="l00886"></a>00886                 <span class="comment">/* wait for conflicting lock to be canceled */</span>
<a name="l00887"></a>00887                 <a class="code" href="group__cl__sync__io.html#ga9e4705c43e9207a09c6cd8c9fac1c3e5" title="Initialize synchronous io wait anchor.">cl_sync_io_init</a>(waiter, 1, <a class="code" href="group__cl__sync__io.html#ga068e3a27f8967f8656fe3407c898d1d6">cl_sync_io_end</a>);
<a name="l00888"></a>00888                 oscl-&gt;<a class="code" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7" title="Owner sleeps on this channel for state change.">ols_owner</a> = waiter;
<a name="l00889"></a>00889 
<a name="l00890"></a>00890                 spin_lock(&amp;tmp_oscl-&gt;<a class="code" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">ols_lock</a>);
<a name="l00891"></a>00891                 <span class="comment">/* add oscl into tmp&apos;s ols_waiting list */</span>
<a name="l00892"></a>00892                 <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#aaf07ba3202fb5cd4074a6b98bc41f9e3" title="wait entry of ols_waiting_list">ols_wait_entry</a>,
<a name="l00893"></a>00893                               &amp;tmp_oscl-&gt;<a class="code" href="structosc__lock.html#a59dd81488c9fbd6733740cfaeed61b56" title="waiting list for this lock to be cancelled">ols_waiting_list</a>);
<a name="l00894"></a>00894                 spin_unlock(&amp;tmp_oscl-&gt;<a class="code" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">ols_lock</a>);
<a name="l00895"></a>00895 
<a name="l00896"></a>00896                 spin_unlock(&amp;obj-&gt;<a class="code" href="structosc__object.html#a950a26b39516a8c32370d8cb1fe92c7f">oo_ol_spin</a>);
<a name="l00897"></a>00897                 rc = <a class="code" href="group__cl__sync__io.html#ga92057d29f315080be03e18c0262a1871" title="Wait until all IO completes.">cl_sync_io_wait</a>(env, waiter, 0);
<a name="l00898"></a>00898                 spin_lock(&amp;obj-&gt;<a class="code" href="structosc__object.html#a950a26b39516a8c32370d8cb1fe92c7f">oo_ol_spin</a>);
<a name="l00899"></a>00899 
<a name="l00900"></a>00900                 <span class="keywordflow">if</span> (rc &lt; 0)
<a name="l00901"></a>00901                         <span class="keywordflow">break</span>;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903                 oscl-&gt;<a class="code" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7" title="Owner sleeps on this channel for state change.">ols_owner</a> = NULL;
<a name="l00904"></a>00904                 <span class="keywordflow">goto</span> restart;
<a name="l00905"></a>00905         }
<a name="l00906"></a>00906         spin_unlock(&amp;obj-&gt;<a class="code" href="structosc__object.html#a950a26b39516a8c32370d8cb1fe92c7f">oo_ol_spin</a>);
<a name="l00907"></a>00907 
<a name="l00908"></a>00908         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(rc);
<a name="l00909"></a>00909 }
<a name="l00910"></a>00910 
<a name="l00925"></a><a class="code" href="group__osc.html#ga7593097c6dc02fd995d0453038fbecd2">00925</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga7593097c6dc02fd995d0453038fbecd2" title="Implementation of cl_lock_operations::clo_enqueue() method for osc layer.">osc_lock_enqueue</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l00926"></a>00926                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice,
<a name="l00927"></a>00927                             <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *unused, <span class="keyword">struct</span> <a class="code" href="structcl__sync__io.html" title="Anchor for synchronous transfer.">cl_sync_io</a> *anchor)
<a name="l00928"></a>00928 {
<a name="l00929"></a>00929         <span class="keyword">struct </span><a class="code" href="structosc__thread__info.html">osc_thread_info</a>          *info  = <a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env);
<a name="l00930"></a>00930         <span class="keyword">struct </span><a class="code" href="structosc__io.html" title="State maintained by osc layer for each IO context.">osc_io</a>                   *oio   = <a class="code" href="group__osc.html#ga80a9df989eeced2c8854e2e74214ce40">osc_env_io</a>(env);
<a name="l00931"></a>00931         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a>               *osc   = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(slice-&gt;<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>);
<a name="l00932"></a>00932         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>                 *oscl  = <a class="code" href="group__osc.html#ga9858e598601602f25f65cd55b4e98c0e">cl2osc_lock</a>(slice);
<a name="l00933"></a>00933         <span class="keyword">struct </span><a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>                  *lock  = slice-&gt;<a class="code" href="structcl__lock__slice.html#abd152a13b7a1df918805b47ac43113b3">cls_lock</a>;
<a name="l00934"></a>00934         <span class="keyword">struct </span><a class="code" href="structldlm__res__id.html">ldlm_res_id</a>              *resname = &amp;info-&gt;<a class="code" href="structosc__thread__info.html#a4ddc57930642d6fa4191333d22ed2d4b">oti_resname</a>;
<a name="l00935"></a>00935         <span class="keyword">union </span><a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a>          *policy  = &amp;info-&gt;<a class="code" href="structosc__thread__info.html#a2fee545583b6ef8741d83fbb3d42dae1">oti_policy</a>;
<a name="l00936"></a>00936         <a class="code" href="osc__internal_8h.html#a5809fffe78bdf9f7d43e4e427c7ec90f">osc_enqueue_upcall_f</a>            upcall   = <a class="code" href="group__osc.html#ga29f791d1abf24609d793f38771cc90b3" title="Lock upcall function that is executed either when a reply to ENQUEUE rpc is received...">osc_lock_upcall</a>;
<a name="l00937"></a>00937         <span class="keywordtype">void</span>                            *cookie  = oscl;
<a name="l00938"></a>00938         <span class="keywordtype">bool</span>                            async    = <span class="keyword">false</span>;
<a name="l00939"></a>00939         <span class="keywordtype">int</span>                             result;
<a name="l00940"></a>00940 
<a name="l00941"></a>00941         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <a class="code" href="utils_2wirehdr_8c.html#a2e063b87e63a187e8b2302ef6628b842">LASSERTF</a>(<a class="code" href="osd__iam_8h.html#a7f75ab6839d468f4d23480a9c65724c5">ergo</a>(oscl-&gt;<a class="code" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416" title="if set, the osc_lock is a glimpse lock.">ols_glimpse</a>, lock-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>.<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> &lt;= <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1afaf0c2a08e023e6c4bafbf758093b1d4">CLM_READ</a>),
<a name="l00944"></a>00944                 <span class="stringliteral">&quot;lock = %p, ols = %p\n&quot;</span>, lock, oscl);
<a name="l00945"></a>00945 
<a name="l00946"></a>00946         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> == <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a2d25aac14431d41d5aaa8ae702e40705">OLS_GRANTED</a>)
<a name="l00947"></a>00947                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a> &amp; <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>)
<a name="l00950"></a>00950                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(enqueue_base, 0);
<a name="l00951"></a>00951 
<a name="l00952"></a>00952         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416" title="if set, the osc_lock is a glimpse lock.">ols_glimpse</a>) {
<a name="l00953"></a>00953                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="osd__iam_8h.html#aeefd33b919b7320ecefdf0d16ca7d993">equi</a>(oscl-&gt;<a class="code" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001" title="For async glimpse lock.">ols_agl</a>, anchor == NULL));
<a name="l00954"></a>00954                 async = <span class="keyword">true</span>;
<a name="l00955"></a>00955                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(enqueue_base, 0);
<a name="l00956"></a>00956         }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958         result = <a class="code" href="group__osc.html#gab799760ac0c7ccb8e4f6b7f109ad619e">osc_lock_enqueue_wait</a>(env, osc, oscl);
<a name="l00959"></a>00959         <span class="keywordflow">if</span> (result &lt; 0)
<a name="l00960"></a>00960                 <a class="code" href="small__write_8c.html#ad2ce2f6a9a52e27a453236173fb2cb12">GOTO</a>(out, result);
<a name="l00961"></a>00961 
<a name="l00962"></a>00962         <span class="comment">/* we can grant lockless lock right after all conflicting locks</span>
<a name="l00963"></a>00963 <span class="comment">         * are canceled. */</span>
<a name="l00964"></a>00964         <span class="keywordflow">if</span> (<a class="code" href="group__osc.html#gaa565e6849b165c1b13f243a672677c99">osc_lock_is_lockless</a>(oscl)) {
<a name="l00965"></a>00965                 oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> = <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a2d25aac14431d41d5aaa8ae702e40705">OLS_GRANTED</a>;
<a name="l00966"></a>00966                 oio-&gt;<a class="code" href="structosc__io.html#a8dc8c1963fac8b54b8e5953f22352b3e" title="true if this io is lockless.">oi_lockless</a> = 1;
<a name="l00967"></a>00967                 <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(0);
<a name="l00968"></a>00968         }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970 enqueue_base:
<a name="l00971"></a>00971         oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> = <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a776ca12c4ee51af431b067dea743f901">OLS_ENQUEUED</a>;
<a name="l00972"></a>00972         <span class="keywordflow">if</span> (anchor != NULL) {
<a name="l00973"></a>00973                 atomic_inc(&amp;anchor-&gt;<a class="code" href="structcl__sync__io.html#aaf7f7fe203e365e9074f83bb8d5e2298" title="number of pages yet to be transferred.">csi_sync_nr</a>);
<a name="l00974"></a>00974                 oscl-&gt;<a class="code" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7" title="Owner sleeps on this channel for state change.">ols_owner</a> = anchor;
<a name="l00975"></a>00975         }
<a name="l00976"></a>00976 
<a name="l00983"></a>00983         <a class="code" href="group__fid.html#gaaaba49803730bc60e29110c7104bff68" title="Build DLM resource name from object id &amp;amp; seq, which will be removed finally,...">ostid_build_res_name</a>(&amp;osc-&gt;<a class="code" href="structosc__object.html#aa101340a37e6780faa2a9fecc3d3a4a1">oo_oinfo</a>-&gt;<a class="code" href="structlov__oinfo.html#a8d09d3283744c17ac1dd29e7235d5c7b">loi_oi</a>, resname);
<a name="l00984"></a>00984         <a class="code" href="group__osc.html#gaa5a7b973cac7b99a2bd42990c4d5f368">osc_lock_build_policy</a>(env, lock, policy);
<a name="l00985"></a>00985         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001" title="For async glimpse lock.">ols_agl</a>) {
<a name="l00986"></a>00986                 oscl-&gt;<a class="code" href="structosc__lock.html#a4d1369425e04be04518a52972a05bf89">ols_einfo</a>.<a class="code" href="structldlm__enqueue__info.html#af0ba62d8b646a2164ec979fb9bca48d4" title="lock glimpse callback">ei_cbdata</a> = NULL;
<a name="l00987"></a>00987                 <span class="comment">/* hold a reference for callback */</span>
<a name="l00988"></a>00988                 <a class="code" href="group__cl__object.html#gae84de86afc6e9dbf1f9e1a7219bd202b" title="Acquire an additional reference to the object o.">cl_object_get</a>(<a class="code" href="group__osc.html#gabeee966e59f8ff3f8a8c3cba94b63559">osc2cl</a>(osc));
<a name="l00989"></a>00989                 upcall = <a class="code" href="group__osc.html#gaf9b0a5fcc4fbfa6437afc998a0b8657d">osc_lock_upcall_agl</a>;
<a name="l00990"></a>00990                 cookie = osc;
<a name="l00991"></a>00991         }
<a name="l00992"></a>00992         result = <a class="code" href="osc__internal_8h.html#aad7a0f5242c750c4920c0b3f801ea07f">osc_enqueue_base</a>(<a class="code" href="group__osc.html#ga62ec09b84963e0993a0c996837113edc">osc_export</a>(osc), resname, &amp;oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a>,
<a name="l00993"></a>00993                                   policy, &amp;oscl-&gt;<a class="code" href="structosc__lock.html#a942265d5ad56c6b1260aa06ae9df6960" title="lock value block">ols_lvb</a>,
<a name="l00994"></a>00994                                   osc-&gt;<a class="code" href="structosc__object.html#aa101340a37e6780faa2a9fecc3d3a4a1">oo_oinfo</a>-&gt;<a class="code" href="structlov__oinfo.html#aa755ce6d1c4d5d9b1be2cd245a162477">loi_kms_valid</a>,
<a name="l00995"></a>00995                                   upcall, cookie,
<a name="l00996"></a>00996                                   &amp;oscl-&gt;<a class="code" href="structosc__lock.html#a4d1369425e04be04518a52972a05bf89">ols_einfo</a>, <a class="code" href="osc__internal_8h.html#aa45a2aadf67d5ff2d284201e7e354b52">PTLRPCD_SET</a>, async,
<a name="l00997"></a>00997                                   oscl-&gt;<a class="code" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001" title="For async glimpse lock.">ols_agl</a>);
<a name="l00998"></a>00998         <span class="keywordflow">if</span> (result == 0) {
<a name="l00999"></a>00999                 <span class="keywordflow">if</span> (<a class="code" href="group__osc.html#gaa565e6849b165c1b13f243a672677c99">osc_lock_is_lockless</a>(oscl)) {
<a name="l01000"></a>01000                         oio-&gt;<a class="code" href="structosc__io.html#a8dc8c1963fac8b54b8e5953f22352b3e" title="true if this io is lockless.">oi_lockless</a> = 1;
<a name="l01001"></a>01001                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!async) {
<a name="l01002"></a>01002                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> == <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a2d25aac14431d41d5aaa8ae702e40705">OLS_GRANTED</a>);
<a name="l01003"></a>01003                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oscl-&gt;<a class="code" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">ols_hold</a>);
<a name="l01004"></a>01004                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oscl-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a> != NULL);
<a name="l01005"></a>01005                 }
<a name="l01006"></a>01006         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001" title="For async glimpse lock.">ols_agl</a>) {
<a name="l01007"></a>01007                 <a class="code" href="group__cl__object.html#ga61a377b8d6ccf182357c959cfdbbcf16" title="Releases a reference on o.">cl_object_put</a>(env, <a class="code" href="group__osc.html#gabeee966e59f8ff3f8a8c3cba94b63559">osc2cl</a>(osc));
<a name="l01008"></a>01008                 result = 0;
<a name="l01009"></a>01009         }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 out:
<a name="l01012"></a>01012         <span class="keywordflow">if</span> (result &lt; 0) {
<a name="l01013"></a>01013                 oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> = <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a0be13e08c2f9842b70f8f380a029ad49">OLS_CANCELLED</a>;
<a name="l01014"></a>01014                 <a class="code" href="group__osc.html#ga023dc78f4efa274e91d49f39aeb869f7">osc_lock_wake_waiters</a>(env, osc, oscl);
<a name="l01015"></a>01015 
<a name="l01016"></a>01016                 <span class="keywordflow">if</span> (anchor != NULL)
<a name="l01017"></a>01017                         <a class="code" href="group__cl__sync__io.html#gadb134aa2c1fb3f510bb8fe2a6da02bb9" title="Indicate that transfer of a single page completed.">cl_sync_io_note</a>(env, anchor, result);
<a name="l01018"></a>01018         }
<a name="l01019"></a>01019         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(result);
<a name="l01020"></a>01020 }
<a name="l01021"></a>01021 
<a name="l01025"></a><a class="code" href="group__osc.html#ga0b1ea64f21458b5bb73af82b0feda0df">01025</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga0b1ea64f21458b5bb73af82b0feda0df" title="Breaks a link between osc_lock and dlm_lock.">osc_lock_detach</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *olck)
<a name="l01026"></a>01026 {
<a name="l01027"></a>01027         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *dlmlock;
<a name="l01028"></a>01028 
<a name="l01029"></a>01029         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01030"></a>01030 
<a name="l01031"></a>01031         dlmlock = olck-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a>;
<a name="l01032"></a>01032         <span class="keywordflow">if</span> (dlmlock == NULL)
<a name="l01033"></a>01033                 <a class="code" href="libcfs__debug_8h.html#add49da686844faee56b8f16f9c784085">RETURN_EXIT</a>;
<a name="l01034"></a>01034 
<a name="l01035"></a>01035         <span class="keywordflow">if</span> (olck-&gt;<a class="code" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">ols_hold</a>) {
<a name="l01036"></a>01036                 olck-&gt;<a class="code" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">ols_hold</a> = 0;
<a name="l01037"></a>01037                 <a class="code" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref</a>(&amp;olck-&gt;<a class="code" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">ols_handle</a>, olck-&gt;<a class="code" href="structosc__lock.html#a4d1369425e04be04518a52972a05bf89">ols_einfo</a>.<a class="code" href="structldlm__enqueue__info.html#af97991a29b4940204cb0bef4bafeb678" title="Type of the lock being enqueued.">ei_mode</a>);
<a name="l01038"></a>01038                 olck-&gt;<a class="code" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">ols_handle</a>.<a class="code" href="structlustre__handle.html#a735d65d1a27d9cafdc17245e4574000a">cookie</a> = 0ULL;
<a name="l01039"></a>01039         }
<a name="l01040"></a>01040 
<a name="l01041"></a>01041         olck-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a> = NULL;
<a name="l01042"></a>01042 
<a name="l01043"></a>01043         <span class="comment">/* release a reference taken in osc_lock_upcall(). */</span>
<a name="l01044"></a>01044         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(olck-&gt;<a class="code" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152" title="this is much like osc_lock::ols_hold, except that this bit is cleared _after_ reference...">ols_has_ref</a>);
<a name="l01045"></a>01045         <a class="code" href="group__lu__ref.html#ga9502d6573eadb28a4ea33ff6482e1752">lu_ref_del</a>(&amp;dlmlock-&gt;<a class="code" href="structldlm__lock.html#a2cc84a3989e5b197caffa7a0fe014f27" title="Reference tracking structure to debug leaked locks.">l_reference</a>, <span class="stringliteral">&quot;osc_lock&quot;</span>, olck);
<a name="l01046"></a>01046         <a class="code" href="group__LDLM.html#gaf3357d35be5378aa299677e298c5a625" title="Release a lock reference obtained by some other means (see LDLM_LOCK_PUT()).">LDLM_LOCK_RELEASE</a>(dlmlock);
<a name="l01047"></a>01047         olck-&gt;<a class="code" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152" title="this is much like osc_lock::ols_hold, except that this bit is cleared _after_ reference...">ols_has_ref</a> = 0;
<a name="l01048"></a>01048 
<a name="l01049"></a>01049         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l01050"></a>01050 }
<a name="l01051"></a>01051 
<a name="l01066"></a><a class="code" href="group__osc.html#gacc121e00f4060228eda6e7504a4cc1d0">01066</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gacc121e00f4060228eda6e7504a4cc1d0" title="Implements cl_lock_operations::clo_cancel() method for osc layer.">osc_lock_cancel</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01067"></a>01067                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice)
<a name="l01068"></a>01068 {
<a name="l01069"></a>01069         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a> *obj  = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(slice-&gt;<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>);
<a name="l01070"></a>01070         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>   *oscl = <a class="code" href="group__osc.html#ga9858e598601602f25f65cd55b4e98c0e">cl2osc_lock</a>(slice);
<a name="l01071"></a>01071 
<a name="l01072"></a>01072         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01073"></a>01073 
<a name="l01074"></a>01074         <a class="code" href="libcfs__private_8h.html#a85e7b3762b6313387835c7ea0dd29081">LINVRNT</a>(<a class="code" href="group__osc.html#ga54adc12953bce11081c44d696c8b147e" title="Invariant that has to be true all of the time.">osc_lock_invariant</a>(oscl));
<a name="l01075"></a>01075 
<a name="l01076"></a>01076         <a class="code" href="group__osc.html#ga0b1ea64f21458b5bb73af82b0feda0df" title="Breaks a link between osc_lock and dlm_lock.">osc_lock_detach</a>(env, oscl);
<a name="l01077"></a>01077         oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> = <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a0be13e08c2f9842b70f8f380a029ad49">OLS_CANCELLED</a>;
<a name="l01078"></a>01078         oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a> &amp;= ~<a class="code" href="group__LDLM.html#ga3af51d9e1097e0aeaacd1c3cc88fec62" title="XXX FIXME: This is being added to b_size as a low-risk fix to the fact that the LVB...">LDLM_FL_LVB_READY</a>;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080         <a class="code" href="group__osc.html#ga023dc78f4efa274e91d49f39aeb869f7">osc_lock_wake_waiters</a>(env, obj, oscl);
<a name="l01081"></a>01081         <a class="code" href="flock_8c.html#ad111e603bbebe5d87f6bc39264ce4733">EXIT</a>;
<a name="l01082"></a>01082 }
<a name="l01083"></a>01083 
<a name="l01084"></a><a class="code" href="group__osc.html#ga3448ad07c07772caeab7bc754ce00c9f">01084</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#ga3448ad07c07772caeab7bc754ce00c9f">osc_lock_print</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env, <span class="keywordtype">void</span> *cookie,
<a name="l01085"></a>01085                           <a class="code" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc" title="Type of &amp;quot;printer&amp;quot; function used by lu_object_operations::loo_object_print()...">lu_printer_t</a> p, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice)
<a name="l01086"></a>01086 {
<a name="l01087"></a>01087         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *lock = <a class="code" href="group__osc.html#ga9858e598601602f25f65cd55b4e98c0e">cl2osc_lock</a>(slice);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089         (*p)(env, cookie, <span class="stringliteral">&quot;%p &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot; &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a><span class="stringliteral">&quot; %d %p &quot;</span>,
<a name="l01090"></a>01090              lock-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a>, lock-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a>, lock-&gt;<a class="code" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">ols_handle</a>.<a class="code" href="structlustre__handle.html#a735d65d1a27d9cafdc17245e4574000a">cookie</a>,
<a name="l01091"></a>01091              lock-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a>, lock-&gt;<a class="code" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7" title="Owner sleeps on this channel for state change.">ols_owner</a>);
<a name="l01092"></a>01092         <a class="code" href="group__osc.html#ga6aa1f3c3c89042ae19f13680ff68cf89">osc_lvb_print</a>(env, cookie, p, &amp;lock-&gt;<a class="code" href="structosc__lock.html#a942265d5ad56c6b1260aa06ae9df6960" title="lock value block">ols_lvb</a>);
<a name="l01093"></a>01093         <span class="keywordflow">return</span> 0;
<a name="l01094"></a>01094 }
<a name="l01095"></a>01095 
<a name="l01096"></a>01096 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__lock__operations.html">cl_lock_operations</a> <a class="code" href="group__osc.html#gaf69bf16bf23d5ce82362b480fcb0a331">osc_lock_ops</a> = {
<a name="l01097"></a>01097         .<a class="code" href="structcl__lock__operations.html#a4b649544378d50bf50bcb9c65d49795a" title="Destructor.">clo_fini</a>    = <a class="code" href="group__osc.html#gab6bded0dd5d3b8886cb39393501ee7e3">osc_lock_fini</a>,
<a name="l01098"></a>01098         .clo_enqueue = <a class="code" href="group__osc.html#ga7593097c6dc02fd995d0453038fbecd2" title="Implementation of cl_lock_operations::clo_enqueue() method for osc layer.">osc_lock_enqueue</a>,
<a name="l01099"></a>01099         .clo_cancel  = <a class="code" href="group__osc.html#gacc121e00f4060228eda6e7504a4cc1d0" title="Implements cl_lock_operations::clo_cancel() method for osc layer.">osc_lock_cancel</a>,
<a name="l01100"></a>01100         .clo_print   = <a class="code" href="group__osc.html#ga3448ad07c07772caeab7bc754ce00c9f">osc_lock_print</a>,
<a name="l01101"></a>01101 };
<a name="l01102"></a>01102 
<a name="l01103"></a><a class="code" href="group__osc.html#gaf0377559340dde5b6d5c16cfabc67d64">01103</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#gaf0377559340dde5b6d5c16cfabc67d64">osc_lock_lockless_cancel</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01104"></a>01104                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a> *slice)
<a name="l01105"></a>01105 {
<a name="l01106"></a>01106         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a>      *ols   = <a class="code" href="group__osc.html#ga9858e598601602f25f65cd55b4e98c0e">cl2osc_lock</a>(slice);
<a name="l01107"></a>01107         <span class="keyword">struct </span><a class="code" href="structosc__object.html">osc_object</a>    *osc   = <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(slice-&gt;<a class="code" href="structcl__lock__slice.html#a7b92d10a7e81059bb811ba196a438d56" title="Object slice corresponding to this lock slice.">cls_obj</a>);
<a name="l01108"></a>01108         <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *descr = &amp;slice-&gt;<a class="code" href="structcl__lock__slice.html#abd152a13b7a1df918805b47ac43113b3">cls_lock</a>-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>;
<a name="l01109"></a>01109         <span class="keywordtype">int</span> result;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(ols-&gt;<a class="code" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">ols_dlmlock</a> == NULL);
<a name="l01112"></a>01112         result = <a class="code" href="group__osc.html#ga3a7f4b12063dd00ce41a418fb3818e39">osc_lock_flush</a>(osc, descr-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a>, descr-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a>,
<a name="l01113"></a>01113                                 descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a>, 0);
<a name="l01114"></a>01114         <span class="keywordflow">if</span> (result)
<a name="l01115"></a>01115                 <a class="code" href="libcfs__debug_8h.html#ad06acc43c8c74fb94f76adde491a72ac">CERROR</a>(<span class="stringliteral">&quot;Pages for lockless lock %p were not purged(%d)\n&quot;</span>,
<a name="l01116"></a>01116                        ols, result);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118         <a class="code" href="group__osc.html#ga023dc78f4efa274e91d49f39aeb869f7">osc_lock_wake_waiters</a>(env, osc, ols);
<a name="l01119"></a>01119 }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcl__lock__operations.html">cl_lock_operations</a> <a class="code" href="group__osc.html#gae177dc16a77b0406ec3645ad1725734d">osc_lock_lockless_ops</a> = {
<a name="l01122"></a>01122         .<a class="code" href="structcl__lock__operations.html#a4b649544378d50bf50bcb9c65d49795a" title="Destructor.">clo_fini</a>      = <a class="code" href="group__osc.html#gab6bded0dd5d3b8886cb39393501ee7e3">osc_lock_fini</a>,
<a name="l01123"></a>01123         .clo_enqueue   = <a class="code" href="group__osc.html#ga7593097c6dc02fd995d0453038fbecd2" title="Implementation of cl_lock_operations::clo_enqueue() method for osc layer.">osc_lock_enqueue</a>,
<a name="l01124"></a>01124         .clo_cancel    = <a class="code" href="group__osc.html#gaf0377559340dde5b6d5c16cfabc67d64">osc_lock_lockless_cancel</a>,
<a name="l01125"></a>01125         .clo_print     = <a class="code" href="group__osc.html#ga3448ad07c07772caeab7bc754ce00c9f">osc_lock_print</a>
<a name="l01126"></a>01126 };
<a name="l01127"></a>01127 
<a name="l01128"></a><a class="code" href="group__osc.html#ga7e5994ba02ffc93e8e2ccc8d91c4b19e">01128</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__osc.html#ga7e5994ba02ffc93e8e2ccc8d91c4b19e">osc_lock_set_writer</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01129"></a>01129                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io,
<a name="l01130"></a>01130                                 <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *oscl)
<a name="l01131"></a>01131 {
<a name="l01132"></a>01132         <span class="keyword">struct </span><a class="code" href="structcl__lock__descr.html" title="Lock description.">cl_lock_descr</a> *descr = &amp;oscl-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>.<a class="code" href="structcl__lock__slice.html#abd152a13b7a1df918805b47ac43113b3">cls_lock</a>-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>;
<a name="l01133"></a>01133         pgoff_t io_start;
<a name="l01134"></a>01134         pgoff_t io_end;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136         <span class="keywordflow">if</span> (!<a class="code" href="group__cl__object.html#ga49a29b0baac53b37e4a7e7334c081c21" title="Returns true, iff o0 and o1 are slices of the same object.">cl_object_same</a>(io-&gt;<a class="code" href="structcl__io.html#ab2758184445778d1acf0282ac0e6687b" title="main object this io is against.">ci_obj</a>, obj))
<a name="l01137"></a>01137                 <span class="keywordflow">return</span>;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a> == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475" title="write system call">CIT_WRITE</a>)) {
<a name="l01140"></a>01140                 io_start = <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(obj, io-&gt;<a class="code" href="structcl__io.html#a8b561db29f0b79fba4d14b66b9882530">u</a>.<a class="code" href="structcl__io.html#af169d766a52d3a74b080f712b0ec062a">ci_rw</a>.<a class="code" href="structcl__io__rw__common.html#ab26f1075c6f3b543ce4d5dc150ddb3a1">crw_pos</a>);
<a name="l01141"></a>01141                 io_end = <a class="code" href="group__cl__page.html#gaa04da32f8652bb1f20f7017d8ed387e4" title="Converts a page index into a byte offset within object obj.">cl_index</a>(obj, io-&gt;<a class="code" href="structcl__io.html#a8b561db29f0b79fba4d14b66b9882530">u</a>.<a class="code" href="structcl__io.html#af169d766a52d3a74b080f712b0ec062a">ci_rw</a>.<a class="code" href="structcl__io__rw__common.html#ab26f1075c6f3b543ce4d5dc150ddb3a1">crw_pos</a> +
<a name="l01142"></a>01142                                                 io-&gt;<a class="code" href="structcl__io.html#a8b561db29f0b79fba4d14b66b9882530">u</a>.<a class="code" href="structcl__io.html#af169d766a52d3a74b080f712b0ec062a">ci_rw</a>.<a class="code" href="structcl__io__rw__common.html#af24378d4ab416fe6705cdf3b4db6da93">crw_count</a> - 1);
<a name="l01143"></a>01143                 <span class="keywordflow">if</span> (<a class="code" href="group__cl__io.html#ga81a17e84380b3479ecbe1e4a0a868801" title="True, iff io is an O_APPEND write(2).">cl_io_is_append</a>(io)) {
<a name="l01144"></a>01144                         io_start = 0;
<a name="l01145"></a>01145                         io_end = <a class="code" href="group__clio.html#gafe652221af494d72225936c18562922f">CL_PAGE_EOF</a>;
<a name="l01146"></a>01146                 }
<a name="l01147"></a>01147         } <span class="keywordflow">else</span> {
<a name="l01148"></a>01148                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="group__cl__io.html#gabb552842f09a0899378f5a04410f4dc7">cl_io_is_mkwrite</a>(io));
<a name="l01149"></a>01149                 io_start = io_end = io-&gt;<a class="code" href="structcl__io.html#a8b561db29f0b79fba4d14b66b9882530">u</a>.<a class="code" href="structcl__io.html#a1a7759183426a4d21ab676823e0a8a11">ci_fault</a>.ft_index;
<a name="l01150"></a>01150         }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152         <span class="keywordflow">if</span> (descr-&gt;<a class="code" href="structcl__lock__descr.html#a38822af64d2e66354d0a1aeea10b260c" title="Lock mode.">cld_mode</a> &gt;= <a class="code" href="group__cl__lock.html#gga85e741e93c4ba0b8fd87206425e347a1acf7d9afdb41a33222d042680cd268179">CLM_WRITE</a> &amp;&amp;
<a name="l01153"></a>01153             descr-&gt;<a class="code" href="structcl__lock__descr.html#aafdf4a5ff7082bf16fee443e1fb0ba23" title="Index of the first page protected by this lock.">cld_start</a> &lt;= io_start &amp;&amp; descr-&gt;<a class="code" href="structcl__lock__descr.html#a36fdfb9057af6617dcb7ce622059bcf3" title="Index of the last page (inclusive) protected by this lock.">cld_end</a> &gt;= io_end) {
<a name="l01154"></a>01154                 <span class="keyword">struct </span><a class="code" href="structosc__io.html" title="State maintained by osc layer for each IO context.">osc_io</a> *oio = <a class="code" href="group__osc.html#ga80a9df989eeced2c8854e2e74214ce40">osc_env_io</a>(env);
<a name="l01155"></a>01155 
<a name="l01156"></a>01156                 <span class="comment">/* There must be only one lock to match the write region */</span>
<a name="l01157"></a>01157                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(oio-&gt;<a class="code" href="structosc__io.html#a40f597a8aa0127c8b2db17502f0dcbea" title="write osc_lock for this IO, used by osc_extent_find().">oi_write_osclock</a> == NULL);
<a name="l01158"></a>01158                 oio-&gt;<a class="code" href="structosc__io.html#a40f597a8aa0127c8b2db17502f0dcbea" title="write osc_lock for this IO, used by osc_extent_find().">oi_write_osclock</a> = oscl;
<a name="l01159"></a>01159         }
<a name="l01160"></a>01160 }
<a name="l01161"></a>01161 
<a name="l01162"></a><a class="code" href="group__osc.html#gabd5ab860e2021ff6b4cd161a7392744a">01162</a> <span class="keywordtype">int</span> <a class="code" href="group__osc.html#gabd5ab860e2021ff6b4cd161a7392744a">osc_lock_init</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01163"></a>01163                   <span class="keyword">struct</span> <a class="code" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> *obj, <span class="keyword">struct</span> <a class="code" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> *lock,
<a name="l01164"></a>01164                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcl__io.html" title="State for io.">cl_io</a> *io)
<a name="l01165"></a>01165 {
<a name="l01166"></a>01166         <span class="keyword">struct </span><a class="code" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> *oscl;
<a name="l01167"></a>01167         __u32 enqflags = lock-&gt;<a class="code" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79" title="lock attribute, extent, cl_object, etc.">cll_descr</a>.<a class="code" href="structcl__lock__descr.html#a7e923c851e4a58e9e561a3b4e2d85a2e" title="flags to enqueue lock.">cld_enq_flags</a>;
<a name="l01168"></a>01168 
<a name="l01169"></a>01169         <a class="code" href="obd__support_8h.html#a17051758ec7639b4156d85894b7df140">OBD_SLAB_ALLOC_PTR_GFP</a>(oscl, <a class="code" href="group__osc.html#gab64712a972a010e480fe937ff1382a55">osc_lock_kmem</a>, GFP_NOFS);
<a name="l01170"></a>01170         <span class="keywordflow">if</span> (oscl == NULL)
<a name="l01171"></a>01171                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l01172"></a>01172 
<a name="l01173"></a>01173         oscl-&gt;<a class="code" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a> = <a class="code" href="group__osc.html#ggaa4f7ee68e4b3bb49dcf8c8f62ac36215a23081e5902c9447c703ecc678119d6e9">OLS_NEW</a>;
<a name="l01174"></a>01174         spin_lock_init(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">ols_lock</a>);
<a name="l01175"></a>01175         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#a59dd81488c9fbd6733740cfaeed61b56" title="waiting list for this lock to be cancelled">ols_waiting_list</a>);
<a name="l01176"></a>01176         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#aaf07ba3202fb5cd4074a6b98bc41f9e3" title="wait entry of ols_waiting_list">ols_wait_entry</a>);
<a name="l01177"></a>01177         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;oscl-&gt;<a class="code" href="structosc__lock.html#a61ed1b1236e5970e472888bb62c81193" title="list entry for osc_object::oo_ol_list">ols_nextlock_oscobj</a>);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179         oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a> = <a class="code" href="group__osc.html#ga8dd2b15bab97b5408114762ab5c22c95">osc_enq2ldlm_flags</a>(enqflags);
<a name="l01180"></a>01180         oscl-&gt;<a class="code" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001" title="For async glimpse lock.">ols_agl</a> = !!(enqflags &amp; <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a143ec61f815da4099f40d16b5e1b13d2" title="for async glimpse lock.">CEF_AGL</a>);
<a name="l01181"></a>01181         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001" title="For async glimpse lock.">ols_agl</a>)
<a name="l01182"></a>01182                 oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a> |= <a class="code" href="group__LDLM.html#ga34a11c94b46a7cd00e464a9063ff3879" title="Server told not to wait if blocked.">LDLM_FL_BLOCK_NOWAIT</a>;
<a name="l01183"></a>01183         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a> &amp; <a class="code" href="group__LDLM.html#ga71a692568def3030f14e3a56f51eacc2" title="lock request has intent">LDLM_FL_HAS_INTENT</a>) {
<a name="l01184"></a>01184                 oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a> |= <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a>;
<a name="l01185"></a>01185                 oscl-&gt;<a class="code" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416" title="if set, the osc_lock is a glimpse lock.">ols_glimpse</a> = 1;
<a name="l01186"></a>01186         }
<a name="l01187"></a>01187         <a class="code" href="group__osc.html#gaf9d3972737301af659fe94269be36549">osc_lock_build_einfo</a>(env, lock, <a class="code" href="group__osc.html#ga3ad629bb969c0a039ba0a4dace92585a">cl2osc</a>(obj), &amp;oscl-&gt;<a class="code" href="structosc__lock.html#a4d1369425e04be04518a52972a05bf89">ols_einfo</a>);
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         <a class="code" href="group__clio.html#ga9c2fdf8ae73a6f36bc8df4249459da93" title="Adds lock slice to the compound lock.">cl_lock_slice_add</a>(lock, &amp;oscl-&gt;<a class="code" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a>, obj, &amp;osc_lock_ops);
<a name="l01190"></a>01190 
<a name="l01191"></a>01191         <span class="keywordflow">if</span> (!(enqflags &amp; <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902acf6cb6d67732370185bebac31ca6ef29" title="tell the sub layers that it must be a `real&amp;#39; lock.">CEF_MUST</a>))
<a name="l01192"></a>01192                 <span class="comment">/* try to convert this lock to a lockless lock */</span>
<a name="l01193"></a>01193                 <a class="code" href="group__osc.html#gae950ceda261ffba5e5cfd891375e866d" title="Determine if the lock should be converted into a lockless lock.">osc_lock_to_lockless</a>(env, oscl, (enqflags &amp; <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a0a16d738d6f6b4a50693501adc8e310d" title="tell the sub layers that never request a `real&amp;#39; lock.">CEF_NEVER</a>));
<a name="l01194"></a>01194         <span class="keywordflow">if</span> (oscl-&gt;<a class="code" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed" title="inherit the lockless attribute from top level cl_io.">ols_locklessable</a> &amp;&amp; !(enqflags &amp; <a class="code" href="group__cl__lock.html#gga37f72b37baaeba18d9e0fac4560ec902a2b96e0457cbff9ba9a8aa854009cf8da" title="tell the server to instruct (though a flag in the blocking ast) an owner of the conflicting...">CEF_DISCARD_DATA</a>))
<a name="l01195"></a>01195                 oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a> |= <a class="code" href="group__LDLM.html#ga38083448d90777d7741c673dbcf70a94" title="measure lock contention and return -EUSERS if locking contention is high">LDLM_FL_DENY_ON_CONTENTION</a>;
<a name="l01196"></a>01196 
<a name="l01197"></a>01197         <span class="keywordflow">if</span> (io-&gt;<a class="code" href="structcl__io.html#ac02cd7b5e65d1d20d00de68de64d8b50" title="type of this IO.">ci_type</a> == <a class="code" href="group__cl__io.html#gga7ce44ceebcd945560fa661571e3a4378aa9c9f93ccf31c58b09085a8460ed1475" title="write system call">CIT_WRITE</a> || <a class="code" href="group__cl__io.html#gabb552842f09a0899378f5a04410f4dc7">cl_io_is_mkwrite</a>(io))
<a name="l01198"></a>01198                 <a class="code" href="group__osc.html#ga7e5994ba02ffc93e8e2ccc8d91c4b19e">osc_lock_set_writer</a>(env, io, obj, oscl);
<a name="l01199"></a>01199 
<a name="l01200"></a>01200         <a class="code" href="group__LDLM.html#gae27210c0d51e6f38e3b5f2ff08793f97" title="Just a fancy CDEBUG call with log level preset to LDLM_DEBUG.">LDLM_DEBUG_NOLOCK</a>(<span class="stringliteral">&quot;lock %p, osc lock %p, flags &quot;</span><a class="code" href="libcfs_2include_2libcfs_2types_8h.html#abd4b7b7675c19f574aa3c3cd3a7f770f">LPX64</a>,
<a name="l01201"></a>01201                           lock, oscl, oscl-&gt;<a class="code" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275" title="DLM flags with which osc_lock::ols_lock was enqueued.">ols_flags</a>);
<a name="l01202"></a>01202 
<a name="l01203"></a>01203         <span class="keywordflow">return</span> 0;
<a name="l01204"></a>01204 }
<a name="l01205"></a>01205 
<a name="l01210"></a><a class="code" href="group__osc.html#ga8977a8e1e24c419f01c5a96f6fbf65a2">01210</a> <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *<a class="code" href="group__osc.html#ga8977a8e1e24c419f01c5a96f6fbf65a2" title="Finds an existing lock covering given index and optionally different from a given...">osc_dlmlock_at_pgoff</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlu__env.html" title="Environment.">lu_env</a> *env,
<a name="l01211"></a>01211                                        <span class="keyword">struct</span> <a class="code" href="structosc__object.html">osc_object</a> *obj, pgoff_t index,
<a name="l01212"></a>01212                                        <span class="keyword">enum</span> <a class="code" href="osc__internal_8h.html#a89099d25428f6679c80d1b0bffc08660" title="Bit flags for osc_dlm_lock_at_pageoff().">osc_dap_flags</a> dap_flags)
<a name="l01213"></a>01213 {
<a name="l01214"></a>01214         <span class="keyword">struct </span><a class="code" href="structosc__thread__info.html">osc_thread_info</a> *info = <a class="code" href="group__osc.html#gab36f866d45e03d542948442f19e29c41">osc_env_info</a>(env);
<a name="l01215"></a>01215         <span class="keyword">struct </span><a class="code" href="structldlm__res__id.html">ldlm_res_id</a> *resname = &amp;info-&gt;<a class="code" href="structosc__thread__info.html#a4ddc57930642d6fa4191333d22ed2d4b">oti_resname</a>;
<a name="l01216"></a>01216         <span class="keyword">union </span><a class="code" href="unionldlm__policy__data.html">ldlm_policy_data</a> *policy  = &amp;info-&gt;<a class="code" href="structosc__thread__info.html#a2fee545583b6ef8741d83fbb3d42dae1">oti_policy</a>;
<a name="l01217"></a>01217         <span class="keyword">struct </span><a class="code" href="structlustre__handle.html">lustre_handle</a> lockh;
<a name="l01218"></a>01218         <span class="keyword">struct </span><a class="code" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> *lock = NULL;
<a name="l01219"></a>01219         <span class="keyword">enum</span> <a class="code" href="group__lustreidl.html#ga78e7c1d7ad283002413a597e75aa7441">ldlm_mode</a> <a class="code" href="mdsrate_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>;
<a name="l01220"></a>01220         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> flags;
<a name="l01221"></a>01221 
<a name="l01222"></a>01222         <a class="code" href="flock_8c.html#affebc0cf7e41098a8c78a8c2c4586d72">ENTRY</a>;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224         <a class="code" href="group__fid.html#gaaaba49803730bc60e29110c7104bff68" title="Build DLM resource name from object id &amp;amp; seq, which will be removed finally,...">ostid_build_res_name</a>(&amp;obj-&gt;<a class="code" href="structosc__object.html#aa101340a37e6780faa2a9fecc3d3a4a1">oo_oinfo</a>-&gt;<a class="code" href="structlov__oinfo.html#a8d09d3283744c17ac1dd29e7235d5c7b">loi_oi</a>, resname);
<a name="l01225"></a>01225         <a class="code" href="group__osc.html#ga5023e2c6d3427c41c4f8002c8845bcfe">osc_index2policy</a>(policy, <a class="code" href="group__osc.html#gabeee966e59f8ff3f8a8c3cba94b63559">osc2cl</a>(obj), index, index);
<a name="l01226"></a>01226         policy-&gt;<a class="code" href="unionldlm__policy__data.html#a236126dd74c519fec18188164e86c73d">l_extent</a>.<a class="code" href="structldlm__extent.html#a26ed2c10540083850c4075cd178ae1c5">gid</a> = <a class="code" href="group__LDLM.html#ga23d29567f6cc8a2df9416fe89a728b0e" title="LDLM_GID_ANY is used to match any group id in ldlm_lock_match().">LDLM_GID_ANY</a>;
<a name="l01227"></a>01227 
<a name="l01228"></a>01228         flags = <a class="code" href="group__LDLM.html#ga2c6bbb5a5fb8a17d596ecaba494aa7d2" title="Server placed lock on granted list, or a recovering client wants the lock added to...">LDLM_FL_BLOCK_GRANTED</a> | <a class="code" href="group__LDLM.html#ga3845b64e7040a6d03323e5289bd71adc" title="this lock is being destroyed">LDLM_FL_CBPENDING</a>;
<a name="l01229"></a>01229         <span class="keywordflow">if</span> (dap_flags &amp; <a class="code" href="osc__internal_8h.html#a89099d25428f6679c80d1b0bffc08660ac8fc793fe979069b05b695bef936f66e" title="Just check if the desired lock exists, it won&amp;#39;t hold reference count on lock...">OSC_DAP_FL_TEST_LOCK</a>)
<a name="l01230"></a>01230                 flags |= <a class="code" href="group__LDLM.html#ga58e627c7337b75f31e5879803c02d7f5" title="return blocking lock">LDLM_FL_TEST_LOCK</a>;
<a name="l01231"></a>01231         <span class="comment">/*</span>
<a name="l01232"></a>01232 <span class="comment">         * It is fine to match any group lock since there could be only one</span>
<a name="l01233"></a>01233 <span class="comment">         * with a uniq gid and it conflicts with all other lock modes too</span>
<a name="l01234"></a>01234 <span class="comment">         */</span>
<a name="l01235"></a>01235 again:
<a name="l01236"></a>01236         mode = <a class="code" href="osc__internal_8h.html#af6ccff10ed40679babebb500c67e4930">osc_match_base</a>(<a class="code" href="group__osc.html#ga62ec09b84963e0993a0c996837113edc">osc_export</a>(obj), resname, <a class="code" href="packet-lustre_8c.html#ab92227eb33b3bc79ee12e10421865cad">LDLM_EXTENT</a>, policy,
<a name="l01237"></a>01237                                <a class="code" href="packet-lustre_8c.html#a4b1936ce7054752c0a9d74ebc836c5d6">LCK_PR</a> | <a class="code" href="packet-lustre_8c.html#acfddf2f902384575528f1e893c561afc">LCK_PW</a> | <a class="code" href="packet-lustre_8c.html#a37496b5479e3e46be8b0be98137baeb1">LCK_GROUP</a>, &amp;flags, obj, &amp;lockh,
<a name="l01238"></a>01238                                dap_flags &amp; <a class="code" href="osc__internal_8h.html#a89099d25428f6679c80d1b0bffc08660ade85f028b77dd34a1e01d9a502f7e7a6" title="Return the lock even if it is being canceled.">OSC_DAP_FL_CANCELING</a>);
<a name="l01239"></a>01239         <span class="keywordflow">if</span> (mode != 0) {
<a name="l01240"></a>01240                 lock = <a class="code" href="group__LDLM.html#ga362da0472f4016a927cc50b1163585e4" title="Obtain a lock reference by its handle.">ldlm_handle2lock</a>(&amp;lockh);
<a name="l01241"></a>01241                 <span class="comment">/* RACE: the lock is cancelled so let&apos;s try again */</span>
<a name="l01242"></a>01242                 <span class="keywordflow">if</span> (<a class="code" href="libcfs__private_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(lock == NULL))
<a name="l01243"></a>01243                         <span class="keywordflow">goto</span> again;
<a name="l01244"></a>01244         }
<a name="l01245"></a>01245 
<a name="l01246"></a>01246         <a class="code" href="libcfs__debug_8h.html#a787d0616756df8ab4dceb42a0b73e6d6">RETURN</a>(lock);
<a name="l01247"></a>01247 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:40 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
