<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: dt_body_operations Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dt_body_operations Struct Reference<br/>
<small>
[<a class="el" href="group__dt.html">dt</a>]</small>
</h1><!-- doxytag: class="dt_body_operations" -->
<p>Per-dt-object operations on "file body" - unstructure raw data.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dt__object_8h_source.html">dt_object.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#a6d7a363128fd4899b709b2ff18afd54c">dbo_read</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, loff_t *pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data.  <a href="#a6d7a363128fd4899b709b2ff18afd54c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#aa4d64d407e2b442c1e418fa9ca46ab44">dbo_declare_write</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, loff_t pos, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to write data to object.  <a href="#aa4d64d407e2b442c1e418fa9ca46ab44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#a1d14bb3445892ab680cd8885645334bb">dbo_write</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, loff_t *pos, struct <a class="el" href="structthandle.html">thandle</a> *th, int <a class="el" href="mdsrate_8c.html#a28a2a20ee60bdfbd168e4f4bf20d8c82">ignore</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write unstructured data to regular existing object.  <a href="#a1d14bb3445892ab680cd8885645334bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#afe9f070ccbf102ca7d366a0d902216a7">dbo_bufs_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, loff_t pos, ssize_t len, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int rw)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return buffers for data.  <a href="#afe9f070ccbf102ca7d366a0d902216a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#aaa0f2da7b7271a358b9c1e3bfa4326e3">dbo_bufs_put</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int nr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release reference granted by -&gt;<a class="el" href="structdt__body__operations.html#afe9f070ccbf102ca7d366a0d902216a7" title="Return buffers for data.">dbo_bufs_get()</a>.  <a href="#aaa0f2da7b7271a358b9c1e3bfa4326e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#a064a13169a793907c32faa01a657810a">dbo_read_prep</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lnb, int nr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare buffers for reading.  <a href="#a064a13169a793907c32faa01a657810a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#ab941af8487086f964f8721de634b86b8">dbo_write_prep</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int nr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare buffers for write.  <a href="#ab941af8487086f964f8721de634b86b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#aaa2ba33b84fa7bdb6413e6f8347a1482">dbo_declare_write_commit</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int nr, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to write data stored in the buffers.  <a href="#aaa2ba33b84fa7bdb6413e6f8347a1482"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#ac44e84fe7124d965c379a6817e4dc8bc">dbo_write_commit</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int nr, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to existing object.  <a href="#ac44e84fe7124d965c379a6817e4dc8bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#afde6790a70f30800664044f1c627cb63">dbo_fiemap_get</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct fiemap *fm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return logical to physical block mapping for a given extent.  <a href="#afde6790a70f30800664044f1c627cb63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#a814e0570b29ea97a47f9851e0f6bfc0c">dbo_declare_punch</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> end, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare intention to deallocate space from an object.  <a href="#a814e0570b29ea97a47f9851e0f6bfc0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#a3ee6232f042892134c6f2fead05ed2c4">dbo_punch</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> end, struct <a class="el" href="structthandle.html">thandle</a> *th)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate specified region in an object.  <a href="#a3ee6232f042892134c6f2fead05ed2c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdt__body__operations.html#a5b1cd9fc446d73843de8c4e57475765e">dbo_ladvise</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> end, enum <a class="el" href="group__lustreuser.html#ga6800d248c7e9177fa2705d90cb97c86f">lu_ladvise_type</a> advice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give advices on specified region in an object.  <a href="#a5b1cd9fc446d73843de8c4e57475765e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Per-dt-object operations on "file body" - unstructure raw data. </p>

<p>Definition at line <a class="el" href="dt__object_8h_source.html#l01023">1023</a> of file <a class="el" href="dt__object_8h_source.html">dt_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="afe9f070ccbf102ca7d366a0d902216a7"></a><!-- doxytag: member="dt_body_operations::dbo_bufs_get" ref="afe9f070ccbf102ca7d366a0d902216a7" args=")(const struct lu_env *env, struct dt_object *dt, loff_t pos, ssize_t len, struct niobuf_local *lb, int rw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#afe9f070ccbf102ca7d366a0d902216a7">dt_body_operations::dbo_bufs_get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, loff_t pos, ssize_t len, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int rw)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return buffers for data. </p>
<p>This method is used to access data with no copying. It's so-called zero-copy I/O. The method returns the descriptors for the internal buffers where data are managed by the disk filesystem. For example, pagecache in case of ext4 or ARC with ZFS. Then other components (e.g. networking) can transfer data from or to the buffers with no additional copying.</p>
<p>The method should fill an array of struct <a class="el" href="structniobuf__local.html">niobuf_local</a>, where each element describes a full or partial page for data at specific offset. The caller should use page/lnb_page_offset/len to find data at object's offset lnb_file_offset.</p>
<p>The memory referenced by the descriptors can't change its purpose until the complementary -&gt;<a class="el" href="structdt__body__operations.html#aaa0f2da7b7271a358b9c1e3bfa4326e3" title="Release reference granted by -&gt;dbo_bufs_get().">dbo_bufs_put()</a> is called. The caller should specify if the buffers are used to read or modify data so that OSD can decide how to initialize the buffers: bring all the data for reads or just bring partial buffers for write. Note: the method does not check whether output array is large enough.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>position in the object to start </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>size of region in bytes </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>lb</em>&nbsp;</td><td>array of descriptors to fill </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rw</em>&nbsp;</td><td>0 if used to read, 1 if used for write</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>positive</em>&nbsp;</td><td>number of descriptors on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02318">dt_bufs_get()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa0f2da7b7271a358b9c1e3bfa4326e3"></a><!-- doxytag: member="dt_body_operations::dbo_bufs_put" ref="aaa0f2da7b7271a358b9c1e3bfa4326e3" args=")(const struct lu_env *env, struct dt_object *dt, struct niobuf_local *lb, int nr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#aaa0f2da7b7271a358b9c1e3bfa4326e3">dt_body_operations::dbo_bufs_put</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int nr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release reference granted by -&gt;<a class="el" href="structdt__body__operations.html#afe9f070ccbf102ca7d366a0d902216a7" title="Return buffers for data.">dbo_bufs_get()</a>. </p>
<p>Release the reference granted by the previous -&gt;<a class="el" href="structdt__body__operations.html#afe9f070ccbf102ca7d366a0d902216a7" title="Return buffers for data.">dbo_bufs_get()</a>. Note the references are counted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>lb</em>&nbsp;</td><td>array of descriptors to fill </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nr</em>&nbsp;</td><td>size of the array</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02329">dt_bufs_put()</a>.</p>

</div>
</div>
<a class="anchor" id="a814e0570b29ea97a47f9851e0f6bfc0c"></a><!-- doxytag: member="dt_body_operations::dbo_declare_punch" ref="a814e0570b29ea97a47f9851e0f6bfc0c" args=")(const struct lu_env *env, struct dt_object *dt, __u64 start, __u64 end, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#a814e0570b29ea97a47f9851e0f6bfc0c">dt_body_operations::dbo_declare_punch</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> end, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to deallocate space from an object. </p>
<p>Notify the underlying filesystem that space may be deallocated in this transactions. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. The object need not exist.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>start</em>&nbsp;</td><td>the start of the region to deallocate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>end</em>&nbsp;</td><td>the end of the region to deallocate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02398">dt_declare_punch()</a>.</p>

</div>
</div>
<a class="anchor" id="aa4d64d407e2b442c1e418fa9ca46ab44"></a><!-- doxytag: member="dt_body_operations::dbo_declare_write" ref="aa4d64d407e2b442c1e418fa9ca46ab44" args=")(const struct lu_env *env, struct dt_object *dt, const struct lu_buf *buf, loff_t pos, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* <a class="el" href="structdt__body__operations.html#aa4d64d407e2b442c1e418fa9ca46ab44">dt_body_operations::dbo_declare_write</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, loff_t pos, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to write data to object. </p>
<p>Notify the underlying filesystem that data may be written in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it. The object need not exist. If the layer implementing this method is responsible for quota, then the method should reserve space for the given credentials and return an error if quota is over. If the write later fails for some reason, then the reserve should be released properly (usually in -&gt;<a class="el" href="group__dt.html#gac5cb16311e5767ec9068c9aac417628a">dt_trans_stop()</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>buffer (including size) to copy data from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>position in the object to start </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02087">dt_declare_record_write()</a>, and <a class="el" href="dt__object_8h_source.html#l02377">dt_declare_write()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa2ba33b84fa7bdb6413e6f8347a1482"></a><!-- doxytag: member="dt_body_operations::dbo_declare_write_commit" ref="aaa2ba33b84fa7bdb6413e6f8347a1482" args=")(const struct lu_env *env, struct dt_object *dt, struct niobuf_local *lb, int nr, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#aaa2ba33b84fa7bdb6413e6f8347a1482">dt_body_operations::dbo_declare_write_commit</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int nr, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare intention to write data stored in the buffers. </p>
<p>Notify the underlying filesystem that data may be written in this transaction. This enables the layer below to prepare resources (e.g. journal credits in ext4). This method should be called between creating the transaction and starting it.</p>
<p>If the layer implementing this method is responsible for quota, then the method should be reserving a space for the given credentials and return an error if quota is exceeded. If the write later fails for some reason, then the reserve should be released properly (usually in -&gt;<a class="el" href="group__dt.html#gac5cb16311e5767ec9068c9aac417628a">dt_trans_stop()</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lb</em>&nbsp;</td><td>array of descriptors </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nr</em>&nbsp;</td><td>size of the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02347">dt_declare_write_commit()</a>.</p>

</div>
</div>
<a class="anchor" id="afde6790a70f30800664044f1c627cb63"></a><!-- doxytag: member="dt_body_operations::dbo_fiemap_get" ref="afde6790a70f30800664044f1c627cb63" args=")(const struct lu_env *env, struct dt_object *dt, struct fiemap *fm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#afde6790a70f30800664044f1c627cb63">dt_body_operations::dbo_fiemap_get</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct fiemap *fm)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return logical to physical block mapping for a given extent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fm</em>&nbsp;</td><td>describe the region to map and the output buffer see the details in include/linux/fiemap.h</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02426">dt_fiemap_get()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b1cd9fc446d73843de8c4e57475765e"></a><!-- doxytag: member="dt_body_operations::dbo_ladvise" ref="a5b1cd9fc446d73843de8c4e57475765e" args=")(const struct lu_env *env, struct dt_object *dt, __u64 start, __u64 end, enum lu_ladvise_type advice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#a5b1cd9fc446d73843de8c4e57475765e">dt_body_operations::dbo_ladvise</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> end, enum <a class="el" href="group__lustreuser.html#ga6800d248c7e9177fa2705d90cb97c86f">lu_ladvise_type</a> advice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give advices on specified region in an object. </p>
<p>This method is used to give advices about access pattern on an given region of the object. The disk filesystem understands the advices and tunes cache/read-ahead policies.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>start</em>&nbsp;</td><td>the start of the region affected </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>end</em>&nbsp;</td><td>the end of the region affected </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>advice</em>&nbsp;</td><td>advice type</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02417">dt_ladvise()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ee6232f042892134c6f2fead05ed2c4"></a><!-- doxytag: member="dt_body_operations::dbo_punch" ref="a3ee6232f042892134c6f2fead05ed2c4" args=")(const struct lu_env *env, struct dt_object *dt, __u64 start, __u64 end, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#a3ee6232f042892134c6f2fead05ed2c4">dt_body_operations::dbo_punch</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="rename__many_8c.html#ac452537b6646180ccdf7beba12c1b331">start</a>, <a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> end, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate specified region in an object. </p>
<p>This method is used to deallocate (release) space possibly consumed by the given region of the object. If the layer implementing this method is responsible for quota, then the method should maintain space accounting for the given credentials.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>start</em>&nbsp;</td><td>the start of the region to deallocate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>end</em>&nbsp;</td><td>the end of the region to deallocate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02408">dt_punch()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d7a363128fd4899b709b2ff18afd54c"></a><!-- doxytag: member="dt_body_operations::dbo_read" ref="a6d7a363128fd4899b709b2ff18afd54c" args=")(const struct lu_env *env, struct dt_object *dt, struct lu_buf *buf, loff_t *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* <a class="el" href="structdt__body__operations.html#a6d7a363128fd4899b709b2ff18afd54c">dt_body_operations::dbo_read</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, loff_t *pos)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data. </p>
<p>Read unstructured data from an existing regular object. Only data before attr.la_size is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>buffer (including size) to copy data in </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>position in the object to start </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>original value of <em>pos</em> + bytes returned</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>positive</em>&nbsp;</td><td>bytes read on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8c_source.html#l00469">dt_read()</a>, <a class="el" href="dt__object_8c_source.html#l00490">dt_record_read()</a>, <a class="el" href="lod__object_8c_source.html#l04017">lod_read()</a>, and <a class="el" href="mdd__object_8c_source.html#l00271">mdd_readlink()</a>.</p>

</div>
</div>
<a class="anchor" id="a064a13169a793907c32faa01a657810a"></a><!-- doxytag: member="dt_body_operations::dbo_read_prep" ref="a064a13169a793907c32faa01a657810a" args=")(const struct lu_env *env, struct dt_object *dt, struct niobuf_local *lnb, int nr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#a064a13169a793907c32faa01a657810a">dt_body_operations::dbo_read_prep</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lnb, int nr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare buffers for reading. </p>
<p>The method is called on the given buffers to fill them with data if that wasn't done in -&gt;<a class="el" href="structdt__body__operations.html#afe9f070ccbf102ca7d366a0d902216a7" title="Return buffers for data.">dbo_bufs_get()</a>. The idea is that the caller should be able to get few buffers for discontiguous regions using few calls to -&gt;<a class="el" href="structdt__body__operations.html#afe9f070ccbf102ca7d366a0d902216a7" title="Return buffers for data.">dbo_bufs_get()</a> and then request them all for the preparation with a single call, so that OSD can fire many I/Os to run concurrently. It's up to the specific OSD whether to implement this logic in -&gt;<a class="el" href="structdt__body__operations.html#a064a13169a793907c32faa01a657810a" title="Prepare buffers for reading.">dbo_read_prep()</a> or just use -&gt;<a class="el" href="structdt__body__operations.html#afe9f070ccbf102ca7d366a0d902216a7" title="Return buffers for data.">dbo_bufs_get()</a> to prepare data for every requested region individually.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lnb</em>&nbsp;</td><td>array of buffer descriptors </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nr</em>&nbsp;</td><td>size of the array</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02368">dt_read_prep()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d14bb3445892ab680cd8885645334bb"></a><!-- doxytag: member="dt_body_operations::dbo_write" ref="a1d14bb3445892ab680cd8885645334bb" args=")(const struct lu_env *env, struct dt_object *dt, const struct lu_buf *buf, loff_t *pos, struct thandle *th, int ignore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* <a class="el" href="structdt__body__operations.html#a1d14bb3445892ab680cd8885645334bb">dt_body_operations::dbo_write</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, const struct <a class="el" href="structlu__buf.html">lu_buf</a> *<a class="el" href="lnet_2utils_2debug_8c.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, loff_t *pos, struct <a class="el" href="structthandle.html">thandle</a> *th, int <a class="el" href="mdsrate_8c.html#a28a2a20ee60bdfbd168e4f4bf20d8c82">ignore</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write unstructured data to regular existing object. </p>
<p>The method allocates space and puts data in. Also, the method should maintain attr.la_size properly. Partial writes are possible.</p>
<p>If the layer implementing this method is responsible for quota, then the method should maintain space accounting for the given credentials.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>buffer (including size) to copy data from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>position in the object to start </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td><em>pos</em> + bytes written </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore</em>&nbsp;</td><td>unused (was used to request quota ignorance)</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>positive</em>&nbsp;</td><td>bytes written on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8c_source.html#l00504">dt_record_write()</a>, <a class="el" href="dt__object_8h_source.html#l02388">dt_write()</a>, and <a class="el" href="mdd__dir_8c_source.html#l02189">mdd_object_create()</a>.</p>

</div>
</div>
<a class="anchor" id="ac44e84fe7124d965c379a6817e4dc8bc"></a><!-- doxytag: member="dt_body_operations::dbo_write_commit" ref="ac44e84fe7124d965c379a6817e4dc8bc" args=")(const struct lu_env *env, struct dt_object *dt, struct niobuf_local *lb, int nr, struct thandle *th)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#ac44e84fe7124d965c379a6817e4dc8bc">dt_body_operations::dbo_write_commit</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int nr, struct <a class="el" href="structthandle.html">thandle</a> *th)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write to existing object. </p>
<p>This method is used to write data to a persistent storage using the buffers returned by -&gt;<a class="el" href="structdt__body__operations.html#afe9f070ccbf102ca7d366a0d902216a7" title="Return buffers for data.">dbo_bufs_get()</a>. The caller puts new data into the buffers using own mechanisms (e.g. direct transfer from a NIC). The method should maintain attr.la_size. Also, attr.la_blocks should be maintained but this can be done in lazy manner, when actual allocation happens.</p>
<p>If the layer implementing this method is responsible for quota, then the method should maintain space accounting for the given credentials.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lb</em>&nbsp;</td><td>array of descriptors for the buffers </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nr</em>&nbsp;</td><td>size of the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>th</em>&nbsp;</td><td>transaction handle</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02358">dt_write_commit()</a>.</p>

</div>
</div>
<a class="anchor" id="ab941af8487086f964f8721de634b86b8"></a><!-- doxytag: member="dt_body_operations::dbo_write_prep" ref="ab941af8487086f964f8721de634b86b8" args=")(const struct lu_env *env, struct dt_object *dt, struct niobuf_local *lb, int nr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structdt__body__operations.html#ab941af8487086f964f8721de634b86b8">dt_body_operations::dbo_write_prep</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structdt__object.html">dt_object</a> *dt, struct <a class="el" href="structniobuf__local.html">niobuf_local</a> *lb, int nr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare buffers for write. </p>
<p>This method is called on the given buffers to ensure the partial buffers contain correct data. The underlying idea is the same as in -&gt;db_read_prep().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>execution environment for this thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lb</em>&nbsp;</td><td>array of buffer descriptors </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nr</em>&nbsp;</td><td>size of the array</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>negated errno on error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="dt__object_8h_source.html#l02338">dt_write_prep()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="dt__object_8h_source.html">dt_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:53 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
