<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lnet/lnet/nidstrings.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lnet/lnet/nidstrings.c</h1><a href="lnet_2lnet_2nidstrings_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2011, 2014, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lnet/lnet/nidstrings.c</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Author: Phil Schwan &lt;phil@clusterfs.com&gt;</span>
<a name="l00039"></a>00039 <span class="comment"> */</span>
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">00041</a> <span class="preprocessor">#define DEBUG_SUBSYSTEM S_LNET</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;<a class="code" href="libcfs_8h.html">libcfs/libcfs.h</a>&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;<a class="code" href="nidstr_8h.html">lnet/nidstr.h</a>&gt;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">/* max value for numeric network address */</span>
<a name="l00047"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a2ab69fad40a1781fe8db369f55bd2b8a">00047</a> <span class="preprocessor">#define MAX_NUMERIC_VALUE 0xffffffff</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#af292f56fa61c0dbf3e923bf742f9d754">00049</a> <span class="preprocessor">#define IPSTRING_LENGTH 16</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 <span class="comment">/* CAVEAT VENDITOR! Keep the canonical string representation of nets/nids</span>
<a name="l00052"></a>00052 <span class="comment"> * consistent in all conversion functions.  Some code fragments are copied</span>
<a name="l00053"></a>00053 <span class="comment"> * around for the sake of clarity...</span>
<a name="l00054"></a>00054 <span class="comment"> */</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">/* CAVEAT EMPTOR! Racey temporary buffer allocation!</span>
<a name="l00057"></a>00057 <span class="comment"> * Choose the number of nidstrings to support the MAXIMUM expected number of</span>
<a name="l00058"></a>00058 <span class="comment"> * concurrent users.  If there are more, the returned string will be volatile.</span>
<a name="l00059"></a>00059 <span class="comment"> * NB this number must allow for a process to be descheduled for a timeslice</span>
<a name="l00060"></a>00060 <span class="comment"> * between getting its string and using it.</span>
<a name="l00061"></a>00061 <span class="comment"> */</span>
<a name="l00062"></a>00062 
<a name="l00063"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#af7959ba9942d80ec189247be9a9c1b26">00063</a> <span class="keyword">static</span> <span class="keywordtype">char</span>      <a class="code" href="lnet_2lnet_2nidstrings_8c.html#af7959ba9942d80ec189247be9a9c1b26">libcfs_nidstrings</a>[<a class="code" href="nidstr_8h.html#ac4b7b6bb4b2fc0bec53c27e5af66856d">LNET_NIDSTR_COUNT</a>][<a class="code" href="nidstr_8h.html#a3204219a0a99b43920e3f9cdd5446459">LNET_NIDSTR_SIZE</a>];
<a name="l00064"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#afff2568f8ae614ec9f48eba7ec23a154">00064</a> <span class="keyword">static</span> <span class="keywordtype">int</span>       <a class="code" href="lnet_2lnet_2nidstrings_8c.html#afff2568f8ae614ec9f48eba7ec23a154">libcfs_nidstring_idx</a>;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keyword">static</span> <a class="code" href="lfsck__lib_8c.html#ab95d324289898b63aeef7504b0269245">DEFINE_SPINLOCK</a>(libcfs_nidstring_lock);
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *<a class="code" href="lnet_2lnet_2nidstrings_8c.html#a6375a5ccc526f15bb897f4aa66cd4966">libcfs_namenum2netstrfns</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>);
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keywordtype">char</span> *
<a name="l00071"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a91bf85bd084c5a8bc80c53e7b1d2305a">00071</a> <a class="code" href="nidstr_8h.html#a91bf85bd084c5a8bc80c53e7b1d2305a">libcfs_next_nidstring</a>(<span class="keywordtype">void</span>)
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073         <span class="keywordtype">char</span>          *str;
<a name="l00074"></a>00074         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  flags;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         spin_lock_irqsave(&amp;libcfs_nidstring_lock, flags);
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         str = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#af7959ba9942d80ec189247be9a9c1b26">libcfs_nidstrings</a>[<a class="code" href="lnet_2lnet_2nidstrings_8c.html#afff2568f8ae614ec9f48eba7ec23a154">libcfs_nidstring_idx</a>++];
<a name="l00079"></a>00079         <span class="keywordflow">if</span> (<a class="code" href="lnet_2lnet_2nidstrings_8c.html#afff2568f8ae614ec9f48eba7ec23a154">libcfs_nidstring_idx</a> == <a class="code" href="group__llapi.html#ga25f003de16c08a4888b69f619d70f427">ARRAY_SIZE</a>(<a class="code" href="lnet_2lnet_2nidstrings_8c.html#af7959ba9942d80ec189247be9a9c1b26">libcfs_nidstrings</a>))
<a name="l00080"></a>00080                 <a class="code" href="lnet_2lnet_2nidstrings_8c.html#afff2568f8ae614ec9f48eba7ec23a154">libcfs_nidstring_idx</a> = 0;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082         spin_unlock_irqrestore(&amp;libcfs_nidstring_lock, flags);
<a name="l00083"></a>00083         <span class="keywordflow">return</span> str;
<a name="l00084"></a>00084 }
<a name="l00085"></a>00085 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#a91bf85bd084c5a8bc80c53e7b1d2305a">libcfs_next_nidstring</a>);
<a name="l00086"></a>00086 
<a name="l00115"></a><a class="code" href="structnidrange.html">00115</a> <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> {
<a name="l00120"></a><a class="code" href="structnidrange.html#a68af68972612ae3def4f475b13bd8909">00120</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> <a class="code" href="structnidrange.html#a68af68972612ae3def4f475b13bd8909" title="Link to list of this structures which is built on nid range list parsing.">nr_link</a>;
<a name="l00124"></a><a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30">00124</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> <a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>;
<a name="l00128"></a><a class="code" href="structnidrange.html#a7437de88dae4e7de24c8b73e49d2847a">00128</a>         <span class="keywordtype">int</span> <a class="code" href="structnidrange.html#a7437de88dae4e7de24c8b73e49d2847a" title="Flag indicating that *&amp;lt;net&amp;gt; is found.">nr_all</a>;
<a name="l00132"></a><a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b">00132</a>         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a>;
<a name="l00136"></a><a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc">00136</a>         <span class="keywordtype">int</span> <a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc" title="Number of network.">nr_netnum</a>;
<a name="l00137"></a>00137 };
<a name="l00138"></a>00138 
<a name="l00142"></a><a class="code" href="structaddrrange.html">00142</a> <span class="keyword">struct </span><a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> {
<a name="l00146"></a><a class="code" href="structaddrrange.html#a76d82f2a774f033d23eaae2b14832b67">00146</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> <a class="code" href="structaddrrange.html#a76d82f2a774f033d23eaae2b14832b67" title="Link to nidrange::nr_addrranges.">ar_link</a>;
<a name="l00150"></a><a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b">00150</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> <a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>;
<a name="l00151"></a>00151 };
<a name="l00152"></a>00152 
<a name="l00162"></a>00162 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00163"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#aabbb9a06452b00832ad7b69ee20adf17">00163</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#aabbb9a06452b00832ad7b69ee20adf17" title="Parses &amp;lt;addrrange&amp;gt; token on the syntax.">parse_addrange</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> *src, <span class="keyword">struct</span> <a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *<a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a>)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165         <span class="keyword">struct </span><a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *<a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a>;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167         <span class="keywordflow">if</span> (src-&gt;<a class="code" href="structcfs__lstr.html#adf880bbf7e5b96717c0ffd49e4f72076">ls_len</a> == 1 &amp;&amp; src-&gt;<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a>[0] == <span class="charliteral">&apos;*&apos;</span>) {
<a name="l00168"></a>00168                 nidrange-&gt;<a class="code" href="structnidrange.html#a7437de88dae4e7de24c8b73e49d2847a" title="Flag indicating that *&amp;lt;net&amp;gt; is found.">nr_all</a> = 1;
<a name="l00169"></a>00169                 <span class="keywordflow">return</span> 0;
<a name="l00170"></a>00170         }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172         <a class="code" href="libcfs__private_8h.html#a87a8b94124ee7f73a969859a2fd83294">LIBCFS_ALLOC</a>(addrrange, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrrange));
<a name="l00173"></a>00173         <span class="keywordflow">if</span> (addrrange == NULL)
<a name="l00174"></a>00174                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00175"></a>00175         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;addrrange-&gt;<a class="code" href="structaddrrange.html#a76d82f2a774f033d23eaae2b14832b67" title="Link to nidrange::nr_addrranges.">ar_link</a>, &amp;nidrange-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>);
<a name="l00176"></a>00176         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;addrrange-&gt;<a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>);
<a name="l00177"></a>00177 
<a name="l00178"></a>00178         <span class="keywordflow">return</span> nidrange-&gt;<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a>-&gt;<a class="code" href="structnetstrfns.html#a2a6f4c0f036817aa992eeaec33affddb">nf_parse_addrlist</a>(src-&gt;<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a>,
<a name="l00179"></a>00179                                                 src-&gt;<a class="code" href="structcfs__lstr.html#adf880bbf7e5b96717c0ffd49e4f72076">ls_len</a>,
<a name="l00180"></a>00180                                                 &amp;addrrange-&gt;<a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>);
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00193"></a>00193 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *
<a name="l00194"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a85a4d74b3a5da7ef5ad5a84fd2f54ac6">00194</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a85a4d74b3a5da7ef5ad5a84fd2f54ac6" title="Finds or creates struct nidrange.">add_nidrange</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> *src,
<a name="l00195"></a>00195              <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist)
<a name="l00196"></a>00196 {
<a name="l00197"></a>00197         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf;
<a name="l00198"></a>00198         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00199"></a>00199         <span class="keywordtype">int</span> endlen;
<a name="l00200"></a>00200         <span class="keywordtype">unsigned</span> netnum;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="keywordflow">if</span> (src-&gt;<a class="code" href="structcfs__lstr.html#adf880bbf7e5b96717c0ffd49e4f72076">ls_len</a> &gt;= <a class="code" href="nidstr_8h.html#a3204219a0a99b43920e3f9cdd5446459">LNET_NIDSTR_SIZE</a>)
<a name="l00203"></a>00203                 <span class="keywordflow">return</span> NULL;
<a name="l00204"></a>00204 
<a name="l00205"></a>00205         nf = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a6375a5ccc526f15bb897f4aa66cd4966">libcfs_namenum2netstrfns</a>(src-&gt;<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a>);
<a name="l00206"></a>00206         <span class="keywordflow">if</span> (nf == NULL)
<a name="l00207"></a>00207                 <span class="keywordflow">return</span> NULL;
<a name="l00208"></a>00208         endlen = src-&gt;<a class="code" href="structcfs__lstr.html#adf880bbf7e5b96717c0ffd49e4f72076">ls_len</a> - strlen(nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>);
<a name="l00209"></a>00209         <span class="keywordflow">if</span> (endlen == 0)
<a name="l00210"></a>00210                 <span class="comment">/* network name only, e.g. &quot;elan&quot; or &quot;tcp&quot; */</span>
<a name="l00211"></a>00211                 netnum = 0;
<a name="l00212"></a>00212         <span class="keywordflow">else</span> {
<a name="l00213"></a>00213                 <span class="comment">/* e.g. &quot;elan25&quot; or &quot;tcp23&quot;, refuse to parse if</span>
<a name="l00214"></a>00214 <span class="comment">                 * network name is not appended with decimal or</span>
<a name="l00215"></a>00215 <span class="comment">                 * hexadecimal number */</span>
<a name="l00216"></a>00216                 <span class="keywordflow">if</span> (!<a class="code" href="libcfs__string_8h.html#ae3f2fcd1121f0e73e47879877383ff0e" title="Converts string to integer.">cfs_str2num_check</a>(src-&gt;<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a> + strlen(nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>),
<a name="l00217"></a>00217                                        endlen, &amp;netnum, 0, <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a2ab69fad40a1781fe8db369f55bd2b8a">MAX_NUMERIC_VALUE</a>))
<a name="l00218"></a>00218                         <span class="keywordflow">return</span> NULL;
<a name="l00219"></a>00219         }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(nr, nidlist, <a class="code" href="structnidrange.html#a68af68972612ae3def4f475b13bd8909" title="Link to list of this structures which is built on nid range list parsing.">nr_link</a>) {
<a name="l00222"></a>00222                 <span class="keywordflow">if</span> (nr-&gt;<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a> != nf)
<a name="l00223"></a>00223                         <span class="keywordflow">continue</span>;
<a name="l00224"></a>00224                 <span class="keywordflow">if</span> (nr-&gt;<a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc" title="Number of network.">nr_netnum</a> != netnum)
<a name="l00225"></a>00225                         <span class="keywordflow">continue</span>;
<a name="l00226"></a>00226                 <span class="keywordflow">return</span> nr;
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         <a class="code" href="libcfs__private_8h.html#a87a8b94124ee7f73a969859a2fd83294">LIBCFS_ALLOC</a>(nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a>));
<a name="l00230"></a>00230         <span class="keywordflow">if</span> (nr == NULL)
<a name="l00231"></a>00231                 <span class="keywordflow">return</span> NULL;
<a name="l00232"></a>00232         <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;nr-&gt;<a class="code" href="structnidrange.html#a68af68972612ae3def4f475b13bd8909" title="Link to list of this structures which is built on nid range list parsing.">nr_link</a>, nidlist);
<a name="l00233"></a>00233         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(&amp;nr-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>);
<a name="l00234"></a>00234         nr-&gt;<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a> = nf;
<a name="l00235"></a>00235         nr-&gt;<a class="code" href="structnidrange.html#a7437de88dae4e7de24c8b73e49d2847a" title="Flag indicating that *&amp;lt;net&amp;gt; is found.">nr_all</a> = 0;
<a name="l00236"></a>00236         nr-&gt;<a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc" title="Number of network.">nr_netnum</a> = netnum;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         <span class="keywordflow">return</span> nr;
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00247"></a>00247 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00248"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a72ec58d22097d11d150831c9377b4a68">00248</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a72ec58d22097d11d150831c9377b4a68" title="Parses &amp;lt;nidrange&amp;gt; token of the syntax.">parse_nidrange</a>(<span class="keyword">struct</span> <a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> *src, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist)
<a name="l00249"></a>00249 {
<a name="l00250"></a>00250         <span class="keyword">struct </span><a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> addrrange;
<a name="l00251"></a>00251         <span class="keyword">struct </span><a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> net;
<a name="l00252"></a>00252         <span class="keyword">struct </span><a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> tmp;
<a name="l00253"></a>00253         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255         tmp = *src;
<a name="l00256"></a>00256         <span class="keywordflow">if</span> (<a class="code" href="libcfs__string_8h.html#a96360a23c2c49982017d60056e9953e6" title="Extracts tokens from strings.">cfs_gettok</a>(src, <span class="charliteral">&apos;@&apos;</span>, &amp;addrrange) == 0)
<a name="l00257"></a>00257                 <span class="keywordflow">goto</span> failed;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         <span class="keywordflow">if</span> (<a class="code" href="libcfs__string_8h.html#a96360a23c2c49982017d60056e9953e6" title="Extracts tokens from strings.">cfs_gettok</a>(src, <span class="charliteral">&apos;@&apos;</span>, &amp;net) == 0 || src-&gt;<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a> != NULL)
<a name="l00260"></a>00260                 <span class="keywordflow">goto</span> failed;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         nr = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a85a4d74b3a5da7ef5ad5a84fd2f54ac6" title="Finds or creates struct nidrange.">add_nidrange</a>(&amp;net, nidlist);
<a name="l00263"></a>00263         <span class="keywordflow">if</span> (nr == NULL)
<a name="l00264"></a>00264                 <span class="keywordflow">goto</span> failed;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266         <span class="keywordflow">if</span> (<a class="code" href="lnet_2lnet_2nidstrings_8c.html#aabbb9a06452b00832ad7b69ee20adf17" title="Parses &amp;lt;addrrange&amp;gt; token on the syntax.">parse_addrange</a>(&amp;addrrange, nr) != 0)
<a name="l00267"></a>00267                 <span class="keywordflow">goto</span> failed;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         <span class="keywordflow">return</span> 1;
<a name="l00270"></a>00270 failed:
<a name="l00271"></a>00271         <span class="keywordflow">return</span> 0;
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00282"></a>00282 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00283"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#ac1253688846d599f8916d46880733480">00283</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#ac1253688846d599f8916d46880733480" title="Frees addrrange structures of list.">free_addrranges</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *<a class="code" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)
<a name="l00284"></a>00284 {
<a name="l00285"></a>00285         <span class="keywordflow">while</span> (!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(list)) {
<a name="l00286"></a>00286                 <span class="keyword">struct </span><a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *ar;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288                 ar = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(list-&gt;<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>, <span class="keyword">struct</span> <a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a>, <a class="code" href="structaddrrange.html#a76d82f2a774f033d23eaae2b14832b67" title="Link to nidrange::nr_addrranges.">ar_link</a>);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290                 <a class="code" href="libcfs__string_8h.html#a860f9e47eda266fefdc515be69e74ef0" title="Frees cfs_expr_list structures of list.">cfs_expr_list_free_list</a>(&amp;ar-&gt;<a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>);
<a name="l00291"></a>00291                 <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(&amp;ar-&gt;<a class="code" href="structaddrrange.html#a76d82f2a774f033d23eaae2b14832b67" title="Link to nidrange::nr_addrranges.">ar_link</a>);
<a name="l00292"></a>00292                 <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(ar, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a>));
<a name="l00293"></a>00293         }
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00304"></a>00304 <span class="keywordtype">void</span>
<a name="l00305"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a5d88a3953873b66b955d0e7b24857648">00305</a> <a class="code" href="nidstr_8h.html#a5d88a3953873b66b955d0e7b24857648" title="Frees nidrange strutures of list.">cfs_free_nidlist</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *<a class="code" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)
<a name="l00306"></a>00306 {
<a name="l00307"></a>00307         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a> *pos, *<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>;
<a name="l00308"></a>00308         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310         <a class="code" href="list_8h.html#a9e4b9328744994b9d3878f5dad75c09f" title="Iterate over a list safely.">list_for_each_safe</a>(pos, next, list) {
<a name="l00311"></a>00311                 nr = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(pos, <span class="keyword">struct</span> <a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a>, <a class="code" href="structnidrange.html#a68af68972612ae3def4f475b13bd8909" title="Link to list of this structures which is built on nid range list parsing.">nr_link</a>);
<a name="l00312"></a>00312                 <a class="code" href="lnet_2lnet_2nidstrings_8c.html#ac1253688846d599f8916d46880733480" title="Frees addrrange structures of list.">free_addrranges</a>(&amp;nr-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>);
<a name="l00313"></a>00313                 <a class="code" href="list_8h.html#ab1708206f0f7e0a56550b35372203ba5" title="Remove an entry from the list it is currently in.">list_del</a>(pos);
<a name="l00314"></a>00314                 <a class="code" href="libcfs__private_8h.html#a41386bf0bd3a9596cd7161910902f4e7">LIBCFS_FREE</a>(nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a>));
<a name="l00315"></a>00315         }
<a name="l00316"></a>00316 }
<a name="l00317"></a>00317 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#a5d88a3953873b66b955d0e7b24857648" title="Frees nidrange strutures of list.">cfs_free_nidlist</a>);
<a name="l00318"></a>00318 
<a name="l00332"></a>00332 <span class="keywordtype">int</span>
<a name="l00333"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a9bf9ac0aa634e0b5cf454207896798b6">00333</a> <a class="code" href="nidstr_8h.html#aa5f0b5f8c71c052bd424add759aef1ad" title="Parses nid range list.">cfs_parse_nidlist</a>(<span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> len, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist)
<a name="l00334"></a>00334 {
<a name="l00335"></a>00335         <span class="keyword">struct </span><a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> src;
<a name="l00336"></a>00336         <span class="keyword">struct </span><a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> res;
<a name="l00337"></a>00337         <span class="keywordtype">int</span> rc;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339         src.<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a> = str;
<a name="l00340"></a>00340         src.<a class="code" href="structcfs__lstr.html#adf880bbf7e5b96717c0ffd49e4f72076">ls_len</a> = len;
<a name="l00341"></a>00341         <a class="code" href="list_8h.html#a0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(nidlist);
<a name="l00342"></a>00342         <span class="keywordflow">while</span> (src.<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a>) {
<a name="l00343"></a>00343                 rc = <a class="code" href="libcfs__string_8h.html#a96360a23c2c49982017d60056e9953e6" title="Extracts tokens from strings.">cfs_gettok</a>(&amp;src, <span class="charliteral">&apos; &apos;</span>, &amp;res);
<a name="l00344"></a>00344                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l00345"></a>00345                         <a class="code" href="nidstr_8h.html#a5d88a3953873b66b955d0e7b24857648" title="Frees nidrange strutures of list.">cfs_free_nidlist</a>(nidlist);
<a name="l00346"></a>00346                         <span class="keywordflow">return</span> 0;
<a name="l00347"></a>00347                 }
<a name="l00348"></a>00348                 rc = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a72ec58d22097d11d150831c9377b4a68" title="Parses &amp;lt;nidrange&amp;gt; token of the syntax.">parse_nidrange</a>(&amp;res, nidlist);
<a name="l00349"></a>00349                 <span class="keywordflow">if</span> (rc == 0) {
<a name="l00350"></a>00350                         <a class="code" href="nidstr_8h.html#a5d88a3953873b66b955d0e7b24857648" title="Frees nidrange strutures of list.">cfs_free_nidlist</a>(nidlist);
<a name="l00351"></a>00351                         <span class="keywordflow">return</span> 0;
<a name="l00352"></a>00352                 }
<a name="l00353"></a>00353         }
<a name="l00354"></a>00354         <span class="keywordflow">return</span> 1;
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#aa5f0b5f8c71c052bd424add759aef1ad" title="Parses nid range list.">cfs_parse_nidlist</a>);
<a name="l00357"></a>00357 
<a name="l00366"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a508ea4e6bc24951069a9e2c64a552ed3">00366</a> <span class="keywordtype">int</span> <a class="code" href="nidstr_8h.html#a1004468e3400da4843eee957ee3deae1" title="Matches a nid (nid) against the compiled list of nidranges (nidlist).">cfs_match_nid</a>(<a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist)
<a name="l00367"></a>00367 {
<a name="l00368"></a>00368         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00369"></a>00369         <span class="keyword">struct </span><a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *ar;
<a name="l00370"></a>00370 
<a name="l00371"></a>00371         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(nr, nidlist, nr_link) {
<a name="l00372"></a>00372                 <span class="keywordflow">if</span> (nr-&gt;<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a>-&gt;<a class="code" href="structnetstrfns.html#aa6b63c720ed7ed94973f37fe9a287f40">nf_type</a> != <a class="code" href="group__lnet__addr.html#gad907b8fc6e2f50ca5ddcde69d8fbaa37">LNET_NETTYP</a>(<a class="code" href="group__lnet__addr.html#gabf536c21b8f5226eadf3a124a265ee3b">LNET_NIDNET</a>(nid)))
<a name="l00373"></a>00373                         <span class="keywordflow">continue</span>;
<a name="l00374"></a>00374                 <span class="keywordflow">if</span> (nr-&gt;<a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc" title="Number of network.">nr_netnum</a> != <a class="code" href="group__lnet__addr.html#gaa5b1f70b0f73fff4e4d2ceb7b95965b1">LNET_NETNUM</a>(<a class="code" href="group__lnet__addr.html#gabf536c21b8f5226eadf3a124a265ee3b">LNET_NIDNET</a>(nid)))
<a name="l00375"></a>00375                         <span class="keywordflow">continue</span>;
<a name="l00376"></a>00376                 <span class="keywordflow">if</span> (nr-&gt;<a class="code" href="structnidrange.html#a7437de88dae4e7de24c8b73e49d2847a" title="Flag indicating that *&amp;lt;net&amp;gt; is found.">nr_all</a>)
<a name="l00377"></a>00377                         <span class="keywordflow">return</span> 1;
<a name="l00378"></a>00378                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(ar, &amp;nr-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>, <a class="code" href="structaddrrange.html#a76d82f2a774f033d23eaae2b14832b67" title="Link to nidrange::nr_addrranges.">ar_link</a>)
<a name="l00379"></a>00379                         <span class="keywordflow">if</span> (nr-&gt;<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a>-&gt;<a class="code" href="structnetstrfns.html#ae4b381dc7da09782e43ad48a7e38bcdd">nf_match_addr</a>(<a class="code" href="group__lnet__addr.html#ga692b6a866269a35490f2e2803cc2e5d6" title="extract the address part of an lnet_nid_t">LNET_NIDADDR</a>(nid),
<a name="l00380"></a>00380                                                         &amp;ar-&gt;<a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>))
<a name="l00381"></a>00381                                 <span class="keywordflow">return</span> 1;
<a name="l00382"></a>00382         }
<a name="l00383"></a>00383         <span class="keywordflow">return</span> 0;
<a name="l00384"></a>00384 }
<a name="l00385"></a>00385 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#a1004468e3400da4843eee957ee3deae1" title="Matches a nid (nid) against the compiled list of nidranges (nidlist).">cfs_match_nid</a>);
<a name="l00386"></a>00386 
<a name="l00392"></a>00392 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00393"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a25879dbbfb65c884ac4fd4ecb4a1d6cb">00393</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a25879dbbfb65c884ac4fd4ecb4a1d6cb" title="Print the network part of the nidrange nr into the specified buffer.">cfs_print_network</a>(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> count, <span class="keyword">struct</span> <a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr)
<a name="l00394"></a>00394 {
<a name="l00395"></a>00395         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf = nr-&gt;<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a>;
<a name="l00396"></a>00396 
<a name="l00397"></a>00397         <span class="keywordflow">if</span> (nr-&gt;<a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc" title="Number of network.">nr_netnum</a> == 0)
<a name="l00398"></a>00398                 <span class="keywordflow">return</span> scnprintf(buffer, count, <span class="stringliteral">&quot;@%s&quot;</span>, nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>);
<a name="l00399"></a>00399         <span class="keywordflow">else</span>
<a name="l00400"></a>00400                 <span class="keywordflow">return</span> scnprintf(buffer, count, <span class="stringliteral">&quot;@%s%u&quot;</span>,
<a name="l00401"></a>00401                                     nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>, nr-&gt;<a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc" title="Number of network.">nr_netnum</a>);
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00410"></a>00410 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00411"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a35bd578189318174ce7281f27eaad121">00411</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a35bd578189318174ce7281f27eaad121" title="Print a list of addrrange (addrranges) into the specified buffer.">cfs_print_addrranges</a>(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> count, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *addrranges,
<a name="l00412"></a>00412                      <span class="keyword">struct</span> <a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr)
<a name="l00413"></a>00413 {
<a name="l00414"></a>00414         <span class="keywordtype">int</span> i = 0;
<a name="l00415"></a>00415         <span class="keyword">struct </span><a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *ar;
<a name="l00416"></a>00416         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf = nr-&gt;<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a>;
<a name="l00417"></a>00417 
<a name="l00418"></a>00418         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(ar, addrranges, ar_link) {
<a name="l00419"></a>00419                 <span class="keywordflow">if</span> (i != 0)
<a name="l00420"></a>00420                         i += scnprintf(buffer + i, count - i, <span class="stringliteral">&quot; &quot;</span>);
<a name="l00421"></a>00421                 i += nf-&gt;<a class="code" href="structnetstrfns.html#a8b03833cac484416ceb9222c83ea34a6">nf_print_addrlist</a>(buffer + i, count - i,
<a name="l00422"></a>00422                                            &amp;ar-&gt;<a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>);
<a name="l00423"></a>00423                 i += <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a25879dbbfb65c884ac4fd4ecb4a1d6cb" title="Print the network part of the nidrange nr into the specified buffer.">cfs_print_network</a>(buffer + i, count - i, nr);
<a name="l00424"></a>00424         }
<a name="l00425"></a>00425         <span class="keywordflow">return</span> i;
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00435"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a621d22996f316e174804c2161fce451e">00435</a> <span class="keywordtype">int</span> <a class="code" href="nidstr_8h.html#aa06b51377a365d1ab37dcac12f4020aa" title="Print a list of nidranges (nidlist) into the specified buffer.">cfs_print_nidlist</a>(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> count, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist)
<a name="l00436"></a>00436 {
<a name="l00437"></a>00437         <span class="keywordtype">int</span> i = 0;
<a name="l00438"></a>00438         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440         <span class="keywordflow">if</span> (count &lt;= 0)
<a name="l00441"></a>00441                 <span class="keywordflow">return</span> 0;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(nr, nidlist, <a class="code" href="structnidrange.html#a68af68972612ae3def4f475b13bd8909" title="Link to list of this structures which is built on nid range list parsing.">nr_link</a>) {
<a name="l00444"></a>00444                 <span class="keywordflow">if</span> (i != 0)
<a name="l00445"></a>00445                         i += scnprintf(buffer + i, count - i, <span class="stringliteral">&quot; &quot;</span>);
<a name="l00446"></a>00446 
<a name="l00447"></a>00447                 <span class="keywordflow">if</span> (nr-&gt;<a class="code" href="structnidrange.html#a7437de88dae4e7de24c8b73e49d2847a" title="Flag indicating that *&amp;lt;net&amp;gt; is found.">nr_all</a> != 0) {
<a name="l00448"></a>00448                         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(&amp;nr-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>));
<a name="l00449"></a>00449                         i += scnprintf(buffer + i, count - i, <span class="stringliteral">&quot;*&quot;</span>);
<a name="l00450"></a>00450                         i += <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a25879dbbfb65c884ac4fd4ecb4a1d6cb" title="Print the network part of the nidrange nr into the specified buffer.">cfs_print_network</a>(buffer + i, count - i, nr);
<a name="l00451"></a>00451                 } <span class="keywordflow">else</span> {
<a name="l00452"></a>00452                         i += <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a35bd578189318174ce7281f27eaad121" title="Print a list of addrrange (addrranges) into the specified buffer.">cfs_print_addrranges</a>(buffer + i, count - i,
<a name="l00453"></a>00453                                                   &amp;nr-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>, nr);
<a name="l00454"></a>00454                 }
<a name="l00455"></a>00455         }
<a name="l00456"></a>00456         <span class="keywordflow">return</span> i;
<a name="l00457"></a>00457 }
<a name="l00458"></a>00458 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#aa06b51377a365d1ab37dcac12f4020aa" title="Print a list of nidranges (nidlist) into the specified buffer.">cfs_print_nidlist</a>);
<a name="l00459"></a>00459 
<a name="l00468"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a136cf0d0ede87182505473ab313f8b45">00468</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a136cf0d0ede87182505473ab313f8b45" title="Determines minimum and maximum addresses for a single numeric address range.">cfs_ip_ar_min_max</a>(<span class="keyword">struct</span> <a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *ar, __u32 *min_nid,
<a name="l00469"></a>00469                               __u32 *max_nid)
<a name="l00470"></a>00470 {
<a name="l00471"></a>00471         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00472"></a>00472         <span class="keyword">struct </span><a class="code" href="structcfs__range__expr.html">cfs_range_expr</a> *re;
<a name="l00473"></a>00473         __u32 tmp_ip_addr = 0;
<a name="l00474"></a>00474         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_ip[4] = {0};
<a name="l00475"></a>00475         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_ip[4] = {0};
<a name="l00476"></a>00476         <span class="keywordtype">int</span> re_count = 0;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(el, &amp;ar-&gt;<a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>, el_link) {
<a name="l00479"></a>00479                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(re, &amp;el-&gt;<a class="code" href="structcfs__expr__list.html#a8cb88aa577495eacd0f9325df7ae0f75">el_exprs</a>, <a class="code" href="structcfs__range__expr.html#a9f59d966c4f6d1779c31c1732dcf21a9">re_link</a>) {
<a name="l00480"></a>00480                         min_ip[re_count] = re-&gt;<a class="code" href="structcfs__range__expr.html#aba957d5d4bb305e755cee0d4cb67b044">re_lo</a>;
<a name="l00481"></a>00481                         max_ip[re_count] = re-&gt;<a class="code" href="structcfs__range__expr.html#ad66352ab42e30bd2bad63315e21cb680">re_hi</a>;
<a name="l00482"></a>00482                         re_count++;
<a name="l00483"></a>00483                 }
<a name="l00484"></a>00484         }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486         tmp_ip_addr = ((min_ip[0] &lt;&lt; 24) | (min_ip[1] &lt;&lt; 16) |
<a name="l00487"></a>00487                        (min_ip[2] &lt;&lt; 8) | min_ip[3]);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489         <span class="keywordflow">if</span> (min_nid != NULL)
<a name="l00490"></a>00490                 *min_nid = tmp_ip_addr;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         tmp_ip_addr = ((max_ip[0] &lt;&lt; 24) | (max_ip[1] &lt;&lt; 16) |
<a name="l00493"></a>00493                        (max_ip[2] &lt;&lt; 8) | max_ip[3]);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         <span class="keywordflow">if</span> (max_nid != NULL)
<a name="l00496"></a>00496                 *max_nid = tmp_ip_addr;
<a name="l00497"></a>00497 }
<a name="l00498"></a>00498 
<a name="l00507"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a754c9e74a6b37c1de774a2a350859ba4">00507</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a754c9e74a6b37c1de774a2a350859ba4" title="Determines minimum and maximum addresses for a single numeric address range.">cfs_num_ar_min_max</a>(<span class="keyword">struct</span> <a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *ar, __u32 *min_nid,
<a name="l00508"></a>00508                                __u32 *max_nid)
<a name="l00509"></a>00509 {
<a name="l00510"></a>00510         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00511"></a>00511         <span class="keyword">struct </span><a class="code" href="structcfs__range__expr.html">cfs_range_expr</a> *re;
<a name="l00512"></a>00512         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_addr = 0;
<a name="l00513"></a>00513         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_addr = 0;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(el, &amp;ar-&gt;<a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>, el_link) {
<a name="l00516"></a>00516                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(re, &amp;el-&gt;<a class="code" href="structcfs__expr__list.html#a8cb88aa577495eacd0f9325df7ae0f75">el_exprs</a>, <a class="code" href="structcfs__range__expr.html#a9f59d966c4f6d1779c31c1732dcf21a9">re_link</a>) {
<a name="l00517"></a>00517                         <span class="keywordflow">if</span> (re-&gt;<a class="code" href="structcfs__range__expr.html#aba957d5d4bb305e755cee0d4cb67b044">re_lo</a> &lt; min_addr || min_addr == 0)
<a name="l00518"></a>00518                                 min_addr = re-&gt;<a class="code" href="structcfs__range__expr.html#aba957d5d4bb305e755cee0d4cb67b044">re_lo</a>;
<a name="l00519"></a>00519                         <span class="keywordflow">if</span> (re-&gt;<a class="code" href="structcfs__range__expr.html#ad66352ab42e30bd2bad63315e21cb680">re_hi</a> &gt; max_addr)
<a name="l00520"></a>00520                                 max_addr = re-&gt;<a class="code" href="structcfs__range__expr.html#ad66352ab42e30bd2bad63315e21cb680">re_hi</a>;
<a name="l00521"></a>00521                 }
<a name="l00522"></a>00522         }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524         <span class="keywordflow">if</span> (min_nid != NULL)
<a name="l00525"></a>00525                 *min_nid = min_addr;
<a name="l00526"></a>00526         <span class="keywordflow">if</span> (max_nid != NULL)
<a name="l00527"></a>00527                 *max_nid = max_addr;
<a name="l00528"></a>00528 }
<a name="l00529"></a>00529 
<a name="l00539"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a8b2ab1bbe3a53a309c4d8f25afee74c1">00539</a> <span class="keywordtype">bool</span> <a class="code" href="nidstr_8h.html#a8b2ab1bbe3a53a309c4d8f25afee74c1" title="Determines whether an expression list in an nidrange contains exactly one contiguous...">cfs_nidrange_is_contiguous</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist)
<a name="l00540"></a>00540 {
<a name="l00541"></a>00541         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00542"></a>00542         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf = NULL;
<a name="l00543"></a>00543         <span class="keywordtype">char</span> *lndname = NULL;
<a name="l00544"></a>00544         <span class="keywordtype">int</span> netnum = -1;
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(nr, nidlist, nr_link) {
<a name="l00547"></a>00547                 nf = nr-&gt;<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a>;
<a name="l00548"></a>00548                 <span class="keywordflow">if</span> (lndname == NULL)
<a name="l00549"></a>00549                         lndname = nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>;
<a name="l00550"></a>00550                 <span class="keywordflow">if</span> (netnum == -1)
<a name="l00551"></a>00551                         netnum = nr-&gt;<a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc" title="Number of network.">nr_netnum</a>;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553                 <span class="keywordflow">if</span> (strcmp(lndname, nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>) != 0 ||
<a name="l00554"></a>00554                     netnum != nr-&gt;<a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc" title="Number of network.">nr_netnum</a>)
<a name="l00555"></a>00555                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00556"></a>00556         }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         <span class="keywordflow">if</span> (nf == NULL)
<a name="l00559"></a>00559                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         <span class="keywordflow">if</span> (!nf-&gt;<a class="code" href="structnetstrfns.html#acc8cdcdaa445353388bf0dce52c7cfce">nf_is_contiguous</a>(nidlist))
<a name="l00562"></a>00562                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00565"></a>00565 }
<a name="l00566"></a>00566 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#a8b2ab1bbe3a53a309c4d8f25afee74c1" title="Determines whether an expression list in an nidrange contains exactly one contiguous...">cfs_nidrange_is_contiguous</a>);
<a name="l00567"></a>00567 
<a name="l00577"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#acbd0bd03c72ef48867b31b940cf4a656">00577</a> <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#acbd0bd03c72ef48867b31b940cf4a656" title="Determines whether an expression list in an num nidrange contains exactly one contiguous...">cfs_num_is_contiguous</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist)
<a name="l00578"></a>00578 {
<a name="l00579"></a>00579         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00580"></a>00580         <span class="keyword">struct </span><a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *ar;
<a name="l00581"></a>00581         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00582"></a>00582         <span class="keyword">struct </span><a class="code" href="structcfs__range__expr.html">cfs_range_expr</a> *re;
<a name="l00583"></a>00583         <span class="keywordtype">int</span> last_hi = 0;
<a name="l00584"></a>00584         __u32 last_end_nid = 0;
<a name="l00585"></a>00585         __u32 current_start_nid = 0;
<a name="l00586"></a>00586         __u32 current_end_nid = 0;
<a name="l00587"></a>00587 
<a name="l00588"></a>00588         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(nr, nidlist, nr_link) {
<a name="l00589"></a>00589                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(ar, &amp;nr-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>, ar_link) {
<a name="l00590"></a>00590                         <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a754c9e74a6b37c1de774a2a350859ba4" title="Determines minimum and maximum addresses for a single numeric address range.">cfs_num_ar_min_max</a>(ar, &amp;current_start_nid,
<a name="l00591"></a>00591                                            &amp;current_end_nid);
<a name="l00592"></a>00592                         <span class="keywordflow">if</span> (last_end_nid != 0 &amp;&amp;
<a name="l00593"></a>00593                             (current_start_nid - last_end_nid != 1))
<a name="l00594"></a>00594                                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00595"></a>00595                         last_end_nid = current_end_nid;
<a name="l00596"></a>00596                         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(el, &amp;ar-&gt;<a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>,
<a name="l00597"></a>00597                                             el_link) {
<a name="l00598"></a>00598                                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(re, &amp;el-&gt;<a class="code" href="structcfs__expr__list.html#a8cb88aa577495eacd0f9325df7ae0f75">el_exprs</a>,
<a name="l00599"></a>00599                                                     <a class="code" href="structcfs__range__expr.html#a9f59d966c4f6d1779c31c1732dcf21a9">re_link</a>) {
<a name="l00600"></a>00600                                         <span class="keywordflow">if</span> (re-&gt;<a class="code" href="structcfs__range__expr.html#a915e9674c9bf97f2bc997482efad5d10">re_stride</a> &gt; 1)
<a name="l00601"></a>00601                                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00602"></a>00602                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (last_hi != 0 &amp;&amp;
<a name="l00603"></a>00603                                                  re-&gt;<a class="code" href="structcfs__range__expr.html#ad66352ab42e30bd2bad63315e21cb680">re_hi</a> - last_hi != 1)
<a name="l00604"></a>00604                                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00605"></a>00605                                         last_hi = re-&gt;<a class="code" href="structcfs__range__expr.html#ad66352ab42e30bd2bad63315e21cb680">re_hi</a>;
<a name="l00606"></a>00606                                 }
<a name="l00607"></a>00607                         }
<a name="l00608"></a>00608                 }
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 
<a name="l00623"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a427babd44a62d4d31f0a03dc62143a69">00623</a> <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a427babd44a62d4d31f0a03dc62143a69" title="Determines whether an expression list in an ip nidrange contains exactly one contiguous...">cfs_ip_is_contiguous</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist)
<a name="l00624"></a>00624 {
<a name="l00625"></a>00625         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00626"></a>00626         <span class="keyword">struct </span><a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *ar;
<a name="l00627"></a>00627         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00628"></a>00628         <span class="keyword">struct </span><a class="code" href="structcfs__range__expr.html">cfs_range_expr</a> *re;
<a name="l00629"></a>00629         <span class="keywordtype">int</span> expr_count;
<a name="l00630"></a>00630         <span class="keywordtype">int</span> last_hi = 255;
<a name="l00631"></a>00631         <span class="keywordtype">int</span> last_diff = 0;
<a name="l00632"></a>00632         __u32 last_end_nid = 0;
<a name="l00633"></a>00633         __u32 current_start_nid = 0;
<a name="l00634"></a>00634         __u32 current_end_nid = 0;
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(nr, nidlist, nr_link) {
<a name="l00637"></a>00637                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(ar, &amp;nr-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>, ar_link) {
<a name="l00638"></a>00638                         last_hi = 255;
<a name="l00639"></a>00639                         last_diff = 0;
<a name="l00640"></a>00640                         <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a136cf0d0ede87182505473ab313f8b45" title="Determines minimum and maximum addresses for a single numeric address range.">cfs_ip_ar_min_max</a>(ar, &amp;current_start_nid,
<a name="l00641"></a>00641                                           &amp;current_end_nid);
<a name="l00642"></a>00642                         <span class="keywordflow">if</span> (last_end_nid != 0 &amp;&amp;
<a name="l00643"></a>00643                             (current_start_nid - last_end_nid != 1))
<a name="l00644"></a>00644                                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00645"></a>00645                         last_end_nid = current_end_nid;
<a name="l00646"></a>00646                         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(el,
<a name="l00647"></a>00647                                             &amp;ar-&gt;<a class="code" href="structaddrrange.html#ab76c34b0e7d2606fd1dde398048b3c7b" title="List head for cfs_expr_list::el_list.">ar_numaddr_ranges</a>,
<a name="l00648"></a>00648                                             el_link) {
<a name="l00649"></a>00649                                 expr_count = 0;
<a name="l00650"></a>00650                                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(re, &amp;el-&gt;<a class="code" href="structcfs__expr__list.html#a8cb88aa577495eacd0f9325df7ae0f75">el_exprs</a>,
<a name="l00651"></a>00651                                                     <a class="code" href="structcfs__range__expr.html#a9f59d966c4f6d1779c31c1732dcf21a9">re_link</a>) {
<a name="l00652"></a>00652                                         expr_count++;
<a name="l00653"></a>00653                                         <span class="keywordflow">if</span> (re-&gt;<a class="code" href="structcfs__range__expr.html#a915e9674c9bf97f2bc997482efad5d10">re_stride</a> &gt; 1 ||
<a name="l00654"></a>00654                                             (last_diff &gt; 0 &amp;&amp; last_hi != 255) ||
<a name="l00655"></a>00655                                             (last_diff &gt; 0 &amp;&amp; last_hi == 255 &amp;&amp;
<a name="l00656"></a>00656                                              re-&gt;<a class="code" href="structcfs__range__expr.html#aba957d5d4bb305e755cee0d4cb67b044">re_lo</a> &gt; 0))
<a name="l00657"></a>00657                                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00658"></a>00658                                         last_hi = re-&gt;<a class="code" href="structcfs__range__expr.html#ad66352ab42e30bd2bad63315e21cb680">re_hi</a>;
<a name="l00659"></a>00659                                         last_diff = re-&gt;<a class="code" href="structcfs__range__expr.html#ad66352ab42e30bd2bad63315e21cb680">re_hi</a> - re-&gt;<a class="code" href="structcfs__range__expr.html#aba957d5d4bb305e755cee0d4cb67b044">re_lo</a>;
<a name="l00660"></a>00660                                 }
<a name="l00661"></a>00661                         }
<a name="l00662"></a>00662                 }
<a name="l00663"></a>00663         }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00666"></a>00666 }
<a name="l00667"></a>00667 
<a name="l00676"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#ae6ce2c35f12986006eab5a28475eebed">00676</a> <span class="keywordtype">void</span> <a class="code" href="nidstr_8h.html#ae6ce2c35f12986006eab5a28475eebed" title="Takes a linked list of nidrange expressions, determines the minimum and maximum nid...">cfs_nidrange_find_min_max</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist, <span class="keywordtype">char</span> *min_nid,
<a name="l00677"></a>00677                                <span class="keywordtype">char</span> *max_nid, <span class="keywordtype">size_t</span> nidstr_length)
<a name="l00678"></a>00678 {
<a name="l00679"></a>00679         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00680"></a>00680         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf = NULL;
<a name="l00681"></a>00681         <span class="keywordtype">int</span> netnum = -1;
<a name="l00682"></a>00682         __u32 min_addr;
<a name="l00683"></a>00683         __u32 max_addr;
<a name="l00684"></a>00684         <span class="keywordtype">char</span> *lndname = NULL;
<a name="l00685"></a>00685         <span class="keywordtype">char</span> min_addr_str[<a class="code" href="lnet_2lnet_2nidstrings_8c.html#af292f56fa61c0dbf3e923bf742f9d754">IPSTRING_LENGTH</a>];
<a name="l00686"></a>00686         <span class="keywordtype">char</span> max_addr_str[<a class="code" href="lnet_2lnet_2nidstrings_8c.html#af292f56fa61c0dbf3e923bf742f9d754">IPSTRING_LENGTH</a>];
<a name="l00687"></a>00687 
<a name="l00688"></a>00688         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(nr, nidlist, nr_link) {
<a name="l00689"></a>00689                 nf = nr-&gt;<a class="code" href="structnidrange.html#a733b61b61c4820a5744c6ae82d52e17b" title="Pointer to corresponding element of libcfs_netstrfns.">nr_netstrfns</a>;
<a name="l00690"></a>00690                 lndname = nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>;
<a name="l00691"></a>00691                 <span class="keywordflow">if</span> (netnum == -1)
<a name="l00692"></a>00692                         netnum = nr-&gt;<a class="code" href="structnidrange.html#a5c312a671b53f68907253b646020fcfc" title="Number of network.">nr_netnum</a>;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694                 nf-&gt;<a class="code" href="structnetstrfns.html#adcd830468976833b1d8e5489162b1965">nf_min_max</a>(nidlist, &amp;min_addr, &amp;max_addr);
<a name="l00695"></a>00695         }
<a name="l00696"></a>00696         nf-&gt;<a class="code" href="structnetstrfns.html#a5b5d5f3d59011f785d050b209f87a39d">nf_addr2str</a>(min_addr, min_addr_str, <span class="keyword">sizeof</span>(min_addr_str));
<a name="l00697"></a>00697         nf-&gt;<a class="code" href="structnetstrfns.html#a5b5d5f3d59011f785d050b209f87a39d">nf_addr2str</a>(max_addr, max_addr_str, <span class="keyword">sizeof</span>(max_addr_str));
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         snprintf(min_nid, nidstr_length, <span class="stringliteral">&quot;%s@%s%d&quot;</span>, min_addr_str, lndname,
<a name="l00700"></a>00700                  netnum);
<a name="l00701"></a>00701         snprintf(max_nid, nidstr_length, <span class="stringliteral">&quot;%s@%s%d&quot;</span>, max_addr_str, lndname,
<a name="l00702"></a>00702                  netnum);
<a name="l00703"></a>00703 }
<a name="l00704"></a>00704 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#ae6ce2c35f12986006eab5a28475eebed" title="Takes a linked list of nidrange expressions, determines the minimum and maximum nid...">cfs_nidrange_find_min_max</a>);
<a name="l00705"></a>00705 
<a name="l00713"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#aa356aadc2011c998282e47f69b467e16">00713</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#aa356aadc2011c998282e47f69b467e16" title="Determines the min and max NID values for num LNDs.">cfs_num_min_max</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist, __u32 *min_nid,
<a name="l00714"></a>00714                             __u32 *max_nid)
<a name="l00715"></a>00715 {
<a name="l00716"></a>00716         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00717"></a>00717         <span class="keyword">struct </span><a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *ar;
<a name="l00718"></a>00718         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp_min_addr = 0;
<a name="l00719"></a>00719         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp_max_addr = 0;
<a name="l00720"></a>00720         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_addr = 0;
<a name="l00721"></a>00721         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_addr = 0;
<a name="l00722"></a>00722 
<a name="l00723"></a>00723         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(nr, nidlist, nr_link) {
<a name="l00724"></a>00724                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(ar, &amp;nr-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>, <a class="code" href="structaddrrange.html#a76d82f2a774f033d23eaae2b14832b67" title="Link to nidrange::nr_addrranges.">ar_link</a>) {
<a name="l00725"></a>00725                         <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a754c9e74a6b37c1de774a2a350859ba4" title="Determines minimum and maximum addresses for a single numeric address range.">cfs_num_ar_min_max</a>(ar, &amp;tmp_min_addr,
<a name="l00726"></a>00726                                            &amp;tmp_max_addr);
<a name="l00727"></a>00727                         <span class="keywordflow">if</span> (tmp_min_addr &lt; min_addr || min_addr == 0)
<a name="l00728"></a>00728                                 min_addr = tmp_min_addr;
<a name="l00729"></a>00729                         <span class="keywordflow">if</span> (tmp_max_addr &gt; max_addr)
<a name="l00730"></a>00730                                 max_addr = tmp_min_addr;
<a name="l00731"></a>00731                 }
<a name="l00732"></a>00732         }
<a name="l00733"></a>00733         *max_nid = max_addr;
<a name="l00734"></a>00734         *min_nid = min_addr;
<a name="l00735"></a>00735 }
<a name="l00736"></a>00736 
<a name="l00745"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a5a56a4ee1462918b07b9d9a38e3de20f">00745</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a5a56a4ee1462918b07b9d9a38e3de20f" title="Takes an nidlist and determines the minimum and maximum ip addresses.">cfs_ip_min_max</a>(<span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *nidlist, __u32 *min_nid,
<a name="l00746"></a>00746                            __u32 *max_nid)
<a name="l00747"></a>00747 {
<a name="l00748"></a>00748         <span class="keyword">struct </span><a class="code" href="structnidrange.html" title="Nid range list syntax.">nidrange</a> *nr;
<a name="l00749"></a>00749         <span class="keyword">struct </span><a class="code" href="structaddrrange.html" title="Structure to represent &amp;lt;addrrange&amp;gt; token of the syntax.">addrrange</a> *ar;
<a name="l00750"></a>00750         __u32 tmp_min_ip_addr = 0;
<a name="l00751"></a>00751         __u32 tmp_max_ip_addr = 0;
<a name="l00752"></a>00752         __u32 min_ip_addr = 0;
<a name="l00753"></a>00753         __u32 max_ip_addr = 0;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(nr, nidlist, nr_link) {
<a name="l00756"></a>00756                 <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(ar, &amp;nr-&gt;<a class="code" href="structnidrange.html#acfa80e12b6df485b1253eb615e258e30" title="List head for addrrange::ar_link.">nr_addrranges</a>, <a class="code" href="structaddrrange.html#a76d82f2a774f033d23eaae2b14832b67" title="Link to nidrange::nr_addrranges.">ar_link</a>) {
<a name="l00757"></a>00757                         <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a136cf0d0ede87182505473ab313f8b45" title="Determines minimum and maximum addresses for a single numeric address range.">cfs_ip_ar_min_max</a>(ar, &amp;tmp_min_ip_addr,
<a name="l00758"></a>00758                                           &amp;tmp_max_ip_addr);
<a name="l00759"></a>00759                         <span class="keywordflow">if</span> (tmp_min_ip_addr &lt; min_ip_addr || min_ip_addr == 0)
<a name="l00760"></a>00760                                 min_ip_addr = tmp_min_ip_addr;
<a name="l00761"></a>00761                         <span class="keywordflow">if</span> (tmp_max_ip_addr &gt; max_ip_addr)
<a name="l00762"></a>00762                                 max_ip_addr = tmp_max_ip_addr;
<a name="l00763"></a>00763                 }
<a name="l00764"></a>00764         }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="keywordflow">if</span> (min_nid != NULL)
<a name="l00767"></a>00767                 *min_nid = min_ip_addr;
<a name="l00768"></a>00768         <span class="keywordflow">if</span> (max_nid != NULL)
<a name="l00769"></a>00769                 *max_nid = max_ip_addr;
<a name="l00770"></a>00770 }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00773"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#ad6ec70be7726c406eba66c434edceef9">00773</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#ad6ec70be7726c406eba66c434edceef9">libcfs_lo_str2addr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> nob, __u32 *addr)
<a name="l00774"></a>00774 {
<a name="l00775"></a>00775         *addr = 0;
<a name="l00776"></a>00776         <span class="keywordflow">return</span> 1;
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00780"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a268e274e6a018cd254c47bafd6bb25b4">00780</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a268e274e6a018cd254c47bafd6bb25b4">libcfs_ip_addr2str</a>(__u32 addr, <span class="keywordtype">char</span> *str, <span class="keywordtype">size_t</span> <a class="code" href="lp__utils_8h.html#a439227feff9d7f55384e8780cfc2eb82">size</a>)
<a name="l00781"></a>00781 {
<a name="l00782"></a>00782         snprintf(str, size, <span class="stringliteral">&quot;%u.%u.%u.%u&quot;</span>,
<a name="l00783"></a>00783                  (addr &gt;&gt; 24) &amp; 0xff, (addr &gt;&gt; 16) &amp; 0xff,
<a name="l00784"></a>00784                  (addr &gt;&gt; 8) &amp; 0xff, addr &amp; 0xff);
<a name="l00785"></a>00785 }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="comment">/* CAVEAT EMPTOR XscanfX</span>
<a name="l00788"></a>00788 <span class="comment"> * I use &quot;%n&quot; at the end of a sscanf format to detect trailing junk.  However</span>
<a name="l00789"></a>00789 <span class="comment"> * sscanf may return immediately if it sees the terminating &apos;0&apos; in a string, so</span>
<a name="l00790"></a>00790 <span class="comment"> * I initialise the %n variable to the expected length.  If sscanf sets it;</span>
<a name="l00791"></a>00791 <span class="comment"> * fine, if it doesn&apos;t, then the scan ended at the end of the string, which is</span>
<a name="l00792"></a>00792 <span class="comment"> * fine too :) */</span>
<a name="l00793"></a>00793 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00794"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a98e788a967233621352a540b467aa2a0">00794</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a98e788a967233621352a540b467aa2a0">libcfs_ip_str2addr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> nob, __u32 *addr)
<a name="l00795"></a>00795 {
<a name="l00796"></a>00796         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    a;
<a name="l00797"></a>00797         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    b;
<a name="l00798"></a>00798         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    c;
<a name="l00799"></a>00799         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    d;
<a name="l00800"></a>00800         <span class="keywordtype">int</span>             n = nob; <span class="comment">/* XscanfX */</span>
<a name="l00801"></a>00801 
<a name="l00802"></a>00802         <span class="comment">/* numeric IP? */</span>
<a name="l00803"></a>00803         <span class="keywordflow">if</span> (sscanf(str, <span class="stringliteral">&quot;%u.%u.%u.%u%n&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;n) &gt;= 4 &amp;&amp;
<a name="l00804"></a>00804             n == nob &amp;&amp;
<a name="l00805"></a>00805             (a &amp; ~0xff) == 0 &amp;&amp; (b &amp; ~0xff) == 0 &amp;&amp;
<a name="l00806"></a>00806             (c &amp; ~0xff) == 0 &amp;&amp; (d &amp; ~0xff) == 0) {
<a name="l00807"></a>00807                 *addr = ((a&lt;&lt;24)|(b&lt;&lt;16)|(c&lt;&lt;8)|d);
<a name="l00808"></a>00808                 <span class="keywordflow">return</span> 1;
<a name="l00809"></a>00809         }
<a name="l00810"></a>00810         <span class="keywordflow">return</span> 0;
<a name="l00811"></a>00811 }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 <span class="comment">/* Used by lnet/config.c so it can&apos;t be static */</span>
<a name="l00814"></a>00814 <span class="keywordtype">int</span>
<a name="l00815"></a><a class="code" href="string_8h.html#a786157001da47851996d77d92289a589">00815</a> <a class="code" href="nidstr_8h.html#a786157001da47851996d77d92289a589">cfs_ip_addr_parse</a>(<span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> len, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *<a class="code" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)
<a name="l00816"></a>00816 {
<a name="l00817"></a>00817         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00818"></a>00818         <span class="keyword">struct </span><a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> src;
<a name="l00819"></a>00819         <span class="keywordtype">int</span> rc;
<a name="l00820"></a>00820         <span class="keywordtype">int</span> i;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822         src.<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a> = str;
<a name="l00823"></a>00823         src.<a class="code" href="structcfs__lstr.html#adf880bbf7e5b96717c0ffd49e4f72076">ls_len</a> = len;
<a name="l00824"></a>00824         i = 0;
<a name="l00825"></a>00825 
<a name="l00826"></a>00826         <span class="keywordflow">while</span> (src.<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a> != NULL) {
<a name="l00827"></a>00827                 <span class="keyword">struct </span><a class="code" href="structcfs__lstr.html" title="Structure to represent NULL-less strings.">cfs_lstr</a> res;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829                 <span class="keywordflow">if</span> (!<a class="code" href="libcfs__string_8h.html#a96360a23c2c49982017d60056e9953e6" title="Extracts tokens from strings.">cfs_gettok</a>(&amp;src, <span class="charliteral">&apos;.&apos;</span>, &amp;res)) {
<a name="l00830"></a>00830                         rc = -EINVAL;
<a name="l00831"></a>00831                         <span class="keywordflow">goto</span> out;
<a name="l00832"></a>00832                 }
<a name="l00833"></a>00833 
<a name="l00834"></a>00834                 rc = <a class="code" href="libcfs__string_8h.html#a9fceedd2da112e9e1d8c5515f7ed3404" title="Parses &amp;lt;cfs_expr_list&amp;gt; token of the syntax.">cfs_expr_list_parse</a>(res.<a class="code" href="structcfs__lstr.html#a161b25dda18c638ec09126538c01a177">ls_str</a>, res.<a class="code" href="structcfs__lstr.html#adf880bbf7e5b96717c0ffd49e4f72076">ls_len</a>, 0, 255, &amp;el);
<a name="l00835"></a>00835                 <span class="keywordflow">if</span> (rc != 0)
<a name="l00836"></a>00836                         <span class="keywordflow">goto</span> out;
<a name="l00837"></a>00837 
<a name="l00838"></a>00838                 <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;el-&gt;<a class="code" href="structcfs__expr__list.html#a7518136a1025352468617d315739b293">el_link</a>, list);
<a name="l00839"></a>00839                 i++;
<a name="l00840"></a>00840         }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842         <span class="keywordflow">if</span> (i == 4)
<a name="l00843"></a>00843                 <span class="keywordflow">return</span> 0;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         rc = -EINVAL;
<a name="l00846"></a>00846 out:
<a name="l00847"></a>00847         <a class="code" href="libcfs__string_8h.html#a860f9e47eda266fefdc515be69e74ef0" title="Frees cfs_expr_list structures of list.">cfs_expr_list_free_list</a>(list);
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         <span class="keywordflow">return</span> rc;
<a name="l00850"></a>00850 }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00853"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a37c47b5cea4bbf137ef22e39cf1063c6">00853</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a37c47b5cea4bbf137ef22e39cf1063c6">libcfs_ip_addr_range_print</a>(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> count, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *<a class="code" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)
<a name="l00854"></a>00854 {
<a name="l00855"></a>00855         <span class="keywordtype">int</span> i = 0, j = 0;
<a name="l00856"></a>00856         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(el, list, <a class="code" href="structcfs__expr__list.html#a7518136a1025352468617d315739b293">el_link</a>) {
<a name="l00859"></a>00859                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(j++ &lt; 4);
<a name="l00860"></a>00860                 <span class="keywordflow">if</span> (i != 0)
<a name="l00861"></a>00861                         i += scnprintf(buffer + i, count - i, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l00862"></a>00862                 i += <a class="code" href="libcfs__string_8h.html#a8b6a98370224cd18cdbebf15201b692e" title="Print a list of range expressions (expr_list) into specified buffer.">cfs_expr_list_print</a>(buffer + i, count - i, el);
<a name="l00863"></a>00863         }
<a name="l00864"></a>00864         <span class="keywordflow">return</span> i;
<a name="l00865"></a>00865 }
<a name="l00866"></a>00866 
<a name="l00873"></a>00873 <span class="keywordtype">int</span>
<a name="l00874"></a><a class="code" href="string_8h.html#ad9e60349af3524b73b3b83531666b522">00874</a> <a class="code" href="nidstr_8h.html#ad9e60349af3524b73b3b83531666b522" title="Matches address (addr) against address set encoded in list.">cfs_ip_addr_match</a>(__u32 addr, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *<a class="code" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)
<a name="l00875"></a>00875 {
<a name="l00876"></a>00876         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00877"></a>00877         <span class="keywordtype">int</span> i = 0;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879         <a class="code" href="list_8h.html#accc8d8e6c8ffe8ce964c5a1b59732cf3" title="Iterate backwards over a list of given type.">list_for_each_entry_reverse</a>(el, list, <a class="code" href="structcfs__expr__list.html#a7518136a1025352468617d315739b293">el_link</a>) {
<a name="l00880"></a>00880                 <span class="keywordflow">if</span> (!<a class="code" href="libcfs__string_8h.html#a0833518917f4fe3005b74b0493439787" title="Matches value (value) against ranges expression list expr_list.">cfs_expr_list_match</a>(addr &amp; 0xff, el))
<a name="l00881"></a>00881                         <span class="keywordflow">return</span> 0;
<a name="l00882"></a>00882                 addr &gt;&gt;= 8;
<a name="l00883"></a>00883                 i++;
<a name="l00884"></a>00884         }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886         <span class="keywordflow">return</span> i == 4;
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00894"></a>00894 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00895"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a35d0e0bbdb8455d5a606d168ffd16b00">00895</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a35d0e0bbdb8455d5a606d168ffd16b00" title="Print the network part of the nidrange nr into the specified buffer.">libcfs_decnum_addr2str</a>(__u32 addr, <span class="keywordtype">char</span> *str, <span class="keywordtype">size_t</span> <a class="code" href="lp__utils_8h.html#a439227feff9d7f55384e8780cfc2eb82">size</a>)
<a name="l00896"></a>00896 {
<a name="l00897"></a>00897         snprintf(str, size, <span class="stringliteral">&quot;%u&quot;</span>, addr);
<a name="l00898"></a>00898 }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00901"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#af07ce97fc2f755ad70e8e9c2571f01d8">00901</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#af07ce97fc2f755ad70e8e9c2571f01d8">libcfs_num_str2addr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> nob, __u32 *addr)
<a name="l00902"></a>00902 {
<a name="l00903"></a>00903         <span class="keywordtype">int</span>     n;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905         n = nob;
<a name="l00906"></a>00906         <span class="keywordflow">if</span> (sscanf(str, <span class="stringliteral">&quot;0x%x%n&quot;</span>, addr, &amp;n) &gt;= 1 &amp;&amp; n == nob)
<a name="l00907"></a>00907                 <span class="keywordflow">return</span> 1;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909         n = nob;
<a name="l00910"></a>00910         <span class="keywordflow">if</span> (sscanf(str, <span class="stringliteral">&quot;0X%x%n&quot;</span>, addr, &amp;n) &gt;= 1 &amp;&amp; n == nob)
<a name="l00911"></a>00911                 <span class="keywordflow">return</span> 1;
<a name="l00912"></a>00912 
<a name="l00913"></a>00913         n = nob;
<a name="l00914"></a>00914         <span class="keywordflow">if</span> (sscanf(str, <span class="stringliteral">&quot;%u%n&quot;</span>, addr, &amp;n) &gt;= 1 &amp;&amp; n == nob)
<a name="l00915"></a>00915                 <span class="keywordflow">return</span> 1;
<a name="l00916"></a>00916 
<a name="l00917"></a>00917         <span class="keywordflow">return</span> 0;
<a name="l00918"></a>00918 }
<a name="l00919"></a>00919 
<a name="l00928"></a>00928 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00929"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a1a02f452ac68604e7d5d1d43aa33c729">00929</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a1a02f452ac68604e7d5d1d43aa33c729" title="Nf_parse_addrlist method for networks using numeric addresses.">libcfs_num_parse</a>(<span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> len, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *<a class="code" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)
<a name="l00930"></a>00930 {
<a name="l00931"></a>00931         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00932"></a>00932         <span class="keywordtype">int</span>     rc;
<a name="l00933"></a>00933 
<a name="l00934"></a>00934         rc = <a class="code" href="libcfs__string_8h.html#a9fceedd2da112e9e1d8c5515f7ed3404" title="Parses &amp;lt;cfs_expr_list&amp;gt; token of the syntax.">cfs_expr_list_parse</a>(str, len, 0, <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a2ab69fad40a1781fe8db369f55bd2b8a">MAX_NUMERIC_VALUE</a>, &amp;el);
<a name="l00935"></a>00935         <span class="keywordflow">if</span> (rc == 0)
<a name="l00936"></a>00936                 <a class="code" href="list_8h.html#a588bec046f1e9797b33a5c5ab250f447" title="Insert an entry at the end of a list.">list_add_tail</a>(&amp;el-&gt;<a class="code" href="structcfs__expr__list.html#a7518136a1025352468617d315739b293">el_link</a>, list);
<a name="l00937"></a>00937 
<a name="l00938"></a>00938         <span class="keywordflow">return</span> rc;
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00942"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a92a5b09d2c275f4173d9f3f9bb00fe0b">00942</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a92a5b09d2c275f4173d9f3f9bb00fe0b">libcfs_num_addr_range_print</a>(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> count, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *<a class="code" href="lnetctl_8c.html#ac75dee5cf9c8f0128e744b7d95db6767">list</a>)
<a name="l00943"></a>00943 {
<a name="l00944"></a>00944         <span class="keywordtype">int</span> i = 0, j = 0;
<a name="l00945"></a>00945         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00946"></a>00946 
<a name="l00947"></a>00947         <a class="code" href="list_8h.html#a9b782fefb5ab71ce9762182e45a615e1" title="Iterate over a list of given type.">list_for_each_entry</a>(el, list, <a class="code" href="structcfs__expr__list.html#a7518136a1025352468617d315739b293">el_link</a>) {
<a name="l00948"></a>00948                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(j++ &lt; 1);
<a name="l00949"></a>00949                 i += <a class="code" href="libcfs__string_8h.html#a8b6a98370224cd18cdbebf15201b692e" title="Print a list of range expressions (expr_list) into specified buffer.">cfs_expr_list_print</a>(buffer + i, count - i, el);
<a name="l00950"></a>00950         }
<a name="l00951"></a>00951         <span class="keywordflow">return</span> i;
<a name="l00952"></a>00952 }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954 <span class="comment">/*</span>
<a name="l00955"></a>00955 <span class="comment"> * Nf_match_addr method for networks using numeric addresses</span>
<a name="l00956"></a>00956 <span class="comment"> *</span>
<a name="l00957"></a>00957 <span class="comment"> * \retval 1 on match</span>
<a name="l00958"></a>00958 <span class="comment"> * \retval 0 otherwise</span>
<a name="l00959"></a>00959 <span class="comment"> */</span>
<a name="l00960"></a>00960 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00961"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a05ede6b07a27ea2b76d13113bc45f20a">00961</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a05ede6b07a27ea2b76d13113bc45f20a">libcfs_num_match</a>(__u32 addr, <span class="keyword">struct</span> <a class="code" href="structlist__head.html">list_head</a> *numaddr)
<a name="l00962"></a>00962 {
<a name="l00963"></a>00963         <span class="keyword">struct </span><a class="code" href="structcfs__expr__list.html">cfs_expr_list</a> *el;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965         <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(!<a class="code" href="list_8h.html#a0fce12be81e8f2677b3a272fee1652ac" title="Test whether a list is empty.">list_empty</a>(numaddr));
<a name="l00966"></a>00966         el = <a class="code" href="list_8h.html#a26c976b7f654e70df318c1843e5094de" title="Get the container of a list.">list_entry</a>(numaddr-&gt;<a class="code" href="structlist__head.html#ac3b0ff0dfb978a0cfbdad6b9d19cdcfe">next</a>, <span class="keyword">struct</span> <a class="code" href="structcfs__expr__list.html">cfs_expr_list</a>, <a class="code" href="structcfs__expr__list.html#a7518136a1025352468617d315739b293">el_link</a>);
<a name="l00967"></a>00967 
<a name="l00968"></a>00968         <span class="keywordflow">return</span> <a class="code" href="libcfs__string_8h.html#a0833518917f4fe3005b74b0493439787" title="Matches value (value) against ranges expression list expr_list.">cfs_expr_list_match</a>(addr, el);
<a name="l00969"></a>00969 }
<a name="l00970"></a>00970 
<a name="l00971"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a53227b1694532a6523cc9a351bee0e3a">00971</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a53227b1694532a6523cc9a351bee0e3a">libcfs_netstrfns</a>[] = {
<a name="l00972"></a>00972         { .<a class="code" href="structnetstrfns.html#aa6b63c720ed7ed94973f37fe9a287f40">nf_type</a>              = <a class="code" href="nidstr_8h.html#afb9b21dcb0b6eb4e9e0c9cb090e774beab2569f8547a3ef45663982f966cd9458">LOLND</a>,
<a name="l00973"></a>00973           .nf_name              = <span class="stringliteral">&quot;lo&quot;</span>,
<a name="l00974"></a>00974           .nf_modname           = <span class="stringliteral">&quot;klolnd&quot;</span>,
<a name="l00975"></a>00975           .nf_addr2str          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a35d0e0bbdb8455d5a606d168ffd16b00" title="Print the network part of the nidrange nr into the specified buffer.">libcfs_decnum_addr2str</a>,
<a name="l00976"></a>00976           .nf_str2addr          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#ad6ec70be7726c406eba66c434edceef9">libcfs_lo_str2addr</a>,
<a name="l00977"></a>00977           .nf_parse_addrlist    = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a1a02f452ac68604e7d5d1d43aa33c729" title="Nf_parse_addrlist method for networks using numeric addresses.">libcfs_num_parse</a>,
<a name="l00978"></a>00978           .nf_print_addrlist    = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a92a5b09d2c275f4173d9f3f9bb00fe0b">libcfs_num_addr_range_print</a>,
<a name="l00979"></a>00979           .nf_match_addr        = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a05ede6b07a27ea2b76d13113bc45f20a">libcfs_num_match</a>,
<a name="l00980"></a>00980           .nf_is_contiguous     = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#acbd0bd03c72ef48867b31b940cf4a656" title="Determines whether an expression list in an num nidrange contains exactly one contiguous...">cfs_num_is_contiguous</a>,
<a name="l00981"></a>00981           .nf_min_max           = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#aa356aadc2011c998282e47f69b467e16" title="Determines the min and max NID values for num LNDs.">cfs_num_min_max</a> },
<a name="l00982"></a>00982         { .nf_type              = <a class="code" href="nidstr_8h.html#afb9b21dcb0b6eb4e9e0c9cb090e774bea7712f2834e8e9ff044c86fe04c5d8d39">SOCKLND</a>,
<a name="l00983"></a>00983           .nf_name              = <span class="stringliteral">&quot;tcp&quot;</span>,
<a name="l00984"></a>00984           .nf_modname           = <span class="stringliteral">&quot;ksocklnd&quot;</span>,
<a name="l00985"></a>00985           .nf_addr2str          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a268e274e6a018cd254c47bafd6bb25b4">libcfs_ip_addr2str</a>,
<a name="l00986"></a>00986           .nf_str2addr          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a98e788a967233621352a540b467aa2a0">libcfs_ip_str2addr</a>,
<a name="l00987"></a>00987           .nf_parse_addrlist    = <a class="code" href="nidstr_8h.html#a786157001da47851996d77d92289a589">cfs_ip_addr_parse</a>,
<a name="l00988"></a>00988           .nf_print_addrlist    = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a37c47b5cea4bbf137ef22e39cf1063c6">libcfs_ip_addr_range_print</a>,
<a name="l00989"></a>00989           .nf_match_addr        = <a class="code" href="nidstr_8h.html#ad9e60349af3524b73b3b83531666b522" title="Matches address (addr) against address set encoded in list.">cfs_ip_addr_match</a>,
<a name="l00990"></a>00990           .nf_is_contiguous     = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a427babd44a62d4d31f0a03dc62143a69" title="Determines whether an expression list in an ip nidrange contains exactly one contiguous...">cfs_ip_is_contiguous</a>,
<a name="l00991"></a>00991           .nf_min_max           = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a5a56a4ee1462918b07b9d9a38e3de20f" title="Takes an nidlist and determines the minimum and maximum ip addresses.">cfs_ip_min_max</a> },
<a name="l00992"></a>00992         { .nf_type              = <a class="code" href="nidstr_8h.html#afb9b21dcb0b6eb4e9e0c9cb090e774bea878f32da37e30aa19380f35c360ffe74">O2IBLND</a>,
<a name="l00993"></a>00993           .nf_name              = <span class="stringliteral">&quot;o2ib&quot;</span>,
<a name="l00994"></a>00994           .nf_modname           = <span class="stringliteral">&quot;ko2iblnd&quot;</span>,
<a name="l00995"></a>00995           .nf_addr2str          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a268e274e6a018cd254c47bafd6bb25b4">libcfs_ip_addr2str</a>,
<a name="l00996"></a>00996           .nf_str2addr          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a98e788a967233621352a540b467aa2a0">libcfs_ip_str2addr</a>,
<a name="l00997"></a>00997           .nf_parse_addrlist    = <a class="code" href="nidstr_8h.html#a786157001da47851996d77d92289a589">cfs_ip_addr_parse</a>,
<a name="l00998"></a>00998           .nf_print_addrlist    = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a37c47b5cea4bbf137ef22e39cf1063c6">libcfs_ip_addr_range_print</a>,
<a name="l00999"></a>00999           .nf_match_addr        = <a class="code" href="nidstr_8h.html#ad9e60349af3524b73b3b83531666b522" title="Matches address (addr) against address set encoded in list.">cfs_ip_addr_match</a>,
<a name="l01000"></a>01000           .nf_is_contiguous     = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a427babd44a62d4d31f0a03dc62143a69" title="Determines whether an expression list in an ip nidrange contains exactly one contiguous...">cfs_ip_is_contiguous</a>,
<a name="l01001"></a>01001           .nf_min_max           = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a5a56a4ee1462918b07b9d9a38e3de20f" title="Takes an nidlist and determines the minimum and maximum ip addresses.">cfs_ip_min_max</a> },
<a name="l01002"></a>01002         { .nf_type              = <a class="code" href="nidstr_8h.html#afb9b21dcb0b6eb4e9e0c9cb090e774bea849384fc332c2aa0e096404067976d77">GNILND</a>,
<a name="l01003"></a>01003           .nf_name              = <span class="stringliteral">&quot;gni&quot;</span>,
<a name="l01004"></a>01004           .nf_modname           = <span class="stringliteral">&quot;kgnilnd&quot;</span>,
<a name="l01005"></a>01005           .nf_addr2str          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a35d0e0bbdb8455d5a606d168ffd16b00" title="Print the network part of the nidrange nr into the specified buffer.">libcfs_decnum_addr2str</a>,
<a name="l01006"></a>01006           .nf_str2addr          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#af07ce97fc2f755ad70e8e9c2571f01d8">libcfs_num_str2addr</a>,
<a name="l01007"></a>01007           .nf_parse_addrlist    = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a1a02f452ac68604e7d5d1d43aa33c729" title="Nf_parse_addrlist method for networks using numeric addresses.">libcfs_num_parse</a>,
<a name="l01008"></a>01008           .nf_print_addrlist    = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a92a5b09d2c275f4173d9f3f9bb00fe0b">libcfs_num_addr_range_print</a>,
<a name="l01009"></a>01009           .nf_match_addr        = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a05ede6b07a27ea2b76d13113bc45f20a">libcfs_num_match</a>,
<a name="l01010"></a>01010           .nf_is_contiguous     = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#acbd0bd03c72ef48867b31b940cf4a656" title="Determines whether an expression list in an num nidrange contains exactly one contiguous...">cfs_num_is_contiguous</a>,
<a name="l01011"></a>01011           .nf_min_max           = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#aa356aadc2011c998282e47f69b467e16" title="Determines the min and max NID values for num LNDs.">cfs_num_min_max</a> },
<a name="l01012"></a>01012         { .nf_type              = <a class="code" href="nidstr_8h.html#afb9b21dcb0b6eb4e9e0c9cb090e774bea3b1909089d9ca6fbe0e0ceeeb537cfd9">GNIIPLND</a>,
<a name="l01013"></a>01013           .nf_name              = <span class="stringliteral">&quot;gip&quot;</span>,
<a name="l01014"></a>01014           .nf_modname           = <span class="stringliteral">&quot;kgnilnd&quot;</span>,
<a name="l01015"></a>01015           .nf_addr2str          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a268e274e6a018cd254c47bafd6bb25b4">libcfs_ip_addr2str</a>,
<a name="l01016"></a>01016           .nf_str2addr          = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a98e788a967233621352a540b467aa2a0">libcfs_ip_str2addr</a>,
<a name="l01017"></a>01017           .nf_parse_addrlist    = <a class="code" href="nidstr_8h.html#a786157001da47851996d77d92289a589">cfs_ip_addr_parse</a>,
<a name="l01018"></a>01018           .nf_print_addrlist    = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a37c47b5cea4bbf137ef22e39cf1063c6">libcfs_ip_addr_range_print</a>,
<a name="l01019"></a>01019           .nf_match_addr        = <a class="code" href="nidstr_8h.html#ad9e60349af3524b73b3b83531666b522" title="Matches address (addr) against address set encoded in list.">cfs_ip_addr_match</a>,
<a name="l01020"></a>01020           .nf_is_contiguous     = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a427babd44a62d4d31f0a03dc62143a69" title="Determines whether an expression list in an ip nidrange contains exactly one contiguous...">cfs_ip_is_contiguous</a>,
<a name="l01021"></a>01021           .nf_min_max           = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a5a56a4ee1462918b07b9d9a38e3de20f" title="Takes an nidlist and determines the minimum and maximum ip addresses.">cfs_ip_min_max</a> },
<a name="l01022"></a>01022 };
<a name="l01023"></a>01023 
<a name="l01024"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3c20c5f4fec23e83b3c35e3e2c7e4f3d">01024</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3c20c5f4fec23e83b3c35e3e2c7e4f3d">libcfs_nnetstrfns</a> = <a class="code" href="group__llapi.html#ga25f003de16c08a4888b69f619d70f427">ARRAY_SIZE</a>(libcfs_netstrfns);
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *
<a name="l01027"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a4dbadeb3bf735772361eb1db1374553e">01027</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a4dbadeb3bf735772361eb1db1374553e">libcfs_lnd2netstrfns</a>(__u32 lnd)
<a name="l01028"></a>01028 {
<a name="l01029"></a>01029         <span class="keywordtype">int</span>     i;
<a name="l01030"></a>01030 
<a name="l01031"></a>01031         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3c20c5f4fec23e83b3c35e3e2c7e4f3d">libcfs_nnetstrfns</a>; i++)
<a name="l01032"></a>01032                 <span class="keywordflow">if</span> (lnd == libcfs_netstrfns[i].<a class="code" href="structnetstrfns.html#aa6b63c720ed7ed94973f37fe9a287f40">nf_type</a>)
<a name="l01033"></a>01033                         <span class="keywordflow">return</span> &amp;libcfs_netstrfns[i];
<a name="l01034"></a>01034 
<a name="l01035"></a>01035         <span class="keywordflow">return</span> NULL;
<a name="l01036"></a>01036 }
<a name="l01037"></a>01037 
<a name="l01038"></a>01038 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *
<a name="l01039"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a6375a5ccc526f15bb897f4aa66cd4966">01039</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a6375a5ccc526f15bb897f4aa66cd4966">libcfs_namenum2netstrfns</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)
<a name="l01040"></a>01040 {
<a name="l01041"></a>01041         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf;
<a name="l01042"></a>01042         <span class="keywordtype">int</span>               i;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3c20c5f4fec23e83b3c35e3e2c7e4f3d">libcfs_nnetstrfns</a>; i++) {
<a name="l01045"></a>01045                 nf = &amp;libcfs_netstrfns[i];
<a name="l01046"></a>01046                 <span class="keywordflow">if</span> (!strncmp(name, nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>, strlen(nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>)))
<a name="l01047"></a>01047                         <span class="keywordflow">return</span> nf;
<a name="l01048"></a>01048         }
<a name="l01049"></a>01049         <span class="keywordflow">return</span> NULL;
<a name="l01050"></a>01050 }
<a name="l01051"></a>01051 
<a name="l01052"></a>01052 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *
<a name="l01053"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3c512634d8bce9999cda6848269cd848">01053</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3c512634d8bce9999cda6848269cd848">libcfs_name2netstrfns</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)
<a name="l01054"></a>01054 {
<a name="l01055"></a>01055         <span class="keywordtype">int</span>    i;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3c20c5f4fec23e83b3c35e3e2c7e4f3d">libcfs_nnetstrfns</a>; i++)
<a name="l01058"></a>01058                 <span class="keywordflow">if</span> (!strcmp(libcfs_netstrfns[i].<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>, name))
<a name="l01059"></a>01059                         <span class="keywordflow">return</span> &amp;libcfs_netstrfns[i];
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         <span class="keywordflow">return</span> NULL;
<a name="l01062"></a>01062 }
<a name="l01063"></a>01063 
<a name="l01064"></a>01064 <span class="keywordtype">int</span>
<a name="l01065"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a0f3eb9cc7f8a35fe35d6e8035bbb38f7">01065</a> <a class="code" href="nidstr_8h.html#a0f3eb9cc7f8a35fe35d6e8035bbb38f7">libcfs_isknown_lnd</a>(__u32 lnd)
<a name="l01066"></a>01066 {
<a name="l01067"></a>01067         <span class="keywordflow">return</span> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a4dbadeb3bf735772361eb1db1374553e">libcfs_lnd2netstrfns</a>(lnd) != NULL;
<a name="l01068"></a>01068 }
<a name="l01069"></a>01069 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#a0f3eb9cc7f8a35fe35d6e8035bbb38f7">libcfs_isknown_lnd</a>);
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 <span class="keywordtype">char</span> *
<a name="l01072"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#ac683b5afc0cd18b68c036de94213efbd">01072</a> <a class="code" href="nidstr_8h.html#ac683b5afc0cd18b68c036de94213efbd">libcfs_lnd2modname</a>(__u32 lnd)
<a name="l01073"></a>01073 {
<a name="l01074"></a>01074         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a4dbadeb3bf735772361eb1db1374553e">libcfs_lnd2netstrfns</a>(lnd);
<a name="l01075"></a>01075 
<a name="l01076"></a>01076         <span class="keywordflow">return</span> (nf == NULL) ? NULL : nf-&gt;<a class="code" href="structnetstrfns.html#afd37763315a43537a783b3ec138c3c67">nf_modname</a>;
<a name="l01077"></a>01077 }
<a name="l01078"></a>01078 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#ac683b5afc0cd18b68c036de94213efbd">libcfs_lnd2modname</a>);
<a name="l01079"></a>01079 
<a name="l01080"></a>01080 <span class="keywordtype">int</span>
<a name="l01081"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#aaeee3241b5001dd919f447fbf0254e68">01081</a> <a class="code" href="nidstr_8h.html#aaeee3241b5001dd919f447fbf0254e68">libcfs_str2lnd</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l01082"></a>01082 {
<a name="l01083"></a>01083         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3c512634d8bce9999cda6848269cd848">libcfs_name2netstrfns</a>(str);
<a name="l01084"></a>01084 
<a name="l01085"></a>01085         <span class="keywordflow">if</span> (nf != NULL)
<a name="l01086"></a>01086                 <span class="keywordflow">return</span> nf-&gt;<a class="code" href="structnetstrfns.html#aa6b63c720ed7ed94973f37fe9a287f40">nf_type</a>;
<a name="l01087"></a>01087 
<a name="l01088"></a>01088         <span class="keywordflow">return</span> -ENXIO;
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#aaeee3241b5001dd919f447fbf0254e68">libcfs_str2lnd</a>);
<a name="l01091"></a>01091 
<a name="l01092"></a>01092 <span class="keywordtype">char</span> *
<a name="l01093"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a48cf2a62869f373640f622897b24b8d7">01093</a> <a class="code" href="nidstr_8h.html#a48cf2a62869f373640f622897b24b8d7">libcfs_lnd2str_r</a>(__u32 lnd, <span class="keywordtype">char</span> *<a class="code" href="parallel__grouplock_8c.html#a30581aaaef7980b9fc6df8f98406097c">buf</a>, <span class="keywordtype">size_t</span> buf_size)
<a name="l01094"></a>01094 {
<a name="l01095"></a>01095         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf;
<a name="l01096"></a>01096 
<a name="l01097"></a>01097         nf = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a4dbadeb3bf735772361eb1db1374553e">libcfs_lnd2netstrfns</a>(lnd);
<a name="l01098"></a>01098         <span class="keywordflow">if</span> (nf == NULL)
<a name="l01099"></a>01099                 snprintf(buf, buf_size, <span class="stringliteral">&quot;?%u?&quot;</span>, lnd);
<a name="l01100"></a>01100         <span class="keywordflow">else</span>
<a name="l01101"></a>01101                 snprintf(buf, buf_size, <span class="stringliteral">&quot;%s&quot;</span>, nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>);
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         <span class="keywordflow">return</span> buf;
<a name="l01104"></a>01104 }
<a name="l01105"></a>01105 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#a48cf2a62869f373640f622897b24b8d7">libcfs_lnd2str_r</a>);
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 <span class="keywordtype">char</span> *
<a name="l01108"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a899dcf2459e309499c54be5f199d5926">01108</a> <a class="code" href="nidstr_8h.html#a899dcf2459e309499c54be5f199d5926">libcfs_net2str_r</a>(__u32 net, <span class="keywordtype">char</span> *<a class="code" href="parallel__grouplock_8c.html#a30581aaaef7980b9fc6df8f98406097c">buf</a>, <span class="keywordtype">size_t</span> buf_size)
<a name="l01109"></a>01109 {
<a name="l01110"></a>01110         __u32             nnum = <a class="code" href="group__lnet__addr.html#gaa5b1f70b0f73fff4e4d2ceb7b95965b1">LNET_NETNUM</a>(net);
<a name="l01111"></a>01111         __u32             lnd  = <a class="code" href="group__lnet__addr.html#gad907b8fc6e2f50ca5ddcde69d8fbaa37">LNET_NETTYP</a>(net);
<a name="l01112"></a>01112         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf;
<a name="l01113"></a>01113 
<a name="l01114"></a>01114         nf = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a4dbadeb3bf735772361eb1db1374553e">libcfs_lnd2netstrfns</a>(lnd);
<a name="l01115"></a>01115         <span class="keywordflow">if</span> (nf == NULL)
<a name="l01116"></a>01116                 snprintf(buf, buf_size, <span class="stringliteral">&quot;&lt;%u:%u&gt;&quot;</span>, lnd, nnum);
<a name="l01117"></a>01117         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nnum == 0)
<a name="l01118"></a>01118                 snprintf(buf, buf_size, <span class="stringliteral">&quot;%s&quot;</span>, nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>);
<a name="l01119"></a>01119         <span class="keywordflow">else</span>
<a name="l01120"></a>01120                 snprintf(buf, buf_size, <span class="stringliteral">&quot;%s%u&quot;</span>, nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>, nnum);
<a name="l01121"></a>01121 
<a name="l01122"></a>01122         <span class="keywordflow">return</span> buf;
<a name="l01123"></a>01123 }
<a name="l01124"></a>01124 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#a899dcf2459e309499c54be5f199d5926">libcfs_net2str_r</a>);
<a name="l01125"></a>01125 
<a name="l01126"></a>01126 <span class="keywordtype">char</span> *
<a name="l01127"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a5a7fd82c64fe23630ff4136f05cebeb2">01127</a> <a class="code" href="nidstr_8h.html#a5a7fd82c64fe23630ff4136f05cebeb2">libcfs_nid2str_r</a>(<a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> nid, <span class="keywordtype">char</span> *<a class="code" href="parallel__grouplock_8c.html#a30581aaaef7980b9fc6df8f98406097c">buf</a>, <span class="keywordtype">size_t</span> buf_size)
<a name="l01128"></a>01128 {
<a name="l01129"></a>01129         __u32             addr = <a class="code" href="group__lnet__addr.html#ga692b6a866269a35490f2e2803cc2e5d6" title="extract the address part of an lnet_nid_t">LNET_NIDADDR</a>(nid);
<a name="l01130"></a>01130         __u32             net  = <a class="code" href="group__lnet__addr.html#gabf536c21b8f5226eadf3a124a265ee3b">LNET_NIDNET</a>(nid);
<a name="l01131"></a>01131         __u32             nnum = <a class="code" href="group__lnet__addr.html#gaa5b1f70b0f73fff4e4d2ceb7b95965b1">LNET_NETNUM</a>(net);
<a name="l01132"></a>01132         __u32             lnd  = <a class="code" href="group__lnet__addr.html#gad907b8fc6e2f50ca5ddcde69d8fbaa37">LNET_NETTYP</a>(net);
<a name="l01133"></a>01133         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf;
<a name="l01134"></a>01134 
<a name="l01135"></a>01135         <span class="keywordflow">if</span> (nid == <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>) {
<a name="l01136"></a>01136                 strncpy(buf, <span class="stringliteral">&quot;&lt;?&gt;&quot;</span>, buf_size);
<a name="l01137"></a>01137                 buf[buf_size - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01138"></a>01138                 <span class="keywordflow">return</span> buf;
<a name="l01139"></a>01139         }
<a name="l01140"></a>01140 
<a name="l01141"></a>01141         nf = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a4dbadeb3bf735772361eb1db1374553e">libcfs_lnd2netstrfns</a>(lnd);
<a name="l01142"></a>01142         <span class="keywordflow">if</span> (nf == NULL) {
<a name="l01143"></a>01143                 snprintf(buf, buf_size, <span class="stringliteral">&quot;%x@&lt;%u:%u&gt;&quot;</span>, addr, lnd, nnum);
<a name="l01144"></a>01144         } <span class="keywordflow">else</span> {
<a name="l01145"></a>01145                 <span class="keywordtype">size_t</span> addr_len;
<a name="l01146"></a>01146 
<a name="l01147"></a>01147                 nf-&gt;<a class="code" href="structnetstrfns.html#a5b5d5f3d59011f785d050b209f87a39d">nf_addr2str</a>(addr, buf, buf_size);
<a name="l01148"></a>01148                 addr_len = strlen(buf);
<a name="l01149"></a>01149                 <span class="keywordflow">if</span> (nnum == 0)
<a name="l01150"></a>01150                         snprintf(buf + addr_len, buf_size - addr_len, <span class="stringliteral">&quot;@%s&quot;</span>,
<a name="l01151"></a>01151                                  nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>);
<a name="l01152"></a>01152                 <span class="keywordflow">else</span>
<a name="l01153"></a>01153                         snprintf(buf + addr_len, buf_size - addr_len, <span class="stringliteral">&quot;@%s%u&quot;</span>,
<a name="l01154"></a>01154                                  nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>, nnum);
<a name="l01155"></a>01155         }
<a name="l01156"></a>01156 
<a name="l01157"></a>01157         <span class="keywordflow">return</span> buf;
<a name="l01158"></a>01158 }
<a name="l01159"></a>01159 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#a5a7fd82c64fe23630ff4136f05cebeb2">libcfs_nid2str_r</a>);
<a name="l01160"></a>01160 
<a name="l01161"></a>01161 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *
<a name="l01162"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3440cdba7492dc1e57acc7f82ac2e5b4">01162</a> <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3440cdba7492dc1e57acc7f82ac2e5b4">libcfs_str2net_internal</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, __u32 *net)
<a name="l01163"></a>01163 {
<a name="l01164"></a>01164         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf = NULL;
<a name="l01165"></a>01165         <span class="keywordtype">int</span>               nob;
<a name="l01166"></a>01166         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      netnum;
<a name="l01167"></a>01167         <span class="keywordtype">int</span>               i;
<a name="l01168"></a>01168 
<a name="l01169"></a>01169         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3c20c5f4fec23e83b3c35e3e2c7e4f3d">libcfs_nnetstrfns</a>; i++) {
<a name="l01170"></a>01170                 nf = &amp;libcfs_netstrfns[i];
<a name="l01171"></a>01171                 <span class="keywordflow">if</span> (!strncmp(str, nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>, strlen(nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>)))
<a name="l01172"></a>01172                         <span class="keywordflow">break</span>;
<a name="l01173"></a>01173         }
<a name="l01174"></a>01174 
<a name="l01175"></a>01175         <span class="keywordflow">if</span> (i == libcfs_nnetstrfns)
<a name="l01176"></a>01176                 <span class="keywordflow">return</span> NULL;
<a name="l01177"></a>01177 
<a name="l01178"></a>01178         nob = strlen(nf-&gt;<a class="code" href="structnetstrfns.html#a619d5d948a5782bd5a0d94d12781433d">nf_name</a>);
<a name="l01179"></a>01179 
<a name="l01180"></a>01180         <span class="keywordflow">if</span> (strlen(str) == (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)nob) {
<a name="l01181"></a>01181                 netnum = 0;
<a name="l01182"></a>01182         } <span class="keywordflow">else</span> {
<a name="l01183"></a>01183                 <span class="keywordflow">if</span> (nf-&gt;<a class="code" href="structnetstrfns.html#aa6b63c720ed7ed94973f37fe9a287f40">nf_type</a> == <a class="code" href="nidstr_8h.html#afb9b21dcb0b6eb4e9e0c9cb090e774beab2569f8547a3ef45663982f966cd9458">LOLND</a>) <span class="comment">/* net number not allowed */</span>
<a name="l01184"></a>01184                         <span class="keywordflow">return</span> NULL;
<a name="l01185"></a>01185 
<a name="l01186"></a>01186                 str += nob;
<a name="l01187"></a>01187                 i = strlen(str);
<a name="l01188"></a>01188                 <span class="keywordflow">if</span> (sscanf(str, <span class="stringliteral">&quot;%u%n&quot;</span>, &amp;netnum, &amp;i) &lt; 1 ||
<a name="l01189"></a>01189                     i != (<span class="keywordtype">int</span>)strlen(str))
<a name="l01190"></a>01190                         <span class="keywordflow">return</span> NULL;
<a name="l01191"></a>01191         }
<a name="l01192"></a>01192 
<a name="l01193"></a>01193         *net = <a class="code" href="group__lnet__addr.html#ga664629710c7e7bf96661b4a3d4300e96">LNET_MKNET</a>(nf-&gt;<a class="code" href="structnetstrfns.html#aa6b63c720ed7ed94973f37fe9a287f40">nf_type</a>, netnum);
<a name="l01194"></a>01194         <span class="keywordflow">return</span> nf;
<a name="l01195"></a>01195 }
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 __u32
<a name="l01198"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a96425c6dbd6d6f2f5d4d299e50c75cf4">01198</a> <a class="code" href="nidstr_8h.html#a96425c6dbd6d6f2f5d4d299e50c75cf4">libcfs_str2net</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l01199"></a>01199 {
<a name="l01200"></a>01200         __u32  net;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202         <span class="keywordflow">if</span> (<a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3440cdba7492dc1e57acc7f82ac2e5b4">libcfs_str2net_internal</a>(str, &amp;net) != NULL)
<a name="l01203"></a>01203                 <span class="keywordflow">return</span> net;
<a name="l01204"></a>01204 
<a name="l01205"></a>01205         <span class="keywordflow">return</span> <a class="code" href="group__lnet__addr.html#gabf536c21b8f5226eadf3a124a265ee3b">LNET_NIDNET</a>(<a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>);
<a name="l01206"></a>01206 }
<a name="l01207"></a>01207 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#a96425c6dbd6d6f2f5d4d299e50c75cf4">libcfs_str2net</a>);
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>
<a name="l01210"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#aa3843a47ded8303f0352e33b5d009bee">01210</a> <a class="code" href="nidstr_8h.html#aa3843a47ded8303f0352e33b5d009bee">libcfs_str2nid</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l01211"></a>01211 {
<a name="l01212"></a>01212         <span class="keyword">const</span> <span class="keywordtype">char</span>       *sep = strchr(str, <span class="charliteral">&apos;@&apos;</span>);
<a name="l01213"></a>01213         <span class="keyword">struct </span><a class="code" href="structnetstrfns.html">netstrfns</a> *nf;
<a name="l01214"></a>01214         __u32             net;
<a name="l01215"></a>01215         __u32             addr;
<a name="l01216"></a>01216 
<a name="l01217"></a>01217         <span class="keywordflow">if</span> (sep != NULL) {
<a name="l01218"></a>01218                 nf = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a3440cdba7492dc1e57acc7f82ac2e5b4">libcfs_str2net_internal</a>(sep + 1, &amp;net);
<a name="l01219"></a>01219                 <span class="keywordflow">if</span> (nf == NULL)
<a name="l01220"></a>01220                         <span class="keywordflow">return</span> <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>;
<a name="l01221"></a>01221         } <span class="keywordflow">else</span> {
<a name="l01222"></a>01222                 sep = str + strlen(str);
<a name="l01223"></a>01223                 net = <a class="code" href="group__lnet__addr.html#ga664629710c7e7bf96661b4a3d4300e96">LNET_MKNET</a>(<a class="code" href="nidstr_8h.html#afb9b21dcb0b6eb4e9e0c9cb090e774bea7712f2834e8e9ff044c86fe04c5d8d39">SOCKLND</a>, 0);
<a name="l01224"></a>01224                 nf = <a class="code" href="lnet_2lnet_2nidstrings_8c.html#a4dbadeb3bf735772361eb1db1374553e">libcfs_lnd2netstrfns</a>(<a class="code" href="nidstr_8h.html#afb9b21dcb0b6eb4e9e0c9cb090e774bea7712f2834e8e9ff044c86fe04c5d8d39">SOCKLND</a>);
<a name="l01225"></a>01225                 <a class="code" href="utils_2wirehdr_8c.html#a40eabc293a68a6404ce1de507c99c4b5">LASSERT</a>(nf != NULL);
<a name="l01226"></a>01226         }
<a name="l01227"></a>01227 
<a name="l01228"></a>01228         <span class="keywordflow">if</span> (!nf-&gt;<a class="code" href="structnetstrfns.html#a391360a6023b06a3b6933a84e80429b6">nf_str2addr</a>(str, (<span class="keywordtype">int</span>)(sep - str), &amp;addr))
<a name="l01229"></a>01229                 <span class="keywordflow">return</span> <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>;
<a name="l01230"></a>01230 
<a name="l01231"></a>01231         <span class="keywordflow">return</span> <a class="code" href="group__lnet__addr.html#gacab9a4d9fd8480776bef52653af50be3">LNET_MKNID</a>(net, addr);
<a name="l01232"></a>01232 }
<a name="l01233"></a>01233 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#aa3843a47ded8303f0352e33b5d009bee">libcfs_str2nid</a>);
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 <span class="keywordtype">char</span> *
<a name="l01236"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#ab0b294c710b89667647c7636e7e4d519">01236</a> <a class="code" href="nidstr_8h.html#ab0b294c710b89667647c7636e7e4d519">libcfs_id2str</a>(<a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a> <span class="keywordtype">id</span>)
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238         <span class="keywordtype">char</span> *str = <a class="code" href="nidstr_8h.html#a91bf85bd084c5a8bc80c53e7b1d2305a">libcfs_next_nidstring</a>();
<a name="l01239"></a>01239 
<a name="l01240"></a>01240         <span class="keywordflow">if</span> (<span class="keywordtype">id</span>.pid == <a class="code" href="group__lnet__addr.html#ga048843ee9085f3c7dab16554a040f791" title="wildcard PID that matches any lnet_pid_t">LNET_PID_ANY</a>) {
<a name="l01241"></a>01241                 snprintf(str, <a class="code" href="nidstr_8h.html#a3204219a0a99b43920e3f9cdd5446459">LNET_NIDSTR_SIZE</a>,
<a name="l01242"></a>01242                          <span class="stringliteral">&quot;LNET_PID_ANY-%s&quot;</span>, <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(<span class="keywordtype">id</span>.nid));
<a name="l01243"></a>01243                 <span class="keywordflow">return</span> str;
<a name="l01244"></a>01244         }
<a name="l01245"></a>01245 
<a name="l01246"></a>01246         snprintf(str, <a class="code" href="nidstr_8h.html#a3204219a0a99b43920e3f9cdd5446459">LNET_NIDSTR_SIZE</a>, <span class="stringliteral">&quot;%s%u-%s&quot;</span>,
<a name="l01247"></a>01247                  ((<span class="keywordtype">id</span>.pid &amp; <a class="code" href="group__lnet__addr.html#ga419649526d652fb587ed39e554045384">LNET_PID_USERFLAG</a>) != 0) ? <span class="stringliteral">&quot;U&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l01248"></a>01248                  (<span class="keywordtype">id</span>.pid &amp; ~LNET_PID_USERFLAG), <a class="code" href="nidstr_8h.html#ada87bd30bf737eb0f07cd208ba08d73d">libcfs_nid2str</a>(<span class="keywordtype">id</span>.nid));
<a name="l01249"></a>01249         <span class="keywordflow">return</span> str;
<a name="l01250"></a>01250 }
<a name="l01251"></a>01251 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#ab0b294c710b89667647c7636e7e4d519">libcfs_id2str</a>);
<a name="l01252"></a>01252 
<a name="l01253"></a>01253 <span class="keywordtype">int</span>
<a name="l01254"></a><a class="code" href="lnet_2lnet_2nidstrings_8c.html#a6f39a5422879c7c07495d4d012f49e80">01254</a> <a class="code" href="nidstr_8h.html#ae24c1de9166410125ea86a5d013c909a">libcfs_str2anynid</a>(<a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> *nidp, <span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l01255"></a>01255 {
<a name="l01256"></a>01256         <span class="keywordflow">if</span> (!strcmp(str, <span class="stringliteral">&quot;*&quot;</span>)) {
<a name="l01257"></a>01257                 *nidp = <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>;
<a name="l01258"></a>01258                 <span class="keywordflow">return</span> 1;
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261         *nidp = <a class="code" href="nidstr_8h.html#aa3843a47ded8303f0352e33b5d009bee">libcfs_str2nid</a>(str);
<a name="l01262"></a>01262         <span class="keywordflow">return</span> *nidp != <a class="code" href="group__lnet__addr.html#gaf07699e7475f5357f581c00afeaaa1d7" title="wildcard NID that matches any end-point address">LNET_NID_ANY</a>;
<a name="l01263"></a>01263 }
<a name="l01264"></a>01264 EXPORT_SYMBOL(<a class="code" href="nidstr_8h.html#ae24c1de9166410125ea86a5d013c909a">libcfs_str2anynid</a>);
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:34 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
