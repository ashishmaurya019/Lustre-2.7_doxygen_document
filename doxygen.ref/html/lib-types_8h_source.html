<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lnet/include/lnet/lib-types.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>lnet/include/lnet/lib-types.h</h1><a href="lib-types_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * GPL HEADER START</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License version 2 only,</span>
<a name="l00008"></a>00008 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00011"></a>00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00013"></a>00013 <span class="comment"> * General Public License version 2 for more details (a copy is included</span>
<a name="l00014"></a>00014 <span class="comment"> * in the LICENSE file that accompanied this code).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * version 2 along with this program; If not, see</span>
<a name="l00018"></a>00018 <span class="comment"> * http://www.sun.com/software/products/lustre/docs/GPLv2.pdf</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,</span>
<a name="l00021"></a>00021 <span class="comment"> * CA 95054 USA or visit www.sun.com if you need additional information or</span>
<a name="l00022"></a>00022 <span class="comment"> * have any questions.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * GPL HEADER END</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00028"></a>00028 <span class="comment"> * Use is subject to license terms.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 2012, 2015, Intel Corporation.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> * This file is part of Lustre, http://www.lustre.org/</span>
<a name="l00034"></a>00034 <span class="comment"> * Lustre is a trademark of Sun Microsystems, Inc.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * lnet/include/lnet/lib-types.h</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * Types used by the library side routines that do not need to be</span>
<a name="l00039"></a>00039 <span class="comment"> * exposed to the user application</span>
<a name="l00040"></a>00040 <span class="comment"> */</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#ifndef __LNET_LIB_TYPES_H__</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define __LNET_LIB_TYPES_H__</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="preprocessor">#ifndef __KERNEL__</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor"># error This include is only for kernel use.</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;linux/kthread.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;linux/uio.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;linux/types.h&gt;</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;<a class="code" href="lnetctl_8h.html">lnet/lnetctl.h</a>&gt;</span>
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">/* Max payload size */</span>
<a name="l00056"></a>00056 <span class="preprocessor">#ifndef CONFIG_LNET_MAX_PAYLOAD</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor"># error &quot;CONFIG_LNET_MAX_PAYLOAD must be defined in config.h&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a><a class="code" href="lib-types_8h.html#ae4a0852c4a11faf9ee8dcf3d25557f1f">00060</a> <span class="preprocessor">#define LNET_MAX_PAYLOAD       CONFIG_LNET_MAX_PAYLOAD</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#if (LNET_MAX_PAYLOAD &lt; LNET_MTU)</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor"># error &quot;LNET_MAX_PAYLOAD too small - error in configure --with-max-payload-mb&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#elif (LNET_MAX_PAYLOAD &gt; (PAGE_SIZE * LNET_MAX_IOV))</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor"># error &quot;LNET_MAX_PAYLOAD too large - error in configure --with-max-payload-mb&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span>
<a name="l00067"></a>00067 <span class="comment">/* forward refs */</span>
<a name="l00068"></a>00068 <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a>;
<a name="l00069"></a>00069 
<a name="l00070"></a><a class="code" href="structlnet__msg.html">00070</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__msg.html">lnet_msg</a> {
<a name="l00071"></a><a class="code" href="structlnet__msg.html#adfda1fb437097bc0181caec654fdeee1">00071</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__msg.html#adfda1fb437097bc0181caec654fdeee1">msg_activelist</a>;
<a name="l00072"></a><a class="code" href="structlnet__msg.html#ab04413e3c8ebd8a0501b999e5e412bb2">00072</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__msg.html#ab04413e3c8ebd8a0501b999e5e412bb2">msg_list</a>;       <span class="comment">/* Q for credits/MD */</span>
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="structlnet__msg.html#a3eae88b8bca4af9b435568e8312d141e">00074</a>         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>       <a class="code" href="structlnet__msg.html#a3eae88b8bca4af9b435568e8312d141e">msg_target</a>;
<a name="l00075"></a>00075         <span class="comment">/* where is it from, it&apos;s only for building event */</span>
<a name="l00076"></a><a class="code" href="structlnet__msg.html#aac24c1658dfb31092ec509a80369880a">00076</a>         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>              <a class="code" href="structlnet__msg.html#aac24c1658dfb31092ec509a80369880a">msg_from</a>;
<a name="l00077"></a><a class="code" href="structlnet__msg.html#a1a2220c5785595da6fafe1fa63dc5761">00077</a>         __u32                   <a class="code" href="structlnet__msg.html#a1a2220c5785595da6fafe1fa63dc5761">msg_type</a>;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079         <span class="comment">/* committed for sending */</span>
<a name="l00080"></a><a class="code" href="structlnet__msg.html#a4bda7881614f903a6c88218a517e7ffa">00080</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__msg.html#a4bda7881614f903a6c88218a517e7ffa">msg_tx_committed</a>:1;
<a name="l00081"></a>00081         <span class="comment">/* CPT # this message committed for sending */</span>
<a name="l00082"></a><a class="code" href="structlnet__msg.html#ae388dcf0a0635375e35670a2c44b9182">00082</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__msg.html#ae388dcf0a0635375e35670a2c44b9182">msg_tx_cpt</a>:15;
<a name="l00083"></a>00083         <span class="comment">/* committed for receiving */</span>
<a name="l00084"></a><a class="code" href="structlnet__msg.html#ac45d270c7c5418f76c8cc9f48f0e34e8">00084</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__msg.html#ac45d270c7c5418f76c8cc9f48f0e34e8">msg_rx_committed</a>:1;
<a name="l00085"></a>00085         <span class="comment">/* CPT # this message committed for receiving */</span>
<a name="l00086"></a><a class="code" href="structlnet__msg.html#a9f9999b1d63d45e925f2b3e49183818b">00086</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__msg.html#a9f9999b1d63d45e925f2b3e49183818b">msg_rx_cpt</a>:15;
<a name="l00087"></a>00087         <span class="comment">/* queued for tx credit */</span>
<a name="l00088"></a><a class="code" href="structlnet__msg.html#abf89293de164fb8117bec0e5f559e181">00088</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__msg.html#abf89293de164fb8117bec0e5f559e181">msg_tx_delayed</a>:1;
<a name="l00089"></a>00089         <span class="comment">/* queued for RX buffer */</span>
<a name="l00090"></a><a class="code" href="structlnet__msg.html#a7fbd8a57eed82128f2970b92b8e0bbfd">00090</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__msg.html#a7fbd8a57eed82128f2970b92b8e0bbfd">msg_rx_delayed</a>:1;
<a name="l00091"></a>00091         <span class="comment">/* ready for pending on RX delay list */</span>
<a name="l00092"></a><a class="code" href="structlnet__msg.html#a3fc305af37b165fed6ac114fb01993a7">00092</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__msg.html#a3fc305af37b165fed6ac114fb01993a7">msg_rx_ready_delay</a>:1;
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="structlnet__msg.html#a76f7989dadedb9368546af4463f02558">00094</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a76f7989dadedb9368546af4463f02558">msg_vmflush</a>:1;      <span class="comment">/* VM trying to free memory */</span>
<a name="l00095"></a><a class="code" href="structlnet__msg.html#a4c3173920184837e4b72a8e278200654">00095</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a4c3173920184837e4b72a8e278200654">msg_target_is_router</a>:1; <span class="comment">/* sending to a router */</span>
<a name="l00096"></a><a class="code" href="structlnet__msg.html#aa642f0a4705c40e9b29d6406a919ca7a">00096</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#aa642f0a4705c40e9b29d6406a919ca7a">msg_routing</a>:1;      <span class="comment">/* being forwarded */</span>
<a name="l00097"></a><a class="code" href="structlnet__msg.html#abb28b77727918bc3b31bc748e3d765a0">00097</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#abb28b77727918bc3b31bc748e3d765a0">msg_ack</a>:1;          <span class="comment">/* ack on finalize (PUT) */</span>
<a name="l00098"></a><a class="code" href="structlnet__msg.html#a41320014d9be6345e4a7eb105ed05e59">00098</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a41320014d9be6345e4a7eb105ed05e59">msg_sending</a>:1;      <span class="comment">/* outgoing message */</span>
<a name="l00099"></a><a class="code" href="structlnet__msg.html#a415d2315128d39187a82e16f84a36154">00099</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a415d2315128d39187a82e16f84a36154">msg_receiving</a>:1;    <span class="comment">/* being received */</span>
<a name="l00100"></a><a class="code" href="structlnet__msg.html#aa578ee3a86598e4b723ab71a76dd7f43">00100</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#aa578ee3a86598e4b723ab71a76dd7f43">msg_txcredit</a>:1;     <span class="comment">/* taken an NI send credit */</span>
<a name="l00101"></a><a class="code" href="structlnet__msg.html#a864024acc129bf8b4c9a9ce028e25d04">00101</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a864024acc129bf8b4c9a9ce028e25d04">msg_peertxcredit</a>:1; <span class="comment">/* taken a peer send credit */</span>
<a name="l00102"></a><a class="code" href="structlnet__msg.html#a647755a676c11eb9d28f71ba355ff446">00102</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a647755a676c11eb9d28f71ba355ff446">msg_rtrcredit</a>:1;    <span class="comment">/* taken a globel router credit */</span>
<a name="l00103"></a><a class="code" href="structlnet__msg.html#a87d1233d181c828436e1c6eb3d31f030">00103</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a87d1233d181c828436e1c6eb3d31f030">msg_peerrtrcredit</a>:1; <span class="comment">/* taken a peer router credit */</span>
<a name="l00104"></a><a class="code" href="structlnet__msg.html#a91dc999a8d001c652512c813f961f9d4">00104</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a91dc999a8d001c652512c813f961f9d4">msg_onactivelist</a>:1; <span class="comment">/* on the activelist */</span>
<a name="l00105"></a><a class="code" href="structlnet__msg.html#ae83c704965e6dc40020decd687fb55a7">00105</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#ae83c704965e6dc40020decd687fb55a7">msg_rdma_get</a>:1;
<a name="l00106"></a>00106 
<a name="l00107"></a><a class="code" href="structlnet__msg.html#aa7f67e8e6a6ffa128492393329f4c65d">00107</a>         <span class="keyword">struct </span><a class="code" href="structlnet__peer.html">lnet_peer</a>     *<a class="code" href="structlnet__msg.html#aa7f67e8e6a6ffa128492393329f4c65d">msg_txpeer</a>;         <span class="comment">/* peer I&apos;m sending to */</span>
<a name="l00108"></a><a class="code" href="structlnet__msg.html#a334a85b2cc08787019c15d05b17917b0">00108</a>         <span class="keyword">struct </span><a class="code" href="structlnet__peer.html">lnet_peer</a>     *<a class="code" href="structlnet__msg.html#a334a85b2cc08787019c15d05b17917b0">msg_rxpeer</a>;         <span class="comment">/* peer I received from */</span>
<a name="l00109"></a>00109 
<a name="l00110"></a><a class="code" href="structlnet__msg.html#a3390a9237c9998322bac0d502489ff2f">00110</a>         <span class="keywordtype">void</span>                 *<a class="code" href="structlnet__msg.html#a3390a9237c9998322bac0d502489ff2f">msg_private</a>;
<a name="l00111"></a><a class="code" href="structlnet__msg.html#a9fd985ea127346aaf96a8be81fa4c5cf">00111</a>         <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a>    *<a class="code" href="structlnet__msg.html#a9fd985ea127346aaf96a8be81fa4c5cf">msg_md</a>;
<a name="l00112"></a>00112 
<a name="l00113"></a><a class="code" href="structlnet__msg.html#a531290c08c788260e8b03361248b7a85">00113</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a531290c08c788260e8b03361248b7a85">msg_len</a>;
<a name="l00114"></a><a class="code" href="structlnet__msg.html#a6a598e4f9f9bb0c9141c6214132468fe">00114</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a6a598e4f9f9bb0c9141c6214132468fe">msg_wanted</a>;
<a name="l00115"></a><a class="code" href="structlnet__msg.html#a32efa47936ed2a61597a6cc4e4dadab6">00115</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a32efa47936ed2a61597a6cc4e4dadab6">msg_offset</a>;
<a name="l00116"></a><a class="code" href="structlnet__msg.html#a6a88c3961801b52ea58ed834de777216">00116</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          <a class="code" href="structlnet__msg.html#a6a88c3961801b52ea58ed834de777216">msg_niov</a>;
<a name="l00117"></a><a class="code" href="structlnet__msg.html#a39654ad4cfa54b0f9ee515442cd53292">00117</a>         <span class="keyword">struct </span>kvec          *<a class="code" href="structlnet__msg.html#a39654ad4cfa54b0f9ee515442cd53292">msg_iov</a>;
<a name="l00118"></a><a class="code" href="structlnet__msg.html#a171b36cbd86ade754afa1124bc67ded4">00118</a>         <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a>          *<a class="code" href="structlnet__msg.html#a171b36cbd86ade754afa1124bc67ded4">msg_kiov</a>;
<a name="l00119"></a>00119 
<a name="l00120"></a><a class="code" href="structlnet__msg.html#a9f6b2c6aaf2f89240cc1cc0ec6c48699">00120</a>         <a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>          <a class="code" href="structlnet__msg.html#a9f6b2c6aaf2f89240cc1cc0ec6c48699">msg_ev</a>;
<a name="l00121"></a><a class="code" href="structlnet__msg.html#a9c5310e3e391a46dc5d1b500f6ab85c5">00121</a>         lnet_hdr_t            <a class="code" href="structlnet__msg.html#a9c5310e3e391a46dc5d1b500f6ab85c5">msg_hdr</a>;
<a name="l00122"></a>00122 } <a class="code" href="structlnet__msg.html">lnet_msg_t</a>;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 
<a name="l00125"></a><a class="code" href="structlnet__libhandle.html">00125</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__libhandle.html">lnet_libhandle</a> {
<a name="l00126"></a><a class="code" href="structlnet__libhandle.html#a32799022375291467c1a98fe0751b0ea">00126</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__libhandle.html#a32799022375291467c1a98fe0751b0ea">lh_hash_chain</a>;
<a name="l00127"></a><a class="code" href="structlnet__libhandle.html#a6100b66a5a6404b9112c2d186ab63cf8">00127</a>         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                   <a class="code" href="structlnet__libhandle.html#a6100b66a5a6404b9112c2d186ab63cf8">lh_cookie</a>;
<a name="l00128"></a>00128 } <a class="code" href="structlnet__libhandle.html">lnet_libhandle_t</a>;
<a name="l00129"></a>00129 
<a name="l00130"></a><a class="code" href="lib-types_8h.html#a2ed4466401e1844b887817d2bdd4e602">00130</a> <span class="preprocessor">#define lh_entry(ptr, type, member) \</span>
<a name="l00131"></a>00131 <span class="preprocessor">        ((type *)((char *)(ptr)-(char *)(&amp;((type *)0)-&gt;member)))</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>
<a name="l00133"></a><a class="code" href="structlnet__eq.html">00133</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__eq.html">lnet_eq</a> {
<a name="l00134"></a><a class="code" href="structlnet__eq.html#a5fef04742ac7b28339f13e26a7fde453">00134</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__eq.html#a5fef04742ac7b28339f13e26a7fde453">eq_list</a>;
<a name="l00135"></a><a class="code" href="structlnet__eq.html#ac54e3d4df0572e9617f7c806091be0f8">00135</a>         <a class="code" href="structlnet__libhandle.html">lnet_libhandle_t</a>        <a class="code" href="structlnet__eq.html#ac54e3d4df0572e9617f7c806091be0f8">eq_lh</a>;
<a name="l00136"></a><a class="code" href="structlnet__eq.html#ad01c5ac3a9392f586722afd13bb6d3d1">00136</a>         <a class="code" href="group__lnet__eq.html#gaa852e678ebaca5da7e2de48b659e50a6">lnet_seq_t</a>              <a class="code" href="structlnet__eq.html#ad01c5ac3a9392f586722afd13bb6d3d1">eq_enq_seq</a>;
<a name="l00137"></a><a class="code" href="structlnet__eq.html#a055350e302f5082d2950d4673a37cde1">00137</a>         <a class="code" href="group__lnet__eq.html#gaa852e678ebaca5da7e2de48b659e50a6">lnet_seq_t</a>              <a class="code" href="structlnet__eq.html#a055350e302f5082d2950d4673a37cde1">eq_deq_seq</a>;
<a name="l00138"></a><a class="code" href="structlnet__eq.html#a9887ff204fae1bd5859e2529a2e4754a">00138</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__eq.html#a9887ff204fae1bd5859e2529a2e4754a">eq_size</a>;
<a name="l00139"></a><a class="code" href="structlnet__eq.html#a3af67a2baa4f21fef3a789101e50aaa9">00139</a>         <a class="code" href="group__lnet__eq.html#ga79dedea26148b7a6e911c83996f7ae2e" title="Event queue handler function type.">lnet_eq_handler_t</a>       <a class="code" href="structlnet__eq.html#a3af67a2baa4f21fef3a789101e50aaa9">eq_callback</a>;
<a name="l00140"></a><a class="code" href="structlnet__eq.html#a50d5d03e415bf0198ebb049f987cb4b2">00140</a>         <a class="code" href="structlnet__event__t.html" title="Information about an event on a MD.">lnet_event_t</a>            *<a class="code" href="structlnet__eq.html#a50d5d03e415bf0198ebb049f987cb4b2">eq_events</a>;
<a name="l00141"></a><a class="code" href="structlnet__eq.html#a1822344950a4efe943edf8681bd4feb3">00141</a>         <span class="keywordtype">int</span>                     **<a class="code" href="structlnet__eq.html#a1822344950a4efe943edf8681bd4feb3">eq_refs</a>;      <span class="comment">/* percpt refcount for EQ */</span>
<a name="l00142"></a>00142 } <a class="code" href="structlnet__eq.html">lnet_eq_t</a>;
<a name="l00143"></a>00143 
<a name="l00144"></a><a class="code" href="structlnet__me.html">00144</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__me.html">lnet_me</a> {
<a name="l00145"></a><a class="code" href="structlnet__me.html#a23d2c629484fa58ba06c3e18920c0201">00145</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__me.html#a23d2c629484fa58ba06c3e18920c0201">me_list</a>;
<a name="l00146"></a><a class="code" href="structlnet__me.html#aced5499a649234e2e155192162eb4f0f">00146</a>         <a class="code" href="structlnet__libhandle.html">lnet_libhandle_t</a>        <a class="code" href="structlnet__me.html#aced5499a649234e2e155192162eb4f0f">me_lh</a>;
<a name="l00147"></a><a class="code" href="structlnet__me.html#a7d897dee73d84cba5419194058a696c2">00147</a>         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>       <a class="code" href="structlnet__me.html#a7d897dee73d84cba5419194058a696c2">me_match_id</a>;
<a name="l00148"></a><a class="code" href="structlnet__me.html#a37db8c02043614eb31f25ab99c3362d1">00148</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__me.html#a37db8c02043614eb31f25ab99c3362d1">me_portal</a>;
<a name="l00149"></a><a class="code" href="structlnet__me.html#a50ca06d781ae97c1bd09d5869df6a9a1">00149</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__me.html#a50ca06d781ae97c1bd09d5869df6a9a1">me_pos</a>;         <span class="comment">/* hash offset in mt_hash */</span>
<a name="l00150"></a><a class="code" href="structlnet__me.html#aa856aa7a667283de72aa75840b92a029">00150</a>         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                   <a class="code" href="structlnet__me.html#aa856aa7a667283de72aa75840b92a029">me_match_bits</a>;
<a name="l00151"></a><a class="code" href="structlnet__me.html#a3e06ce06c8a74576a59a817a7db76633">00151</a>         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                   <a class="code" href="structlnet__me.html#a3e06ce06c8a74576a59a817a7db76633">me_ignore_bits</a>;
<a name="l00152"></a><a class="code" href="structlnet__me.html#a5334b232d3a236a960c8c11a0741b279">00152</a>         <a class="code" href="group__lnet__me.html#gac82673f6f990f95b569ecc7fa9c738b9" title="Specifies whether the match entry or memory descriptor should be unlinked automatically...">lnet_unlink_t</a>           <a class="code" href="structlnet__me.html#a5334b232d3a236a960c8c11a0741b279">me_unlink</a>;
<a name="l00153"></a><a class="code" href="structlnet__me.html#a366f47f68c49d1e30eb0d4f82c55b781">00153</a>         <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a>      *<a class="code" href="structlnet__me.html#a366f47f68c49d1e30eb0d4f82c55b781">me_md</a>;
<a name="l00154"></a>00154 } <a class="code" href="structlnet__me.html">lnet_me_t</a>;
<a name="l00155"></a>00155 
<a name="l00156"></a><a class="code" href="structlnet__libmd.html">00156</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__libmd.html">lnet_libmd</a> {
<a name="l00157"></a><a class="code" href="structlnet__libmd.html#a4b416688f76cad018d05d9c114efadde">00157</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__libmd.html#a4b416688f76cad018d05d9c114efadde">md_list</a>;
<a name="l00158"></a><a class="code" href="structlnet__libmd.html#a798ab2f4e58cf8105143c3f6f0d0c63d">00158</a>         <a class="code" href="structlnet__libhandle.html">lnet_libhandle_t</a>        <a class="code" href="structlnet__libmd.html#a798ab2f4e58cf8105143c3f6f0d0c63d">md_lh</a>;
<a name="l00159"></a><a class="code" href="structlnet__libmd.html#a501ffcdf120f0b75d67c159fc0b4c4bf">00159</a>         <a class="code" href="structlnet__me.html">lnet_me_t</a>              *<a class="code" href="structlnet__libmd.html#a501ffcdf120f0b75d67c159fc0b4c4bf">md_me</a>;
<a name="l00160"></a><a class="code" href="structlnet__libmd.html#a30f3d25f07c7223d47e6b022ffa42bab">00160</a>         <span class="keywordtype">char</span>                   *<a class="code" href="structlnet__libmd.html#a30f3d25f07c7223d47e6b022ffa42bab">md_start</a>;
<a name="l00161"></a><a class="code" href="structlnet__libmd.html#adb24e275d106265021b78e759ecbeaf7">00161</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__libmd.html#adb24e275d106265021b78e759ecbeaf7">md_offset</a>;
<a name="l00162"></a><a class="code" href="structlnet__libmd.html#af69c046f9f1bc2ed36aba12c45af33d5">00162</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__libmd.html#af69c046f9f1bc2ed36aba12c45af33d5">md_length</a>;
<a name="l00163"></a><a class="code" href="structlnet__libmd.html#af8ba863e9da6cad6d871aa3676126d9e">00163</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__libmd.html#af8ba863e9da6cad6d871aa3676126d9e">md_max_size</a>;
<a name="l00164"></a><a class="code" href="structlnet__libmd.html#ab9b726f426a7d3e7e88a44f2d7558e57">00164</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__libmd.html#ab9b726f426a7d3e7e88a44f2d7558e57">md_threshold</a>;
<a name="l00165"></a><a class="code" href="structlnet__libmd.html#adf9a3416433fbb85d990dd49dc794c6c">00165</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__libmd.html#adf9a3416433fbb85d990dd49dc794c6c">md_refcount</a>;
<a name="l00166"></a><a class="code" href="structlnet__libmd.html#aa09a904a9db90a4a47acc06d108827c1">00166</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__libmd.html#aa09a904a9db90a4a47acc06d108827c1">md_options</a>;
<a name="l00167"></a><a class="code" href="structlnet__libmd.html#a4aa4f6002ac5a4a2d195872c02942473">00167</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__libmd.html#a4aa4f6002ac5a4a2d195872c02942473">md_flags</a>;
<a name="l00168"></a><a class="code" href="structlnet__libmd.html#ad8f4081216a793191fda6fa3d727b6cb">00168</a>         <span class="keywordtype">void</span>                   *<a class="code" href="structlnet__libmd.html#ad8f4081216a793191fda6fa3d727b6cb">md_user_ptr</a>;
<a name="l00169"></a><a class="code" href="structlnet__libmd.html#a9253038399b3eb3498f1305eb7114ea5">00169</a>         <a class="code" href="structlnet__eq.html">lnet_eq_t</a>              *<a class="code" href="structlnet__libmd.html#a9253038399b3eb3498f1305eb7114ea5">md_eq</a>;
<a name="l00170"></a><a class="code" href="structlnet__libmd.html#aafac482671fdf9f30797855b8256cc2c">00170</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__libmd.html#aafac482671fdf9f30797855b8256cc2c">md_niov</a>;        <span class="comment">/* # frags */</span>
<a name="l00171"></a>00171         <span class="keyword">union </span>{
<a name="l00172"></a><a class="code" href="structlnet__libmd.html#a8b3bd46f19557b0307e8005f783505f6">00172</a>                 <span class="keyword">struct </span>kvec     <a class="code" href="structlnet__libmd.html#a8b3bd46f19557b0307e8005f783505f6">iov</a>[<a class="code" href="group__lnet__md.html#gae5c5481fe02371e7bf253b2b1cf0d030" title="limit on the number of fragments in discontiguous MDs">LNET_MAX_IOV</a>];
<a name="l00173"></a><a class="code" href="structlnet__libmd.html#a04711966d3775c15b6f93d97d5082dac">00173</a>                 <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a>     <a class="code" href="structlnet__libmd.html#a04711966d3775c15b6f93d97d5082dac">kiov</a>[<a class="code" href="group__lnet__md.html#gae5c5481fe02371e7bf253b2b1cf0d030" title="limit on the number of fragments in discontiguous MDs">LNET_MAX_IOV</a>];
<a name="l00174"></a>00174         } <a class="code" href="structlnet__libmd.html#ab7e8a58580335a101b009e5d86ab0b5c">md_iov</a>;
<a name="l00175"></a>00175 } <a class="code" href="structlnet__libmd.html">lnet_libmd_t</a>;
<a name="l00176"></a>00176 
<a name="l00177"></a><a class="code" href="lib-types_8h.html#a2c5b7452e731f04cf4a39518fb5aa084">00177</a> <span class="preprocessor">#define LNET_MD_FLAG_ZOMBIE      (1 &lt;&lt; 0)</span>
<a name="l00178"></a><a class="code" href="lib-types_8h.html#a539da9394199673b9037c55288dabde1">00178</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_MD_FLAG_AUTO_UNLINK (1 &lt;&lt; 1)</span>
<a name="l00179"></a><a class="code" href="lib-types_8h.html#a48ed55bf9ce511ae2d6d4a2d3dc05181">00179</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_MD_FLAG_ABORTED     (1 &lt;&lt; 2)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span>
<a name="l00181"></a><a class="code" href="structlnet__test__peer__t.html">00181</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00182"></a>00182         <span class="comment">/* info about peers we are trying to fail */</span>
<a name="l00183"></a><a class="code" href="structlnet__test__peer__t.html#a6aab8ba25328d8eaa30b207720e71775">00183</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        tp_list;        <span class="comment">/* ln_test_peers */</span>
<a name="l00184"></a><a class="code" href="structlnet__test__peer__t.html#afa3c7fde48230e1f1507d2f7482fd9f9">00184</a>         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>              tp_nid;         <span class="comment">/* matching nid */</span>
<a name="l00185"></a><a class="code" href="structlnet__test__peer__t.html#a0d203e64e31ae4c2bf0bd123d7f24d43">00185</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            tp_threshold;   <span class="comment">/* # failures to simulate */</span>
<a name="l00186"></a>00186 } <a class="code" href="structlnet__test__peer__t.html">lnet_test_peer_t</a>;
<a name="l00187"></a>00187 
<a name="l00188"></a><a class="code" href="lib-types_8h.html#a53130aa68d868b953a3505222b38735f">00188</a> <span class="preprocessor">#define LNET_COOKIE_TYPE_MD    1</span>
<a name="l00189"></a><a class="code" href="lib-types_8h.html#ac8379636a5de8747f3f602db3832700a">00189</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_COOKIE_TYPE_ME    2</span>
<a name="l00190"></a><a class="code" href="lib-types_8h.html#a78215653e1db51f1bd7f4d900d4dcc60">00190</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_COOKIE_TYPE_EQ    3</span>
<a name="l00191"></a><a class="code" href="lib-types_8h.html#a7296a5cddaf2b8383561621e6c4da8dc">00191</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_COOKIE_TYPE_BITS  2</span>
<a name="l00192"></a><a class="code" href="lib-types_8h.html#a858b384e0b211ef146b905360a38321b">00192</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_COOKIE_MASK        ((1ULL &lt;&lt; LNET_COOKIE_TYPE_BITS) - 1ULL)</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span>
<a name="l00194"></a>00194 <span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a>;                                  <span class="comment">/* forward ref */</span>
<a name="l00195"></a>00195 <span class="keyword">struct </span>socket;
<a name="l00196"></a>00196 
<a name="l00197"></a><a class="code" href="structlnet__lnd.html">00197</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__lnd.html">lnet_lnd</a>
<a name="l00198"></a>00198 {
<a name="l00199"></a>00199         <span class="comment">/* fields managed by portals */</span>
<a name="l00200"></a><a class="code" href="structlnet__lnd.html#a4bd9f666d4fcc92a1208c25474369ae1">00200</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__lnd.html#a4bd9f666d4fcc92a1208c25474369ae1">lnd_list</a>;       <span class="comment">/* stash in the LND table */</span>
<a name="l00201"></a><a class="code" href="structlnet__lnd.html#a5000790382e6ed4738ad7783cd12c60a">00201</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__lnd.html#a5000790382e6ed4738ad7783cd12c60a">lnd_refcount</a>;   <span class="comment">/* # active instances */</span>
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         <span class="comment">/* fields initialized by the LND */</span>
<a name="l00204"></a><a class="code" href="structlnet__lnd.html#a6d26bd32f95d6abaf0c68a16ef0bb876">00204</a>         __u32                   <a class="code" href="structlnet__lnd.html#a6d26bd32f95d6abaf0c68a16ef0bb876">lnd_type</a>;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         int  (*<a class="code" href="structlnet__lnd.html#ab31f3d230d76889bc8706b7d6c504d93">lnd_startup</a>) (<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni);
<a name="l00207"></a>00207         void (*<a class="code" href="structlnet__lnd.html#ac4649e7570d00f6cae19ec3244587e01">lnd_shutdown</a>) (<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni);
<a name="l00208"></a>00208         int  (*<a class="code" href="structlnet__lnd.html#a6e943b70ce8849bf83a9bed37a38d3d9">lnd_ctl</a>)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mdsrate_8c.html#a7353cae57e2530c316ddacb27ef14932">cmd</a>, <span class="keywordtype">void</span> *arg);
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <span class="comment">/* In data movement APIs below, payload buffers are described as a set</span>
<a name="l00211"></a>00211 <span class="comment">         * of &apos;niov&apos; fragments which are...</span>
<a name="l00212"></a>00212 <span class="comment">         * EITHER</span>
<a name="l00213"></a>00213 <span class="comment">         *    in virtual memory (struct kvec *iov != NULL)</span>
<a name="l00214"></a>00214 <span class="comment">         * OR</span>
<a name="l00215"></a>00215 <span class="comment">         *    in pages (kernel only: plt_kiov_t *kiov != NULL).</span>
<a name="l00216"></a>00216 <span class="comment">         * The LND may NOT overwrite these fragment descriptors.</span>
<a name="l00217"></a>00217 <span class="comment">         * An &apos;offset&apos; and may specify a byte offset within the set of</span>
<a name="l00218"></a>00218 <span class="comment">         * fragments to start from</span>
<a name="l00219"></a>00219 <span class="comment">         */</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         <span class="comment">/* Start sending a preformatted message.  &apos;private&apos; is NULL for PUT and</span>
<a name="l00222"></a>00222 <span class="comment">         * GET messages; otherwise this is a response to an incoming message</span>
<a name="l00223"></a>00223 <span class="comment">         * and &apos;private&apos; is the &apos;private&apos; passed to lnet_parse().  Return</span>
<a name="l00224"></a>00224 <span class="comment">         * non-zero for immediate failure, otherwise complete later with</span>
<a name="l00225"></a>00225 <span class="comment">         * lnet_finalize() */</span>
<a name="l00226"></a>00226         int (*<a class="code" href="structlnet__lnd.html#aa4a4203a63572a59a0b9ee5a0c325c1f">lnd_send</a>)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keywordtype">void</span> *<span class="keyword">private</span>, <a class="code" href="structlnet__msg.html">lnet_msg_t</a> *<a class="code" href="multiop_8c.html#afbbc03d010d4a43d0dcc0ef3c41de5ec">msg</a>);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228         <span class="comment">/* Start receiving &apos;mlen&apos; bytes of payload data, skipping the following</span>
<a name="l00229"></a>00229 <span class="comment">         * &apos;rlen&apos; - &apos;mlen&apos; bytes. &apos;private&apos; is the &apos;private&apos; passed to</span>
<a name="l00230"></a>00230 <span class="comment">         * lnet_parse().  Return non-zero for immedaite failure, otherwise</span>
<a name="l00231"></a>00231 <span class="comment">         * complete later with lnet_finalize().  This also gives back a receive</span>
<a name="l00232"></a>00232 <span class="comment">         * credit if the LND does flow control. */</span>
<a name="l00233"></a>00233         int (*<a class="code" href="structlnet__lnd.html#a73dd1b327750961e85472898b2cc5423">lnd_recv</a>)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keywordtype">void</span> *<span class="keyword">private</span>, <a class="code" href="structlnet__msg.html">lnet_msg_t</a> *<a class="code" href="multiop_8c.html#afbbc03d010d4a43d0dcc0ef3c41de5ec">msg</a>,
<a name="l00234"></a>00234                         <span class="keywordtype">int</span> delayed, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> niov,
<a name="l00235"></a>00235                         <span class="keyword">struct </span>kvec *iov, <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a> *kiov,
<a name="l00236"></a>00236                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rlen);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         <span class="comment">/* lnet_parse() has had to delay processing of this message</span>
<a name="l00239"></a>00239 <span class="comment">         * (e.g. waiting for a forwarding buffer or send credits).  Give the</span>
<a name="l00240"></a>00240 <span class="comment">         * LND a chance to free urgently needed resources.  If called, return 0</span>
<a name="l00241"></a>00241 <span class="comment">         * for success and do NOT give back a receive credit; that has to wait</span>
<a name="l00242"></a>00242 <span class="comment">         * until lnd_recv() gets called.  On failure return &lt; 0 and</span>
<a name="l00243"></a>00243 <span class="comment">         * release resources; lnd_recv() will not be called. */</span>
<a name="l00244"></a>00244         int (*<a class="code" href="structlnet__lnd.html#ab9387e583430506e8e277cdcc6c09ebc">lnd_eager_recv</a>)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keywordtype">void</span> *<span class="keyword">private</span>, <a class="code" href="structlnet__msg.html">lnet_msg_t</a> *<a class="code" href="multiop_8c.html#afbbc03d010d4a43d0dcc0ef3c41de5ec">msg</a>,
<a name="l00245"></a>00245                               <span class="keywordtype">void</span> **new_privatep);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         <span class="comment">/* notification of peer health */</span>
<a name="l00248"></a>00248         void (*<a class="code" href="structlnet__lnd.html#a830a44de0dab03bf73f08d887723ad5e">lnd_notify</a>)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> peer, <span class="keywordtype">int</span> alive);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         <span class="comment">/* query of peer aliveness */</span>
<a name="l00251"></a>00251         void (*<a class="code" href="structlnet__lnd.html#a21ddb262251d9a45c03acc60f05d0abd">lnd_query</a>)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> peer, <a class="code" href="linux-time_8h.html#a0e81d053bc8d925f6574c760bbea5ac4">cfs_time_t</a> *when);
<a name="l00252"></a>00252 
<a name="l00253"></a>00253         <span class="comment">/* accept a new connection */</span>
<a name="l00254"></a>00254         int (*<a class="code" href="structlnet__lnd.html#ac1ba4de5344f2eb50700e5f2a5c6a4e1">lnd_accept</a>)(<span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> *ni, <span class="keyword">struct </span>socket *sock);
<a name="l00255"></a>00255 } <a class="code" href="structlnet__lnd.html">lnd_t</a>;
<a name="l00256"></a>00256 
<a name="l00257"></a><a class="code" href="structWIRE__ATTR.html">00257</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00258"></a><a class="code" href="structWIRE__ATTR.html#adac592560d10830327f00f4e15efef3e">00258</a>         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a> ns_nid;
<a name="l00259"></a><a class="code" href="structWIRE__ATTR.html#affd329675bfdecb6a199823845f29e61">00259</a>         __u32      ns_status;
<a name="l00260"></a><a class="code" href="structWIRE__ATTR.html#a2722ce11b95114e4af59721e7dcacb90">00260</a>         __u32      ns_unused;
<a name="l00261"></a>00261 } <a class="code" href="structWIRE__ATTR.html">WIRE_ATTR</a> lnet_ni_status_t;
<a name="l00262"></a>00262 
<a name="l00263"></a><a class="code" href="structlnet__tx__queue.html">00263</a> <span class="keyword">struct </span><a class="code" href="structlnet__tx__queue.html">lnet_tx_queue</a> {
<a name="l00264"></a><a class="code" href="structlnet__tx__queue.html#a5825c5e7bf63411d1081129bade9c3bb">00264</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__tx__queue.html#a5825c5e7bf63411d1081129bade9c3bb">tq_credits</a>;     <span class="comment">/* # tx credits free */</span>
<a name="l00265"></a><a class="code" href="structlnet__tx__queue.html#ab50903ab0e3337ef1bcf362e18d4bba2">00265</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__tx__queue.html#ab50903ab0e3337ef1bcf362e18d4bba2">tq_credits_min</a>; <span class="comment">/* lowest it&apos;s been */</span>
<a name="l00266"></a><a class="code" href="structlnet__tx__queue.html#ae5dccff6cdf217554affeab072410c3b">00266</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__tx__queue.html#ae5dccff6cdf217554affeab072410c3b">tq_credits_max</a>; <span class="comment">/* total # tx credits */</span>
<a name="l00267"></a><a class="code" href="structlnet__tx__queue.html#acb5e40654e9ca7fed588a3fe2944b817">00267</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__tx__queue.html#acb5e40654e9ca7fed588a3fe2944b817">tq_delayed</a>;     <span class="comment">/* delayed TXs */</span>
<a name="l00268"></a>00268 };
<a name="l00269"></a>00269 
<a name="l00270"></a><a class="code" href="structlnet__ni.html">00270</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__ni.html">lnet_ni</a> {
<a name="l00271"></a><a class="code" href="structlnet__ni.html#aafda5fff67e2d61c483587e7a9c71eb7">00271</a>         spinlock_t              <a class="code" href="structlnet__ni.html#aafda5fff67e2d61c483587e7a9c71eb7">ni_lock</a>;
<a name="l00272"></a><a class="code" href="structlnet__ni.html#a5e2ac7f49f506d97062856b207ecbae5">00272</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__ni.html#a5e2ac7f49f506d97062856b207ecbae5">ni_list</a>;        <span class="comment">/* chain on ln_nis */</span>
<a name="l00273"></a><a class="code" href="structlnet__ni.html#a1eb4aca742158b0d6ba79f95279dbfc0">00273</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__ni.html#a1eb4aca742158b0d6ba79f95279dbfc0">ni_cptlist</a>;     <span class="comment">/* chain on ln_nis_cpt */</span>
<a name="l00274"></a><a class="code" href="structlnet__ni.html#af4d018f203531512886c5a8e8d574a9b">00274</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__ni.html#af4d018f203531512886c5a8e8d574a9b">ni_maxtxcredits</a>; <span class="comment">/* # tx credits  */</span>
<a name="l00275"></a>00275         <span class="comment">/* # per-peer send credits */</span>
<a name="l00276"></a><a class="code" href="structlnet__ni.html#a1cad78a107e2c63e8d9b548e9bf8461c">00276</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__ni.html#a1cad78a107e2c63e8d9b548e9bf8461c">ni_peertxcredits</a>;
<a name="l00277"></a>00277         <span class="comment">/* # per-peer router buffer credits */</span>
<a name="l00278"></a><a class="code" href="structlnet__ni.html#a29dec3817262213b4e6c762c47f5c700">00278</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__ni.html#a29dec3817262213b4e6c762c47f5c700">ni_peerrtrcredits</a>;
<a name="l00279"></a>00279         <span class="comment">/* seconds to consider peer dead */</span>
<a name="l00280"></a><a class="code" href="structlnet__ni.html#aa9b363a9ac0e568408df3e7c9db50800">00280</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__ni.html#aa9b363a9ac0e568408df3e7c9db50800">ni_peertimeout</a>;
<a name="l00281"></a><a class="code" href="structlnet__ni.html#aa28a1ce3e160cdf6700fb8d9a176be8d">00281</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__ni.html#aa28a1ce3e160cdf6700fb8d9a176be8d">ni_ncpts</a>;       <span class="comment">/* number of CPTs */</span>
<a name="l00282"></a><a class="code" href="structlnet__ni.html#a64a08f44d55729fdee2980966bf817b8">00282</a>         __u32                   *<a class="code" href="structlnet__ni.html#a64a08f44d55729fdee2980966bf817b8">ni_cpts</a>;       <span class="comment">/* bond NI on some CPTs */</span>
<a name="l00283"></a><a class="code" href="structlnet__ni.html#a3220978c27f9626e971d2537a167795d">00283</a>         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>              <a class="code" href="structlnet__ni.html#a3220978c27f9626e971d2537a167795d">ni_nid</a>;         <span class="comment">/* interface&apos;s NID */</span>
<a name="l00284"></a><a class="code" href="structlnet__ni.html#a1c634f5ccbd0a699083bf608b02c8841">00284</a>         <span class="keywordtype">void</span>                    *<a class="code" href="structlnet__ni.html#a1c634f5ccbd0a699083bf608b02c8841">ni_data</a>;       <span class="comment">/* instance-specific data */</span>
<a name="l00285"></a><a class="code" href="structlnet__ni.html#ae24d6e6f3abc2750ce6f4afff6945a9d">00285</a>         <a class="code" href="structlnet__lnd.html">lnd_t</a>                   *<a class="code" href="structlnet__ni.html#ae24d6e6f3abc2750ce6f4afff6945a9d">ni_lnd</a>;        <span class="comment">/* procedural interface */</span>
<a name="l00286"></a><a class="code" href="structlnet__ni.html#a087d88b6528a5b9ddfa4ae5d57747bf5">00286</a>         <span class="keyword">struct </span><a class="code" href="structlnet__tx__queue.html">lnet_tx_queue</a>    **<a class="code" href="structlnet__ni.html#a087d88b6528a5b9ddfa4ae5d57747bf5">ni_tx_queues</a>; <span class="comment">/* percpt TX queues */</span>
<a name="l00287"></a><a class="code" href="structlnet__ni.html#acfefe18957f9e21b57d732888a57fc79">00287</a>         <span class="keywordtype">int</span>                     **<a class="code" href="structlnet__ni.html#acfefe18957f9e21b57d732888a57fc79">ni_refs</a>;      <span class="comment">/* percpt reference count */</span>
<a name="l00288"></a><a class="code" href="structlnet__ni.html#a2410cad52c6614857b548c990ba06c51">00288</a>         <span class="keywordtype">long</span>                    <a class="code" href="structlnet__ni.html#a2410cad52c6614857b548c990ba06c51">ni_last_alive</a>;  <span class="comment">/* when I was last alive */</span>
<a name="l00289"></a><a class="code" href="structlnet__ni.html#a5def424e7d0dd4725bd026097d51453c">00289</a>         lnet_ni_status_t        *<a class="code" href="structlnet__ni.html#a5def424e7d0dd4725bd026097d51453c">ni_status</a>;     <span class="comment">/* my health status */</span>
<a name="l00290"></a>00290         <span class="comment">/* per NI LND tunables */</span>
<a name="l00291"></a><a class="code" href="structlnet__ni.html#a51f668728b5005d7dca9f645d647f3de">00291</a>         <span class="keyword">struct </span><a class="code" href="structlnet__ioctl__config__lnd__tunables.html">lnet_ioctl_config_lnd_tunables</a> *<a class="code" href="structlnet__ni.html#a51f668728b5005d7dca9f645d647f3de">ni_lnd_tunables</a>;
<a name="l00292"></a>00292         <span class="comment">/* equivalent interfaces to use */</span>
<a name="l00293"></a><a class="code" href="structlnet__ni.html#ac1b5c5d8940752a8e065758473484ddd">00293</a>         <span class="keywordtype">char</span>                    *<a class="code" href="structlnet__ni.html#ac1b5c5d8940752a8e065758473484ddd">ni_interfaces</a>[<a class="code" href="group__lnet__addr.html#ga068d1aa322aa37d85a4875c9909d2197">LNET_MAX_INTERFACES</a>];
<a name="l00294"></a>00294 } <a class="code" href="structlnet__ni.html">lnet_ni_t</a>;
<a name="l00295"></a>00295 
<a name="l00296"></a><a class="code" href="lib-types_8h.html#a86911c4edd16e913f063b2b33d7d54d1">00296</a> <span class="preprocessor">#define LNET_PROTO_PING_MATCHBITS       0x8000000000000000LL</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span>
<a name="l00298"></a>00298 <span class="comment">/* NB: value of these features equal to LNET_PROTO_PING_VERSION_x</span>
<a name="l00299"></a>00299 <span class="comment"> * of old LNet, so there shouldn&apos;t be any compatibility issue */</span>
<a name="l00300"></a><a class="code" href="lib-types_8h.html#aebef905af11053f261f1631aa81bb358">00300</a> <span class="preprocessor">#define LNET_PING_FEAT_INVAL            (0)             </span><span class="comment">/* no feature */</span>
<a name="l00301"></a><a class="code" href="lib-types_8h.html#a80509c506d2a71a4ca1228bdea258c6f">00301</a> <span class="preprocessor">#define LNET_PING_FEAT_BASE             (1 &lt;&lt; 0)        </span><span class="comment">/* just a ping */</span>
<a name="l00302"></a><a class="code" href="lib-types_8h.html#a5986e87c9dab88b3dcf10aec66bba4aa">00302</a> <span class="preprocessor">#define LNET_PING_FEAT_NI_STATUS        (1 &lt;&lt; 1)        </span><span class="comment">/* return NI status */</span>
<a name="l00303"></a><a class="code" href="lib-types_8h.html#a877e8c86f144e61b2b5d1d21ab49ab30">00303</a> <span class="preprocessor">#define LNET_PING_FEAT_RTE_DISABLED     (1 &lt;&lt; 2)        </span><span class="comment">/* Routing enabled */</span>
<a name="l00304"></a>00304 
<a name="l00305"></a><a class="code" href="lib-types_8h.html#a91d5bd14ada1f483f625ae03ab0be3d0">00305</a> <span class="preprocessor">#define LNET_PING_FEAT_MASK             (LNET_PING_FEAT_BASE | \</span>
<a name="l00306"></a>00306 <span class="preprocessor">                                         LNET_PING_FEAT_NI_STATUS)</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>
<a name="l00308"></a>00308 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00309"></a><a class="code" href="structWIRE__ATTR.html#a9c86349916a1bd8a8fc470c701d3084a">00309</a>         __u32                   pi_magic;
<a name="l00310"></a><a class="code" href="structWIRE__ATTR.html#a88324fa784ce0003d6f2f1a768b69a9a">00310</a>         __u32                   pi_features;
<a name="l00311"></a><a class="code" href="structWIRE__ATTR.html#a4cf18ec25f2d4172b218083993d77224">00311</a>         <a class="code" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd" title="ID of a process in a node.">lnet_pid_t</a>              pi_pid;
<a name="l00312"></a><a class="code" href="structWIRE__ATTR.html#a455d567b8374973ba60b4e5ec336444a">00312</a>         __u32                   pi_nnis;
<a name="l00313"></a><a class="code" href="structWIRE__ATTR.html#ad3bd40dbe3231db98eb8c27ff4d4bc1b">00313</a>         lnet_ni_status_t        pi_ni[0];
<a name="l00314"></a>00314 } <a class="code" href="structWIRE__ATTR.html">WIRE_ATTR</a> lnet_ping_info_t;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">/* router checker data, per router */</span>
<a name="l00317"></a><a class="code" href="lib-types_8h.html#a083684087939ec9fc7a1fd95c408cac8">00317</a> <span class="preprocessor">#define LNET_MAX_RTR_NIS   16</span>
<a name="l00318"></a><a class="code" href="lib-types_8h.html#a7f3854ef0dee38dc87198c61a8caa95a">00318</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_PINGINFO_SIZE offsetof(lnet_ping_info_t, pi_ni[LNET_MAX_RTR_NIS])</span>
<a name="l00319"></a><a class="code" href="structlnet__rc__data__t.html">00319</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00320"></a>00320         <span class="comment">/* chain on the_lnet.ln_zombie_rcd or ln_deathrow_rcd */</span>
<a name="l00321"></a><a class="code" href="structlnet__rc__data__t.html#a4d94c4f9e6f12847b5c7e1709d981285">00321</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        rcd_list;
<a name="l00322"></a><a class="code" href="structlnet__rc__data__t.html#a816ddbda25dffde87d38543fb760644e">00322</a>         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>        rcd_mdh;        <span class="comment">/* ping buffer MD */</span>
<a name="l00323"></a><a class="code" href="structlnet__rc__data__t.html#a72d2c3086e0e2b3a94677e308a6df846">00323</a>         <span class="keyword">struct </span><a class="code" href="structlnet__peer.html">lnet_peer</a>        *rcd_gateway;   <span class="comment">/* reference to gateway */</span>
<a name="l00324"></a><a class="code" href="structlnet__rc__data__t.html#a557d2dbc5af1219abac7ee7cff7e01ea">00324</a>         lnet_ping_info_t        *rcd_pinginfo;  <span class="comment">/* ping buffer */</span>
<a name="l00325"></a>00325 } <a class="code" href="structlnet__rc__data__t.html">lnet_rc_data_t</a>;
<a name="l00326"></a>00326 
<a name="l00327"></a><a class="code" href="structlnet__peer.html">00327</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__peer.html">lnet_peer</a> {
<a name="l00328"></a>00328         <span class="comment">/* chain on peer hash */</span>
<a name="l00329"></a><a class="code" href="structlnet__peer.html#ab3491792b104ea3b463fe84601381391">00329</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__peer.html#ab3491792b104ea3b463fe84601381391">lp_hashlist</a>;
<a name="l00330"></a>00330         <span class="comment">/* messages blocking for tx credits */</span>
<a name="l00331"></a><a class="code" href="structlnet__peer.html#a684bbfb23f0ff77794f3d5219a240169">00331</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__peer.html#a684bbfb23f0ff77794f3d5219a240169">lp_txq</a>;
<a name="l00332"></a>00332         <span class="comment">/* messages blocking for router credits */</span>
<a name="l00333"></a><a class="code" href="structlnet__peer.html#af15e4568a2a57a1d442bdcb59a2e85d5">00333</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__peer.html#af15e4568a2a57a1d442bdcb59a2e85d5">lp_rtrq</a>;
<a name="l00334"></a>00334         <span class="comment">/* chain on router list */</span>
<a name="l00335"></a><a class="code" href="structlnet__peer.html#a0391e84d9f38635d90aab34cb26c5d4c">00335</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__peer.html#a0391e84d9f38635d90aab34cb26c5d4c">lp_rtr_list</a>;
<a name="l00336"></a>00336         <span class="comment">/* # tx credits available */</span>
<a name="l00337"></a><a class="code" href="structlnet__peer.html#a242d73f0ae01292f256fc702adcf4076">00337</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer.html#a242d73f0ae01292f256fc702adcf4076">lp_txcredits</a>;
<a name="l00338"></a>00338         <span class="comment">/* low water mark */</span>
<a name="l00339"></a><a class="code" href="structlnet__peer.html#add205ab4888f95264cc3fa111b2f8026">00339</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer.html#add205ab4888f95264cc3fa111b2f8026">lp_mintxcredits</a>;
<a name="l00340"></a>00340         <span class="comment">/* # router credits */</span>
<a name="l00341"></a><a class="code" href="structlnet__peer.html#aa54bef2a5fe8adaa507761d821b04a6e">00341</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer.html#aa54bef2a5fe8adaa507761d821b04a6e">lp_rtrcredits</a>;
<a name="l00342"></a>00342         <span class="comment">/* low water mark */</span>
<a name="l00343"></a><a class="code" href="structlnet__peer.html#af9d65bc8d5d7efc5cd2d5392d954e7cb">00343</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer.html#af9d65bc8d5d7efc5cd2d5392d954e7cb">lp_minrtrcredits</a>;
<a name="l00344"></a>00344         <span class="comment">/* alive/dead? */</span>
<a name="l00345"></a><a class="code" href="structlnet__peer.html#a93b08b2e2755d5ba314e5671614fffc4">00345</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__peer.html#a93b08b2e2755d5ba314e5671614fffc4">lp_alive</a>:1;
<a name="l00346"></a>00346         <span class="comment">/* notification outstanding? */</span>
<a name="l00347"></a><a class="code" href="structlnet__peer.html#a189d7deed801714c9602c057300bc6bc">00347</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__peer.html#a189d7deed801714c9602c057300bc6bc">lp_notify</a>:1;
<a name="l00348"></a>00348         <span class="comment">/* outstanding notification for LND? */</span>
<a name="l00349"></a><a class="code" href="structlnet__peer.html#a2a4aee5e7aa212a0db2b74c71f56f460">00349</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__peer.html#a2a4aee5e7aa212a0db2b74c71f56f460">lp_notifylnd</a>:1;
<a name="l00350"></a>00350         <span class="comment">/* some thread is handling notification */</span>
<a name="l00351"></a><a class="code" href="structlnet__peer.html#a2b5124d59576ad37cce3e1b1e6a64d55">00351</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__peer.html#a2b5124d59576ad37cce3e1b1e6a64d55">lp_notifying</a>:1;
<a name="l00352"></a>00352         <span class="comment">/* SEND event outstanding from ping */</span>
<a name="l00353"></a><a class="code" href="structlnet__peer.html#a78f7fb411b14cc183766c132c48706a8">00353</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__peer.html#a78f7fb411b14cc183766c132c48706a8">lp_ping_notsent</a>;
<a name="l00354"></a>00354         <span class="comment">/* # times router went dead&lt;-&gt;alive */</span>
<a name="l00355"></a><a class="code" href="structlnet__peer.html#a1e492df23aac2fb7dc6b529e7adc7a3e">00355</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer.html#a1e492df23aac2fb7dc6b529e7adc7a3e">lp_alive_count</a>;
<a name="l00356"></a>00356         <span class="comment">/* bytes queued for sending */</span>
<a name="l00357"></a><a class="code" href="structlnet__peer.html#ad599ae77ab8e39866e0d263f24fa5217">00357</a>         <span class="keywordtype">long</span>                    <a class="code" href="structlnet__peer.html#ad599ae77ab8e39866e0d263f24fa5217">lp_txqnob</a>;
<a name="l00358"></a>00358         <span class="comment">/* time of last aliveness news */</span>
<a name="l00359"></a><a class="code" href="structlnet__peer.html#a2af0374a724da1c79c5e991f7586c6d1">00359</a>         <a class="code" href="linux-time_8h.html#a0e81d053bc8d925f6574c760bbea5ac4">cfs_time_t</a>              <a class="code" href="structlnet__peer.html#a2af0374a724da1c79c5e991f7586c6d1">lp_timestamp</a>;
<a name="l00360"></a>00360         <span class="comment">/* time of last ping attempt */</span>
<a name="l00361"></a><a class="code" href="structlnet__peer.html#a2a5735c5495271fb0b4ebd5f46f6b5b8">00361</a>         <a class="code" href="linux-time_8h.html#a0e81d053bc8d925f6574c760bbea5ac4">cfs_time_t</a>              <a class="code" href="structlnet__peer.html#a2a5735c5495271fb0b4ebd5f46f6b5b8">lp_ping_timestamp</a>;
<a name="l00362"></a>00362         <span class="comment">/* != 0 if ping reply expected */</span>
<a name="l00363"></a><a class="code" href="structlnet__peer.html#adf731466ab37f41340f0042ecc4fe219">00363</a>         <a class="code" href="linux-time_8h.html#a0e81d053bc8d925f6574c760bbea5ac4">cfs_time_t</a>              <a class="code" href="structlnet__peer.html#adf731466ab37f41340f0042ecc4fe219">lp_ping_deadline</a>;
<a name="l00364"></a>00364         <span class="comment">/* when I was last alive */</span>
<a name="l00365"></a><a class="code" href="structlnet__peer.html#a9c6c59cf8dc61f01d0577922040f6092">00365</a>         <a class="code" href="linux-time_8h.html#a0e81d053bc8d925f6574c760bbea5ac4">cfs_time_t</a>              <a class="code" href="structlnet__peer.html#a9c6c59cf8dc61f01d0577922040f6092">lp_last_alive</a>;
<a name="l00366"></a>00366         <span class="comment">/* when lp_ni was queried last time */</span>
<a name="l00367"></a><a class="code" href="structlnet__peer.html#a803acb8f36c560cf4bdcad307639f484">00367</a>         <a class="code" href="linux-time_8h.html#a0e81d053bc8d925f6574c760bbea5ac4">cfs_time_t</a>              <a class="code" href="structlnet__peer.html#a803acb8f36c560cf4bdcad307639f484">lp_last_query</a>;
<a name="l00368"></a>00368         <span class="comment">/* interface peer is on */</span>
<a name="l00369"></a><a class="code" href="structlnet__peer.html#ad9a175e6f90270679d208dc66fade647">00369</a>         <a class="code" href="structlnet__ni.html">lnet_ni_t</a>               *<a class="code" href="structlnet__peer.html#ad9a175e6f90270679d208dc66fade647">lp_ni</a>;
<a name="l00370"></a><a class="code" href="structlnet__peer.html#aa602b0cde4678f96f3608ff7d27a0528">00370</a>         <a class="code" href="group__lnet__addr.html#ga0d47ef2c4f1002efbdd050547f80a312" title="Address of an end-point in an LNet network.">lnet_nid_t</a>              <a class="code" href="structlnet__peer.html#aa602b0cde4678f96f3608ff7d27a0528">lp_nid</a>;         <span class="comment">/* peer&apos;s NID */</span>
<a name="l00371"></a><a class="code" href="structlnet__peer.html#acdbe378e30971a1f139a63a573277f8c">00371</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer.html#acdbe378e30971a1f139a63a573277f8c">lp_refcount</a>;    <span class="comment">/* # refs */</span>
<a name="l00372"></a><a class="code" href="structlnet__peer.html#a3c34de3e249461243ed296597b38bdc9">00372</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer.html#a3c34de3e249461243ed296597b38bdc9">lp_cpt</a>;         <span class="comment">/* CPT this peer attached on */</span>
<a name="l00373"></a>00373         <span class="comment">/* # refs from lnet_route_t::lr_gateway */</span>
<a name="l00374"></a><a class="code" href="structlnet__peer.html#aeea10375e4ab231a0389c1eceb6c9ae5">00374</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer.html#aeea10375e4ab231a0389c1eceb6c9ae5">lp_rtr_refcount</a>;
<a name="l00375"></a>00375         <span class="comment">/* returned RC ping features */</span>
<a name="l00376"></a><a class="code" href="structlnet__peer.html#a537cc824665c1fc15591483cd5e5f1e8">00376</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__peer.html#a537cc824665c1fc15591483cd5e5f1e8">lp_ping_feats</a>;
<a name="l00377"></a><a class="code" href="structlnet__peer.html#a1a186dde37315516e260706083fcb324">00377</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__peer.html#a1a186dde37315516e260706083fcb324">lp_routes</a>;      <span class="comment">/* routers on this peer */</span>
<a name="l00378"></a><a class="code" href="structlnet__peer.html#ace91d8161de198143e47ef1403eeaabd">00378</a>         <a class="code" href="structlnet__rc__data__t.html">lnet_rc_data_t</a>          *<a class="code" href="structlnet__peer.html#ace91d8161de198143e47ef1403eeaabd">lp_rcd</a>;        <span class="comment">/* router checker state */</span>
<a name="l00379"></a>00379 } <a class="code" href="structlnet__peer.html">lnet_peer_t</a>;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="comment">/* peer hash size */</span>
<a name="l00382"></a><a class="code" href="lib-types_8h.html#a304e5ce00ae200d3806b41b8c0859e60">00382</a> <span class="preprocessor">#define LNET_PEER_HASH_BITS     9</span>
<a name="l00383"></a><a class="code" href="lib-types_8h.html#ae4b313f2293c218aca0b18f0419d2d4e">00383</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_PEER_HASH_SIZE     (1 &lt;&lt; LNET_PEER_HASH_BITS)</span>
<a name="l00384"></a>00384 <span class="preprocessor"></span>
<a name="l00385"></a>00385 <span class="comment">/* peer hash table */</span>
<a name="l00386"></a><a class="code" href="structlnet__peer__table.html">00386</a> <span class="keyword">struct </span><a class="code" href="structlnet__peer__table.html">lnet_peer_table</a> {
<a name="l00387"></a><a class="code" href="structlnet__peer__table.html#a546f7ac2c0b3a2e0651fc54d0d0cf5a7">00387</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer__table.html#a546f7ac2c0b3a2e0651fc54d0d0cf5a7">pt_version</a>;     <span class="comment">/* /proc validity stamp */</span>
<a name="l00388"></a><a class="code" href="structlnet__peer__table.html#ab64dff98ddd14cd94162fc403553fbe3">00388</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer__table.html#ab64dff98ddd14cd94162fc403553fbe3">pt_number</a>;      <span class="comment">/* # peers extant */</span>
<a name="l00389"></a><a class="code" href="structlnet__peer__table.html#add5a965668cfc3006e06b3cc71caa80b">00389</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__peer__table.html#add5a965668cfc3006e06b3cc71caa80b">pt_zombies</a>;     <span class="comment">/* # zombies to go to deathrow</span>
<a name="l00390"></a>00390 <span class="comment">                                                 * (and not there yet) */</span>
<a name="l00391"></a><a class="code" href="structlnet__peer__table.html#a81e34bdfbfb02480a61b147f7e9c3fe9">00391</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__peer__table.html#a81e34bdfbfb02480a61b147f7e9c3fe9">pt_deathrow</a>;    <span class="comment">/* zombie peers */</span>
<a name="l00392"></a><a class="code" href="structlnet__peer__table.html#a94b4ecd7fcdb2439a4b39e95e9cc0b8a">00392</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *<a class="code" href="structlnet__peer__table.html#a94b4ecd7fcdb2439a4b39e95e9cc0b8a">pt_hash</a>;       <span class="comment">/* NID-&gt;peer hash */</span>
<a name="l00393"></a>00393 };
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="comment">/* peer aliveness is enabled only on routers for peers in a network where the</span>
<a name="l00396"></a>00396 <span class="comment"> * lnet_ni_t::ni_peertimeout has been set to a positive value */</span>
<a name="l00397"></a><a class="code" href="lib-types_8h.html#a4974d37b68d5f9cf29a5acc838507136">00397</a> <span class="preprocessor">#define lnet_peer_aliveness_enabled(lp) (the_lnet.ln_routing != 0 &amp;&amp; \</span>
<a name="l00398"></a>00398 <span class="preprocessor">                                         (lp)-&gt;lp_ni-&gt;ni_peertimeout &gt; 0)</span>
<a name="l00399"></a>00399 <span class="preprocessor"></span>
<a name="l00400"></a><a class="code" href="structlnet__route__t.html">00400</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00401"></a><a class="code" href="structlnet__route__t.html#a0911c07131bff750c1d76c5f7c6f0c60">00401</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lr_list;        <span class="comment">/* chain on net */</span>
<a name="l00402"></a><a class="code" href="structlnet__route__t.html#a46500255c412cef04e8289af404795ff">00402</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lr_gwlist;      <span class="comment">/* chain on gateway */</span>
<a name="l00403"></a><a class="code" href="structlnet__route__t.html#a4acb3e5a1115b91a57b9a2fbb10486de">00403</a>         <a class="code" href="structlnet__peer.html">lnet_peer_t</a>             *lr_gateway;    <span class="comment">/* router node */</span>
<a name="l00404"></a><a class="code" href="structlnet__route__t.html#a258629f7b69ecfe751f04f79451dae26">00404</a>         __u32                   lr_net;         <span class="comment">/* remote network number */</span>
<a name="l00405"></a><a class="code" href="structlnet__route__t.html#aeb08bd40f14c0eab1b5b5be87eabb4f9">00405</a>         <span class="keywordtype">int</span>                     lr_seq;         <span class="comment">/* sequence for round-robin */</span>
<a name="l00406"></a><a class="code" href="structlnet__route__t.html#af051f41159dfbd5002598ca41412d1e1">00406</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lr_downis;      <span class="comment">/* number of down NIs */</span>
<a name="l00407"></a><a class="code" href="structlnet__route__t.html#a27c7885a6338856ec3918a3831afdf88">00407</a>         __u32                   lr_hops;        <span class="comment">/* how far I am */</span>
<a name="l00408"></a><a class="code" href="structlnet__route__t.html#a175ce59feb705c82c0335944c1266cf7">00408</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            lr_priority;    <span class="comment">/* route priority */</span>
<a name="l00409"></a>00409 } <a class="code" href="structlnet__route__t.html">lnet_route_t</a>;
<a name="l00410"></a>00410 
<a name="l00411"></a><a class="code" href="lib-types_8h.html#ad7e0c9e65b3b165bc5d17922a060796c">00411</a> <span class="preprocessor">#define LNET_REMOTE_NETS_HASH_DEFAULT   (1U &lt;&lt; 7)</span>
<a name="l00412"></a><a class="code" href="lib-types_8h.html#ab1107901519a90396a42d1b890202974">00412</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_REMOTE_NETS_HASH_MAX       (1U &lt;&lt; 16)</span>
<a name="l00413"></a><a class="code" href="lib-types_8h.html#a47c865e32e7409a4e83b3d6bd3ce8e1e">00413</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_REMOTE_NETS_HASH_SIZE      (1 &lt;&lt; the_lnet.ln_remote_nets_hbits)</span>
<a name="l00414"></a>00414 <span class="preprocessor"></span>
<a name="l00415"></a><a class="code" href="structlnet__remotenet__t.html">00415</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00416"></a>00416         <span class="comment">/* chain on ln_remote_nets_hash */</span>
<a name="l00417"></a><a class="code" href="structlnet__remotenet__t.html#a5738d6dc8b4c05342a31b5bdee87b8ed">00417</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lrn_list;
<a name="l00418"></a>00418         <span class="comment">/* routes to me */</span>
<a name="l00419"></a><a class="code" href="structlnet__remotenet__t.html#a47cb21f6d101c718482637da9ef31a61">00419</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        lrn_routes;
<a name="l00420"></a>00420         <span class="comment">/* my net number */</span>
<a name="l00421"></a><a class="code" href="structlnet__remotenet__t.html#a59acf9f14db9d8bc485f2e4686b2f55a">00421</a>         __u32                   lrn_net;
<a name="l00422"></a>00422 } <a class="code" href="structlnet__remotenet__t.html">lnet_remotenet_t</a>;
<a name="l00423"></a>00423 
<a name="l00425"></a><a class="code" href="lib-types_8h.html#a000df956f7547647e50f2774495bc384">00425</a> <span class="preprocessor">#define LNET_CREDIT_OK          0</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>
<a name="l00427"></a><a class="code" href="lib-types_8h.html#a4fb17fd779192a789da5513cbabe607b">00427</a> <span class="preprocessor">#define LNET_CREDIT_WAIT        1</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>
<a name="l00429"></a><a class="code" href="structlnet__rtrbufpool__t.html">00429</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00430"></a>00430         <span class="comment">/* my free buffer pool */</span>
<a name="l00431"></a><a class="code" href="structlnet__rtrbufpool__t.html#af87f64eb4914469558bf90c105b0cc6c">00431</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        rbp_bufs;
<a name="l00432"></a>00432         <span class="comment">/* messages blocking for a buffer */</span>
<a name="l00433"></a><a class="code" href="structlnet__rtrbufpool__t.html#a8243b98914eb2938f76be27eac728dc6">00433</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        rbp_msgs;
<a name="l00434"></a>00434         <span class="comment">/* # pages in each buffer */</span>
<a name="l00435"></a><a class="code" href="structlnet__rtrbufpool__t.html#a33164499ddedb0c9b8408253593c8636">00435</a>         <span class="keywordtype">int</span>                     rbp_npages;
<a name="l00436"></a>00436         <span class="comment">/* requested number of buffers */</span>
<a name="l00437"></a><a class="code" href="structlnet__rtrbufpool__t.html#acd550f5111a8fddea572a36424c02fff">00437</a>         <span class="keywordtype">int</span>                     rbp_req_nbuffers;
<a name="l00438"></a>00438         <span class="comment">/* # buffers actually allocated */</span>
<a name="l00439"></a><a class="code" href="structlnet__rtrbufpool__t.html#aceac3b0b351da3193b60fad8bf1fccec">00439</a>         <span class="keywordtype">int</span>                     rbp_nbuffers;
<a name="l00440"></a>00440         <span class="comment">/* # free buffers / blocked messages */</span>
<a name="l00441"></a><a class="code" href="structlnet__rtrbufpool__t.html#a28200b4f6f393dfa11abb191833df76a">00441</a>         <span class="keywordtype">int</span>                     rbp_credits;
<a name="l00442"></a>00442         <span class="comment">/* low water mark */</span>
<a name="l00443"></a><a class="code" href="structlnet__rtrbufpool__t.html#ac373b91f7e3e7b0ce712249cdd71a34a">00443</a>         <span class="keywordtype">int</span>                     rbp_mincredits;
<a name="l00444"></a>00444 } <a class="code" href="structlnet__rtrbufpool__t.html">lnet_rtrbufpool_t</a>;
<a name="l00445"></a>00445 
<a name="l00446"></a><a class="code" href="structlnet__rtrbuf__t.html">00446</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00447"></a><a class="code" href="structlnet__rtrbuf__t.html#a8de9d4ca1d87e50530932800388501f1">00447</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>         rb_list;       <span class="comment">/* chain on rbp_bufs */</span>
<a name="l00448"></a><a class="code" href="structlnet__rtrbuf__t.html#adfcffe05aa53c4a0552c2db89fa18bc1">00448</a>         <a class="code" href="structlnet__rtrbufpool__t.html">lnet_rtrbufpool_t</a>       *rb_pool;       <span class="comment">/* owning pool */</span>
<a name="l00449"></a><a class="code" href="structlnet__rtrbuf__t.html#ab72f14a1950f29bfee5c80badea07ce7">00449</a>         <a class="code" href="structlnet__kiov__t.html" title="A page-based fragment of a MD.">lnet_kiov_t</a>              rb_kiov[0];    <span class="comment">/* the buffer space */</span>
<a name="l00450"></a>00450 } <a class="code" href="structlnet__rtrbuf__t.html">lnet_rtrbuf_t</a>;
<a name="l00451"></a>00451 
<a name="l00452"></a><a class="code" href="lib-types_8h.html#a02d5ba023fd724854ca1cde901eef7b2">00452</a> <span class="preprocessor">#define LNET_PEER_HASHSIZE   503                </span><span class="comment">/* prime! */</span>
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="keyword">enum</span> {
<a name="l00455"></a>00455         <span class="comment">/* Didn&apos;t match anything */</span>
<a name="l00456"></a><a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516a31ceea64aa600d706d29c68b9601fe31">00456</a>         <a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516a31ceea64aa600d706d29c68b9601fe31">LNET_MATCHMD_NONE</a>       = (1 &lt;&lt; 0),
<a name="l00457"></a>00457         <span class="comment">/* Matched OK */</span>
<a name="l00458"></a><a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516a133f4919ce3c93e5ccc3ca5b7d8d77c6">00458</a>         <a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516a133f4919ce3c93e5ccc3ca5b7d8d77c6">LNET_MATCHMD_OK</a>         = (1 &lt;&lt; 1),
<a name="l00459"></a>00459         <span class="comment">/* Must be discarded */</span>
<a name="l00460"></a><a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516ab166ed528a0afa86c3f3583d099126cd">00460</a>         <a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516ab166ed528a0afa86c3f3583d099126cd">LNET_MATCHMD_DROP</a>       = (1 &lt;&lt; 2),
<a name="l00461"></a>00461         <span class="comment">/* match and buffer is exhausted */</span>
<a name="l00462"></a><a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516a8be8547e2ceeb3073fbbba7461c0e691">00462</a>         <a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516a8be8547e2ceeb3073fbbba7461c0e691">LNET_MATCHMD_EXHAUSTED</a>  = (1 &lt;&lt; 3),
<a name="l00463"></a>00463         <span class="comment">/* match or drop */</span>
<a name="l00464"></a><a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516a070cc78b0ab61cf09e764fbc1180147d">00464</a>         <a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516a070cc78b0ab61cf09e764fbc1180147d">LNET_MATCHMD_FINISH</a>     = (<a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516a133f4919ce3c93e5ccc3ca5b7d8d77c6">LNET_MATCHMD_OK</a> | <a class="code" href="lib-types_8h.html#afded920d42f51b77f7f86b5057dd4516ab166ed528a0afa86c3f3583d099126cd">LNET_MATCHMD_DROP</a>),
<a name="l00465"></a>00465 };
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="comment">/* Options for lnet_portal_t::ptl_options */</span>
<a name="l00468"></a><a class="code" href="lib-types_8h.html#ab0d90f7ae1a62f116f2c89e7922541e6">00468</a> <span class="preprocessor">#define LNET_PTL_LAZY               (1 &lt;&lt; 0)</span>
<a name="l00469"></a><a class="code" href="lib-types_8h.html#a61b09683f12d68d9f5e05a3d96c09a87">00469</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_PTL_MATCH_UNIQUE       (1 &lt;&lt; 1)    </span><span class="comment">/* unique match, for RDMA */</span>
<a name="l00470"></a><a class="code" href="lib-types_8h.html#ab2e7b06e749e9b4351627acc600bc185">00470</a> <span class="preprocessor">#define LNET_PTL_MATCH_WILDCARD     (1 &lt;&lt; 2)    </span><span class="comment">/* wildcard match, request portal */</span>
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="comment">/* parameter for matching operations (GET, PUT) */</span>
<a name="l00473"></a><a class="code" href="structlnet__match__info.html">00473</a> <span class="keyword">struct </span><a class="code" href="structlnet__match__info.html">lnet_match_info</a> {
<a name="l00474"></a><a class="code" href="structlnet__match__info.html#aaad56a8dc99dd9252ae7975df430dd0e">00474</a>         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                   <a class="code" href="structlnet__match__info.html#aaad56a8dc99dd9252ae7975df430dd0e">mi_mbits</a>;
<a name="l00475"></a><a class="code" href="structlnet__match__info.html#a703bef555eafb5fec99ea6f8a6111fe4">00475</a>         <a class="code" href="structlnet__process__id__t.html" title="Global process ID.">lnet_process_id_t</a>       <a class="code" href="structlnet__match__info.html#a703bef555eafb5fec99ea6f8a6111fe4">mi_id</a>;
<a name="l00476"></a><a class="code" href="structlnet__match__info.html#a9d51f9eabcd7b7bd5f2e33a14f6bd1ac">00476</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__match__info.html#a9d51f9eabcd7b7bd5f2e33a14f6bd1ac">mi_opc</a>;
<a name="l00477"></a><a class="code" href="structlnet__match__info.html#ab76370bfe15721bbc0fa5f04ecab2ff6">00477</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__match__info.html#ab76370bfe15721bbc0fa5f04ecab2ff6">mi_portal</a>;
<a name="l00478"></a><a class="code" href="structlnet__match__info.html#a6ecc87eb43c00732ee461e9a0a684500">00478</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__match__info.html#a6ecc87eb43c00732ee461e9a0a684500">mi_rlength</a>;
<a name="l00479"></a><a class="code" href="structlnet__match__info.html#a205df9681df8c13b802337269a976dc3">00479</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__match__info.html#a205df9681df8c13b802337269a976dc3">mi_roffset</a>;
<a name="l00480"></a>00480 };
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="comment">/* ME hash of RDMA portal */</span>
<a name="l00483"></a><a class="code" href="lib-types_8h.html#a307ec426658aaff6f95d076eef79f50b">00483</a> <span class="preprocessor">#define LNET_MT_HASH_BITS               8</span>
<a name="l00484"></a><a class="code" href="lib-types_8h.html#a51cdba4aa6502dccd32a1f23f1cab99b">00484</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_MT_HASH_SIZE               (1 &lt;&lt; LNET_MT_HASH_BITS)</span>
<a name="l00485"></a><a class="code" href="lib-types_8h.html#a6f8f7a1aa28e3408c1605362dcc02adc">00485</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_MT_HASH_MASK               (LNET_MT_HASH_SIZE - 1)</span>
<a name="l00486"></a>00486 <span class="preprocessor"></span><span class="comment">/* we allocate (LNET_MT_HASH_SIZE + 1) entries for lnet_match_table::mt_hash,</span>
<a name="l00487"></a>00487 <span class="comment"> * the last entry is reserved for MEs with ignore-bits */</span>
<a name="l00488"></a><a class="code" href="lib-types_8h.html#a18d536cbb9cd6655a3ff78809530b68e">00488</a> <span class="preprocessor">#define LNET_MT_HASH_IGNORE             LNET_MT_HASH_SIZE</span>
<a name="l00489"></a>00489 <span class="preprocessor"></span><span class="comment">/* __u64 has 2^6 bits, so need 2^(LNET_MT_HASH_BITS - LNET_MT_BITS_U64) which</span>
<a name="l00490"></a>00490 <span class="comment"> * is 4 __u64s as bit-map, and add an extra __u64 (only use one bit) for the</span>
<a name="l00491"></a>00491 <span class="comment"> * ME-list with ignore-bits, which is mtable::mt_hash[LNET_MT_HASH_IGNORE] */</span>
<a name="l00492"></a><a class="code" href="lib-types_8h.html#af9943c9bfa8f09598bbe3dc1ed6eadb2">00492</a> <span class="preprocessor">#define LNET_MT_BITS_U64                6       </span><span class="comment">/* 2^6 bits */</span>
<a name="l00493"></a><a class="code" href="lib-types_8h.html#ac9c12fa731115fbb30d5d1e650fb884a">00493</a> <span class="preprocessor">#define LNET_MT_EXHAUSTED_BITS          (LNET_MT_HASH_BITS - LNET_MT_BITS_U64)</span>
<a name="l00494"></a><a class="code" href="lib-types_8h.html#a2932991b73f23715137cff6b4dba18a0">00494</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_MT_EXHAUSTED_BMAP          ((1 &lt;&lt; LNET_MT_EXHAUSTED_BITS) + 1)</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span>
<a name="l00496"></a>00496 <span class="comment">/* portal match table */</span>
<a name="l00497"></a><a class="code" href="structlnet__match__table.html">00497</a> <span class="keyword">struct </span><a class="code" href="structlnet__match__table.html">lnet_match_table</a> {
<a name="l00498"></a>00498         <span class="comment">/* reserved for upcoming patches, CPU partition ID */</span>
<a name="l00499"></a><a class="code" href="structlnet__match__table.html#ae77f296ac769e83b4ee027bf83d9214f">00499</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__match__table.html#ae77f296ac769e83b4ee027bf83d9214f">mt_cpt</a>;
<a name="l00500"></a><a class="code" href="structlnet__match__table.html#a0838d2de55baa679736d01f649e9e367">00500</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__match__table.html#a0838d2de55baa679736d01f649e9e367">mt_portal</a>;      <span class="comment">/* portal index */</span>
<a name="l00501"></a>00501         <span class="comment">/* match table is set as &quot;enabled&quot; if there&apos;s non-exhausted MD</span>
<a name="l00502"></a>00502 <span class="comment">         * attached on mt_mhash, it&apos;s only valid for wildcard portal */</span>
<a name="l00503"></a><a class="code" href="structlnet__match__table.html#a4fe444346f00ad24ae23df868a503fbb">00503</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__match__table.html#a4fe444346f00ad24ae23df868a503fbb">mt_enabled</a>;
<a name="l00504"></a>00504         <span class="comment">/* bitmap to flag whether MEs on mt_hash are exhausted or not */</span>
<a name="l00505"></a><a class="code" href="structlnet__match__table.html#afa5b95d553ca1a948e02ed38c1f826b5">00505</a>         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                   <a class="code" href="structlnet__match__table.html#afa5b95d553ca1a948e02ed38c1f826b5">mt_exhausted</a>[<a class="code" href="lib-types_8h.html#a2932991b73f23715137cff6b4dba18a0">LNET_MT_EXHAUSTED_BMAP</a>];
<a name="l00506"></a><a class="code" href="structlnet__match__table.html#a12d1a68eebc202a26330f9add87b77b9">00506</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *<a class="code" href="structlnet__match__table.html#a12d1a68eebc202a26330f9add87b77b9">mt_mhash</a>;      <span class="comment">/* matching hash */</span>
<a name="l00507"></a>00507 };
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="comment">/* these are only useful for wildcard portal */</span>
<a name="l00510"></a>00510 <span class="comment">/* Turn off message rotor for wildcard portals */</span>
<a name="l00511"></a><a class="code" href="lib-types_8h.html#a78c5ea1b4898f23af2a7edc38d57fcd6">00511</a> <span class="preprocessor">#define LNET_PTL_ROTOR_OFF      0</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span><span class="comment">/* round-robin dispatch all PUT messages for wildcard portals */</span>
<a name="l00513"></a><a class="code" href="lib-types_8h.html#a4e2514284207e44bfc7909394602dfc8">00513</a> <span class="preprocessor">#define LNET_PTL_ROTOR_ON       1</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span><span class="comment">/* round-robin dispatch routed PUT message for wildcard portals */</span>
<a name="l00515"></a><a class="code" href="lib-types_8h.html#acf19215090dec7e535f70980f845041d">00515</a> <span class="preprocessor">#define LNET_PTL_ROTOR_RR_RT    2</span>
<a name="l00516"></a>00516 <span class="preprocessor"></span><span class="comment">/* dispatch routed PUT message by hashing source NID for wildcard portals */</span>
<a name="l00517"></a><a class="code" href="lib-types_8h.html#a36353ae5c4659d0417ad6a2918be7426">00517</a> <span class="preprocessor">#define LNET_PTL_ROTOR_HASH_RT  3</span>
<a name="l00518"></a>00518 <span class="preprocessor"></span>
<a name="l00519"></a><a class="code" href="structlnet__portal.html">00519</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlnet__portal.html">lnet_portal</a> {
<a name="l00520"></a><a class="code" href="structlnet__portal.html#ab1b151c76495ea671b9ed30453fa471e">00520</a>         spinlock_t              <a class="code" href="structlnet__portal.html#ab1b151c76495ea671b9ed30453fa471e">ptl_lock</a>;
<a name="l00521"></a><a class="code" href="structlnet__portal.html#ae5d9086fe22d68423afc62c5a4ddf974">00521</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__portal.html#ae5d9086fe22d68423afc62c5a4ddf974">ptl_index</a>;      <span class="comment">/* portal ID, reserved */</span>
<a name="l00522"></a>00522         <span class="comment">/* flags on this portal: lazy, unique... */</span>
<a name="l00523"></a><a class="code" href="structlnet__portal.html#afc09dd4ac1c412bc22a91b5bd46cbaa4">00523</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__portal.html#afc09dd4ac1c412bc22a91b5bd46cbaa4">ptl_options</a>;
<a name="l00524"></a>00524         <span class="comment">/* list of messages which are stealing buffer */</span>
<a name="l00525"></a><a class="code" href="structlnet__portal.html#a7ab407e232725592836cc792b044ad59">00525</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__portal.html#a7ab407e232725592836cc792b044ad59">ptl_msg_stealing</a>;
<a name="l00526"></a>00526         <span class="comment">/* messages blocking for MD */</span>
<a name="l00527"></a><a class="code" href="structlnet__portal.html#aa46884284a6c19fa9a3a7a924d5f8d12">00527</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__portal.html#aa46884284a6c19fa9a3a7a924d5f8d12">ptl_msg_delayed</a>;
<a name="l00528"></a>00528         <span class="comment">/* Match table for each CPT */</span>
<a name="l00529"></a><a class="code" href="structlnet__portal.html#a0a17d9ab6c0092c1749476e1e059d4c4">00529</a>         <span class="keyword">struct </span><a class="code" href="structlnet__match__table.html">lnet_match_table</a> **<a class="code" href="structlnet__portal.html#a0a17d9ab6c0092c1749476e1e059d4c4">ptl_mtables</a>;
<a name="l00530"></a>00530         <span class="comment">/* spread rotor of incoming &quot;PUT&quot; */</span>
<a name="l00531"></a><a class="code" href="structlnet__portal.html#a4bd9f819b33b974ef9f9184f3bba73e1">00531</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__portal.html#a4bd9f819b33b974ef9f9184f3bba73e1">ptl_rotor</a>;
<a name="l00532"></a>00532         <span class="comment">/* # active entries for this portal */</span>
<a name="l00533"></a><a class="code" href="structlnet__portal.html#a20ad4f822586e0df60c62d1c3de288df">00533</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__portal.html#a20ad4f822586e0df60c62d1c3de288df">ptl_mt_nmaps</a>;
<a name="l00534"></a>00534         <span class="comment">/* array of active entries&apos; cpu-partition-id */</span>
<a name="l00535"></a><a class="code" href="structlnet__portal.html#ae146b6f48fab29152b5fd0ba78590718">00535</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__portal.html#ae146b6f48fab29152b5fd0ba78590718">ptl_mt_maps</a>[0];
<a name="l00536"></a>00536 } <a class="code" href="structlnet__portal.html">lnet_portal_t</a>;
<a name="l00537"></a>00537 
<a name="l00538"></a><a class="code" href="lib-types_8h.html#aed9709b38d5da9b20504cb5fc4afa9e2">00538</a> <span class="preprocessor">#define LNET_LH_HASH_BITS       12</span>
<a name="l00539"></a><a class="code" href="lib-types_8h.html#a58ed7326ad02f177a95ca99d5f8bad8c">00539</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_LH_HASH_SIZE       (1ULL &lt;&lt; LNET_LH_HASH_BITS)</span>
<a name="l00540"></a><a class="code" href="lib-types_8h.html#ab9feac769921ac852760dcc0457d8b23">00540</a> <span class="preprocessor"></span><span class="preprocessor">#define LNET_LH_HASH_MASK       (LNET_LH_HASH_SIZE - 1)</span>
<a name="l00541"></a>00541 <span class="preprocessor"></span>
<a name="l00542"></a>00542 <span class="comment">/* resource container (ME, MD, EQ) */</span>
<a name="l00543"></a><a class="code" href="structlnet__res__container.html">00543</a> <span class="keyword">struct </span><a class="code" href="structlnet__res__container.html">lnet_res_container</a> {
<a name="l00544"></a><a class="code" href="structlnet__res__container.html#a816d5a59dcf6812dfa95010978d150f3">00544</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            <a class="code" href="structlnet__res__container.html#a816d5a59dcf6812dfa95010978d150f3">rec_type</a>;       <span class="comment">/* container type */</span>
<a name="l00545"></a><a class="code" href="structlnet__res__container.html#ab61ad80b4d9c6f026050f08f40dffbfe">00545</a>         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                   <a class="code" href="structlnet__res__container.html#ab61ad80b4d9c6f026050f08f40dffbfe">rec_lh_cookie</a>;  <span class="comment">/* cookie generator */</span>
<a name="l00546"></a><a class="code" href="structlnet__res__container.html#a2e664685e7af7195ade19dfa6d9a6b52">00546</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__res__container.html#a2e664685e7af7195ade19dfa6d9a6b52">rec_active</a>;     <span class="comment">/* active resource list */</span>
<a name="l00547"></a><a class="code" href="structlnet__res__container.html#aba416b4d402d550b6396ae16a17736c0">00547</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        *<a class="code" href="structlnet__res__container.html#aba416b4d402d550b6396ae16a17736c0">rec_lh_hash</a>;   <span class="comment">/* handle hash */</span>
<a name="l00548"></a>00548 };
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="comment">/* message container */</span>
<a name="l00551"></a><a class="code" href="structlnet__msg__container.html">00551</a> <span class="keyword">struct </span><a class="code" href="structlnet__msg__container.html">lnet_msg_container</a> {
<a name="l00552"></a><a class="code" href="structlnet__msg__container.html#aec7426f93f016fd9a0b9e43de3177a27">00552</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__msg__container.html#aec7426f93f016fd9a0b9e43de3177a27">msc_init</a>;       <span class="comment">/* initialized or not */</span>
<a name="l00553"></a>00553         <span class="comment">/* max # threads finalizing */</span>
<a name="l00554"></a><a class="code" href="structlnet__msg__container.html#a2d455e99c0dbff484e18509060ef1fe3">00554</a>         <span class="keywordtype">int</span>                     <a class="code" href="structlnet__msg__container.html#a2d455e99c0dbff484e18509060ef1fe3">msc_nfinalizers</a>;
<a name="l00555"></a>00555         <span class="comment">/* msgs waiting to complete finalizing */</span>
<a name="l00556"></a><a class="code" href="structlnet__msg__container.html#a25d25d3f88b902e55e89d8b6942265cf">00556</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__msg__container.html#a25d25d3f88b902e55e89d8b6942265cf">msc_finalizing</a>;
<a name="l00557"></a><a class="code" href="structlnet__msg__container.html#a43859c3e9cf2e1535548664fc831a359">00557</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>        <a class="code" href="structlnet__msg__container.html#a43859c3e9cf2e1535548664fc831a359">msc_active</a>;     <span class="comment">/* active message list */</span>
<a name="l00558"></a>00558         <span class="comment">/* threads doing finalization */</span>
<a name="l00559"></a><a class="code" href="structlnet__msg__container.html#a1620cff0b6bff6b6a7873c8382948e18">00559</a>         <span class="keywordtype">void</span>                    **<a class="code" href="structlnet__msg__container.html#a1620cff0b6bff6b6a7873c8382948e18">msc_finalizers</a>;
<a name="l00560"></a>00560 };
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="comment">/* Router Checker states */</span>
<a name="l00563"></a><a class="code" href="lib-types_8h.html#a2ee45e48a2aa6f859f68b2fd287b2a98">00563</a> <span class="preprocessor">#define LNET_RC_STATE_SHUTDOWN          0       </span><span class="comment">/* not started */</span>
<a name="l00564"></a><a class="code" href="lib-types_8h.html#a79b4e07c2f4c32b8b024d78bf0153279">00564</a> <span class="preprocessor">#define LNET_RC_STATE_RUNNING           1       </span><span class="comment">/* started up OK */</span>
<a name="l00565"></a><a class="code" href="lib-types_8h.html#a28b4337c81c4f86285728ce38cbc936d">00565</a> <span class="preprocessor">#define LNET_RC_STATE_STOPPING          2       </span><span class="comment">/* telling thread to stop */</span>
<a name="l00566"></a>00566 
<a name="l00567"></a><a class="code" href="structlnet__t.html">00567</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00568"></a>00568 {
<a name="l00569"></a>00569         <span class="comment">/* CPU partition table of LNet */</span>
<a name="l00570"></a><a class="code" href="structlnet__t.html#a5d08ac79bc169e6b076d613fb5bff4a7">00570</a>         <span class="keyword">struct </span><a class="code" href="structcfs__cpt__table.html">cfs_cpt_table</a>            *ln_cpt_table;
<a name="l00571"></a>00571         <span class="comment">/* number of CPTs in ln_cpt_table */</span>
<a name="l00572"></a><a class="code" href="structlnet__t.html#ae3e62af90a1e56e98db5f61f4c925ac8">00572</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    ln_cpt_number;
<a name="l00573"></a><a class="code" href="structlnet__t.html#aa0299154df4cbb5e3678fe4d5d01f2d7">00573</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    ln_cpt_bits;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         <span class="comment">/* protect LNet resources (ME/MD/EQ) */</span>
<a name="l00576"></a><a class="code" href="structlnet__t.html#a27b9cc1604d420562c55c6db5cbe05dc">00576</a>         <span class="keyword">struct </span><a class="code" href="structcfs__percpt__lock.html">cfs_percpt_lock</a>          *ln_res_lock;
<a name="l00577"></a>00577         <span class="comment">/* # portals */</span>
<a name="l00578"></a><a class="code" href="structlnet__t.html#a51ce914f86d36178f8fd02e1df822aed">00578</a>         <span class="keywordtype">int</span>                             ln_nportals;
<a name="l00579"></a>00579         <span class="comment">/* the vector of portals */</span>
<a name="l00580"></a><a class="code" href="structlnet__t.html#ad95e04ca3be339cf5a9fb7eadbf9972e">00580</a>         <a class="code" href="structlnet__portal.html">lnet_portal_t</a>                   **ln_portals;
<a name="l00581"></a>00581         <span class="comment">/* percpt ME containers */</span>
<a name="l00582"></a><a class="code" href="structlnet__t.html#a452678ffdbb511647ef4f699fcdde2e2">00582</a>         <span class="keyword">struct </span><a class="code" href="structlnet__res__container.html">lnet_res_container</a>       **ln_me_containers;
<a name="l00583"></a>00583         <span class="comment">/* percpt MD container */</span>
<a name="l00584"></a><a class="code" href="structlnet__t.html#a152cba71824a29d15d1e62afd9623edb">00584</a>         <span class="keyword">struct </span><a class="code" href="structlnet__res__container.html">lnet_res_container</a>       **ln_md_containers;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586         <span class="comment">/* Event Queue container */</span>
<a name="l00587"></a><a class="code" href="structlnet__t.html#a9437fca8da9d40aca12e9bd5b85582ed">00587</a>         <span class="keyword">struct </span><a class="code" href="structlnet__res__container.html">lnet_res_container</a>       ln_eq_container;
<a name="l00588"></a><a class="code" href="structlnet__t.html#a0fd14d6d08768076737f53b437374c28">00588</a>         wait_queue_head_t               ln_eq_waitq;
<a name="l00589"></a><a class="code" href="structlnet__t.html#ad777afbc31f3c5b4352f3a49fe384193">00589</a>         spinlock_t                      ln_eq_wait_lock;
<a name="l00590"></a>00590 
<a name="l00591"></a><a class="code" href="structlnet__t.html#a3bef8e34509cc7fdb5eecaa366f2c44e">00591</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                    ln_remote_nets_hbits;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         <span class="comment">/* protect NI, peer table, credits, routers, rtrbuf... */</span>
<a name="l00594"></a><a class="code" href="structlnet__t.html#a2317da329d4d077a2a160d11a9e5eeb9">00594</a>         <span class="keyword">struct </span><a class="code" href="structcfs__percpt__lock.html">cfs_percpt_lock</a>          *ln_net_lock;
<a name="l00595"></a>00595         <span class="comment">/* percpt message containers for active/finalizing/freed message */</span>
<a name="l00596"></a><a class="code" href="structlnet__t.html#aab9e28c09765396d85af7e6e17dbc487">00596</a>         <span class="keyword">struct </span><a class="code" href="structlnet__msg__container.html">lnet_msg_container</a>       **ln_msg_containers;
<a name="l00597"></a><a class="code" href="structlnet__t.html#a9617288331ece355f10c6052fc7fd03b">00597</a>         <a class="code" href="structlnet__counters.html">lnet_counters_t</a>                 **ln_counters;
<a name="l00598"></a><a class="code" href="structlnet__t.html#a3b269ebfd3eb1536e8723c82c281ac35">00598</a>         <span class="keyword">struct </span><a class="code" href="structlnet__peer__table.html">lnet_peer_table</a>          **ln_peer_tables;
<a name="l00599"></a>00599         <span class="comment">/* failure simulation */</span>
<a name="l00600"></a><a class="code" href="structlnet__t.html#a02cb12f6f1b3dd5b8460c490e99b7488">00600</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_test_peers;
<a name="l00601"></a><a class="code" href="structlnet__t.html#a1fc3662bab7c37a609bd3de306db3d78">00601</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_drop_rules;
<a name="l00602"></a><a class="code" href="structlnet__t.html#ae1cde89003b51e958b06430aa7fe3b3b">00602</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_delay_rules;
<a name="l00603"></a>00603 
<a name="l00604"></a><a class="code" href="structlnet__t.html#a526b947edbd9bd9d36e7f18cddd1b78f">00604</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_nis;         <span class="comment">/* LND instances */</span>
<a name="l00605"></a>00605         <span class="comment">/* NIs bond on specific CPT(s) */</span>
<a name="l00606"></a><a class="code" href="structlnet__t.html#ae67ce330c4e1050874857883f080771e">00606</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_nis_cpt;
<a name="l00607"></a>00607         <span class="comment">/* dying LND instances */</span>
<a name="l00608"></a><a class="code" href="structlnet__t.html#a7065bf48bc33a6b7afe62d0e7cca3b42">00608</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_nis_zombie;
<a name="l00609"></a><a class="code" href="structlnet__t.html#a8e00885910043b00e8eb163ebfa23c1a">00609</a>         <a class="code" href="structlnet__ni.html">lnet_ni_t</a>                       *ln_loni;       <span class="comment">/* the loopback NI */</span>
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         <span class="comment">/* remote networks with routes to them */</span>
<a name="l00612"></a><a class="code" href="structlnet__t.html#ab3e96f6e5fd899a5c8d85fc42fa582db">00612</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                *ln_remote_nets_hash;
<a name="l00613"></a>00613         <span class="comment">/* validity stamp */</span>
<a name="l00614"></a><a class="code" href="structlnet__t.html#af52c401ccefe562c2720b984cde1230e">00614</a>         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                           ln_remote_nets_version;
<a name="l00615"></a>00615         <span class="comment">/* list of all known routers */</span>
<a name="l00616"></a><a class="code" href="structlnet__t.html#a707e8baca9b1290b11ef5f71da83e69a">00616</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_routers;
<a name="l00617"></a>00617         <span class="comment">/* validity stamp */</span>
<a name="l00618"></a><a class="code" href="structlnet__t.html#a14bf069f5efd9e4c3558adea26f5a3e3">00618</a>         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                           ln_routers_version;
<a name="l00619"></a>00619         <span class="comment">/* percpt router buffer pools */</span>
<a name="l00620"></a><a class="code" href="structlnet__t.html#a9e81fad139f4b714d1bf62a707082720">00620</a>         <a class="code" href="structlnet__rtrbufpool__t.html">lnet_rtrbufpool_t</a>               **ln_rtrpools;
<a name="l00621"></a>00621 
<a name="l00622"></a><a class="code" href="structlnet__t.html#a7a235518cd5d080b2cf7987a5e00e331">00622</a>         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_md_t</a>                ln_ping_target_md;
<a name="l00623"></a><a class="code" href="structlnet__t.html#abc7c15d1ce277f8bea1b1c5784b92848">00623</a>         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_eq_t</a>                ln_ping_target_eq;
<a name="l00624"></a><a class="code" href="structlnet__t.html#ad838692faf6be550727479ebc71c1358">00624</a>         lnet_ping_info_t                *ln_ping_info;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="comment">/* router checker startup/shutdown state */</span>
<a name="l00627"></a><a class="code" href="structlnet__t.html#ad11000edbecf768d436e0fd38c4fc3fa">00627</a>         <span class="keywordtype">int</span>                             ln_rc_state;
<a name="l00628"></a>00628         <span class="comment">/* router checker&apos;s event queue */</span>
<a name="l00629"></a><a class="code" href="structlnet__t.html#a5bc5bbf49539d0aafd1c4f70e822cb27">00629</a>         <a class="code" href="structlnet__handle__any__t.html" title="Objects maintained by the LNet are accessed through handles.">lnet_handle_eq_t</a>                ln_rc_eqh;
<a name="l00630"></a>00630         <span class="comment">/* rcd still pending on net */</span>
<a name="l00631"></a><a class="code" href="structlnet__t.html#a132fce37b9bb62a89ebe8f981f066c6f">00631</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_rcd_deathrow;
<a name="l00632"></a>00632         <span class="comment">/* rcd ready for free */</span>
<a name="l00633"></a><a class="code" href="structlnet__t.html#a3b2b11f4db16d2843ad291397e592a38">00633</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_rcd_zombie;
<a name="l00634"></a>00634         <span class="comment">/* serialise startup/shutdown */</span>
<a name="l00635"></a><a class="code" href="structlnet__t.html#aa75a5577c91e184bf942e66423714960">00635</a>         <span class="keyword">struct </span>semaphore                ln_rc_signal;
<a name="l00636"></a>00636 
<a name="l00637"></a><a class="code" href="structlnet__t.html#acc341e6e7123afaf8e97f3cebfd0ebef">00637</a>         <span class="keyword">struct </span>mutex                    ln_api_mutex;
<a name="l00638"></a><a class="code" href="structlnet__t.html#a1145a356312916f23b20707589b7c569">00638</a>         <span class="keyword">struct </span>mutex                    ln_lnd_mutex;
<a name="l00639"></a>00639         <span class="comment">/* Have I called LNetNIInit myself? */</span>
<a name="l00640"></a><a class="code" href="structlnet__t.html#ad347c4871e6f2fd060350716293a6502">00640</a>         <span class="keywordtype">int</span>                             ln_niinit_self;
<a name="l00641"></a>00641         <span class="comment">/* LNetNIInit/LNetNIFini counter */</span>
<a name="l00642"></a><a class="code" href="structlnet__t.html#a008b64f97ed48dcad18d54947d4a3a4f">00642</a>         <span class="keywordtype">int</span>                             ln_refcount;
<a name="l00643"></a>00643         <span class="comment">/* shutdown in progress */</span>
<a name="l00644"></a><a class="code" href="structlnet__t.html#aed3f1c926e668aa17b379e39ab05b211">00644</a>         <span class="keywordtype">int</span>                             ln_shutdown;
<a name="l00645"></a>00645 
<a name="l00646"></a><a class="code" href="structlnet__t.html#a60187f1658e1a58a2a5e28be5430e5ae">00646</a>         <span class="keywordtype">int</span>                             ln_routing;     <span class="comment">/* am I a router? */</span>
<a name="l00647"></a><a class="code" href="structlnet__t.html#ab1ab3d0316ca42824371c7e01086b7d7">00647</a>         <a class="code" href="group__lnet__addr.html#gafa13bf627f3dbcdec22141de051a61cd" title="ID of a process in a node.">lnet_pid_t</a>                      ln_pid;         <span class="comment">/* requested pid */</span>
<a name="l00648"></a>00648         <span class="comment">/* uniquely identifies this ni in this epoch */</span>
<a name="l00649"></a><a class="code" href="structlnet__t.html#a439064815a6639de1d683f2a43468b4a">00649</a>         <a class="code" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>                           ln_interface_cookie;
<a name="l00650"></a>00650         <span class="comment">/* registered LNDs */</span>
<a name="l00651"></a><a class="code" href="structlnet__t.html#a5fa9a95701dadcec23d1545331fb5f3c">00651</a>         <span class="keyword">struct </span><a class="code" href="structlist__head.html">list_head</a>                ln_lnds;
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         <span class="comment">/* test protocol compatibility flags */</span>
<a name="l00654"></a><a class="code" href="structlnet__t.html#a485759471b72fd03051cd687bb582531">00654</a>         <span class="keywordtype">int</span>                             ln_testprotocompat;
<a name="l00655"></a>00655 
<a name="l00656"></a>00656         <span class="comment">/* 0 - load the NIs from the mod params</span>
<a name="l00657"></a>00657 <span class="comment">         * 1 - do not load the NIs from the mod params</span>
<a name="l00658"></a>00658 <span class="comment">         * Reverse logic to ensure that other calls to LNetNIInit</span>
<a name="l00659"></a>00659 <span class="comment">         * need no change</span>
<a name="l00660"></a>00660 <span class="comment">         */</span>
<a name="l00661"></a><a class="code" href="structlnet__t.html#a75eea51f6fd59c90b7487ac386865fe4">00661</a>         <span class="keywordtype">bool</span>                            ln_nis_from_mod_params;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663         <span class="comment">/* waitq for router checker.  As long as there are no routes in</span>
<a name="l00664"></a>00664 <span class="comment">         * the list, the router checker will sleep on this queue.  when</span>
<a name="l00665"></a>00665 <span class="comment">         * routes are added the thread will wake up */</span>
<a name="l00666"></a><a class="code" href="structlnet__t.html#acb124c3d2f370dfa4824f7483918b7ae">00666</a>         wait_queue_head_t               ln_rc_waitq;
<a name="l00667"></a>00667 } <a class="code" href="structlnet__t.html">lnet_t</a>;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:33 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
