<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: cl_lock Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cl_lock Struct Reference<br/>
<small>
[<a class="el" href="group__cl__lock.html">cl_lock</a>]</small>
</h1><!-- doxytag: class="cl_lock" -->
<p>Layered client lock.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl__object_8h_source.html">cl_object.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__lock.html#a0b01a26d3cefbee85d1c803a490b34e8">cll_layers</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of slices.  <a href="#a0b01a26d3cefbee85d1c803a490b34e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__lock__descr.html">cl_lock_descr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79">cll_descr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock attribute, extent, <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>, etc.  <a href="#aed90f033b2853b070b0fabad04764d79"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Layered client lock. </p>
<p>Extent locking on the client.</p>
<p>LAYERING</p>
<p>The locking model of the new client code is built around</p>
<p>struct <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a></p>
<p>data-type representing an extent lock on a regular file. <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> is a layered object (much like <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> and <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>), it consists of a header (struct <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>) and a list of layers (struct <a class="el" href="structcl__lock__slice.html" title="Per-layer part of cl_lock.">cl_lock_slice</a>), linked to <a class="el" href="structcl__lock.html#a0b01a26d3cefbee85d1c803a490b34e8" title="List of slices.">cl_lock::cll_layers</a> list through <a class="el" href="structcl__lock__slice.html#ade7bcd39b007dcafd05e98434e3ee990" title="Linkage into cl_lock::cll_layers.">cl_lock_slice::cls_linkage</a>.</p>
<p>Typical <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> consists of the two layers:</p>
<ul>
<li><a class="el" href="structvvp__lock.html">vvp_lock</a> (vvp specific data), and</li>
<li><a class="el" href="structlov__lock.html" title="lov-specific lock state.">lov_lock</a> (lov specific data).</li>
</ul>
<p><a class="el" href="structlov__lock.html" title="lov-specific lock state.">lov_lock</a> contains an array of sub-locks. Each of these sub-locks is a normal <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>: it has a header (struct <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>) and a list of layers:</p>
<ul>
<li><a class="el" href="structlovsub__lock.html" title="Lock state at lovsub layer.">lovsub_lock</a>, and</li>
<li><a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a></li>
</ul>
<p>Each sub-lock is associated with a <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> (representing stripe sub-object or the file to which top-level <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> is associated to), and is linked into that cl_object::coh_locks. In this respect <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> is similar to <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a> (that at lov layer also fans out into multiple sub-objects), and is different from <a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>, that doesn't fan out (there is usually exactly one <a class="el" href="structosc__page.html" title="Page state private for osc layer.">osc_page</a> for every <a class="el" href="structvvp__page.html" title="VVP-private page state.">vvp_page</a>). We shall call vvp-lov portion of the lock a "top-lock" and its lovsub-osc portion a "sub-lock".</p>
<p>LIFE CYCLE</p>
<p><a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> is a cacheless data container for the requirements of locks to complete the IO. <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> is created before I/O starts and destroyed when the I/O is complete.</p>
<p><a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> depends on LDLM lock to fulfill lock semantics. LDLM lock is attached to <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> at OSC layer. LDLM lock is still cacheable.</p>
<p>INTERFACE AND USAGE</p>
<p>Two major methods are supported for <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>: clo_enqueue and clo_cancel. A <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> is enqueued by <a class="el" href="group__cl__lock.html#ga4afe671873f4a7343d9c50c574557fd6" title="Main high-level entry point of cl_lock interface that finds existing or enqueues...">cl_lock_request()</a>, which will call clo_enqueue() methods for each layer to enqueue the lock. At the LOV layer, if a <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> consists of multiple sub cl_locks, each sub locks will be enqueued correspondingly. At OSC layer, the lock enqueue request will tend to reuse cached LDLM lock; otherwise a new LDLM lock will have to be requested from OST side.</p>
<p><a class="el" href="group__cl__lock.html#gaab3c1781a296023121c2641a117a57b1">cl_lock_cancel()</a> must be called to release a <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> after use. clo_cancel() method will be called for each layer to release the resource held by this lock. At OSC layer, the reference count of LDLM lock, which is held at clo_enqueue time, is released.</p>
<p>LDLM lock can only be canceled if there is no <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> using it.</p>
<p>Overall process of the locking during IO operation is as following:</p>
<ul>
<li>once parameters for IO are setup in <a class="el" href="structcl__io.html" title="State for io.">cl_io</a>, <a class="el" href="structcl__io__operations.html#a4211dc9e2bf48da829c2fffd4633b1cf" title="Collect locks for the current iteration of io.">cl_io_operations::cio_lock()</a> is called on each layer. Responsibility of this method is to add locks, needed by a given layer into <a class="el" href="structcl__io.html#a5e4726f4ed7b0cc829ca85342b383875" title="list of locks (to be) acquired by this io.">cl_io.ci_lockset</a>.</li>
</ul>
<ul>
<li>once locks for all layers were collected, they are sorted to avoid dead-locks (<a class="el" href="cl__io_8c.html#a1c8ae3cf1af3a00e72c098782274635d">cl_io_locks_sort()</a>), and enqueued.</li>
</ul>
<ul>
<li>when all locks are acquired, IO is performed;</li>
</ul>
<ul>
<li>locks are released after IO is complete.</li>
</ul>
<p>Striping introduces major additional complexity into locking. The fundamental problem is that it is generally unsafe to actively use (hold) two locks on the different OST servers at the same time, as this introduces inter-server dependency and can lead to cascading evictions.</p>
<p>Basic solution is to sub-divide large read/write IOs into smaller pieces so that no multi-stripe locks are taken (note that this design abandons POSIX read/write semantics). Such pieces ideally can be executed concurrently. At the same time, certain types of IO cannot be sub-divived, without sacrificing correctness. This includes:</p>
<ul>
<li>O_APPEND write, where [0, EOF] lock has to be taken, to guarantee atomicity;</li>
</ul>
<ul>
<li>ftruncate(fd, offset), where [offset, EOF] lock has to be taken.</li>
</ul>
<p>Also, in the case of read(fd, buf, count) or write(fd, buf, count), where buf is a part of memory mapped Lustre file, a lock or locks protecting buf has to be held together with the usual lock on [offset, offset + count].</p>
<p>Interaction with DLM</p>
<p>In the expected setup, <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> is ultimately backed up by a collection of DLM locks (struct <a class="el" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a>). Association between <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> and DLM lock is implemented in osc layer, that also matches DLM events (ASTs, cancellation, etc.) into cl_lock_operation calls. See struct <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> for a more detailed description of interaction with DLM. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01189">1189</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="aed90f033b2853b070b0fabad04764d79"></a><!-- doxytag: member="cl_lock::cll_descr" ref="aed90f033b2853b070b0fabad04764d79" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__lock__descr.html">cl_lock_descr</a> <a class="el" href="structcl__lock.html#aed90f033b2853b070b0fabad04764d79">cl_lock::cll_descr</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lock attribute, extent, <a class="el" href="structcl__object.html" title="Sub-class of lu_object with methods common for objects on the client stacks.">cl_object</a>, etc. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01193">1193</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="echo__client_8c_source.html#l01197">cl_echo_enqueue0()</a>, <a class="el" href="lcommon__misc_8c_source.html#l00124">cl_get_grouplock()</a>, <a class="el" href="glimpse_8c_source.html#l00085">cl_glimpse_lock()</a>, <a class="el" href="cl__lock_8c_source.html#l00104">cl_lock_init()</a>, <a class="el" href="cl__lock_8c_source.html#l00273">cl_lock_print()</a>, <a class="el" href="cl__lock_8c_source.html#l00195">cl_lock_request()</a>, <a class="el" href="cl__lock_8c_source.html#l00052">cl_lock_trace0()</a>, <a class="el" href="lov__lock_8c_source.html#l00126">lov_lock_sub_init()</a>, <a class="el" href="lov__lock_8c_source.html#l00055">lov_sublock_env_get()</a>, <a class="el" href="osc__cache_8c_source.html#l00619">osc_extent_find()</a>, <a class="el" href="osc__lock_8c_source.html#l00743">osc_lock_build_einfo()</a>, <a class="el" href="osc__lock_8c_source.html#l00152">osc_lock_build_policy()</a>, <a class="el" href="osc__lock_8c_source.html#l00809">osc_lock_compatible()</a>, <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, <a class="el" href="osc__lock_8c_source.html#l00853">osc_lock_enqueue_wait()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, <a class="el" href="osc__lock_8c_source.html#l01103">osc_lock_lockless_cancel()</a>, and <a class="el" href="osc__lock_8c_source.html#l01128">osc_lock_set_writer()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b01a26d3cefbee85d1c803a490b34e8"></a><!-- doxytag: member="cl_lock::cll_layers" ref="a0b01a26d3cefbee85d1c803a490b34e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__head.html">list_head</a> <a class="el" href="structcl__lock.html#a0b01a26d3cefbee85d1c803a490b34e8">cl_lock::cll_layers</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of slices. </p>
<p>Immutable after creation. </p>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l01191">1191</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>

<p>Referenced by <a class="el" href="cl__lock_8c_source.html#l00134">cl_lock_at()</a>, <a class="el" href="cl__lock_8c_source.html#l00149">cl_lock_cancel()</a>, <a class="el" href="cl__lock_8c_source.html#l00171">cl_lock_enqueue()</a>, <a class="el" href="cl__lock_8c_source.html#l00085">cl_lock_fini()</a>, <a class="el" href="cl__lock_8c_source.html#l00104">cl_lock_init()</a>, <a class="el" href="cl__lock_8c_source.html#l00273">cl_lock_print()</a>, and <a class="el" href="cl__lock_8c_source.html#l00072">cl_lock_slice_add()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="cl__object_8h_source.html">cl_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:52 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
