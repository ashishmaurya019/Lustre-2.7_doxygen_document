<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: osc_lock Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>osc_lock Struct Reference<br/>
<small>
[<a class="el" href="group__osc.html">osc</a>]</small>
</h1><!-- doxytag: class="osc_lock" -->
<p>osc-private state of <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">ols_cl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">spinlock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641">ols_lock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal lock to protect states, etc.  <a href="#ac103709b1b39897da03bf305179e4641"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7">ols_owner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Owner sleeps on this channel for state change.  <a href="#aca301e8e6fd1eda2ae94eb28c4defae7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a59dd81488c9fbd6733740cfaeed61b56">ols_waiting_list</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">waiting list for this lock to be cancelled  <a href="#a59dd81488c9fbd6733740cfaeed61b56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#aaf07ba3202fb5cd4074a6b98bc41f9e3">ols_wait_entry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">wait entry of ols_waiting_list  <a href="#aaf07ba3202fb5cd4074a6b98bc41f9e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a61ed1b1236e5970e472888bb62c81193">ols_nextlock_oscobj</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list entry for <a class="el" href="structosc__object.html#a7f440305c7a797bfcffc48fb36f73eda">osc_object::oo_ol_list</a>  <a href="#a61ed1b1236e5970e472888bb62c81193"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f">ols_dlmlock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">underlying DLM lock  <a href="#aa628fd5a29fe670d23088616c9c6182f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275">ols_flags</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DLM flags with which <a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a> was enqueued.  <a href="#a6aab2a482c5aa5d06deb2d5a8df7b275"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlustre__handle.html">lustre_handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732">ols_handle</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a> handle  <a href="#a638af9b318fdd4b2d94f549ff165a732"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a4d1369425e04be04518a52972a05bf89">ols_einfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__osc.html#gaa4f7ee68e4b3bb49dcf8c8f62ac36215">osc_lock_state</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">ols_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structost__lvb.html">ost_lvb</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a942265d5ad56c6b1260aa06ae9df6960">ols_lvb</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock value block  <a href="#a942265d5ad56c6b1260aa06ae9df6960"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2">ols_hold</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true, if <a class="el" href="group__LDLM.html#ga2d77135057c3b9123a3ae5704752c946" title="Add specified reader/writer reference to LDLM lock with handle lockh.">ldlm_lock_addref()</a> was called against <a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a>.  <a href="#a40ce4d599eee71b32fa4cf9a5df7cca2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152">ols_has_ref</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is much like <a class="el" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">osc_lock::ols_hold</a>, except that this bit is cleared _after_ reference in released in osc_lock_unuse().  <a href="#ab4a4bb0e1ed33561bda35534caa67152"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed">ols_locklessable</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inherit the lockless attribute from top level <a class="el" href="structcl__io.html" title="State for io.">cl_io</a>.  <a href="#a1bea66d8dcb337d683b314e349d996ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416">ols_glimpse</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">if set, the <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> is a glimpse lock.  <a href="#a5b89f022e42397b2beb321f01ef5d416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001">ols_agl</a>:1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For async glimpse lock.  <a href="#ab1cb6efc7400d813edcfd0a4e6fe3001"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>osc-private state of <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a>. </p>
<p>Interaction with DLM.</p>
<p>Once receive upcall is invoked, <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> remembers a handle of DLM lock in <a class="el" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732" title="osc_lock::ols_lock handle">osc_lock::ols_handle</a> and a pointer to that lock in <a class="el" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f" title="underlying DLM lock">osc_lock::ols_dlmlock</a>.</p>
<p>This pointer is protected through a reference, acquired by osc_lock_upcall0(). Also, an additional reference is acquired by <a class="el" href="group__LDLM.html#ga2d77135057c3b9123a3ae5704752c946" title="Add specified reader/writer reference to LDLM lock with handle lockh.">ldlm_lock_addref()</a> call protecting the lock from cancellation, until osc_lock_unuse() releases it.</p>
<p>Below is a description of how lock references are acquired and released inside of DLM.</p>
<ul>
<li>When new lock is created and enqueued to the server (<a class="el" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client-side lock enqueue.">ldlm_cli_enqueue()</a>)<ul>
<li><a class="el" href="ldlm__internal_8h.html#af29553310c1f2362ca2145806a061f27" title="Create and fill in new LDLM lock with specified properties.">ldlm_lock_create()</a><ul>
<li><a class="el" href="ldlm__lock_8c.html#ac99ac7b91d3210a55c99a1247cb85003" title="Allocate and initialize new lock structure.">ldlm_lock_new()</a>: initializes a lock with 2 references. One for the caller (released when reply from the server is received, or on error), and another for the hash table.</li>
</ul>
</li>
<li><a class="el" href="ldlm__internal_8h.html#a6731d485dba03ece37507d6b4bebe97b" title="Add specified reader/writer reference to LDLM lock lock.">ldlm_lock_addref_internal()</a>: protects the lock from cancellation.</li>
</ul>
</li>
</ul>
<ul>
<li>When reply is received from the server (<a class="el" href="osc__request_8c.html#aac04a950bb72380b3974c40e0fceb6d6">osc_enqueue_interpret()</a>)<ul>
<li><a class="el" href="group__ldlm__cli__api.html#gac421005283912bb5186b035013aa58c0" title="Finishing portion of client lock enqueue code.">ldlm_cli_enqueue_fini()</a><ul>
<li><a class="el" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT()</a>: releases caller reference acquired by <a class="el" href="ldlm__lock_8c.html#ac99ac7b91d3210a55c99a1247cb85003" title="Allocate and initialize new lock structure.">ldlm_lock_new()</a>.</li>
<li>if (rc != 0) <a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a>: error case: matches <a class="el" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client-side lock enqueue.">ldlm_cli_enqueue()</a>.</li>
</ul>
</li>
<li><a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a>: for async locks, matches <a class="el" href="group__ldlm__cli__api.html#gac3edcad1b11e283d6ef8455a2b598b07" title="Client-side lock enqueue.">ldlm_cli_enqueue()</a>.</li>
</ul>
</li>
</ul>
<ul>
<li>When lock is being cancelled (<a class="el" href="group__LDLM.html#gadec8a773eb3b13c995cf35a4d013393b" title="Attempts to cancel LDLM lock lock that has no reader/writer references.">ldlm_lock_cancel()</a>)<ul>
<li><a class="el" href="group__LDLM.html#ga833125f7d72f8e77cb16c031c56dd2a0" title="Destroys a LDLM lock lock.">ldlm_lock_destroy()</a><ul>
<li><a class="el" href="group__LDLM.html#ga5945b4d89a157c2e0fb6d955b3bf0c3f" title="Release a temporary lock reference obtained by ldlm_handle2lock() or __ldlm_handle2lock()...">LDLM_LOCK_PUT()</a>: releases hash-table reference acquired by <a class="el" href="ldlm__lock_8c.html#ac99ac7b91d3210a55c99a1247cb85003" title="Allocate and initialize new lock structure.">ldlm_lock_new()</a>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> is detached from <a class="el" href="structldlm__lock.html" title="LDLM lock structure.">ldlm_lock</a> by <a class="el" href="group__osc.html#ga0b1ea64f21458b5bb73af82b0feda0df" title="Breaks a link between osc_lock and dlm_lock.">osc_lock_detach()</a> that is called either when lock is cancelled (osc_lock_blocking()), or when locks is deleted without cancellation (e.g., from cl_locks_prune()). In the latter case ldlm lock remains in memory, and can be re-attached to <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> in the future. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00260">260</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ab1cb6efc7400d813edcfd0a4e6fe3001"></a><!-- doxytag: member="osc_lock::ols_agl" ref="ab1cb6efc7400d813edcfd0a4e6fe3001" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structosc__lock.html#ab1cb6efc7400d813edcfd0a4e6fe3001">osc_lock::ols_agl</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For async glimpse lock. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00290">290</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, and <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>.</p>

</div>
</div>
<a class="anchor" id="aaea6569665985de217dd5948d806db01"></a><!-- doxytag: member="osc_lock::ols_cl" ref="aaea6569665985de217dd5948d806db01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__lock__slice.html">cl_lock_slice</a> <a class="el" href="structosc__lock.html#aaea6569665985de217dd5948d806db01">osc_lock::ols_cl</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00261">261</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__cl__internal_8h_source.html#l00555">cl2osc_lock()</a>, <a class="el" href="osc__cache_8c_source.html#l00619">osc_extent_find()</a>, <a class="el" href="osc__lock_8c_source.html#l00809">osc_lock_compatible()</a>, <a class="el" href="osc__lock_8c_source.html#l00853">osc_lock_enqueue_wait()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, <a class="el" href="osc__lock_8c_source.html#l00065">osc_lock_is_lockless()</a>, <a class="el" href="osc__lock_8c_source.html#l01128">osc_lock_set_writer()</a>, <a class="el" href="osc__lock_8c_source.html#l00768">osc_lock_to_lockless()</a>, and <a class="el" href="osc__lock_8c_source.html#l00302">osc_lock_upcall()</a>.</p>

</div>
</div>
<a class="anchor" id="aa628fd5a29fe670d23088616c9c6182f"></a><!-- doxytag: member="osc_lock::ols_dlmlock" ref="aa628fd5a29fe670d23088616c9c6182f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structldlm__lock.html">ldlm_lock</a>* <a class="el" href="structosc__lock.html#aa628fd5a29fe670d23088616c9c6182f">osc_lock::ols_dlmlock</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>underlying DLM lock </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00274">274</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l00619">osc_extent_find()</a>, <a class="el" href="osc__lock_8c_source.html#l00693">osc_ldlm_weigh_ast()</a>, <a class="el" href="osc__lock_8c_source.html#l01025">osc_lock_detach()</a>, <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, <a class="el" href="osc__lock_8c_source.html#l00141">osc_lock_fini()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, <a class="el" href="osc__lock_8c_source.html#l00088">osc_lock_invariant()</a>, <a class="el" href="osc__lock_8c_source.html#l01103">osc_lock_lockless_cancel()</a>, and <a class="el" href="osc__lock_8c_source.html#l01084">osc_lock_print()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d1369425e04be04518a52972a05bf89"></a><!-- doxytag: member="osc_lock::ols_einfo" ref="a4d1369425e04be04518a52972a05bf89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structldlm__enqueue__info.html">ldlm_enqueue_info</a> <a class="el" href="structosc__lock.html#a4d1369425e04be04518a52972a05bf89">osc_lock::ols_einfo</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00279">279</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l01025">osc_lock_detach()</a>, <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, and <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a6aab2a482c5aa5d06deb2d5a8df7b275"></a><!-- doxytag: member="osc_lock::ols_flags" ref="a6aab2a482c5aa5d06deb2d5a8df7b275" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uapi__kernelcomm_8h.html#adc2adfee3162ec44eb82da5f869a806c">__u64</a> <a class="el" href="structosc__lock.html#a6aab2a482c5aa5d06deb2d5a8df7b275">osc_lock::ols_flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DLM flags with which <a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a> was enqueued. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00276">276</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l01066">osc_lock_cancel()</a>, <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, <a class="el" href="osc__lock_8c_source.html#l01084">osc_lock_print()</a>, and <a class="el" href="osc__lock_8c_source.html#l00302">osc_lock_upcall()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b89f022e42397b2beb321f01ef5d416"></a><!-- doxytag: member="osc_lock::ols_glimpse" ref="a5b89f022e42397b2beb321f01ef5d416" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structosc__lock.html#a5b89f022e42397b2beb321f01ef5d416">osc_lock::ols_glimpse</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>if set, the <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> is a glimpse lock. </p>
<p>For glimpse locks, we treat the EVAVAIL error as torerable, this will make upper logic happy to wait all glimpse locks to each OSTs to be completed. Glimpse lock converts to normal lock if the server lock is granted. Glimpse lock should be destroyed immediately after use. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00290">290</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l00809">osc_lock_compatible()</a>, <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, <a class="el" href="osc__lock_8c_source.html#l00768">osc_lock_to_lockless()</a>, and <a class="el" href="osc__lock_8c_source.html#l00302">osc_lock_upcall()</a>.</p>

</div>
</div>
<a class="anchor" id="a638af9b318fdd4b2d94f549ff165a732"></a><!-- doxytag: member="osc_lock::ols_handle" ref="a638af9b318fdd4b2d94f549ff165a732" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlustre__handle.html">lustre_handle</a> <a class="el" href="structosc__lock.html#a638af9b318fdd4b2d94f549ff165a732">osc_lock::ols_handle</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a> handle </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00278">278</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l01025">osc_lock_detach()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, <a class="el" href="osc__lock_8c_source.html#l00088">osc_lock_invariant()</a>, and <a class="el" href="osc__lock_8c_source.html#l01084">osc_lock_print()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4a4bb0e1ed33561bda35534caa67152"></a><!-- doxytag: member="osc_lock::ols_has_ref" ref="ab4a4bb0e1ed33561bda35534caa67152" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152">osc_lock::ols_has_ref</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this is much like <a class="el" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2" title="true, if ldlm_lock_addref() was called against osc_lock::ols_lock.">osc_lock::ols_hold</a>, except that this bit is cleared _after_ reference in released in osc_lock_unuse(). </p>
<p>This fine distinction is needed because:</p>
<ul>
<li>if ldlm lock still has a reference, osc_ast_data_get() needs to return associated <a class="el" href="structcl__lock.html" title="Layered client lock.">cl_lock</a> (so that a flag is needed that is cleared after <a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a> returned), and</li>
</ul>
<ul>
<li><a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a> can invoke blocking ast (for a LDLM_FL_CBPENDING lock), and <a class="el" href="structosc__lock.html" title="osc-private state of cl_lock.">osc_lock</a> functions like <a class="el" href="group__osc.html#gacc121e00f4060228eda6e7504a4cc1d0" title="Implements cl_lock_operations::clo_cancel() method for osc layer.">osc_lock_cancel()</a> called from there need to know whether to release lock reference (so that a flag is needed that is cleared before <a class="el" href="group__LDLM.html#ga82ed1d0d1d2788cad8813e69df77d625" title="Decrease reader/writer refcount for LDLM lock with handle lockh.">ldlm_lock_decref()</a> is called). </li>
</ul>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00290">290</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l01025">osc_lock_detach()</a>, and <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>.</p>

</div>
</div>
<a class="anchor" id="a40ce4d599eee71b32fa4cf9a5df7cca2"></a><!-- doxytag: member="osc_lock::ols_hold" ref="a40ce4d599eee71b32fa4cf9a5df7cca2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structosc__lock.html#a40ce4d599eee71b32fa4cf9a5df7cca2">osc_lock::ols_hold</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>true, if <a class="el" href="group__LDLM.html#ga2d77135057c3b9123a3ae5704752c946" title="Add specified reader/writer reference to LDLM lock with handle lockh.">ldlm_lock_addref()</a> was called against <a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641" title="Internal lock to protect states, etc.">osc_lock::ols_lock</a>. </p>
<p>This is used for sanity checking.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structosc__lock.html#ab4a4bb0e1ed33561bda35534caa67152" title="this is much like osc_lock::ols_hold, except that this bit is cleared _after_ reference...">osc_lock::ols_has_ref</a> </dd></dl>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00290">290</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l00619">osc_extent_find()</a>, <a class="el" href="osc__lock_8c_source.html#l01025">osc_lock_detach()</a>, <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, and <a class="el" href="osc__lock_8c_source.html#l00088">osc_lock_invariant()</a>.</p>

</div>
</div>
<a class="anchor" id="ac103709b1b39897da03bf305179e4641"></a><!-- doxytag: member="osc_lock::ols_lock" ref="ac103709b1b39897da03bf305179e4641" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spinlock_t <a class="el" href="structosc__lock.html#ac103709b1b39897da03bf305179e4641">osc_lock::ols_lock</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal lock to protect states, etc. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00263">263</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l00853">osc_lock_enqueue_wait()</a>, <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, and <a class="el" href="osc__lock_8c_source.html#l00832">osc_lock_wake_waiters()</a>.</p>

</div>
</div>
<a class="anchor" id="a1bea66d8dcb337d683b314e349d996ed"></a><!-- doxytag: member="osc_lock::ols_locklessable" ref="a1bea66d8dcb337d683b314e349d996ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structosc__lock.html#a1bea66d8dcb337d683b314e349d996ed">osc_lock::ols_locklessable</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>inherit the lockless attribute from top level <a class="el" href="structcl__io.html" title="State for io.">cl_io</a>. </p>
<p>If true, osc_lock_enqueue is able to tolerate the -EUSERS error. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00290">290</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, <a class="el" href="osc__lock_8c_source.html#l00088">osc_lock_invariant()</a>, <a class="el" href="osc__lock_8c_source.html#l00768">osc_lock_to_lockless()</a>, and <a class="el" href="osc__lock_8c_source.html#l00302">osc_lock_upcall()</a>.</p>

</div>
</div>
<a class="anchor" id="a942265d5ad56c6b1260aa06ae9df6960"></a><!-- doxytag: member="osc_lock::ols_lvb" ref="a942265d5ad56c6b1260aa06ae9df6960" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structost__lvb.html">ost_lvb</a> <a class="el" href="structosc__lock.html#a942265d5ad56c6b1260aa06ae9df6960">osc_lock::ols_lvb</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lock value block </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00282">282</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, <a class="el" href="osc__lock_8c_source.html#l01084">osc_lock_print()</a>, and <a class="el" href="osc__lock_8c_source.html#l00302">osc_lock_upcall()</a>.</p>

</div>
</div>
<a class="anchor" id="a61ed1b1236e5970e472888bb62c81193"></a><!-- doxytag: member="osc_lock::ols_nextlock_oscobj" ref="a61ed1b1236e5970e472888bb62c81193" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__head.html">list_head</a> <a class="el" href="structosc__lock.html#a61ed1b1236e5970e472888bb62c81193">osc_lock::ols_nextlock_oscobj</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>list entry for <a class="el" href="structosc__object.html#a7f440305c7a797bfcffc48fb36f73eda">osc_object::oo_ol_list</a> </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00271">271</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l00693">osc_ldlm_weigh_ast()</a>, <a class="el" href="osc__lock_8c_source.html#l00853">osc_lock_enqueue_wait()</a>, <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, and <a class="el" href="osc__lock_8c_source.html#l00832">osc_lock_wake_waiters()</a>.</p>

</div>
</div>
<a class="anchor" id="aca301e8e6fd1eda2ae94eb28c4defae7"></a><!-- doxytag: member="osc_lock::ols_owner" ref="aca301e8e6fd1eda2ae94eb28c4defae7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcl__sync__io.html">cl_sync_io</a>* <a class="el" href="structosc__lock.html#aca301e8e6fd1eda2ae94eb28c4defae7">osc_lock::ols_owner</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Owner sleeps on this channel for state change. </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00265">265</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, <a class="el" href="osc__lock_8c_source.html#l00853">osc_lock_enqueue_wait()</a>, <a class="el" href="osc__lock_8c_source.html#l01084">osc_lock_print()</a>, <a class="el" href="osc__lock_8c_source.html#l00302">osc_lock_upcall()</a>, and <a class="el" href="osc__lock_8c_source.html#l00832">osc_lock_wake_waiters()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7c08a350800344211d420d88f66bc7c"></a><!-- doxytag: member="osc_lock::ols_state" ref="ae7c08a350800344211d420d88f66bc7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__osc.html#gaa4f7ee68e4b3bb49dcf8c8f62ac36215">osc_lock_state</a> <a class="el" href="structosc__lock.html#ae7c08a350800344211d420d88f66bc7c">osc_lock::ols_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00280">280</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__cache_8c_source.html#l00619">osc_extent_find()</a>, <a class="el" href="osc__lock_8c_source.html#l01066">osc_lock_cancel()</a>, <a class="el" href="osc__lock_8c_source.html#l00809">osc_lock_compatible()</a>, <a class="el" href="osc__lock_8c_source.html#l00925">osc_lock_enqueue()</a>, <a class="el" href="osc__lock_8c_source.html#l00243">osc_lock_granted()</a>, <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, <a class="el" href="osc__lock_8c_source.html#l00088">osc_lock_invariant()</a>, <a class="el" href="osc__lock_8c_source.html#l01084">osc_lock_print()</a>, <a class="el" href="osc__lock_8c_source.html#l00768">osc_lock_to_lockless()</a>, and <a class="el" href="osc__lock_8c_source.html#l00302">osc_lock_upcall()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf07ba3202fb5cd4074a6b98bc41f9e3"></a><!-- doxytag: member="osc_lock::ols_wait_entry" ref="aaf07ba3202fb5cd4074a6b98bc41f9e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__head.html">list_head</a> <a class="el" href="structosc__lock.html#aaf07ba3202fb5cd4074a6b98bc41f9e3">osc_lock::ols_wait_entry</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>wait entry of ols_waiting_list </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00269">269</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l00853">osc_lock_enqueue_wait()</a>, <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, and <a class="el" href="osc__lock_8c_source.html#l00832">osc_lock_wake_waiters()</a>.</p>

</div>
</div>
<a class="anchor" id="a59dd81488c9fbd6733740cfaeed61b56"></a><!-- doxytag: member="osc_lock::ols_waiting_list" ref="a59dd81488c9fbd6733740cfaeed61b56" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__head.html">list_head</a> <a class="el" href="structosc__lock.html#a59dd81488c9fbd6733740cfaeed61b56">osc_lock::ols_waiting_list</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>waiting list for this lock to be cancelled </p>

<p>Definition at line <a class="el" href="osc__cl__internal_8h_source.html#l00267">267</a> of file <a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a>.</p>

<p>Referenced by <a class="el" href="osc__lock_8c_source.html#l00853">osc_lock_enqueue_wait()</a>, <a class="el" href="osc__lock_8c_source.html#l01162">osc_lock_init()</a>, and <a class="el" href="osc__lock_8c_source.html#l00832">osc_lock_wake_waiters()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/osc/<a class="el" href="osc__cl__internal_8h_source.html">osc_cl_internal.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:54 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
