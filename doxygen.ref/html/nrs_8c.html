<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: lustre/ptlrpc/nrs.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lustre/ptlrpc/nrs.c File Reference</h1><code>#include &lt;<a class="el" href="obd__support_8h_source.html">obd_support.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="obd__class_8h_source.html">obd_class.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="lustre__net_8h_source.html">lustre_net.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="lprocfs__status_8h_source.html">lprocfs_status.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="libcfs_8h_source.html">libcfs/libcfs.h</a>&gt;</code><br/>
<code>#include &quot;<a class="el" href="ptlrpc__internal_8h_source.html">ptlrpc_internal.h</a>&quot;</code><br/>

<p><a href="nrs_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#abda60744d497fcfe370cfd6b2d65c7ed">DEBUG_SUBSYSTEM</a>&nbsp;&nbsp;&nbsp;S_RPC</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">nrs  <a href="#abda60744d497fcfe370cfd6b2d65c7ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnrs__core.html">nrs_core</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#ad543d45ab909c062d714baabb15576ca">nrs_core</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NRS core object.  <a href="#ad543d45ab909c062d714baabb15576ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a464be72e6ccb20f6cb3f01cadc709399">nrs_policy_init</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a9ec886b1c98564c4fb88f460ad63c892">nrs_policy_fini</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a0cd19c55101ad1e38a172821fee9f1f8">nrs_policy_ctl_locked</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a> opc, void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#ab0431763f8af37f9f10dac5d884bab3b">nrs_policy_stop0</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a6c7661d26dd212aae15851a38e71ade4">nrs_policy_stop_locked</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a8db69645bb5947003ada611a8cfe89d2">nrs_policy_stop_primary</a> (struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *nrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transitions the <em>nrs</em> NRS head's primary policy to <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a3e737ea7aa14781899e40eb0343c9a39" title="Policy is progress of stopping.">ptlrpc_nrs_pol_state::NRS_POL_STATE_STOPPING</a> and if the policy has no pending usage references, to <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a60ca6b44260cb20198b1d5d4747a6257" title="Policies are at this state either at the start of their life, or transition here...">ptlrpc_nrs_pol_state::NRS_POL_STATE_STOPPED</a>.  <a href="#a8db69645bb5947003ada611a8cfe89d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a4630e3b5b9e989a55f772264a9621b78">nrs_policy_start_locked</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, char *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transitions a policy across the ptlrpc_nrs_pol_state range of values, in response to an lprocfs command to start a policy.  <a href="#a4630e3b5b9e989a55f772264a9621b78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a9a8a706937e7f4af4dc72337fbe40814">nrs_policy_get_locked</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increases the policy's usage reference count.  <a href="#a9a8a706937e7f4af4dc72337fbe40814"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a6a213cf1db771ef07a3e0c146ddc68e6">nrs_policy_put_locked</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decreases the policy's usage reference count, and stops the policy in case it was already stopping and have no more outstanding usage references (which indicates it has no more queued or started requests, and can be safely stopped).  <a href="#a6a213cf1db771ef07a3e0c146ddc68e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a9630b070e1b5be35664de89cb9c0996f">nrs_policy_put</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#aa3068360b11a41b43f942cae4332c23e">nrs_policy_find_locked</a> (struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *nrs, char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find and return a policy by name.  <a href="#aa3068360b11a41b43f942cae4332c23e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a482dd8acde17c378429a74d5428c21ae">nrs_resource_put</a> (struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *res)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release references for the resource hierarchy moving upwards towards the policy instance resource.  <a href="#a482dd8acde17c378429a74d5428c21ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#ac9f61820f84d81d579b1b47be3985a49">nrs_resource_get</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq, bool moving_req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains references for each resource in the resource hierarchy for request <em>nrq</em> if it is to be handled by <em>policy</em>.  <a href="#ac9f61820f84d81d579b1b47be3985a49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a6ba673781ab2ba2e38ab4c17c1e26cff">nrs_resource_get_safe</a> (struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *nrs, struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq, struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> **resp, bool moving_req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains resources for the resource hierarchies and policy references for the fallback and current primary policy (if any), that will later be used to handle request <em>nrq</em>.  <a href="#a6ba673781ab2ba2e38ab4c17c1e26cff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a391d93543ea4b81e59ded6346e0ee92e">nrs_resource_put_safe</a> (struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> **resp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases references to resource hierarchies and policies, because they are no longer required; used when request handling has been completed, or the request is moving to the high priority NRS head.  <a href="#a391d93543ea4b81e59ded6346e0ee92e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a03fa2d011c5fcb5c16cd48b910775cc0">nrs_request_get</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy, bool peek, bool force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains an NRS request from <em>policy</em> for handling or examination; the request should be removed in the 'handling' case.  <a href="#a03fa2d011c5fcb5c16cd48b910775cc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#ac63065fc9f6fc04df590c34a1da9a1cf">nrs_request_enqueue</a> (struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueues request <em>nrq</em> for later handling, via one one the policies for which resources where earlier obtained via <a class="el" href="nrs_8c.html#a6ba673781ab2ba2e38ab4c17c1e26cff" title="Obtains resources for the resource hierarchies and policy references for the fallback...">nrs_resource_get_safe()</a>.  <a href="#ac63065fc9f6fc04df590c34a1da9a1cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a1a55a7f119a21dbba1ef14e86b75bf5f">nrs_request_stop</a> (struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *nrq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a request has been handled.  <a href="#a1a55a7f119a21dbba1ef14e86b75bf5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#afbd695867fa6a33db4e9338da1e78225">nrs_policy_ctl</a> (struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *nrs, char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a> opc, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handler for operations that can be carried out on policies.  <a href="#afbd695867fa6a33db4e9338da1e78225"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a98db68c1f20f3dc3f47786ab0f73615f">nrs_policy_unregister</a> (struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *nrs, char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters a policy by name.  <a href="#a98db68c1f20f3dc3f47786ab0f73615f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a90bbaf18e29bc89bc9413c3f33e67767">nrs_policy_register</a> (struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *nrs, struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a policy from  descriptor <em>desc</em> with NRS head <em>nrs</em>.  <a href="#a90bbaf18e29bc89bc9413c3f33e67767"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#adaa29dac38998de2d61c893c40692886">ptlrpc_nrs_req_add_nolock</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue request <em>req</em> using one of the policies its resources are referring to.  <a href="#adaa29dac38998de2d61c893c40692886"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a12a7e4c91309d6d9c9ebac14e75cfb96">ptlrpc_nrs_hpreq_add_nolock</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a request on the high priority NRS head.  <a href="#a12a7e4c91309d6d9c9ebac14e75cfb96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a7978fc12e9b90b634434afcb040704e5">nrs_policy_compatible</a> (const struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc, const struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a boolean predicate indicating whether the policy described by <em>desc</em> is adequate for use with service <em>svc</em>.  <a href="#a7978fc12e9b90b634434afcb040704e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a8efb55101ffc6a1a76fffca83975af92">nrs_register_policies_locked</a> (struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *nrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers all compatible policies in <a class="el" href="structnrs__core.html#a6bd6f7f96d860c488aff9d4e638d272d" title="List of all policy descriptors registered with NRS core; protected by nrs_core::nrs_mutex...">nrs_core.nrs_policies</a>, for NRS head <em>nrs</em>.  <a href="#a8efb55101ffc6a1a76fffca83975af92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a8064f6a6223a2b93724fb16a58a46c59">nrs_svcpt_setup_locked0</a> (struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *nrs, struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *svcpt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes NRS head <em>nrs</em> of service partition <em>svcpt</em>, and registers all compatible policies in NRS core, with the NRS head.  <a href="#a8064f6a6223a2b93724fb16a58a46c59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#adfbbff6846bdd8aeeb06722e0e77aabc">nrs_svcpt_setup_locked</a> (struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *svcpt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates a regular and optionally a high-priority NRS head (if the service handles high-priority RPCs), and then registers all available compatible policies on those NRS heads.  <a href="#adfbbff6846bdd8aeeb06722e0e77aabc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a63a8af62fd1f0baa77f225c25ea41bae">nrs_svcpt_cleanup_locked</a> (struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *svcpt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters all policies on all available NRS heads in a service partition; called at PTLRPC service unregistration time.  <a href="#a63a8af62fd1f0baa77f225c25ea41bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#acb10df06d5d3d8b6320247eeb2e6dc16">nrs_policy_find_desc_locked</a> (const char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the descriptor for a policy as identified by by <em>name</em>.  <a href="#acb10df06d5d3d8b6320247eeb2e6dc16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a2cc98defe939efdcf9bdf5f9f520d08a">nrs_policy_unregister_locked</a> (struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the policy from all supported NRS heads of all partitions of all PTLRPC services.  <a href="#a2cc98defe939efdcf9bdf5f9f520d08a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#ga5de7e78460dcd401c48a46cf67ac9851">ptlrpc_nrs_policy_register</a> (struct <a class="el" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a new policy with NRS core.  <a href="group__nrs.html#ga5de7e78460dcd401c48a46cf67ac9851"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#gafa9c71a2f34f3e56750abaeba0d358f8">ptlrpc_nrs_policy_unregister</a> (struct <a class="el" href="structptlrpc__nrs__pol__conf.html">ptlrpc_nrs_pol_conf</a> *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters a previously registered policy with NRS core.  <a href="group__nrs.html#gafa9c71a2f34f3e56750abaeba0d358f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a107d0adae381864f5c53de6cc805a59f">ptlrpc_service_nrs_setup</a> (struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup NRS heads on all service partitions of service <em>svc</em>, and register all compatible policies on those NRS heads.  <a href="#a107d0adae381864f5c53de6cc805a59f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#addde07332222429e28ec6cb0a78ca460">ptlrpc_service_nrs_cleanup</a> (struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters all policies on all service partitions of service <em>svc</em>.  <a href="#addde07332222429e28ec6cb0a78ca460"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a040685413af9d845199d4866c37316b8">ptlrpc_nrs_req_initialize</a> (struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *svcpt, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, bool hp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains NRS head resources for request <em>req</em>.  <a href="#a040685413af9d845199d4866c37316b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#aa35053963b23dd9e0dc17f6b214da481">ptlrpc_nrs_req_finalize</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases resources for a request; is called after the request has been handled.  <a href="#aa35053963b23dd9e0dc17f6b214da481"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a41d6af6b26aebda69530fe3537266dfd">ptlrpc_nrs_req_stop_nolock</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a376ea8577919ec8eb729d36195bcbf1a">ptlrpc_nrs_req_add</a> (struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *svcpt, struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, bool hp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueues request <em>req</em> on either the regular or high-priority NRS head of service partition <em>svcpt</em>.  <a href="#a376ea8577919ec8eb729d36195bcbf1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a735bd46503efe2446339ecdded1cbef5">nrs_request_removed</a> (struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a54ec453671a55cf9b6012577c03eaca6">ptlrpc_nrs_req_get_nolock0</a> (struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *svcpt, bool hp, bool peek, bool force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains a request for handling from an NRS head of service partition <em>svcpt</em>.  <a href="#a54ec453671a55cf9b6012577c03eaca6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a7da7205147ceea7096dc6bdfe96a2d4c">ptlrpc_nrs_req_del_nolock</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dequeues request <em>req</em> from the policy it has been enqueued on.  <a href="#a7da7205147ceea7096dc6bdfe96a2d4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#acd9117d134d826c1aaed14e2e8d5f57d">ptlrpc_nrs_req_pending_nolock</a> (struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *svcpt, bool hp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether there are any requests currently enqueued on any of the policies of service partition's <em>svcpt</em> NRS head specified by <em>hp</em>.  <a href="#acd9117d134d826c1aaed14e2e8d5f57d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#adca0e099406dbe4e2f80aed92e475774">ptlrpc_nrs_req_throttling_nolock</a> (struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *svcpt, bool hp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether NRS policy is throttling reqeust.  <a href="#adca0e099406dbe4e2f80aed92e475774"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrs.html#gae517dc74ee0bcadf3b53f6ed4c57e6de">ptlrpc_nrs_req_hp_move</a> (struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves request <em>req</em> from the regular to the high-priority NRS head.  <a href="group__nrs.html#gae517dc74ee0bcadf3b53f6ed4c57e6de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a4970fb4b913c82e5566a7ecbcd8a26b7">ptlrpc_nrs_policy_control</a> (const struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *svc, enum <a class="el" href="group__nrs.html#ga79e63c48a144326744316f397c52a883">ptlrpc_nrs_queue_type</a> queue, char *<a class="el" href="mdt__coordinator_8c.html#a5ac083a645d964373f022d03df4849c8">name</a>, enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a> opc, bool single, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out a control operation <em>opc</em> on the policy identified by the human-readable <em>name</em>, on either all partitions, or only on the first partition of service <em>svc</em>.  <a href="#a4970fb4b913c82e5566a7ecbcd8a26b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#a88b6333c295cad770117c12285bc8382">ptlrpc_nrs_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds all policies that ship with the ptlrpc module, to NRS core's list of policies <em><a class="el" href="structnrs__core.html#a6bd6f7f96d860c488aff9d4e638d272d" title="List of all policy descriptors registered with NRS core; protected by nrs_core::nrs_mutex...">nrs_core.nrs_policies</a></em>.  <a href="#a88b6333c295cad770117c12285bc8382"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nrs_8c.html#ab94623e611d2b1ab7143fc656f8df4b3">ptlrpc_nrs_fini</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all policy descriptors from <a class="el" href="structnrs__core.html#a6bd6f7f96d860c488aff9d4e638d272d" title="List of all policy descriptors registered with NRS core; protected by nrs_core::nrs_mutex...">nrs_core::nrs_policies</a>, and frees the policy descriptors.  <a href="#ab94623e611d2b1ab7143fc656f8df4b3"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="abda60744d497fcfe370cfd6b2d65c7ed"></a><!-- doxytag: member="nrs.c::DEBUG_SUBSYSTEM" ref="abda60744d497fcfe370cfd6b2d65c7ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_SUBSYSTEM&nbsp;&nbsp;&nbsp;S_RPC</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>nrs </p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00042">42</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a7978fc12e9b90b634434afcb040704e5"></a><!-- doxytag: member="nrs.c::nrs_policy_compatible" ref="a7978fc12e9b90b634434afcb040704e5" args="(const struct ptlrpc_service *svc, const struct ptlrpc_nrs_pol_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool nrs_policy_compatible </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *&nbsp;</td>
          <td class="paramname"> <em>svc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a boolean predicate indicating whether the policy described by <em>desc</em> is adequate for use with service <em>svc</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svc</em>&nbsp;</td><td>the service </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>the policy descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>the policy is not compatible with the service </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>the policy is compatible with the service </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00885">885</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="lustre__nrs_8h_source.html#l00453">ptlrpc_nrs_pol_desc::pd_compat</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01099">nrs_policy_unregister_locked()</a>, <a class="el" href="nrs_8c_source.html#l00904">nrs_register_policies_locked()</a>, <a class="el" href="nrs_8c_source.html#l01165">ptlrpc_nrs_policy_register()</a>, <a class="el" href="nrs_8c_source.html#l01435">ptlrpc_service_nrs_cleanup()</a>, and <a class="el" href="nrs_8c_source.html#l01390">ptlrpc_service_nrs_setup()</a>.</p>

</div>
</div>
<a class="anchor" id="afbd695867fa6a33db4e9338da1e78225"></a><!-- doxytag: member="nrs.c::nrs_policy_ctl" ref="afbd695867fa6a33db4e9338da1e78225" args="(struct ptlrpc_nrs *nrs, char *name, enum ptlrpc_nrs_ctl opc, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_policy_ctl </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *&nbsp;</td>
          <td class="paramname"> <em>nrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a>&nbsp;</td>
          <td class="paramname"> <em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handler for operations that can be carried out on policies. </p>
<p>Handles opcodes that are common to all policy types within NRS core, and passes any unknown opcodes to the policy-specific control function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrs</em>&nbsp;</td><td>the NRS head this policy belongs to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>the human-readable policy name; should be the same as <a class="el" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">ptlrpc_nrs_pol_desc::pd_name</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>opc</em>&nbsp;</td><td>the opcode of the operation being carried out. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>can be used to pass information in and out between when carrying an operation; usually data that is private to the policy at some level, or generic policy status information.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>operation was carried out successfully </td></tr>
  </table>
  </dd>
</dl>

<p><p>Unknown opcode, pass it down to the policy-specific control function for handling.</p>
<p>Start <em>policy</em> </p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00655">655</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="lustre__nrs_8h_source.html#l00324">ptlrpc_nrs::nrs_lock</a>, <a class="el" href="lustre__nrs_8h_source.html#l00539">NRS_POL_STATE_STARTED</a>, <a class="el" href="lustre__nrs_8h_source.html#l00525">NRS_POL_STATE_STOPPED</a>, <a class="el" href="nrs_8c_source.html#l00070">nrs_policy_ctl_locked()</a>, <a class="el" href="nrs_8c_source.html#l00356">nrs_policy_find_locked()</a>, <a class="el" href="nrs_8c_source.html#l00336">nrs_policy_put_locked()</a>, <a class="el" href="nrs_8c_source.html#l00192">nrs_policy_start_locked()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00594">ptlrpc_nrs_policy::pol_state</a>, <a class="el" href="lustre__nrs_8h_source.html#l00056">PTLRPC_NRS_CTL_START</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01738">ptlrpc_nrs_policy_control()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cd19c55101ad1e38a172821fee9f1f8"></a><!-- doxytag: member="nrs.c::nrs_policy_ctl_locked" ref="a0cd19c55101ad1e38a172821fee9f1f8" args="(struct ptlrpc_nrs_policy *policy, enum ptlrpc_nrs_ctl opc, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_policy_ctl_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a>&nbsp;</td>
          <td class="paramname"> <em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>The policy may be stopped, but the lprocfs files and <a class="el" href="structptlrpc__nrs__policy.html" title="NRS policy.">ptlrpc_nrs_policy</a> instances remain present until unregistration time. Do not perform the ctl operation if the policy is stopped, as policy-&gt;pol_private will be NULL in such a case.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00070">70</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="lustre__nrs_8h_source.html#l00525">NRS_POL_STATE_STOPPED</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#ad5e959465f0b9fd65ae096036df926d3">ptlrpc_nrs_pol_ops::op_policy_ctl</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00594">ptlrpc_nrs_policy::pol_state</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00655">nrs_policy_ctl()</a>.</p>

</div>
</div>
<a class="anchor" id="acb10df06d5d3d8b6320247eeb2e6dc16"></a><!-- doxytag: member="nrs.c::nrs_policy_find_desc_locked" ref="acb10df06d5d3d8b6320247eeb2e6dc16" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a>* nrs_policy_find_desc_locked </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the descriptor for a policy as identified by by <em>name</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>the policy name</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>the</em>&nbsp;</td><td>policy descriptor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01075">1075</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, <a class="el" href="lustre__nrs_8h_source.html#l00382">NRS_POL_NAME_MAX</a>, <a class="el" href="lustre__nrs_8h_source.html#l00445">ptlrpc_nrs_pol_desc::pd_list</a>, <a class="el" href="lustre__nrs_8h_source.html#l00441">ptlrpc_nrs_pol_desc::pd_name</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01165">ptlrpc_nrs_policy_register()</a>, and <a class="el" href="nrs_8c_source.html#l01323">ptlrpc_nrs_policy_unregister()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3068360b11a41b43f942cae4332c23e"></a><!-- doxytag: member="nrs.c::nrs_policy_find_locked" ref="aa3068360b11a41b43f942cae4332c23e" args="(struct ptlrpc_nrs *nrs, char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a>* nrs_policy_find_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *&nbsp;</td>
          <td class="paramname"> <em>nrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find and return a policy by name. </p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00356">356</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, <a class="el" href="lustre__nrs_8h_source.html#l00382">NRS_POL_NAME_MAX</a>, <a class="el" href="nrs_8c_source.html#l00325">nrs_policy_get_locked()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00329">ptlrpc_nrs::nrs_policy_list</a>, <a class="el" href="lustre__nrs_8h_source.html#l00441">ptlrpc_nrs_pol_desc::pd_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00585">ptlrpc_nrs_policy::pol_list</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00655">nrs_policy_ctl()</a>, <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>, and <a class="el" href="nrs_8c_source.html#l00707">nrs_policy_unregister()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ec886b1c98564c4fb88f460ad63c892"></a><!-- doxytag: member="nrs.c::nrs_policy_fini" ref="a9ec886b1c98564c4fb88f460ad63c892" args="(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_policy_fini </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00061">61</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#a19f8bfc734d211149596592a8381e336">ptlrpc_nrs_pol_ops::op_policy_fini</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00610">ptlrpc_nrs_policy::pol_ref</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00602">ptlrpc_nrs_policy::pol_req_queued</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>, and <a class="el" href="nrs_8c_source.html#l00707">nrs_policy_unregister()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8a706937e7f4af4dc72337fbe40814"></a><!-- doxytag: member="nrs.c::nrs_policy_get_locked" ref="a9a8a706937e7f4af4dc72337fbe40814" args="(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_policy_get_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increases the policy's usage reference count. </p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00325">325</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="lustre__nrs_8h_source.html#l00610">ptlrpc_nrs_policy::pol_ref</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00356">nrs_policy_find_locked()</a>, and <a class="el" href="nrs_8c_source.html#l00457">nrs_resource_get_safe()</a>.</p>

</div>
</div>
<a class="anchor" id="a464be72e6ccb20f6cb3f01cadc709399"></a><!-- doxytag: member="nrs.c::nrs_policy_init" ref="a464be72e6ccb20f6cb3f01cadc709399" args="(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_policy_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00055">55</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="structptlrpc__nrs__pol__ops.html#a569dc08f6db72425acb3af23817016b5">ptlrpc_nrs_pol_ops::op_policy_init</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>.</p>

</div>
</div>
<a class="anchor" id="a9630b070e1b5be35664de89cb9c0996f"></a><!-- doxytag: member="nrs.c::nrs_policy_put" ref="a9630b070e1b5be35664de89cb9c0996f" args="(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_policy_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00346">346</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="lustre__nrs_8h_source.html#l00324">ptlrpc_nrs::nrs_lock</a>, <a class="el" href="nrs_8c_source.html#l00336">nrs_policy_put_locked()</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00457">nrs_resource_get_safe()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a213cf1db771ef07a3e0c146ddc68e6"></a><!-- doxytag: member="nrs.c::nrs_policy_put_locked" ref="a6a213cf1db771ef07a3e0c146ddc68e6" args="(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_policy_put_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decreases the policy's usage reference count, and stops the policy in case it was already stopping and have no more outstanding usage references (which indicates it has no more queued or started requests, and can be safely stopped). </p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00336">336</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__nrs_8h_source.html#l00529">NRS_POL_STATE_STOPPING</a>, <a class="el" href="nrs_8c_source.html#l00087">nrs_policy_stop0()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00610">ptlrpc_nrs_policy::pol_ref</a>, <a class="el" href="lustre__nrs_8h_source.html#l00594">ptlrpc_nrs_policy::pol_state</a>, and <a class="el" href="libcfs__private_8h_source.html#l00310">unlikely</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00655">nrs_policy_ctl()</a>, <a class="el" href="nrs_8c_source.html#l00346">nrs_policy_put()</a>, <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>, <a class="el" href="nrs_8c_source.html#l00707">nrs_policy_unregister()</a>, and <a class="el" href="nrs_8c_source.html#l00511">nrs_resource_put_safe()</a>.</p>

</div>
</div>
<a class="anchor" id="a90bbaf18e29bc89bc9413c3f33e67767"></a><!-- doxytag: member="nrs.c::nrs_policy_register" ref="a90bbaf18e29bc89bc9413c3f33e67767" args="(struct ptlrpc_nrs *nrs, struct ptlrpc_nrs_pol_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_policy_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *&nbsp;</td>
          <td class="paramname"> <em>nrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a policy from  descriptor <em>desc</em> with NRS head <em>nrs</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrs</em>&nbsp;</td><td>the NRS head on which the policy will be registered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>the policy descriptor from which the information will be obtained to register the policy.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00764">764</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="list_8h_source.html#l00048">INIT_LIST_HEAD</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00090">list_add_tail()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00324">ptlrpc_nrs::nrs_lock</a>, <a class="el" href="lustre__nrs_8h_source.html#l00366">ptlrpc_nrs::nrs_num_pols</a>, <a class="el" href="lustre__nrs_8h_source.html#l00525">NRS_POL_STATE_STOPPED</a>, <a class="el" href="nrs_8c_source.html#l00356">nrs_policy_find_locked()</a>, <a class="el" href="nrs_8c_source.html#l00061">nrs_policy_fini()</a>, <a class="el" href="nrs_8c_source.html#l00055">nrs_policy_init()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00329">ptlrpc_nrs::nrs_policy_list</a>, <a class="el" href="nrs_8c_source.html#l00336">nrs_policy_put_locked()</a>, <a class="el" href="nrs_8c_source.html#l00192">nrs_policy_start_locked()</a>, <a class="el" href="nrs_8c_source.html#l00707">nrs_policy_unregister()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00342">ptlrpc_nrs::nrs_svcpt</a>, <a class="el" href="obd__support_8h_source.html#l00713">OBD_CPT_ALLOC_GFP</a>, <a class="el" href="obd__support_8h_source.html#l00830">OBD_FREE_PTR</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#a1eb83c9a1da21c4090e85c6711dbf6d6">ptlrpc_nrs_pol_ops::op_req_dequeue</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#ae4c73dc673c0175574a7eee691f846a2">ptlrpc_nrs_pol_ops::op_req_enqueue</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#ad7f082871c0f527c8d6b1c27c40a88e6">ptlrpc_nrs_pol_ops::op_req_get</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#affec8ac80f98364807dfe58e82fe4afe">ptlrpc_nrs_pol_ops::op_res_get</a>, <a class="el" href="lustre__nrs_8h_source.html#l00453">ptlrpc_nrs_pol_desc::pd_compat</a>, <a class="el" href="lustre__nrs_8h_source.html#l00503">ptlrpc_nrs_pol_desc::pd_flags</a>, <a class="el" href="lustre__nrs_8h_source.html#l00441">ptlrpc_nrs_pol_desc::pd_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00598">ptlrpc_nrs_policy::pol_flags</a>, <a class="el" href="lustre__nrs_8h_source.html#l00585">ptlrpc_nrs_policy::pol_list</a>, <a class="el" href="lustre__nrs_8h_source.html#l00590">ptlrpc_nrs_policy::pol_list_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00594">ptlrpc_nrs_policy::pol_state</a>, <a class="el" href="lustre__nrs_8h_source.html#l00276">PTLRPC_NRS_FL_REG_START</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, and <a class="el" href="lustre__net_8h_source.html#l01753">ptlrpc_service_part::scp_cpt</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00904">nrs_register_policies_locked()</a>, and <a class="el" href="nrs_8c_source.html#l01165">ptlrpc_nrs_policy_register()</a>.</p>

</div>
</div>
<a class="anchor" id="a4630e3b5b9e989a55f772264a9621b78"></a><!-- doxytag: member="nrs.c::nrs_policy_start_locked" ref="a4630e3b5b9e989a55f772264a9621b78" args="(struct ptlrpc_nrs_policy *policy, char *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_policy_start_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transitions a policy across the ptlrpc_nrs_pol_state range of values, in response to an lprocfs command to start a policy. </p>
<p>If a primary policy different to the current one is specified, this function will transition the new policy to the <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a6198482c4c72e590f9009efb54f424ec" title="Policy is in progress of starting.">ptlrpc_nrs_pol_state::NRS_POL_STATE_STARTING</a> and then to <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a8da4904dfb7ba56810332673912a76cb" title="A policy is in this state in two cases:it is the fallback policy, which is always...">ptlrpc_nrs_pol_state::NRS_POL_STATE_STARTED</a>, and will then transition the old primary policy (if there is one) to <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a3e737ea7aa14781899e40eb0343c9a39" title="Policy is progress of stopping.">ptlrpc_nrs_pol_state::NRS_POL_STATE_STOPPING</a>, and if there are no outstanding references on the policy to <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a60ca6b44260cb20198b1d5d4747a6257" title="Policies are at this state either at the start of their life, or transition here...">ptlrpc_nrs_pol_stae::NRS_POL_STATE_STOPPED</a>.</p>
<p>If the fallback policy is specified, this is taken to indicate an instruction to stop the current primary policy, without substituting it with another primary policy, so the primary policy (if any) is transitioned to <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a3e737ea7aa14781899e40eb0343c9a39" title="Policy is progress of stopping.">ptlrpc_nrs_pol_state::NRS_POL_STATE_STOPPING</a>, and if there are no outstanding references on the policy to <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a60ca6b44260cb20198b1d5d4747a6257" title="Policies are at this state either at the start of their life, or transition here...">ptlrpc_nrs_pol_stae::NRS_POL_STATE_STOPPED</a>. In this case, the fallback policy is only left active in the NRS head. </p>

<p><p>Don't allow multiple starting which is too complex, and has no real benefit.</p>
<p>This is for cases in which the user sets the policy to the fallback policy (currently fifo for all services); i.e. the user is resetting the policy to the default; so we stop the primary policy, if any.</p>
<p>If we reach here, we must be setting up the fallback policy at service startup time, and only a single policy with the <a class="el" href="group__nrs.html#gga6ea16220314a76d72e40776a753ad5e8ad327b4b9e26d26b5620cfdb682ca0b4c" title="Fallback policy, use this flag only on a single supported policy per service.">nrs_policy_flags::PTLRPC_NRS_FL_FALLBACK</a> flag set can register with NRS core.</p>
<p>Shouldn't start primary policy if w/o fallback policy.</p>
<p>If the policy argument now is different from the last time, stop the policy first and start it again with the new argument.</p>
<p>Increase the module usage count for policies registering from other modules.</p>
<p>Serialize policy starting across the NRS head</p>
<p>This path is only used at PTLRPC service setup time.</p>
<p>And set the newly-started policy as the primary one.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00192">192</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__nrs_8h_source.html#l00324">ptlrpc_nrs::nrs_lock</a>, <a class="el" href="lustre__nrs_8h_source.html#l00383">NRS_POL_ARG_MAX</a>, <a class="el" href="lustre__nrs_8h_source.html#l00539">NRS_POL_STATE_STARTED</a>, <a class="el" href="lustre__nrs_8h_source.html#l00533">NRS_POL_STATE_STARTING</a>, <a class="el" href="lustre__nrs_8h_source.html#l00525">NRS_POL_STATE_STOPPED</a>, <a class="el" href="lustre__nrs_8h_source.html#l00529">NRS_POL_STATE_STOPPING</a>, <a class="el" href="lustre__nrs_8h_source.html#l00350">ptlrpc_nrs::nrs_policy_fallback</a>, <a class="el" href="lustre__nrs_8h_source.html#l00346">ptlrpc_nrs::nrs_policy_primary</a>, <a class="el" href="lustre__nrs_8h_source.html#l00370">ptlrpc_nrs::nrs_policy_starting</a>, <a class="el" href="nrs_8c_source.html#l00108">nrs_policy_stop_locked()</a>, <a class="el" href="nrs_8c_source.html#l00148">nrs_policy_stop_primary()</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#a04b4479f93de2fbd7380f10ffaf5f35c">ptlrpc_nrs_pol_ops::op_policy_start</a>, <a class="el" href="lustre__nrs_8h_source.html#l00441">ptlrpc_nrs_pol_desc::pd_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00499">ptlrpc_nrs_pol_desc::pd_owner</a>, <a class="el" href="lustre__nrs_8h_source.html#l00507">ptlrpc_nrs_pol_desc::pd_refs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00614">ptlrpc_nrs_policy::pol_arg</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00598">ptlrpc_nrs_policy::pol_flags</a>, <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00594">ptlrpc_nrs_policy::pol_state</a>, <a class="el" href="lustre__nrs_8h_source.html#l00272">PTLRPC_NRS_FL_FALLBACK</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00655">nrs_policy_ctl()</a>, and <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>.</p>

</div>
</div>
<a class="anchor" id="ab0431763f8af37f9f10dac5d884bab3b"></a><!-- doxytag: member="nrs.c::nrs_policy_stop0" ref="ab0431763f8af37f9f10dac5d884bab3b" args="(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_policy_stop0 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00087">87</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00525">NRS_POL_STATE_STOPPED</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#a858a315f60b599de84db2cadfb9d6784">ptlrpc_nrs_pol_ops::op_policy_stop</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00499">ptlrpc_nrs_pol_desc::pd_owner</a>, <a class="el" href="lustre__nrs_8h_source.html#l00507">ptlrpc_nrs_pol_desc::pd_refs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00590">ptlrpc_nrs_policy::pol_list_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00622">ptlrpc_nrs_policy::pol_private</a>, <a class="el" href="lustre__nrs_8h_source.html#l00602">ptlrpc_nrs_policy::pol_req_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00606">ptlrpc_nrs_policy::pol_req_started</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00594">ptlrpc_nrs_policy::pol_state</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00336">nrs_policy_put_locked()</a>, <a class="el" href="nrs_8c_source.html#l00108">nrs_policy_stop_locked()</a>, and <a class="el" href="nrs_8c_source.html#l00148">nrs_policy_stop_primary()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c7661d26dd212aae15851a38e71ade4"></a><!-- doxytag: member="nrs.c::nrs_policy_stop_locked" ref="a6c7661d26dd212aae15851a38e71ade4" args="(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_policy_stop_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00108">108</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__nrs_8h_source.html#l00539">NRS_POL_STATE_STARTED</a>, <a class="el" href="lustre__nrs_8h_source.html#l00533">NRS_POL_STATE_STARTING</a>, <a class="el" href="lustre__nrs_8h_source.html#l00529">NRS_POL_STATE_STOPPING</a>, <a class="el" href="lustre__nrs_8h_source.html#l00350">ptlrpc_nrs::nrs_policy_fallback</a>, <a class="el" href="lustre__nrs_8h_source.html#l00346">ptlrpc_nrs::nrs_policy_primary</a>, <a class="el" href="nrs_8c_source.html#l00087">nrs_policy_stop0()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00375">ptlrpc_nrs::nrs_stopping</a>, <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00610">ptlrpc_nrs_policy::pol_ref</a>, <a class="el" href="lustre__nrs_8h_source.html#l00594">ptlrpc_nrs_policy::pol_state</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00192">nrs_policy_start_locked()</a>, and <a class="el" href="nrs_8c_source.html#l00707">nrs_policy_unregister()</a>.</p>

</div>
</div>
<a class="anchor" id="a8db69645bb5947003ada611a8cfe89d2"></a><!-- doxytag: member="nrs.c::nrs_policy_stop_primary" ref="a8db69645bb5947003ada611a8cfe89d2" args="(struct ptlrpc_nrs *nrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_policy_stop_primary </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *&nbsp;</td>
          <td class="paramname"> <em>nrs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transitions the <em>nrs</em> NRS head's primary policy to <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a3e737ea7aa14781899e40eb0343c9a39" title="Policy is progress of stopping.">ptlrpc_nrs_pol_state::NRS_POL_STATE_STOPPING</a> and if the policy has no pending usage references, to <a class="el" href="group__nrs.html#gga843285b91fa9672fdf0fcc93b4387971a60ca6b44260cb20198b1d5d4747a6257" title="Policies are at this state either at the start of their life, or transition here...">ptlrpc_nrs_pol_state::NRS_POL_STATE_STOPPED</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrs</em>&nbsp;</td><td>the NRS head to carry out this operation on </td></tr>
  </table>
  </dd>
</dl>

<p><p>XXX: This should really be RETURN_EXIT, but the latter does not currently print anything out, and possibly should be fixed to do so.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00148">148</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__nrs_8h_source.html#l00539">NRS_POL_STATE_STARTED</a>, <a class="el" href="lustre__nrs_8h_source.html#l00529">NRS_POL_STATE_STOPPING</a>, <a class="el" href="lustre__nrs_8h_source.html#l00346">ptlrpc_nrs::nrs_policy_primary</a>, <a class="el" href="nrs_8c_source.html#l00087">nrs_policy_stop0()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00610">ptlrpc_nrs_policy::pol_ref</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00594">ptlrpc_nrs_policy::pol_state</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00192">nrs_policy_start_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="a98db68c1f20f3dc3f47786ab0f73615f"></a><!-- doxytag: member="nrs.c::nrs_policy_unregister" ref="a98db68c1f20f3dc3f47786ab0f73615f" args="(struct ptlrpc_nrs *nrs, char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_policy_unregister </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *&nbsp;</td>
          <td class="paramname"> <em>nrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters a policy by name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrs</em>&nbsp;</td><td>the NRS head this policy belongs to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>the human-readable policy name; should be the same as <a class="el" href="structptlrpc__nrs__pol__desc.html#a0a92ae21dc1071c65c7e7d2efa67a976" title="Human-readable policy name.">ptlrpc_nrs_pol_desc::pd_name</a></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00707">707</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00116">list_del()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00324">ptlrpc_nrs::nrs_lock</a>, <a class="el" href="lustre__nrs_8h_source.html#l00366">ptlrpc_nrs::nrs_num_pols</a>, <a class="el" href="lustre__nrs_8h_source.html#l00525">NRS_POL_STATE_STOPPED</a>, <a class="el" href="nrs_8c_source.html#l00356">nrs_policy_find_locked()</a>, <a class="el" href="nrs_8c_source.html#l00061">nrs_policy_fini()</a>, <a class="el" href="nrs_8c_source.html#l00336">nrs_policy_put_locked()</a>, <a class="el" href="nrs_8c_source.html#l00108">nrs_policy_stop_locked()</a>, <a class="el" href="obd__support_8h_source.html#l00830">OBD_FREE_PTR</a>, <a class="el" href="lustre__nrs_8h_source.html#l00585">ptlrpc_nrs_policy::pol_list</a>, <a class="el" href="lustre__nrs_8h_source.html#l00622">ptlrpc_nrs_policy::pol_private</a>, <a class="el" href="lustre__nrs_8h_source.html#l00610">ptlrpc_nrs_policy::pol_ref</a>, <a class="el" href="lustre__nrs_8h_source.html#l00602">ptlrpc_nrs_policy::pol_req_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00606">ptlrpc_nrs_policy::pol_req_started</a>, <a class="el" href="lustre__nrs_8h_source.html#l00594">ptlrpc_nrs_policy::pol_state</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>, <a class="el" href="nrs_8c_source.html#l01099">nrs_policy_unregister_locked()</a>, and <a class="el" href="nrs_8c_source.html#l01026">nrs_svcpt_cleanup_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="a2cc98defe939efdcf9bdf5f9f520d08a"></a><!-- doxytag: member="nrs.c::nrs_policy_unregister_locked" ref="a2cc98defe939efdcf9bdf5f9f520d08a" args="(struct ptlrpc_nrs_pol_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_policy_unregister_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__pol__desc.html">ptlrpc_nrs_pol_desc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the policy from all supported NRS heads of all partitions of all PTLRPC services. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>the policy descriptor to unregister</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>successfully unregistered policy on all supported NRS heads</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>mutex_is_locked(&amp;<a class="el" href="structnrs__core.html#a1809292c09cd3a2f8ad6c1d729891231" title="Protects nrs_core::nrs_policies, serializes external policy registration/unregistration...">nrs_core.nrs_mutex</a>) </dd>
<dd>
mutex_is_locked(&amp;ptlrpc_all_services_mutex) </dd></dl>

<p><p>Ignore -ENOENT as the policy may not have registered successfully on all service partitions.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01099">1099</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, <a class="el" href="nrs_8c_source.html#l00885">nrs_policy_compatible()</a>, <a class="el" href="nrs_8c_source.html#l00707">nrs_policy_unregister()</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00189">nrs_svc_has_hp()</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00199">nrs_svcpt2nrs()</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#a4278270d8cf6849261467dd6a69bd19a">ptlrpc_nrs_pol_ops::op_lprocfs_fini</a>, <a class="el" href="lustre__nrs_8h_source.html#l00441">ptlrpc_nrs_pol_desc::pd_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="service_8c_source.html#l00068">ptlrpc_all_services</a>, <a class="el" href="service_8c_source.html#l00070">ptlrpc_all_services_mutex</a>, <a class="el" href="lustre__net_8h_source.html#l01857">ptlrpc_service_for_each_part</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01753">ptlrpc_service_part::scp_cpt</a>, <a class="el" href="lustre__net_8h_source.html#l01713">ptlrpc_service::srv_is_stopping</a>, and <a class="el" href="libcfs__private_8h_source.html#l00310">unlikely</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01165">ptlrpc_nrs_policy_register()</a>, and <a class="el" href="nrs_8c_source.html#l01323">ptlrpc_nrs_policy_unregister()</a>.</p>

</div>
</div>
<a class="anchor" id="a8efb55101ffc6a1a76fffca83975af92"></a><!-- doxytag: member="nrs.c::nrs_register_policies_locked" ref="a8efb55101ffc6a1a76fffca83975af92" args="(struct ptlrpc_nrs *nrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_register_policies_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *&nbsp;</td>
          <td class="paramname"> <em>nrs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers all compatible policies in <a class="el" href="structnrs__core.html#a6bd6f7f96d860c488aff9d4e638d272d" title="List of all policy descriptors registered with NRS core; protected by nrs_core::nrs_mutex...">nrs_core.nrs_policies</a>, for NRS head <em>nrs</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrs</em>&nbsp;</td><td>the NRS head</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>mutex_is_locked(&amp;<a class="el" href="structnrs__core.html#a1809292c09cd3a2f8ad6c1d729891231" title="Protects nrs_core::nrs_policies, serializes external policy registration/unregistration...">nrs_core.nrs_mutex</a>)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#a107d0adae381864f5c53de6cc805a59f" title="Setup NRS heads on all service partitions of service svc, and register all compatible...">ptlrpc_service_nrs_setup()</a> </dd></dl>

<p><p>Fail registration if any of the policies' registration fails.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00904">904</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00278">CERROR</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, <a class="el" href="nrs_8c_source.html#l00885">nrs_policy_compatible()</a>, <a class="el" href="nrs_8c_source.html#l00764">nrs_policy_register()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00342">ptlrpc_nrs::nrs_svcpt</a>, <a class="el" href="lustre__nrs_8h_source.html#l00441">ptlrpc_nrs_pol_desc::pd_name</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01753">ptlrpc_service_part::scp_cpt</a>, and <a class="el" href="lustre__net_8h_source.html#l01678">ptlrpc_service::srv_name</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00947">nrs_svcpt_setup_locked0()</a>.</p>

</div>
</div>
<a class="anchor" id="ac63065fc9f6fc04df590c34a1da9a1cf"></a><!-- doxytag: member="nrs.c::nrs_request_enqueue" ref="ac63065fc9f6fc04df590c34a1da9a1cf" args="(struct ptlrpc_nrs_request *nrq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_request_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *&nbsp;</td>
          <td class="paramname"> <em>nrq</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueues request <em>nrq</em> for later handling, via one one the policies for which resources where earlier obtained via <a class="el" href="nrs_8c.html#a6ba673781ab2ba2e38ab4c17c1e26cff" title="Obtains resources for the resource hierarchies and policy references for the fallback...">nrs_resource_get_safe()</a>. </p>
<p>The function attempts to enqueue the request first on the primary policy (if any), since this is the preferred choice.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nrq</em>&nbsp;</td><td>the request being enqueued</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#a6ba673781ab2ba2e38ab4c17c1e26cff" title="Obtains resources for the resource hierarchies and policy references for the fallback...">nrs_resource_get_safe()</a> </dd></dl>

<p><p>Try in descending order, because the primary policy (if any) is the preferred choice.</p>
<p>Should never get here, as at least the primary policy's <a class="el" href="structptlrpc__nrs__pol__ops.html#ae4c73dc673c0175574a7eee691f846a2" title="Called when attempting to add a request to a policy for later handling; this operation...">ptlrpc_nrs_pol_ops::op_req_enqueue()</a> implementation should always succeed.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00583">583</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="libcfs__private_8h_source.html#l00281">LBUG</a>, <a class="el" href="lustre__nrs_8h_source.html#l00698">ptlrpc_nrs_request::nr_res_idx</a>, <a class="el" href="lustre__nrs_8h_source.html#l00691">ptlrpc_nrs_request::nr_res_ptrs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00358">ptlrpc_nrs::nrs_req_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00671">NRS_RES_MAX</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#ae4c73dc673c0175574a7eee691f846a2">ptlrpc_nrs_pol_ops::op_req_enqueue</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00602">ptlrpc_nrs_policy::pol_req_queued</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00665">ptlrpc_nrs_resource::res_policy</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00836">ptlrpc_nrs_req_add_nolock()</a>.</p>

</div>
</div>
<a class="anchor" id="a03fa2d011c5fcb5c16cd48b910775cc0"></a><!-- doxytag: member="nrs.c::nrs_request_get" ref="a03fa2d011c5fcb5c16cd48b910775cc0" args="(struct ptlrpc_nrs_policy *policy, bool peek, bool force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a>* nrs_request_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>peek</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>force</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains an NRS request from <em>policy</em> for handling or examination; the request should be removed in the 'handling' case. </p>
<p>Calling into this function implies we already know the policy has a request waiting to be handled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>the policy from which a request </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peek</em>&nbsp;</td><td>when set, signifies that we just want to examine the request, and not handle it, so the request is not removed from the policy. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>when set, it will force a policy to return a request if it has one pending</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>the</em>&nbsp;</td><td>NRS request to be handled </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00559">559</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="osd__iam_8h_source.html#l00057">ergo</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00238">nrs_request_policy()</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#ad7f082871c0f527c8d6b1c27c40a88e6">ptlrpc_nrs_pol_ops::op_req_get</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00602">ptlrpc_nrs_policy::pol_req_queued</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01583">ptlrpc_nrs_req_get_nolock0()</a>.</p>

</div>
</div>
<a class="anchor" id="a735bd46503efe2446339ecdded1cbef5"></a><!-- doxytag: member="nrs.c::nrs_request_removed" ref="a735bd46503efe2446339ecdded1cbef5" args="(struct ptlrpc_nrs_policy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_request_removed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>If the policy has no more requests queued, remove it from <a class="el" href="structptlrpc__nrs.html#abba957e518558f35d3e0dd9f2f7f7eb3" title="List of policies with queued requests.">ptlrpc_nrs::nrs_policy_queued</a>.</p>
<p>If there are other policies with queued requests, move the current policy to the end so that we can round robin over all policies and drain the requests.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01537">1537</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="list_8h_source.html#l00150">list_move_tail()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00338">ptlrpc_nrs::nrs_policy_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00358">ptlrpc_nrs::nrs_req_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00590">ptlrpc_nrs_policy::pol_list_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00602">ptlrpc_nrs_policy::pol_req_queued</a>, and <a class="el" href="libcfs__private_8h_source.html#l00310">unlikely</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01619">ptlrpc_nrs_req_del_nolock()</a>, and <a class="el" href="nrs_8c_source.html#l01583">ptlrpc_nrs_req_get_nolock0()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a55a7f119a21dbba1ef14e86b75bf5f"></a><!-- doxytag: member="nrs.c::nrs_request_stop" ref="a1a55a7f119a21dbba1ef14e86b75bf5f" args="(struct ptlrpc_nrs_request *nrq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_request_stop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *&nbsp;</td>
          <td class="paramname"> <em>nrq</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when a request has been handled. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrs</em>&nbsp;</td><td>the request that has been handled; can be used for job/resource control.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="nrs_8c.html#a41d6af6b26aebda69530fe3537266dfd">ptlrpc_nrs_req_stop_nolock()</a> </dd></dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00623">623</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__nrs_8h_source.html#l00362">ptlrpc_nrs::nrs_req_started</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00238">nrs_request_policy()</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#afda655439032cd5103c48bfdafa6d98a">ptlrpc_nrs_pol_ops::op_req_stop</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00606">ptlrpc_nrs_policy::pol_req_started</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01509">ptlrpc_nrs_req_stop_nolock()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9f61820f84d81d579b1b47be3985a49"></a><!-- doxytag: member="nrs.c::nrs_resource_get" ref="ac9f61820f84d81d579b1b47be3985a49" args="(struct ptlrpc_nrs_policy *policy, struct ptlrpc_nrs_request *nrq, bool moving_req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a>* nrs_resource_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__policy.html">ptlrpc_nrs_policy</a> *&nbsp;</td>
          <td class="paramname"> <em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *&nbsp;</td>
          <td class="paramname"> <em>nrq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>moving_req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains references for each resource in the resource hierarchy for request <em>nrq</em> if it is to be handled by <em>policy</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>policy</em>&nbsp;</td><td>the policy </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>the request </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>moving_req</em>&nbsp;</td><td>denotes whether this is a call to the function by ldlm_lock_reorder_req(), in order to move <em>nrq</em> to the high-priority NRS head; we should not sleep when set.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>resource hierarchy references not obtained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valid-pointer</em>&nbsp;</td><td>the bottom level of the resource hierarchy</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structptlrpc__nrs__pol__ops.html#affec8ac80f98364807dfe58e82fe4afe" title="Called when obtaining references to the resources of the resource hierarchy for a...">ptlrpc_nrs_pol_ops::op_res_get()</a> </dd></dl>

<p><p>Set to NULL to traverse the resource hierarchy from the top.</p>
<p>Return once we have obtained a reference to the bottom level of the resource hierarchy.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00406">406</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="nrs_8c_source.html#l00375">nrs_resource_put()</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#affec8ac80f98364807dfe58e82fe4afe">ptlrpc_nrs_pol_ops::op_res_get</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00661">ptlrpc_nrs_resource::res_parent</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00665">ptlrpc_nrs_resource::res_policy</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00457">nrs_resource_get_safe()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ba673781ab2ba2e38ab4c17c1e26cff"></a><!-- doxytag: member="nrs.c::nrs_resource_get_safe" ref="a6ba673781ab2ba2e38ab4c17c1e26cff" args="(struct ptlrpc_nrs *nrs, struct ptlrpc_nrs_request *nrq, struct ptlrpc_nrs_resource **resp, bool moving_req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_resource_get_safe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *&nbsp;</td>
          <td class="paramname"> <em>nrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__request.html">ptlrpc_nrs_request</a> *&nbsp;</td>
          <td class="paramname"> <em>nrq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> **&nbsp;</td>
          <td class="paramname"> <em>resp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>moving_req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains resources for the resource hierarchies and policy references for the fallback and current primary policy (if any), that will later be used to handle request <em>nrq</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrs</em>&nbsp;</td><td>the NRS head instance that will be handling request <em>nrq</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrq</em>&nbsp;</td><td>the request that is being handled. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>resp</em>&nbsp;</td><td>the array where references to the resource hierarchy are stored. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>moving_req</em>&nbsp;</td><td>is set when obtaining resources while moving a request from a policy on the regular NRS head to a policy on the HP NRS head (via ldlm_lock_reorder_req()). It signifies that allocations to get resources should be atomic; for a full explanation, see comment in <a class="el" href="structptlrpc__nrs__pol__ops.html#affec8ac80f98364807dfe58e82fe4afe" title="Called when obtaining references to the resources of the resource hierarchy for a...">ptlrpc_nrs_pol_ops::op_res_get()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p><p>Obtain policy references.</p>
<p>Obtain resource hierarchy references.</p>
<p>A primary policy may exist which may not wish to serve a particular request for different reasons; release the reference on the policy as it will not be used for this request.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00457">457</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="lustre__nrs_8h_source.html#l00324">ptlrpc_nrs::nrs_lock</a>, <a class="el" href="lustre__nrs_8h_source.html#l00350">ptlrpc_nrs::nrs_policy_fallback</a>, <a class="el" href="nrs_8c_source.html#l00325">nrs_policy_get_locked()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00346">ptlrpc_nrs::nrs_policy_primary</a>, <a class="el" href="nrs_8c_source.html#l00346">nrs_policy_put()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00669">NRS_RES_FALLBACK</a>, <a class="el" href="lustre__nrs_8h_source.html#l00671">NRS_RES_MAX</a>, <a class="el" href="lustre__nrs_8h_source.html#l00670">NRS_RES_PRIMARY</a>, and <a class="el" href="nrs_8c_source.html#l00406">nrs_resource_get()</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01673">ptlrpc_nrs_req_hp_move()</a>, and <a class="el" href="nrs_8c_source.html#l01475">ptlrpc_nrs_req_initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a482dd8acde17c378429a74d5428c21ae"></a><!-- doxytag: member="nrs.c::nrs_resource_put" ref="a482dd8acde17c378429a74d5428c21ae" args="(struct ptlrpc_nrs_resource *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_resource_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release references for the resource hierarchy moving upwards towards the policy instance resource. </p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00375">375</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="structptlrpc__nrs__pol__ops.html#a1fc1f744ceed9307e93dc3ad6f9f882b">ptlrpc_nrs_pol_ops::op_res_put</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00661">ptlrpc_nrs_resource::res_parent</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00665">ptlrpc_nrs_resource::res_policy</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00406">nrs_resource_get()</a>, and <a class="el" href="nrs_8c_source.html#l00511">nrs_resource_put_safe()</a>.</p>

</div>
</div>
<a class="anchor" id="a391d93543ea4b81e59ded6346e0ee92e"></a><!-- doxytag: member="nrs.c::nrs_resource_put_safe" ref="a391d93543ea4b81e59ded6346e0ee92e" args="(struct ptlrpc_nrs_resource **resp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_resource_put_safe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs__resource.html">ptlrpc_nrs_resource</a> **&nbsp;</td>
          <td class="paramname"> <em>resp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases references to resource hierarchies and policies, because they are no longer required; used when request handling has been completed, or the request is moving to the high priority NRS head. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resp</em>&nbsp;</td><td>the resource hierarchy that is being released</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ptlrpcnrs_req_hp_move() </dd>
<dd>
<a class="el" href="nrs_8c.html#aa35053963b23dd9e0dc17f6b214da481" title="Releases resources for a request; is called after the request has been handled.">ptlrpc_nrs_req_finalize()</a> </dd></dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00511">511</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="lustre__nrs_8h_source.html#l00324">ptlrpc_nrs::nrs_lock</a>, <a class="el" href="nrs_8c_source.html#l00336">nrs_policy_put_locked()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00671">NRS_RES_MAX</a>, <a class="el" href="nrs_8c_source.html#l00375">nrs_resource_put()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00665">ptlrpc_nrs_resource::res_policy</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01499">ptlrpc_nrs_req_finalize()</a>, and <a class="el" href="nrs_8c_source.html#l01673">ptlrpc_nrs_req_hp_move()</a>.</p>

</div>
</div>
<a class="anchor" id="a63a8af62fd1f0baa77f225c25ea41bae"></a><!-- doxytag: member="nrs.c::nrs_svcpt_cleanup_locked" ref="a63a8af62fd1f0baa77f225c25ea41bae" args="(struct ptlrpc_service_part *svcpt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nrs_svcpt_cleanup_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *&nbsp;</td>
          <td class="paramname"> <em>svcpt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters all policies on all available NRS heads in a service partition; called at PTLRPC service unregistration time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svcpt</em>&nbsp;</td><td>the PTLRPC service partition</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>mutex_is_locked(&amp;<a class="el" href="structnrs__core.html#a1809292c09cd3a2f8ad6c1d729891231" title="Protects nrs_core::nrs_policies, serializes external policy registration/unregistration...">nrs_core.nrs_mutex</a>) </dd></dl>

<p><p>If the service partition has an HP NRS head, clean that up as well.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01026">1026</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00484">list_for_each_entry_safe</a>, <a class="el" href="lustre__nrs_8h_source.html#l00329">ptlrpc_nrs::nrs_policy_list</a>, <a class="el" href="nrs_8c_source.html#l00707">nrs_policy_unregister()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00375">ptlrpc_nrs::nrs_stopping</a>, <a class="el" href="lustre__nrs_8h_source.html#l00342">ptlrpc_nrs::nrs_svcpt</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00184">nrs_svcpt_has_hp()</a>, <a class="el" href="obd__support_8h_source.html#l00830">OBD_FREE_PTR</a>, <a class="el" href="lustre__nrs_8h_source.html#l00441">ptlrpc_nrs_pol_desc::pd_name</a>, <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>, <a class="el" href="lustre__nrs_8h_source.html#l00585">ptlrpc_nrs_policy::pol_list</a>, <a class="el" href="lustre__net_8h_source.html#l01821">ptlrpc_service_part::scp_nrs_hp</a>, and <a class="el" href="lustre__net_8h_source.html#l01818">ptlrpc_service_part::scp_nrs_reg</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01435">ptlrpc_service_nrs_cleanup()</a>.</p>

</div>
</div>
<a class="anchor" id="adfbbff6846bdd8aeeb06722e0e77aabc"></a><!-- doxytag: member="nrs.c::nrs_svcpt_setup_locked" ref="adfbbff6846bdd8aeeb06722e0e77aabc" args="(struct ptlrpc_service_part *svcpt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_svcpt_setup_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *&nbsp;</td>
          <td class="paramname"> <em>svcpt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a regular and optionally a high-priority NRS head (if the service handles high-priority RPCs), and then registers all available compatible policies on those NRS heads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>svcpt</em>&nbsp;</td><td>the PTLRPC service partition to setup</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>mutex_is_locked(&amp;<a class="el" href="structnrs__core.html#a1809292c09cd3a2f8ad6c1d729891231" title="Protects nrs_core::nrs_policies, serializes external policy registration/unregistration...">nrs_core.nrs_mutex</a>) </dd></dl>

<p><p>Initialize the regular NRS head.</p>
<p>Optionally allocate a high-priority NRS head.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00983">983</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00199">nrs_svcpt2nrs()</a>, <a class="el" href="nrs_8c_source.html#l00947">nrs_svcpt_setup_locked0()</a>, <a class="el" href="obd__support_8h_source.html#l00719">OBD_CPT_ALLOC_PTR</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01753">ptlrpc_service_part::scp_cpt</a>, and <a class="el" href="lustre__net_8h_source.html#l01821">ptlrpc_service_part::scp_nrs_hp</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01390">ptlrpc_service_nrs_setup()</a>.</p>

</div>
</div>
<a class="anchor" id="a8064f6a6223a2b93724fb16a58a46c59"></a><!-- doxytag: member="nrs.c::nrs_svcpt_setup_locked0" ref="a8064f6a6223a2b93724fb16a58a46c59" args="(struct ptlrpc_nrs *nrs, struct ptlrpc_service_part *svcpt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int nrs_svcpt_setup_locked0 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__nrs.html">ptlrpc_nrs</a> *&nbsp;</td>
          <td class="paramname"> <em>nrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *&nbsp;</td>
          <td class="paramname"> <em>svcpt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes NRS head <em>nrs</em> of service partition <em>svcpt</em>, and registers all compatible policies in NRS core, with the NRS head. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nrs</em>&nbsp;</td><td>the NRS head </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svcpt</em>&nbsp;</td><td>the PTLRPC service partition to setup</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>mutex_is_locked(&amp;<a class="el" href="structnrs__core.html#a1809292c09cd3a2f8ad6c1d729891231" title="Protects nrs_core::nrs_policies, serializes external policy registration/unregistration...">nrs_core.nrs_mutex</a>) </dd></dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00947">947</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="list_8h_source.html#l00048">INIT_LIST_HEAD</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="libcfs__private_8h_source.html#l00281">LBUG</a>, <a class="el" href="lustre__nrs_8h_source.html#l00324">ptlrpc_nrs::nrs_lock</a>, <a class="el" href="lustre__nrs_8h_source.html#l00329">ptlrpc_nrs::nrs_policy_list</a>, <a class="el" href="lustre__nrs_8h_source.html#l00338">ptlrpc_nrs::nrs_policy_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00354">ptlrpc_nrs::nrs_queue_type</a>, <a class="el" href="nrs_8c_source.html#l00904">nrs_register_policies_locked()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00342">ptlrpc_nrs::nrs_svcpt</a>, <a class="el" href="lustre__nrs_8h_source.html#l00379">ptlrpc_nrs::nrs_throttling</a>, <a class="el" href="lustre__nrs_8h_source.html#l00293">PTLRPC_NRS_QUEUE_HP</a>, <a class="el" href="lustre__nrs_8h_source.html#l00292">PTLRPC_NRS_QUEUE_REG</a>, <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>, <a class="el" href="lustre__net_8h_source.html#l01821">ptlrpc_service_part::scp_nrs_hp</a>, and <a class="el" href="lustre__net_8h_source.html#l01818">ptlrpc_service_part::scp_nrs_reg</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00983">nrs_svcpt_setup_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="ab94623e611d2b1ab7143fc656f8df4b3"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_fini" ref="ab94623e611d2b1ab7143fc656f8df4b3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_nrs_fini </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all policy descriptors from <a class="el" href="structnrs__core.html#a6bd6f7f96d860c488aff9d4e638d272d" title="List of all policy descriptors registered with NRS core; protected by nrs_core::nrs_mutex...">nrs_core::nrs_policies</a>, and frees the policy descriptors. </p>
<p>Since all PTLRPC services are stopped at this point, there are no more instances of any policies, because each service will have stopped its policy instances in <a class="el" href="nrs_8c.html#addde07332222429e28ec6cb0a78ca460" title="Unregisters all policies on all service partitions of service svc.">ptlrpc_service_nrs_cleanup()</a>, so we just need to free the descriptors here. </p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01836">1836</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="list_8h_source.html#l00125">list_del_init()</a>, <a class="el" href="list_8h_source.html#l00484">list_for_each_entry_safe</a>, <a class="el" href="obd__support_8h_source.html#l00830">OBD_FREE_PTR</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00445">ptlrpc_nrs_pol_desc::pd_list</a>.</p>

<p>Referenced by <a class="el" href="ptlrpc__module_8c_source.html#l00138">ptlrpc_exit()</a>, <a class="el" href="ptlrpc__module_8c_source.html#l00052">ptlrpc_init()</a>, and <a class="el" href="nrs_8c_source.html#l01787">ptlrpc_nrs_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a12a7e4c91309d6d9c9ebac14e75cfb96"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_hpreq_add_nolock" ref="a12a7e4c91309d6d9c9ebac14e75cfb96" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ptlrpc_nrs_hpreq_add_nolock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a request on the high priority NRS head. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>the request to enqueue. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00861">861</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="libcfs__debug_8h_source.html#l00138">D_NET</a>, <a class="el" href="lustre__net_8h_source.html#l01302">DEBUG_REQ</a>, <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="flock_8c_source.html#l00090">EXIT</a>, <a class="el" href="pack__generic_8c_source.html#l00989">lustre_msg_get_opc()</a>, <a class="el" href="packet-lustre_8c_source.html#l00303">OBD_PING</a>, <a class="el" href="nrs_8c_source.html#l00836">ptlrpc_nrs_req_add_nolock()</a>, <a class="el" href="lustre__net_8h_source.html#l01003">ptlrpc_request::rq_hp</a>, <a class="el" href="lustre__net_8h_source.html#l00966">ptlrpc_request::rq_lock</a>, and <a class="el" href="lustre__net_8h_source.html#l01030">ptlrpc_request::rq_reqmsg</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01524">ptlrpc_nrs_req_add()</a>, and <a class="el" href="nrs_8c_source.html#l01673">ptlrpc_nrs_req_hp_move()</a>.</p>

</div>
</div>
<a class="anchor" id="a88b6333c295cad770117c12285bc8382"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_init" ref="a88b6333c295cad770117c12285bc8382" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_nrs_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds all policies that ship with the ptlrpc module, to NRS core's list of policies <em><a class="el" href="structnrs__core.html#a6bd6f7f96d860c488aff9d4e638d272d" title="List of all policy descriptors registered with NRS core; protected by nrs_core::nrs_mutex...">nrs_core.nrs_policies</a></em>. </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>all policies have been registered successfully </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error </td></tr>
  </table>
  </dd>
</dl>

<p><p>Since no PTLRPC services have been started at this point, all we need to do for cleanup is to free the descriptors.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01787">1787</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="list_8h_source.html#l00048">INIT_LIST_HEAD</a>, <a class="el" href="nrs__fifo_8c_source.html#l00260">nrs_conf_fifo</a>, <a class="el" href="nrs_8c_source.html#l01836">ptlrpc_nrs_fini()</a>, <a class="el" href="nrs_8c_source.html#l01165">ptlrpc_nrs_policy_register()</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="ptlrpc__module_8c_source.html#l00052">ptlrpc_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a4970fb4b913c82e5566a7ecbcd8a26b7"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_policy_control" ref="a4970fb4b913c82e5566a7ecbcd8a26b7" args="(const struct ptlrpc_service *svc, enum ptlrpc_nrs_queue_type queue, char *name, enum ptlrpc_nrs_ctl opc, bool single, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_nrs_policy_control </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *&nbsp;</td>
          <td class="paramname"> <em>svc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__nrs.html#ga79e63c48a144326744316f397c52a883">ptlrpc_nrs_queue_type</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__nrs.html#gaa3db631148675f8074864fa452691540">ptlrpc_nrs_ctl</a>&nbsp;</td>
          <td class="paramname"> <em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>single</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out a control operation <em>opc</em> on the policy identified by the human-readable <em>name</em>, on either all partitions, or only on the first partition of service <em>svc</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svc</em>&nbsp;</td><td>the service the policy belongs to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queue</em>&nbsp;</td><td>whether to carry out the command on the policy which belongs to the regular, high-priority, or both NRS heads of service partitions of <em>svc</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>the policy to act upon, by human-readable name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>opc</em>&nbsp;</td><td>the opcode of the operation to carry out </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>single</em>&nbsp;</td><td>when set, the operation will only be carried out on the NRS heads of the first service partition of <em>svc</em>. This is useful for some policies which e.g. share identical values on the same parameters of different service partitions; when reading these parameters via lprocfs, these policies may just want to obtain and print out the values from the first service partition. Storing these values centrally elsewhere then could be another solution for this. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>can be used as a generic in/out buffer between control operations and the user environment.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>operation was carried out successfully </td></tr>
  </table>
  </dd>
</dl>

<p><p>XXX: We could optionally check for nrs_svc_has_hp(svc) here, and return an error if it is false. Right now we rely on the policies' lprocfs handlers that call the present function to make this check; if they fail to do so, they might hit the assertion inside <a class="el" href="ptlrpc__internal_8h.html#a12a3fc5ebcced2d0102d16c587421595">nrs_svcpt2nrs()</a> below.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01738">1738</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="flock_8c_source.html#l00061">ENTRY</a>, <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="nrs_8c_source.html#l00655">nrs_policy_ctl()</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00199">nrs_svcpt2nrs()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00052">PTLRPC_NRS_CTL_INVALID</a>, <a class="el" href="lustre__nrs_8h_source.html#l00294">PTLRPC_NRS_QUEUE_BOTH</a>, <a class="el" href="lustre__nrs_8h_source.html#l00293">PTLRPC_NRS_QUEUE_HP</a>, <a class="el" href="lustre__nrs_8h_source.html#l00292">PTLRPC_NRS_QUEUE_REG</a>, <a class="el" href="lustre__net_8h_source.html#l01857">ptlrpc_service_for_each_part</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

</div>
</div>
<a class="anchor" id="a376ea8577919ec8eb729d36195bcbf1a"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_req_add" ref="a376ea8577919ec8eb729d36195bcbf1a" args="(struct ptlrpc_service_part *svcpt, struct ptlrpc_request *req, bool hp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_nrs_req_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *&nbsp;</td>
          <td class="paramname"> <em>svcpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>hp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueues request <em>req</em> on either the regular or high-priority NRS head of service partition <em>svcpt</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svcpt</em>&nbsp;</td><td>the service partition </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>req</em>&nbsp;</td><td>the request to be enqueued </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hp</em>&nbsp;</td><td>whether to enqueue the request on the regular or high-priority NRS head. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01524">1524</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="nrs_8c_source.html#l00861">ptlrpc_nrs_hpreq_add_nolock()</a>, and <a class="el" href="nrs_8c_source.html#l00836">ptlrpc_nrs_req_add_nolock()</a>.</p>

<p>Referenced by <a class="el" href="service_8c_source.html#l01634">ptlrpc_server_request_add()</a>.</p>

</div>
</div>
<a class="anchor" id="adaa29dac38998de2d61c893c40692886"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_req_add_nolock" ref="adaa29dac38998de2d61c893c40692886" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ptlrpc_nrs_req_add_nolock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue request <em>req</em> using one of the policies its resources are referring to. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>req</em>&nbsp;</td><td>the request to enqueue. </td></tr>
  </table>
  </dd>
</dl>

<p><p>Add the policy to the NRS head's list of policies with enqueued requests, if it has not been added there.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00836">836</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="utils_2wirehdr_8c_source.html#l00044">LASSERT</a>, <a class="el" href="list_8h_source.html#l00090">list_add_tail()</a>, <a class="el" href="list_8h_source.html#l00161">list_empty()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00338">ptlrpc_nrs::nrs_policy_queued</a>, <a class="el" href="nrs_8c_source.html#l00583">nrs_request_enqueue()</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00238">nrs_request_policy()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00590">ptlrpc_nrs_policy::pol_list_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>, and <a class="el" href="libcfs__private_8h_source.html#l00310">unlikely</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l00861">ptlrpc_nrs_hpreq_add_nolock()</a>, and <a class="el" href="nrs_8c_source.html#l01524">ptlrpc_nrs_req_add()</a>.</p>

</div>
</div>
<a class="anchor" id="a7da7205147ceea7096dc6bdfe96a2d4c"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_req_del_nolock" ref="a7da7205147ceea7096dc6bdfe96a2d4c" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_nrs_req_del_nolock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dequeues request <em>req</em> from the policy it has been enqueued on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>req</em>&nbsp;</td><td>the request </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01619">1619</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="ptlrpc__internal_8h_source.html#l00238">nrs_request_policy()</a>, <a class="el" href="nrs_8c_source.html#l01537">nrs_request_removed()</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#a1eb83c9a1da21c4090e85c6711dbf6d6">ptlrpc_nrs_pol_ops::op_req_dequeue</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00626">ptlrpc_nrs_policy::pol_desc</a>.</p>

<p>Referenced by <a class="el" href="nrs_8c_source.html#l01673">ptlrpc_nrs_req_hp_move()</a>.</p>

</div>
</div>
<a class="anchor" id="aa35053963b23dd9e0dc17f6b214da481"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_req_finalize" ref="aa35053963b23dd9e0dc17f6b214da481" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_nrs_req_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases resources for a request; is called after the request has been handled. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>req</em>&nbsp;</td><td>the request</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="service_8c.html#a2d71c5442a9a62c66bd99bc984d2c8d1" title="to finish a request: stop sending more early replies, and release the request.">ptlrpc_server_finish_request()</a> </dd></dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01499">1499</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="nrs_8c_source.html#l00511">nrs_resource_put_safe()</a>.</p>

<p>Referenced by <a class="el" href="service_8c_source.html#l01013">ptlrpc_server_finish_active_request()</a>, and <a class="el" href="service_8c_source.html#l01634">ptlrpc_server_request_add()</a>.</p>

</div>
</div>
<a class="anchor" id="a54ec453671a55cf9b6012577c03eaca6"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_req_get_nolock0" ref="a54ec453671a55cf9b6012577c03eaca6" args="(struct ptlrpc_service_part *svcpt, bool hp, bool peek, bool force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a>* ptlrpc_nrs_req_get_nolock0 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *&nbsp;</td>
          <td class="paramname"> <em>svcpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>hp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>peek</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>force</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains a request for handling from an NRS head of service partition <em>svcpt</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svcpt</em>&nbsp;</td><td>the service partition </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hp</em>&nbsp;</td><td>whether to obtain a request from the regular or high-priority NRS head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peek</em>&nbsp;</td><td>when set, signifies that we just want to examine the request, and not handle it, so the request is not removed from the policy. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>when set, it will force a policy to return a request if it has one pending</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>the</em>&nbsp;</td><td>request to be handled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>the head has no requests to serve </td></tr>
  </table>
  </dd>
</dl>

<p><p>Always try to drain requests from all NRS polices even if they are inactive, because the user can change policy status at runtime.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01583">1583</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="libcfs__private_8h_source.html#l00309">likely</a>, <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, <a class="el" href="lustre__nrs_8h_source.html#l00701">ptlrpc_nrs_request::nr_started</a>, <a class="el" href="lustre__nrs_8h_source.html#l00338">ptlrpc_nrs::nrs_policy_queued</a>, <a class="el" href="lustre__nrs_8h_source.html#l00362">ptlrpc_nrs::nrs_req_started</a>, <a class="el" href="nrs_8c_source.html#l00559">nrs_request_get()</a>, <a class="el" href="nrs_8c_source.html#l01537">nrs_request_removed()</a>, <a class="el" href="ptlrpc__internal_8h_source.html#l00199">nrs_svcpt2nrs()</a>, <a class="el" href="lustre__nrs_8h_source.html#l00618">ptlrpc_nrs_policy::pol_nrs</a>, <a class="el" href="lustre__nrs_8h_source.html#l00606">ptlrpc_nrs_policy::pol_req_started</a>, and <a class="el" href="lustre__net_8h_source.html#l00939">rq_nrq</a>.</p>

<p>Referenced by <a class="el" href="ptlrpc__internal_8h_source.html#l00160">ptlrpc_nrs_req_get_nolock()</a>, and <a class="el" href="ptlrpc__internal_8h_source.html#l00167">ptlrpc_nrs_req_peek_nolock()</a>.</p>

</div>
</div>
<a class="anchor" id="a040685413af9d845199d4866c37316b8"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_req_initialize" ref="a040685413af9d845199d4866c37316b8" args="(struct ptlrpc_service_part *svcpt, struct ptlrpc_request *req, bool hp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_nrs_req_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *&nbsp;</td>
          <td class="paramname"> <em>svcpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>hp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains NRS head resources for request <em>req</em>. </p>
<p>These could be either on the regular or HP NRS head of <em>svcpt</em>; resources taken on the regular head can later be swapped for HP head resources by ldlm_lock_reorder_req().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svcpt</em>&nbsp;</td><td>the service partition </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>req</em>&nbsp;</td><td>the request </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hp</em>&nbsp;</td><td>which NRS head of <em>svcpt</em> to use </td></tr>
  </table>
  </dd>
</dl>

<p><p>It is fine to access <em>nr_initialized</em> without locking as there is no contention at this early stage.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01475">1475</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="nrs_8c_source.html#l00457">nrs_resource_get_safe()</a>, and <a class="el" href="ptlrpc__internal_8h_source.html#l00199">nrs_svcpt2nrs()</a>.</p>

<p>Referenced by <a class="el" href="service_8c_source.html#l01634">ptlrpc_server_request_add()</a>.</p>

</div>
</div>
<a class="anchor" id="acd9117d134d826c1aaed14e2e8d5f57d"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_req_pending_nolock" ref="acd9117d134d826c1aaed14e2e8d5f57d" args="(struct ptlrpc_service_part *svcpt, bool hp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ptlrpc_nrs_req_pending_nolock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *&nbsp;</td>
          <td class="paramname"> <em>svcpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>hp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether there are any requests currently enqueued on any of the policies of service partition's <em>svcpt</em> NRS head specified by <em>hp</em>. </p>
<p>Should be called while holding ptlrpc_service_part::scp_req_lock to get a reliable result.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svcpt</em>&nbsp;</td><td>the service partition to enquire. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hp</em>&nbsp;</td><td>whether the regular or high-priority NRS head is to be enquired.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>the indicated NRS head has no enqueued requests. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>the indicated NRS head has some enqueued requests. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01643">1643</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="lustre__nrs_8h_source.html#l00358">ptlrpc_nrs::nrs_req_queued</a>, and <a class="el" href="ptlrpc__internal_8h_source.html#l00199">nrs_svcpt2nrs()</a>.</p>

<p>Referenced by <a class="el" href="service_8c_source.html#l01686">ptlrpc_server_allow_high()</a>, <a class="el" href="service_8c_source.html#l01718">ptlrpc_server_high_pending()</a>, and <a class="el" href="service_8c_source.html#l01761">ptlrpc_server_normal_pending()</a>.</p>

</div>
</div>
<a class="anchor" id="a41d6af6b26aebda69530fe3537266dfd"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_req_stop_nolock" ref="a41d6af6b26aebda69530fe3537266dfd" args="(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_nrs_req_stop_nolock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01509">1509</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="nrs_8c_source.html#l00623">nrs_request_stop()</a>.</p>

<p>Referenced by <a class="el" href="service_8c_source.html#l01013">ptlrpc_server_finish_active_request()</a>.</p>

</div>
</div>
<a class="anchor" id="adca0e099406dbe4e2f80aed92e475774"></a><!-- doxytag: member="nrs.c::ptlrpc_nrs_req_throttling_nolock" ref="adca0e099406dbe4e2f80aed92e475774" args="(struct ptlrpc_service_part *svcpt, bool hp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ptlrpc_nrs_req_throttling_nolock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service__part.html">ptlrpc_service_part</a> *&nbsp;</td>
          <td class="paramname"> <em>svcpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>hp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether NRS policy is throttling reqeust. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svcpt</em>&nbsp;</td><td>the service partition to enquire. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hp</em>&nbsp;</td><td>whether the regular or high-priority NRS head is to be enquired.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>the indicated NRS head has no enqueued requests. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>the indicated NRS head has some enqueued requests. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01660">1660</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="ptlrpc__internal_8h_source.html#l00199">nrs_svcpt2nrs()</a>, and <a class="el" href="lustre__nrs_8h_source.html#l00379">ptlrpc_nrs::nrs_throttling</a>.</p>

<p>Referenced by <a class="el" href="service_8c_source.html#l01686">ptlrpc_server_allow_high()</a>, and <a class="el" href="service_8c_source.html#l01734">ptlrpc_server_allow_normal()</a>.</p>

</div>
</div>
<a class="anchor" id="addde07332222429e28ec6cb0a78ca460"></a><!-- doxytag: member="nrs.c::ptlrpc_service_nrs_cleanup" ref="addde07332222429e28ec6cb0a78ca460" args="(struct ptlrpc_service *svc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptlrpc_service_nrs_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *&nbsp;</td>
          <td class="paramname"> <em>svc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters all policies on all service partitions of service <em>svc</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svc</em>&nbsp;</td><td>the PTLRPC service to unregister </td></tr>
  </table>
  </dd>
</dl>

<p><p>Clean up NRS heads on all service partitions</p>
<p>Clean up lprocfs interfaces for all supported policies for the service.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01435">1435</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, <a class="el" href="nrs_8c_source.html#l00885">nrs_policy_compatible()</a>, <a class="el" href="nrs_8c_source.html#l01026">nrs_svcpt_cleanup_locked()</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#a4278270d8cf6849261467dd6a69bd19a">ptlrpc_nrs_pol_ops::op_lprocfs_fini</a>, <a class="el" href="lustre__nrs_8h_source.html#l00445">ptlrpc_nrs_pol_desc::pd_list</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, and <a class="el" href="lustre__net_8h_source.html#l01857">ptlrpc_service_for_each_part</a>.</p>

<p>Referenced by <a class="el" href="service_8c_source.html#l03160">ptlrpc_unregister_service()</a>.</p>

</div>
</div>
<a class="anchor" id="a107d0adae381864f5c53de6cc805a59f"></a><!-- doxytag: member="nrs.c::ptlrpc_service_nrs_setup" ref="a107d0adae381864f5c53de6cc805a59f" args="(struct ptlrpc_service *svc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptlrpc_service_nrs_setup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structptlrpc__service.html">ptlrpc_service</a> *&nbsp;</td>
          <td class="paramname"> <em>svc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup NRS heads on all service partitions of service <em>svc</em>, and register all compatible policies on those NRS heads. </p>
<p>To be called from withing ptl </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>svc</em>&nbsp;</td><td>the service to setup</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ve</em>&nbsp;</td><td>error, the calling logic should eventually call <a class="el" href="nrs_8c.html#addde07332222429e28ec6cb0a78ca460" title="Unregisters all policies on all service partitions of service svc.">ptlrpc_service_nrs_cleanup()</a> to undo any work performed by this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__net.html#ga13835bf69545de9744051ff7ef02a4c3" title="Initialize service on a given portal.">ptlrpc_register_service()</a> </dd>
<dd>
<a class="el" href="nrs_8c.html#addde07332222429e28ec6cb0a78ca460" title="Unregisters all policies on all service partitions of service svc.">ptlrpc_service_nrs_cleanup()</a> </dd></dl>

<p><p>Initialize NRS heads on all service CPTs.</p>
<p>Set up lprocfs interfaces for all supported policies for the service.</p>
</p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l01390">1390</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

<p>References <a class="el" href="small__write_8c_source.html#l00044">GOTO</a>, <a class="el" href="list_8h_source.html#l00459">list_for_each_entry</a>, <a class="el" href="nrs_8c_source.html#l00885">nrs_policy_compatible()</a>, <a class="el" href="nrs_8c_source.html#l00983">nrs_svcpt_setup_locked()</a>, <a class="el" href="structptlrpc__nrs__pol__ops.html#ad81393abaf1277b8fdebc3f67903c55a">ptlrpc_nrs_pol_ops::op_lprocfs_init</a>, <a class="el" href="lustre__nrs_8h_source.html#l00445">ptlrpc_nrs_pol_desc::pd_list</a>, <a class="el" href="lustre__nrs_8h_source.html#l00449">ptlrpc_nrs_pol_desc::pd_ops</a>, <a class="el" href="lustre__net_8h_source.html#l01857">ptlrpc_service_for_each_part</a>, and <a class="el" href="libcfs__debug_8h_source.html#l00352">RETURN</a>.</p>

<p>Referenced by <a class="el" href="service_8c_source.html#l00690">ptlrpc_register_service()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ad543d45ab909c062d714baabb15576ca"></a><!-- doxytag: member="nrs.c::nrs_core" ref="ad543d45ab909c062d714baabb15576ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnrs__core.html">nrs_core</a> <a class="el" href="structnrs__core.html">nrs_core</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NRS core object. </p>
<p>nrs </p>

<p>Definition at line <a class="el" href="nrs_8c_source.html#l00053">53</a> of file <a class="el" href="nrs_8c_source.html">nrs.c</a>.</p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:50 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
