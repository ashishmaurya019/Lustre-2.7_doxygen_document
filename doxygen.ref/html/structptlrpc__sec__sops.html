<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: ptlrpc_sec_sops Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ptlrpc_sec_sops Struct Reference<br/>
<small>
[<a class="el" href="group__sptlrpc.html">sptlrpc</a>]</small>
</h1><!-- doxytag: class="ptlrpc_sec_sops" -->
<p>server side policy operation vector.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#a2a593984c53aea5425bc29f6ede99144">accept</a> )(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">verify an incoming request.  <a href="#a2a593984c53aea5425bc29f6ede99144"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#a876a2e82cdca22048ce6521778690e83">authorize</a> )(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform security transformation upon reply message.  <a href="#a876a2e82cdca22048ce6521778690e83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#a26a206ee7e1e7782f6ebd2994ecab72b">invalidate_ctx</a> )(struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidate server context <em>ctx</em>.  <a href="#a26a206ee7e1e7782f6ebd2994ecab72b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412">alloc_rs</a> )(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int msgsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a <a class="el" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>.  <a href="#ad698da3f8f10c271ae3486521ce09412"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#a9efbc6c11a531f258abfbb66ec8d3c83">free_rs</a> )(struct <a class="el" href="structptlrpc__reply__state.html">ptlrpc_reply_state</a> *rs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a <a class="el" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>.  <a href="#a9efbc6c11a531f258abfbb66ec8d3c83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#af0088688e5488aa185de82f8c48be04c">free_ctx</a> )(struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the server context <em>ctx</em>.  <a href="#af0088688e5488aa185de82f8c48be04c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#a54b152657628c74074ae4ea4989846a3">install_rctx</a> )(struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a reverse context based on the server context <em>ctx</em>.  <a href="#a54b152657628c74074ae4ea4989846a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#a5f77240383f3487906dfdaae468168b8">prep_bulk</a> )(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare buffer for incoming bulk write.  <a href="#a5f77240383f3487906dfdaae468168b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#a56c58f3ce724e969057039fb1a0360b3">unwrap_bulk</a> )(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unwrap the bulk write data.  <a href="#a56c58f3ce724e969057039fb1a0360b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptlrpc__sec__sops.html#abbee33a52946011b640ea70e9ad75252">wrap_bulk</a> )(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrap the bulk read data.  <a href="#abbee33a52946011b640ea70e9ad75252"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>server side policy operation vector. </p>

<p>Definition at line <a class="el" href="lustre__sec_8h_source.html#l00721">721</a> of file <a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a2a593984c53aea5425bc29f6ede99144"></a><!-- doxytag: member="ptlrpc_sec_sops::accept" ref="a2a593984c53aea5425bc29f6ede99144" args=")(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__sops.html#a2a593984c53aea5425bc29f6ede99144">ptlrpc_sec_sops::accept</a>)(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>verify an incoming request. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>request message is pointed by req-&gt;rq_reqbuf, size is req-&gt;rq_reqdata_len; and the message has been unpacked to host byte order.</dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SECSVC_OK</em>&nbsp;</td><td>success, req-&gt;rq_reqmsg point to request message in clear text, size is req-&gt;rq_reqlen; req-&gt;rq_svc_ctx is set; req-&gt;rq_sp_from is decoded from request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SECSVC_COMPLETE</em>&nbsp;</td><td>success, the request has been fully processed, and reply message has been prepared; req-&gt;rq_sp_from is decoded from request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SECSVC_DROP</em>&nbsp;</td><td>failed, this request should be dropped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#a3c230271abbb26a1028bcea10ca6cad2">null_accept()</a>, <a class="el" href="sec__plain_8c.html#a8fd3434732e95212ee54af334647ba4f">plain_accept()</a>, <a class="el" href="gss__keyring_8c.html#a4e843949cb40706f83c2f8a89f48cac3">gss_svc_accept_kr()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l02070">sptlrpc_svc_unwrap_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ad698da3f8f10c271ae3486521ce09412"></a><!-- doxytag: member="ptlrpc_sec_sops::alloc_rs" ref="ad698da3f8f10c271ae3486521ce09412" args=")(struct ptlrpc_request *req, int msgsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__sops.html#ad698da3f8f10c271ae3486521ce09412">ptlrpc_sec_sops::alloc_rs</a>)(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, int msgsize)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a <a class="el" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msgsize</em>&nbsp;</td><td>size of the reply message in clear text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>if req-&gt;rq_reply_state != NULL, then it's pre-allocated, we should simply use it; otherwise we'll responsible for allocating a new one. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>req-&gt;rq_reply_state != NULL; </dd>
<dd>
req-&gt;rq_reply_state-&gt;rs_msg != NULL;</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#af5be22e80a2e944a10d94d8244f3c640">null_alloc_rs()</a>, <a class="el" href="sec__plain_8c.html#ab14c6e9d847d245142e0e941d047a671">plain_alloc_rs()</a>, <a class="el" href="gss__internal_8h.html#abd29c9ffb7d0c9cc19ca1e3b1c4a970c">gss_svc_alloc_rs()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l02130">sptlrpc_svc_alloc_rs()</a>.</p>

</div>
</div>
<a class="anchor" id="a876a2e82cdca22048ce6521778690e83"></a><!-- doxytag: member="ptlrpc_sec_sops::authorize" ref="a876a2e82cdca22048ce6521778690e83" args=")(struct ptlrpc_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__sops.html#a876a2e82cdca22048ce6521778690e83">ptlrpc_sec_sops::authorize</a>)(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform security transformation upon reply message. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>reply message is pointed by req-&gt;rq_reply_state-&gt;rs_msg, size is req-&gt;rq_replen. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>req-&gt;rs_repdata_len is the final message size. </dd>
<dd>
req-&gt;rq_reply_off is set.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__null_8c.html#a349a654176769a65894468c92763795b">null_authorize()</a>, <a class="el" href="sec__plain_8c.html#a8918787a2ff35c6ddb0625bac8e1f617">plain_authorize()</a>, <a class="el" href="gss__internal_8h.html#aa659134e6e34ca30e85dc652a408d7fc">gss_svc_authorize()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l02180">sptlrpc_svc_wrap_reply()</a>.</p>

</div>
</div>
<a class="anchor" id="af0088688e5488aa185de82f8c48be04c"></a><!-- doxytag: member="ptlrpc_sec_sops::free_ctx" ref="af0088688e5488aa185de82f8c48be04c" args=")(struct ptlrpc_svc_ctx *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__sec__sops.html#af0088688e5488aa185de82f8c48be04c">ptlrpc_sec_sops::free_ctx</a>)(struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the server context <em>ctx</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gss__internal_8h.html#a6f07334c490938a3644ceaaaeca8c1dc">gss_svc_free_ctx()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l02229">sptlrpc_svc_ctx_decref()</a>.</p>

</div>
</div>
<a class="anchor" id="a9efbc6c11a531f258abfbb66ec8d3c83"></a><!-- doxytag: member="ptlrpc_sec_sops::free_rs" ref="a9efbc6c11a531f258abfbb66ec8d3c83" args=")(struct ptlrpc_reply_state *rs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__sec__sops.html#a9efbc6c11a531f258abfbb66ec8d3c83">ptlrpc_sec_sops::free_rs</a>)(struct <a class="el" href="structptlrpc__reply__state.html">ptlrpc_reply_state</a> *rs)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a <a class="el" href="structptlrpc__reply__state.html" title="Structure to define reply state on the server Reply state holds various reply message...">ptlrpc_reply_state</a>. </p>

<p>Referenced by <a class="el" href="sec_8c_source.html#l02201">sptlrpc_svc_free_rs()</a>.</p>

</div>
</div>
<a class="anchor" id="a54b152657628c74074ae4ea4989846a3"></a><!-- doxytag: member="ptlrpc_sec_sops::install_rctx" ref="a54b152657628c74074ae4ea4989846a3" args=")(struct obd_import *imp, struct ptlrpc_svc_ctx *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__sops.html#a54b152657628c74074ae4ea4989846a3">ptlrpc_sec_sops::install_rctx</a>)(struct <a class="el" href="structobd__import.html">obd_import</a> *imp, struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install a reverse context based on the server context <em>ctx</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gss__keyring_8c.html#aebc35641628f2930e1c7c19a8fed89c6">gss_svc_install_rctx_kr()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l01759">sptlrpc_svc_install_rvs_ctx()</a>.</p>

</div>
</div>
<a class="anchor" id="a26a206ee7e1e7782f6ebd2994ecab72b"></a><!-- doxytag: member="ptlrpc_sec_sops::invalidate_ctx" ref="a26a206ee7e1e7782f6ebd2994ecab72b" args=")(struct ptlrpc_svc_ctx *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structptlrpc__sec__sops.html#a26a206ee7e1e7782f6ebd2994ecab72b">ptlrpc_sec_sops::invalidate_ctx</a>)(struct <a class="el" href="structptlrpc__svc__ctx.html">ptlrpc_svc_ctx</a> *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invalidate server context <em>ctx</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gss__internal_8h.html#a65a2fcf20b33d6a9bf89b27963ea7852">gss_svc_invalidate_ctx()</a>. </dd></dl>

<p>Referenced by <a class="el" href="sec_8c_source.html#l02244">sptlrpc_svc_ctx_invalidate()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f77240383f3487906dfdaae468168b8"></a><!-- doxytag: member="ptlrpc_sec_sops::prep_bulk" ref="a5f77240383f3487906dfdaae468168b8" args=")(struct ptlrpc_request *req, struct ptlrpc_bulk_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__sops.html#a5f77240383f3487906dfdaae468168b8">ptlrpc_sec_sops::prep_bulk</a>)(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare buffer for incoming bulk write. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>desc-&gt;bd_iov and desc-&gt;bd_iov_count describes the buffer intended to receive the write.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gss__bulk_8c.html#ab28eaefa1ab987d3ab01d040e0babfa3">gss_svc_prep_bulk()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a56c58f3ce724e969057039fb1a0360b3"></a><!-- doxytag: member="ptlrpc_sec_sops::unwrap_bulk" ref="a56c58f3ce724e969057039fb1a0360b3" args=")(struct ptlrpc_request *req, struct ptlrpc_bulk_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__sops.html#a56c58f3ce724e969057039fb1a0360b3">ptlrpc_sec_sops::unwrap_bulk</a>)(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwrap the bulk write data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__plain_8c.html#a88b3431804a6daedc3c1d6514f6701f1">plain_svc_unwrap_bulk()</a>, <a class="el" href="gss__bulk_8c.html#ad5f4894d4323e35fa6f9934bd6141e1e">gss_svc_unwrap_bulk()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abbee33a52946011b640ea70e9ad75252"></a><!-- doxytag: member="ptlrpc_sec_sops::wrap_bulk" ref="abbee33a52946011b640ea70e9ad75252" args=")(struct ptlrpc_request *req, struct ptlrpc_bulk_desc *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structptlrpc__sec__sops.html#abbee33a52946011b640ea70e9ad75252">ptlrpc_sec_sops::wrap_bulk</a>)(struct <a class="el" href="structptlrpc__request.html">ptlrpc_request</a> *req, struct <a class="el" href="structptlrpc__bulk__desc.html">ptlrpc_bulk_desc</a> *desc)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrap the bulk read data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sec__plain_8c.html#a3eb2a48b7ce309c42e80163c4655335b">plain_svc_wrap_bulk()</a>, <a class="el" href="gss__bulk_8c.html#ad475a21881c6727d0700e6e3d4548fb4">gss_svc_wrap_bulk()</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="lustre__sec_8h_source.html">lustre_sec.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:54 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
