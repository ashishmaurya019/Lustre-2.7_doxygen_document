<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Lustre: cl_page_operations Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body fgcolor="#202020">
<img src="http://wiki.lustre.org/apidoc/header.jpg">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cl_page_operations Struct Reference<br/>
<small>
[<a class="el" href="group__cl__page.html">cl_page</a>]</small>
</h1><!-- doxytag: class="cl_page_operations" -->
<p>Per-layer page operations.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl__object_8h_source.html">cl_object.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#afb6338fcddde30623c66ad280f8bff83">cpo_own</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>, int nonblock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>&lt;-&gt;struct page methods.  <a href="#afb6338fcddde30623c66ad280f8bff83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a4d11c1fa2d9422c18786f613c9221138">cpo_disown</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when ownership it yielded.  <a href="#a4d11c1fa2d9422c18786f613c9221138"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a252f84a75b3822e0d7fb071f9b7bca85">cpo_assume</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called for a page that is already "owned" by <em>io</em> from VM point of view.  <a href="#a252f84a75b3822e0d7fb071f9b7bca85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a0fa0c8be297c146cbcb8d57197f42505">cpo_unassume</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dual to <a class="el" href="structcl__page__operations.html#a252f84a75b3822e0d7fb071f9b7bca85" title="Called for a page that is already &quot;owned&quot; by io from VM point of view.">cl_page_operations::cpo_assume()</a>.  <a href="#a0fa0c8be297c146cbcb8d57197f42505"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#ad84c50cbd10e0aabbffd4c7d2fd15197">cpo_export</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, int uptodate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Announces whether the page contains valid data or not by <em>uptodate</em>.  <a href="#ad84c50cbd10e0aabbffd4c7d2fd15197"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a25940fbc8d8db64c799404461f38dbaa">cpo_is_vmlocked</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether underlying VM page is locked (in the suitable sense).  <a href="#a25940fbc8d8db64c799404461f38dbaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a56791c4e1490f9df55b3e4f6fc83c845">cpo_discard</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Page destruction.  <a href="#a56791c4e1490f9df55b3e4f6fc83c845"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a5c6692ed54cf2c677e7b8bd90b08a013">cpo_delete</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when page is removed from the cache, and is about to being destroyed.  <a href="#a5c6692ed54cf2c677e7b8bd90b08a013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#ac17fa4746c7d4698e944b3dc59514836">cpo_fini</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#ac17fa4746c7d4698e944b3dc59514836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a2ad2c255ac9556a954937b2dde91d8fe">cpo_print</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional debugging helper.  <a href="#a2ad2c255ac9556a954937b2dde91d8fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a544c974f96094f81cfb62d875f26e492">cpo_prep</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a page is submitted for a transfer as a part of <a class="el" href="structcl__page__list.html">cl_page_list</a>.  <a href="#a544c974f96094f81cfb62d875f26e492"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a10efe3c32edb23a4fb1f6b1af177bf95">cpo_completion</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, int ioret)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Completion handler.  <a href="#a10efe3c32edb23a4fb1f6b1af177bf95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#ac9f10051729d6cdc35868c30fcb81cea">cpo_make_ready</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when cached page is about to be added to the ptlrpc request as a part of req formation.  <a href="#ac9f10051729d6cdc35868c30fcb81cea"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">transfer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp84a0f3455dcca894ace136be62efa292"></a>Transfer methods. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" >struct {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;int(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__page__operations.html#a544c974f96094f81cfb62d875f26e492">cpo_prep</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when a page is submitted for a transfer as a part of <a class="el" href="structcl__page__list.html">cl_page_list</a>.  <a href="#aecdc085c9fea0cbaf67c57de5a89c818"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;void(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__page__operations.html#a10efe3c32edb23a4fb1f6b1af177bf95">cpo_completion</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, int ioret)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Completion handler.  <a href="#ac68655d528f672f29008f5ba15dad6ef"></a><br/></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;int(*&nbsp;&nbsp;&nbsp;<a class="el" href="structcl__page__operations.html#ac9f10051729d6cdc35868c30fcb81cea">cpo_make_ready</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when cached page is about to be added to the ptlrpc request as a part of req formation.  <a href="#a26d732ea16b12ae36df0c1821c77815b"></a><br/></td></tr>
<tr><td class="memItemLeft" valign="top">}&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a> [CRT_NR]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request type dependent vector of operations.  <a href="#aefbdf5f91d4f9624e213bd8c1b9cf485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#aece03986dfa3b574ef3cc06ce36a830b">cpo_clip</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, int from, int to)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell transfer engine that only [to, from] part of a page should be transmitted.  <a href="#aece03986dfa3b574ef3cc06ce36a830b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a2158a4b2c70af878b457dcb790c924f3">cpo_cancel</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl__page__operations.html#a0056ad7a02f61f50cfa8dc6362b1be44">cpo_flush</a> )(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out a page by kernel.  <a href="#a0056ad7a02f61f50cfa8dc6362b1be44"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Per-layer page operations. </p>
<p>Methods taking an <em>io</em> argument are for the activity happening in the context of given <em>io</em>. Page is assumed to be owned by that io, except for the obvious cases (like <a class="el" href="structcl__page__operations.html#afb6338fcddde30623c66ad280f8bff83" title="cl_page&lt;-&gt;struct page methods.">cl_page_operations::cpo_own()</a>).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="vvp__page_8c.html#a36e433f0b77cc5e85bbd3f604db26727">vvp_page_ops</a>, lov_page_ops, <a class="el" href="group__osc.html#gaa294766b9587b701f2a57f07f8236c94">osc_page_ops</a> </dd></dl>

<p>Definition at line <a class="el" href="cl__object_8h_source.html#l00801">801</a> of file <a class="el" href="cl__object_8h_source.html">cl_object.h</a>.</p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a252f84a75b3822e0d7fb071f9b7bca85"></a><!-- doxytag: member="cl_page_operations::cpo_assume" ref="a252f84a75b3822e0d7fb071f9b7bca85" args=")(const struct lu_env *env, const struct cl_page_slice *slice, struct cl_io *io)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__page__operations.html#a252f84a75b3822e0d7fb071f9b7bca85">cl_page_operations::cpo_assume</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called for a page that is already "owned" by <em>io</em> from VM point of view. </p>
<p>Optional.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga77a2e8592e58cc9c514cb4ac38a9d2f4" title="Assume page ownership.">cl_page_assume()</a> </dd>
<dd>
<a class="el" href="vvp__page_8c.html#a834779aaa8268a1a9214f480b9c1c432">vvp_page_assume()</a>, lov_page_assume() </dd></dl>

</div>
</div>
<a class="anchor" id="a2158a4b2c70af878b457dcb790c924f3"></a><!-- doxytag: member="cl_page_operations::cpo_cancel" ref="a2158a4b2c70af878b457dcb790c924f3" args=")(const struct lu_env *env, const struct cl_page_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__page__operations.html#a2158a4b2c70af878b457dcb790c924f3">cl_page_operations::cpo_cancel</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="pre"><dt><b>Precondition:</b></dt><dd>the page was queued for transferring. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>page is removed from client's pending list, or -EBUSY is returned if it has already been in transferring.</dd></dl>
<p>This is one of seldom page operation which is: 0. called from top level; 1. don't have vmpage locked; 2. every layer should synchronize execution of its -&gt;<a class="el" href="structcl__page__operations.html#a2158a4b2c70af878b457dcb790c924f3">cpo_cancel()</a> with completion handlers. Osc uses client obd lock for this purpose. Based on there is no vvp_page_cancel and lov_page_cancel(), cpo_cancel is defacto protected by client lock.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__osc.html#ga5bcdf3c9bd3b0482012b4554a08c901d">osc_page_cancel()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aece03986dfa3b574ef3cc06ce36a830b"></a><!-- doxytag: member="cl_page_operations::cpo_clip" ref="aece03986dfa3b574ef3cc06ce36a830b" args=")(const struct lu_env *env, const struct cl_page_slice *slice, int from, int to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__page__operations.html#aece03986dfa3b574ef3cc06ce36a830b">cl_page_operations::cpo_clip</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, int from, int to)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell transfer engine that only [to, from] part of a page should be transmitted. </p>
<p>This is used for immediate transfers.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>XXX this is not very good interface. It would be much better if all transfer parameters were supplied as arguments to <a class="el" href="structcl__io__operations.html#a2aa87d92a0f183a26ae076afc9b8b74f" title="Submit pages from queue-&gt;c2_qin for IO, and move successfully submitted pages...">cl_io_operations::cio_submit()</a> call, but it is not clear how to do this for page queues.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga2218cff8efc343a14d1c312f64e15e1f" title="Tells transfer engine that only part of a page is to be transmitted.">cl_page_clip()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10efe3c32edb23a4fb1f6b1af177bf95"></a><!-- doxytag: member="cl_page_operations::cpo_completion" ref="a10efe3c32edb23a4fb1f6b1af177bf95" args=")(const struct lu_env *env, const struct cl_page_slice *slice, int ioret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__page__operations.html#a10efe3c32edb23a4fb1f6b1af177bf95">cl_page_operations::cpo_completion</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, int ioret)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Completion handler. </p>
<p>This is guaranteed to be eventually fired after <a class="el" href="structcl__page__operations.html#a544c974f96094f81cfb62d875f26e492" title="Called when a page is submitted for a transfer as a part of cl_page_list.">cl_page_operations::cpo_prep()</a> or <a class="el" href="structcl__page__operations.html#ac9f10051729d6cdc35868c30fcb81cea" title="Called when cached page is about to be added to the ptlrpc request as a part of req...">cl_page_operations::cpo_make_ready()</a> call.</p>
<p>This method can be called in a non-blocking context. It is guaranteed however, that the page involved and its object are pinned in memory (and, hence, calling <a class="el" href="group__cl__page.html#ga1dc4205fd892e559c96ce97aad4eebf1" title="Releases a reference to a page.">cl_page_put()</a> is safe).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga778ad6a1a849ef9701db714913c879ec" title="Notify layers about transfer completion.">cl_page_completion()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c6692ed54cf2c677e7b8bd90b08a013"></a><!-- doxytag: member="cl_page_operations::cpo_delete" ref="a5c6692ed54cf2c677e7b8bd90b08a013" args=")(const struct lu_env *env, const struct cl_page_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__page__operations.html#a5c6692ed54cf2c677e7b8bd90b08a013">cl_page_operations::cpo_delete</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when page is removed from the cache, and is about to being destroyed. </p>
<p>Optional.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga55a51f6efaa6effc3b5b3d045d4ee432" title="Called when a decision is made to throw page out of memory.">cl_page_delete()</a> </dd>
<dd>
<a class="el" href="vvp__page_8c.html#afb02305a2c215477ae5520c9cf991531">vvp_page_delete()</a>, <a class="el" href="group__osc.html#ga44b16168cf595ce24f67e0ff359f7a2d">osc_page_delete()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a56791c4e1490f9df55b3e4f6fc83c845"></a><!-- doxytag: member="cl_page_operations::cpo_discard" ref="a56791c4e1490f9df55b3e4f6fc83c845" args=")(const struct lu_env *env, const struct cl_page_slice *slice, struct cl_io *io)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__page__operations.html#a56791c4e1490f9df55b3e4f6fc83c845">cl_page_operations::cpo_discard</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Page destruction. </p>
<p>Called when page is truncated from the object. Optional.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga775efaa18bd22d404f7588fd35f6cd03" title="Called when page is to be removed from the object, e.g., as a result of truncate...">cl_page_discard()</a> </dd>
<dd>
<a class="el" href="vvp__page_8c.html#ac16ccee12a084e9cc157faee436bf9bb">vvp_page_discard()</a>, osc_page_discard() </dd></dl>

</div>
</div>
<a class="anchor" id="a4d11c1fa2d9422c18786f613c9221138"></a><!-- doxytag: member="cl_page_operations::cpo_disown" ref="a4d11c1fa2d9422c18786f613c9221138" args=")(const struct lu_env *env, const struct cl_page_slice *slice, struct cl_io *io)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__page__operations.html#a4d11c1fa2d9422c18786f613c9221138">cl_page_operations::cpo_disown</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when ownership it yielded. </p>
<p>Optional.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#gae41a4c98faae723b2566a721b6e4b7fb" title="Releases page ownership.">cl_page_disown()</a> </dd>
<dd>
<a class="el" href="vvp__page_8c.html#a52c7a56f26bf98e8d5391a57c2bc6a40">vvp_page_disown()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad84c50cbd10e0aabbffd4c7d2fd15197"></a><!-- doxytag: member="cl_page_operations::cpo_export" ref="ad84c50cbd10e0aabbffd4c7d2fd15197" args=")(const struct lu_env *env, const struct cl_page_slice *slice, int uptodate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__page__operations.html#ad84c50cbd10e0aabbffd4c7d2fd15197">cl_page_operations::cpo_export</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, int uptodate)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Announces whether the page contains valid data or not by <em>uptodate</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#gafacf1187afd6e200c6f8d59539baf50c" title="Marks page up-to-date.">cl_page_export()</a> </dd>
<dd>
<a class="el" href="vvp__page_8c.html#af58aa6786d18d521fae5d6ea9b52fd44">vvp_page_export()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac17fa4746c7d4698e944b3dc59514836"></a><!-- doxytag: member="cl_page_operations::cpo_fini" ref="ac17fa4746c7d4698e944b3dc59514836" args=")(const struct lu_env *env, struct cl_page_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__page__operations.html#ac17fa4746c7d4698e944b3dc59514836">cl_page_operations::cpo_fini</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Frees resources and slice itself. </p>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00133">cl_page_free()</a>.</p>

</div>
</div>
<a class="anchor" id="a0056ad7a02f61f50cfa8dc6362b1be44"></a><!-- doxytag: member="cl_page_operations::cpo_flush" ref="a0056ad7a02f61f50cfa8dc6362b1be44" args=")(const struct lu_env *env, const struct cl_page_slice *slice, struct cl_io *io)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__page__operations.html#a0056ad7a02f61f50cfa8dc6362b1be44">cl_page_operations::cpo_flush</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out a page by kernel. </p>
<p>This is only called by ll_writepage right now.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga0616bcd8605ed9a75e799f64bcdd5a2d" title="Called if a pge is being written back by kernel&#39;s intention.">cl_page_flush()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a25940fbc8d8db64c799404461f38dbaa"></a><!-- doxytag: member="cl_page_operations::cpo_is_vmlocked" ref="a25940fbc8d8db64c799404461f38dbaa" args=")(const struct lu_env *env, const struct cl_page_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__page__operations.html#a25940fbc8d8db64c799404461f38dbaa">cl_page_operations::cpo_is_vmlocked</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether underlying VM page is locked (in the suitable sense). </p>
<p>Used for assertions.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EBUSY,:</em>&nbsp;</td><td>page is protected by a lock of a given mode; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENODATA,:</em>&nbsp;</td><td>page is not protected by a lock; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0,:</em>&nbsp;</td><td>this layer cannot decide. (Should never happen.) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="cl__page_8c_source.html#l00821">cl_page_is_vmlocked()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9f10051729d6cdc35868c30fcb81cea"></a><!-- doxytag: member="cl_page_operations::cpo_make_ready" ref="ac9f10051729d6cdc35868c30fcb81cea" args=")(const struct lu_env *env, const struct cl_page_slice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__page__operations.html#ac9f10051729d6cdc35868c30fcb81cea">cl_page_operations::cpo_make_ready</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when cached page is about to be added to the ptlrpc request as a part of req formation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 : proceed with this page; </dd>
<dd>
-EAGAIN : skip this page; </dd>
<dd>
-ve : error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga864bcec4bff9dd1f988f928348c08796" title="Notify layers that transfer formation engine decided to yank this page from the cache...">cl_page_make_ready()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afb6338fcddde30623c66ad280f8bff83"></a><!-- doxytag: member="cl_page_operations::cpo_own" ref="afb6338fcddde30623c66ad280f8bff83" args=")(const struct lu_env *env, const struct cl_page_slice *slice, struct cl_io *io, int nonblock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__page__operations.html#afb6338fcddde30623c66ad280f8bff83">cl_page_operations::cpo_own</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>, int nonblock)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="structcl__page.html" title="Fields are protected by the lock on struct page, except for atomics and immutables...">cl_page</a>&lt;-&gt;struct page methods. </p>
<p>Only one layer in the stack has to implement these. Current code assumes that this functionality is provided by the topmost layer, see <a class="el" href="cl__internal_8h.html#aa893212191da3dac2561960974965726">cl_page_disown0()</a> as an example. Called when <em>io</em> acquires this page into the exclusive ownership. When this method returns, it is guaranteed that the is not owned by other io, and no transfer is going on against it. Optional.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga2f91322039a4254d13f6e0a668e5746a" title="Own a page, might be blocked.">cl_page_own()</a> </dd>
<dd>
<a class="el" href="vvp__page_8c.html#a6af1e468fe270ee2cc37ad69bce89e69">vvp_page_own()</a>, lov_page_own() </dd></dl>

</div>
</div>
<a class="anchor" id="a544c974f96094f81cfb62d875f26e492"></a><!-- doxytag: member="cl_page_operations::cpo_prep" ref="a544c974f96094f81cfb62d875f26e492" args=")(const struct lu_env *env, const struct cl_page_slice *slice, struct cl_io *io)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__page__operations.html#a544c974f96094f81cfb62d875f26e492">cl_page_operations::cpo_prep</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when a page is submitted for a transfer as a part of <a class="el" href="structcl__page__list.html">cl_page_list</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 : page is eligible for submission; </dd>
<dd>
-EALREADY : skip this page; </dd>
<dd>
-ve : error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga8216a843e48aa6d45d049b6aacb13744" title="Prepares page for immediate transfer.">cl_page_prep()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ad2c255ac9556a954937b2dde91d8fe"></a><!-- doxytag: member="cl_page_operations::cpo_print" ref="a2ad2c255ac9556a954937b2dde91d8fe" args=")(const struct lu_env *env, const struct cl_page_slice *slice, void *cookie, lu_printer_t p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structcl__page__operations.html#a2ad2c255ac9556a954937b2dde91d8fe">cl_page_operations::cpo_print</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, void *cookie, <a class="el" href="group__lu.html#gac8ccca21472f6dc3ea91d73983740fdc">lu_printer_t</a> p)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optional debugging helper. </p>
<p>Prints given page slice.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga8c8a48c83e51dbc9dd7a79933c1133d2" title="Prints human readable representation of pg to the f.">cl_page_print()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0fa0c8be297c146cbcb8d57197f42505"></a><!-- doxytag: member="cl_page_operations::cpo_unassume" ref="a0fa0c8be297c146cbcb8d57197f42505" args=")(const struct lu_env *env, const struct cl_page_slice *slice, struct cl_io *io)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structcl__page__operations.html#a0fa0c8be297c146cbcb8d57197f42505">cl_page_operations::cpo_unassume</a>)(const struct <a class="el" href="structlu__env.html">lu_env</a> *env, const struct <a class="el" href="structcl__page__slice.html">cl_page_slice</a> *slice, struct <a class="el" href="structcl__io.html">cl_io</a> *<a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">io</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dual to <a class="el" href="structcl__page__operations.html#a252f84a75b3822e0d7fb071f9b7bca85" title="Called for a page that is already &quot;owned&quot; by io from VM point of view.">cl_page_operations::cpo_assume()</a>. </p>
<p>Optional. Called bottom-to-top when IO releases a page without actually unlocking it.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cl__page.html#ga4e7db1845b76bea8277b4e3d2a482f61" title="Releases page ownership without unlocking the page.">cl_page_unassume()</a> </dd>
<dd>
<a class="el" href="vvp__page_8c.html#aedf0e0d2269f65c87dfabb1b293416ed">vvp_page_unassume()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aefbdf5f91d4f9624e213bd8c1b9cf485"></a><!-- doxytag: member="cl_page_operations::io" ref="aefbdf5f91d4f9624e213bd8c1b9cf485" args="[CRT_NR]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   <a class="el" href="structcl__page__operations.html#aefbdf5f91d4f9624e213bd8c1b9cf485">cl_page_operations::io</a>[CRT_NR]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request type dependent vector of operations. </p>
<p>Transfer operations depend on transfer mode (cl_req_type). To avoid passing transfer mode to each and every of these methods, and to avoid branching on request type inside of the methods, separate methods for cl_req_type:CRT_READ and cl_req_type:CRT_WRITE are provided. That is, method invocation usually looks like</p>
<p>slice-&gt;cp_ops.io[req-&gt;crq_type].cpo_method(env, slice, ...); </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lustre/include/<a class="el" href="cl__object_8h_source.html">cl_object.h</a></li>
</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Sun Jun 5 20:54:52 2016 for Lustre by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.1</small></address><br>
<small><a href="http://www.sun.com/contact">Contact</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/index.html">About Sun</a>&nbsp;|&nbsp;<a href="http://www.sun.com/aboutsun/media/index.html">News</a>&nbsp;|&nbsp;<a href="http://www.sun.com/corp_emp/">Employment</a>&nbsp;|&nbsp;<a href="http://www.sun.com/privacy/">Privacy</a>&nbsp;|&nbsp;<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>&nbsp;|&nbsp;<a href="http://www.sun.com/suntrademarks/">Trademarks</a>&nbsp;|&nbsp;(C) 2008 Sun Microsystems, Inc.</small>
</body>
</html>
